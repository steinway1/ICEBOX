(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/**
 * @popperjs/core v2.11.8 - MIT License
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

var max = Math.max;
var min = Math.min;
var round = Math.round;

function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = isElement(element) ? getWindow(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

function getVariation(placement) {
  return placement.split('-')[1];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
            _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            effect = _ref.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var passive = {
  passive: true
};

function effect$2(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect$2,
  data: {}
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
      y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, getWindow(popper)) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$1(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$1,
  requires: ['computeStyles']
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}

var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = offset + overflow[mainSide];
    var max$1 = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper$1 = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers$1
}); // eslint-disable-next-line import/no-unused-modules

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

exports.applyStyles = applyStyles$1;
exports.arrow = arrow$1;
exports.computeStyles = computeStyles$1;
exports.createPopper = createPopper;
exports.createPopperLite = createPopper$1;
exports.defaultModifiers = defaultModifiers;
exports.detectOverflow = detectOverflow;
exports.eventListeners = eventListeners;
exports.flip = flip$1;
exports.hide = hide$1;
exports.offset = offset$1;
exports.popperGenerator = popperGenerator;
exports.popperOffsets = popperOffsets$1;
exports.preventOverflow = preventOverflow$1;


},{}],2:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{}],3:[function(require,module,exports){
// ==================================================
// fancyBox v3.5.7
//
// Licensed GPLv3 for open source use
// or fancyBox Commercial License for commercial use
//
// http://fancyapps.com/fancybox/
// Copyright 2019 fancyApps
//
// ==================================================
!function(t,e,n,o){"use strict";function i(t,e){var o,i,a,s=[],r=0;t&&t.isDefaultPrevented()||(t.preventDefault(),e=e||{},t&&t.data&&(e=h(t.data.options,e)),o=e.$target||n(t.currentTarget).trigger("blur"),(a=n.fancybox.getInstance())&&a.$trigger&&a.$trigger.is(o)||(e.selector?s=n(e.selector):(i=o.attr("data-fancybox")||"",i?(s=t.data?t.data.items:[],s=s.length?s.filter('[data-fancybox="'+i+'"]'):n('[data-fancybox="'+i+'"]')):s=[o]),r=n(s).index(o),r<0&&(r=0),a=n.fancybox.open(s,e,r),a.$trigger=o))}if(t.console=t.console||{info:function(t){}},n){if(n.fn.fancybox)return void console.info("fancyBox already initialized");var a={closeExisting:!1,loop:!1,gutter:50,keyboard:!0,preventCaptionOverlap:!0,arrows:!0,infobar:!0,smallBtn:"auto",toolbar:"auto",buttons:["zoom","slideShow","thumbs","close"],idleTime:3,protect:!1,modal:!1,image:{preload:!1},ajax:{settings:{data:{fancybox:!0}}},iframe:{tpl:'<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" allowfullscreen="allowfullscreen" allow="autoplay; fullscreen" src=""></iframe>',preload:!0,css:{},attr:{scrolling:"auto"}},video:{tpl:'<video class="fancybox-video" controls controlsList="nodownload" poster="{{poster}}"><source src="{{src}}" type="{{format}}" />Sorry, your browser doesn\'t support embedded videos, <a href="{{src}}">download</a> and watch with your favorite video player!</video>',format:"",autoStart:!0},defaultType:"image",animationEffect:"zoom",animationDuration:366,zoomOpacity:"auto",transitionEffect:"fade",transitionDuration:366,slideClass:"",baseClass:"",baseTpl:'<div class="fancybox-container" role="dialog" tabindex="-1"><div class="fancybox-bg"></div><div class="fancybox-inner"><div class="fancybox-infobar"><span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span></div><div class="fancybox-toolbar">{{buttons}}</div><div class="fancybox-navigation">{{arrows}}</div><div class="fancybox-stage"></div><div class="fancybox-caption"><div class="fancybox-caption__body"></div></div></div></div>',spinnerTpl:'<div class="fancybox-loading"></div>',errorTpl:'<div class="fancybox-error"><p>{{ERROR}}</p></div>',btnTpl:{download:'<a download data-fancybox-download class="fancybox-button fancybox-button--download" title="{{DOWNLOAD}}" href="javascript:;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.62 17.09V19H5.38v-1.91zm-2.97-6.96L17 11.45l-5 4.87-5-4.87 1.36-1.32 2.68 2.64V5h1.92v7.77z"/></svg></a>',zoom:'<button data-fancybox-zoom class="fancybox-button fancybox-button--zoom" title="{{ZOOM}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.7 17.3l-3-3a5.9 5.9 0 0 0-.6-7.6 5.9 5.9 0 0 0-8.4 0 5.9 5.9 0 0 0 0 8.4 5.9 5.9 0 0 0 7.7.7l3 3a1 1 0 0 0 1.3 0c.4-.5.4-1 0-1.5zM8.1 13.8a4 4 0 0 1 0-5.7 4 4 0 0 1 5.7 0 4 4 0 0 1 0 5.7 4 4 0 0 1-5.7 0z"/></svg></button>',close:'<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 10.6L6.6 5.2 5.2 6.6l5.4 5.4-5.4 5.4 1.4 1.4 5.4-5.4 5.4 5.4 1.4-1.4-5.4-5.4 5.4-5.4-1.4-1.4-5.4 5.4z"/></svg></button>',arrowLeft:'<button data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}"><div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.28 15.7l-1.34 1.37L5 12l4.94-5.07 1.34 1.38-2.68 2.72H19v1.94H8.6z"/></svg></div></button>',arrowRight:'<button data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}"><div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.4 12.97l-2.68 2.72 1.34 1.38L19 12l-4.94-5.07-1.34 1.38 2.68 2.72H5v1.94z"/></svg></div></button>',smallBtn:'<button type="button" data-fancybox-close class="fancybox-button fancybox-close-small" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 24 24"><path d="M13 12l5-5-1-1-5 5-5-5-1 1 5 5-5 5 1 1 5-5 5 5 1-1z"/></svg></button>'},parentEl:"body",hideScrollbar:!0,autoFocus:!0,backFocus:!0,trapFocus:!0,fullScreen:{autoStart:!1},touch:{vertical:!0,momentum:!0},hash:null,media:{},slideShow:{autoStart:!1,speed:3e3},thumbs:{autoStart:!1,hideOnClose:!0,parentEl:".fancybox-container",axis:"y"},wheel:"auto",onInit:n.noop,beforeLoad:n.noop,afterLoad:n.noop,beforeShow:n.noop,afterShow:n.noop,beforeClose:n.noop,afterClose:n.noop,onActivate:n.noop,onDeactivate:n.noop,clickContent:function(t,e){return"image"===t.type&&"zoom"},clickSlide:"close",clickOutside:"close",dblclickContent:!1,dblclickSlide:!1,dblclickOutside:!1,mobile:{preventCaptionOverlap:!1,idleTime:!1,clickContent:function(t,e){return"image"===t.type&&"toggleControls"},clickSlide:function(t,e){return"image"===t.type?"toggleControls":"close"},dblclickContent:function(t,e){return"image"===t.type&&"zoom"},dblclickSlide:function(t,e){return"image"===t.type&&"zoom"}},lang:"en",i18n:{en:{CLOSE:"Close",NEXT:"Next",PREV:"Previous",ERROR:"The requested content cannot be loaded. <br/> Please try again later.",PLAY_START:"Start slideshow",PLAY_STOP:"Pause slideshow",FULL_SCREEN:"Full screen",THUMBS:"Thumbnails",DOWNLOAD:"Download",SHARE:"Share",ZOOM:"Zoom"},de:{CLOSE:"Schlie&szlig;en",NEXT:"Weiter",PREV:"Zur&uuml;ck",ERROR:"Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es sp&auml;ter nochmal.",PLAY_START:"Diaschau starten",PLAY_STOP:"Diaschau beenden",FULL_SCREEN:"Vollbild",THUMBS:"Vorschaubilder",DOWNLOAD:"Herunterladen",SHARE:"Teilen",ZOOM:"Vergr&ouml;&szlig;ern"}}},s=n(t),r=n(e),c=0,l=function(t){return t&&t.hasOwnProperty&&t instanceof n},d=function(){return t.requestAnimationFrame||t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||t.oRequestAnimationFrame||function(e){return t.setTimeout(e,1e3/60)}}(),u=function(){return t.cancelAnimationFrame||t.webkitCancelAnimationFrame||t.mozCancelAnimationFrame||t.oCancelAnimationFrame||function(e){t.clearTimeout(e)}}(),f=function(){var t,n=e.createElement("fakeelement"),o={transition:"transitionend",OTransition:"oTransitionEnd",MozTransition:"transitionend",WebkitTransition:"webkitTransitionEnd"};for(t in o)if(void 0!==n.style[t])return o[t];return"transitionend"}(),p=function(t){return t&&t.length&&t[0].offsetHeight},h=function(t,e){var o=n.extend(!0,{},t,e);return n.each(e,function(t,e){n.isArray(e)&&(o[t]=e)}),o},g=function(t){var o,i;return!(!t||t.ownerDocument!==e)&&(n(".fancybox-container").css("pointer-events","none"),o={x:t.getBoundingClientRect().left+t.offsetWidth/2,y:t.getBoundingClientRect().top+t.offsetHeight/2},i=e.elementFromPoint(o.x,o.y)===t,n(".fancybox-container").css("pointer-events",""),i)},b=function(t,e,o){var i=this;i.opts=h({index:o},n.fancybox.defaults),n.isPlainObject(e)&&(i.opts=h(i.opts,e)),n.fancybox.isMobile&&(i.opts=h(i.opts,i.opts.mobile)),i.id=i.opts.id||++c,i.currIndex=parseInt(i.opts.index,10)||0,i.prevIndex=null,i.prevPos=null,i.currPos=0,i.firstRun=!0,i.group=[],i.slides={},i.addContent(t),i.group.length&&i.init()};n.extend(b.prototype,{init:function(){var o,i,a=this,s=a.group[a.currIndex],r=s.opts;r.closeExisting&&n.fancybox.close(!0),n("body").addClass("fancybox-active"),!n.fancybox.getInstance()&&!1!==r.hideScrollbar&&!n.fancybox.isMobile&&e.body.scrollHeight>t.innerHeight&&(n("head").append('<style id="fancybox-style-noscroll" type="text/css">.compensate-for-scrollbar{margin-right:'+(t.innerWidth-e.documentElement.clientWidth)+"px;}</style>"),n("body").addClass("compensate-for-scrollbar")),i="",n.each(r.buttons,function(t,e){i+=r.btnTpl[e]||""}),o=n(a.translate(a,r.baseTpl.replace("{{buttons}}",i).replace("{{arrows}}",r.btnTpl.arrowLeft+r.btnTpl.arrowRight))).attr("id","fancybox-container-"+a.id).addClass(r.baseClass).data("FancyBox",a).appendTo(r.parentEl),a.$refs={container:o},["bg","inner","infobar","toolbar","stage","caption","navigation"].forEach(function(t){a.$refs[t]=o.find(".fancybox-"+t)}),a.trigger("onInit"),a.activate(),a.jumpTo(a.currIndex)},translate:function(t,e){var n=t.opts.i18n[t.opts.lang]||t.opts.i18n.en;return e.replace(/\{\{(\w+)\}\}/g,function(t,e){return void 0===n[e]?t:n[e]})},addContent:function(t){var e,o=this,i=n.makeArray(t);n.each(i,function(t,e){var i,a,s,r,c,l={},d={};n.isPlainObject(e)?(l=e,d=e.opts||e):"object"===n.type(e)&&n(e).length?(i=n(e),d=i.data()||{},d=n.extend(!0,{},d,d.options),d.$orig=i,l.src=o.opts.src||d.src||i.attr("href"),l.type||l.src||(l.type="inline",l.src=e)):l={type:"html",src:e+""},l.opts=n.extend(!0,{},o.opts,d),n.isArray(d.buttons)&&(l.opts.buttons=d.buttons),n.fancybox.isMobile&&l.opts.mobile&&(l.opts=h(l.opts,l.opts.mobile)),a=l.type||l.opts.type,r=l.src||"",!a&&r&&((s=r.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i))?(a="video",l.opts.video.format||(l.opts.video.format="video/"+("ogv"===s[1]?"ogg":s[1]))):r.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)?a="image":r.match(/\.(pdf)((\?|#).*)?$/i)?(a="iframe",l=n.extend(!0,l,{contentType:"pdf",opts:{iframe:{preload:!1}}})):"#"===r.charAt(0)&&(a="inline")),a?l.type=a:o.trigger("objectNeedsType",l),l.contentType||(l.contentType=n.inArray(l.type,["html","inline","ajax"])>-1?"html":l.type),l.index=o.group.length,"auto"==l.opts.smallBtn&&(l.opts.smallBtn=n.inArray(l.type,["html","inline","ajax"])>-1),"auto"===l.opts.toolbar&&(l.opts.toolbar=!l.opts.smallBtn),l.$thumb=l.opts.$thumb||null,l.opts.$trigger&&l.index===o.opts.index&&(l.$thumb=l.opts.$trigger.find("img:first"),l.$thumb.length&&(l.opts.$orig=l.opts.$trigger)),l.$thumb&&l.$thumb.length||!l.opts.$orig||(l.$thumb=l.opts.$orig.find("img:first")),l.$thumb&&!l.$thumb.length&&(l.$thumb=null),l.thumb=l.opts.thumb||(l.$thumb?l.$thumb[0].src:null),"function"===n.type(l.opts.caption)&&(l.opts.caption=l.opts.caption.apply(e,[o,l])),"function"===n.type(o.opts.caption)&&(l.opts.caption=o.opts.caption.apply(e,[o,l])),l.opts.caption instanceof n||(l.opts.caption=void 0===l.opts.caption?"":l.opts.caption+""),"ajax"===l.type&&(c=r.split(/\s+/,2),c.length>1&&(l.src=c.shift(),l.opts.filter=c.shift())),l.opts.modal&&(l.opts=n.extend(!0,l.opts,{trapFocus:!0,infobar:0,toolbar:0,smallBtn:0,keyboard:0,slideShow:0,fullScreen:0,thumbs:0,touch:0,clickContent:!1,clickSlide:!1,clickOutside:!1,dblclickContent:!1,dblclickSlide:!1,dblclickOutside:!1})),o.group.push(l)}),Object.keys(o.slides).length&&(o.updateControls(),(e=o.Thumbs)&&e.isActive&&(e.create(),e.focus()))},addEvents:function(){var e=this;e.removeEvents(),e.$refs.container.on("click.fb-close","[data-fancybox-close]",function(t){t.stopPropagation(),t.preventDefault(),e.close(t)}).on("touchstart.fb-prev click.fb-prev","[data-fancybox-prev]",function(t){t.stopPropagation(),t.preventDefault(),e.previous()}).on("touchstart.fb-next click.fb-next","[data-fancybox-next]",function(t){t.stopPropagation(),t.preventDefault(),e.next()}).on("click.fb","[data-fancybox-zoom]",function(t){e[e.isScaledDown()?"scaleToActual":"scaleToFit"]()}),s.on("orientationchange.fb resize.fb",function(t){t&&t.originalEvent&&"resize"===t.originalEvent.type?(e.requestId&&u(e.requestId),e.requestId=d(function(){e.update(t)})):(e.current&&"iframe"===e.current.type&&e.$refs.stage.hide(),setTimeout(function(){e.$refs.stage.show(),e.update(t)},n.fancybox.isMobile?600:250))}),r.on("keydown.fb",function(t){var o=n.fancybox?n.fancybox.getInstance():null,i=o.current,a=t.keyCode||t.which;if(9==a)return void(i.opts.trapFocus&&e.focus(t));if(!(!i.opts.keyboard||t.ctrlKey||t.altKey||t.shiftKey||n(t.target).is("input,textarea,video,audio,select")))return 8===a||27===a?(t.preventDefault(),void e.close(t)):37===a||38===a?(t.preventDefault(),void e.previous()):39===a||40===a?(t.preventDefault(),void e.next()):void e.trigger("afterKeydown",t,a)}),e.group[e.currIndex].opts.idleTime&&(e.idleSecondsCounter=0,r.on("mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle",function(t){e.idleSecondsCounter=0,e.isIdle&&e.showControls(),e.isIdle=!1}),e.idleInterval=t.setInterval(function(){++e.idleSecondsCounter>=e.group[e.currIndex].opts.idleTime&&!e.isDragging&&(e.isIdle=!0,e.idleSecondsCounter=0,e.hideControls())},1e3))},removeEvents:function(){var e=this;s.off("orientationchange.fb resize.fb"),r.off("keydown.fb .fb-idle"),this.$refs.container.off(".fb-close .fb-prev .fb-next"),e.idleInterval&&(t.clearInterval(e.idleInterval),e.idleInterval=null)},previous:function(t){return this.jumpTo(this.currPos-1,t)},next:function(t){return this.jumpTo(this.currPos+1,t)},jumpTo:function(t,e){var o,i,a,s,r,c,l,d,u,f=this,h=f.group.length;if(!(f.isDragging||f.isClosing||f.isAnimating&&f.firstRun)){if(t=parseInt(t,10),!(a=f.current?f.current.opts.loop:f.opts.loop)&&(t<0||t>=h))return!1;if(o=f.firstRun=!Object.keys(f.slides).length,r=f.current,f.prevIndex=f.currIndex,f.prevPos=f.currPos,s=f.createSlide(t),h>1&&((a||s.index<h-1)&&f.createSlide(t+1),(a||s.index>0)&&f.createSlide(t-1)),f.current=s,f.currIndex=s.index,f.currPos=s.pos,f.trigger("beforeShow",o),f.updateControls(),s.forcedDuration=void 0,n.isNumeric(e)?s.forcedDuration=e:e=s.opts[o?"animationDuration":"transitionDuration"],e=parseInt(e,10),i=f.isMoved(s),s.$slide.addClass("fancybox-slide--current"),o)return s.opts.animationEffect&&e&&f.$refs.container.css("transition-duration",e+"ms"),f.$refs.container.addClass("fancybox-is-open").trigger("focus"),f.loadSlide(s),void f.preload("image");c=n.fancybox.getTranslate(r.$slide),l=n.fancybox.getTranslate(f.$refs.stage),n.each(f.slides,function(t,e){n.fancybox.stop(e.$slide,!0)}),r.pos!==s.pos&&(r.isComplete=!1),r.$slide.removeClass("fancybox-slide--complete fancybox-slide--current"),i?(u=c.left-(r.pos*c.width+r.pos*r.opts.gutter),n.each(f.slides,function(t,o){o.$slide.removeClass("fancybox-animated").removeClass(function(t,e){return(e.match(/(^|\s)fancybox-fx-\S+/g)||[]).join(" ")});var i=o.pos*c.width+o.pos*o.opts.gutter;n.fancybox.setTranslate(o.$slide,{top:0,left:i-l.left+u}),o.pos!==s.pos&&o.$slide.addClass("fancybox-slide--"+(o.pos>s.pos?"next":"previous")),p(o.$slide),n.fancybox.animate(o.$slide,{top:0,left:(o.pos-s.pos)*c.width+(o.pos-s.pos)*o.opts.gutter},e,function(){o.$slide.css({transform:"",opacity:""}).removeClass("fancybox-slide--next fancybox-slide--previous"),o.pos===f.currPos&&f.complete()})})):e&&s.opts.transitionEffect&&(d="fancybox-animated fancybox-fx-"+s.opts.transitionEffect,r.$slide.addClass("fancybox-slide--"+(r.pos>s.pos?"next":"previous")),n.fancybox.animate(r.$slide,d,e,function(){r.$slide.removeClass(d).removeClass("fancybox-slide--next fancybox-slide--previous")},!1)),s.isLoaded?f.revealContent(s):f.loadSlide(s),f.preload("image")}},createSlide:function(t){var e,o,i=this;return o=t%i.group.length,o=o<0?i.group.length+o:o,!i.slides[t]&&i.group[o]&&(e=n('<div class="fancybox-slide"></div>').appendTo(i.$refs.stage),i.slides[t]=n.extend(!0,{},i.group[o],{pos:t,$slide:e,isLoaded:!1}),i.updateSlide(i.slides[t])),i.slides[t]},scaleToActual:function(t,e,o){var i,a,s,r,c,l=this,d=l.current,u=d.$content,f=n.fancybox.getTranslate(d.$slide).width,p=n.fancybox.getTranslate(d.$slide).height,h=d.width,g=d.height;l.isAnimating||l.isMoved()||!u||"image"!=d.type||!d.isLoaded||d.hasError||(l.isAnimating=!0,n.fancybox.stop(u),t=void 0===t?.5*f:t,e=void 0===e?.5*p:e,i=n.fancybox.getTranslate(u),i.top-=n.fancybox.getTranslate(d.$slide).top,i.left-=n.fancybox.getTranslate(d.$slide).left,r=h/i.width,c=g/i.height,a=.5*f-.5*h,s=.5*p-.5*g,h>f&&(a=i.left*r-(t*r-t),a>0&&(a=0),a<f-h&&(a=f-h)),g>p&&(s=i.top*c-(e*c-e),s>0&&(s=0),s<p-g&&(s=p-g)),l.updateCursor(h,g),n.fancybox.animate(u,{top:s,left:a,scaleX:r,scaleY:c},o||366,function(){l.isAnimating=!1}),l.SlideShow&&l.SlideShow.isActive&&l.SlideShow.stop())},scaleToFit:function(t){var e,o=this,i=o.current,a=i.$content;o.isAnimating||o.isMoved()||!a||"image"!=i.type||!i.isLoaded||i.hasError||(o.isAnimating=!0,n.fancybox.stop(a),e=o.getFitPos(i),o.updateCursor(e.width,e.height),n.fancybox.animate(a,{top:e.top,left:e.left,scaleX:e.width/a.width(),scaleY:e.height/a.height()},t||366,function(){o.isAnimating=!1}))},getFitPos:function(t){var e,o,i,a,s=this,r=t.$content,c=t.$slide,l=t.width||t.opts.width,d=t.height||t.opts.height,u={};return!!(t.isLoaded&&r&&r.length)&&(e=n.fancybox.getTranslate(s.$refs.stage).width,o=n.fancybox.getTranslate(s.$refs.stage).height,e-=parseFloat(c.css("paddingLeft"))+parseFloat(c.css("paddingRight"))+parseFloat(r.css("marginLeft"))+parseFloat(r.css("marginRight")),o-=parseFloat(c.css("paddingTop"))+parseFloat(c.css("paddingBottom"))+parseFloat(r.css("marginTop"))+parseFloat(r.css("marginBottom")),l&&d||(l=e,d=o),i=Math.min(1,e/l,o/d),l*=i,d*=i,l>e-.5&&(l=e),d>o-.5&&(d=o),"image"===t.type?(u.top=Math.floor(.5*(o-d))+parseFloat(c.css("paddingTop")),u.left=Math.floor(.5*(e-l))+parseFloat(c.css("paddingLeft"))):"video"===t.contentType&&(a=t.opts.width&&t.opts.height?l/d:t.opts.ratio||16/9,d>l/a?d=l/a:l>d*a&&(l=d*a)),u.width=l,u.height=d,u)},update:function(t){var e=this;n.each(e.slides,function(n,o){e.updateSlide(o,t)})},updateSlide:function(t,e){var o=this,i=t&&t.$content,a=t.width||t.opts.width,s=t.height||t.opts.height,r=t.$slide;o.adjustCaption(t),i&&(a||s||"video"===t.contentType)&&!t.hasError&&(n.fancybox.stop(i),n.fancybox.setTranslate(i,o.getFitPos(t)),t.pos===o.currPos&&(o.isAnimating=!1,o.updateCursor())),o.adjustLayout(t),r.length&&(r.trigger("refresh"),t.pos===o.currPos&&o.$refs.toolbar.add(o.$refs.navigation.find(".fancybox-button--arrow_right")).toggleClass("compensate-for-scrollbar",r.get(0).scrollHeight>r.get(0).clientHeight)),o.trigger("onUpdate",t,e)},centerSlide:function(t){var e=this,o=e.current,i=o.$slide;!e.isClosing&&o&&(i.siblings().css({transform:"",opacity:""}),i.parent().children().removeClass("fancybox-slide--previous fancybox-slide--next"),n.fancybox.animate(i,{top:0,left:0,opacity:1},void 0===t?0:t,function(){i.css({transform:"",opacity:""}),o.isComplete||e.complete()},!1))},isMoved:function(t){var e,o,i=t||this.current;return!!i&&(o=n.fancybox.getTranslate(this.$refs.stage),e=n.fancybox.getTranslate(i.$slide),!i.$slide.hasClass("fancybox-animated")&&(Math.abs(e.top-o.top)>.5||Math.abs(e.left-o.left)>.5))},updateCursor:function(t,e){var o,i,a=this,s=a.current,r=a.$refs.container;s&&!a.isClosing&&a.Guestures&&(r.removeClass("fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-zoomOut fancybox-can-swipe fancybox-can-pan"),o=a.canPan(t,e),i=!!o||a.isZoomable(),r.toggleClass("fancybox-is-zoomable",i),n("[data-fancybox-zoom]").prop("disabled",!i),o?r.addClass("fancybox-can-pan"):i&&("zoom"===s.opts.clickContent||n.isFunction(s.opts.clickContent)&&"zoom"==s.opts.clickContent(s))?r.addClass("fancybox-can-zoomIn"):s.opts.touch&&(s.opts.touch.vertical||a.group.length>1)&&"video"!==s.contentType&&r.addClass("fancybox-can-swipe"))},isZoomable:function(){var t,e=this,n=e.current;if(n&&!e.isClosing&&"image"===n.type&&!n.hasError){if(!n.isLoaded)return!0;if((t=e.getFitPos(n))&&(n.width>t.width||n.height>t.height))return!0}return!1},isScaledDown:function(t,e){var o=this,i=!1,a=o.current,s=a.$content;return void 0!==t&&void 0!==e?i=t<a.width&&e<a.height:s&&(i=n.fancybox.getTranslate(s),i=i.width<a.width&&i.height<a.height),i},canPan:function(t,e){var o=this,i=o.current,a=null,s=!1;return"image"===i.type&&(i.isComplete||t&&e)&&!i.hasError&&(s=o.getFitPos(i),void 0!==t&&void 0!==e?a={width:t,height:e}:i.isComplete&&(a=n.fancybox.getTranslate(i.$content)),a&&s&&(s=Math.abs(a.width-s.width)>1.5||Math.abs(a.height-s.height)>1.5)),s},loadSlide:function(t){var e,o,i,a=this;if(!t.isLoading&&!t.isLoaded){if(t.isLoading=!0,!1===a.trigger("beforeLoad",t))return t.isLoading=!1,!1;switch(e=t.type,o=t.$slide,o.off("refresh").trigger("onReset").addClass(t.opts.slideClass),e){case"image":a.setImage(t);break;case"iframe":a.setIframe(t);break;case"html":a.setContent(t,t.src||t.content);break;case"video":a.setContent(t,t.opts.video.tpl.replace(/\{\{src\}\}/gi,t.src).replace("{{format}}",t.opts.videoFormat||t.opts.video.format||"").replace("{{poster}}",t.thumb||""));break;case"inline":n(t.src).length?a.setContent(t,n(t.src)):a.setError(t);break;case"ajax":a.showLoading(t),i=n.ajax(n.extend({},t.opts.ajax.settings,{url:t.src,success:function(e,n){"success"===n&&a.setContent(t,e)},error:function(e,n){e&&"abort"!==n&&a.setError(t)}})),o.one("onReset",function(){i.abort()});break;default:a.setError(t)}return!0}},setImage:function(t){var o,i=this;setTimeout(function(){var e=t.$image;i.isClosing||!t.isLoading||e&&e.length&&e[0].complete||t.hasError||i.showLoading(t)},50),i.checkSrcset(t),t.$content=n('<div class="fancybox-content"></div>').addClass("fancybox-is-hidden").appendTo(t.$slide.addClass("fancybox-slide--image")),!1!==t.opts.preload&&t.opts.width&&t.opts.height&&t.thumb&&(t.width=t.opts.width,t.height=t.opts.height,o=e.createElement("img"),o.onerror=function(){n(this).remove(),t.$ghost=null},o.onload=function(){i.afterLoad(t)},t.$ghost=n(o).addClass("fancybox-image").appendTo(t.$content).attr("src",t.thumb)),i.setBigImage(t)},checkSrcset:function(e){var n,o,i,a,s=e.opts.srcset||e.opts.image.srcset;if(s){i=t.devicePixelRatio||1,a=t.innerWidth*i,o=s.split(",").map(function(t){var e={};return t.trim().split(/\s+/).forEach(function(t,n){var o=parseInt(t.substring(0,t.length-1),10);if(0===n)return e.url=t;o&&(e.value=o,e.postfix=t[t.length-1])}),e}),o.sort(function(t,e){return t.value-e.value});for(var r=0;r<o.length;r++){var c=o[r];if("w"===c.postfix&&c.value>=a||"x"===c.postfix&&c.value>=i){n=c;break}}!n&&o.length&&(n=o[o.length-1]),n&&(e.src=n.url,e.width&&e.height&&"w"==n.postfix&&(e.height=e.width/e.height*n.value,e.width=n.value),e.opts.srcset=s)}},setBigImage:function(t){var o=this,i=e.createElement("img"),a=n(i);t.$image=a.one("error",function(){o.setError(t)}).one("load",function(){var e;t.$ghost||(o.resolveImageSlideSize(t,this.naturalWidth,this.naturalHeight),o.afterLoad(t)),o.isClosing||(t.opts.srcset&&(e=t.opts.sizes,e&&"auto"!==e||(e=(t.width/t.height>1&&s.width()/s.height()>1?"100":Math.round(t.width/t.height*100))+"vw"),a.attr("sizes",e).attr("srcset",t.opts.srcset)),t.$ghost&&setTimeout(function(){t.$ghost&&!o.isClosing&&t.$ghost.hide()},Math.min(300,Math.max(1e3,t.height/1600))),o.hideLoading(t))}).addClass("fancybox-image").attr("src",t.src).appendTo(t.$content),(i.complete||"complete"==i.readyState)&&a.naturalWidth&&a.naturalHeight?a.trigger("load"):i.error&&a.trigger("error")},resolveImageSlideSize:function(t,e,n){var o=parseInt(t.opts.width,10),i=parseInt(t.opts.height,10);t.width=e,t.height=n,o>0&&(t.width=o,t.height=Math.floor(o*n/e)),i>0&&(t.width=Math.floor(i*e/n),t.height=i)},setIframe:function(t){var e,o=this,i=t.opts.iframe,a=t.$slide;t.$content=n('<div class="fancybox-content'+(i.preload?" fancybox-is-hidden":"")+'"></div>').css(i.css).appendTo(a),a.addClass("fancybox-slide--"+t.contentType),t.$iframe=e=n(i.tpl.replace(/\{rnd\}/g,(new Date).getTime())).attr(i.attr).appendTo(t.$content),i.preload?(o.showLoading(t),e.on("load.fb error.fb",function(e){this.isReady=1,t.$slide.trigger("refresh"),o.afterLoad(t)}),a.on("refresh.fb",function(){var n,o,s=t.$content,r=i.css.width,c=i.css.height;if(1===e[0].isReady){try{n=e.contents(),o=n.find("body")}catch(t){}o&&o.length&&o.children().length&&(a.css("overflow","visible"),s.css({width:"100%","max-width":"100%",height:"9999px"}),void 0===r&&(r=Math.ceil(Math.max(o[0].clientWidth,o.outerWidth(!0)))),s.css("width",r||"").css("max-width",""),void 0===c&&(c=Math.ceil(Math.max(o[0].clientHeight,o.outerHeight(!0)))),s.css("height",c||""),a.css("overflow","auto")),s.removeClass("fancybox-is-hidden")}})):o.afterLoad(t),e.attr("src",t.src),a.one("onReset",function(){try{n(this).find("iframe").hide().unbind().attr("src","//about:blank")}catch(t){}n(this).off("refresh.fb").empty(),t.isLoaded=!1,t.isRevealed=!1})},setContent:function(t,e){var o=this;o.isClosing||(o.hideLoading(t),t.$content&&n.fancybox.stop(t.$content),t.$slide.empty(),l(e)&&e.parent().length?((e.hasClass("fancybox-content")||e.parent().hasClass("fancybox-content"))&&e.parents(".fancybox-slide").trigger("onReset"),t.$placeholder=n("<div>").hide().insertAfter(e),e.css("display","inline-block")):t.hasError||("string"===n.type(e)&&(e=n("<div>").append(n.trim(e)).contents()),t.opts.filter&&(e=n("<div>").html(e).find(t.opts.filter))),t.$slide.one("onReset",function(){n(this).find("video,audio").trigger("pause"),t.$placeholder&&(t.$placeholder.after(e.removeClass("fancybox-content").hide()).remove(),t.$placeholder=null),t.$smallBtn&&(t.$smallBtn.remove(),t.$smallBtn=null),t.hasError||(n(this).empty(),t.isLoaded=!1,t.isRevealed=!1)}),n(e).appendTo(t.$slide),n(e).is("video,audio")&&(n(e).addClass("fancybox-video"),n(e).wrap("<div></div>"),t.contentType="video",t.opts.width=t.opts.width||n(e).attr("width"),t.opts.height=t.opts.height||n(e).attr("height")),t.$content=t.$slide.children().filter("div,form,main,video,audio,article,.fancybox-content").first(),t.$content.siblings().hide(),t.$content.length||(t.$content=t.$slide.wrapInner("<div></div>").children().first()),t.$content.addClass("fancybox-content"),t.$slide.addClass("fancybox-slide--"+t.contentType),o.afterLoad(t))},setError:function(t){t.hasError=!0,t.$slide.trigger("onReset").removeClass("fancybox-slide--"+t.contentType).addClass("fancybox-slide--error"),t.contentType="html",this.setContent(t,this.translate(t,t.opts.errorTpl)),t.pos===this.currPos&&(this.isAnimating=!1)},showLoading:function(t){var e=this;(t=t||e.current)&&!t.$spinner&&(t.$spinner=n(e.translate(e,e.opts.spinnerTpl)).appendTo(t.$slide).hide().fadeIn("fast"))},hideLoading:function(t){var e=this;(t=t||e.current)&&t.$spinner&&(t.$spinner.stop().remove(),delete t.$spinner)},afterLoad:function(t){var e=this;e.isClosing||(t.isLoading=!1,t.isLoaded=!0,e.trigger("afterLoad",t),e.hideLoading(t),!t.opts.smallBtn||t.$smallBtn&&t.$smallBtn.length||(t.$smallBtn=n(e.translate(t,t.opts.btnTpl.smallBtn)).appendTo(t.$content)),t.opts.protect&&t.$content&&!t.hasError&&(t.$content.on("contextmenu.fb",function(t){return 2==t.button&&t.preventDefault(),!0}),"image"===t.type&&n('<div class="fancybox-spaceball"></div>').appendTo(t.$content)),e.adjustCaption(t),e.adjustLayout(t),t.pos===e.currPos&&e.updateCursor(),e.revealContent(t))},adjustCaption:function(t){var e,n=this,o=t||n.current,i=o.opts.caption,a=o.opts.preventCaptionOverlap,s=n.$refs.caption,r=!1;s.toggleClass("fancybox-caption--separate",a),a&&i&&i.length&&(o.pos!==n.currPos?(e=s.clone().appendTo(s.parent()),e.children().eq(0).empty().html(i),r=e.outerHeight(!0),e.empty().remove()):n.$caption&&(r=n.$caption.outerHeight(!0)),o.$slide.css("padding-bottom",r||""))},adjustLayout:function(t){var e,n,o,i,a=this,s=t||a.current;s.isLoaded&&!0!==s.opts.disableLayoutFix&&(s.$content.css("margin-bottom",""),s.$content.outerHeight()>s.$slide.height()+.5&&(o=s.$slide[0].style["padding-bottom"],i=s.$slide.css("padding-bottom"),parseFloat(i)>0&&(e=s.$slide[0].scrollHeight,s.$slide.css("padding-bottom",0),Math.abs(e-s.$slide[0].scrollHeight)<1&&(n=i),s.$slide.css("padding-bottom",o))),s.$content.css("margin-bottom",n))},revealContent:function(t){var e,o,i,a,s=this,r=t.$slide,c=!1,l=!1,d=s.isMoved(t),u=t.isRevealed;return t.isRevealed=!0,e=t.opts[s.firstRun?"animationEffect":"transitionEffect"],i=t.opts[s.firstRun?"animationDuration":"transitionDuration"],i=parseInt(void 0===t.forcedDuration?i:t.forcedDuration,10),!d&&t.pos===s.currPos&&i||(e=!1),"zoom"===e&&(t.pos===s.currPos&&i&&"image"===t.type&&!t.hasError&&(l=s.getThumbPos(t))?c=s.getFitPos(t):e="fade"),"zoom"===e?(s.isAnimating=!0,c.scaleX=c.width/l.width,c.scaleY=c.height/l.height,a=t.opts.zoomOpacity,"auto"==a&&(a=Math.abs(t.width/t.height-l.width/l.height)>.1),a&&(l.opacity=.1,c.opacity=1),n.fancybox.setTranslate(t.$content.removeClass("fancybox-is-hidden"),l),p(t.$content),void n.fancybox.animate(t.$content,c,i,function(){s.isAnimating=!1,s.complete()})):(s.updateSlide(t),e?(n.fancybox.stop(r),o="fancybox-slide--"+(t.pos>=s.prevPos?"next":"previous")+" fancybox-animated fancybox-fx-"+e,r.addClass(o).removeClass("fancybox-slide--current"),t.$content.removeClass("fancybox-is-hidden"),p(r),"image"!==t.type&&t.$content.hide().show(0),void n.fancybox.animate(r,"fancybox-slide--current",i,function(){r.removeClass(o).css({transform:"",opacity:""}),t.pos===s.currPos&&s.complete()},!0)):(t.$content.removeClass("fancybox-is-hidden"),u||!d||"image"!==t.type||t.hasError||t.$content.hide().fadeIn("fast"),void(t.pos===s.currPos&&s.complete())))},getThumbPos:function(t){var e,o,i,a,s,r=!1,c=t.$thumb;return!(!c||!g(c[0]))&&(e=n.fancybox.getTranslate(c),o=parseFloat(c.css("border-top-width")||0),i=parseFloat(c.css("border-right-width")||0),a=parseFloat(c.css("border-bottom-width")||0),s=parseFloat(c.css("border-left-width")||0),r={top:e.top+o,left:e.left+s,width:e.width-i-s,height:e.height-o-a,scaleX:1,scaleY:1},e.width>0&&e.height>0&&r)},complete:function(){var t,e=this,o=e.current,i={};!e.isMoved()&&o.isLoaded&&(o.isComplete||(o.isComplete=!0,o.$slide.siblings().trigger("onReset"),e.preload("inline"),p(o.$slide),o.$slide.addClass("fancybox-slide--complete"),n.each(e.slides,function(t,o){o.pos>=e.currPos-1&&o.pos<=e.currPos+1?i[o.pos]=o:o&&(n.fancybox.stop(o.$slide),o.$slide.off().remove())}),e.slides=i),e.isAnimating=!1,e.updateCursor(),e.trigger("afterShow"),o.opts.video.autoStart&&o.$slide.find("video,audio").filter(":visible:first").trigger("play").one("ended",function(){Document.exitFullscreen?Document.exitFullscreen():this.webkitExitFullscreen&&this.webkitExitFullscreen(),e.next()}),o.opts.autoFocus&&"html"===o.contentType&&(t=o.$content.find("input[autofocus]:enabled:visible:first"),t.length?t.trigger("focus"):e.focus(null,!0)),o.$slide.scrollTop(0).scrollLeft(0))},preload:function(t){var e,n,o=this;o.group.length<2||(n=o.slides[o.currPos+1],e=o.slides[o.currPos-1],e&&e.type===t&&o.loadSlide(e),n&&n.type===t&&o.loadSlide(n))},focus:function(t,o){var i,a,s=this,r=["a[href]","area[href]",'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',"select:not([disabled]):not([aria-hidden])","textarea:not([disabled]):not([aria-hidden])","button:not([disabled]):not([aria-hidden])","iframe","object","embed","video","audio","[contenteditable]",'[tabindex]:not([tabindex^="-"])'].join(",");s.isClosing||(i=!t&&s.current&&s.current.isComplete?s.current.$slide.find("*:visible"+(o?":not(.fancybox-close-small)":"")):s.$refs.container.find("*:visible"),i=i.filter(r).filter(function(){return"hidden"!==n(this).css("visibility")&&!n(this).hasClass("disabled")}),i.length?(a=i.index(e.activeElement),t&&t.shiftKey?(a<0||0==a)&&(t.preventDefault(),i.eq(i.length-1).trigger("focus")):(a<0||a==i.length-1)&&(t&&t.preventDefault(),i.eq(0).trigger("focus"))):s.$refs.container.trigger("focus"))},activate:function(){var t=this;n(".fancybox-container").each(function(){var e=n(this).data("FancyBox");e&&e.id!==t.id&&!e.isClosing&&(e.trigger("onDeactivate"),e.removeEvents(),e.isVisible=!1)}),t.isVisible=!0,(t.current||t.isIdle)&&(t.update(),t.updateControls()),t.trigger("onActivate"),t.addEvents()},close:function(t,e){var o,i,a,s,r,c,l,u=this,f=u.current,h=function(){u.cleanUp(t)};return!u.isClosing&&(u.isClosing=!0,!1===u.trigger("beforeClose",t)?(u.isClosing=!1,d(function(){u.update()}),!1):(u.removeEvents(),a=f.$content,o=f.opts.animationEffect,i=n.isNumeric(e)?e:o?f.opts.animationDuration:0,f.$slide.removeClass("fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated"),!0!==t?n.fancybox.stop(f.$slide):o=!1,f.$slide.siblings().trigger("onReset").remove(),i&&u.$refs.container.removeClass("fancybox-is-open").addClass("fancybox-is-closing").css("transition-duration",i+"ms"),u.hideLoading(f),u.hideControls(!0),u.updateCursor(),"zoom"!==o||a&&i&&"image"===f.type&&!u.isMoved()&&!f.hasError&&(l=u.getThumbPos(f))||(o="fade"),"zoom"===o?(n.fancybox.stop(a),s=n.fancybox.getTranslate(a),c={top:s.top,left:s.left,scaleX:s.width/l.width,scaleY:s.height/l.height,width:l.width,height:l.height},r=f.opts.zoomOpacity,
"auto"==r&&(r=Math.abs(f.width/f.height-l.width/l.height)>.1),r&&(l.opacity=0),n.fancybox.setTranslate(a,c),p(a),n.fancybox.animate(a,l,i,h),!0):(o&&i?n.fancybox.animate(f.$slide.addClass("fancybox-slide--previous").removeClass("fancybox-slide--current"),"fancybox-animated fancybox-fx-"+o,i,h):!0===t?setTimeout(h,i):h(),!0)))},cleanUp:function(e){var o,i,a,s=this,r=s.current.opts.$orig;s.current.$slide.trigger("onReset"),s.$refs.container.empty().remove(),s.trigger("afterClose",e),s.current.opts.backFocus&&(r&&r.length&&r.is(":visible")||(r=s.$trigger),r&&r.length&&(i=t.scrollX,a=t.scrollY,r.trigger("focus"),n("html, body").scrollTop(a).scrollLeft(i))),s.current=null,o=n.fancybox.getInstance(),o?o.activate():(n("body").removeClass("fancybox-active compensate-for-scrollbar"),n("#fancybox-style-noscroll").remove())},trigger:function(t,e){var o,i=Array.prototype.slice.call(arguments,1),a=this,s=e&&e.opts?e:a.current;if(s?i.unshift(s):s=a,i.unshift(a),n.isFunction(s.opts[t])&&(o=s.opts[t].apply(s,i)),!1===o)return o;"afterClose"!==t&&a.$refs?a.$refs.container.trigger(t+".fb",i):r.trigger(t+".fb",i)},updateControls:function(){var t=this,o=t.current,i=o.index,a=t.$refs.container,s=t.$refs.caption,r=o.opts.caption;o.$slide.trigger("refresh"),r&&r.length?(t.$caption=s,s.children().eq(0).html(r)):t.$caption=null,t.hasHiddenControls||t.isIdle||t.showControls(),a.find("[data-fancybox-count]").html(t.group.length),a.find("[data-fancybox-index]").html(i+1),a.find("[data-fancybox-prev]").prop("disabled",!o.opts.loop&&i<=0),a.find("[data-fancybox-next]").prop("disabled",!o.opts.loop&&i>=t.group.length-1),"image"===o.type?a.find("[data-fancybox-zoom]").show().end().find("[data-fancybox-download]").attr("href",o.opts.image.src||o.src).show():o.opts.toolbar&&a.find("[data-fancybox-download],[data-fancybox-zoom]").hide(),n(e.activeElement).is(":hidden,[disabled]")&&t.$refs.container.trigger("focus")},hideControls:function(t){var e=this,n=["infobar","toolbar","nav"];!t&&e.current.opts.preventCaptionOverlap||n.push("caption"),this.$refs.container.removeClass(n.map(function(t){return"fancybox-show-"+t}).join(" ")),this.hasHiddenControls=!0},showControls:function(){var t=this,e=t.current?t.current.opts:t.opts,n=t.$refs.container;t.hasHiddenControls=!1,t.idleSecondsCounter=0,n.toggleClass("fancybox-show-toolbar",!(!e.toolbar||!e.buttons)).toggleClass("fancybox-show-infobar",!!(e.infobar&&t.group.length>1)).toggleClass("fancybox-show-caption",!!t.$caption).toggleClass("fancybox-show-nav",!!(e.arrows&&t.group.length>1)).toggleClass("fancybox-is-modal",!!e.modal)},toggleControls:function(){this.hasHiddenControls?this.showControls():this.hideControls()}}),n.fancybox={version:"3.5.7",defaults:a,getInstance:function(t){var e=n('.fancybox-container:not(".fancybox-is-closing"):last').data("FancyBox"),o=Array.prototype.slice.call(arguments,1);return e instanceof b&&("string"===n.type(t)?e[t].apply(e,o):"function"===n.type(t)&&t.apply(e,o),e)},open:function(t,e,n){return new b(t,e,n)},close:function(t){var e=this.getInstance();e&&(e.close(),!0===t&&this.close(t))},destroy:function(){this.close(!0),r.add("body").off("click.fb-start","**")},isMobile:/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),use3d:function(){var n=e.createElement("div");return t.getComputedStyle&&t.getComputedStyle(n)&&t.getComputedStyle(n).getPropertyValue("transform")&&!(e.documentMode&&e.documentMode<11)}(),getTranslate:function(t){var e;return!(!t||!t.length)&&(e=t[0].getBoundingClientRect(),{top:e.top||0,left:e.left||0,width:e.width,height:e.height,opacity:parseFloat(t.css("opacity"))})},setTranslate:function(t,e){var n="",o={};if(t&&e)return void 0===e.left&&void 0===e.top||(n=(void 0===e.left?t.position().left:e.left)+"px, "+(void 0===e.top?t.position().top:e.top)+"px",n=this.use3d?"translate3d("+n+", 0px)":"translate("+n+")"),void 0!==e.scaleX&&void 0!==e.scaleY?n+=" scale("+e.scaleX+", "+e.scaleY+")":void 0!==e.scaleX&&(n+=" scaleX("+e.scaleX+")"),n.length&&(o.transform=n),void 0!==e.opacity&&(o.opacity=e.opacity),void 0!==e.width&&(o.width=e.width),void 0!==e.height&&(o.height=e.height),t.css(o)},animate:function(t,e,o,i,a){var s,r=this;n.isFunction(o)&&(i=o,o=null),r.stop(t),s=r.getTranslate(t),t.on(f,function(c){(!c||!c.originalEvent||t.is(c.originalEvent.target)&&"z-index"!=c.originalEvent.propertyName)&&(r.stop(t),n.isNumeric(o)&&t.css("transition-duration",""),n.isPlainObject(e)?void 0!==e.scaleX&&void 0!==e.scaleY&&r.setTranslate(t,{top:e.top,left:e.left,width:s.width*e.scaleX,height:s.height*e.scaleY,scaleX:1,scaleY:1}):!0!==a&&t.removeClass(e),n.isFunction(i)&&i(c))}),n.isNumeric(o)&&t.css("transition-duration",o+"ms"),n.isPlainObject(e)?(void 0!==e.scaleX&&void 0!==e.scaleY&&(delete e.width,delete e.height,t.parent().hasClass("fancybox-slide--image")&&t.parent().addClass("fancybox-is-scaling")),n.fancybox.setTranslate(t,e)):t.addClass(e),t.data("timer",setTimeout(function(){t.trigger(f)},o+33))},stop:function(t,e){t&&t.length&&(clearTimeout(t.data("timer")),e&&t.trigger(f),t.off(f).css("transition-duration",""),t.parent().removeClass("fancybox-is-scaling"))}},n.fn.fancybox=function(t){var e;return t=t||{},e=t.selector||!1,e?n("body").off("click.fb-start",e).on("click.fb-start",e,{options:t},i):this.off("click.fb-start").on("click.fb-start",{items:this,options:t},i),this},r.on("click.fb-start","[data-fancybox]",i),r.on("click.fb-start","[data-fancybox-trigger]",function(t){n('[data-fancybox="'+n(this).attr("data-fancybox-trigger")+'"]').eq(n(this).attr("data-fancybox-index")||0).trigger("click.fb-start",{$trigger:n(this)})}),function(){var t=null;r.on("mousedown mouseup focus blur",".fancybox-button",function(e){switch(e.type){case"mousedown":t=n(this);break;case"mouseup":t=null;break;case"focusin":n(".fancybox-button").removeClass("fancybox-focus"),n(this).is(t)||n(this).is("[disabled]")||n(this).addClass("fancybox-focus");break;case"focusout":n(".fancybox-button").removeClass("fancybox-focus")}})}()}}(window,document,jQuery),function(t){"use strict";var e={youtube:{matcher:/(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(watch\?(.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(.*)|[\w-]{11}|\?listType=(.*)&list=(.*))(.*)/i,params:{autoplay:1,autohide:1,fs:1,rel:0,hd:1,wmode:"transparent",enablejsapi:1,html5:1},paramPlace:8,type:"iframe",url:"https://www.youtube-nocookie.com/embed/$4",thumb:"https://img.youtube.com/vi/$4/hqdefault.jpg"},vimeo:{matcher:/^.+vimeo.com\/(.*\/)?([\d]+)(.*)?/,params:{autoplay:1,hd:1,show_title:1,show_byline:1,show_portrait:0,fullscreen:1},paramPlace:3,type:"iframe",url:"//player.vimeo.com/video/$2"},instagram:{matcher:/(instagr\.am|instagram\.com)\/p\/([a-zA-Z0-9_\-]+)\/?/i,type:"image",url:"//$1/p/$2/media/?size=l"},gmap_place:{matcher:/(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(((maps\/(place\/(.*)\/)?\@(.*),(\d+.?\d+?)z))|(\?ll=))(.*)?/i,type:"iframe",url:function(t){return"//maps.google."+t[2]+"/?ll="+(t[9]?t[9]+"&z="+Math.floor(t[10])+(t[12]?t[12].replace(/^\//,"&"):""):t[12]+"").replace(/\?/,"&")+"&output="+(t[12]&&t[12].indexOf("layer=c")>0?"svembed":"embed")}},gmap_search:{matcher:/(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(maps\/search\/)(.*)/i,type:"iframe",url:function(t){return"//maps.google."+t[2]+"/maps?q="+t[5].replace("query=","q=").replace("api=1","")+"&output=embed"}}},n=function(e,n,o){if(e)return o=o||"","object"===t.type(o)&&(o=t.param(o,!0)),t.each(n,function(t,n){e=e.replace("$"+t,n||"")}),o.length&&(e+=(e.indexOf("?")>0?"&":"?")+o),e};t(document).on("objectNeedsType.fb",function(o,i,a){var s,r,c,l,d,u,f,p=a.src||"",h=!1;s=t.extend(!0,{},e,a.opts.media),t.each(s,function(e,o){if(c=p.match(o.matcher)){if(h=o.type,f=e,u={},o.paramPlace&&c[o.paramPlace]){d=c[o.paramPlace],"?"==d[0]&&(d=d.substring(1)),d=d.split("&");for(var i=0;i<d.length;++i){var s=d[i].split("=",2);2==s.length&&(u[s[0]]=decodeURIComponent(s[1].replace(/\+/g," ")))}}return l=t.extend(!0,{},o.params,a.opts[e],u),p="function"===t.type(o.url)?o.url.call(this,c,l,a):n(o.url,c,l),r="function"===t.type(o.thumb)?o.thumb.call(this,c,l,a):n(o.thumb,c),"youtube"===e?p=p.replace(/&t=((\d+)m)?(\d+)s/,function(t,e,n,o){return"&start="+((n?60*parseInt(n,10):0)+parseInt(o,10))}):"vimeo"===e&&(p=p.replace("&%23","#")),!1}}),h?(a.opts.thumb||a.opts.$thumb&&a.opts.$thumb.length||(a.opts.thumb=r),"iframe"===h&&(a.opts=t.extend(!0,a.opts,{iframe:{preload:!1,attr:{scrolling:"no"}}})),t.extend(a,{type:h,src:p,origSrc:a.src,contentSource:f,contentType:"image"===h?"image":"gmap_place"==f||"gmap_search"==f?"map":"video"})):p&&(a.type=a.opts.defaultType)});var o={youtube:{src:"https://www.youtube.com/iframe_api",class:"YT",loading:!1,loaded:!1},vimeo:{src:"https://player.vimeo.com/api/player.js",class:"Vimeo",loading:!1,loaded:!1},load:function(t){var e,n=this;if(this[t].loaded)return void setTimeout(function(){n.done(t)});this[t].loading||(this[t].loading=!0,e=document.createElement("script"),e.type="text/javascript",e.src=this[t].src,"youtube"===t?window.onYouTubeIframeAPIReady=function(){n[t].loaded=!0,n.done(t)}:e.onload=function(){n[t].loaded=!0,n.done(t)},document.body.appendChild(e))},done:function(e){var n,o,i;"youtube"===e&&delete window.onYouTubeIframeAPIReady,(n=t.fancybox.getInstance())&&(o=n.current.$content.find("iframe"),"youtube"===e&&void 0!==YT&&YT?i=new YT.Player(o.attr("id"),{events:{onStateChange:function(t){0==t.data&&n.next()}}}):"vimeo"===e&&void 0!==Vimeo&&Vimeo&&(i=new Vimeo.Player(o),i.on("ended",function(){n.next()})))}};t(document).on({"afterShow.fb":function(t,e,n){e.group.length>1&&("youtube"===n.contentSource||"vimeo"===n.contentSource)&&o.load(n.contentSource)}})}(jQuery),function(t,e,n){"use strict";var o=function(){return t.requestAnimationFrame||t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||t.oRequestAnimationFrame||function(e){return t.setTimeout(e,1e3/60)}}(),i=function(){return t.cancelAnimationFrame||t.webkitCancelAnimationFrame||t.mozCancelAnimationFrame||t.oCancelAnimationFrame||function(e){t.clearTimeout(e)}}(),a=function(e){var n=[];e=e.originalEvent||e||t.e,e=e.touches&&e.touches.length?e.touches:e.changedTouches&&e.changedTouches.length?e.changedTouches:[e];for(var o in e)e[o].pageX?n.push({x:e[o].pageX,y:e[o].pageY}):e[o].clientX&&n.push({x:e[o].clientX,y:e[o].clientY});return n},s=function(t,e,n){return e&&t?"x"===n?t.x-e.x:"y"===n?t.y-e.y:Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2)):0},r=function(t){if(t.is('a,area,button,[role="button"],input,label,select,summary,textarea,video,audio,iframe')||n.isFunction(t.get(0).onclick)||t.data("selectable"))return!0;for(var e=0,o=t[0].attributes,i=o.length;e<i;e++)if("data-fancybox-"===o[e].nodeName.substr(0,14))return!0;return!1},c=function(e){var n=t.getComputedStyle(e)["overflow-y"],o=t.getComputedStyle(e)["overflow-x"],i=("scroll"===n||"auto"===n)&&e.scrollHeight>e.clientHeight,a=("scroll"===o||"auto"===o)&&e.scrollWidth>e.clientWidth;return i||a},l=function(t){for(var e=!1;;){if(e=c(t.get(0)))break;if(t=t.parent(),!t.length||t.hasClass("fancybox-stage")||t.is("body"))break}return e},d=function(t){var e=this;e.instance=t,e.$bg=t.$refs.bg,e.$stage=t.$refs.stage,e.$container=t.$refs.container,e.destroy(),e.$container.on("touchstart.fb.touch mousedown.fb.touch",n.proxy(e,"ontouchstart"))};d.prototype.destroy=function(){var t=this;t.$container.off(".fb.touch"),n(e).off(".fb.touch"),t.requestId&&(i(t.requestId),t.requestId=null),t.tapped&&(clearTimeout(t.tapped),t.tapped=null)},d.prototype.ontouchstart=function(o){var i=this,c=n(o.target),d=i.instance,u=d.current,f=u.$slide,p=u.$content,h="touchstart"==o.type;if(h&&i.$container.off("mousedown.fb.touch"),(!o.originalEvent||2!=o.originalEvent.button)&&f.length&&c.length&&!r(c)&&!r(c.parent())&&(c.is("img")||!(o.originalEvent.clientX>c[0].clientWidth+c.offset().left))){if(!u||d.isAnimating||u.$slide.hasClass("fancybox-animated"))return o.stopPropagation(),void o.preventDefault();i.realPoints=i.startPoints=a(o),i.startPoints.length&&(u.touch&&o.stopPropagation(),i.startEvent=o,i.canTap=!0,i.$target=c,i.$content=p,i.opts=u.opts.touch,i.isPanning=!1,i.isSwiping=!1,i.isZooming=!1,i.isScrolling=!1,i.canPan=d.canPan(),i.startTime=(new Date).getTime(),i.distanceX=i.distanceY=i.distance=0,i.canvasWidth=Math.round(f[0].clientWidth),i.canvasHeight=Math.round(f[0].clientHeight),i.contentLastPos=null,i.contentStartPos=n.fancybox.getTranslate(i.$content)||{top:0,left:0},i.sliderStartPos=n.fancybox.getTranslate(f),i.stagePos=n.fancybox.getTranslate(d.$refs.stage),i.sliderStartPos.top-=i.stagePos.top,i.sliderStartPos.left-=i.stagePos.left,i.contentStartPos.top-=i.stagePos.top,i.contentStartPos.left-=i.stagePos.left,n(e).off(".fb.touch").on(h?"touchend.fb.touch touchcancel.fb.touch":"mouseup.fb.touch mouseleave.fb.touch",n.proxy(i,"ontouchend")).on(h?"touchmove.fb.touch":"mousemove.fb.touch",n.proxy(i,"ontouchmove")),n.fancybox.isMobile&&e.addEventListener("scroll",i.onscroll,!0),((i.opts||i.canPan)&&(c.is(i.$stage)||i.$stage.find(c).length)||(c.is(".fancybox-image")&&o.preventDefault(),n.fancybox.isMobile&&c.parents(".fancybox-caption").length))&&(i.isScrollable=l(c)||l(c.parent()),n.fancybox.isMobile&&i.isScrollable||o.preventDefault(),(1===i.startPoints.length||u.hasError)&&(i.canPan?(n.fancybox.stop(i.$content),i.isPanning=!0):i.isSwiping=!0,i.$container.addClass("fancybox-is-grabbing")),2===i.startPoints.length&&"image"===u.type&&(u.isLoaded||u.$ghost)&&(i.canTap=!1,i.isSwiping=!1,i.isPanning=!1,i.isZooming=!0,n.fancybox.stop(i.$content),i.centerPointStartX=.5*(i.startPoints[0].x+i.startPoints[1].x)-n(t).scrollLeft(),i.centerPointStartY=.5*(i.startPoints[0].y+i.startPoints[1].y)-n(t).scrollTop(),i.percentageOfImageAtPinchPointX=(i.centerPointStartX-i.contentStartPos.left)/i.contentStartPos.width,i.percentageOfImageAtPinchPointY=(i.centerPointStartY-i.contentStartPos.top)/i.contentStartPos.height,i.startDistanceBetweenFingers=s(i.startPoints[0],i.startPoints[1]))))}},d.prototype.onscroll=function(t){var n=this;n.isScrolling=!0,e.removeEventListener("scroll",n.onscroll,!0)},d.prototype.ontouchmove=function(t){var e=this;return void 0!==t.originalEvent.buttons&&0===t.originalEvent.buttons?void e.ontouchend(t):e.isScrolling?void(e.canTap=!1):(e.newPoints=a(t),void((e.opts||e.canPan)&&e.newPoints.length&&e.newPoints.length&&(e.isSwiping&&!0===e.isSwiping||t.preventDefault(),e.distanceX=s(e.newPoints[0],e.startPoints[0],"x"),e.distanceY=s(e.newPoints[0],e.startPoints[0],"y"),e.distance=s(e.newPoints[0],e.startPoints[0]),e.distance>0&&(e.isSwiping?e.onSwipe(t):e.isPanning?e.onPan():e.isZooming&&e.onZoom()))))},d.prototype.onSwipe=function(e){var a,s=this,r=s.instance,c=s.isSwiping,l=s.sliderStartPos.left||0;if(!0!==c)"x"==c&&(s.distanceX>0&&(s.instance.group.length<2||0===s.instance.current.index&&!s.instance.current.opts.loop)?l+=Math.pow(s.distanceX,.8):s.distanceX<0&&(s.instance.group.length<2||s.instance.current.index===s.instance.group.length-1&&!s.instance.current.opts.loop)?l-=Math.pow(-s.distanceX,.8):l+=s.distanceX),s.sliderLastPos={top:"x"==c?0:s.sliderStartPos.top+s.distanceY,left:l},s.requestId&&(i(s.requestId),s.requestId=null),s.requestId=o(function(){s.sliderLastPos&&(n.each(s.instance.slides,function(t,e){var o=e.pos-s.instance.currPos;n.fancybox.setTranslate(e.$slide,{top:s.sliderLastPos.top,left:s.sliderLastPos.left+o*s.canvasWidth+o*e.opts.gutter})}),s.$container.addClass("fancybox-is-sliding"))});else if(Math.abs(s.distance)>10){if(s.canTap=!1,r.group.length<2&&s.opts.vertical?s.isSwiping="y":r.isDragging||!1===s.opts.vertical||"auto"===s.opts.vertical&&n(t).width()>800?s.isSwiping="x":(a=Math.abs(180*Math.atan2(s.distanceY,s.distanceX)/Math.PI),s.isSwiping=a>45&&a<135?"y":"x"),"y"===s.isSwiping&&n.fancybox.isMobile&&s.isScrollable)return void(s.isScrolling=!0);r.isDragging=s.isSwiping,s.startPoints=s.newPoints,n.each(r.slides,function(t,e){var o,i;n.fancybox.stop(e.$slide),o=n.fancybox.getTranslate(e.$slide),i=n.fancybox.getTranslate(r.$refs.stage),e.$slide.css({transform:"",opacity:"","transition-duration":""}).removeClass("fancybox-animated").removeClass(function(t,e){return(e.match(/(^|\s)fancybox-fx-\S+/g)||[]).join(" ")}),e.pos===r.current.pos&&(s.sliderStartPos.top=o.top-i.top,s.sliderStartPos.left=o.left-i.left),n.fancybox.setTranslate(e.$slide,{top:o.top-i.top,left:o.left-i.left})}),r.SlideShow&&r.SlideShow.isActive&&r.SlideShow.stop()}},d.prototype.onPan=function(){var t=this;if(s(t.newPoints[0],t.realPoints[0])<(n.fancybox.isMobile?10:5))return void(t.startPoints=t.newPoints);t.canTap=!1,t.contentLastPos=t.limitMovement(),t.requestId&&i(t.requestId),t.requestId=o(function(){n.fancybox.setTranslate(t.$content,t.contentLastPos)})},d.prototype.limitMovement=function(){var t,e,n,o,i,a,s=this,r=s.canvasWidth,c=s.canvasHeight,l=s.distanceX,d=s.distanceY,u=s.contentStartPos,f=u.left,p=u.top,h=u.width,g=u.height;return i=h>r?f+l:f,a=p+d,t=Math.max(0,.5*r-.5*h),e=Math.max(0,.5*c-.5*g),n=Math.min(r-h,.5*r-.5*h),o=Math.min(c-g,.5*c-.5*g),l>0&&i>t&&(i=t-1+Math.pow(-t+f+l,.8)||0),l<0&&i<n&&(i=n+1-Math.pow(n-f-l,.8)||0),d>0&&a>e&&(a=e-1+Math.pow(-e+p+d,.8)||0),d<0&&a<o&&(a=o+1-Math.pow(o-p-d,.8)||0),{top:a,left:i}},d.prototype.limitPosition=function(t,e,n,o){var i=this,a=i.canvasWidth,s=i.canvasHeight;return n>a?(t=t>0?0:t,t=t<a-n?a-n:t):t=Math.max(0,a/2-n/2),o>s?(e=e>0?0:e,e=e<s-o?s-o:e):e=Math.max(0,s/2-o/2),{top:e,left:t}},d.prototype.onZoom=function(){var e=this,a=e.contentStartPos,r=a.width,c=a.height,l=a.left,d=a.top,u=s(e.newPoints[0],e.newPoints[1]),f=u/e.startDistanceBetweenFingers,p=Math.floor(r*f),h=Math.floor(c*f),g=(r-p)*e.percentageOfImageAtPinchPointX,b=(c-h)*e.percentageOfImageAtPinchPointY,m=(e.newPoints[0].x+e.newPoints[1].x)/2-n(t).scrollLeft(),v=(e.newPoints[0].y+e.newPoints[1].y)/2-n(t).scrollTop(),y=m-e.centerPointStartX,x=v-e.centerPointStartY,w=l+(g+y),$=d+(b+x),S={top:$,left:w,scaleX:f,scaleY:f};e.canTap=!1,e.newWidth=p,e.newHeight=h,e.contentLastPos=S,e.requestId&&i(e.requestId),e.requestId=o(function(){n.fancybox.setTranslate(e.$content,e.contentLastPos)})},d.prototype.ontouchend=function(t){var o=this,s=o.isSwiping,r=o.isPanning,c=o.isZooming,l=o.isScrolling;if(o.endPoints=a(t),o.dMs=Math.max((new Date).getTime()-o.startTime,1),o.$container.removeClass("fancybox-is-grabbing"),n(e).off(".fb.touch"),e.removeEventListener("scroll",o.onscroll,!0),o.requestId&&(i(o.requestId),o.requestId=null),o.isSwiping=!1,o.isPanning=!1,o.isZooming=!1,o.isScrolling=!1,o.instance.isDragging=!1,o.canTap)return o.onTap(t);o.speed=100,o.velocityX=o.distanceX/o.dMs*.5,o.velocityY=o.distanceY/o.dMs*.5,r?o.endPanning():c?o.endZooming():o.endSwiping(s,l)},d.prototype.endSwiping=function(t,e){var o=this,i=!1,a=o.instance.group.length,s=Math.abs(o.distanceX),r="x"==t&&a>1&&(o.dMs>130&&s>10||s>50);o.sliderLastPos=null,"y"==t&&!e&&Math.abs(o.distanceY)>50?(n.fancybox.animate(o.instance.current.$slide,{top:o.sliderStartPos.top+o.distanceY+150*o.velocityY,opacity:0},200),i=o.instance.close(!0,250)):r&&o.distanceX>0?i=o.instance.previous(300):r&&o.distanceX<0&&(i=o.instance.next(300)),!1!==i||"x"!=t&&"y"!=t||o.instance.centerSlide(200),o.$container.removeClass("fancybox-is-sliding")},d.prototype.endPanning=function(){var t,e,o,i=this;i.contentLastPos&&(!1===i.opts.momentum||i.dMs>350?(t=i.contentLastPos.left,e=i.contentLastPos.top):(t=i.contentLastPos.left+500*i.velocityX,e=i.contentLastPos.top+500*i.velocityY),o=i.limitPosition(t,e,i.contentStartPos.width,i.contentStartPos.height),o.width=i.contentStartPos.width,o.height=i.contentStartPos.height,n.fancybox.animate(i.$content,o,366))},d.prototype.endZooming=function(){var t,e,o,i,a=this,s=a.instance.current,r=a.newWidth,c=a.newHeight;a.contentLastPos&&(t=a.contentLastPos.left,e=a.contentLastPos.top,i={top:e,left:t,width:r,height:c,scaleX:1,scaleY:1},n.fancybox.setTranslate(a.$content,i),r<a.canvasWidth&&c<a.canvasHeight?a.instance.scaleToFit(150):r>s.width||c>s.height?a.instance.scaleToActual(a.centerPointStartX,a.centerPointStartY,150):(o=a.limitPosition(t,e,r,c),n.fancybox.animate(a.$content,o,150)))},d.prototype.onTap=function(e){var o,i=this,s=n(e.target),r=i.instance,c=r.current,l=e&&a(e)||i.startPoints,d=l[0]?l[0].x-n(t).scrollLeft()-i.stagePos.left:0,u=l[0]?l[0].y-n(t).scrollTop()-i.stagePos.top:0,f=function(t){var o=c.opts[t];if(n.isFunction(o)&&(o=o.apply(r,[c,e])),o)switch(o){case"close":r.close(i.startEvent);break;case"toggleControls":r.toggleControls();break;case"next":r.next();break;case"nextOrClose":r.group.length>1?r.next():r.close(i.startEvent);break;case"zoom":"image"==c.type&&(c.isLoaded||c.$ghost)&&(r.canPan()?r.scaleToFit():r.isScaledDown()?r.scaleToActual(d,u):r.group.length<2&&r.close(i.startEvent))}};if((!e.originalEvent||2!=e.originalEvent.button)&&(s.is("img")||!(d>s[0].clientWidth+s.offset().left))){if(s.is(".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container"))o="Outside";else if(s.is(".fancybox-slide"))o="Slide";else{if(!r.current.$content||!r.current.$content.find(s).addBack().filter(s).length)return;o="Content"}if(i.tapped){if(clearTimeout(i.tapped),i.tapped=null,Math.abs(d-i.tapX)>50||Math.abs(u-i.tapY)>50)return this;f("dblclick"+o)}else i.tapX=d,i.tapY=u,c.opts["dblclick"+o]&&c.opts["dblclick"+o]!==c.opts["click"+o]?i.tapped=setTimeout(function(){i.tapped=null,r.isAnimating||f("click"+o)},500):f("click"+o);return this}},n(e).on("onActivate.fb",function(t,e){e&&!e.Guestures&&(e.Guestures=new d(e))}).on("beforeClose.fb",function(t,e){e&&e.Guestures&&e.Guestures.destroy()})}(window,document,jQuery),function(t,e){"use strict";e.extend(!0,e.fancybox.defaults,{btnTpl:{slideShow:'<button data-fancybox-play class="fancybox-button fancybox-button--play" title="{{PLAY_START}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.5 5.4v13.2l11-6.6z"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.33 5.75h2.2v12.5h-2.2V5.75zm5.15 0h2.2v12.5h-2.2V5.75z"/></svg></button>'},slideShow:{autoStart:!1,speed:3e3,progress:!0}});var n=function(t){this.instance=t,this.init()};e.extend(n.prototype,{timer:null,isActive:!1,$button:null,init:function(){var t=this,n=t.instance,o=n.group[n.currIndex].opts.slideShow;t.$button=n.$refs.toolbar.find("[data-fancybox-play]").on("click",function(){t.toggle()}),n.group.length<2||!o?t.$button.hide():o.progress&&(t.$progress=e('<div class="fancybox-progress"></div>').appendTo(n.$refs.inner))},set:function(t){var n=this,o=n.instance,i=o.current;i&&(!0===t||i.opts.loop||o.currIndex<o.group.length-1)?n.isActive&&"video"!==i.contentType&&(n.$progress&&e.fancybox.animate(n.$progress.show(),{scaleX:1},i.opts.slideShow.speed),n.timer=setTimeout(function(){o.current.opts.loop||o.current.index!=o.group.length-1?o.next():o.jumpTo(0)},i.opts.slideShow.speed)):(n.stop(),o.idleSecondsCounter=0,o.showControls())},clear:function(){var t=this;clearTimeout(t.timer),t.timer=null,t.$progress&&t.$progress.removeAttr("style").hide()},start:function(){var t=this,e=t.instance.current;e&&(t.$button.attr("title",(e.opts.i18n[e.opts.lang]||e.opts.i18n.en).PLAY_STOP).removeClass("fancybox-button--play").addClass("fancybox-button--pause"),t.isActive=!0,e.isComplete&&t.set(!0),t.instance.trigger("onSlideShowChange",!0))},stop:function(){var t=this,e=t.instance.current;t.clear(),t.$button.attr("title",(e.opts.i18n[e.opts.lang]||e.opts.i18n.en).PLAY_START).removeClass("fancybox-button--pause").addClass("fancybox-button--play"),t.isActive=!1,t.instance.trigger("onSlideShowChange",!1),t.$progress&&t.$progress.removeAttr("style").hide()},toggle:function(){var t=this;t.isActive?t.stop():t.start()}}),e(t).on({"onInit.fb":function(t,e){e&&!e.SlideShow&&(e.SlideShow=new n(e))},"beforeShow.fb":function(t,e,n,o){var i=e&&e.SlideShow;o?i&&n.opts.slideShow.autoStart&&i.start():i&&i.isActive&&i.clear()},"afterShow.fb":function(t,e,n){var o=e&&e.SlideShow;o&&o.isActive&&o.set()},"afterKeydown.fb":function(n,o,i,a,s){var r=o&&o.SlideShow;!r||!i.opts.slideShow||80!==s&&32!==s||e(t.activeElement).is("button,a,input")||(a.preventDefault(),r.toggle())},"beforeClose.fb onDeactivate.fb":function(t,e){var n=e&&e.SlideShow;n&&n.stop()}}),e(t).on("visibilitychange",function(){var n=e.fancybox.getInstance(),o=n&&n.SlideShow;o&&o.isActive&&(t.hidden?o.clear():o.set())})}(document,jQuery),function(t,e){"use strict";var n=function(){for(var e=[["requestFullscreen","exitFullscreen","fullscreenElement","fullscreenEnabled","fullscreenchange","fullscreenerror"],["webkitRequestFullscreen","webkitExitFullscreen","webkitFullscreenElement","webkitFullscreenEnabled","webkitfullscreenchange","webkitfullscreenerror"],["webkitRequestFullScreen","webkitCancelFullScreen","webkitCurrentFullScreenElement","webkitCancelFullScreen","webkitfullscreenchange","webkitfullscreenerror"],["mozRequestFullScreen","mozCancelFullScreen","mozFullScreenElement","mozFullScreenEnabled","mozfullscreenchange","mozfullscreenerror"],["msRequestFullscreen","msExitFullscreen","msFullscreenElement","msFullscreenEnabled","MSFullscreenChange","MSFullscreenError"]],n={},o=0;o<e.length;o++){var i=e[o];if(i&&i[1]in t){for(var a=0;a<i.length;a++)n[e[0][a]]=i[a];return n}}return!1}();if(n){var o={request:function(e){e=e||t.documentElement,e[n.requestFullscreen](e.ALLOW_KEYBOARD_INPUT)},exit:function(){t[n.exitFullscreen]()},toggle:function(e){e=e||t.documentElement,this.isFullscreen()?this.exit():this.request(e)},isFullscreen:function(){return Boolean(t[n.fullscreenElement])},enabled:function(){return Boolean(t[n.fullscreenEnabled])}};e.extend(!0,e.fancybox.defaults,{btnTpl:{fullScreen:'<button data-fancybox-fullscreen class="fancybox-button fancybox-button--fsenter" title="{{FULL_SCREEN}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z"/></svg></button>'},fullScreen:{autoStart:!1}}),e(t).on(n.fullscreenchange,function(){var t=o.isFullscreen(),n=e.fancybox.getInstance();n&&(n.current&&"image"===n.current.type&&n.isAnimating&&(n.isAnimating=!1,n.update(!0,!0,0),n.isComplete||n.complete()),n.trigger("onFullscreenChange",t),n.$refs.container.toggleClass("fancybox-is-fullscreen",t),n.$refs.toolbar.find("[data-fancybox-fullscreen]").toggleClass("fancybox-button--fsenter",!t).toggleClass("fancybox-button--fsexit",t))})}e(t).on({"onInit.fb":function(t,e){var i;if(!n)return void e.$refs.toolbar.find("[data-fancybox-fullscreen]").remove();e&&e.group[e.currIndex].opts.fullScreen?(i=e.$refs.container,i.on("click.fb-fullscreen","[data-fancybox-fullscreen]",function(t){t.stopPropagation(),t.preventDefault(),o.toggle()}),e.opts.fullScreen&&!0===e.opts.fullScreen.autoStart&&o.request(),e.FullScreen=o):e&&e.$refs.toolbar.find("[data-fancybox-fullscreen]").hide()},"afterKeydown.fb":function(t,e,n,o,i){e&&e.FullScreen&&70===i&&(o.preventDefault(),e.FullScreen.toggle())},"beforeClose.fb":function(t,e){e&&e.FullScreen&&e.$refs.container.hasClass("fancybox-is-fullscreen")&&o.exit()}})}(document,jQuery),function(t,e){"use strict";var n="fancybox-thumbs";e.fancybox.defaults=e.extend(!0,{btnTpl:{thumbs:'<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.59 14.59h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76H5.65V5.65z"/></svg></button>'},thumbs:{autoStart:!1,hideOnClose:!0,parentEl:".fancybox-container",axis:"y"}},e.fancybox.defaults);var o=function(t){this.init(t)};e.extend(o.prototype,{$button:null,$grid:null,$list:null,isVisible:!1,isActive:!1,init:function(t){var e=this,n=t.group,o=0;e.instance=t,e.opts=n[t.currIndex].opts.thumbs,t.Thumbs=e,e.$button=t.$refs.toolbar.find("[data-fancybox-thumbs]");for(var i=0,a=n.length;i<a&&(n[i].thumb&&o++,!(o>1));i++);o>1&&e.opts?(e.$button.removeAttr("style").on("click",function(){e.toggle()}),e.isActive=!0):e.$button.hide()},create:function(){var t,o=this,i=o.instance,a=o.opts.parentEl,s=[];o.$grid||(o.$grid=e('<div class="'+n+" "+n+"-"+o.opts.axis+'"></div>').appendTo(i.$refs.container.find(a).addBack().filter(a)),o.$grid.on("click","a",function(){i.jumpTo(e(this).attr("data-index"))})),o.$list||(o.$list=e('<div class="'+n+'__list">').appendTo(o.$grid)),e.each(i.group,function(e,n){t=n.thumb,t||"image"!==n.type||(t=n.src),s.push('<a href="javascript:;" tabindex="0" data-index="'+e+'"'+(t&&t.length?' style="background-image:url('+t+')"':'class="fancybox-thumbs-missing"')+"></a>")}),o.$list[0].innerHTML=s.join(""),"x"===o.opts.axis&&o.$list.width(parseInt(o.$grid.css("padding-right"),10)+i.group.length*o.$list.children().eq(0).outerWidth(!0))},focus:function(t){var e,n,o=this,i=o.$list,a=o.$grid;o.instance.current&&(e=i.children().removeClass("fancybox-thumbs-active").filter('[data-index="'+o.instance.current.index+'"]').addClass("fancybox-thumbs-active"),n=e.position(),"y"===o.opts.axis&&(n.top<0||n.top>i.height()-e.outerHeight())?i.stop().animate({scrollTop:i.scrollTop()+n.top},t):"x"===o.opts.axis&&(n.left<a.scrollLeft()||n.left>a.scrollLeft()+(a.width()-e.outerWidth()))&&i.parent().stop().animate({scrollLeft:n.left},t))},update:function(){var t=this;t.instance.$refs.container.toggleClass("fancybox-show-thumbs",this.isVisible),t.isVisible?(t.$grid||t.create(),t.instance.trigger("onThumbsShow"),t.focus(0)):t.$grid&&t.instance.trigger("onThumbsHide"),t.instance.update()},hide:function(){this.isVisible=!1,this.update()},show:function(){this.isVisible=!0,this.update()},toggle:function(){this.isVisible=!this.isVisible,this.update()}}),e(t).on({"onInit.fb":function(t,e){var n;e&&!e.Thumbs&&(n=new o(e),n.isActive&&!0===n.opts.autoStart&&n.show())},"beforeShow.fb":function(t,e,n,o){var i=e&&e.Thumbs;i&&i.isVisible&&i.focus(o?0:250)},"afterKeydown.fb":function(t,e,n,o,i){var a=e&&e.Thumbs;a&&a.isActive&&71===i&&(o.preventDefault(),a.toggle())},"beforeClose.fb":function(t,e){var n=e&&e.Thumbs;n&&n.isVisible&&!1!==n.opts.hideOnClose&&n.$grid.hide()}})}(document,jQuery),function(t,e){"use strict";function n(t){var e={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;","`":"&#x60;","=":"&#x3D;"};return String(t).replace(/[&<>"'`=\/]/g,function(t){return e[t]})}e.extend(!0,e.fancybox.defaults,{btnTpl:{share:'<button data-fancybox-share class="fancybox-button fancybox-button--share" title="{{SHARE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2.55 19c1.4-8.4 9.1-9.8 11.9-9.8V5l7 7-7 6.3v-3.5c-2.8 0-10.5 2.1-11.9 4.2z"/></svg></button>'},share:{url:function(t,e){return!t.currentHash&&"inline"!==e.type&&"html"!==e.type&&(e.origSrc||e.src)||window.location},
tpl:'<div class="fancybox-share"><h1>{{SHARE}}</h1><p><a class="fancybox-share__button fancybox-share__button--fb" href="https://www.facebook.com/sharer/sharer.php?u={{url}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196" /></svg><span>Facebook</span></a><a class="fancybox-share__button fancybox-share__button--tw" href="https://twitter.com/intent/tweet?url={{url}}&text={{descr}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z" /></svg><span>Twitter</span></a><a class="fancybox-share__button fancybox-share__button--pt" href="https://www.pinterest.com/pin/create/button/?url={{url}}&description={{descr}}&media={{media}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z" fill="#fff"/></svg><span>Pinterest</span></a></p><p><input class="fancybox-share__input" type="text" value="{{url_raw}}" onclick="select()" /></p></div>'}}),e(t).on("click","[data-fancybox-share]",function(){var t,o,i=e.fancybox.getInstance(),a=i.current||null;a&&("function"===e.type(a.opts.share.url)&&(t=a.opts.share.url.apply(a,[i,a])),o=a.opts.share.tpl.replace(/\{\{media\}\}/g,"image"===a.type?encodeURIComponent(a.src):"").replace(/\{\{url\}\}/g,encodeURIComponent(t)).replace(/\{\{url_raw\}\}/g,n(t)).replace(/\{\{descr\}\}/g,i.$caption?encodeURIComponent(i.$caption.text()):""),e.fancybox.open({src:i.translate(i,o),type:"html",opts:{touch:!1,animationEffect:!1,afterLoad:function(t,e){i.$refs.container.one("beforeClose.fb",function(){t.close(null,0)}),e.$content.find(".fancybox-share__button").click(function(){return window.open(this.href,"Share","width=550, height=450"),!1})},mobile:{autoFocus:!1}}}))})}(document,jQuery),function(t,e,n){"use strict";function o(){var e=t.location.hash.substr(1),n=e.split("-"),o=n.length>1&&/^\+?\d+$/.test(n[n.length-1])?parseInt(n.pop(-1),10)||1:1,i=n.join("-");return{hash:e,index:o<1?1:o,gallery:i}}function i(t){""!==t.gallery&&n("[data-fancybox='"+n.escapeSelector(t.gallery)+"']").eq(t.index-1).focus().trigger("click.fb-start")}function a(t){var e,n;return!!t&&(e=t.current?t.current.opts:t.opts,""!==(n=e.hash||(e.$orig?e.$orig.data("fancybox")||e.$orig.data("fancybox-trigger"):""))&&n)}n.escapeSelector||(n.escapeSelector=function(t){return(t+"").replace(/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,function(t,e){return e?"\0"===t?"�":t.slice(0,-1)+"\\"+t.charCodeAt(t.length-1).toString(16)+" ":"\\"+t})}),n(function(){!1!==n.fancybox.defaults.hash&&(n(e).on({"onInit.fb":function(t,e){var n,i;!1!==e.group[e.currIndex].opts.hash&&(n=o(),(i=a(e))&&n.gallery&&i==n.gallery&&(e.currIndex=n.index-1))},"beforeShow.fb":function(n,o,i,s){var r;i&&!1!==i.opts.hash&&(r=a(o))&&(o.currentHash=r+(o.group.length>1?"-"+(i.index+1):""),t.location.hash!=="#"+o.currentHash&&(s&&!o.origHash&&(o.origHash=t.location.hash),o.hashTimer&&clearTimeout(o.hashTimer),o.hashTimer=setTimeout(function(){"replaceState"in t.history?(t.history[s?"pushState":"replaceState"]({},e.title,t.location.pathname+t.location.search+"#"+o.currentHash),s&&(o.hasCreatedHistory=!0)):t.location.hash=o.currentHash,o.hashTimer=null},300)))},"beforeClose.fb":function(n,o,i){i&&!1!==i.opts.hash&&(clearTimeout(o.hashTimer),o.currentHash&&o.hasCreatedHistory?t.history.back():o.currentHash&&("replaceState"in t.history?t.history.replaceState({},e.title,t.location.pathname+t.location.search+(o.origHash||"")):t.location.hash=o.origHash),o.currentHash=null)}}),n(t).on("hashchange.fb",function(){var t=o(),e=null;n.each(n(".fancybox-container").get().reverse(),function(t,o){var i=n(o).data("FancyBox");if(i&&i.currentHash)return e=i,!1}),e?e.currentHash===t.gallery+"-"+t.index||1===t.index&&e.currentHash==t.gallery||(e.currentHash=null,e.close()):""!==t.gallery&&i(t)}),setTimeout(function(){n.fancybox.getInstance()||i(o())},50))})}(window,document,jQuery),function(t,e){"use strict";var n=(new Date).getTime();e(t).on({"onInit.fb":function(t,e,o){e.$refs.stage.on("mousewheel DOMMouseScroll wheel MozMousePixelScroll",function(t){var o=e.current,i=(new Date).getTime();e.group.length<2||!1===o.opts.wheel||"auto"===o.opts.wheel&&"image"!==o.type||(t.preventDefault(),t.stopPropagation(),o.$slide.hasClass("fancybox-animated")||(t=t.originalEvent||t,i-n<250||(n=i,e[(-t.deltaY||-t.deltaX||t.wheelDelta||-t.detail)<0?"next":"previous"]())))})}})}(document,jQuery);
},{}],4:[function(require,module,exports){
/*
 * International Telephone Input v18.2.1
 * https://github.com/jackocnr/intl-tel-input.git
 * Licensed under the MIT license
 */

!function(a){var b=function(a,b,c){"use strict";return function(){function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}function f(a,b,c){return b&&e(a.prototype,b),c&&e(a,c),a}for(var g=[["Afghanistan (‫افغانستان‬‎)","af","93"],["Albania (Shqipëri)","al","355"],["Algeria (‫الجزائر‬‎)","dz","213"],["American Samoa","as","1",5,["684"]],["Andorra","ad","376"],["Angola","ao","244"],["Anguilla","ai","1",6,["264"]],["Antigua and Barbuda","ag","1",7,["268"]],["Argentina","ar","54"],["Armenia (Հայաստան)","am","374"],["Aruba","aw","297"],["Australia","au","61",0],["Austria (Österreich)","at","43"],["Azerbaijan (Azərbaycan)","az","994"],["Bahamas","bs","1",8,["242"]],["Bahrain (‫البحرين‬‎)","bh","973"],["Bangladesh (বাংলাদেশ)","bd","880"],["Barbados","bb","1",9,["246"]],["Belarus (Беларусь)","by","375"],["Belgium (België)","be","32"],["Belize","bz","501"],["Benin (Bénin)","bj","229"],["Bermuda","bm","1",10,["441"]],["Bhutan (འབྲུག)","bt","975"],["Bolivia","bo","591"],["Bosnia and Herzegovina (Босна и Херцеговина)","ba","387"],["Botswana","bw","267"],["Brazil (Brasil)","br","55"],["British Indian Ocean Territory","io","246"],["British Virgin Islands","vg","1",11,["284"]],["Brunei","bn","673"],["Bulgaria (България)","bg","359"],["Burkina Faso","bf","226"],["Burundi (Uburundi)","bi","257"],["Cambodia (កម្ពុជា)","kh","855"],["Cameroon (Cameroun)","cm","237"],["Canada","ca","1",1,["204","226","236","249","250","289","306","343","365","387","403","416","418","431","437","438","450","506","514","519","548","579","581","587","604","613","639","647","672","705","709","742","778","780","782","807","819","825","867","873","902","905"]],["Cape Verde (Kabu Verdi)","cv","238"],["Caribbean Netherlands","bq","599",1,["3","4","7"]],["Cayman Islands","ky","1",12,["345"]],["Central African Republic (République centrafricaine)","cf","236"],["Chad (Tchad)","td","235"],["Chile","cl","56"],["China (中国)","cn","86"],["Christmas Island","cx","61",2],["Cocos (Keeling) Islands","cc","61",1],["Colombia","co","57"],["Comoros (‫جزر القمر‬‎)","km","269"],["Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)","cd","243"],["Congo (Republic) (Congo-Brazzaville)","cg","242"],["Cook Islands","ck","682"],["Costa Rica","cr","506"],["Côte d’Ivoire","ci","225"],["Croatia (Hrvatska)","hr","385"],["Cuba","cu","53"],["Curaçao","cw","599",0],["Cyprus (Κύπρος)","cy","357"],["Czech Republic (Česká republika)","cz","420"],["Denmark (Danmark)","dk","45"],["Djibouti","dj","253"],["Dominica","dm","1",13,["767"]],["Dominican Republic (República Dominicana)","do","1",2,["809","829","849"]],["Ecuador","ec","593"],["Egypt (‫مصر‬‎)","eg","20"],["El Salvador","sv","503"],["Equatorial Guinea (Guinea Ecuatorial)","gq","240"],["Eritrea","er","291"],["Estonia (Eesti)","ee","372"],["Ethiopia","et","251"],["Falkland Islands (Islas Malvinas)","fk","500"],["Faroe Islands (Føroyar)","fo","298"],["Fiji","fj","679"],["Finland (Suomi)","fi","358",0],["France","fr","33"],["French Guiana (Guyane française)","gf","594"],["French Polynesia (Polynésie française)","pf","689"],["Gabon","ga","241"],["Gambia","gm","220"],["Georgia (საქართველო)","ge","995"],["Germany (Deutschland)","de","49"],["Ghana (Gaana)","gh","233"],["Gibraltar","gi","350"],["Greece (Ελλάδα)","gr","30"],["Greenland (Kalaallit Nunaat)","gl","299"],["Grenada","gd","1",14,["473"]],["Guadeloupe","gp","590",0],["Guam","gu","1",15,["671"]],["Guatemala","gt","502"],["Guernsey","gg","44",1,["1481","7781","7839","7911"]],["Guinea (Guinée)","gn","224"],["Guinea-Bissau (Guiné Bissau)","gw","245"],["Guyana","gy","592"],["Haiti","ht","509"],["Honduras","hn","504"],["Hong Kong (香港)","hk","852"],["Hungary (Magyarország)","hu","36"],["Iceland (Ísland)","is","354"],["India (भारत)","in","91"],["Indonesia","id","62"],["Iran (‫ایران‬‎)","ir","98"],["Iraq (‫العراق‬‎)","iq","964"],["Ireland","ie","353"],["Isle of Man","im","44",2,["1624","74576","7524","7924","7624"]],["Israel (‫ישראל‬‎)","il","972"],["Italy (Italia)","it","39",0],["Jamaica","jm","1",4,["876","658"]],["Japan (日本)","jp","81"],["Jersey","je","44",3,["1534","7509","7700","7797","7829","7937"]],["Jordan (‫الأردن‬‎)","jo","962"],["Kazakhstan (Казахстан)","kz","7",1,["33","7"]],["Kenya","ke","254"],["Kiribati","ki","686"],["Kosovo","xk","383"],["Kuwait (‫الكويت‬‎)","kw","965"],["Kyrgyzstan (Кыргызстан)","kg","996"],["Laos (ລາວ)","la","856"],["Latvia (Latvija)","lv","371"],["Lebanon (‫لبنان‬‎)","lb","961"],["Lesotho","ls","266"],["Liberia","lr","231"],["Libya (‫ليبيا‬‎)","ly","218"],["Liechtenstein","li","423"],["Lithuania (Lietuva)","lt","370"],["Luxembourg","lu","352"],["Macau (澳門)","mo","853"],["Macedonia (FYROM) (Македонија)","mk","389"],["Madagascar (Madagasikara)","mg","261"],["Malawi","mw","265"],["Malaysia","my","60"],["Maldives","mv","960"],["Mali","ml","223"],["Malta","mt","356"],["Marshall Islands","mh","692"],["Martinique","mq","596"],["Mauritania (‫موريتانيا‬‎)","mr","222"],["Mauritius (Moris)","mu","230"],["Mayotte","yt","262",1,["269","639"]],["Mexico (México)","mx","52"],["Micronesia","fm","691"],["Moldova (Republica Moldova)","md","373"],["Monaco","mc","377"],["Mongolia (Монгол)","mn","976"],["Montenegro (Crna Gora)","me","382"],["Montserrat","ms","1",16,["664"]],["Morocco (‫المغرب‬‎)","ma","212",0],["Mozambique (Moçambique)","mz","258"],["Myanmar (Burma) (မြန်မာ)","mm","95"],["Namibia (Namibië)","na","264"],["Nauru","nr","674"],["Nepal (नेपाल)","np","977"],["Netherlands (Nederland)","nl","31"],["New Caledonia (Nouvelle-Calédonie)","nc","687"],["New Zealand","nz","64"],["Nicaragua","ni","505"],["Niger (Nijar)","ne","227"],["Nigeria","ng","234"],["Niue","nu","683"],["Norfolk Island","nf","672"],["North Korea (조선 민주주의 인민 공화국)","kp","850"],["Northern Mariana Islands","mp","1",17,["670"]],["Norway (Norge)","no","47",0],["Oman (‫عُمان‬‎)","om","968"],["Pakistan (‫پاکستان‬‎)","pk","92"],["Palau","pw","680"],["Palestine (‫فلسطين‬‎)","ps","970"],["Panama (Panamá)","pa","507"],["Papua New Guinea","pg","675"],["Paraguay","py","595"],["Peru (Perú)","pe","51"],["Philippines","ph","63"],["Poland (Polska)","pl","48"],["Portugal","pt","351"],["Puerto Rico","pr","1",3,["787","939"]],["Qatar (‫قطر‬‎)","qa","974"],["Réunion (La Réunion)","re","262",0],["Romania (România)","ro","40"],["Russia (Россия)","ru","7",0],["Rwanda","rw","250"],["Saint Barthélemy","bl","590",1],["Saint Helena","sh","290"],["Saint Kitts and Nevis","kn","1",18,["869"]],["Saint Lucia","lc","1",19,["758"]],["Saint Martin (Saint-Martin (partie française))","mf","590",2],["Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)","pm","508"],["Saint Vincent and the Grenadines","vc","1",20,["784"]],["Samoa","ws","685"],["San Marino","sm","378"],["São Tomé and Príncipe (São Tomé e Príncipe)","st","239"],["Saudi Arabia (‫المملكة العربية السعودية‬‎)","sa","966"],["Senegal (Sénégal)","sn","221"],["Serbia (Србија)","rs","381"],["Seychelles","sc","248"],["Sierra Leone","sl","232"],["Singapore","sg","65"],["Sint Maarten","sx","1",21,["721"]],["Slovakia (Slovensko)","sk","421"],["Slovenia (Slovenija)","si","386"],["Solomon Islands","sb","677"],["Somalia (Soomaaliya)","so","252"],["South Africa","za","27"],["South Korea (대한민국)","kr","82"],["South Sudan (‫جنوب السودان‬‎)","ss","211"],["Spain (España)","es","34"],["Sri Lanka (ශ්‍රී ලංකාව)","lk","94"],["Sudan (‫السودان‬‎)","sd","249"],["Suriname","sr","597"],["Svalbard and Jan Mayen","sj","47",1,["79"]],["Swaziland","sz","268"],["Sweden (Sverige)","se","46"],["Switzerland (Schweiz)","ch","41"],["Syria (‫سوريا‬‎)","sy","963"],["Taiwan (台灣)","tw","886"],["Tajikistan","tj","992"],["Tanzania","tz","255"],["Thailand (ไทย)","th","66"],["Timor-Leste","tl","670"],["Togo","tg","228"],["Tokelau","tk","690"],["Tonga","to","676"],["Trinidad and Tobago","tt","1",22,["868"]],["Tunisia (‫تونس‬‎)","tn","216"],["Turkey (Türkiye)","tr","90"],["Turkmenistan","tm","993"],["Turks and Caicos Islands","tc","1",23,["649"]],["Tuvalu","tv","688"],["U.S. Virgin Islands","vi","1",24,["340"]],["Uganda","ug","256"],["Ukraine (Україна)","ua","380"],["United Arab Emirates (‫الإمارات العربية المتحدة‬‎)","ae","971"],["United Kingdom","gb","44",0],["United States","us","1",0],["Uruguay","uy","598"],["Uzbekistan (Oʻzbekiston)","uz","998"],["Vanuatu","vu","678"],["Vatican City (Città del Vaticano)","va","39",1,["06698"]],["Venezuela","ve","58"],["Vietnam (Việt Nam)","vn","84"],["Wallis and Futuna (Wallis-et-Futuna)","wf","681"],["Western Sahara (‫الصحراء الغربية‬‎)","eh","212",1,["5288","5289"]],["Yemen (‫اليمن‬‎)","ye","967"],["Zambia","zm","260"],["Zimbabwe","zw","263"],["Åland Islands","ax","358",1,["18"]]],h=0;h<g.length;h++){var i=g[h];g[h]={name:i[0],iso2:i[1],dialCode:i[2],priority:i[3]||0,areaCodes:i[4]||null}}a.intlTelInputGlobals={getInstance:function(b){var c=b.getAttribute("data-intl-tel-input-id");return a.intlTelInputGlobals.instances[c]},instances:{}};var j=0,k={allowDropdown:!0,autoHideDialCode:!0,autoPlaceholder:"polite",customContainer:"",customPlaceholder:null,dropdownContainer:null,excludeCountries:[],formatOnDisplay:!0,geoIpLookup:null,hiddenInput:"",initialCountry:"",localizedCountries:null,nationalMode:!0,onlyCountries:[],placeholderNumberType:"MOBILE",preferredCountries:["us","gb"],separateDialCode:!1,utilsScript:""},l=["800","822","833","844","855","866","877","880","881","882","883","884","885","886","887","888","889"];a.addEventListener("load",function(){a.intlTelInputGlobals.windowLoaded=!0});var m=function(a,b){for(var c=Object.keys(a),d=0;d<c.length;d++)b(c[d],a[c[d]])},n=function(b){m(a.intlTelInputGlobals.instances,function(c){a.intlTelInputGlobals.instances[c][b]()})},o=function(){function e(a,b){var c=this;d(this,e),this.id=j++,this.a=a,this.b=null,this.c=null;var f=b||{};this.d={},m(k,function(a,b){c.d[a]=f.hasOwnProperty(a)?f[a]:b}),this.e=Boolean(a.getAttribute("placeholder"))}return f(e,[{key:"_init",value:function(){var a=this;if(this.d.nationalMode&&(this.d.autoHideDialCode=!1),this.d.separateDialCode&&(this.d.autoHideDialCode=this.d.nationalMode=!1),this.g=/Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),this.g&&(b.body.classList.add("iti-mobile"),this.d.dropdownContainer||(this.d.dropdownContainer=b.body)),"undefined"!=typeof Promise){var c=new Promise(function(b,c){a.h=b,a.i=c}),d=new Promise(function(b,c){a.i0=b,a.i1=c});this.promise=Promise.all([c,d])}else this.h=this.i=function(){},this.i0=this.i1=function(){};this.s={},this._b(),this._f(),this._h(),this._i(),this._i3()}},{key:"_b",value:function(){this._d(),this._d2(),this._e(),this.d.localizedCountries&&this._d0(),(this.d.onlyCountries.length||this.d.localizedCountries)&&this.p.sort(this._d1)}},{key:"_c",value:function(a,b,d){b.length>this.dialCodeMaxLen&&(this.dialCodeMaxLen=b.length),this.q.hasOwnProperty(b)||(this.q[b]=[]);for(var e=0;e<this.q[b].length;e++)if(this.q[b][e]===a)return;var f=d!==c?d:this.q[b].length;this.q[b][f]=a}},{key:"_d",value:function(){if(this.d.onlyCountries.length){var a=this.d.onlyCountries.map(function(a){return a.toLowerCase()});this.p=g.filter(function(b){return a.indexOf(b.iso2)>-1})}else if(this.d.excludeCountries.length){var b=this.d.excludeCountries.map(function(a){return a.toLowerCase()});this.p=g.filter(function(a){return-1===b.indexOf(a.iso2)})}else this.p=g}},{key:"_d0",value:function(){for(var a=0;a<this.p.length;a++){var b=this.p[a].iso2.toLowerCase();this.d.localizedCountries.hasOwnProperty(b)&&(this.p[a].name=this.d.localizedCountries[b])}}},{key:"_d1",value:function(a,b){return a.name.localeCompare(b.name)}},{key:"_d2",value:function(){this.dialCodeMaxLen=0,this.q={};for(var a=0;a<this.p.length;a++){var b=this.p[a];this._c(b.iso2,b.dialCode,b.priority)}for(var c=0;c<this.p.length;c++){var d=this.p[c];if(d.areaCodes)for(var e=this.q[d.dialCode][0],f=0;f<d.areaCodes.length;f++){for(var g=d.areaCodes[f],h=1;h<g.length;h++){var i=d.dialCode+g.substr(0,h);this._c(e,i),this._c(d.iso2,i)}this._c(d.iso2,d.dialCode+g)}}}},{key:"_e",value:function(){this.preferredCountries=[];for(var a=0;a<this.d.preferredCountries.length;a++){var b=this.d.preferredCountries[a].toLowerCase(),c=this._y(b,!1,!0);c&&this.preferredCountries.push(c)}}},{key:"_e2",value:function(a,c,d){var e=b.createElement(a);return c&&m(c,function(a,b){return e.setAttribute(a,b)}),d&&d.appendChild(e),e}},{key:"_f",value:function(){this.a.setAttribute("autocomplete","off");var a="iti";this.d.allowDropdown&&(a+=" iti--allow-dropdown"),this.d.separateDialCode&&(a+=" iti--separate-dial-code"),this.d.customContainer&&(a+=" ",a+=this.d.customContainer);var b=this._e2("div",{"class":a});if(this.a.parentNode.insertBefore(b,this.a),this.k=this._e2("div",{"class":"iti__flag-container"},b),b.appendChild(this.a),this.selectedFlag=this._e2("div",{"class":"iti__selected-flag",role:"combobox","aria-owns":"country-listbox"},this.k),this.l=this._e2("div",{"class":"iti__flag"},this.selectedFlag),this.d.separateDialCode&&(this.t=this._e2("div",{"class":"iti__selected-dial-code"},this.selectedFlag)),this.d.allowDropdown&&(this.selectedFlag.setAttribute("tabindex","0"),this.u=this._e2("div",{"class":"iti__arrow"},this.selectedFlag),this.m=this._e2("ul",{"class":"iti__country-list iti__hide",id:"country-listbox","aria-expanded":"false",role:"listbox"}),this.preferredCountries.length&&(this._g(this.preferredCountries,"iti__preferred"),this._e2("li",{"class":"iti__divider",role:"separator","aria-disabled":"true"},this.m)),this._g(this.p,"iti__standard"),this.d.dropdownContainer?(this.dropdown=this._e2("div",{"class":"iti iti--container"}),this.dropdown.appendChild(this.m)):this.k.appendChild(this.m)),this.d.hiddenInput){var c=this.d.hiddenInput,d=this.a.getAttribute("name");if(d){var e=d.lastIndexOf("[");-1!==e&&(c="".concat(d.substr(0,e),"[").concat(c,"]"))}this.hiddenInput=this._e2("input",{type:"hidden",name:c}),b.appendChild(this.hiddenInput)}}},{key:"_g",value:function(a,b){for(var c="",d=0;d<a.length;d++){var e=a[d];c+="<li class='iti__country ".concat(b,"' tabIndex='-1' id='iti-item-").concat(e.iso2,"' role='option' data-dial-code='").concat(e.dialCode,"' data-country-code='").concat(e.iso2,"'>"),c+="<div class='iti__flag-box'><div class='iti__flag iti__".concat(e.iso2,"'></div></div>"),c+="<span class='iti__country-name'>".concat(e.name,"</span>"),c+="<span class='iti__dial-code'>+".concat(e.dialCode,"</span>"),c+="</li>"}this.m.insertAdjacentHTML("beforeend",c)}},{key:"_h",value:function(){var a=this.a.value,b=this._5(a),c=this._w(a),d=this.d,e=d.initialCountry,f=d.nationalMode,g=d.autoHideDialCode,h=d.separateDialCode;b&&!c?this._v(a):"auto"!==e&&(e?this._z(e.toLowerCase()):b&&c?this._z("us"):(this.j=this.preferredCountries.length?this.preferredCountries[0].iso2:this.p[0].iso2,a||this._z(this.j)),a||f||g||h||(this.a.value="+".concat(this.s.dialCode))),a&&this._u(a)}},{key:"_i",value:function(){this._j(),this.d.autoHideDialCode&&this._l(),this.d.allowDropdown&&this._i2(),this.hiddenInput&&this._i0()}},{key:"_i0",value:function(){var a=this;this._a14=function(){a.hiddenInput.value=a.getNumber()},this.a.form&&this.a.form.addEventListener("submit",this._a14)}},{key:"_i1",value:function(){for(var a=this.a;a&&"LABEL"!==a.tagName;)a=a.parentNode;return a}},{key:"_i2",value:function(){var a=this;this._a9=function(b){a.m.classList.contains("iti__hide")?a.a.focus():b.preventDefault()};var b=this._i1();b&&b.addEventListener("click",this._a9),this._a10=function(){!a.m.classList.contains("iti__hide")||a.a.disabled||a.a.readOnly||a._n()},this.selectedFlag.addEventListener("click",this._a10),this._a11=function(b){a.m.classList.contains("iti__hide")&&-1!==["ArrowUp","ArrowDown"," ","Enter"].indexOf(b.key)&&(b.preventDefault(),b.stopPropagation(),a._n()),"Tab"===b.key&&a._2()},this.k.addEventListener("keydown",this._a11)}},{key:"_i3",value:function(){var b=this;this.d.utilsScript&&!a.intlTelInputUtils?a.intlTelInputGlobals.windowLoaded?a.intlTelInputGlobals.loadUtils(this.d.utilsScript):a.addEventListener("load",function(){a.intlTelInputGlobals.loadUtils(b.d.utilsScript)}):this.i0(),"auto"===this.d.initialCountry?this._i4():this.h()}},{key:"_i4",value:function(){a.intlTelInputGlobals.autoCountry?this.handleAutoCountry():a.intlTelInputGlobals.startedLoadingAutoCountry||(a.intlTelInputGlobals.startedLoadingAutoCountry=!0,"function"==typeof this.d.geoIpLookup&&this.d.geoIpLookup(function(b){a.intlTelInputGlobals.autoCountry=b.toLowerCase(),setTimeout(function(){return n("handleAutoCountry")})},function(){return n("rejectAutoCountryPromise")}))}},{key:"_j",value:function(){var a=this;this._a12=function(){a._v(a.a.value)&&a._8()},this.a.addEventListener("keyup",this._a12),this._a13=function(){setTimeout(a._a12)},this.a.addEventListener("cut",this._a13),this.a.addEventListener("paste",this._a13)}},{key:"_j2",value:function(a){var b=this.a.getAttribute("maxlength");return b&&a.length>b?a.substr(0,b):a}},{key:"_l",value:function(){var a=this;this._a8=function(){a._l2()},this.a.form&&this.a.form.addEventListener("submit",this._a8),this.a.addEventListener("blur",this._a8)}},{key:"_l2",value:function(){if("+"===this.a.value.charAt(0)){var a=this._m(this.a.value);a&&this.s.dialCode!==a||(this.a.value="")}}},{key:"_m",value:function(a){return a.replace(/\D/g,"")}},{key:"_m2",value:function(a){var c=b.createEvent("Event");c.initEvent(a,!0,!0),this.a.dispatchEvent(c)}},{key:"_n",value:function(){this.m.classList.remove("iti__hide"),this.m.setAttribute("aria-expanded","true"),this._o(),this.b&&(this._x(this.b,!1),this._3(this.b,!0)),this._p(),this.u.classList.add("iti__arrow--up"),this._m2("open:countrydropdown")}},{key:"_n2",value:function(a,b,c){c&&!a.classList.contains(b)?a.classList.add(b):!c&&a.classList.contains(b)&&a.classList.remove(b)}},{key:"_o",value:function(){var c=this;if(this.d.dropdownContainer&&this.d.dropdownContainer.appendChild(this.dropdown),!this.g){var d=this.a.getBoundingClientRect(),e=a.pageYOffset||b.documentElement.scrollTop,f=d.top+e,g=this.m.offsetHeight,h=f+this.a.offsetHeight+g<e+a.innerHeight,i=f-g>e;if(this._n2(this.m,"iti__country-list--dropup",!h&&i),this.d.dropdownContainer){var j=!h&&i?0:this.a.offsetHeight;this.dropdown.style.top="".concat(f+j,"px"),this.dropdown.style.left="".concat(d.left+b.body.scrollLeft,"px"),this._a4=function(){return c._2()},a.addEventListener("scroll",this._a4)}}}},{key:"_o2",value:function(a){for(var b=a;b&&b!==this.m&&!b.classList.contains("iti__country");)b=b.parentNode;return b===this.m?null:b}},{key:"_p",value:function(){var a=this;this._a0=function(b){var c=a._o2(b.target);c&&a._x(c,!1)},this.m.addEventListener("mouseover",this._a0),this._a1=function(b){var c=a._o2(b.target);c&&a._1(c)},this.m.addEventListener("click",this._a1);var c=!0;this._a2=function(){c||a._2(),c=!1},b.documentElement.addEventListener("click",this._a2);var d="",e=null;this._a3=function(b){b.preventDefault(),"ArrowUp"===b.key||"ArrowDown"===b.key?a._q(b.key):"Enter"===b.key?a._r():"Escape"===b.key?a._2():/^[a-zA-ZÀ-ÿ ]$/.test(b.key)&&(e&&clearTimeout(e),d+=b.key.toLowerCase(),a._s(d),e=setTimeout(function(){d=""},1e3))},b.addEventListener("keydown",this._a3)}},{key:"_q",value:function(a){var b="ArrowUp"===a?this.c.previousElementSibling:this.c.nextElementSibling;b&&(b.classList.contains("iti__divider")&&(b="ArrowUp"===a?b.previousElementSibling:b.nextElementSibling),this._x(b,!0))}},{key:"_r",value:function(){this.c&&this._1(this.c)}},{key:"_s",value:function(a){for(var b=0;b<this.p.length;b++)if(this._t(this.p[b].name,a)){var c=this.m.querySelector("#iti-item-".concat(this.p[b].iso2));this._x(c,!1),this._3(c,!0);break}}},{key:"_t",value:function(a,b){return a.substr(0,b.length).toLowerCase()===b}},{key:"_u",value:function(b){var c=b;if(this.d.formatOnDisplay&&a.intlTelInputUtils&&this.s){var d=!this.d.separateDialCode&&(this.d.nationalMode||"+"!==c.charAt(0)),e=intlTelInputUtils.numberFormat,f=e.NATIONAL,g=e.INTERNATIONAL,h=d?f:g;c=intlTelInputUtils.formatNumber(c,this.s.iso2,h)}c=this._7(c),this.a.value=c}},{key:"_v",value:function(a){var b=a,c=this.s.dialCode,d="1"===c;b&&this.d.nationalMode&&d&&"+"!==b.charAt(0)&&("1"!==b.charAt(0)&&(b="1".concat(b)),b="+".concat(b)),this.d.separateDialCode&&c&&"+"!==b.charAt(0)&&(b="+".concat(c).concat(b));var e=this._5(b),f=this._m(b),g=null;if(e){var h=this.q[this._m(e)],i=-1!==h.indexOf(this.s.iso2)&&f.length<=e.length-1;if(!("1"===c&&this._w(f))&&!i)for(var j=0;j<h.length;j++)if(h[j]){g=h[j];break}}else"+"===b.charAt(0)&&f.length?g="":b&&"+"!==b||(g=this.j);return null!==g&&this._z(g)}},{key:"_w",value:function(a){var b=this._m(a);if("1"===b.charAt(0)){var c=b.substr(1,3);return-1!==l.indexOf(c)}return!1}},{key:"_x",value:function(a,b){var c=this.c;c&&c.classList.remove("iti__highlight"),this.c=a,this.c.classList.add("iti__highlight"),b&&this.c.focus()}},{key:"_y",value:function(a,b,c){for(var d=b?g:this.p,e=0;e<d.length;e++)if(d[e].iso2===a)return d[e];if(c)return null;throw new Error("No country data for '".concat(a,"'"))}},{key:"_z",value:function(a){var b=this.s.iso2?this.s:{};this.s=a?this._y(a,!1,!1):{},this.s.iso2&&(this.j=this.s.iso2),this.l.setAttribute("class","iti__flag iti__".concat(a));var c=a?"".concat(this.s.name,": +").concat(this.s.dialCode):"Unknown";if(this.selectedFlag.setAttribute("title",c),this.d.separateDialCode){var d=this.s.dialCode?"+".concat(this.s.dialCode):"";this.t.innerHTML=d;var e=this.selectedFlag.offsetWidth||this._getHiddenSelectedFlagWidth();this.a.style.paddingLeft="".concat(e+6,"px")}if(this._0(),this.d.allowDropdown){var f=this.b;if(f&&(f.classList.remove("iti__active"),f.setAttribute("aria-selected","false")),a){var g=this.m.querySelector("#iti-item-".concat(a));g.setAttribute("aria-selected","true"),g.classList.add("iti__active"),this.b=g,this.m.setAttribute("aria-activedescendant",g.getAttribute("id"))}}return b.iso2!==a}},{key:"_getHiddenSelectedFlagWidth",value:function(){var a=this.a.parentNode.cloneNode();a.style.visibility="hidden",b.body.appendChild(a);var c=this.selectedFlag.cloneNode(!0);a.appendChild(c);var d=c.offsetWidth;return a.remove(),d}},{key:"_0",value:function(){var b="aggressive"===this.d.autoPlaceholder||!this.e&&"polite"===this.d.autoPlaceholder;if(a.intlTelInputUtils&&b){var c=intlTelInputUtils.numberType[this.d.placeholderNumberType],d=this.s.iso2?intlTelInputUtils.getExampleNumber(this.s.iso2,this.d.nationalMode,c):"";d=this._7(d),"function"==typeof this.d.customPlaceholder&&(d=this.d.customPlaceholder(d,this.s)),this.a.setAttribute("placeholder",d)}}},{key:"_1",value:function(a){var b=this._z(a.getAttribute("data-country-code"));this._2(),this._4(a.getAttribute("data-dial-code"),!0),this.a.focus();var c=this.a.value.length;this.a.setSelectionRange(c,c),b&&this._8()}},{key:"_2",value:function(){this.m.classList.add("iti__hide"),this.m.setAttribute("aria-expanded","false"),this.u.classList.remove("iti__arrow--up"),b.removeEventListener("keydown",this._a3),b.documentElement.removeEventListener("click",this._a2),this.m.removeEventListener("mouseover",this._a0),this.m.removeEventListener("click",this._a1),this.d.dropdownContainer&&(this.g||a.removeEventListener("scroll",this._a4),this.dropdown.parentNode&&this.dropdown.parentNode.removeChild(this.dropdown)),this._m2("close:countrydropdown")}},{key:"_3",value:function(c,d){var e=this.m,f=a.pageYOffset||b.documentElement.scrollTop,g=e.offsetHeight,h=e.getBoundingClientRect().top+f,i=h+g,j=c.offsetHeight,k=c.getBoundingClientRect().top+f,l=k+j,m=k-h+e.scrollTop,n=g/2-j/2;if(k<h)d&&(m-=n),e.scrollTop=m;else if(l>i){d&&(m+=n);var o=g-j;e.scrollTop=m-o}}},{key:"_4",value:function(a,b){var c,d=this.a.value,e="+".concat(a);if("+"===d.charAt(0)){var f=this._5(d);c=f?d.replace(f,e):e}else{if(this.d.nationalMode||this.d.separateDialCode)return;if(d)c=e+d;else{if(!b&&this.d.autoHideDialCode)return;c=e}}this.a.value=c}},{key:"_5",value:function(a){var b="";if("+"===a.charAt(0))for(var c="",d=0;d<a.length;d++){var e=a.charAt(d);if(!isNaN(parseInt(e,10))&&(c+=e,this.q[c]&&(b=a.substr(0,d+1)),c.length===this.dialCodeMaxLen))break}return b}},{key:"_6",value:function(){var a=this.a.value.trim(),b=this.s.dialCode,c=this._m(a);return(this.d.separateDialCode&&"+"!==a.charAt(0)&&b&&c?"+".concat(b):"")+a}},{key:"_7",value:function(a){var b=a;if(this.d.separateDialCode){var c=this._5(b);if(c){c="+".concat(this.s.dialCode);var d=" "===b[c.length]||"-"===b[c.length]?c.length+1:c.length;b=b.substr(d)}}return this._j2(b)}},{key:"_8",value:function(){this._m2("countrychange")}},{key:"handleAutoCountry",value:function(){"auto"===this.d.initialCountry&&(this.j=a.intlTelInputGlobals.autoCountry,this.a.value||this.setCountry(this.j),this.h())}},{key:"handleUtils",value:function(){a.intlTelInputUtils&&(this.a.value&&this._u(this.a.value),this._0()),this.i0()}},{key:"destroy",value:function(){var b=this.a.form;if(this.d.allowDropdown){this._2(),this.selectedFlag.removeEventListener("click",this._a10),this.k.removeEventListener("keydown",this._a11);var c=this._i1();c&&c.removeEventListener("click",this._a9)}this.hiddenInput&&b&&b.removeEventListener("submit",this._a14),this.d.autoHideDialCode&&(b&&b.removeEventListener("submit",this._a8),this.a.removeEventListener("blur",this._a8)),this.a.removeEventListener("keyup",this._a12),this.a.removeEventListener("cut",this._a13),this.a.removeEventListener("paste",this._a13),this.a.removeAttribute("data-intl-tel-input-id");var d=this.a.parentNode;d.parentNode.insertBefore(this.a,d),d.parentNode.removeChild(d),delete a.intlTelInputGlobals.instances[this.id]}},{key:"getExtension",value:function(){return a.intlTelInputUtils?intlTelInputUtils.getExtension(this._6(),this.s.iso2):""}},{key:"getNumber",value:function(b){if(a.intlTelInputUtils){var c=this.s.iso2;return intlTelInputUtils.formatNumber(this._6(),c,b)}return""}},{key:"getNumberType",value:function(){return a.intlTelInputUtils?intlTelInputUtils.getNumberType(this._6(),this.s.iso2):-99}},{key:"getSelectedCountryData",value:function(){return this.s}},{key:"getValidationError",value:function(){if(a.intlTelInputUtils){var b=this.s.iso2;return intlTelInputUtils.getValidationError(this._6(),b)}return-99}},{key:"isValidNumber",value:function(){var b=this._6().trim(),c=this.d.nationalMode?this.s.iso2:"";return a.intlTelInputUtils?intlTelInputUtils.isValidNumber(b,c):null}},{key:"setCountry",value:function(a){var b=a.toLowerCase();this.l.classList.contains("iti__".concat(b))||(this._z(b),this._4(this.s.dialCode,!1),this._8())}},{key:"setNumber",value:function(a){var b=this._v(a);this._u(a),b&&this._8()}},{key:"setPlaceholderNumberType",value:function(a){this.d.placeholderNumberType=a,this._0()}}]),e}()
;a.intlTelInputGlobals.getCountryData=function(){return g};var p=function(a,c,d){var e=b.createElement("script");e.onload=function(){n("handleUtils"),c&&c()},e.onerror=function(){n("rejectUtilsScriptPromise"),d&&d()},e.className="iti-load-utils",e.async=!0,e.src=a,b.body.appendChild(e)};return a.intlTelInputGlobals.loadUtils=function(b){if(!a.intlTelInputUtils&&!a.intlTelInputGlobals.startedLoadingUtilsScript){if(a.intlTelInputGlobals.startedLoadingUtilsScript=!0,"undefined"!=typeof Promise)return new Promise(function(a,c){return p(b,a,c)});p(b)}return null},a.intlTelInputGlobals.defaults=k,a.intlTelInputGlobals.version="16.0.0",function(b,c){var d=new o(b,c);return d._init(),b.setAttribute("data-intl-tel-input-id",d.id),a.intlTelInputGlobals.instances[d.id]=d,d}}()}(window,document);"object"==typeof module&&module.exports?module.exports=b:window.intlTelInput=b}();
},{}],5:[function(require,module,exports){
/*!
  Zoom 1.7.21
  license: MIT
  http://www.jacklmoore.com/zoom
*/
(function ($) {
  var defaults = {
    url: false,
    callback: false,
    target: false,
    duration: 120,
    on: 'mouseover', // other options: grab, click, toggle
    touch: true, // enables a touch fallback
    onZoomIn: false,
    onZoomOut: false,
    magnify: 1
  };

  // Core Zoom Logic, independent of event listeners.
  $.zoom = function (target, source, img, magnify) {
    var targetHeight,
      targetWidth,
      sourceHeight,
      sourceWidth,
      xRatio,
      yRatio,
      offset,
      $target = $(target),
      position = $target.css('position'),
      $source = $(source);

    // The parent element needs positioning so that the zoomed element can be correctly positioned within.
    target.style.position = /(absolute|fixed)/.test(position) ? position : 'relative';
    target.style.overflow = 'hidden';
    img.style.width = img.style.height = '';

    $(img)
      .addClass('zoomImg')
      .css({
        position: 'absolute',
        top: 0,
        left: 0,
        opacity: 0,
        width: img.width * magnify,
        height: img.height * magnify,
        border: 'none',
        maxWidth: 'none',
        maxHeight: 'none'
      })
      .appendTo(target);

    return {
      init: function () {
        targetWidth = $target.outerWidth();
        targetHeight = $target.outerHeight();

        if (source === target) {
          sourceWidth = targetWidth;
          sourceHeight = targetHeight;
        } else {
          sourceWidth = $source.outerWidth();
          sourceHeight = $source.outerHeight();
        }

        xRatio = (img.width - targetWidth) / sourceWidth;
        yRatio = (img.height - targetHeight) / sourceHeight;

        offset = $source.offset();
      },
      move: function (e) {
        var left = (e.pageX - offset.left),
          top = (e.pageY - offset.top);

        top = Math.max(Math.min(top, sourceHeight), 0);
        left = Math.max(Math.min(left, sourceWidth), 0);

        img.style.left = (left * -xRatio) + 'px';
        img.style.top = (top * -yRatio) + 'px';
      }
    };
  };

  $.fn.zoom = function (options) {
    return this.each(function () {
      var
        settings = $.extend({}, defaults, options || {}),
        //target will display the zoomed image
        target = settings.target && $(settings.target)[0] || this,
        //source will provide zoom location info (thumbnail)
        source = this,
        $source = $(source),
        img = document.createElement('img'),
        $img = $(img),
        mousemove = 'mousemove.zoom',
        clicked = false,
        touched = false;

      // If a url wasn't specified, look for an image element.
      if (!settings.url) {
        var srcElement = source.querySelector('img');
        if (srcElement) {
          settings.url = srcElement.getAttribute('data-src') || srcElement.currentSrc || srcElement.src;
        }
        if (!settings.url) {
          return;
        }
      }

      $source.one('zoom.destroy', function (position, overflow) {
        $source.off(".zoom");
        target.style.position = position;
        target.style.overflow = overflow;
        img.onload = null;
        $img.remove();
      }.bind(this, target.style.position, target.style.overflow));

      img.onload = function () {
        var zoom = $.zoom(target, source, img, settings.magnify);

        function start(e) {
          zoom.init();
          zoom.move(e);

          // Skip the fade-in for IE8 and lower since it chokes on fading-in
          // and changing position based on mousemovement at the same time.
          $img.stop()
            .fadeTo($.support.opacity ? settings.duration : 0, 1, $.isFunction(settings.onZoomIn) ? settings.onZoomIn.call(img) : false);
        }

        function stop() {
          $img.stop()
            .fadeTo(settings.duration, 0, $.isFunction(settings.onZoomOut) ? settings.onZoomOut.call(img) : false);
        }

        // Mouse events
        if (settings.on === 'grab') {
          $source
            .on('mousedown.zoom',
              function (e) {
                if (e.which === 1) {
                  $(document).one('mouseup.zoom',
                    function () {
                      stop();

                      $(document).off(mousemove, zoom.move);
                    }
                  );

                  start(e);

                  $(document).on(mousemove, zoom.move);

                  e.preventDefault();
                }
              }
            );
        } else if (settings.on === 'click') {
          $source.on('click.zoom',
            function (e) {
              if (clicked) {
                // bubble the event up to the document to trigger the unbind.
                return;
              } else {
                clicked = true;
                start(e);
                $(document).on(mousemove, zoom.move);
                $(document).one('click.zoom',
                  function () {
                    stop();
                    clicked = false;
                    $(document).off(mousemove, zoom.move);
                  }
                );
                return false;
              }
            }
          );
        } else if (settings.on === 'toggle') {
          $source.on('click.zoom',
            function (e) {
              if (clicked) {
                stop();
              } else {
                start(e);
              }
              clicked = !clicked;
            }
          );
        } else if (settings.on === 'mouseover') {
          zoom.init(); // Preemptively call init because IE7 will fire the mousemove handler before the hover handler.

          $source
            .on('mouseenter.zoom', start)
            .on('mouseleave.zoom', stop)
            .on(mousemove, zoom.move);
        }

        // Touch fallback
        if (settings.touch) {
          $source
            .on('touchstart.zoom', function (e) {
              e.preventDefault();
              if (touched) {
                touched = false;
                stop();
              } else {
                touched = true;
                start(e.originalEvent.touches[0] || e.originalEvent.changedTouches[0]);
              }
            })
            .on('touchmove.zoom', function (e) {
              e.preventDefault();
              zoom.move(e.originalEvent.touches[0] || e.originalEvent.changedTouches[0]);
            })
            .on('touchend.zoom', function (e) {
              e.preventDefault();
              if (touched) {
                touched = false;
                stop();
              }
            });
        }

        if ($.isFunction(settings.callback)) {
          settings.callback.call(img);
        }
      };

      img.setAttribute('role', 'presentation');
      img.alt = '';
      img.src = settings.url;
    });
  };

  $.fn.zoom.defaults = defaults;
}(window.jQuery));
},{}],6:[function(require,module,exports){
/*!
* country-region-selector
* ------------------------
* 1.0.0
* @author Ben Keen
* @repo https://github.com/benkeen/country-region-selector
* @licence MIT
*/

!function (a, n) { if ("function" == typeof define && define.amd) define([], n); else if ("object" == typeof exports) try { module.exports = n(require()) } catch (a) { module.exports = n() } else a.crs = n() }(this, function () { "use strict"; var m = !0, h = !0, M = [], l = [["Afghanistan", "AF", "Badakhshan~BDS|Badghis~BDG|Baghlan~BGL|Balkh~BAL|Bamyan~BAM|Daykundi~DAY|Farah~FRA|Faryab~FYB|Ghazni~GHA|Ghor~GHO|Helmand~HEL|Herat~HER|Jowzjan~JOW|Kabul~KAB|Kandahar~KAN|Kapisa~KAP|Khost~KHO|Kunar~KNR|Kunduz~KDZ|Laghman~LAG|Logar~LOW|Maidan Wardak~WAR|Nangarhar~NAN|Nimruz~NIM|Nuristan~NUR|Paktia~PIA|Paktika~PKA|Panjshir~PAN|Parwan~PAR|Samangan~SAM|Sar-e Pol~SAR|Takhar~TAK|Urozgan~ORU|Zabul~ZAB"], ["Åland Islands", "AX", "Brändö~BR|Eckerö~EC|Finström~FN|Föglö~FG|Geta~GT|Hammarland~HM|Jomala~JM|Kumlinge~KM|Kökar~KK|Lemland~LE|Lumparland~LU|Mariehamn~MH|Saltvik~SV|Sottunga~ST|Sund~SD|Vårdö~VR"], ["Albania", "AL", "Berat~01|Dibër~09|Durrës~02|Elbasan~03|Fier~04|Gjirokastër~05|Korçë~06|Kukës~07|Lezhë~08|Shkodër~10|Tirana~11|Vlorë~12"], ["Algeria", "DZ", "Adrar~01|Aïn Defla~44|Aïn Témouchent~46|Algiers~16|Annaba~23|Batna~05|Béchar~08|Béjaïa~06|Biskra~07|Blida~09|Bordj Bou Arréridj~34|Bouïra~10|Boumerdès~35|Chlef~02|Constantine~25|Djelfa~17|El Bayadh~32|El Oued~39|El Tarf~36|Ghardaïa~47|Guelma~24|Illizi~33|Jijel~18|Khenchela~40|Laghouat~03|Mascara~29|Médéa~26|Mila~43|Mostaganem~27|Msila~28|Naâma~45|Oran~31|Ouargla~30|Oum el Bouaghi~04|Relizane~48|Saïda~20|Sétif~19|Sidi Bel Abbès~22|Skikda~21|Souk Ahras~41|Tamanghasset~11|Tébessa~12|Tiaret~14|Tindouf~37|Tipaza~42|Tissemsilt~38|Tizi Ouzou~15|Tlemcen~13"], ["American Samoa", "AS", "Tutuila~01|Aunu'u~02|Ta'ū~03|Ofu‑Olosega~04|Rose Atoll~21|Swains Island~22"], ["Andorra", "AD", "Andorra la Vella~07|Canillo~02|Encamp~03|Escaldes-Engordany~08|La Massana~04|Ordino~05|Sant Julià de Lòria~06"], ["Angola", "AO", "Bengo~BGO|Benguela~BGU|Bié~BIE|Cabinda~CAB|Cuando Cubango~CCU|Cuanza Norte~CNO|Cuanza Sul~CUS|Cunene~CNN|Huambo~HUA|Huíla~HUI|Luanda~LUA|Lunda Norte~LNO|Lunda Sul~LSU|Malanje~MAL|Moxico~MOX|Namibe~NAM|Uíge~UIG|Zaire~ZAI"], ["Anguilla", "AI", "Anguilla~01|Anguillita Island~02|Blowing Rock~03|Cove Cay~04|Crocus Cay~05|Deadman's Cay~06|Dog Island~07|East Cay~08|Little Island~09|Little Scrub Island~10|Mid Cay~11|North Cay~12|Prickly Pear Cays~13|Rabbit Island~14|Sandy Island/Sand Island~15|Scilly Cay~16|Scrub Island~17|Seal Island~18|Sombrero/Hat Island~19|South Cay~20|South Wager Island~21|West Cay~22"], ["Antarctica", "AQ", "Antarctica~AQ"], ["Antigua and Barbuda", "AG", "Antigua Island~01|Barbuda Island~02|Bird Island~04|Bishop Island~05|Blake Island~06|Crump Island~09|Dulcina Island~10|Exchange Island~11|Five Islands~12|Great Bird Island~13|Green Island~14|Guiana Island~15|Hawes Island~17|Hells Gate Island~16|Henry Island~18|Johnson Island~19|Kid Island~20|Lobster Island~22|Maiden Island~24|Moor Island~25|Nanny Island~26|Pelican Island~27|Prickly Pear Island~28|Rabbit Island~29|Red Head Island~31|Redonda Island~03|Sandy Island~32|Smith Island~33|The Sisters~34|Vernon Island~35|Wicked Will Island~36|York Island~37"], ["Argentina", "AR", "Buenos Aires~B|Capital Federal~C|Catamarca~K|Chaco~H|Chubut~U|Córdoba~X|Corrientes~W|Entre Ríos~E|Formosa~P|Jujuy~Y|La Pampa~L|La Rioja~F|Mendoza~M|Misiones~N|Neuquén~Q|Río Negro~R|Salta~A|San Juan~J|San Luis~D|Santa Cruz~Z|Santa Fe~S|Santiago del Estero~G|Tierra del Fuego~V|Tucumán~T"], ["Armenia", "AM", "Aragatsotn~AG|Ararat~AR|Armavir~AV|Gegharkunik~GR|Kotayk~KT|Lori~LO|Shirak~SH|Syunik~SU|Tavush~TV|Vayots Dzor~VD|Yerevan~ER"], ["Aruba", "AW", "Aruba~AW"], ["Australia", "AU", "Australian Capital Territory~ACT|New South Wales~NSW|Northern Territory~NT|Queensland~QLD|South Australia~SA|Tasmania~TAS|Victoria~VIC|Western Australia~WA"], ["Austria", "AT", "Burgenland~1|Kärnten~2|Niederösterreich~3|Oberösterreich~4|Salzburg~5|Steiermark~6|Tirol~7|Vorarlberg~8|Wien~9"], ["Azerbaijan", "AZ", "Abşeron~ABS|Ağcabədi~AGC|Ağdam~AGM|Ağdaş~AGS|Ağstafa~AGA|Ağsu~AGU|Astara~AST|Babək~BAB|Balakən~BAL|Bərdə~BAR|Beyləqan~BEY|Biləsuvar~BIL|Cəbrayıl~CAB|Cəlilabad~CAL|Culfa~CUL|Daşkəsən~DAS|Füzuli~FUZ|Gədəbəy~GAD|Goranboy~GOR|Göyçay~GOY|Göygöl~GYG|Hacıqabul~HAC|İmişli~IMI|İsmayıllı~ISM|Kəlbəcər~KAL|Kǝngǝrli~KAN|Kürdəmir~KUR|Laçın~LAC|Lənkəran~LAN|Lerik~LER|Masallı~MAS|Neftçala~NEF|Oğuz~OGU|Ordubad~ORD|Qəbələ~QAB|Qax~QAX|Qazax~QAZ|Qobustan~QOB|Quba~QBA|Qubadli~QBI|Qusar~QUS|Saatlı~SAT|Sabirabad~SAB|Şabran~SBN|Sədərək~SAD|Şahbuz~SAH|Şəki~SAK|Salyan~SAL|Şamaxı~SMI|Şəmkir~SKR|Samux~SMX|Şərur~SAR|Siyəzən~SIY|Şuşa~SUS|Tərtər~TAR|Tovuz~TOV|Ucar~UCA|Xaçmaz~XAC|Xızı~XIZ|Xocalı~XCI|Xocavənd~XVD|Yardımlı~YAR|Yevlax~YEV|Zəngilan~ZAN|Zaqatala~ZAQ|Zərdab~ZAR"], ["Bahamas", "BS", "Acklins Island~01|Berry Islands~22|Bimini~02|Black Point~23|Cat Island~03|Central Abaco~24|Crooked Island and Long Cay~28|East Grand Bahama~29|Exuma~04|Freeport~05|Fresh Creek~06|Governor's Harbour~07|Green Turtle Cay~08|Harbour Island~09|High Rock~10|Inagua~11|Kemps Bay~12|Long Island~13|Marsh Harbour~14|Mayaguana~15|Moore’s Island~40|New Providence~16|Nichollstown and Berry Islands~17|North Abaco~42|North Andros~41|North Eleuthera~33|Ragged Island~18|Rock Sound~19|San Salvador and Rum Cay~20|Sandy Point~21|South Abaco~35|South Andros~36|South Eleuthera~37|West Grand Bahama~39"], ["Bahrain", "BH", "Al Janūbīyah~14|Al Manāmah~13|Al Muḩarraq~15|Al Wusţá~16|Ash Shamālīyah~17"], ["Bangladesh", "BD", "Barisal~A|Chittagong~B|Dhaka~C|Khulna~D|Mymensingh~M|Rajshahi~E|Rangpur~F|Sylhet~G"], ["Barbados", "BB", "Christ Church~01|Saint Andrew~02|Saint George~03|Saint James~04|Saint John~05|Saint Joseph~06|Saint Lucy~07|Saint Michael~08|Saint Peter~09|Saint Philip~10|Saint Thomas~11"], ["Belarus", "BY", "Brest voblast~BR|Gorod Minsk~HO|Homiel voblast~HO|Hrodna voblast~HR|Mahilyow voblast~MA|Minsk voblast~MI|Vitsebsk voblast~VI"], ["Belgium", "BE", "Bruxelles-Capitale~BRU|Région Flamande~VLG|Région Wallonië~WAL"], ["Belize", "BZ", "Belize District~BZ|Cayo District~CY|Corozal District~CZL|Orange Walk District~OW|Stann Creek District~SC|Toledo District~TOL"], ["Benin", "BJ", "Alibori~AL|Atakora~AK|Atlantique~AQ|Borgou~BO|Collines Department~CO|Donga~DO|Kouffo~KO|Littoral Department~LI|Mono Department~MO|Ouémé~OU|Plateau~PL|Zou~ZO"], ["Bermuda", "BM", "City of Hamilton~03|Devonshire Parish~01|Hamilton Parish~02|Paget Parish~04|Pembroke Parish~05|Sandys Parish~08|Smith's Parish~09|Southampton Parish~10|St. George's Parish~07|Town of St. George~06|Warwick Parish~11"], ["Bhutan", "BT", "Bumthang~33|Chhukha~12|Dagana~22|Gasa~GA|Haa~13|Lhuntse~44|Mongar~42|Paro~11|Pemagatshel~43|Punakha~23|Samdrup Jongkhar~45|Samtse~14|Sarpang~31|Thimphu~15|Trashigang~41|Trashiyangtse~TY|Trongsa~32|Tsirang~21|Wangdue Phodrang~24|Zhemgang~34"], ["Bolivia", "BO", "Beni~B|Chuquisaca~H|Cochabamba~C|La Paz~L|Oruro~O|Pando~N|Potosí~P|Santa Cruz~S|Tarija~T"], ["Bonaire, Sint Eustatius and Saba", "BQ", "Bonaire~BO|Saba Isand~SA|Sint Eustatius~SE"], ["Bosnia and Herzegovina", "BA", "Brčko Distrikt~BRC|Federacija Bosne i Hercegovine~BIH|Republika Srpska~SRP"], ["Botswana", "BW", "Central~CE|Ghanzi~GH|Kgalagadi~KG|Kgatleng~KL|Kweneng~KW|North West~NW|North-East~NE|South East~SE|Southern~SO"], ["Bouvet Island", "BV", "Bouvet Island~BV"], ["Brazil", "BR", "Acre~AC|Alagoas~AL|Amapá~AP|Amazonas~AM|Bahia~BA|Ceará~CE|Distrito Federal~DF|Espírito Santo~ES|Goiás~GO|Maranhão~MA|Mato Grosso~MT|Mato Grosso do Sul~MS|Minas Gerais~MG|Pará~PA|Paraíba~PB|Paraná~PR|Pernambuco~PE|Piauí~PI|Rio de Janeiro~RJ|Rio Grande do Norte~RN|Rio Grande do Sul~RS|Rondônia~RO|Roraima~RR|Santa Catarina~SC|São Paulo~SP|Sergipe~SE|Tocantins~TO"], ["British Indian Ocean Territory", "IO", "British Indian Ocean Territory~IO"], ["Brunei Darussalam", "BN", "Belait~BE|Brunei Muara~BM|Temburong~TE|Tutong~TU"], ["Bulgaria", "BG", "Blagoevgrad~01|Burgas~02|Dobrich~08|Gabrovo~07|Jambol~28|Khaskovo~26|Kjustendil~10|Kurdzhali~09|Lovech~11|Montana~12|Pazardzhik~13|Pernik~14|Pleven~15|Plovdiv~16|Razgrad~17|Ruse~18|Shumen~27|Silistra~19|Sliven~20|Smoljan~21|Sofija~23|Sofija-Grad~22|Stara Zagora~24|Turgovishhe~25|Varna~03|Veliko Turnovo~04|Vidin~05|Vraca~06"], ["Burkina Faso", "BF", "Balé~BAL|Bam/Lake Bam~BAM|Banwa Province~BAN|Bazèga~BAZ|Bougouriba~BGR|Boulgou Province~BLG|Boulkiemdé~BLK|Comoé/Komoe~COM|Ganzourgou Province~GAN|Gnagna~GNA|Gourma Province~GOU|Houet~HOU|Ioba~IOB|Kadiogo~KAD|Kénédougou~KEN|Komondjari~KMD|Kompienga~KMP|Kossi Province~KOS|Koulpélogo~KOP|Kouritenga~KOT|Kourwéogo~KOW|Léraba~LER|Loroum~LOR|Mouhoun~MOU|Namentenga~NAM|Naouri/Nahouri~NAO|Nayala~NAY|Noumbiel~NOU|Oubritenga~OUB|Oudalan~OUD|Passoré~PAS|Poni~PON|Sanguié~SNG|Sanmatenga~SMT|Séno~SEN|Sissili~SIS|Soum~SOM|Sourou~SOR|Tapoa~TAP|Tui/Tuy~TUI|Yagha~YAG|Yatenga~YAT|Ziro~ZIR|Zondoma~ZON|Zoundwéogo~ZOU"], ["Burundi", "BI", "Bubanza~BB|Bujumbura Mairie~BM|Bujumbura Rural~BL|Bururi~BR|Cankuzo~CA|Cibitoke~CI|Gitega~GI|Karuzi~KR|Kayanza~KY|Kirundo~KI|Makamba~MA|Muramvya~MU|Muyinga~MY|Mwaro~MW|Ngozi~NG|Rutana~RT|Ruyigi~RY"], ["Cambodia", "KH", "Baat Dambang~2|Banteay Mean Chey~1|Kampong Chaam~3|Kampong Chhnang~4|Kampong Spueu~5|Kampong Thum~6|Kampot~7|Kandaal~8|Kaoh Kong~9|Kracheh~10|Krong Kaeb~23|Krong Pailin~24|Krong Preah Sihanouk~18|Mondol Kiri~11|Otdar Mean Chey~22|Phnom Penh~12|Pousaat~15|Preah Vihear~13|Prey Veaeng~14|Rotanah Kiri~16|Siem Reab~17|Stueng Treng~19|Svaay Rieng~20|Taakaev~21|Tbong Khmum~25"], ["Cameroon", "CM", "Adamaoua~AD|Centre~CE|Est~ES|Extrême-Nord~EN|Littoral~LT|Nord~NO|Nord-Ouest~NW|Ouest~OU|Sud~SU|Sud-Ouest~SW"], ["Canada", "CA", "Alberta~AB|British Columbia~BC|Manitoba~MB|New Brunswick~NB|Newfoundland and Labrador~NL|Northwest Territories~NT|Nova Scotia~NS|Nunavut~NU|Ontario~ON|Prince Edward Island~PE|Quebec~QC|Saskatchewan~SK|Yukon~YT"], ["Cape Verde", "CV", "Boa Vista~BV|Brava~BR|Calheta de São Miguel~CS|Maio~MA|Mosteiros~MO|Paúl~PA|Porto Novo~PN|Praia~PR|Ribeira Brava~RB|Ribeira Grande~RG|Sal~SL|Santa Catarina~CA|Santa Cruz~CR|São Domingos~SD|São Filipe~SF|São Nicolau~SN|São Vicente~SV|Tarrafal~TA|Tarrafal de São Nicolau~TS"], ["Cayman Islands", "KY", "Creek|Eastern|Midland|South Town|Spot Bay|Stake Bay|West End|Western"], ["Central African Republic", "CF", "Bamingui-Bangoran~BB|Bangui~BGF|Basse-Kotto~BK|Haute-Kotto~HK|Haut-Mbomou~HM|Kémo~KG|Lobaye~LB|Mambéré-Kadéï~HS|Mbomou~MB|Nana-Grebizi~10|Nana-Mambéré~NM|Ombella-M'Poko~MP|Ouaka~UK|Ouham~AC|Ouham Péndé~OP|Sangha-Mbaéré~SE|Vakaga~VK"], ["Chad", "TD", "Bahr el Ghazal~BG|Batha~BA|Borkou~BO|Chari-Baguirmi~CB|Ennedi-Est~EE|Ennedi-Ouest~EO|Guéra~GR|Hadjer Lamis~HL|Kanem~KA|Lac~LC|Logone Occidental~LO|Logone Oriental~LR|Mondoul~MA|Mayo-Kébbi-Est~ME|Moyen-Chari~MC|Ouaddai~OD|Salamat~SA|Sila~SI|Tandjilé~TA|Tibesti~TI|Ville de Ndjamena~ND|Wadi Fira~WF"], ["Chile", "CL", "Aisén del General Carlos Ibáñez del Campo~AI|Antofagasta~AN|Araucanía~AR|Arica y Parinacota~AP|Atacama~AT|Bío-Bío~BI|Coquimbo~CO|Libertador General Bernardo O'Higgins~LI|Los Lagos~LL|Los Ríos~LR|Magallanes y Antartica Chilena~MA|Marga-Marga~|Maule~ML|Región Metropolitana de Santiago~RM|Tarapacá~TA|Valparaíso~VS"], ["China", "CN", "Anhui~34|Beijing~11|Chongqing~50|Fujian~35|Gansu~62|Guangdong~44|Guangxi~45|Guizhou~52|Hainan~46|Hebei~13|Heilongjiang~23|Henan~41|Hong Kong~91|Hubei~42|Hunan~43|Inner Mongolia~15|Jiangsu~32|Jiangxi~36|Jilin~22|Liaoning~21|Macau~92|Ningxia~64|Qinghai~63|Shaanxi~61|Shandong~37|Shanghai~31|Shanxi~14|Sichuan~51|Tianjin~12|Tibet~54|Xinjiang~65|Yunnan~53|Zhejiang~33"], ["Christmas Island", "CX", "Christmas Island~CX"], ["Cocos (Keeling) Islands", "CC", "Direction Island~DI|Home Island~HM|Horsburgh Island~HR|North Keeling Island~NK|South Island~SI|West Island~WI"], ["Colombia", "CO", "Amazonas~AMA|Antioquia~ANT|Arauca~ARA|Archipiélago de San Andrés~SAP|Atlántico~ATL|Bogotá D.C.~DC|Bolívar~BOL|Boyacá~BOY|Caldas~CAL|Caquetá~CAQ|Casanare~CAS|Cauca~CAU|Cesar~CES|Chocó~CHO|Córdoba~COR|Cundinamarca~CUN|Guainía~GUA|Guaviare~GUV|Huila~HUI|La Guajira~LAG|Magdalena~MAG|Meta~MET|Nariño~NAR|Norte de Santander~NSA|Putumayo~PUT|Quindío~QUI|Risaralda~RIS|Santander~SAN|Sucre~SUC|Tolima~TOL|Valle del Cauca~VAC|Vaupés~VAU|Vichada~VID"], ["Comoros", "KM", "Andjazîdja~G|Andjouân~A|Moûhîlî~M"], ["Congo, Republic of the (Brazzaville)", "CG", "Bouenza~11|Brazzaville~BZV|Cuvette~8|Cuvette-Ouest~15|Kouilou~5|Lékoumou~2|Likouala~7|Niari~9|Plateaux~14|Pointe-Noire~16|Pool~12|Sangha~13"], ["Congo, the Democratic Republic of the (Kinshasa)", "CD", "Bandundu~BN|Bas-Congo~BC|Équateur~EQ|Kasaï-Occidental~KE|Kasaï-Oriental~KW|Katanga~KA|Kinshasa~KN|Maniema~MA|Nord-Kivu~NK|Orientale~OR|Sud-Kivu~SK"], ["Cook Islands", "CK", "Aitutaki|Atiu|Avarua|Mangaia|Manihiki|Ma'uke|Mitiaro|Nassau|Palmerston|Penrhyn|Pukapuka|Rakahanga"], ["Costa Rica", "CR", "Alajuela~2|Cartago~3|Guanacaste~5|Heredia~4|Limón~7|Puntarenas~6|San José~1"], ["Côte d'Ivoire, Republic of", "CI", "Agnéby~16|Bafing~17|Bas-Sassandra~09|Denguélé~10|Dix-Huit Montagnes~06|Fromager~18|Haut-Sassandra~02|Lacs~07|Lagunes~01|Marahoué~12|Moyen-Cavally~19|Moyen-Comoé~05|N'zi-Comoé~11|Savanes~03|Sud-Bandama~15|Sud-Comoé~13|Vallée du Bandama~04|Worodougou~14|Zanzan~08"], ["Croatia", "HR", "Bjelovarsko-Bilogorska Županija~07|Brodsko-Posavska Županija~12|Dubrovačko-Neretvanska Županija~19|Grad Zagreb~21|Istarska Županija~18|Karlovačka Županija~04|Koprivničko-Krizevačka Županija~06|Krapinsko-Zagorska Županija~02|Ličko-Senjska Županija~09|Međimurska Županija~20|Osječko-Baranjska Županija~14|Požeško-Slavonska Županija~11|Primorsko-Goranska Županija~08|Sisačko-Moslavačka Županija~03|Splitsko-Dalmatinska Županija~17|Sibensko-Kninska Županija~15|Varaždinska Županija~05|Virovitičko-Podravska Županija~10|Vukovarsko-Srijemska Županija~16|Zadarska Županija~13|Zagrebacka Zupanija~01"], ["Cuba", "CU", "Artemisa~15|Camagüey~09|Ciego de Ávila~08|Cienfuegos~06|Granma~12|Guantánamo~14|Holguín~11|Isla de la Juventud~99|La Habana~03|Las Tunas~10|Matanzas~04|Mayabeque~16|Pinar del Río~01|Sancti Spíritus~07|Santiago de Cuba~13|Villa Clara~05"], ["Curaçao", "CW", "Curaçao~CW"], ["Cyprus", "CY", "Ammochostos~04|Keryneia~05|Larnaka~03|Lefkosia~01|Lemesos~02|Pafos~05"], ["Czech Republic", "CZ", "Hlavní město Praha~PR|Jihočeský kraj~JC|Jihomoravský kraj~JM|Karlovarský kraj~KA|Královéhradecký kraj~KR|Liberecký kraj~LI|Moravskoslezský kraj~MO|Olomoucký kraj~OL|Pardubický kraj~PA|Plzeňský kraj~PL|Středočeský kraj~ST|Ústecký kraj~US|Vysočina~VY|Zlínský kraj~ZL"], ["Denmark", "DK", "Hovedstaden~84|Kujalleq~GL-KU|Midtjylland~82|Norderøerne~FO-01|Nordjylland~81|Østerø~FO-06|Qaasuitsup~GL-QA|Qeqqata~GL-QE|Sandø~FO-02|Sermersooq~GL-SM|Sjælland~85|Strømø~FO-03|Suderø~FO-04|Syddanmark~83|Vågø~FO-05"], ["Djibouti", "DJ", "Ali Sabieh~AS|Arta~AR|Dikhil~DI|Obock~OB|Tadjourah~TA"], ["Dominica", "DM", "Saint Andrew Parish~02|Saint David Parish~03|Saint George Parish~04|Saint John Parish~05|Saint Joseph Parish~06|Saint Luke Parish~07|Saint Mark Parish~08|Saint Patrick Parish~09|Saint Paul Parish~10|Saint Peter Parish~11"], ["Dominican Republic", "DO", "Cibao Central~02|Del Valle~37|Distrito Nacional~01|Enriquillo~38|Norcentral~04|Nordeste~34|Noroeste~34|Norte~35|Valdesia~42"], ["Ecuador", "EC", "Azuay~A|Bolívar~B|Cañar~F|Carchi~C|Chimborazo~H|Cotopaxi~X|El Oro~O|Esmeraldas~E|Galápagos~W|Guayas~G|Imbabura~I|Loja~L|Los Ríos~R|Manabí~M|Morona-Santiago~S|Napo~N|Orellana~D|Pastaza~Y|Pichincha~P|Santa Elena~SE|Santo Domingo de los Tsáchilas~SD|Sucumbíos~U|Tungurahua~T|Zamora-Chinchipe~Z"], ["Egypt", "EG", "Alexandria~ALX|Aswan~ASN|Asyout~AST|Bani Sueif~BNS|Beheira~BH|Cairo~C|Daqahlia~DK|Dumiat~DT|El Bahr El Ahmar~BA|El Ismailia~IS|El Suez~SUZ|El Wadi El Gedeed~WAD|Fayoum~FYM|Gharbia~GH|Giza~SUZ|Helwan~HU|Kafr El Sheikh~KFS|Luxor~LX|Matrouh~MT|Menia~MN|Menofia~MNF|North Sinai~SIN|Port Said~PTS|Qalubia~KB|Qena~KN|Sharqia~SHR|Sixth of October~SU|Sohag~SHG|South Sinai~JS"], ["El Salvador", "SV", "Ahuachapán~AH|Cabañas~CA|Cuscatlán~CU|Chalatenango~CH|La Libertad~LI|La Paz~PA|La Unión~UN|Morazán~MO|San Miguel~SM|San Salvador~SS|Santa Ana~SA|San Vicente~SV|Sonsonate~SO|Usulután~US"], ["Equatorial Guinea", "GQ", "Annobón~AN|Bioko Norte~BN|Bioko Sur~BS|Centro Sur~CS|Kié-Ntem~KN|Litoral~LI|Wele-Nzas~WN"], ["Eritrea", "ER", "Anseba~AN|Debub~DU|Debub-Keih-Bahri~DK|Gash-Barka~GB|Maekel~MA|Semien-Keih-Bahri~SK"], ["Estonia", "EE", "Harjumaa (Tallinn)~37|Hiiumaa (Kardla)~39|Ida-Virumaa (Johvi)~44|Järvamaa (Paide)~41|Jõgevamaa (Jogeva)~49|Läänemaa~57|Lääne-Virumaa (Rakvere)~59|Pärnumaa (Parnu)~67|Põlvamaa (Polva)~65|Raplamaa (Rapla)~70|Saaremaa (Kuessaare)~74|Tartumaa (Tartu)~78|Valgamaa (Valga)~82|Viljandimaa (Viljandi)~84|Võrumaa (Voru)~86"], ["Ethiopia", "ET", "Addis Ababa~AA|Afar~AF|Amhara~AM|Benshangul-Gumaz~BE|Dire Dawa~DD|Gambela~GA|Harari~HA|Oromia~OR|Somali~SO|Southern Nations Nationalities and People's Region~SN|Tigray~TI"], ["Falkland Islands (Islas Malvinas)", "FK", "Falkland Islands (Islas Malvinas)"], ["Faroe Islands", "FO", "Bordoy|Eysturoy|Mykines|Sandoy|Skuvoy|Streymoy|Suduroy|Tvoroyri|Vagar"], ["Fiji", "FJ", "Ba~01|Bua~01|Cakaudrove~03|Kadavu~04|Lau~05|Lomaiviti~06|Macuata~07|Nadroga and Navosa~08|Naitasiri~09|Namosi~10|Ra~011|Rewa~12|Rotuma~R|Serua~12|Tailevu~14"], ["Finland", "FI", "Ahvenanmaan lääni~AL|Etelä-Suomen lääni~ES|Itä-Suomen lääni~IS|Länsi-Suomen lääni~LS|Lapin lääni~LL|Oulun lääni~OL"], ["France", "FR", "Auvergne-Rhône-Alpes~ARA|Bourgogne-Franche-Comté~BFC|Bretagne~BRE|Centre-Val de Loire~CVL|Corse~COR|Grand Est~GES|Hauts-de-France~HDF|Île-de-France~IDF|Normandie~NOR|Nouvelle-Aquitaine~NAQ|Occitanie~OCC|Pays de la Loire~PDL|Provence-Alpes-Cote d'Azur~PAC|Clipperton~CP|Guadeloupe~GP|Guyane~GF|Martinique~MQ|Mayotte~YT|Novelle-Calédonie~NC|Polynésie~PF|Saint-Pierre-et-Miquelon~PM|Saint Barthélemy~BL|Saint Martin~MF|Réunion~RE|Terres Australes Françaises~TF|Wallis-et-Futuna~WF"], ["French Guiana", "GF", "French Guiana"], ["French Polynesia", "PF", "Archipel des Marquises|Archipel des Tuamotu|Archipel des Tubuai|Iles du Vent|Iles Sous-le-Vent"], ["French Southern and Antarctic Lands", "TF", "Adelie Land|Ile Crozet|Iles Kerguelen|Iles Saint-Paul et Amsterdam"], ["Gabon", "GA", "Estuaire~1|Haut-Ogooué~2|Moyen-Ogooué~3|Ngounié~4|Nyanga~5|Ogooué-Ivindo~6|Ogooué-Lolo~7|Ogooué-Maritime~8|Woleu-Ntem~9"], ["Gambia, The", "GM", "Banjul~B|Central River~M|Lower River~L|North Bank~N|Upper River~U|Western~W"], ["Georgia", "GE", "Abkhazia (Sokhumi)~AB|Ajaria (Bat'umi)~AJ|Guria~GU|Imereti~IM|K'akheti~KA|Kvemo Kartli~KK|Mtshkheta-Mtianeti~MM|Rach'a-Lexhkumi-KvemoSvaneti~RL|Samegrelo-Zemo Svaneti~SZ|Samtskhe-Javakheti~SJ|Shida Kartli~SK|Tbilisi~TB"], ["Germany", "DE", "Baden-Württemberg~BW|Bayern~BY|Berlin~BE|Brandenburg~BB|Bremen~HB|Hamburg~HH|Hessen~HE|Mecklenburg-Vorpommern~MV|Niedersachsen~NI|Nordrhein-Westfalen~NW|Rheinland-Pfalz~RP|Saarland~SL|Sachsen~SN|Sachsen-Anhalt~ST|Schleswig-Holstein~SH|Thüringen~TH"], ["Ghana", "GH", "Ashanti~AH|Brong-Ahafo~BA|Central~CP|Eastern~EP|Greater Accra~AA|Northern~NP|Upper East~UE|Upper West~UW|Volta~TV|Western~WP"], ["Gibraltar", "GI", "Gibraltar"], ["Greece", "GR", "Anatolikí Makedonía kai Thráki~A|Attikḯ~I|Dytikí Elláda~G|Dytikí Makedonía~C|Ionía Nísia~F|Kentrikí Makedonía~B|Krítí~M|Notío Aigaío~L|Peloponnísos~J|Stereá Elláda~H|Thessalía~E|Voreío Aigaío~K|Ípeiros~D|Ágion Óros~69"], ["Greenland", "GL", "Kommune Kujalleq~KU|Kommuneqarfik Sermersooq~SM|Qaasuitsup Kommunia~QA|Qeqqata Kommunia~QE"], ["Grenada", "GD", "Saint Andrew~01|Saint David~02|Saint George~03|Saint John~04|Saint Mark~05|Saint Patrick~06|Southern Grenadine Islands~10"], ["Guadeloupe", "GP", "Guadeloupe"], ["Guam", "GU", "Guam"], ["Guatemala", "GT", "Alta Verapaz~AV|Baja Verapaz~BV|Chimaltenango~CM|Chiquimula~CQ|El Progreso~PR|Escuintla~ES|Guatemala~GU|Huehuetenango~HU|Izabal~IZ|Jalapa~JA|Jutiapa~JU|Petén~PE|Quetzaltenango~QZ|Quiché~QC|Retalhuleu~Re|Sacatepéquez~SA|San Marcos~SM|Santa Rosa~SR|Sololá~SO|Suchitepéquez~SU|Totonicapán~TO|Zacapa~ZA"], ["Guernsey", "GG", "Castel|Forest|St. Andrew|St. Martin|St. Peter Port|St. Pierre du Bois|St. Sampson|St. Saviour|Torteval|Vale"], ["Guinea", "GN", "Boké~B|Conakry~C|Faranah~F|Kankan~K|Kindia~D|Labé~L|Mamou~M|Nzérékoré~N"], ["Guinea-Bissau", "GW", "Bafatá~BA|Biombo~BM|Bissau~BS|Bolama-Bijagos~BL|Cacheu~CA|Gabú~GA|Oio~OI|Quinara~QU|Tombali~TO"], ["Guyana", "GY", "Barima-Waini~BA|Cuyuni-Mazaruni~CU|Demerara-Mahaica~DE|East Berbice-Corentyne~EB|Essequibo Islands-West Demerara~ES|Mahaica-Berbice~MA|Pomeroon-Supenaam~PM|Potaro-Siparuni~PT|Upper Demerara-Berbice~UD|Upper Takutu-Upper Essequibo~UT"], ["Haiti", "HT", "Artibonite~AR|Centre~CE|Grand'Anse~GA|Nippes~NI|Nord~ND|Nord-Est~NE|Nord-Ouest~NO|Ouest~OU|Sud~SD|Sud-Est~SE"], ["Heard Island and McDonald Islands", "HM", "Heard Island and McDonald Islands"], ["Holy See (Vatican City)", "VA", "Holy See (Vatican City)~01"], ["Honduras", "HN", "Atlántida~AT|Choluteca~CH|Colón~CL|Comayagua~CM|Copán~CP|Cortés~CR|El Paraíso~EP|Francisco Morazan~FM|Gracias a Dios~GD|Intibucá~IN|Islas de la Bahía~IB|La Paz~LP|Lempira~LE|Ocotepeque~OC|Olancho~OL|Santa Bárbara~SB|Valle~VA|Yoro~YO"], ["Hong Kong", "HK", "Hong Kong"], ["Hungary", "HU", "Bács-Kiskun~BK|Baranya~BA|Békés~BE|Békéscsaba~BC|Borsod-Abauj-Zemplen~BZ|Budapest~BU|Csongrád~CS|Debrecen~DE|Dunaújváros~DU|Eger~EG|Érd~ER|Fejér~FE|Győr~GY|Győr-Moson-Sopron~GS|Hajdú-Bihar~HB|Heves~HE|Hódmezővásárhely~HV|Jász-Nagykun-Szolnok~N|Kaposvár~KV|Kecskemét~KM|Komárom-Esztergom~KE|Miskolc~MI|Nagykanizsa~NK|Nógrád~NO|Nyíregyháza~NY|Pécs~PS|Pest~PE|Salgótarján~ST|Somogy~SO|Sopron~SN|Szabolcs-á-Bereg~SZ|Szeged~SD|Székesfehérvár~SF|Szekszárd~SS|Szolnok~SK|Szombathely~SH|Tatabánya~TB|Tolna~TO|Vas~VA|Veszprém~VE|Veszprém (City)~VM|Zala~ZA|Zalaegerszeg~ZE"], ["Iceland", "IS", "Austurland~7|Höfuðborgarsvæði utan Reykjavíkur~1|Norðurland eystra~6|Norðurland vestra~5|Suðurland~8|Suðurnes~2|Vestfirðir~4|Vesturland~3"], ["India", "IN", "Andaman and Nicobar Islands~AN|Andhra Pradesh~AP|Arunachal Pradesh~AR|Assam~AS|Bihar~BR|Chandigarh~CH|Chhattisgarh~CT|Dadra and Nagar Haveli~DN|Daman and Diu~DD|Delhi~DL|Goa~GA|Gujarat~GJ|Haryana~HR|Himachal Pradesh~HP|Jammu and Kashmir~JK|Jharkhand~JH|Karnataka~KA|Kerala~KL|Lakshadweep~LD|Madhya Pradesh~MP|Maharashtra~MH|Manipur~MN|Meghalaya~ML|Mizoram~MZ|Nagaland~NL|Odisha~OR|Puducherry~PY|Punjab~PB|Rajasthan~RJ|Sikkim~WK|Tamil Nadu~TN|Telangana~TG|Tripura~TR|Uttarakhand~UT|Uttar Pradesh~UP|West Bengal~WB"], ["Indonesia", "ID", "Aceh~AC|Bali~BA|Bangka Belitung~BB|Banten~BT|Bengkulu~BE|Gorontalo~GO|Jakarta Raya~JK|Jambi~JA|Jawa Barat~JB|Jawa Tengah~JT|Jawa Timur~JI|Kalimantan Barat~KB|Kalimantan Selatan~KS|Kalimantan Tengah~KT|Kalimantan Timur~KI|Kalimantan Utara~KU|Kepulauan Riau~KR|Lampung~LA|Maluku~MA|Maluku Utara~MU|Nusa Tenggara Barat~NB|Nusa Tenggara Timur~NT|Papua~PA|Papua Barat~PB|Riau~RI|Sulawesi Selatan~SR|Sulawesi Tengah~ST|Sulawesi Tenggara~SG|Sulawesi Utara~SA|Sumatera Barat~SB|Sumatera Selatan~SS|Sumatera Utara~SU|Yogyakarta~YO"], ["Iran, Islamic Republic of", "IR", "Alborz~32|Ardabīl~03|Āz̄arbāyjān-e Gharbī~02|Āz̄arbāyjān-e Sharqī~01|Būshehr~06|Chahār Maḩāl va Bakhtīārī~08|Eşfahān~04|Fārs~14|Gīlān~19|Golestān~27|Hamadān~24|Hormozgān~23|Īlām~05|Kermān~15|Kermānshāh~17|Khorāsān-e Jonūbī~29|Khorāsān-e Raẕavī~30|Khorāsān-e Shomālī~61|Khūzestān~10|Kohgīlūyeh va Bowyer Aḩmad~18|Kordestān~16|Lorestān~20|Markazi~22|Māzandarān~21|Qazvīn~28|Qom~26|Semnān~12|Sīstān va Balūchestān~13|Tehrān~07|Yazd~25|Zanjān~11"], ["Iraq", "IQ", "Al Anbār~AN|Al Başrah~BA|Al Muthanná~MU|Al Qādisīyah~QA|An Najaf~NA|Arbīl~AR|As Sulaymānīyah~SU|Bābil~BB|Baghdād~BG|Dohuk~DA|Dhī Qār~DQ|Diyālá~DI|Karbalā'~KA|Kirkuk~KI|Maysān~MA|Nīnawá~NI|Şalāḩ ad Dīn~SD|Wāsiţ~WA"], ["Ireland", "IE", "Carlow~CW|Cavan~CN|Clare~CE|Cork~CO|Donegal~DL|Dublin~D|Galway~G|Kerry~KY|Kildare~KE|Kilkenny~KK|Laois~LS|Leitrim~LM|Limerick~LK|Longford~LD|Louth~LH|Mayo~MO|Meath~MH|Monaghan~MN|Offaly~OY|Roscommon~RN|Sligo~SO|Tipperary~TA|Waterford~WD|Westmeath~WH|Wexford~WX|Wicklow~WW"], ["Isle of Man", "IM", "Isle of Man"], ["Israel", "IL", "HaDarom~D|HaMerkaz~M|HaTsafon~Z|H̱efa~HA|Tel-Aviv~TA|Yerushalayim~JM"], ["Italy", "IT", "Abruzzo~65|Basilicata~77|Calabria~78|Campania~72|Emilia-Romagna~45|Friuli-Venezia Giulia~36|Lazio~62|Liguria~42|Lombardia~25|Marche~57|Molise~67|Piemonte~21|Puglia~75|Sardegna~88|Sicilia~82|Toscana~52|Trentino-Alto Adige~32|Umbria~55|Valle d'Aosta~23|Veneto~34"], ["Jamaica", "JM", "Clarendon~13|Hanover~09|Kingston~01|Manchester~12|Portland~04|Saint Andrew~02|Saint Ann~06|Saint Catherine~14|Saint Elizabeth~11|Saint James~08|Saint Mary~05|Saint Thomas~03|Trelawny~07|Westmoreland~10"], ["Japan", "JP", "Aichi~23|Akita~05|Aomori~02|Chiba~12|Ehime~38|Fukui~18|Fukuoka~40|Fukushima~07|Gifu~21|Gunma~10|Hiroshima~34|Hokkaido~01|Hyogo~28|Ibaraki~08|Ishikawa~17|Iwate~03|Kagawa~37|Kagoshima~46|Kanagawa~14|Kochi~39|Kumamoto~43|Kyoto~26|Mie~24|Miyagi~04|Miyazaki~45|Nagano~20|Nagasaki~42|Nara~29|Niigata~15|Oita~44|Okayama~33|Okinawa~47|Osaka~27|Saga~41|Saitama~11|Shiga~25|Shimane~32|Shizuoka~22|Tochigi~09|Tokushima~36|Tokyo~13|Tottori~31|Toyama~16|Wakayama~30|Yamagata~06|Yamaguchi~35|Yamanashi~19"], ["Jersey", "JE", "Jersey"], ["Jordan", "JO", "‘Ajlūn~AJ|Al 'Aqabah~AQ|Al Balqā’~BA|Al Karak~KA|Al Mafraq~MA|Al ‘A̅şimah~AM|Aţ Ţafīlah~AT|Az Zarqā’~AZ|Irbid~IR|Jarash~JA|Ma‘ān~MN|Mādabā~MD"], ["Kazakhstan", "KZ", "Almaty~ALA|Aqmola~AKM|Aqtobe~AKT|Astana~AST|Atyrau~ATY|Batys Qazaqstan~ZAP|Bayqongyr|Mangghystau~MAN|Ongtustik Qazaqstan~YUZ|Pavlodar~PAV|Qaraghandy~KAR|Qostanay~KUS|Qyzylorda~KZY|Shyghys Qazaqstan~VOS|Soltustik Qazaqstan~SEV|Zhambyl~ZHA"], ["Kenya", "KE", "Baringo~01|Bomet~02|Bungoma~03|Busia~04|Eleyo/Marakwet~05|Embu~06|Garissa~07|Homa Bay~08|Isiolo~09|Kajiado~10|Kakamega~11|Kericho~12|Kiambu~13|Kilifi~14|Kirinyaga~15|Kisii~16|Kisumu~17|Kitui~18|Kwale~19|Laikipia~20|Lamu~21|Machakos~22|Makueni~23|Mandera~24|Marsabit~25|Meru~26|Migori~27|Mombasa~28|Murang'a~29|Nairobi City~30|Nakuru~31|Nandi~32|Narok~33|Nyamira~34|Nyandarua~35|Nyeri~36|Samburu~37|Siaya~38|Taita/Taveta~39|Tana River~40|Tharaka-Nithi~41|Trans Nzoia~42|Turkana~43|Uasin Gishu~44|Vihiga~45|Wajir~46|West Pokot~47"], ["Kiribati", "KI", "Abaiang|Abemama|Aranuka|Arorae|Banaba|Beru|Butaritari|Central Gilberts|Gilbert Islands~G|Kanton|Kiritimati|Kuria|Line Islands~L|Maiana|Makin|Marakei|Nikunau|Nonouti|Northern Gilberts|Onotoa|Phoenix Islands~P|Southern Gilberts|Tabiteuea|Tabuaeran|Tamana|Tarawa|Teraina"], ["Korea, Democratic People's Republic of", "KP", "Chagang-do (Chagang Province)~04|Hamgyong-bukto (North Hamgyong Province)~09|Hamgyong-namdo (South Hamgyong Province)~08|Hwanghae-bukto (North Hwanghae Province)~06|Hwanghae-namdo (South Hwanghae Province)~05|Kangwon-do (Kangwon Province)~07|Nasŏn (Najin-Sŏnbong)~13|P'yongan-bukto (North P'yongan Province)~03|P'yongan-namdo (South P'yongan Province)~02|P'yongyang-si (P'yongyang City)~01|Yanggang-do (Yanggang Province)~10"], ["Korea, Republic of", "KR", "Ch'ungch'ongbuk-do~43|Ch'ungch'ongnam-do~44|Cheju-do~49|Chollabuk-do~45|Chollanam-do~46|Inch'on-Kwangyokhi~28|Kang-won-do~42|Kwangju-Kwangyokshi~28|Kyonggi-do~41|Kyongsangbuk-do~47|Kyongsangnam-do~48|Pusan-Kwangyokshi~26|Seoul-T'ukpyolshi~11|Sejong~50|Taegu-Kwangyokshi~27|Taejon-Kwangyokshi~30|Ulsan-Kwangyokshi~31"], ["Kuwait", "KW", "Al Aḩmadi~AH|Al Farwānīyah~FA|Al Jahrā’~JA|Al ‘Āşimah~KU|Ḩawallī~HA|Mubārak al Kabir~MU"], ["Kyrgyzstan", "KG", "Batken Oblasty~B|Bishkek Shaary~GB|Chuy Oblasty (Bishkek)~C|Jalal-Abad Oblasty~J|Naryn Oblasty~N|Osh Oblasty~O|Talas Oblasty~T|Ysyk-Kol Oblasty (Karakol)~Y"], ["Laos", "LA", "Attapu~AT|Bokèo~BK|Bolikhamxai~BL|Champasak~CH|Houaphan~HO|Khammouan~KH|Louang Namtha~LM|Louangphabang~LP|Oudômxai~OU|Phôngsali~PH|Salavan~SL|Savannakhét~SV|Vientiane~VI|Xaignabouli~XA|Xékong~XE|Xaisomboun~XS|Xiangkhouang~XI"], ["Latvia", "LV", "Aglona~001|Aizkraukle~002|Aizpute~003|Aknīste~004|Aloja~005|Alsunga~06|Alūksne~007|Amata~008|Ape~009|Auce~010|Ādaži~011|Babīte~012|Baldone~013|Baltinava~014|Balvi~015|Bauska~016|Beverīna~017|Brocēni~018|Burtnieki~019|Carnikava~020|Cesvaine~021|Cēsis~022|Cibla~023|Dagda~024|Daugavpils~025|Daugavpils (City)~DGV|Dobele~026|Dundaga~027|Durbe~028|Engure~029|Ērgļi~030|Garkalne~031|Grobiņa~032|Gulbene~033|Iecava~034|Ikšķile~035|Ilūkste~036|Inčukalns~037|Jaunjelgava~038|Jaunpiebalga~039|Jaunpils~040|Jelgava~041|Jelgava (City)~JEL|Jēkabpils~042|Jēkabpils (City)~JKB|Jūrmala (City)~JUR|Kandava~043|Kārsava~044|Kocēni~045|Koknese~046|Krāslava~047|Krimulda~048|Krustpils~049|Kuldīga~050|Ķegums~051|Ķekava~052|Lielvārde~053|Liepāja~LPX|Limbaži~054|Līgatne~055|Līvāni~056|Lubāna~057|Ludza~058|Madona~059|Mazsalaca~060|Mālpils~061|Mārupe~062|Mērsrags~063|Naukšēni~064|Nereta~065|Nīca~066|Ogre~067|Olaine~068|Ozolnieki~069|Pārgauja~070|Pāvilosta~071|Pļaviņas~072|Preiļi~073|Priekule~074|Priekuļi~075|Rauna~076|Rēzekne~077|Rēzekne (City)~REZ|Riebiņi~078|Rīga~RIX|Roja~079|Ropaži~080|Rucava~081|Rugāji~082|Rundāle~083|Rūjiena~084|Sala~085|Salacgrīva~086|Salaspils~087|Saldus~088|Saulkrasti~089|Sēja~090|Sigulda~091|Skrīveri~092|Skrunda~093|Smiltene~094|Stopiņi~095|Strenči~096|Talsi~097|Tērvete~098|Tukums~099|Vaiņode~100|Valka~101|Valmiera~VMR|Varakļāni~102|Vārkava~103|Vecpiebalga~104|Vecumnieki~105|Ventspils~106|Ventspils (City)~VEN|Viesīte~107|Viļaka~108|Viļāni~109|Zilupe~110"], ["Lebanon", "LB", "Aakkâr~AK|Baalbelk-Hermel~BH|Béqaa~BI|Beyrouth~BA|Liban-Nord~AS|Liban-Sud~JA|Mont-Liban~JL|Nabatîyé~NA"], ["Lesotho", "LS", "Berea~D|Butha-Buthe~B|Leribe~C|Mafeteng~E|Maseru~A|Mohales Hoek~F|Mokhotlong~J|Qacha's Nek~H|Quthing~G|Thaba-Tseka~K"], ["Liberia", "LR", "Bomi~BM|Bong~BG|Gbarpolu~GP|Grand Bassa~GB|Grand Cape Mount~CM|Grand Gedeh~GG|Grand Kru~GK|Lofa~LO|Margibi~MG|Maryland~MY|Montserrado~MO|Nimba~NI|River Cess~RI|River Geee~RG|Sinoe~SI"], ["Libya", "LY", "Al Buţnān~BU|Al Jabal al Akhḑar~JA|Al Jabal al Gharbī~JG|Al Jafārah~JA|Al Jufrah~JU|Al Kufrah~FK|Al Marj~MJ|Al Marquab~MB|Al Wāḩāt~WA|An Nuqaţ al Khams~NQ|Az Zāwiyah~ZA|Banghāzī~BA|Darnah~DR|Ghāt~GH|Mişrātah~MI|Murzuq~MQ|Nālūt~NL|Sabhā~SB|Surt~SR|Ţarābulus~TB|Yafran~WD|Wādī ash Shāţiʾ~WS"], ["Liechtenstein", "LI", "Balzers~01|Eschen~02|Gamprin~03|Mauren~04|Planken~05|Ruggell~06|Schaan~07|Schellenberg~08|Triesen~09|Triesenberg~10|Vaduz~11"], ["Lithuania", "LT", "Alytaus~AL|Kauno~KU|Klaipėdos~KL|Marijampolės~MR|Panevėžio~PN|Šiaulių~SA|Tauragės~TA|Telšių~TE|Utenos~UT|Vilniaus~VL"], ["Luxembourg", "LU", "Capellen~CA|Clevaux~CL|Diekirch~DI|Echternach~EC|Esch-sur-Alzette~ES|Grevenmacher~GR|Luxembourg~LU|Mersch~ME|Redange~RD|Remich~RM|Vianden~VD|Wiltz~WI"], ["Macao", "MO", "Macao"], ["Macedonia, Republic of", "MK", "Aračinovo~02|Berovo~03|Bitola~04|Bogdanci~05|Bogovinje~06|Bosilovo~07|Brvenica~08|Centar Župa~78|Čaška~08|Češinovo-Obleševo~81|Čučer Sandevo~82|Debar~21|Debarca~22|Delčevo~23|Demir Hisar~25|Demir Kapija~24|Doran~26|Dolneni~27|Gevgelija~18|Gostivar~19|Gradsko~20|Ilinden~34|Jegunovce~35|Karbinci~37|Kavadarci~36|Kičevo~40|Kočani~42|Konče~41|Kratovo~43|Kriva Palanka~44|Krivogaštani~45|Kruševo~46|Kumanovo~47|Lipkovo~48|Lozovo~49|Makedonska Kamenica~51|Makedonski Brod~52|Mavrovo i Rostuša~50|Mogila~53|Negotino~54|Novaci~55|Novo Selo~56|Ohrid~58|Pehčevo~60|Petrovec~59|Plasnica~61|Prilep~62|Probištip~63|Radoviš~|Rankovce~65|Resen~66|Rosoman~67|Skopje~85|Sopište~70|Staro Nagoričane~71|Struga~72|Strumica~73|Studeničani~74|Sveti Nikole~69|Štip~83|Tearce~75|Tetovo~76|Valandovo~10|Vasilevo~11|Veles~13|Vevčani~12|Vinica~14|Vrapčište~16|Zelenikovo~32|Zrnovci~33|Želino~30"], ["Madagascar", "MG", "Antananarivo~T|Antsiranana~D|Fianarantsoa~F|Mahajanga~M|Toamasina~A|Toliara~U"], ["Malawi", "MW", "Balaka~BA|Blantyre~BL|Chikwawa~CK|Chiradzulu~CR|Chitipa~CT|Dedza~DE|Dowa~DO|Karonga~KR|Kasungu~KS|Likoma~LK|Lilongwe~LI|Machinga~MH|Mangochi~MG|Mchinji~MC|Mulanje~MU|Mwanza~MW|Mzimba~MZ|Nkhata Bay~NE|Nkhotakota~NB|Nsanje~NS|Ntcheu~NU|Ntchisi~NI|Phalombe~PH|Rumphi~RU|Salima~SA|Thyolo~TH|Zomba~ZO"], ["Malaysia", "MY", "Johor~01|Kedah~02|Kelantan~03|Melaka~04|Negeri Sembilan~05|Pahang~06|Perak~08|Perlis~09|Pulau Pinang~07|Sabah~12|Sarawak~13|Selangor~10|Terengganu~11|Wilayah Persekutuan (Kuala Lumpur)~14|Wilayah Persekutuan (Labuan)~15|Wilayah Persekutuan (Putrajaya)~16"], ["Maldives", "MV", "Alifu Alifu~02|Alifu Dhaalu~00|Baa~20|Dhaalu~17|Faafu~14|Gaafu Alifu~27|Gaafu Dhaalu~28|Gnaviyani~29|Haa Alifu~07|Haa Dhaalu~23|Kaafu~29|Laamu~05|Lhaviyani~03|Malé~MLE|Meemu~12|Noonu~25|Raa~13|Seenu~01|Shaviyani~24|Thaa~08|Vaavu~04"], ["Mali", "ML", "Bamako~BKO|Gao~7|Kayes~1|Kidal~8|Koulikoro~2|Mopti~5|Segou~4|Sikasso~3|Tombouctou~6"], ["Malta", "MT", "Attard~01|Balzan~02|Birgu~03|Birkirkara~04|Birżebbuġa~05|Bormla~06|Dingli~07|Fgura~08|Floriana~09|Fontana~10|Guda~11|Gżira~12|Għajnsielem~13|Għarb~14|Għargħur~15|Għasri~16|Għaxaq~17|Ħamrun~18|Iklin~19|Isla~20|Kalkara~21|Kerċem~22|Kirkop~23|Lija~24|Luqa~25|Marsa~26|Marsaskala~27|Marsaxlokk~28|Mdina~29|Mellieħa~30|Mġarr~31|Mosta~32|Mqabba~33|Msida~34|Mtarfa~35|Munxar~36|Nadur~37|Naxxar~38|Paola~39|Pembroke~40|Pietà~41|Qala~42|Qormi~43|Qrendi~44|Rabat Għawdex~45|Rabat Malta~46|Safi~47|San Ġiljan~48|San Ġwann~49|San Lawrenz~50|San Pawl il-Baħar~51|Sannat~52|Santa Luċija~53|Santa Venera~54|Siġġiewi~55|Sliema~56|Swieqi~57|Tai Xbiex~58|Tarzien~59|Valletta~60|Xagħra~61|Xewkija~62|Xgħajra~63|Żabbar~64|Żebbuġ Għawde~65|Żebbuġ Malta~66|Żejtun~67|Żurrieq~68"], ["Marshall Islands", "MH", "Ailinglaplap~ALL|Ailuk~ALK|Arno~ARN|Aur~AUR|Bikini and Kili~KIL|Ebon~EBO|Jabat~JAB|Jaluit~JAL|Kwajalein~KWA|Lae~LAE|Lib~LIB|Likiep~LIK|Majuro~MAJ|Maloelap~MAL|Mejit~MEJ|Namdrik~NMK|Namu~NMU|Rongelap~RON|Ujae~UJA|Utrik~UTI|Wotho~WTH|Wotje~WTJ"], ["Martinique", "MQ", "Martinique"], ["Mauritania", "MR", "Adrar~07|Assaba~03|Brakna~05|Dakhlet Nouadhibou~08|Gorgol~04|Guidimaka~10|Hodh Ech Chargui~01|Hodh El Gharbi~02|Inchiri~12|Nouakchott Nord~14|Nouakchott Ouest~13|Nouakchott Sud~15|Tagant~09|Tiris Zemmour~11|Trarza~06"], ["Mauritius", "MU", "Agalega Islands~AG|Beau Bassin-Rose Hill~BR|Black River~BL|Cargados Carajos Shoals~CC|Curepipe~CU|Flacq~FL|Grand Port~GP|Moka~MO|Pamplemousses~PA|Plaines Wilhems~PW|Port Louis (City)~PU|Port Louis~PL|Riviere du Rempart~RR|Rodrigues Island~RO|Savanne~SA|Vacoas-Phoenix~CP"], ["Mayotte", "YT", "Dzaoudzi~01|Pamandzi~02|Mamoudzou~03|Dembeni~04|Bandrélé~05|Kani-Kéli~06|Bouéni~07|Chirongui~08|Sada~09|Ouangani~10|Chiconi~11|Tsingoni~12|M'Tsangamouji~13|Acoua~14|Mtsamboro~15|Bandraboua~16|Koungou~17"], ["Mexico", "MX", "Aguascalientes~AGU|Baja California~BCN|Baja California Sur~BCS|Campeche~CAM|Ciudad de México~DIF|Chiapas~CHP|Chihuahua~CHH|Coahuila de Zaragoza~COA|Colima~COL|Durango~DUR|Estado de México~MEX|Guanajuato~GUA|Guerrero~GRO|Hidalgo~HID|Jalisco~JAL|Michoacán de Ocampo~MIC|Morelos~MOR|Nayarit~NAY|Nuevo León~NLE|Oaxaca~OAX|Puebla~PUE|Querétaro de Arteaga~QUE|Quintana Roo~ROO|San Luis Potosí~SLP|Sinaloa~SIN|Sonora~SON|Tabasco~TAB|Tamaulipas~TAM|Tlaxcala~TLA|Veracruz~VER|Yucatán~YUC|Zacatecas~ZAC"], ["Micronesia, Federated States of", "FM", "Chuuk (Truk)~TRK|Kosrae~KSA|Pohnpei~PNI|Yap~YAP"], ["Moldova", "MD", "Aenii Noi~AN|Basarabeasca~BS|Bălți~BA|Bender~BD|Briceni~BR|Cahul~CA|Cantemir~CT|Călărași~CL|Căușeni~CS|Chișinău~CU|Cimișlia~CM|Criuleni~CR|Dondușeni~DO|Drochia~DR|Dubăsari~DU|Edineț~ED|Fălești~FA|Florești~FL|Găgăuzia~GA|Glodeni~GL|Hîncești~HI|Ialoveni~IA|Leova~LE|Nisporeni~NI|Ocnița~OC|Orhei~OR|Rezina~RE|Rîșcani~RI|Sîngerei~SI|Soroca~SO|Stînga Nistrului~SN|Strășeni~ST|Șoldănești~SD|Ștefan Vodă~SV|Taraclia~TA|Telenești~TE|Ungheni~UN"], ["Monaco", "MC", "Colle~CL|Condamine~CO|Fontvieille~FO|Gare~GA|Jardin Exotique~JE|Larvotto~LA|Malbousquet~MA|Monaco-Ville~MO|Moneghetti~MG|Monte-Carlo~MC|Moulins~MU|Port-Hercule~PH|Saint-Roman~SR|Sainte-Dévote~SD|Source~SO|Spélugues~SP|Vallon de la Rousse~VR"], ["Mongolia", "MN", "Arhangay~073|Bayan-Olgiy~071|Bayanhongor~069|Bulgan~067|Darhan~037|Dornod~061|Dornogovi~063|Dundgovi~059|Dzavhan~065|Govi-Altay~065|Govi-Sumber~064|Hovd~043|Hovsgol~041|Omnogovi~053|Ovorhangay~055|Selenge~049|Suhbaatar~051|Tov~047|Ulaanbaatar~1|Uvs~046"], ["Montenegro", "ME", "Andrijevica~01|Bar~02|Berane~03|Bijelo Polje~04|Budva~05|Cetinje~06|Danilovgrad~07|Gusinje~22|Herceg Novi~08|Kolašin~09|Kotor~10|Mojkovac~11|Nikšić~12|Petnica~23|Plav~13|Plužine~14|Pljevlja~15|Podgorica~16|Rožaje~17|Šavnik~18|Tivat~19|Ulcinj~20|Žabljak~21"], ["Montserrat", "MS", "Saint Anthony|Saint Georges|Saint Peter's"], ["Morocco", "MA", "Chaouia-Ouardigha~09|Doukhala-Abda~10|Fès-Boulemane~05|Gharb-Chrarda-Beni Hssen~02|Grand Casablanca~08|Guelmim-Es Semara~14|Laâyoune-Boujdour-Sakia el Hamra~15|Marrakech-Tensift-Al Haouz~11|Meknès-Tafilalet~06|Oriental~04|Oued ed Dahab-Lagouira~16|Souss-Massa-Drâa~13|Tadla-Azilal~12|Tanger-Tétouan~01|Taza-Al Hoceima-Taounate~03"], ["Mozambique", "MZ", "Cabo Delgado~P|Gaza~G|Inhambane~I|Manica~B|Maputo~L|Maputo (City)~MPM|Nampula~N|Niassa~A|Sofala~S|Tete~T|Zambezia~Q"], ["Myanmar", "MM", "Ayeyarwady~07|Bago~02|Chin~14|Kachin~11|Kayah~12|Kayin~13|Magway~03|Mandalay~04|Mon~15|Nay Pyi Taw~18|Rakhine~16|Sagaing~01|Shan~17|Tanintharyi~05|Yangon~06"], ["Namibia", "NA", "Erongo~ER|Hardap~HA|Kavango East~KE|Kavango West~KW|Karas~KA|Khomas~KH|Kunene~KU|Ohangwena~OW|Omaheke~OH|Omusati~OS|Oshana~ON|Oshikoto~OT|Otjozondjupa~OD|Zambezi~CA"], ["Nauru", "NR", "Aiwo~01|Anabar~02|Anetan~03|Anibare~04|Baiti~05|Boe~06|Buada~07|Denigomodu~08|Ewa~09|Ijuw~10|Meneng~11|Nibok~12|Uaboe~13|Yaren~14"], ["Nepal", "NP", "Bagmati~BA|Bheri~BH|Dhawalagiri~DH|Gandaki~GA|Janakpur~JA|Karnali~KA|Kosi~KO|Lumbini~LU|Mahakali~MA|Mechi~ME|Narayani~NA|Rapti~RA|Sagarmatha~SA|Seti~SE"], ["Netherlands", "NL", "Drenthe~DR|Flevoland~FL|Friesland~FR|Gelderland~GE|Groningen~GR|Limburg~LI|Noord-Brabant~NB|Noord-Holland~NH|Overijssel~OV|Utrecht~UT|Zeeland~ZE|Zuid-Holland~ZH"], ["New Caledonia", "NC", "Iles Loyaute|Nord|Sud"], ["New Zealand", "NZ", "Auckland~AUK|Bay of Plenty~BOP|Canterbury~CAN|Gisborne~GIS|Hawke's Bay~HKB|Marlborough~MBH|Manawatu-Wanganui~MWT|Northland~NTL|Nelson~NSN|Otago~OTA|Southland~STL|Taranaki~TKI|Tasman~TAS|Waikato~WKO|Wellington~WGN|West Coast~WTC|Chatham Islands Territory~CIT"], ["Nicaragua", "NI", "Boaco~BO|Carazo~CA|Chinandega~CI|Chontales~CO|Estelí~ES|Granada~GR|Jinotega~JI|León~LE|Madriz~MD|Managua~MN|Masaya~MS|Matagalpa~MT|Nueva Segovia~NS|Río San Juan~SJ|Rivas~RI|Atlántico Norte~AN|Atlántico Sur~AS"], ["Niger", "NE", "Agadez~1|Diffa~2|Dosso~3|Maradi~4|Niamey~8|Tahoua~5|Tillabéri~6|Zinder~7"], ["Nigeria", "NG", "Abia~AB|Abuja Federal Capital Territory~FC|Adamawa~AD|Akwa Ibom~AK|Anambra~AN|Bauchi~BA|Bayelsa~BY|Benue~BE|Borno~BO|Cross River~CR|Delta~DE|Ebonyi~EB|Edo~ED|Ekiti~EK|Enugu~EN|Gombe~GO|Imo~IM|Jigawa~JI|Kaduna~KD|Kano~KN|Katsina~KT|Kebbi~KE|Kogi~KO|Kwara~KW|Lagos~LA|Nassarawa~NA|Niger~NI|Ogun~OG|Ondo~ON|Osun~OS|Oyo~OY|Plateau~PL|Rivers~RI|Sokoto~SO|Taraba~TA|Yobe~YO|Zamfara~ZA"], ["Niue", "NU", "Niue"], ["Norfolk Island", "NF", "Norfolk Island"], ["Northern Mariana Islands", "MP", "Northern Islands|Rota|Saipan|Tinian"], ["Norway", "NO", "Akershus~02|Aust-Agder~09|Buskerud~06|Finnmark~20|Hedmark~04|Hordaland~12|Møre og Romsdal~15|Nordland~18|Nord-Trøndelag~17|Oppland~05|Oslo~03|Rogaland~11|Sogn og Fjordane~14|Sør-Trøndelag~16|Telemark~08|Troms~19|Vest-Agder~10|Vestfold~07|Østfold~01|Jan Mayen~22|Svalbard~21"], ["Oman", "OM", "Ad Dakhiliyah~DA|Al Buraymi~BU|Al Wusta~WU|Az Zahirah~ZA|Janub al Batinah~BS|Janub ash Sharqiyah~SS|Masqat~MA|Musandam~MU|Shamal al Batinah~BJ|Shamal ash Sharqiyah~SJ|Zufar~ZU"], ["Pakistan", "PK", "Āzād Kashmīr~JK|Balōchistān~BA|Gilgit-Baltistān~GB|Islāmābād~IS|Khaībar Pakhtūnkhwās~KP|Punjāb~PB|Sindh~SD|Federally Administered Tribal Areas~TA"], ["Palau", "PW", "Aimeliik~002|Airai~004|Angaur~010|Hatobohei~050|Kayangel~100|Koror~150|Melekeok~212|Ngaraard~214|Ngarchelong~218|Ngardmau~222|Ngatpang~224|Ngchesar~226|Ngeremlengui~227|Ngiwal~228|Peleliu~350|Sonsoral~350"], ["Palestine, State of", "PS", "Ak Khalīl~HBN|Al Quds~JEM|Arīḩā wal Aghwār~JRH|Bayt Laḩm~BTH|Dayr al Balaḩ~DEB|Ghazzah~GZA|Janīn~JEN|Khān Yūnis~KYS|Nāblus~NBS|Qalqīyah~QQA|Rafaḩ~RFH|Rām Allāh wal Bīrah~RBH|Salfīt~SLT|Shamāl Ghazzah~NGZ|Ţūbās~TBS|Ţūlkarm~TKM"], ["Panama", "PA", "Bocas del Toro~1|Chiriquí~4|Coclé~2|Colón~3|Darién~5|Emberá~EM|Herrera~6|Kuna Yala~KY|Los Santos~7|Ngäbe-Buglé~NB|Panamá~8|Panamá Oeste~10|Veraguas~9"], ["Papua New Guinea", "PG", "Bougainville~NSB|Central~CPM|Chimbu~CPK|East New Britain~EBR|East Sepik~ESW|Eastern Highlands~EHG|Enga~EPW|Gulf~GPK|Hela~HLA|Jiwaka~JWK|Madang~MOM|Manus~MRL|Milne Bay~MBA|Morobe~MPL|Port Moresby~NCD|New Ireland~NIK|Northern~NPP|Southern Highlands~SHM|West New Britain~WBK|West Sepik~SAN|Western~WPD|Western Highlands~WHM"], ["Paraguay", "PY", "Alto Paraguay~16|Alto Parana~10|Amambay~13|Asuncion~ASU|Caaguazu~5|Caazapa~6|Canindeyu~14|Central~11|Concepcion~1|Cordillera~3|Guaira~4|Itapua~7|Misiones~8|Neembucu~12|Paraguari~9|Presidente Hayes~15|San Pedro~2"], ["Peru", "PE", "Amazonas~AMA|Ancash~ANC|Apurimac~APU|Arequipa~ARE|Ayacucho~AYA|Cajamarca~CAJ|Callao~CAL|Cusco~CUS|Huancavelica~HUV|Huanuco~HUC|Ica~ICA|Junin~JUN|La Libertad~LAL|Lambayeque~LAM|Lima~LIM|Loreto~LOR|Madre de Dios~MDD|Moquegua~MOQ|Municipalidad Metropolitana de Lima~LMA|Pasco~PAS|Piura~PIU|Puno~PUN|San Martin~SAM|Tacna~TAC|Tumbes~TUM|Ucayali~UCA"], ["Philippines", "PH", "Abra~ABR|Agusan del Norte~AGN|Agusan del Sur~AGS|Aklan~AKL|Albay~ALB|Antique~ANT|Apayao~APA|Aurora~AUR|Basilan~BAS|Bataan~BAN|Batanes~BTN|Batangas~BTG|Benguet~BEN|Biliran~BIL|Bohol~BOH|Bukidnon~BUK|Bulacan~BUL|Cagayan~CAG|Camarines Norte~CAN|Camarines Sur~CAS|Camiguin~CAM|Capiz~CAP|Catanduanes~CAT|Cavite~CAV|Cebu~CEB|Compostela~COM|Cotabato~NCO|Davao del Norte~DAV|Davao del Sur~DAS|Davao Occidental~DVO|Davao Oriental~DAO|Dinagat Islands~DIN|Eastern Samar~EAS|Guimaras~GUI|Ifugao~IFU|Ilocos Norte~ILN|Ilocos Sur~ILS|Iloilo~ILI|Isabela~ISA|Kalinga~KAL|La Union~LUN|Laguna~LAG|Lanao del Norte~LAN|Lanao del Sur~LAS|Leyte~LEY|Maguindanao~MAG|Masbate~MAS|Metro Manila~00|Mindoro Occidental~MDC|Mindoro Oriental~MDR|Misamis Occidental~MSC|Misamis Oriental~MSR|Mountain Province~MOU|Negros Occidental~NEC|Negros Oriental~NER|Northern Samar~NSA|Nueva Ecija~NUE|Nueva Vizcaya~NUV|Palawan~PLW|Pampanga~PAM|Pangasinan~PAN|Quezon~QUE|Quirino~QUI|Rizal~RIZ|Romblon~ROM|Samar~WSA|Sarangani~SAR|Siquijor~SIG|Sorsogon~SOR|Southern Leyte~SLE|Sultan Kudarat~AUK|Sulu~SLU|Surigao del Norte~SUN|Surigao del Sur~SUR|Tarlac~TAR|Tawi-Tawi~TAW|Zambales~ZMB|Zamboanga del Norte~ZAN|Zamboanga del Sur~ZAS|Zamboanga Sibugay~ZSI"], ["Pitcairn", "PN", "Pitcairn Islands"], ["Poland", "PL", "Dolnośląskie~DS|Kujawsko-pomorskie~KP|Łódzkie~LD|Lubelskie~LU|Lubuskie~LB|Malopolskie~MA|Mazowieckie~MZ|Opolskie~OP|Podkarpackie~PK|Podlaskie~PD|Pomorskie~PM|Śląskie~SL|Świętokrzyskie~SK|Warmińsko-mazurskie~WN|Wielkopolskie~WP|Zachodniopomorskie~ZP"], ["Portugal", "PT", "Acores~20|Aveiro~01|Beja~02|Braga~03|Braganca~04|Castelo Branco~05|Coimbra~06|Evora~07|Faro~08|Guarda~09|Leiria~10|Lisboa~11|Madeira~30|Portalegre~12|Porto~13|Santarem~14|Setubal~15|Viana do Castelo~16|Vila Real~17|Viseu~18"], ["Puerto Rico", "PR", "Adjuntas|Aguada|Aguadilla|Aguas Buenas|Aibonito|Anasco|Arecibo|Arroyo|Barceloneta|Barranquitas|Bayamon|Cabo Rojo|Caguas|Camuy|Canovanas|Carolina|Cat|Ceiba|Ciales|Cidra|Coamo|Comerio|Corozal|Culebra|Dorado|Fajardo|Florida|Guanica|Guayama|Guayanilla|Guaynabo|Gurabo|Hatillo|Hormigueros|Humacao|Isabe|Juana Diaz|Juncos|Lajas|Lares|Las Marias|Las oiza|Luquillo|Manati|Maricao|Maunabo|Mayaguez|Moca|Morovis|Naguabo|Naranjito|Orocovis|Patillas|Penuelas|Ponce|Quebradillas|Rincon|Rio Grande|Sabana linas|San German|San Juan|San Lorenzo|San Sebastian|Santa Isabel|Toa Alta|Toa Baja|Trujillo Alto|Utuado|Vega Alta|Vega ues|Villalba|Yabucoa|Yauco"], ["Qatar", "QA", "Ad Dawḩah~DA|Al Khawr wa adh Dhakhīrah~KH|Al Wakrah~WA|Ar Rayyān~RA|Ash Shamāl~MS|Az̧ Za̧`āyin~ZA|Umm Şalāl~US"], ["Réunion", "RE", "Réunion"], ["Romania", "RO", "Alba~AB|Arad~AR|Arges~AG|Bacau~BC|Bihor~BH|Bistrita-Nasaud~BN|Botosani~BT|Braila~BR|Brasov~BV|Bucuresti~B|Buzau~BZ|Calarasi~CL|Caras-Severin~CS|Cluj~CJ|Constanta~CT|Covasna~CV|Dambovita~DB|Dolj~DJ|Galati~GL|Giurgiu~GR|Gorj~GJ|Harghita~HR|Hunedoara~HD|Ialomita~IL|Iasi~IS|Maramures~MM|Mehedinti~MH|Mures~MS|Neamt~NT|Olt~OT|Prahova~PH|Salaj~SJ|Satu Mare~SM|Sibiu~SB|Suceava~SV|Teleorman~TR|Timis~TM|Tulcea~TL|Valcea~VL|Vaslui~VS|Vrancea~VN"], ["Russian Federation", "RU", "Republic of Adygea~AD|Republic of Altai (Gorno-Altaysk)~AL|Altai Krai~ALT|Amur Oblast~AMU|Arkhangelsk Oblast~ARK|Astrakhan Oblast~AST|Republic of Bashkortostan~BA|Belgorod Oblast~BEL|Bryansk Oblast~BRY|Republic of Buryatia~BU|Chechen Republic~CE|Chelyabinsk Oblast~CHE|Chukotka Autonomous Okrug~CHU|Chuvash Republic~CU|Republic of Dagestan~DA|Republic of Ingushetia~IN|Irkutsk Oblast~IRK|Ivanovo Oblast~IVA|Jewish Autonomous Oblast~JEW|Kabardino-Balkar Republic~KB|Kaliningrad Oblast~KLN|Republic of Kalmykia~KL|Kaluga Oblast~KLU|Kamchatka Krai~KAM|Karachay-Cherkess Republic~KC|Republic of Karelia~KR|Khabarovsk Krai~KHA|Republic of Khakassia~KK|Khanty-Mansi Autonomous Okrug - Yugra~KHM|Kemerovo Oblast~KEM|Kirov Oblast~KIR|Komi Republic~KO|Kostroma Oblast~KOS|Krasnodar Krai~KDA|Krasnoyarsk Krai~KYA|Kurgan Oblast~KGN|Kursk Oblast~KRS|Leningrad Oblast~LEN|Lipetsk Oblast~LIP|Magadan Oblast~MAG|Mari El Republic~ME|Republic of Mordovia~MO|Moscow Oblast~MOS|Moscow~MOW|Murmansk Oblast~MU|Nenets Autonomous Okrug~NEN|Nizhny Novgorod Oblast~NIZ|Novgorod Oblast~NGR|Novosibirsk Oblast~NVS|Omsk Oblast~OMS|Orenburg Oblast~ORE|Oryol Oblast~ORL|Penza Oblast~PNZ|Perm Krai~PER|Primorsky Krai~PRI|Pskov Oblast~PSK|Rostov Oblast~ROS|Ryazan Oblast~RYA|Saint Petersburg~SPE|Sakha (Yakutia) Republic~SA|Sakhalin Oblast~SAK|Samara Oblast~SAM|Saratov Oblast~SAR|Republic of North Ossetia-Alania~NOA|Smolensk Oblast~SMO|Stavropol Krai~STA|Sverdlovsk Oblast~SVE|Tambov Oblast~TAM|Republic of Tatarstan~TA|Tomsk Oblast~TOM|Tuva Republic~TU|Tula Oblast~TUL|Tver Oblast~TVE|Tyumen Oblast~TYU|Udmurt Republic~UD|Ulyanovsk Oblast~ULY|Vladimir Oblast~VLA|Volgograd Oblast~VGG|Vologda Oblast~VLG|Voronezh Oblast~VOR|Yamalo-Nenets Autonomous Okrug~YAN|Yaroslavl Oblast~YAR|Zabaykalsky Krai~ZAB"], ["Rwanda", "RW", "Kigali~01|Eastern~02|Northern~03|Western~04|Southern~05"], ["Saint Barthélemy", "BL", "Au Vent~02|Sous le Vent~01"], ["Saint Helena, Ascension and Tristan da Cunha", "SH", "Ascension~AC|Saint Helena~HL|Tristan da Cunha~TA"], ["Saint Kitts and Nevis", "KN", "Saint Kitts~K|Nevis~N"], ["Saint Lucia", "LC", "Anse-la-Raye~01|Canaries~12|Castries~02|Choiseul~03|Dennery~05|Gros Islet~06|Laborie~07|Micoud~08|Soufriere~10|Vieux Fort~11"], ["Saint Martin", "MF", "Saint Martin"], ["Saint Pierre and Miquelon", "PM", "Miquelon|Saint Pierre"], ["Saint Vincent and the Grenadines", "VC", "Charlotte~01|Grenadines~06|Saint Andrew~02|Saint David~03|Saint George~04|Saint Patrick~05"], ["Samoa", "WS", "A'ana~AA|Aiga-i-le-Tai~AL|Atua~AT|Fa'asaleleaga~FA|Gaga'emauga~GE|Gagaifomauga~GI|Palauli~PA|Satupa'itea~SA|Tuamasaga~TU|Va'a-o-Fonoti~VF|Vaisigano~VS"], ["San Marino", "SM", "Acquaviva~01|Borgo Maggiore~06|Chiesanuova~02|Domagnano~03|Faetano~04|Fiorentino~05|Montegiardino~08|San Marino~07|Serravalle~09"], ["Sao Tome and Principe", "ST", "Principe~P|Sao Tome~S"], ["Saudi Arabia", "SA", "'Asir~14|Al Bahah~11|Al Hudud ash Shamaliyah~08|Al Jawf~12|Al Madinah al Munawwarah~03|Al Qasim~05|Ar Riyad~01|Ash Sharqiyah~04|Ha'il~06|Jazan~09|Makkah al Mukarramah~02|Najran~10|Tabuk~07"], ["Senegal", "SN", "Dakar~DK|Diourbel~DB|Fatick~FK|Kaffrine~KA|Kaolack~KL|Kedougou~KE|Kolda~KD|Louga~LG|Matam~MT|Saint-Louis~SL|Sedhiou~SE|Tambacounda~TC|Thies~TH|Ziguinchor~ZG"], ["Serbia", "RS", "Beograd (Belgrade)~00|Borski~14|Braničevski~11|Jablanički~23|Južnobački~06|Južnobanatski~04|Kolubarski~09|Kosovski~25|Kosovsko-Mitrovački~28|Kosovsko-Pomoravski~29|Mačvanski~08|Moravički~17|Nišavski~20|Pčinjski~24|Pećki~26|Pirotski~22|Podunavski~10|Pomoravski~13|Prizrenski~27|Rasinski~19|Raški~18|Severnobački~01|Severnobanatski~03|Srednjebanatski~02|Sremski~07|Šumadijski~12|Toplički~21|Zaječarski~15|Zapadnobački~05|Zlatiborski~16"], ["Seychelles", "SC", "Anse aux Pins~01|Anse Boileau~02|Anse Etoile~03|Anse Royale~05|Anu Cap~04|Baie Lazare~06|Baie Sainte Anne~07|Beau Vallon~08|Bel Air~09|Bel Ombre~10|Cascade~11|Glacis~12|Grand'Anse Mahe~13|Grand'Anse Praslin~14|La Digue~15|La Riviere Anglaise~16|Les Mamelles~24|Mont Buxton~17|Mont Fleuri~18|Plaisance~19|Pointe La Rue~20|Port Glaud~21|Roche Caiman~25|Saint Louis~22|Takamaka~23"], ["Sierra Leone", "SL", "Eastern~E|Northern~N|Southern~S|Western~W"], ["Singapore", "SG", "Central Singapore~01|North East~02|North West~03|South East~04|South West~05"], ["Sint Maarten (Dutch part)", "SX", "Sint Maarten"], ["Slovakia", "SK", "Banskobystricky~BC|Bratislavsky~BL|Kosicky~KI|Nitriansky~NI|Presovsky~PV|Trenciansky~TC|Trnavsky~TA|Zilinsky~ZI"], ["Slovenia", "SI", "Ajdovscina~001|Apace~195|Beltinci~002|Benedikt~148|Bistrica ob Sotli~149|Bled~003|Bloke~150|Bohinj~004|Borovnica~005|Bovec~006|Braslovce~151|Brda~007|Brezice~009|Brezovica~008|Cankova~152|Celje~011|Cerklje na Gorenjskem~012|Cerknica~013|Cerkno~014|Cerkvenjak~153|Cirkulane~196|Crensovci~015|Crna na Koroskem~016|Crnomelj~017|Destrnik~018|Divaca~019|Dobje~154|Dobrepolje~020|Dobrna~155|Dobrova-Polhov Gradec~021|Dobrovnik~156|Dol pri Ljubljani~022|Dolenjske Toplice~157|Domzale~023|Dornava~024|Dravograd~025|Duplek~026|Gorenja Vas-Poljane~027|Gorisnica~028|Gorje~207|Gornja Radgona~029|Gornji Grad~030|Gornji Petrovci~031|Grad~158|Grosuplje~032|Hajdina~159|Hoce-Slivnica~160|Hodos~161|Horjul~162|Hrastnik~034|Hrpelje-Kozina~035|Idrija~036|Ig~037|Ilirska Bistrica~038|Ivancna Gorica~039|Izola~040s|Jesenice~041|Jursinci~042|Kamnik~043|Kanal~044|Kidricevo~045|Kobarid~046|Kobilje~047|Kocevje~048|Komen~049|Komenda~164|Koper~050|Kodanjevica na Krki~197|Kostel~165|Kozje~051|Kranj~052|Kranjska Gora~053|Krizevci~166|Krsko~054|Kungota~055|Kuzma~056|Lasko~057|Lenart~058|Lendava~059|Litija~068|Ljubljana~061|Ljubno~062|Ljutomer~063|Log-Dragomer~208|Logatec~064|Loska Dolina~065|Loski Potok~066|Lovrenc na Pohorju~167|Lukovica~068|Luce~067|Majsperk~069|Makole~198|Maribor~070|Markovci~168|Medvode~071|Menges~072|Metlika~073|Mezica~074|Miklavz na Dravskem Polju~169|Miren-Kostanjevica~075|Mirna~212|Mirna Pec~170|Mislinja~076|Mokronog-Trebelno~199|Moravce~077|Moravske Toplice~078|Mozirje~079|Murska Sobota~080|Naklo~082|Nazarje~083|Nova Gorica~084|Novo Mesto~085|Odranci~086|Ormoz~087|Osilnica~088|Pesnica~089|Piran~090|Pivka~091|Podcetrtek~092|Podlehnik~172|Podvelka~093|Poljcane~200|Postojna~094|Prebold~174|Preddvor~095|Prevalje~175|Ptuj~096|Race-Fram~098|Radece~099|Radenci~100|Radlje ob Dravi~101|Radovljica~102|Ravne na Koroskem~103|Razkrizje~176|Recica ob Savinji~209|Rence-Vogrsko~201|Ribnica~104|Ribnica na Poboriu~177|Rogaska Slatina~106|Rogasovci~105|Rogatec~107|Ruse~108|Salovci~033|Selnica ob Dravi~178|Semic~109|Sempeter-Vrtojba~183|Sencur~117|Sentilj~118|Sentjernej~119|Sentjur~120|Sentrupert~211|Sevnica~110|Sezana~111|Skocjan~121|Skofja Loka~122|Skofljica~123|Slovenj Gradec~112|Slovenska Bistrica~113|Slovenske Konjice~114|Smarje pri elsah~124|Smarjeske Toplice~206|Smartno ob Paki~125|Smartno pri Litiji~194|Sodrazica~179|Solcava~180|Sostanj~126|Sredisce ob Dravi~202|Starse~115|Store~127|Straza~203|Sveta Ana~181|Sveta Trojica v Slovenskih Goricah~204|Sveta Andraz v Slovenskih Goricah~182|Sveti Jurij~116|Sveti Jurij v Slovenskih Goricah~210|Sveti Tomaz~205|Tabor~184|Tisina~128|Tolmin~128|Trbovlje~129|Trebnje~130|Trnovska Vas~185|Trzin~186|Trzic~131|Turnisce~132|Velenje~133|Velika Polana~187|Velike Lasce~134|Verzej~188|Videm~135|Vipava~136|Vitanje~137|Vodice~138|Vojnik~139|Vransko~189|Vrhnika~140|Vuzenica~141|Zagorje ob Savi~142|Zavrc~143|Zrece~144|Zalec~190|Zelezniki~146|Zetale~191|Ziri~147|Zirovnica~192|Zuzemberk~193"], ["Solomon Islands", "SB", "Central~CE|Choiseul~CH|Guadalcanal~GU|Honiara~CT|Isabel~IS|Makira-Ulawa~MK|Malaita~ML|Rennell and Bellona~RB|Temotu~TE|Western~WE"], ["Somalia", "SO", "Awdal~AW|Bakool~BK|Banaadir~BN|Bari~BR|Bay~BY|Galguduud~GA|Gedo~GE|Hiiraan~HI|Jubbada Dhexe~JD|Jubbada Hoose~JH|Mudug~MU|Nugaal~NU|Sanaag~SA|Shabeellaha Dhexe~SD|Shabeellaha Hoose~SH|Sool~SO|Togdheer~TO|Woqooyi Galbeed~WO"], ["South Africa", "ZA", "Eastern Cape~EC|Free State~FS|Gauteng~GT|KwaZulu-Natal~NL|Limpopo~LP|Mpumalanga~MP|Northern Cape~NC|North West~NW|Western Cape~WC"], ["South Georgia and South Sandwich Islands", "GS", "Bird Island|Bristol Island|Clerke Rocks|Montagu Island|Saunders Island|South Georgia|Southern Thule|Traversay Islands"], ["South Sudan", "SS", "Central Equatoria~CE|Eastern Equatoria~EE|Jonglei~JG|Lakes~LK|Northern Bahr el Ghazal~BN|Unity~UY|Upper Nile~NU|Warrap~WR|Western Bahr el Ghazal~BW|Western Equatoria~EW"], ["Spain", "ES", "Albacete~CM|Alicante~VC|Almería~AN|Araba/Álava~VI|Asturias~O|Ávila~AV|Badajoz~BA|Barcelona~B|Bizkaia~BI|Burgos~BU|Cáceres~CC|Cádiz~CA|Cantabria~S|Castellón~CS|Cueta~CU|Ciudad Real~CR|Córdoba~CO|A Coruña~C|Cuenca~CU|Gipuzkoa~SS|Girona~GI|Granada~GR|Guadalajara~GU|Huelva~H|Huesca~HU|Illes Balears~PM|Jaén~J|León~LE|Lleida~L|Lugo~LU|Madrid~M|Málaga~MA|Melilla~ML|Murcia~MU|Navarre~NA|Ourense~OR|Palencia~P|Las Palmas~GC|Pontevedra~PO|La Rioja~LO|Salamanca~SA|Santa Cruz de Tenerife~TF|Segovia~SG|Sevilla~SE|Soria~SO|Tarragona~T|Teruel~TE|Toledo~TO|Valencia~V|Valladolid~VA|Zamora~ZA|Zaragoza~Z"], ["Sri Lanka", "LK", "Basnahira~1|Dakunu~3|Madhyama~2|Naegenahira~5|Sabaragamuwa~9|Uturu~4|Uturumaeda~7|Vayamba~6|Uva~8"], ["Sudan", "SD", "Al Bahr al Ahmar~RS|Al Jazirah~GZ|Al Khartum~KH|Al Qadarif~GD|An Nil al Abyad~NW|An Nil al Azraq~NB|Ash Shamaliyah~NO|Gharb Darfur~DW|Gharb Kurdufan~GK|Janub Darfur~DS|Janub Kurdufan~KS|Kassala~KA|Nahr an Nil~NR|Shamal Darfur~DN|Sharq Darfur~DE|Shiamal Kurdufan~KN|Sinnar~SI|Wasat Darfur Zalinjay~DC"], ["Suriname", "SR", "Brokopondo~BR|Commewijne~CM|Coronie~CR|Marowijne~MA|Nickerie~NI|Para~PR|Paramaribo~PM|Saramacca~SA|Sipaliwini~SI|Wanica~WA"], ["Swaziland", "SZ", "Hhohho~HH|Lubombo~LU|Manzini~MA|Shiselweni~SH"], ["Sweden", "SE", "Blekinge~K|Dalarnas~W|Gotlands~X|Gavleborgs~I|Hallands~N|Jamtlands~Z|Jonkopings~F|Kalmar~H|Kronobergs~G|Norrbottens~BD|Orebro~T|Ostergotlands~E|Skane~M|Sodermanlands~D|Stockholm~AB|Varmlands~S|Vasterbottens~AC|Vasternorrlands~Y|Vastmanlands~U|Vastra Gotalands~O"], ["Switzerland", "CH", "Aargau~AG|Appenzell Ausserrhoden~AR|Appenzell Innerhoden~AI|Basel-Landschaft~BL|Basel-Stadt~BS|Bern~BE|Fribourg~FR|Genève~GE|Glarus~GL|Graubünden~GR|Jura~JU|Luzern~LU|Neuchâtel~NE|Nidwalden~NW|Obwalden~OW|Sankt Gallen~SG|Schaffhausen~SH|Schwyz~SZ|Solothurn~SO|Thurgau~TG|Ticino~TI|Uri~UR|Valais~VS|Vaud~VD|Zug~ZG|Zürich~ZH"], ["Syrian Arab Republic", "SY", "Al Hasakah~HA|Al Ladhiqiyah~LA|Al Qunaytirah~QU|Ar Raqqah~RA|As Suwayda'~SU|Dar'a~DR|Dayr az Zawr~DY|Dimashq~DI|Halab~HL|Hamah~HM|Hims~HI|Idlib~ID|Rif Dimashq~RD|Tartus~TA"], ["Taiwan", "TW", "Chang-hua~CHA|Chia-i~CYQ|Hsin-chu~HSQ|Hua-lien~HUA|Kao-hsiung~KHH|Keelung~KEE|Kinmen~KIN|Lienchiang~LIE|Miao-li~MIA|Nan-t'ou~NAN|P'eng-hu~PEN|New Taipei~NWT|P'ing-chung~PIF|T'ai-chung~TXG|T'ai-nan~TNN|T'ai-pei~TPE|T'ai-tung~TTT|T'ao-yuan~TAO|Yi-lan~ILA|Yun-lin~YUN"], ["Tajikistan", "TJ", "Dushanbe~DU|Kŭhistoni Badakhshon~GB|Khatlon~KT|Sughd~SU"], ["Tanzania, United Republic of", "TZ", "Arusha~01|Coast~19|Dar es Salaam~02|Dodoma~03|Iringa~04|Kagera~05|Kigoma~08|Kilimanjaro~09|Lindi~12|Manyara~26|Mara~13|Mbeya~14|Morogoro~16|Mtwara~17|Mwanza~18|Pemba North~06|Pemba South~10|Rukwa~20|Ruvuma~21|Shinyanga~22|Singida~23|Tabora~24|Tanga~25|Zanzibar North~07|Zanzibar Central/South~11|Zanzibar Urban/West~15"], ["Thailand", "TH", "Amnat Charoen~37|Ang Thong~15|Bueng Kan~38|Buri Ram~31|Chachoengsao~24|Chai Nat~18|Chaiyaphum~36|Chanthaburi~22|Chiang Mai~50|Chiang Rai~57|Chon Buri~20|Chumphon~86|Kalasin~46|Kamphaeng Phet~62|Kanchanaburi~71|Khon Kaen~40|Krabi~81|Krung Thep Mahanakhon (Bangkok)~10|Lampang~52|Lamphun~51|Loei~42|Lop Buri~16|Mae Hong Son~58|Maha Sarakham~44|Mukdahan~49|Nakhon Nayok~26|Nakhon Phathom~73|Nakhon Phanom~48|Nakhon Ratchasima~30|Nakhon Sawan~60|Nakhon Si Thammarat~80|Nan~55|Narathiwat~96|Nong Bua Lam Phu~39|Nong Khai~43|Nonthaburi~12|Pathum Thani~13|Pattani~94|Phangnga~82|Phatthalung~93|Phayao~56|Phetchabun~76|Phetchaburi~76|Phichit~66|Phitsanulok~65|Phra Nakhon Si Ayutthaya~14|Phrae~54|Phuket~83|Prachin Buri~25|Prachuap Khiri Khan~77|Ranong~85|Ratchaburi~70|Rayong~21|Roi Et~45|Sa Kaeo~27|Sakon Nakhon~47|Samut Prakan~11|Samut Sakhon~74|Samut Songkhram~75|Saraburi~19|Satun~91|Sing Buri~17|Si Sa ket~33|Songkhla~90|Sukhothai~64|Suphan Buri~72|Surat Thani~84|Surin~32|Tak~63|Trang~92|Trat~23|Ubon Ratchathani~34|Udon Thani~41|Uthai Thani~61|Uttaradit~53|Yala~95|Yasothon~35"], ["Timor-Leste", "TL", "Aileu~AL|Ainaro~AN|Baucau~BA|Bobonaro~BO|Cova Lima~CO|Dili~DI|Ermera~ER|Lautem~LA|Liquica~LI|Manatuto~MT|Manufahi~MF|Oecussi~OE|Viqueque~VI"], ["Togo", "TG", "Centre~C|Kara~K|Maritime~M|Plateaux~P|Savannes~S"], ["Tokelau", "TK", "Atafu|Fakaofo|Nukunonu"], ["Tonga", "TO", "'Eua~01|Ha'apai~02|Niuas~03|Tongatapu~04|Vava'u~05"], ["Trinidad and Tobago", "TT", "Arima~ARI|Chaguanas~CHA|Couva-Tabaquite-Talparo~CTT|Diefo Martin~DMN|Mayaro-Rio Claro~MRC|Penal-Debe~PED|Point Fortin~PTF|Port-of-Spain~POS|Princes Town~PRT|San Fernando~SFO|San Juan-Laventille~SJL|Sangre Grande~SGE|Siparia~SIP|Tobago~TOB|Tunapuna-Piarco~TUP"], ["Tunisia", "TN", "Ariana~12|Beja~31|Ben Arous~13|Bizerte~23|Gabes~81|Gafsa~71|Jendouba~32|Kairouan~41|Kasserine~42|Kebili~73|Kef~33|Mahdia~53|Medenine~82|Monastir~52|Nabeul~21|Sfax~61|Sidi Bouzid~43|Siliana~34|Sousse~51|Tataouine~83|Tozeur~72|Tunis~11|Zaghouan~22"], ["Turkey", "TR", "Adana~01|Adiyaman~02|Afyonkarahisar~03|Agri~04|Aksaray~68|Amasya~05|Ankara~06|Antalya~07|Ardahan~75|Artvin~08|Aydin~09|Balikesir~10|Bartin~74|Batman~72|Bayburt~69|Bilecik~11|Bingol~12|Bitlis~13|Bolu~14|Burdur~15|Bursa~16|Canakkale~17|Cankiri~18|Corum~19|Denizli~20|Diyarbakir~21|Duzce~81|Edirne~22|Elazig~23|Erzincan~24|Erzurum~25|Eskisehir~26|Gaziantep~27|Giresun~28|Gumushane~29|Hakkari~30|Hatay~31|Igdir~76|Isparta~32|Istanbul~34|Izmir~35|Kahramanmaras~46|Karabuk~78|Karaman~70|Kars~36|Kastamonu~37|Kayseri~38|Kilis~79|Kirikkale~71|Kirklareli~39|Kirsehir~40|Kocaeli~41|Konya~42|Kutahya~43|Malatya~44|Manisa~45|Mardin~47|Mersin~33|Mugla~48|Mus~49|Nevsehir~50|Nigde~51|Ordu~52|Osmaniye~80|Rize~53|Sakarya~54|Samsun~55|Sanliurfa~63|Siirt~56|Sinop~57|Sirnak~73|Sivas~58|Tekirdag~59|Tokat~60|Trabzon~61|Tunceli~62|Usak~64|Van~65|Yalova~77|Yozgat~66|Zonguldak~67"], ["Turkmenistan", "TM", "Ahal~A|Asgabat~S|Balkan~B|Dashoguz~D|Lebap~L|Mary~M"], ["Turks and Caicos Islands", "TC", "Turks and Caicos Islands"], ["Tuvalu", "TV", "Funafuti~FUN|Nanumanga~NMG|Nanumea~NMA|Niutao~NIT|Nui~NUI|Nukufetau~NKF|Nukulaelae~NKL|Vaitupu~VAU"], ["Uganda", "UG", "Abim~317|Adjumani~301|Amolatar~314|Amuria~216|Amuru~319|Apac~302|Arua~303|Budaka~217|Bududa~223|Bugiri~201|Bukedea~224|Bukwa~218|Buliisa~419|Bundibugyo~401|Bushenyi~402|Busia~202|Butaleja~219|Dokolo~318|Gulu~304|Hoima~403|Ibanda~416|Iganga~203|Isingiro~417|Jinja~204|Kaabong~315|Kabale~404|Kabarole~405|Kaberamaido~213|Kalangala~101|Kaliro~220|Kampala~102|Kamuli~205|Kamwenge~413|Kanungu~414|Kapchorwa~206|Kasese~406|Katakwi~207|Kayunga~112|Kibaale~407|Kiboga~103|Kiruhura~418|Kisoro~408|Kitgum~305|Koboko~316|Kotido~306|Kumi~208|Kyenjojo~415|Lira~307|Luwero~104|Lyantonde~116|Manafwa~221|Maracha~320|Masaka~105|Masindi~409|Mayuge~214|Mbale~209|Mbarara~410|Mityana~114|Moroto~308|Moyo~309|Mpigi~106|Mubende~107|Mukono~108|Nakapiripirit~311|Nakaseke~115|Nakasongola~109|Namutumba~222|Nebbi~310|Ntungamo~411|Oyam~321|Pader~312|Pallisa~210|Rakai~110|Rukungiri~412|Sembabule~111|Sironko~215|Soroti~211|Tororo~212|Wakiso~113|Yumbe~313"], ["Ukraine", "UA", "Cherkasy~71|Chernihiv~74|Chernivtsi~77|Dnipropetrovsk~12|Donetsk~14|Ivano-Frankivsk~26|Kharkiv~63|Kherson~65|Khmelnytskyi~68|Kiev~32|Kirovohrad~35|Luhansk~09|Lviv~46|Mykolaiv~48|Odessa~51|Poltava~53|Rivne~56|Sumy~59|Ternopil~61|Vinnytsia~05|Volyn~07|Zakarpattia~21|Zaporizhia~23|Zhytomyr~18|Avtonomna Respublika Krym~43|Kyïv~30|Sevastopol~40"], ["United Arab Emirates", "AE", "Abu Dhabi~AZ|Ajman~AJ|Dubai~DU|Fujairah~FU|Ras al Khaimah~RK|Sharjah~SH|Umm Al Quwain~UQ"], ["United Kingdom", "GB", "Avon~AVN|Bedfordshire~BDF|Berkshire~BRK|Bristol, City of~COB|Buckinghamshire~BKM|Cambridgeshire~CAM|Cheshire~CHS|Cleveland~CLV|Cornwall~CON|Cumbria~CMA|Derbyshire~DBY|Devon~DEV|Dorset~DOR|Durham~DUR|East Sussex~SXE|Essex~ESS|Gloucestershire~GLS|Greater London~LND|Greater Manchester~GTM|Hampshire (County of Southampton)~HAM|Hereford and Worcester~HWR|Herefordshire~HEF|Hertfordshire~HRT|Isle of Wight~IOW|Kent~KEN|Lancashire~LAN|Leicestershire~LEI|Lincolnshire~LIN|London~LDN|Merseyside~MSY|Middlesex~MDX|Norfolk~NFK|Northamptonshire~NTH|Northumberland~NBL|North Humberside~NHM|North Yorkshire~NYK|Nottinghamshire~NTT|Oxfordshire~OXF|Rutland~RUT|Shropshire~SAL|Somerset~SOM|South Humberside~SHM|South Yorkshire~SYK|Staffordshire~STS|Suffolk~SFK|Surrey~SRY|Tyne and Wear~TWR|Warwickshire~WAR|West Midlands~WMD|West Sussex~SXW|West Yorkshire~WYK|Wiltshire~WIL|Worcestershire~WOR|Antrim~ANT|Armagh~ARM|Belfast, City of~BLF|Down~DOW|Fermanagh~FER|Londonderry~LDY|Derry, City of~DRY|Tyrone~TYR|Aberdeen, City of~AN|Aberdeenshire~ABD|Angus (Forfarshire)~ANS|Argyll~AGB|Ayrshire~ARG|Banffshire~BAN|Berwickshire~BEW|Bute~BUT|Caithness~CAI|Clackmannanshire~CLK|Cromartyshire~COC|Dumfriesshire~DFS|Dunbartonshire (Dumbarton)~DNB|Dundee, City of~DD|East Lothian (Haddingtonshire)~ELN|Edinburgh, City of~EB|Fife~FIF|Glasgow, City of~GLA|Inverness-shire~INV|Kincardineshire~KCD|Kinross-shire~KRS|Kirkcudbrightshire~KKD|Lanarkshire~LKS|Midlothian (County of Edinburgh)~MLN|Moray (Elginshire)~MOR|Nairnshire~NAI|Orkney~OKI|Peeblesshire~PEE|Perthshire~PER|Renfrewshire~RFW|Ross and Cromarty~ROC|Ross-shire~ROS|Roxburghshire~ROX|Selkirkshire~SEL|Shetland (Zetland)~SHI|Stirlingshire~STI|Sutherland~SUT|West Lothian (Linlithgowshire)~WLN|Wigtownshire~WIG|Clwyd~CWD|Dyfed~DFD|Gwent~GNT|Gwynedd~GWN|Mid Glamorgan~MGM|Powys~POW|South Glamorgan~SGM|West Glamorgan~WGM"], ["United States", "US", "Alabama~AL|Alaska~AK|American Samoa~AS|Arizona~AZ|Arkansas~AR|California~CA|Colorado~CO|Connecticut~CT|Delaware~DE|District of Columbia~DC|Micronesia~FM|Florida~FL|Georgia~GA|Guam~GU|Hawaii~HI|Idaho~ID|Illinois~IL|Indiana~IN|Iowa~IA|Kansas~KS|Kentucky~KY|Louisiana~LA|Maine~ME|Marshall Islands~MH|Maryland~MD|Massachusetts~MA|Michigan~MI|Minnesota~MN|Mississippi~MS|Missouri~MO|Montana~MT|Nebraska~NE|Nevada~NV|New Hampshire~NH|New Jersey~NJ|New Mexico~NM|New York~NY|North Carolina~NC|North Dakota~ND|Northern Mariana Islands~MP|Ohio~OH|Oklahoma~OK|Oregon~OR|Palau~PW|Pennsylvania~PA|Puerto Rico~PR|Rhode Island~RI|South Carolina~SC|South Dakota~SD|Tennessee~TN|Texas~TX|Utah~UT|Vermont~VT|Virgin Islands~VI|Virginia~VA|Washington~WA|West Virginia~WV|Wisconsin~WI|Wyoming~WY|Armed Forces Americas~AA|Armed Forces Europe, Canada, Africa and Middle East~AE|Armed Forces Pacific~AP"], ["United States Minor Outlying Islands", "UM", "Baker Island~81|Howland Island~84|Jarvis Island~86|Johnston Atoll~67|Kingman Reef~89|Midway Islands~71|Navassa Island~76|Palmyra Atoll~95|Wake Island~79|Bajo Nuevo Bank~BN|Serranilla Bank~SB"], ["Uruguay", "UY", "Artigas~AR|Canelones~CA|Cerro Largo~CL|Colonia~CO|Durazno~DU|Flores~FS|Florida~FD|Lavalleja~LA|Maldonado~MA|Montevideo~MO|Paysandú~PA|Río Negro~RN|Rivera~RV|Rocha~RO|Salto~SA|San José~SJ|Soriano~SO|Tacuarembó~TA|Treinta y Tres~TT"], ["Uzbekistan", "UZ", "Toshkent shahri~TK|Andijon~AN|Buxoro~BU|Farg‘ona~FA|Jizzax~JI|Namangan~NG|Navoiy~NW|Qashqadaryo (Qarshi)~QA|Samarqand~SA|Sirdaryo (Guliston)~SI|Surxondaryo (Termiz)~SU|Toshkent wiloyati~TO|Xorazm (Urganch)~XO|Qoraqalpog‘iston Respublikasi (Nukus)~QR"], ["Vanuatu", "VU", "Malampa~MAP|Pénama~PAM|Sanma~SAM|Shéfa~SEE|Taféa~TAE|Torba~TOB"], ["Venezuela, Bolivarian Republic of", "VE", "Dependencias Federales~W|Distrito Federal~A|Amazonas~Z|Anzoátegui~B|Apure~C|Aragua~D|Barinas~E|Bolívar~F|Carabobo~G|Cojedes~H|Delta Amacuro~Y|Falcón~I|Guárico~J|Lara~K|Mérida~L|Miranda~M|Monagas~N|Nueva Esparta~O|Portuguesa~P|Sucre~R|Táchira~S|Trujillo~T|Vargas~X|Yaracuy~U|Zulia~V"], ["Vietnam", "VN", "Đồng Nai~39|Đồng Tháp~45|Gia Lai~30|Hà Giang~03|Hà Nam~63|Hà Tây~15|Hà Tĩnh~23|Hải Dương~61|Hậu Giang~73|Hòa Bình~14|Hưng Yên~66|Khánh Hòa~34|Kiên Giang~47|Kon Tum~28|Lai Châu~01|Lâm Đồng~35|Lạng Sơn~09|Lào Cai~02|Long An~41|Nam Định~67|Nghệ An~22|Ninh Bình~18|Ninh Thuận~36|Phú Thọ~68|Phú Yên~32|Quảng Bình~24|Quảng Nam~27|Quảng Ngãi~29|Quảng Ninh~13|Quảng Trị~25|Sóc Trăng~52|Sơn La~05|Tây Ninh~37|Thái Bình~20|Thái Nguyên~69|Thanh Hóa~21|Thừa Thiên–Huế~26|Tiền Giang~46|Trà Vinh~51|Tuyên Quang~07|Vĩnh Long~49|Vĩnh Phúc~70|Yên Bái~06|Cần Thơ~CT|Đà Nẵng~DN|Hà Nội~HN|Hải Phòng~HP|Hồ Chí Minh (Sài Gòn)~SG"], ["Virgin Islands, British", "VG", "Anegada~ANG|Jost Van Dyke~JVD|Tortola~TTA|Virgin Gorda~VGD"], ["Virgin Islands, U.S.", "VI", "St. Thomas~STH|St. John~SJO|St. Croix~SCR"], ["Wallis and Futuna", "WF", "Alo~ALO|Sigave~SIG|Wallis~WAL"], ["Western Sahara", "EH", "Es Smara~ESM|Boujdour~BOD|Laâyoune~LAA|Aousserd~AOU|Oued ed Dahab~OUD"], ["Yemen", "YE", "Abyān~AB|'Adan~AD|Aḑ Ḑāli'~DA|Al Bayḑā'~BA|Al Ḩudaydah~HU|Al Jawf~JA|Al Mahrah~MR|Al Maḩwīt~MW|'Amrān~AM|Dhamār~DH|Ḩaḑramawt~HD|Ḩajjah~HJ|Ibb~IB|Laḩij~LA|Ma'rib~MA|Raymah~RA|Şā‘dah~SD|Şan‘ā'~SN|Shabwah~SH|Tā‘izz~TA"], ["Zambia", "ZM", "Central~02|Copperbelt~08|Eastern~03|Luapula~04|Lusaka~09|Northern~05|North-Western~06|Southern~07|Western~01"], ["Zimbabwe", "ZW", "Bulawayo~BU|Harare~HA|Manicaland~MA|Mashonaland Central~MC|Mashonaland East~ME|Mashonaland West~MW|Masvingo~MV|Matabeleland North~MN|Matabeleland South~MS|Midlands~MI"]], a = function () { $(".crs-country").each(n) }, n = function () { var a = this; if ("true" !== a.getAttribute("data-crs-loaded")) { a.length = 0; var n = $(a).attr("data-default-option"), i = n || "Select country", e = a.getAttribute("data-show-default-option"); m = null === e || "true" === e; var r = $(a).attr("data-default-value"), o = $(a).attr("data-value"), l = 0; m && (this.options[0] = new Option(i, "")), k({ whitelist: a.getAttribute("data-whitelist"), blacklist: a.getAttribute("data-blacklist"), preferred: a.getAttribute("data-preferred"), preferredDelim: a.getAttribute("data-preferred-delim") }); for (var t = 0; t < M.length; t++) { var s = "shortcode" == o || "2-char" === o ? M[t][1] : M[t][0]; M[t][4] && (s = ""), a.options[a.length] = new Option(M[t][0], s), null != r && r === s && (l = t, m && l++) } this.selectedIndex = l; var u = $(a).attr("data-region-id"); if (u) { var d = $("#" + u)[0]; if (d) if (B(d), $(this).on("change", function () { b(a, d) }), r && 0 < a.selectedIndex) { b(a, d); var h = $(d).attr("data-default-value"), S = "shortcode" === d.getAttribute("data-value"); if (null !== h) { var A = m ? a.selectedIndex - 1 : a.selectedIndex, g = M[A][3]; c(d, g, h, S) } } else !1 === m && b(a, d); else console.error("Region dropdown DOM node with ID " + u + " not found."); a.setAttribute("data-crs-loaded", "true") } else console.error("Missing data-region-id on country-region-selector country field.") } }, B = function (a) { var n = $(a).attr("data-blank-option"), i = n || "-", e = a.getAttribute("data-show-default-option"); h = null === e || "true" === e, a.length = 0, h && (a.options[0] = new Option(i, ""), a.selectedIndex = 0) }, k = function (a) { var n = l, i = [], e = 0; if (a.whitelist) { var r = a.whitelist.split(","); for (e = 0; e < l.length; e++)-1 !== r.indexOf(l[e][1]) && i.push(l[e]); n = i } else if (a.blacklist) { var o = a.blacklist.split(","); for (e = 0; e < l.length; e++)-1 === o.indexOf(l[e][1]) && i.push(l[e]); n = i } a.preferred && (n = s(n, a.preferred, a.preferredDelim)), M = n, t() }, t = function () { for (var a = 0; a < M.length; a++) { for (var n = { hasShortcodes: /~/.test(M[a][2]), regions: [] }, i = M[a][2].split("|"), e = 0; e < i.length; e++) { var r = i[e].split("~"); n.regions.push([r[0], r[1]]) } M[a][3] = n } }, c = function (a, n, i, e) { for (var r = 0; r < n.regions.length; r++) { if ((e && n.hasShortcodes && n.regions[r][1] ? n.regions[r][1] : n.regions[r][0]) === i) { a.selectedIndex = h ? r + 1 : r; break } } }, b = function (a, n) { var i = m ? a.selectedIndex - 1 : a.selectedIndex, e = $(n).attr("data-default-option"), r = n.getAttribute("data-value"), o = e || "Select region"; if ("" === a.value) B(n); else { n.length = 0, h && (n.options[0] = new Option(o, "")); var l = M[i][3], t = "shortcode" === r && l.hasShortcodes, s = t ? 1 : 0; l.regions.sort(function (a, n) { var i = a[s].toLowerCase(), e = n[s].toLowerCase(); return i < e ? -1 : e < i ? 1 : 0 }); for (var u = 0; u < l.regions.length; u++) { var d = t ? l.regions[u][1] : l.regions[u][0]; n.options[n.length] = new Option(l.regions[u][0], d) } n.selectedIndex = 0 } }, s = function (a, n, i) { var e = n.split(",").reverse(), r = {}, o = !1, l = a.filter(function (a) { return -1 === e.indexOf(a[1]) || (r[a[1]] = a, !(o = !0)) }); o && i && l.unshift([i, "", "", {}, !0]); for (var t = 0; t < e.length; t++) { var s = e[t]; l.unshift(r[s]) } return l }; return $(a), { init: a } });
},{}],7:[function(require,module,exports){
const $ = require('jquery')
window.$ = $
window.jQuery = $
require('./jquery.crs.min')
require('./jQuery-zoom')
window.popper = require('./popper')
window.tippy = require('./tippy')
window.Splide = require('./splide')
require('./splide-grid')
window.intlTelInput = require('./intlTelInput')
window.Parsley = require('./parsley.min')
window.zenscroll = require('./zenscroll')
window.fancybox = require('./fancybox.min')


/** -- Globals */
/** Constants / Variables / Utils / Ajax */
const constants = require('./modules/constants')
const variables = require('./modules/variables')
const utils = require('./modules/utils')
const ajax = require('./modules/ajax')
Object.assign(window, constants, variables, utils, ajax)


/** -- Append Elements */
/* Page Tips */
window.PageTip = require('./modules/dynamic/pageTip')
/* Backdrop */
window.Backdrop = require('./modules/dynamic/backdrop')
/* Page Confetti */
window.PageConfetti = require('./modules/dynamic/page-confetti')
/* Ask Modal */
window.AskModal = require('./modules/dynamic/ask-modal')
/* Loader Root */
window.rootLoader = require('./modules/dynamic/root-loader')


/** -- Page Elements */
/** Login
 */
require('./modules/login')

/** Header / Footer
 * @type Objects
 */
window.header = require('./modules/elements/header')
window.footer = require('./modules/elements/footer')

/** Page Elements
 * @type Object
 */
window.pageEls = require('./modules/elements/page-elements')
window.pageReviews = require('./modules/elements/page-reviews')
window.heroSplide = require('./modules/elements/hero-splide')
window.pageAlerts = require('./modules/elements/page-alerts')

/** Modals
 * Currency / Cart / Menu / Mail / Quiz / Sign / Menu
 * @type Obejcts
 */
window.currencyModal = require('./modules/modals/currency-modal')
window.cartModal = require('./modules/modals/cart-modal')
window.bookModal = require('./modules/modals/book-modal')
window.mailModal = require('./modules/modals/mail-modal')
window.quizModal = require('./modules/modals/quiz-modal')
window.salesModal = require('./modules/modals/sales-modal')
const SignModal = require('./modules/modals/sign-modal')
const Menu = require('./modules/modals/menu')

/** PG Filters/Select/Modal
 * @type Objects
 */
window.pgSelect = require('./modules/elements/pg-select')
window.pgModal = require('./modules/elements/pg-modal')


/** -- Pages */
const
  /* Loan App : /financing */
  LoanApp = require('./modules/pages/loan-app'),
  /* Job Apply : /apply-job */
  JobApp = require('./modules/pages/job-app'),
  /* Sell Watch : /sell-my-watch */
  SellWatch = require('./modules/pages/sell-watch'),
  /* Loose Diamonds : /loose-diamonds */
  LooseDiamonds = require('./modules/pages/loose-diamonds'),
  /* Homepage : /index */
  Homepage = require('./modules/pages/homepage'),
  ResultsPage = require('./modules/pages/results'),
  ProductPage = require('./modules/pages/product'),
  /* Product Page : /product-page */
  productPage = require('./modules/pages/product'),
  /* My Bag : /cart */
  myBag = require('./modules/pages/my-bag'),
  /* Account Profile : /account */
  account = require('./modules/pages/account-page'),
  /* Locations : /locations */
  locationPage = require('./modules/pages/location-page'),
  /* Sell Pages : /sell */
  sellPage = require('./modules/pages/sell-page'),
  /* Pass Reset : /pass-reset */
  passReset = require('./modules/pages/pass-reset'),
  /* Blog : /blog */
  blogPage = require('./modules/pages/blog-page'),
  /* Form Page : /form */
  formPage = require('./modules/pages/form-page'),
  /* Tag Preview : /tag */
  tagPreview = require('./modules/pages/tag-preview')


/** -- Initialize Page Objects */
const
  pageObjectsArr = [
    header,
    cartModal,
    currencyModal,
    pgModal,
    footer,
    pageEls,
    myBag,
    account,
    locationPage,
    pageAlerts,
    sellPage,
    bookModal,
    passReset,
    pageReviews,
    blogPage,
    heroSplide,
    mailModal,
    quizModal,
    salesModal,
    formPage,
    tagPreview
  ]
const initPageObjects = () => {
  for (const obj of pageObjectsArr) {
    try {
      if (typeof obj.init === "function") {
        obj.init()
      } else {
        console.log(obj, 'No init function')
      }
    } catch (err) {
      console.error(`Error initializing ${obj}:`, err)
    }
  }
}


/** -- Init Page Objects */
document.addEventListener("DOMContentLoaded", function () {
  initPageObjects()
  window.pageTip = new PageTip()
  window.signModal = new SignModal()

  // Loan App
  const loanCaseHolder = document.querySelector('[data-id="loan-apply"]')
  if (loanCaseHolder) {
    window.loanApp = new LoanApp(loanCaseHolder)
  }

  // Job Apply
  const jobCaseHolder = document.querySelector('[data-id="job-apply"]')
  if (jobCaseHolder) {
    window.jobApp = new JobApp(jobCaseHolder)
  }

  // Form Page
  const form = document.querySelector('form#sell_my_watch')
  if (form) {
    window.sellMyWatch = new SellWatch()
  }

  // Loose Diamonds
  const looseDiamondsMain = document.querySelector('.loose_diamonds')
  if (looseDiamondsMain) {
    window.loose = new LooseDiamonds()
  }

  // Menu
  const menuElem = document.querySelector('.menu')
  if (menuElem) {
    window.menu = new Menu('.menu')
  }

  // Homepage
  new Homepage()

  // Results
  const resultsMain = document.querySelector('.main_results')
  if (resultsMain) {
    new ResultsPage()
  }

  const productMain = document.querySelector('.main_product')
  if (productMain) {
    new ProductPage()
  }
})
},{"./fancybox.min":3,"./intlTelInput":4,"./jQuery-zoom":5,"./jquery.crs.min":6,"./modules/ajax":8,"./modules/constants":9,"./modules/dynamic/ask-modal":10,"./modules/dynamic/backdrop":11,"./modules/dynamic/page-confetti":12,"./modules/dynamic/pageTip":13,"./modules/dynamic/root-loader":14,"./modules/elements/footer":15,"./modules/elements/header":16,"./modules/elements/hero-splide":17,"./modules/elements/page-alerts":18,"./modules/elements/page-elements":19,"./modules/elements/page-reviews":20,"./modules/elements/pg-modal":21,"./modules/elements/pg-select":22,"./modules/login":23,"./modules/modals/book-modal":24,"./modules/modals/cart-modal":25,"./modules/modals/currency-modal":26,"./modules/modals/mail-modal":27,"./modules/modals/menu":28,"./modules/modals/quiz-modal":29,"./modules/modals/sales-modal":30,"./modules/modals/sign-modal":31,"./modules/pages/account-page":32,"./modules/pages/blog-page":33,"./modules/pages/form-page":34,"./modules/pages/homepage":35,"./modules/pages/job-app":36,"./modules/pages/loan-app":37,"./modules/pages/location-page":38,"./modules/pages/loose-diamonds":39,"./modules/pages/my-bag":40,"./modules/pages/pass-reset":41,"./modules/pages/product":42,"./modules/pages/results":43,"./modules/pages/sell-page":44,"./modules/pages/sell-watch":45,"./modules/pages/tag-preview":46,"./modules/utils":47,"./modules/variables":48,"./parsley.min":49,"./popper":50,"./splide":52,"./splide-grid":51,"./tippy":53,"./zenscroll":54,"jquery":2}],8:[function(require,module,exports){
function applyRedeemCode() {
  const value = $('#redeem_input').val();
  if (value != '') {
    $.ajax({
      url: '/json/redeem-promo-code',
      type: 'POST',
      data: { code: value },
      success: function (data) {
        var r = $.parseJSON(data);
        if (!r.error) {
          $('.checkout-redeem').show();
        } else {
          showMessage('error', 'Error', r.msg);
        }
      }
    });
  }
}

module.exports = {
  applyRedeemCode
}
},{}],9:[function(require,module,exports){
const constants = {
  IS_VISIBLE: "is-visible",
  IS_ACTIVE: "is-active",
  BUTTON_LOADING: "button_loading",
  IS_HIDDEN: 'is-hidden',
  IS_EXPANDED: 'is-expanded',
  IS_MINIMIZED: 'is-minimized',
  IS_COPIED: 'is-copied',
  IS_ERROR: 'is-error',
  IS_EMPTY: 'is-empty',
  __TRUE: '--true',
  __FALSE: '--false',
  __FADE: '--fade',
  __HALF: '--half',
  __SELECTED: '--selected',
  __LOADED: '--loaded',
  __HIDDEN: '--hidden',
  __VISIBLE: '--visible',
  __VALID: '--valid',
  __INVALID: '--invalid',
  __PENDING: '--pending',
  __LOCKED: '--locked',
  __ACTIVE: '--active',
  __EXPANDED: '--expanded',
  paceOptions: {
    ajax: true,
    document: true,
    elements: {
      selectors: ['main']
    }
  },
};

module.exports = constants;
},{}],10:[function(require,module,exports){
class AskModal {
  constructor(settings = {}) {
    this.heading = settings.heading || 'Are You Sure You Want To Exit?'
    this.subheading = settings.subheading || 'You will lose all unsaved progress.'
    this.exitText = settings.exitText || 'Exit'
    this.keepText = settings.keepText || 'Keep'
    this.exitCallback = settings.exitCallback
    this.keepCallback = this.destroy
  }

  get renderHTML() {
    return `
      <div data-evt="closeAskModal"></div>
      <div>
        <h4>${this.heading}</h4>
        <p>${this.subheading}</p>
        <div>
          <button>${this.exitText}</button>
          <button>${this.keepText}</button>
        </div>
      </div>
    `
  }

  create() {
    const modal = createElem('div', {
      className: 'ask-modal',
      innerHTML: this.renderHTML
    })
    const buttons = [...modal.querySelectorAll('button')]
    const closeEvt = [...modal.querySelectorAll('[data-evt="closeAskModal"]')]
    buttons[0].onclick = () => { this.destroy(); this.exitCallback() }
    buttons[1].onclick = () => { this.keepCallback() }
    for (const evt of closeEvt) {
      evt.onclick = () => { this.destroy() }
    }
    return modal
  }

  destroy() {
    unlockScroll()
    const modal = document.querySelector('.ask-modal')
    if (modal) {
      modal.remove()
    }
  }

  show() {
    lockScroll()
    const elem = this.create()
    document.body.appendChild(elem)
  }
}

module.exports = AskModal
},{}],11:[function(require,module,exports){
class Backdrop {
  constructor(settings = {}) {
    this.el = createElem('div', {
      className: 'page-backdrop',
    })
    this.callback = settings.callback || null
    this.zIndex = settings.zIndex || undefined
    this.background = settings.background || undefined
    this.half = settings.half || false
    this.show()
    this.el.addEventListener('click', (e) => {
      if (e.target === this.el) {
        this.hide()
      }
    })
  }

  show() {
    document.body.appendChild(this.el)
    if (this.zIndex) {
      this.el.style.zIndex = this.zIndex
    }
    if (this.half) {
      this.el.classList.add(__HALF)
    }
    this.el.style.display = 'block'
    setTimeout(() => {
      this.el.style.opacity = '1'
    }, 1);
  }

  hide(ignoreCallback = false) {
    this.el.style.opacity = '0'
    setTimeout(() => {
      this.el.style.display = 'none'
      this.el.remove()
    }, getTransitionTime(this.el));

    if (this.callback && !ignoreCallback) {
      this.callback()
    }
  }
}

module.exports = Backdrop
},{}],12:[function(require,module,exports){
class PageConfetti {
  constructor() {
    this.el = null
    this.containerEl = null
    this.confettiFrequency = 3
    this.confettiInterval = 50
    this.timeToDestroy = 8000
    this.confettiColors = ['#0095c6', '#1ab8ec', '#8cdffa', '#d8f3fc']
    this.confettiAnimations = ['slow', 'medium', 'fast']
  }

  createHolder() {
    this.el = createElem('div', {
      className: 'confetti-holder'
    })
    document.body.appendChild(this.el)
  }

  setup() {
    const containerEl = createElem('div', {
      className: 'confetti-container'
    })
    this.el.appendChild(containerEl)
    this.containerEl = containerEl
  }

  render() {
    this.confettiInterval = setInterval(() => {
      const confettiEl = document.createElement('div')
      const confettiSize = Math.floor(Math.random() * 3) + 7 + 'px'
      const confettiBackground = this.confettiColors[Math.floor(Math.random() * this.confettiColors.length)]
      const confettiLeft = Math.floor(Math.random() * this.el.offsetWidth) + 'px'
      const confettiAnimation = this.confettiAnimations[Math.floor(Math.random() * this.confettiAnimations.length)]

      confettiEl.classList.add('confetti', 'confetti--animation-' + confettiAnimation)
      confettiEl.style.left = confettiLeft
      confettiEl.style.width = confettiSize
      confettiEl.style.height = confettiSize
      confettiEl.style.backgroundColor = confettiBackground

      confettiEl.removeTimeout = setTimeout(function () {
        confettiEl.parentNode.removeChild(confettiEl)
      }, 3000)

      this.containerEl.appendChild(confettiEl)
    }, this.confettiInterval)
  }

  destroy() {
    const el = this.el
    if (el) {
      el.style.opacity = '0'
      setTimeout(() => {
        document.body.removeChild(el)
      }, getTransitionTime(el));
    }
  }

  push(infinity = false) {
    this.createHolder()
    this.setup()
    this.render()
    if (!infinity) {
      setTimeout(() => {
        this.destroy()
      }, this.timeToDestroy);
    }
  }
}

module.exports = PageConfetti
},{}],13:[function(require,module,exports){
(function (global){(function (){
/**
 * Page Tips
 */
(function(global) {
  function PageTip() {
    this.tipElem = null;
    this.handleHover();
  }

  PageTip.prototype.handleHover = function() {
    document.querySelectorAll('[data-tip]').forEach(elem => {
      elem.addEventListener('mouseenter', e => {
        this.createTip(elem);
        this.tipElem.textContent = elem.dataset.tip;
        this.setTipPosition(elem);
      });

      elem.addEventListener('mouseleave', e => {
        this.destroyTip();
      });
    });
  };

  PageTip.prototype.createTip = function(target) {
    if (!this.tipElem) {
      this.tipElem = document.createElement('div');
      this.tipElem.classList.add('page-tip');
      document.body.append(this.tipElem);

      if (target) {
        const extraClass = target.dataset.tipClass;
        if (extraClass) {
          this.tipElem.classList.add(`--${extraClass}`);
        }
      }
    }
  };

  PageTip.prototype.setTipPosition = function(elem) {
    const { left, top, width, height } = elem.getBoundingClientRect();
    const tipWidth = this.tipElem.getBoundingClientRect().width;
    const tipHeight = this.tipElem.getBoundingClientRect().height;
    const elemHeight = elem.offsetHeight;
    const elemWidth = elem.offsetWidth;

    let topPosition = top - tipHeight - 8;
    let leftPosition = (left + (elemWidth / 2)) - (tipWidth / 2);

    if (topPosition < 100) {
      topPosition = top + elemHeight + 8;
      this.tipElem.classList.add('--top');
    }

    if (leftPosition < 0) {
      leftPosition = left;
      this.tipElem.classList.add('--left');
    }

    this.tipElem.style.top = `${topPosition}px`;
    this.tipElem.style.left = `${leftPosition}px`;
  };

  PageTip.prototype.destroyTip = function() {
    if (this.tipElem) {
      this.tipElem.remove();
      this.tipElem = null;
    }
  };

  // Экспортируем класс PageTip
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = PageTip;
  } else {
    global.PageTip = PageTip;
  }
})(typeof window !== "undefined" ? window : global);
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
const rootLoader = new Object({
  class: 'root_loader',
  renderHTML: () => { return `<div class=${rootLoader.class}></div>` },
  isExist: () => { return $(document).find(`.${rootLoader.class}`).length ? true : false },

  push: function (noLock = false) {
    if (!noLock) { lockScroll() }
    if (!this.isExist()) { $body.append(rootLoader.renderHTML()) }
  },
  remove: function (noUnlock = false) {
    if (!noUnlock) unlockScroll();
    if (this.isExist()) { $(document).find(`.${rootLoader.class}`).remove() }
  }
})

module.exports = rootLoader
},{}],15:[function(require,module,exports){
const footer = new Object({
  init: function () {
    function attach() {
      if (window.innerWidth < 992) {
        let footerHeader = Array.from($(".footer-col__header"));

        $.each(footerHeader, function (i) {
          let col = $(footerHeader[i]).closest(".footer-col"),
            body = col.find(".footer-col__body");

          if (body.length && col.length) {
            footerHeader[i].onclick = () => {
              if (body.height() == 0) {
                let scrH = body.find(".footer-col__body-scroll")[0]
                  .scrollHeight;
                body.css({
                  height: `${scrH}px`,
                });
              } else {
                let h = body.css("height");
                body.css("height", h);
                setTimeout(() => {
                  body.css({
                    height: "0px",
                  });
                }, 1);
              }
            };
          }
        });
      }
    }

    $(window).on("load resize", function () {
      attach();
    });
  },
})

module.exports = footer
},{}],16:[function(require,module,exports){
const header = {
  init: function () {
    this.renderDOM();
    this.bindEvents();
    this.setDropdowns()
  },
  renderDOM: function () {
    // Login Dropdown
    this.loginBtn = $('[data-evt="toggleAccountDropdown"]');
    this.loginDropdown = $(".login-dropdown");

    // Search
    this.searchBtn = $('[data-evt="toggleSearch"]');
    this.searchBlock = $(".header-search");

    this.loginLink = $('.login-nav__link')
  },
  bindEvents: function () {
    this.loginBtn.on('mouseover mouseleave', function (evt) {
      let dd = header.loginDropdown
      if (dd.length) {
        switch (evt.type) {
          case 'mouseover':
            dd.css({ display: 'block', opacity: 1 })
            break;
          case 'mouseleave':
            dd.css({ display: 'none', opacity: 0 })
            break;
        }
      }
    })
    this.loginLink.click(function (e) {
      e.stopPropagation()
    })

    this.searchBtn.click(() => {
      let el = header.searchBlock;

      function hideSearch() {
        el.removeClass(IS_VISIBLE);
        unlockScroll();
      }

      if (el.hasClass(IS_VISIBLE)) {
        hideSearch()
        if (window.searchBackdrop) {
          window.searchBackdrop.hide();
        }
      } else {
        lockScroll();
        el.addClass(IS_VISIBLE);
        el.find("input").focus();

        window.searchBackdrop = new Backdrop({
          half: true,
          zIndex: (getZIndex(document.querySelector('header')) - 1),
          callback: hideSearch
        })
      }
    });
  },
  setDropdowns: function (...args) {
    args = Array.from(document.querySelectorAll('.header__sub-link'))

    if (args.length !== 0 && args) {

      const dd = document.querySelector('.nav-drop')
      const cont = [...document.querySelectorAll('.nav-drop__content')]
      const subLink = [...document.querySelectorAll('.nav-drop_more')]
      const IS_ACTIVE = 'is-active'

      let hideDelayTime, showDelayTime

      if (dd && cont && subLink) {
        const pos = (el) => {
          return {
            top: el.getBoundingClientRect().top + el.offsetHeight,
            left: el.getBoundingClientRect().left + (el.offsetWidth / 2) - (dd.offsetWidth / 2)
          }
        }

        const fn = {
          initial: () => {
            dd.style.top = `${pos(args[0]).top}px`
            dd.style.left = `${pos(args[0]).left}px`
          },
          hide: () => {
            dd.style.opacity = 0
            dd.style.display = 'none'
            args.forEach(el => el.classList.remove(IS_ACTIVE))
          },
          show: (el) => {
            args.forEach(el => el.classList.remove(IS_ACTIVE))
            el.classList.add(IS_ACTIVE)
            dd.style.display = 'block'
            dd.style.top = `${pos(el).top}px`
            dd.style.left = `${pos(el).left}px`
            dd.style.opacity = 1
          },
          switchContent: (attr) => {
            cont.forEach(el => el.style.display = 'none')
            cont.filter(el => el.id == `dd_${attr}`).forEach(el => el.style.display = 'block')
          }
        }

        const { initial: setInitial, hide: hide, show: show, switchContent: switchContent } = fn

        for (let i = 0; i < subLink.length; i++) {
          const el = subLink[i],
            content = el.querySelector('.nav-drop__sub')
          el.onmouseover = () => { content.style.display = 'block' }
          el.onmouseleave = () => { content.style.display = 'none' }
        }

        dd.onmouseover = (e) => {
          if (hideDelayTime) window.clearTimeout(hideDelayTime)
        }

        dd.onmouseleave = (e) => {
          window.clearTimeout(showDelayTime)
          hideDelayTime = window.setTimeout(() => {
            hide()
          }, 150);
        }


        args.forEach((el) => {
          el.onmouseover = (e) => {
            const attr = el.dataset.dropdown
            if (attr) {
              window.clearTimeout(hideDelayTime)
              showDelayTime = window.setTimeout(() => {
                switchContent(attr)
                show(el)
              }, 200);
            }
          }

          el.onmouseleave = (e) => {
            window.clearTimeout(showDelayTime)
            hideDelayTime = window.setTimeout(() => {
              hide()
            }, 150);
          }
        })

        window.onscroll = () => {
          window.clearTimeout(showDelayTime)
          hide(); setInitial()
        }

        setInitial()
      }
    }
  }
}

module.exports = header
},{}],17:[function(require,module,exports){
const heroSplide = {
  init: function () {
    try {
      this.initSplide()
    } catch (err) {
      console.log(err.message)
    }
  },
  initSplide: function () {
    const heroSplide = [...document.querySelectorAll('.hero_splide')]
    if (heroSplide.length !== 0) {
      heroSplide.forEach((slide) => {
        let slider = new Splide(slide, {
          type: "slider",
          perPage: 4,
          perMove: 2,
          autoplay: 0,
          gap: "12px",
          arrows: 1,
          pagination: 0,
          speed: 750,
          breakpoints: {
            991: { perPage: 2.5, },
            767: { perPage: 2, perMove: 1 },
            478: { perPage: 1.4, perMove: 1, gap: 8 }
          }
        })
        slider.mount()
      })
    }
  }
}

module.exports = heroSplide
},{}],18:[function(require,module,exports){
const pageAlerts = {
  classes: {
    fullWidth: 'page-alert_backdrop',
    error: 'page-alert_error',
    warning: 'page-alert_warning',
    info: 'page-alert_info',
    visible: 'is-visible'
  },
  init: function () {
    this.cacheDOM()
    this.bindEvents()
    // this.fullWidth()
  },
  cacheDOM: function () {
    this.container = $('.page-alert')
    this.title = $('.page-alert-title')
    this.subtitle = $('.page-alert-text')
    this.close = $('[data-evt="hidePageAlert"]')
  },
  bindEvents: function () {
    this.close.click(this.hideAlert.bind(this))
    clearTimeout(alertTimer)
  },
  fullWidth: function () {
    this.container.addClass(this.classes.fullWidth)
  },
  showAlert: function (errorType = function () { pageAlerts.resetAlert() }, title, text, hideTime = 2500) {
    clearTimeout(alertTimer)
    this.resetAlert();

    this.container.addClass(this.classes.visible).addClass(errorType)
    this.changeMsg(title, text)
    alertTimer = window.setTimeout(function () {
      pageAlerts.hideAlert()
    }, hideTime)
  },
  hideAlert: function () {
    this.container.removeClass(this.classes.visible)
  },
  changeMsg: function (title, text) {
    this.title.html(title)
    this.subtitle.html(text)
  },
  resetAlert: function () {
    this.container.removeClass(function () {
      let i = pageAlerts.classes
      return `${i.warning} ${i.info} ${i.error}`
    })
  }
}

module.exports = pageAlerts
},{}],19:[function(require,module,exports){
const pageEls = new Object({
  init: function () {
    Object.values(this.attachEvent).forEach((target) => {
      if (typeof target === 'function') {
        try {
          target()
        } catch (err) {
          console.error(err)
        }
      }
    })
  },
  attachEvent: {
    filterDropdown: () => {
      let dropdownEls = Array.from($('.filter-dropdown'))

      for (let i = 0; i < dropdownEls.length; i++) {
        const el = dropdownEls[i];
        $(el).hover(function () {
          let thisCurrent = $(this).find('.filter-dropdown__current'),
            list = $(this).find('.filter-dropdown__list'),
            scrollContainer = list.find('> div'),
            buttons = Array.from(scrollContainer.find('> div')),
            main = $(this).find('.filter-dropdown__main')

          const scrollH = scrollContainer[0].scrollHeight

          if (list.height() == 0) {
            list.css({ height: `${scrollH}px` })
            main.addClass(IS_ACTIVE)
          } else {
            list.css({ height: '0px' })
            main.removeClass(IS_ACTIVE)
          }

          $.each(buttons, function (i) {
            buttons[i].onclick = () => {
              let sibs = $(buttons[i]).siblings()
              sibs.removeClass(IS_ACTIVE)
              buttons[i].classList.add(IS_ACTIVE)

              let val = $(buttons[i]).html()
              thisCurrent.html(val)
            }
          })
        })
      }
    },
    trackingDateUpdate: () => {
      const dates = [...document.querySelectorAll('[data-track="updated_date"]')]
      const nowDate = new Date()

      if (dates.length) {
        const day = nowDate.getDate()
        const month = nowDate.toLocaleDateString('en-US', { month: 'short' })
        const year = nowDate.getFullYear()
        let hours = nowDate.getHours()
        const minutes = nowDate.getMinutes().toString().padStart(2, '0')
        const ampm = hours >= 12 ? 'PM' : 'AM'
        hours = hours % 12 || 12

        for (const date of dates) {
          date.innerHTML = `${day} ${month}, ${year}, ${hours}:${minutes} ${ampm}`
        }
      }
    },
    pageFilters: () => {
      let filterRows = Array.from($('.filter-row'))
      for (let i = 0; i < filterRows.length; i++) {
        const el = $(filterRows[i]),
          header = el.find('.filter-row__header'),
          body = el.find('.filter-row__body'),
          container = el.find('.filter-row__container'),
          icon = header.find('svg')

        header.click(() => {
          let currentBodyHeight = body.height()
          if (currentBodyHeight !== 0) {
            body.css({ height: `${currentBodyHeight}px` })
            setTimeout(() => {
              body.css({ height: 0 })
              container.css({ transform: 'translateY(-24px)', opacity: 0 })
              icon.css({ transform: 'rotate(0deg)' })
            }, 1);
          } else {
            let scrollH = container[0].scrollHeight
            body.css({ height: scrollH })
            container.css({ transform: 'translateY(0px)', opacity: 1 })
            icon.css({ transform: 'rotate(180deg)' })
          }
        })
      }
    },
    faqLists: () => {
      const headArr = [...document.querySelectorAll('.faq-head')]
      let liArr = []
      for (const faqHead of headArr) {
        const li = faqHead.closest('li')
        const body = faqHead.nextElementSibling
        if (li && body) {
          liArr.push(li)
          li.show = () => {
            li.classList.add(__ACTIVE)
            const scrollHeight = body.scrollHeight
            body.style.height = `${scrollHeight}px`
            setTimeout(() => {
              body.style.height = 'auto'
            }, 1);
          }
          li.hide = () => {
            li.classList.remove(__ACTIVE)
            body.style.height = 0
          }

          faqHead.onclick = () => {
            console.log(body)
            if (body.offsetHeight !== 0) {
              li.hide()
            } else {
              li.show()
            }
          }

          // Transform letters
          const h6 = faqHead.querySelector('h6')
          if (h6) {
            const capitalized = h6.textContent.toLowerCase().replace(/(\b)(\w)/g, (match, p1, p2) => p2.toUpperCase())
            h6.textContent = capitalized
          }

          // Reveal first
          if (liArr[0] === li) li.show()
        }
      }
    },
    listings: () => {
      const listings = [...document.querySelectorAll('.listing-set')]
      for (const listing of listings) {
        const buttonArray = [...listing.querySelectorAll('.listing-btn:not(.--disabled)')]
        buttonArray.forEach((btn) => {
          btn.addEventListener('click', () => {
            btn.classList.add(IS_ACTIVE)
            buttonArray.forEach((arrBtn) => {
              if (arrBtn != btn) arrBtn.classList.remove(IS_ACTIVE)
            })
          })
        })
      }
    },
    removeZeroSubheading: () => {
      const arr = [...document.querySelectorAll('.results__subheading')]
      for (const subheading of arr) {
        if (subheading.innerHTML.length < 1) {
          subheading.remove()
        }
      }
    },
    initTelInput: () => {
      let telInputArr = Array.from($('[data-input="tel"]'));

      for (var i = 0; i < telInputArr.length; i++) {
        iti = intlTelInput(telInputArr[i], {
          initialCountry: "auto",
          preferredCountries: ["us", "gb", "br", "cn", "es", "it"],
          autoPlaceholder: "aggressive",
          useFullscreenPopup: true,
          utilsScript:
            "/assets/public-2020/js/plugins/phone/utils.js",
          geoIpLookup: function (callback) {
            fetch("https://ipinfo.io/json", {
              cache: "reload",
            })
              .then((response) => {
                if (response.ok) {
                  return response.json();
                }
                throw new Error("Failed: " + response.status);
              })
              .then((ipjson) => {
                callback(ipjson.country);
              })
              .catch((e) => {
                callback("us");
              });
          },
        });
      }
    },
    initCustomUploads: () => {
      this.arr = [...document.querySelectorAll('[data-custom-upload]')]

      const renderOutputFile = (file, imgSrc = '') => {
        let imgElem = imgSrc ? `<div class="--filled" style="background-image: url(${imgSrc})"></div>` : `<div></div>`
        return `
        <div class="custom-upload__file">
          <div>
            ${imgElem}
            <span data-custom-name>${file.name}</span>
          </div>
          <div>
            <div data-evt="custom_upload_remove" class="--remove"></div>
          </div>
        </div>
        `
      }
      const bindBoxEvents = (box, input) => {
        box.ondragover = (e) => {
          e.preventDefault(); box.classList.add(__ACTIVE)
        }
        box.ondragleave = (e) => {
          e.preventDefault(); box.classList.remove(__ACTIVE)
        }
        box.addEventListener('drop', (e) => {
          e.preventDefault()
          box.classList.remove(__ACTIVE)
          const files = e.dataTransfer.files
          const newDataTransfer = new DataTransfer()

          for (const file of files) {
            newDataTransfer.items.add(file)
          }
          input.files = newDataTransfer.files
          input.dispatchEvent(new Event('change', { 'bubbles': true }))
        })
        box.addEventListener('click', (e) => {
          input.click()
        })
      }
      const setIndexes = (upload) => {
        const files = [...upload.querySelectorAll('.custom-upload__file')]
        for (let i = 0; i < files.length; i++) {
          files[i].dataset.customIndex = i
        }
      }
      const processFiles = (files, upload) => {
        const output = upload.querySelector('.custom-upload__files')
        const currentFiles = [...upload.querySelectorAll('.custom-upload__file')]

        for (const file of currentFiles) {
          file.remove()
        }

        for (const file of files) {
          const fileIsImage = file.type.match('image.*')
          if (fileIsImage) {
            let reader = new FileReader()
            reader.onload = (e) => {
              output.insertAdjacentHTML('beforeend', renderOutputFile(file, e.target.result))
            }
            reader.readAsDataURL(file)
          } else {
            output.insertAdjacentHTML('beforeend', renderOutputFile(file))
          }
        }
        setIndexes(upload)
      }

      for (const upload of this.arr) {
        const box = upload.querySelector('.custom-upload__box')
        const input = upload.querySelector('input')

        if (box) {
          bindBoxEvents(box, input)
        }

        input.addEventListener('change', (e) => {
          const files = e.target.files
          processFiles(files, upload)
        })
      }

      document.addEventListener('click', (e) => {
        const target = e.target
        if (e.target.closest('[data-evt="custom_upload_remove"]')) {
          const upload = target.closest('[data-custom-upload]')
          if (!upload) throw new Error('data-custom-upload not found')
          const input = upload.querySelector('input[type="file"]')
          if (!input) throw new Error('input[type="file"] not found')
          const nameEl = e.target.closest('.custom-upload__file').querySelector('*[data-custom-name]')
          if (!nameEl) throw new Error('data-custom-name not found')

          const name = nameEl.innerHTML
          const newDataTransfer = new DataTransfer()
          const { files } = input

          for (let i = 0; i < files.length; i++) {
            if (files[i].name !== name) {
              newDataTransfer.items.add(files[i])
            }
          }

          if (newDataTransfer.items.length === 0) {
            input.value = ''
          } else {
            input.files = newDataTransfer.files
          }

          input.dispatchEvent(new Event('change', { 'bubbles': true }))
        }
      })
    },
    attachPayModal: () => {
      let evtOpenLater = $('[data-evt="payModalLater"]'),
        evtOpenCrypto = $('[data-evt="payModalCrypto"]'),
        evtClose = $('[data-evt="closePayModal"]'),
        crypto = $('#payModalCrypto'),
        later = $('#payModalLater'),
        modal = $('.pay-modal')

      const openModal = () => {
        lockScroll()
        modal.show()
        setTimeout(() => {
          modal.css({ opacity: 1 })
        }, 1);
      }

      const closeModal = () => {
        unlockScroll()
        modal.css({ opacity: 0 })
        setTimeout(() => {
          modal.hide()
        }, getTransitionTime(modal));
      }

      evtOpenLater.add(evtOpenCrypto).click(function () {
        openModal()
        crypto.add(later).hide()
        if ($(this).is(evtOpenCrypto)) {
          crypto.show()
        }
        if ($(this).is(evtOpenLater)) {
          later.show()
        }
      })

      evtClose.click(function () {
        closeModal()
      })
    },
    attachToggleInputs: function () {
      const arr = [...document.querySelectorAll('[data-input-toggle]')]
      for (const input of arr) {
        const btn = input.parentNode.querySelector('button') || input.parentNode.querySelector('input[type="submit"]')
        if (btn) {
          input.addEventListener('input', () => {
            const value = input.value
            if (value) {
              btn.disabled = false
              return
            }
            btn.disabled = true
            return
          })

          input.addEventListener('keydown', (e) => {
            const keyIsEnter = e.key === 'Enter'
            if (keyIsEnter) {
              e.preventDefault()
              btn.click()
            }
          })

          btn.addEventListener('click', () => {
            const value = input.value
            input.value = ''
            input.dispatchEvent(new Event('input'))
          })
        }
      }
    },
    initProductZoom: () => {
      const isDesktop = window.innerWidth > 991
      window.removeSlider = (target) => {
        unlockScroll()
        const slider = target.closest('.zoom_slider'); slider.css({ opacity: 0 })
        setTimeout(() => { slider.hide() }, 400);
      }

      const setDesktopZoom = () => {
        [...document.querySelectorAll('.product-media-img')].reduce((acc, el) => {
          if (el && el !== null) {
            if (!/(placeholder|store|pay)/gi.test(el.getAttribute('src'))) {
              acc.push($(el).parent('.product-media__inner-wrap'))
            }
          }
          return acc
        }, []).forEach((el) => {
          $(el).zoom({ magnify: 1.9, on: 'click' })
          $(el).on('mouseleave', function () { $(document).trigger('click') })
        })
      }

      const setMobileZoom = () => {
        const sliders = [...document.querySelectorAll('.product-slider')] // Get all existing sliders

        sliders.forEach((slider, index) => {
          const button = $('<button/>', { class: `product__zoom-btn zoom_btn${index}` }); button.appendTo($(slider)) // Create & append zoom button
          const renderNewSlider = (slider, index) => { // Get HTML new zoom slider
            let mediaArr = [...slider.querySelectorAll('img')].reduce((acc, img) => {
              const src = img.getAttribute('src')
              if (!acc.includes(src) && !/(placeholder|store|pay)/gi.test(src)) { acc.push(src) }
              return acc
            }, []).sort()

            this.renderMedia = () => {
              return mediaArr.reduce((acc, src) => {
                acc += `<div class="splide__slide"><img src="${src}"></div>`
                return acc
              }, '')
            }

            return `
            <div class="zoom_slider zsl${index}">
              <div>
                <div class="zoom_slider_logo"><img src="${String.raw`\themes\default\frontend\oct-2023/assets/logo.svg`}"></div>
                <button class="zoom_slider-close" onclick="removeSlider($(this))"></button>
                <div class="zoom-sl${index} splide">
                  <div class="splide__track">
                    <div class="splide__list">
                    ${this.renderMedia()}
                    </div>
                  </div>
                  <div class="splide__arrows">
                    <div class="splide__arrow--prev"></div>
                    <div class="splide__arrow--next"></div>
                  </div>
                </div>
              </div>
            </div>`
          }
          const appendNewSlider = (html) => { $body.append(html) } // Append Zoom Slider
          const initNewSlider = (index) => { // Splide Initialization
            this.settings = {
              type: "loop",
              perPage: 1,
              perMove: 1,
              autoplay: 0,
              gap: "12px",
              arrows: 1,
              pagination: 0,
              speed: 800,
              drag: false,
              dragAngleThreshold: 0
            }
            const zoomSlider = new Splide(`.zoom-sl${index}`, this.settings);
            zoomSlider.mount()
          }
          const initZoom = (index) => { // Initialize jQuery zoom for the new slider
            let slides = [...document.querySelector(`.zoom_slider.zsl${index}`).querySelectorAll('.splide__slide')]
            slides.forEach((slide) => {
              $(slide).zoom({
                magnify: 1.4,
                onZoomIn: function () {
                  $(this).closest('.splide').css('border-color', '#e6eaec')
                },
                onZoomOut: function () {
                  $(this).closest('.splide').css('border-color', '#0095c6')
                }
              })
            })
          }
          const showNewSlider = (index) => {
            let localSlider = $(`.zoom_slider.zsl${index}`)
            if (localSlider) { localSlider.show(); lockScroll(); setTimeout(() => { localSlider.css({ opacity: 1 }) }, 1); }
          }
          const openSlider = (index) => {
            let slider = $(`.zoom_slider.zsl${index}`)
            if (slider) { slider.show(); lockScroll(); setTimeout(() => { slider.css({ opacity: 1 }) }, 1); }
          }

          button.click(() => {
            const localSlider = document.querySelector(`.zoom_slider.zsl${index}`)
            if (!localSlider) {
              appendNewSlider(renderNewSlider(slider, index))
              initNewSlider(index)
              initZoom(index)
              showNewSlider(index)
            } else {
              openSlider(index)
            }
          })
        })
      }

      const setZoom = () => {
        $(document).ready(function () {
          if (document.querySelector('.main_product_zoom') == null) {
            if (isDesktop && $('.main_product').length) { setDesktopZoom() } else {
              setMobileZoom()
            }
          }
        })
      }

      return setZoom()
    },
    initTestProductZoom: () => {
      let zoomOpenCount = 0

      const setZoom = () => {
        const
          srcIsValid = (src) => {
            return !/(placeholder|store|pay)/gi.test(src)
          },
          filterMedia = (arr) => {
            return arr.reduce((acc, media) => {
              const
                img = media.querySelector('img'),
                thumbAncestor = media.closest('.product-slider_thumbnails'),
                zoomAncestor = media.closest('.zoom-modal')

              if (img && img !== null && thumbAncestor == null && zoomAncestor == null) {
                const src = img.getAttribute('src')
                if (srcIsValid(src)) { acc.push(media) }
              }
              return acc
            }, [])
          },
          getSrcArr = (arr) => {
            return arr.reduce((acc, media) => {
              const img = media.querySelector('img')
              if (img !== null) {
                if (img.hasAttribute('src')) {
                  const src = img.getAttribute('src')
                  if (srcIsValid(src) && !acc.includes(src)) { acc.push(src) }
                }
              }
              return acc
            }, [])
          },
          renderSlidesHTML = (srcArr) => {
            return srcArr.reduce((acc, src) => {
              acc += `<div style="cursor: zoom-in" class="zoom-modal__slide splide__slide"><img loading="eager" alt="" src="${src}"></div>`
              return acc
            }, '')
          },
          renderSplideHTML = (slidesHTML) => {
            let productTitle = $('.product__item-title').html(),
              price = $('.product__item-price').eq(-1).html()
            return `
          <div class="zoom-modal splide">
            <button data-evt="closeZoomModal" class="zoom-modal__close-btn"></button>
            <div class="zoom-modal__holder">
              <div class="splide__arrows">
                <div class="splide__arrow--prev"></div>
                <div class="splide__arrow--next"></div>
              </div>
              <div class="zoom-modal__header">
                <img src="${String.raw`\themes\default\frontend\oct-2023/assets/logo.svg`}" loading="lazy" alt="">
                <img style="display: none" src="${String.raw`./assets/logo.svg`}" loading="lazy" alt="">
              </div>
              <div class="zoom-modal__footer">
                <h1 class="zoom-modal__name">${productTitle}</h1>
                <a href="javascript:void(0)" data-evt="closeZoomModal" class="zoom-modal__buy-btn" onclick="addToCart()">Add To Cart<span>${price} USD</span></a>
              </div>
              <div class="zoom-modal__slider">
                <div class="splide__track">
                  <div class="splide__list">
                    ${slidesHTML}
                  </div>
                </div>
              </div>
            </div>
          </div>
          `
          },
          initZoomSlider = (indexToGo = 0) => {
            const
              settings = {
                type: "loop",
                perPage: 1,
                perMove: 1,
                autoplay: 0,
                gap: "12px",
                arrows: 1,
                pagination: 0,
                speed: 800,
                drag: false,
                dragAngleThreshold: 0
              },
              slider = document.querySelector('.zoom-modal')
            if (slider !== null) {
              const zoomSlider = new Splide('.zoom-modal', settings);
              zoomSlider.mount()
              zoomSlider.go(indexToGo)
            }
          },
          initPressZoom = (slider) => {
            const slides = [...slider.querySelectorAll('.splide__slide')],
              zoomValue = window.innerWidth > 479 ? 2.2 : 1.6
            slides.forEach((slide) => {
              $(slide).zoom({
                magnify: zoomValue,
                on: 'grab',
                onZoomIn: function () {
                  $('.zoom-modal .splide__arrows').css({ opacity: 0 })
                  $('.zoom-hint').css({ opacity: 0 })
                },
                onZoomOut: function () {
                  $('.zoom-modal .splide__arrows').css({ opacity: 1 })
                }
              })
            })
          }

        const mediaArr = filterMedia([...document.querySelectorAll('.product-media')])

        mediaArr.forEach((el) => {
          el.onclick = () => {
            lockScroll()
            try {
              const
                sibSrcArr = getSrcArr(filterMedia([...el.parentNode.closest('div').querySelectorAll('.product-media')])),
                splideHTML = renderSplideHTML(renderSlidesHTML(sibSrcArr))

              $body.append(splideHTML)
              initZoomSlider(sibSrcArr.indexOf(el.querySelector('img').getAttribute('src')))

              let zoomModal = document.querySelector('.zoom-modal'),
                holder = zoomModal.querySelector('.zoom-modal__holder')
              initPressZoom(zoomModal)

              let zoomHint = $('<\div>', { class: 'zoom-hint' })

              setTimeout(() => {
                zoomModal.style.opacity = 1
                if (zoomOpenCount <= 1) { $(holder).append(zoomHint); setTimeout(() => { zoomHint.css({ opacity: 1 }) }, 500) }
              }, 1);

              zoomModal.addEventListener('mousedown', () => {
                zoomHint.css({ opacity: 0 });
                setTimeout(() => {
                  zoomHint.remove()
                }, 450)
              })
              document.onkeydown = (e) => {
                e = e || window.event
                let isEsc = false
                if ('key' in e) {
                  isEsc = (e.key === "Escape" || e.key === "Esc");
                } else {
                  isEsc = (e.keyCode === 27);
                }
                if (isEsc) {
                  e.preventDefault()
                  unlockScroll()
                  let modal = $('.zoom-modal')
                  if (modal.length) {
                    modal.css({ opacity: 0 })
                    setTimeout(() => {
                      modal.remove()
                    }, getTransitionTime(modal));
                  }
                }
              }
              zoomOpenCount++
            } catch {
              throw new Error('JS : Init Product Zoom Error')
            }
          }
        })

        $(document).on('click', '[data-evt="closeZoomModal"]', function () {
          unlockScroll()
          let modal = $('.zoom-modal')
          if (modal.length) {
            modal.css({ opacity: 0 })
            setTimeout(() => {
              modal.remove()
            }, getTransitionTime(modal));
          }
        })
      }

      if (document.querySelector('.main_product_zoom') !== null) { setZoom() }
    },
    attachStickyScroll: () => {
      const bar = $('.filter-sidebar'), overlay = $('.filter-sidebar__overlay')
      if (bar.length && overlay.length) {
        const els = bar.find('.filter-row')
        $.each(els, function (i) {
          els[i].onclick = () => {
            let cont = $(this).find('.filter-row__container')
            setTimeout(() => {
              let currentHeight = bar.height()
              let scrollHeight = bar[0].scrollHeight
              if ((currentHeight - scrollHeight) <= -5) {
                overlay.css({ opacity: 1 })
              } else {
                overlay.css({ opacity: 0 })
              }
            }, getTransitionTime(cont));
          }
        })
        bar[0].addEventListener('scroll', function (e) {
          if (this.scrollTop + this.clientHeight >= this.scrollHeight) {
            overlay.css({ opacity: 0 })
          } else { overlay.css({ opacity: 1 }) }
        })
      }
    },
    attachCheckoutCopy: () => {
      const btnArr = [...document.querySelectorAll('.crypto-how-btn'), ...document.querySelectorAll('.copy-address-btn')]
      if (btnArr.length) {
        btnArr.forEach((btn) => {
          btn.onclick = () => {
            if (!window.getSelection().toString()) {
              let details = btn.closest('.checkout-form__radio-details')
              if (details !== null) {
                let address = details.querySelector('.copy-address-btn__typo').innerHTML
                async function copyAddress() {
                  try {
                    await navigator.clipboard.writeText(address);
                    details.classList.add(IS_COPIED)
                    setTimeout(() => {
                      details.classList.remove(IS_COPIED)
                    }, 1300);
                  } catch (err) {
                    details.classList.remove(IS_COPIED, IS_ERROR)
                    setTimeout(() => {
                      details.classList.remove(IS_COPIED, IS_ERROR)
                    }, 2100);
                  }
                }
                copyAddress()
              }
            }
          }
        })
      }
    },
    adjustStickyEls: () => {
      const elsArr = [...document.querySelectorAll('.filter-sidebar.to-stick'), ...document.querySelectorAll('.sticky-filters')]
      const header = document.querySelector('.header')

      if (elsArr.length && header) {
        function adjust() {
          let headerHeight = parseInt(window.getComputedStyle(header).getPropertyValue('height'))
          elsArr.forEach((el) => {
            let topValue = $(window).width() > 991 ? headerHeight + 24 : headerHeight
            Object.assign(el.style, { top: `${topValue}px` })
          })
        }
        ['load', 'resize'].forEach((event) => { window.addEventListener(event, () => { adjust() }) })
      }
    },
    bindCardFav: () => {
      const buttons = document.querySelectorAll('.card-item-fav')
      buttons.forEach(btn => btn.onclick = () => {
        if (btn.classList.contains(IS_ACTIVE)) {
          btn.classList.remove(IS_ACTIVE)
        } else {
          btn.classList.add(IS_ACTIVE)
        }
      })
    },
    observeSmartPictures: () => {
      const arr = [...document.querySelectorAll('.smart-picture')]
      for (const el of arr) {
        const img = el.querySelector('img')
        if (!img) {
          el.classList.add(__LOADED)
        } else {
          if (img.complete || img.src.length === 0) {
            el.classList.add(__LOADED)
          } else {
            img.addEventListener('load', () => {
              el.classList.add(__LOADED)
            })
          }
        }
      }
    }
  }
})

module.exports = pageEls
},{}],20:[function(require,module,exports){
const pageReviews = {
  init: function () {
    if (document.querySelector('.page-reviews.splide') !== null) {
      this.initSplide()
    }
  },
  initSplide: function () {
    try {
      let main = new Splide('.page-reviews', {
        type: "slider",
        perPage: 3.4,
        perMove: 1,
        autoplay: 0,
        pauseOnHover: 1,
        pauseOnFocus: 1,
        gap: 12,
        arrows: 1,
        pagination: 1,
        speed: 500,
        breakpoints: {
          991: {
            perPage: 2.2
          },
          620: {
            perPage: 1.3
          }
        }
      })
      main.mount()
    } catch {
      console.log('Page Review SPLIDE ERR')
    }
  }
}

module.exports = pageReviews
},{}],21:[function(require,module,exports){
const pgModal = new Object({
  initialized: undefined,
  init: function () {
    this.renderDOM();
    this.bindEvents();
    Object.values(this.initFn).forEach((target) => {
      if (typeof target === "function") target();
    });
    this.intialized = true;
  },

  renderDOM: function () {
    // Root
    this.modal = $(".pg-modal");
    this.container = $(".pg-modal__container");
    this.backdrop = $(".pg-modal__backdrop");
    this.close = $('[data-evt="closePgModal"]');

    // Sections
    this.section = $(".pg-section");
    this.row = $(".pg-row");
    this.scrollContainer = $(".pg-modal__overscroll");
    this.sectionBracelets = this.section.filter("#pgBracelets");
    this.sectionDiamonds = this.section.filter("#pgDiamonds");
    this.sectionRings = this.section.filter("#pgRings");
    this.sectionNecklaces = this.section.filter("#pgNecklaces");

    // Controls
    this.switchBtn = $(".pg-switch-btn");

    // Select Tabs
    this.selectArr = Array.from($(".pg-select"));
    this.selectBtn = $(".pg-select-btn");
  },
  bindEvents: function () {
    this.close.click(function () {
      pgModal.fn.closeModal();
    });
  },

  fn: {
    openModal: function (target) {
      lockScroll();
      pgModal.modal.show();
      setTimeout(() => {
        pgModal.backdrop.css({ opacity: 1 });
        pgModal.container.removeClass("is-hidden");
      }, 1);
      let att = $(target).attr("data-pg-open");
      pgModal.section.hide();
      switch (att) {
        case "diamonds":
          pgModal.sectionDiamonds.show();
          break;
        case "rings":
          pgModal.sectionRings.show();
          break;
        case "bracelets":
          pgModal.sectionBracelets.show();
          break;
        case "necklaces":
          pgModal.sectionNecklaces.show();
          break;
        default:
          pgModal.section[0].show();
          break;
      }
      pgModal.scrollContainer[0].scrollTop = 0;
      pgSelect.attachControls(pgModal.selectArr, pgModal.selectBtn);
    },
    closeModal: function () {
      unlockScroll();
      pgModal.backdrop.css({ opacity: 0 });
      pgModal.container.addClass("is-hidden");
      setTimeout(() => {
        pgModal.modal.hide();
      }, 475);
    },
    setMobile: function () {
      if ($(window).width() < 480) {
        let arr = Array.from(pgModal.section);
        for (let i = 0; i < arr.length; i++) {
          let nArr = Array.from($(arr[i]).find(pgModal.row));
          $.each(nArr, function (i) {
            if (i > 0) {
              $(nArr[i]).hide();
            }
          });
        }
      }
    },
    attachSectionControls: function () {
      pgModal.section.each(function () {
        let btnArr = [...$(this).find(pgModal.switchBtn)];
        let rowArr = [...$(this).find(pgModal.row)];
        $.each(btnArr, function (i) {
          btnArr[i].onclick = () => {
            $.each(rowArr, function (i) {
              $(rowArr[i]).hide();
            });
            $.each(btnArr, function (i) {
              $(btnArr[i]).removeClass("is-active");
            });
            $(this).addClass("is-active");
            $(rowArr[i]).show();
          };
        });
      });
    },
  },

  initFn: {
    setInitial: () => {
      pgModal.fn.closeModal();
      pgModal.fn.setMobile();
      pgModal.fn.attachSectionControls();
    },
  },
})

module.exports = pgModal
},{}],22:[function(require,module,exports){
const pgSelect = {
  initalized: undefined,
  init: function () {
    this.renderDOM();
    this.initalized = true;
  },
  getAttrDOM: function (att) {
    return $(`[data-pg-set="${att}"]`);
  },
  renderDOM: function () {
    // Shape
    this.shapeImg = this.getAttrDOM("shapeImg");
    this.shapeTitle = this.getAttrDOM("shapeTitle");
    this.shapeDescription = this.getAttrDOM("shapeDescription");

    // Color
    this.colorImg = this.getAttrDOM("colorImg");
    this.colorTitle = this.getAttrDOM("colorTitle");
    this.colorDescription = this.getAttrDOM("colorDescription");

    // Clarity
    this.clarityImg = this.getAttrDOM("clarityImg");
    this.clartyTitle = this.getAttrDOM("clarityTitle");
    this.clarityDescription = this.getAttrDOM("clarityDescription");

    // Ring Size
    this.currentSize = this.getAttrDOM("currentSize");
    this.circSize = this.getAttrDOM("circSize");
    this.dSize = this.getAttrDOM("dSize");
    this.euSize = this.getAttrDOM("euSize");
    this.ukSize = this.getAttrDOM("ukSize");
  },
  attachControls: function (sArr, sBtn) {
    if (!this.initalized) {
      pgSelect.init();
    }
    let selectArr = sArr,
      selectBtn = sBtn;
    for (let i = 0; i < selectArr.length; i++) {
      let thisAttr = selectArr[i].getAttribute("data-pg-select"),
        btnArr = Array.from($(selectArr[i]).find(selectBtn));

      function setPgSelectEvent() {
        let dataSet;
        switch (thisAttr) {
          case "shape":
            dataSet = pgSelect.shape;
            break;
          case "color":
            dataSet = pgSelect.color;
            break;
          case "clarity":
            dataSet = pgSelect.clarity;
            break;
          case "ring-size":
            dataSet = pgSelect.ringSize;
            break;
        }
        return { dataSet };
      }

      $.each(btnArr, function (i) {
        btnArr[i].onclick = () => {
          setPgSelectEvent().dataSet.changeDetails(i);
          $.each(btnArr, function (i) {
            btnArr[i].classList.remove("is-active");
          });
          $(this).addClass("is-active");
        };
      });
    }
  },
  shape: {
    changeDetails: function (index) {
      pgSelect.shapeImg.attr("src", pgSelect.data.shape[index].url);
      pgSelect.shapeTitle.html(pgSelect.data.shape[index].title);
      pgSelect.shapeDescription.html(pgSelect.data.shape[index].description);
    },
  },
  color: {
    changeDetails: function (index) {
      pgSelect.colorImg.attr("src", pgSelect.data.color[index].url);
      pgSelect.colorTitle.html(pgSelect.data.color[index].title);
      pgSelect.colorDescription.html(pgSelect.data.color[index].description);
    },
  },
  clarity: {
    changeDetails: function (index) {
      pgSelect.clarityImg.attr("src", pgSelect.data.clarity[index].url);
      pgSelect.clartyTitle.html(pgSelect.data.clarity[index].title);
      pgSelect.clarityDescription.html(
        pgSelect.data.clarity[index].description
      );
    },
  },
  ringSize: {
    changeDetails: function (index) {
      pgSelect.currentSize.html(pgSelect.data.ringSize[index].us);
      pgSelect.circSize.html(pgSelect.data.ringSize[index].circ);
      pgSelect.dSize.html(pgSelect.data.ringSize[index].diameter);
      pgSelect.euSize.html(pgSelect.data.ringSize[index].europe);
      pgSelect.ukSize.html(pgSelect.data.ringSize[index].uk);
    },
  },
  data: {
    shape: [
      {
        url: "https://i.ibb.co/ZBmcG0f/dmg-shape-round.png",
        title: "Round",
        description:
          "A classic and timeless shape, the round diamond is known for its brilliant sparkle and perfect symmetry.",
      },
      {
        url: "https://i.ibb.co/rdNkYyp/dmg-shape-priness.png",
        title: "Princess",
        description:
          "A square-shaped diamond with sharp corners and exceptional brilliance, known for its modern and clean lines.",
      },
      {
        url: "https://i.ibb.co/271bsCZ/dmg-shape-oval.png",
        title: "Oval",
        description:
          "A modified brilliant cut diamond with an elongated shape, known for its brilliance and ability to create the illusion of longer, slender fingers.",
      },
      {
        url: "https://i.ibb.co/qyQnV1f/dmg-shape-pear.png",
        title: "Pear",
        description:
          "An elegant combination of a round and marquise shape, sometimes called a teardrop, offering a unique and graceful appearance.",
      },
      {
        url: "https://i.ibb.co/NVdgJtv/dmg-shape-emerald.png",
        title: "Emerald",
        description:
          "A rectangular shape with stepped facets, highlighting the diamonds clarity and showcasing a timeless and sophisticated look.",
      },
    ],
    color: [
      {
        url: "https://i.ibb.co/MDnYmGh/dmg-color-near.png",
        title: "K - Last Grade",
        description:
          "The color may be visible to the unaided eye. Diamonds with a K-color grade can be a smart choice, offering excellent value for money.",
      },
      {
        url: "https://i.ibb.co/MDnYmGh/dmg-color-near.png",
        title: "J - Last Grade",
        description:
          'Color in diamonds graded as "near-colorless" may be slightly visible to the naked eye, especially in fancy shapes or diamonds larger than 1 carat.',
      },
      {
        url: "https://i.ibb.co/JkK4B3C/dmg-color-slight.png",
        title: "I - Slightly Detectable",
        description:
          "Upon close examination, the color may be barely noticeable, but it still provides exceptional value.",
      },
      {
        url: "https://i.ibb.co/J2JhPM4/dmg-color-clear.png",
        title: "H - Near Colorless",
        description:
          'The "near-colorless" grade of CA exhibits noticeable color only when compared to much higher color grades, offering excellent value.',
      },
      {
        url: "https://i.ibb.co/J2JhPM4/dmg-color-clear.png",
        title: "G - Almost Colorless",
        description:
          'This grade is the highest level of "near-colorless" and may show some color in comparison to the even higher "colorless" grades, but it offers excellent value.',
      },
      {
        url: "https://i.ibb.co/J2JhPM4/dmg-color-clear.png",
        title: "F - Colorless",
        description:
          'The "colorless" grade is most valued when placed in platinum or white gold, with a faint color that can be identified by a skilled gemologist.',
      },
      {
        url: "https://i.ibb.co/J2JhPM4/dmg-color-clear.png",
        title: "E - Colorless",
        description:
          'This grade, best showcased in platinum or white gold, is so "colorless" that even trained eyes would struggle to detect traces of color.',
      },
    ],
    clarity: [
      {
        url: "https://i.ibb.co/Gp8pKwK/clarity-i3.png",
        title: "I1, I2, I3 - Included",
        description:
          "Diamonds in this clarity range have inclusions that are easily visible under 10x magnification and may also be visible to the naked eye. These diamonds may have reduced brilliance and sparkle due to their inclusions.",
      },
      {
        url: "https://i.ibb.co/ZHBvJz9/clarity-si1-si2.png",
        title: "SI1 & SI2 - Slightly Included",
        description:
          "These grades have noticeable inclusions under 10x magnification, some of which might be visible to the naked eye. SI diamonds generally offer good value as they have inclusions that might not significantly affect the appearance of the diamond.",
      },
      {
        url: "https://i.ibb.co/27xG7GC/clarity-vs1-vs2.png",
        title: "VS1 & VS2 - Very Slightly Included",
        description:
          "These grades have minor inclusions that are visible under 10x magnification but are considered relatively small and not easily noticeable to the naked eye.",
      },
      {
        url: "https://i.ibb.co/d61wnL9/clarity-vvs1-vvs2.png",
        title: "VVS1 & VVS2 - Very, Very Slightly Included",
        description:
          "These grades indicate that inclusions are extremely difficult to see even under 10x magnification. VVS diamonds may have minor inclusions that are barely visible to a skilled grader.",
      },
      {
        url: "https://i.ibb.co/WKsqs99/clarity-fl-if.png",
        title: "FL & IF - Flawless",
        description:
          "These are the highest clarity grades. Flawless diamonds have no visible inclusions or blemishes under 10x magnification, even by a skilled grader. Internally Flawless diamonds have no internal inclusions but may have minor surface blemishes.",
      },
    ],
    ringSize: [
      { us: 4, europe: "47", uk: "H 1/2", diameter: "14.9", circ: "46.8" },
      { us: 4.5, europe: "48", uk: "I 1/2", diameter: "15.3", circ: "48" },
      { us: 5, europe: "49", uk: "J 1/2", diameter: "15.7", circ: "49.3" },
      { us: 5.5, europe: "51", uk: "K 1/2", diameter: "16.1", circ: "50.6" },
      { us: 6, europe: "52", uk: "L 1/2", diameter: "16.5", circ: "51.9" },
      { us: 6.5, europe: "53", uk: "M 1/2", diameter: "16.9", circ: "53.1" },
      { us: 7, europe: "54", uk: "N 1/2", diameter: "17.3", circ: "54.4" },
      { us: 7.5, europe: "55", uk: "O 1/2", diameter: "17.7", circ: "55.7" },
      { us: 8, europe: "57", uk: "P 1/2", diameter: "18.1", circ: "57.0" },
      { us: 8.5, europe: "58", uk: "Q 1/2", diameter: "18.5", circ: "58.3" },
      { us: 9, europe: "59", uk: "R 1/2", diameter: "19.0", circ: "59.5" },
      { us: 9.5, europe: "61", uk: "S 1/2", diameter: "19.4", circ: "60.8" },
      { us: 10, europe: "62", uk: "T 1/2", diameter: "19.8", circ: "62.1" },
      { us: 10.5, europe: "63", uk: "U 1/2", diameter: "20.2", circ: "63.4" },
      { us: 11, europe: "64", uk: "V 1/2", diameter: "20.6", circ: "64.6" },
      { us: 11.5, europe: "66", uk: "W 1/2", diameter: "21.0", circ: "65.9" },
      { us: 12, europe: "67", uk: "X 1/2", diameter: "21.4", circ: "67.2" },
      { us: 12.5, europe: "68", uk: "Z 1/2", diameter: "21.8", circ: "68.5" },
    ],
  },
}

module.exports = pgSelect
},{}],23:[function(require,module,exports){
function initValidators() {
  $(".needs-validation").parsley({
    errorClass: 'is-invalid text-danger',
    successClass: 'is-valid',
    errorsWrapper: '<div class="invalid-feedback"></div>',
    errorTemplate: '<span></span>',
    trigger: 'change'
  });
}

function resetBtnStates(el) {
  el.removeClass('is-successful');
  el.removeClass('is-failed');
}

function showAlternativeBtnText(el, msg, css_class) {
  var original_msg = $(el).html();
  resetBtnStates($(el));
  $(el).addClass(css_class).html(msg);
  setTimeout(function () {
    resetBtnStates($(el));
    $(el).html(original_msg);
  }, 4000);
}

function resetSignMessage() {
  const el = document.querySelector('.sign-modal__message')
  if (el) {
    el.classList.remove('is-successful')
    el.classList.remove('is-failed')
    el.style.display = 'none'
    el.innerHTML = ''
  }
}

function showSignMessage(msg, css_class) {
  const el = document.querySelector('.sign-modal__message')
  if (el) {
    var original_msg = el.innerHTML
    resetSignMessage()
    el.classList.add(css_class)
    el.style.display = 'flex'
    el.innerHTML = msg
    setTimeout(function () {
      resetSignMessage()
      el.innerHTML = original_msg
    }, 4000);
  }
}

function confirmLoginOtp() {
  var otp = $('#otp_1').val() + $('#otp_2').val() + $('#otp_3').val() + $('#otp_4').val();
  var phone = $('#otp_phone').val();
  var countryCode = $('#otp_country').val();
  var btn = '#btn_confirm_otp';


  if (otp != '' && otp.length == 4) {
    window.signModal.startLoading();
    $.ajax({
      url: '/confirm-otp',
      type: 'POST',
      data: { country_code: countryCode, phone_number: phone, otp_code: otp },
      success: function (data) {
        var r = $.parseJSON(data);
        var MsgClass = (r.error) ? 'is-failed' : 'is-successful';
        window.signModal.stopLoading();
        showSignMessage(r.msg, MsgClass);
        if (!r.error) {
          window.location.reload();
        }
      }
    });
  } else {
    showSignMessage('Enter 4 digits OTP', 'is-failed');
  }
}

function resendOtp() {
  var phone = $('#otp_phone').val();
  var countryCode = $('#otp_country').val();
  var btn = '#resend-otp-btn';
  window.signModal.startLoading();
  $.ajax({
    url: '/resend-otp',
    type: 'POST',
    data: { country_code: countryCode, phone_number: phone },
    success: function (data) {
      var r = $.parseJSON(data);
      var MsgClass = (r.error) ? 'is-failed' : 'is-successful';
      window.signModal.stopLoading();
      showSignMessage(r.msg, MsgClass);
    }
  })
}

window.initValidators = initValidators
window.resetBtnStates = resetBtnStates
window.showAlternativeBtnText = showAlternativeBtnText
window.resetSignMessage = resetSignMessage
window.showSignMessage = showSignMessage
window.confirmLoginOtp = confirmLoginOtp
window.resendOtp = resendOtp

window.Parsley.on('form:submit', function () {
  //console.log("submit form");
  var form = $(this.$element[0]);
  var url = form.attr('action');
  var btn = form.find(".js-loading-btn");
  $.ajax({
    type: "POST",
    url: url,
    data: form.serialize(), // serializes the form's elements.
    success: function (data) {
      var r = $.parseJSON(data);
      if (!r.error) {
        //show success state on button and return message in r.msg
        showSignMessage(r.msg, 'is-successful');
        window.setTimeout(function () {
          if (r.link != undefined && r.link != '') {
            window.location.href = r.link;
          } else {
            window.location.reload();
          }
        }, 3000);
      } else {
        //show failed state on button and return message in r.msg
        showSignMessage(r.msg, 'is-failed');
      }
    }
  });
  return false;
});

$(document).ready(function () {
  $('#btn_confirm_otp').on('click', function () {
    confirmLoginOtp();
  });
  $('#resend-otp-btn').on('click', function () {
    resendOtp();
  });
  $('#frm_login_otp').on('submit', function (e) {
    var phoneField = document.querySelector('#phone_input_Login');
    var iti = window.intlTelInputGlobals.getInstance(phoneField);
    e.preventDefault();
    var fullPhone = iti.getNumber();
    var countryCode = '+' + iti.getSelectedCountryData().dialCode;
    var phone = fullPhone.replace(countryCode, '');
    var btn = $(e.target).find(".js-loading-btn");
    $('#otp_phone').val(phone);
    $('#otp_country').val(countryCode);
    $.ajax({
      url: '/send-otp',
      type: 'POST',
      data: { country_code: countryCode, phone_number: phone },
      success: function (data) {
        var r = $.parseJSON(data);
        var MsgClass = (r.error) ? 'is-failed' : 'is-successful';
        showSignMessage(r.msg, MsgClass);
        if (!r.error) {
          $('.sign-modal__phone-span').html(fullPhone);
          window.signModal.switch('otp');
        }
      }
    });
  });
});
},{}],24:[function(require,module,exports){
const bookModal = {
  step: 1,
  apptData: {},

  root: document.querySelector('.book-sell'),
  backdrop: document.querySelector('.book-sell__backdrop'),
  container: document.querySelector('.book-sell__container'),

  evtNextStep: $('[data-evt="bookModalNext"]'),
  evtBackStep: $('[data-evt="bookModalBack"]'),
  evtToggle: $('[data-evt="toggleBookModal"]'),

  sectionDate: $('#bookSectionDate'),
  sectionPersonal: $('#bookSectionPersonal'),
  sectionConfirm: $('#bookSectionConfirm'),

  inputName: document.getElementById('bookFullName'),
  inputEmail: document.getElementById('bookEmail'),
  inputPhone: document.getElementById('bookPhone'),
  inputArr: [this.inputName, this.inputEmail, this.inputPhone],

  confirmName: document.getElementById('bookConfirmName'),
  confirmEmail: document.getElementById('bookConfirmEmail'),
  confirmPhone: document.getElementById('bookConfirmPhone'),
  confirmDate: document.getElementById('bookConfirmDate'),
  confirmTime: document.getElementById('bookConfirmTime'),

  init: function () {
    if (this.root !== null) {
      this.dateTime.init()
      this.attachEvents()
    }
  },

  close: function () {
    unlockScroll()
    this.container.style.transform = 'translateX(100%)'
    this.backdrop.style.opacity = 0
    setTimeout(() => {
      this.root.style.display = 'none'
    }, getTransitionTime(this.container));
  },
  open: function () {
    if (!$('.book-sell__date-box').length) { bookModal.dateTime.appendBoxes(bookModal.dateTime.getDates(true)) }
    lockScroll()
    this.root.style.display = 'block'
    setTimeout(() => {
      this.container.style.transform = 'translateX(0%)'
      this.backdrop.style.opacity = 1
    }, 1);
  },
  toggle: function () {
    if (window.getComputedStyle(this.root).getPropertyValue('display') !== 'none') {
      this.close()
    } else {
      this.open()
    }
  },
  attachEvents: function () {
    this.evtToggle.click(function () {
      bookModal.toggle()
    })
    this.evtNextStep.click(function () {
      switch (bookModal.step) {
        case 1:
          if (bookModal.apptData.date) {
            bookModal.step = 2
            bookModal.sectionDate.hide()
            bookModal.sectionPersonal.show()
            bookModal.observer()
          }
          break;
        case 2:
          if (bookModal.inputName.value && bookModal.inputEmail.value && bookModal.inputPhone.value) {
            bookModal.step = 3
            bookModal.sectionPersonal.hide()
            bookModal.sectionConfirm.show()
            bookModal.apptData.name = bookModal.inputName.value
            bookModal.apptData.email = bookModal.inputEmail.value
            bookModal.apptData.phone = bookModal.inputPhone.value
            bookModal.apptData.url = window.location.href;
            bookModal.observer()
          }
          break;
        case 3:
          bookModal.apptData.date_day = $('#bookConfirmDate').text();
          bookModal.apptData.time = $('#bookConfirmTime').text();
          //alert(JSON.stringify(bookModal.apptData)) // change later
          $.ajax({
            url: '/json/book-appointment',
            type: 'POST',
            data: { json: JSON.stringify(bookModal.apptData) },
            success: function (data) {
              bookModal.close()
              setTimeout(() => {
                bookModal.reset()
              }, getTransitionTime(bookModal.container));
            }
          });

          break;
      }
    })
    this.evtBackStep.click(function () {
      switch (bookModal.step) {
        case 1:
          bookModal.close()
          break;
        case 2:
          --bookModal.step
          bookModal.observer()
          bookModal.sectionPersonal.hide()
          bookModal.sectionDate.show()
          break;
        case 3:
          --bookModal.step
          bookModal.observer()
          bookModal.sectionConfirm.hide()
          bookModal.sectionPersonal.show()
          break;
      }
    })
    const attachInputObesrver = () => {
      let arr = [bookModal.inputName, bookModal.inputEmail, bookModal.inputPhone]
      arr.forEach((el) => { el.oninput = () => { bookModal.observer() } })
    }
    attachInputObesrver()
  },

  dateTime: {
    intervals: [[11, 0o0, 0o0], [13, 30, 0o0], [15, 30, 0o0], [16, 0o0, 0o0], [16, 30, 0o0]],
    daysPerView: 3,
    holder: document.getElementById('bookSellDates'),

    init: function () {
      this.attachEvents()
      this.appendBoxes(this.getDates(true))
    },
    renderHTML: (date) => {
      const weekday = date.toLocaleDateString('en-US', { weekday: 'long' }), day = date.getDate(), month = date.toLocaleDateString('en-US', { month: 'short' }), time = date.toLocaleTimeString('en-US', { hour: 'numeric', hour12: true, minute: 'numeric' })

      let ifPast = new Date() > date ? ' disabled' : ''
      let dayTime = date.getDay() == 6 ? 'Closed' : date.getDay() == 0 ? 'Closed' : time
      let isWeekend = date.getDay() == 6 ? ' is-closed' : date.getDay() == 0 ? ' is-closed' : ''

      return `
      <div class="book-sell__date-box${isWeekend}" data-time="${String(date)}"${ifPast}>
        <span>${weekday}, ${day}${getOrdinalTxt(day)} ${month}</span>
        <span>${dayTime}</span>
      </div>
      `
    },
    appendBoxes: function (arr) {
      arr.forEach((el) => this.holder.insertAdjacentHTML('beforeend', el))
    },
    getDates: function (isNext) {
      let daysArr = [], initial = 0
      let arr = [...document.querySelectorAll('.book-sell__date-box')]
      let initialDate

      if (arr.length == 0) {
        initialDate = new Date()
      } else {
        if (isNext == true) {
          initialDate = new Date(arr[arr.length - 1].getAttribute('data-time'))
        } else {
          initialDate = new Date(arr[0].getAttribute('data-time'))
        }
      }

      if (arr.length !== 0) {
        arr.forEach(el => el.remove());
        if (isNext == true) {
          initialDate.setDate(initialDate.getDate() + 1)
        } else { initialDate.setDate(initialDate.getDate() - 1) }
      }

      while (initial !== this.daysPerView) {
        let dayDate = new Date(initialDate)
        if (isNext == true) { daysArr.push(new Date(dayDate.setDate(initialDate.getDate() + initial))) } else {
          daysArr.push(new Date(dayDate.setDate(initialDate.getDate() - initial)))
        }
        ++initial
      }

      let ints = isNext == true ? this.intervals : this.intervals.slice().reverse()

      let htmlArr = daysArr.reduce((acc, date) => {
        ints.forEach((interval) => {
          let thisDate = new Date(date)
          thisDate.setHours(...interval)
          acc.push(this.renderHTML(thisDate))
        })
        return acc
      }, [])

      if (isNext == true) { return htmlArr } else { return htmlArr.reverse() }
    },
    attachEvents: function () {
      $('[data-switch-time]').click(function () {
        let attr = $(this).attr('data-switch-time')
        switch (attr) {
          case 'next':
            bookModal.dateTime.appendBoxes(bookModal.dateTime.getDates(true))
            break;
          case 'prev':
            if ([...document.querySelectorAll('.book-sell__date-box')][0])
              bookModal.dateTime.appendBoxes(bookModal.dateTime.getDates(false))
            break;
        }
      }),
        $(document).on('click', '.book-sell__date-box', function () {
          $(this).toggleClass(IS_ACTIVE).siblings().removeClass(IS_ACTIVE)
          bookModal.observer()
        })
    }
  },

  observer: function () {
    switch (this.step) {
      case 1:
        let activeDate = $('.book-sell__date-box').filter(`.${IS_ACTIVE}`)
        if (activeDate.length) {
          this.apptData.date = new Date(activeDate.attr('data-time'))
          this.evtNextStep.attr('disabled', false)
        } else {
          delete this.apptData.date
          this.evtNextStep.attr('disabled', true)
        }
        break;
      case 2:
        if (this.inputName.value && this.inputEmail.value && this.inputPhone.value && this.apptData.date) {
          this.evtNextStep.attr('disabled', false)
        } else {
          this.evtNextStep.attr('disabled', true)
        }
        break;
      case 3:
        this.confirmName.innerHTML = this.apptData.name
        this.confirmEmail.innerHTML = this.apptData.email
        this.confirmPhone.innerHTML = this.apptData.phone
        this.confirmDate.innerHTML = `${this.apptData.date.getDate()}${getOrdinalTxt(this.apptData.date.getDate())} ${this.apptData.date.toLocaleDateString('en-US', { month: 'long' })}`
        this.confirmTime.innerHTML = this.apptData.date.toLocaleTimeString('en-US', { hour: 'numeric', hour12: true, minute: 'numeric' })
        break;
    }
  },
  reset: function () {
    bookModal.step = 1
    let inputArr = [this.inputName, this.inputEmail, this.inputPhone]
    inputArr.forEach((el) => { el.value = '' })
    $('.book-sell__date-box').removeClass(IS_ACTIVE)
    bookModal.sectionConfirm.hide()
    bookModal.sectionPersonal.hide()
    bookModal.sectionDate.show()
    Object.values(bookModal.apptData).forEach((el) => {
      delete el
    })
    $('.book-sell__date-box').remove()
    bookModal.observer()
  }
}

module.exports = bookModal
},{}],25:[function(require,module,exports){
const cartModal = new Object({
  init: function () {
    this.renderDOM()
    this.bindToggle()
  },
  renderDOM: function () {
    this._ = $(".cart-modal");
    this.backdrop = this._.find(".cart-modal__backdrop");
    this.container = this._.find(".cart-modal__container");
    this.evtToggle = getEvtDOM("toggleCart");
  },
  bindToggle: function () {
    $(document).on('click', '[data-evt="toggleCart"]', function () {
      let el = $(".cart-modal")
      if (el.length) {
        let container = $(".cart-modal__container"),
          backdrop = $(".cart-modal__backdrop")
        if (elemDisplayed(el)) {
          unlockScroll();
          Object.assign(backdrop[0].style, { opacity: 0 });
          Object.assign(container[0].style, { transform: "translateX(100%)" });
          setTimeout(() => {
            el.hide();
          }, getTransitionTime(container));
        } else {
          lockScroll();
          el.show();
          setTimeout(() => {
            Object.assign(backdrop[0].style, { opacity: 1 });
            Object.assign(container[0].style, { transform: "translateX(0%)" });
          }, 1);
        }
      }
    })
  },
  toggle: function () {
    let el = cartModal._;
    if (el.length) {
      if (elemDisplayed(el)) {
        cartModal.close();
      } else {
        cartModal.open();
      }
    }
  },
  open: function () {
    lockScroll();
    this._.show();
    setTimeout(() => {
      Object.assign(this.backdrop[0].style, { opacity: 1 });
      Object.assign(this.container[0].style, { transform: "translateX(0%)" });
    }, 1);
  },
  close: function () {
    unlockScroll();
    Object.assign(this.backdrop[0].style, { opacity: 0 });
    Object.assign(this.container[0].style, { transform: "translateX(100%)" });
    setTimeout(() => {
      this._.hide();
    }, getTransitionTime(cartModal.container));
  },
})

module.exports = cartModal
},{}],26:[function(require,module,exports){
const currencyModal = new Object({
  init: function () {
    this.renderDOM();
    this.bindEvents();
  },
  renderDOM: function () {
    this._ = $(".cur-modal");
    this.backdrop = this._.find(".cur-modal__backdrop");
    this.container = this._.find(".cur-modal__container");
    this.evtToggle = getEvtDOM("toggleCurrency");
    this.input = this._.find("input");
  },
  bindEvents: function () {
    if (currencyModal.evtToggle.length) {
      $.each(currencyModal.evtToggle, (i) => {
        currencyModal.evtToggle[i].onclick = () => {
          currencyModal.toggle();
        };
      });
    }

    if (currencyModal.input.length) {
      currencyModal.input.on("keyup", function () {
        currencyModal.intraSearch($(this));
      });
    }
  },
  toggle: function () {
    this.input.val("").trigger("keyup");
    let modal = currencyModal._;
    if (modal.length) {
      if (elemDisplayed(modal)) {
        currencyModal.close();
      } else {
        currencyModal.open();
      }
    }
  },
  open: function () {
    lockScroll();
    this._.show();
    setTimeout(() => {
      this.backdrop.css({ opacity: 1 });
      this.container.css({ transform: "translateX(0%)" });
    }, 1);
  },
  close: function () {
    unlockScroll();
    this.backdrop.css({ opacity: 0 });
    this.container.css({ transform: "translateX(100%)" });
    setTimeout(() => {
      this._.hide();
    }, getTransitionTime(currencyModal.backdrop));
  },
  intraSearch: function (input) {
    let val = input.val().toLowerCase(),
      arr = [...$(".cur-item")];
    $.each(arr, function (index) {
      let txt = $(arr[index]).find(".cur-item__name").text().toLowerCase();
      if (~txt.indexOf(val)) {
        $(arr[index]).show();
      } else {
        $(arr[index]).hide();
      }
    });
  },
})

module.exports = currencyModal
},{}],27:[function(require,module,exports){
const mailModal = new Object({
  init: function () {
    this.renderDOM()
    if (this.modal.length) {
      this.bindEvents()
    }
  },
  renderDOM: function () {
    this.modal = $('.mail-modal')
    this.backdrop = $('.mail-modal__backdrop')
    this.container = $('.mail-modal__container')
    this.evtClose = $('[data-mail-modal="close"]')
  },
  bindEvents: function () {
    this.evtClose.on('click', function () { mailModal.close() })
  },
  open: function () {
    lockScroll()
    this.modal.show()
    this.modal.find('input').focus()
    setTimeout(() => {
      this.modal.addClass(__ACTIVE)
    }, 5);
  },
  close: function () {
    unlockScroll()
    this.modal.removeClass(__ACTIVE)
    setTimeout(() => {
      this.modal.hide()
    }, getTransitionTime(this.container));
  }
})

module.exports = mailModal
},{}],28:[function(require,module,exports){
class Menu {
  constructor(rootSelector = '.menu') {
    this._state = false
    this.overState = false
    this.rootEl = document.querySelector(rootSelector)

    if (!this.rootEl) {
      return
    }

    this.contentList = this.rootEl.querySelector('.menu__content-list')
    this.overList = this.rootEl.querySelector('.menu__over-list')
    this.subListArr = [...this.rootEl.querySelectorAll('[data-menu-list]')]
    this.activeListName = this.rootEl.querySelector('#activeListName')

    this.init()
  }

  get state() {
    return this._state
  }

  set state(value) {
    this._state = value
    if (this._state) {
      this.open(true)
    } else {
      this.close(true)
    }
  }

  open(fromSetter = false) {
    if (!fromSetter) {
      this._state = true
    }

    this.rootEl.style.display = 'block'
    setTimeout(() => {
      lockScroll()
      this.rootEl.classList.add(__ACTIVE)
      window.menuBackdrop = new Backdrop({
        half: true,
        callback: () => { this.close() }
      })
    }, 5);
  }

  close(fromSetter = false) {
    if (!fromSetter) {
      this._state = false
    }

    if (window.menuBackdrop) {
      window.menuBackdrop.hide(true)
    }

    unlockScroll()
    this.rootEl.classList.remove(__ACTIVE)

    if (this.overState) {
      this.closeOverList()
    }

    setTimeout(() => {
      this.contentList.scrollTop = 0
      this.rootEl.style.display = 'none'
    }, getTransitionTime(this.rootEl));
  }

  toggle() {
    this.state = !this.state
  }

  openOverList() {
    if (!this.overState) {
      this.overState = true
      this.overList.style.display = 'block'
      this.overList.scrollTop = 0
      this.rootEl.classList.add('--over-active')
      setTimeout(() => {
        this.contentList.classList.add(__HIDDEN)
        this.overList.classList.add(__VISIBLE)
      }, 5);
    }
  }

  closeOverList() {
    if (this.overState) {
      this.overState = false
      this.contentList.classList.remove(__HIDDEN)
      this.overList.classList.remove(__VISIBLE)
      this.rootEl.classList.remove('--over-active')
      this.contentList.scrollTop = 0

      setTimeout(() => {
        this.overList.style.display = 'none'
      }, getTransitionTime(this.overList));

      if (this.activeListName) {
        this.activeListName.innerHTML = this.activeListName.dataset.title || 'Explore Icebox'
      }
    }
  }

  goToNavList(name, item = undefined) {
    if (name) {
      const list = this.subListArr.find(el => el.dataset.menuList === name)
      if (!list) throw new Error('data-menu-list not found')

      this.subListArr.forEach((el) => {
        if (el !== list) {
          el.style.display = 'none'
        } else {
          el.style.display = 'block'
        }
      })
      if (this.activeListName && item) {
        this.activeListName.innerHTML = item.querySelectorAll('span')[0].innerHTML
      }
      this.openOverList()
    }
  }

  reset() {
    this.state = false
    this.overState = false
    this.contentList.scrolTop = 0
    this.overList.scrollTop = 0
  }

  // Events
  bindEvents() {
    const evtNavArr = [...document.querySelectorAll('[data-menu-nav]')]
    evtNavArr.forEach((item) => {
      item.onclick = () => {
        if (this.state && !this.overState) {
          const listName = item.dataset.menuNav
          this.goToNavList(listName, item)
        }
      }
    })

    const evtToggleMenuArr = [...document.querySelectorAll('[data-evt="toggleMenu"]')]
    evtToggleMenuArr.forEach((el) => {
      el.addEventListener('click', () => {
        this.open()
      })
    })
  }

  init() {
    this.reset()
    this.bindEvents()
  }
}

module.exports = Menu
},{}],29:[function(require,module,exports){
const quizModal = {
  currentStep: undefined,
  isFinished: undefined,
  pollLength: undefined,
  maxStep: undefined,
  isInitialized: undefined,
  init: function () {
    this.renderDOM()
    this.setInitial()
    this.bindEvents()
  },
  renderDOM: function () {
    this.modal = $('.quiz-modal')
    this.container = this.modal.find('.quiz-container')
    this.backdrop = this.modal.find('.quiz-modal__backdrop')
    this.heightContainer = this.modal.find('.quiz-container-height')
    this.poll = this.modal.find('.quiz-poll')
    this.pollArr = [...this.poll]
    this.answers = this.modal.find('.quiz-answer')
    this.fullStepText = this.modal.find('.quiz-step-text')
    this.currentStepText = this.modal.find('.quiz-current-step')
    this.maxStepText = this.modal.find('.quiz-max-step')
    this.bar = this.modal.find('.quiz-bar')
    this.evtGoNext = $('[data-evt="quizGoNext"]')
    this.evtOpen = $('[data-evt="openQuizModal"]')
    this.closeBtn = $('[data-evt="closeQuizModal"]')
  },
  bindEvents: function () {
    this.evtGoNext.click(function () {
      quizModal.goNextStep()
    })
    this.closeBtn.click(function () {
      quizModal.close()
    })
    this.evtOpen.click(function () {
      quizModal.open()
    })
  },
  setInitial: function () {
    this.currentStep = 1, this.isFinished = false, this.pollLength = this.pollArr.length, this.maxStep = this.pollLength
    if (this.pollLength !== 0 && this.pollLength !== undefined && this.isInitialized !== true) {
      this.isInitialized = true
      quizModal.currentStepText.html(quizModal.currentStep)
      quizModal.maxStepText.html(quizModal.maxStep)
      this.modal.find('input[type="radio"]').prop('checked', false); this.evtGoNext.html('Next')
      // Object.assign(this.heightContainer[0].style, { height: `${this.getObjectScrollHeight(this.pollArr[0])}` })
      Object.assign(this.bar[0].style, { width: `${(100 / this.pollLength)}%` })
    } else {
      return false
    }
  },
  // utils
  getObjectScrollHeight: function (obj) {
    if (obj instanceof jQuery) {
      return `${obj[0].scrollHeight}px`
    } else {
      return `${obj.scrollHeight}px`
    }
  },
  noEmptyAnswers: function () {
    let parent = $(quizModal.pollArr[(quizModal.currentStep - 1)]),
      checkedRadio = parent.find('input[type="radio"]:checked'),
      answers = parent.find(quizModal.answers)
    if (checkedRadio.length == 0) {
      answers.css({ opacity: '0.3' }); setTimeout(() => { answers.css({ opacity: 1 }) }, 375);
    } else {
      return true
    }
  },
  goNextStep() {
    if (quizModal.currentStep !== quizModal.maxStep) {
      if (quizModal.noEmptyAnswers()) {
        Object.assign(quizModal.pollArr[(quizModal.currentStep - 1)].style, { opacity: 0 })
        Object.assign(quizModal.bar[0].style, { width: `${(100 / quizModal.pollLength) * (quizModal.currentStep + 1)}%` })
        $.each(quizModal.pollArr, function (i) {
          Object.assign(quizModal.pollArr[i].style, { transform: `translateX(-${(quizModal.currentStep * 100)}%)` })
        })
        Object.assign(quizModal.heightContainer[0].style, { height: `${quizModal.pollArr[quizModal.currentStep].scrollHeight}px` })
        ++quizModal.currentStep
        quizModal.currentStepText.html(quizModal.currentStep)
        if (quizModal.currentStep == quizModal.maxStep) {
          quizModal.evtGoNext.html('Show Results')
        }
      }
    } else {
      if (quizModal.noEmptyAnswers()) {
        Object.assign(quizModal.heightContainer[0].style, { height: '0px' })
        Object.assign(quizModal.bar[0].style, { width: '5%' })
        $.each(quizModal.pollArr, function (i) {
          Object.assign(quizModal.pollArr[i].style, { transform: `translateX(-${(quizModal.currentStep * 100)}%)` })
        })
        Object.assign(quizModal.pollArr[(quizModal.currentStep - 1)].style, { opacity: 0 })
        quizModal.evtGoNext.prop('disabled', true)
        quizModal.fullStepText.text('FINDING WATCHES')
        $('.quiz-close-btn').remove()
        quizModal.isFinished = true
        setTimeout(() => {
          quizModal.bar.animate({ width: '100%' }, 3000, function () { quizModal.close() })
        }, 600);
      }
    }
  },
  open: function () {
    lockScroll()
    quizModal.modal.show()
    Object.assign(this.heightContainer[0].style, { height: `${this.getObjectScrollHeight(this.pollArr[quizModal.currentStep - 1])}` })
    setTimeout(() => {
      Object.assign(quizModal.backdrop[0].style, { opacity: 1 })
      Object.assign(quizModal.container[0].style, { transform: 'translateY(0px)', opacity: 1 })
    }, 1);
  },
  close: function () {
    unlockScroll()
    let timeToHide = (parseFloat(window.getComputedStyle(quizModal.backdrop[0]).transitionDuration) * 1000)
    Object.assign(quizModal.backdrop[0].style, { opacity: 0 })
    Object.assign(quizModal.container[0].style, { transform: 'translateY(32px)', opacity: 0 })
    setTimeout(() => {
      quizModal.modal.hide()
    }, timeToHide);
  }
}

module.exports = quizModal
},{}],30:[function(require,module,exports){
const salesModal = {
  init: function () {
    this.renderDOM()
    if (this.modal.length) {
      this.bindEvents()
    }
  },
  renderDOM: function () {
    this.modal = $('.sale-history-modal')
    this.container = $('.sale-history__container')
    this.evtClose = $('[data-evt="closeSalesModal"]')
  },
  bindEvents: function () {
    this.evtClose.click(function () {
      salesModal.close()
    })
  },
  open: function () {
    window.addEventListener('keydown', function (evt) {
      if (evt.key === 'Escape') {
        evt.preventDefault()
        salesModal.close()
      }
    }, { once: true })
    lockScroll()
    this.modal.show()
    setTimeout(() => {
      this.modal.css({ 'background-color': "rgba(13, 16, 26, .7)" })
      this.container.css({ 'transform': 'translateX(0%)' })
    }, 1);
  },
  close: function () {
    unlockScroll()
    this.modal.css({ 'background-color': "rgba(13, 16, 26, 0)" })
    this.container.css({ 'transform': 'translateX(100%)' })
    setTimeout(() => {
      this.modal.hide()
    }, getTransitionTime(this.modal));
  }
}

module.exports = salesModal
},{}],31:[function(require,module,exports){
class SignModal {
  constructor() {
    this.rootEl = document.querySelector('.sign-modal')
    if (!this.rootEl) {
      console.error('No element with class .sign-modal found.')
      return
    }
    this.adjustEl = this.rootEl.querySelector('.sign-modal__adjust')
    this.backdrop = this.rootEl.querySelector('.sign-modal__backdrop')
    this.container = this.rootEl.querySelector('.sign-modal__container')
    this.formsArr = [...this.rootEl.querySelectorAll('form')]
    this.evtOpenArr = document.querySelectorAll('[data-evt="openSignModal"]')
    this.evtCloseArr = document.querySelectorAll('[data-evt="closeSignModal"]')
    this.evtJsToggleSign = document.querySelectorAll('.js-toggle-sign')
    this.contentArr = [...this.rootEl.querySelectorAll('[data-sign-content]')]
    this.evtSwitchContentArr = this.rootEl.querySelectorAll('[data-sign-switch]')
    this.evtTogglePassword = [...this.rootEl.querySelectorAll('[data-evt="togglePassword"]')]
    this.loader = this.rootEl.querySelector('.sign-modal__loader')
    this.jsSubmitArr = [...this.rootEl.querySelectorAll('.js-submit')]
    this.otpArr = [...this.rootEl.querySelectorAll('input.--otp')]
    this.locked = false
    this.opened = true
    this.activeContent = undefined
    this.init()
  }

  /**
   * Getters
   */
  get getActiveContent() {
    return this.contentArr.find(e => window.getComputedStyle(e).display !== 'none')
  }

  /**
   * Utils
   */
  lockModal() {
    this.rootEl.classList.add(__LOCKED)
    this.locked = true
  }
  unlockModal() {
    this.rootEl.classList.remove(__LOCKED)
    this.locked = false
  }

  /**
   * Methods
   */
  switch(contentType) {
    let section = this.contentArr.find(e => e.dataset.signContent === contentType) || this.contentArr[0]
    let activeSection = this.contentArr.find((el) => {
      let displayProperty = window.getComputedStyle(el).display
      return displayProperty !== 'none'
    })
    if (!section) throw new Error(`Expected to find section with data-sign-content=${contentType}`)
    if (activeSection == section) return
    if (contentType == 'otp') {
      this.otpArr.forEach((el) => {
        el.value = ''
      })
    }

    this.activeContent = section
    this.lockModal()
    const currentHeight = this.adjustEl.offsetHeight
    this.adjustEl.style.opacity = 0
    this.adjustEl.style.height = `${currentHeight}px`
    setTimeout(() => {
      this.contentArr.forEach(e => e.style.display = 'none')
      section.style.display = 'flex'
      const newHeight = section.scrollHeight
      this.adjustEl.style.height = `${newHeight}px`

      setTimeout(() => {
        this.adjustEl.style.opacity = '1'
        this.unlockModal()
      }, 5)
      setTimeout(() => {
        this.adjustEl.style.height = 'auto'
      }, getTransitionTime(this.adjustEl));
    }, getTransitionTime(this.adjustEl));
  }
  toggle() {
    if (this.opened) {
      this.close()
    } else {
      this.open()
    }
  }
  open() {
    if (!this.opened) {
      if (window.menu) {
        if (window.menu.state) {
          window.menu.state = false
        }
      }
      const content = this.contentArr.find(e => e.dataset.signContent == 'sms') || this.contentArr[0]
      this.opened = true
      this.rootEl.style.display = 'block'
      this.adjustEl.style.height = 'auto'
      this.contentArr.forEach(e => e.style.display = 'none')
      content.style.display = 'flex'
      // content.querySelector('input').focus()
      lockScroll()
      const show = () => {
        this.backdrop.style.opacity = 1
        this.container.classList.remove(IS_HIDDEN)
      }
      setTimeout(show, 1)
    }
  }
  close() {
    if (this.opened) {
      this.opened = false
      this.backdrop.style.opacity = 0
      this.container.classList.add(IS_HIDDEN)
      unlockScroll()
      setTimeout(() => {
        this.rootEl.style.display = 'none'
      }, getTransitionTime(this.backdrop))
    }
  }
  startLoading() {
    if (this.loader && !this.locked) {
      this.unlockModal()
      this.loader.style.display = 'flex'
      setTimeout(() => { this.loader.style.opacity = '1' }, 10)
    }
  }
  stopLoading() {
    if (this.loader) {
      this.loader.style.opacity = '0'
      setTimeout(() => {
        this.loader.style.display = 'none'
        this.locked = false
      }, getTransitionTime(this.loader))
    }
  }

  /**
   * Bind Events
   */
  bindToggleVisiblity() {
    // Open
    for (const el of this.evtOpenArr) {
      el.addEventListener('click', (e) => {
        e.preventDefault()
        this.toggle()
      })
    }
    // Close
    for (const el of this.evtCloseArr) {
      el.addEventListener('click', (e) => {
        e.preventDefault()
        this.close()
      })
    }
    // Toggle
    for (const el of this.evtJsToggleSign) {
      el.addEventListener('click', (e) => {
        e.preventDefault()
        this.toggle()
        const contentName = el.dataset.signSwitch
        if (contentName) {
          this.switch(contentName)
        }
      })
    }
  }
  bindSwitchContent() {
    for (const el of this.evtSwitchContentArr) {
      el.addEventListener('click', (e) => {
        e.preventDefault()
        const contentName = el.dataset.signSwitch
        this.switch(contentName)
      })
    }
  }
  bindOTPInput() {
    const inputs = this.otpArr
    for (const input of inputs) {
      input.addEventListener('paste', (e) => {
        const data = e.clipboardData.getData('text');
        const value = data.split("");
        if (value.length === inputs.length) {
          inputs.forEach((input, index) => (input.value = value[index]));
        }
      })
      input.addEventListener('input', (e) => {
        const value = e.target.value
        if (value.length > 1) {
          e.target.value = value.replace(/./g, '')
        }
        if (value.match(/\D/g)) {
          e.target.value = ''
        }
        if (value.length > 0) {
          const nextInput = e.target.nextElementSibling
          const valueIsDigit = value.match(/\d/g)
          if (nextInput && valueIsDigit) {
            nextInput.focus()
          }
        }
      })
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Backspace') {
          e.target.value = ''
          const prevInput = e.target.previousElementSibling
          if (prevInput) {
            prevInput.focus()
          }
        }
        if (e.key === 'ArrowLeft') {
          const prevInput = e.target.previousElementSibling
          if (prevInput) {
            prevInput.focus()
          }
        } else if (e.key === 'ArrowRight') {
          const nextInput = e.target.nextElementSibling
          if (nextInput) {
            nextInput.focus()
          }
        }
      })
    }
  }
  bindTogglePassword() {
    for (const btn of this.evtTogglePassword) {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        const input = btn.parentNode.querySelector('input')
        if (input) {
          const type = input.getAttribute('type') === 'password' ? 'text' : 'password'
          const svgShow = btn.querySelector('.svg_pass_show')
          const svgHide = btn.querySelector('.svg_pass_hide')

          input.type = type
          if (svgShow && svgHide) {
            if (type === 'text') {
              svgShow.style.display = 'none'
              svgHide.style.display = 'inline'
            } else {
              svgShow.style.display = 'inline'
              svgHide.style.display = 'none'
            }
          }
        }
      })
    }
  }
  bindSubmit() {
    this.formsArr.forEach((form) => {
      $(form).on('submit', function () {
        if ($(this).parsley().isValid()) {
          this.startLoading()
        }
      })
    })
  }

  /**
   * Initialize
   */
  initialSetup() {
    this.rootEl.style.display = 'none'
    this.close()
    this.switch('phone_register')
  }
  init() {
    if (this.rootEl) {
      this.bindToggleVisiblity()
      this.bindSwitchContent()
      this.bindOTPInput()
      this.bindTogglePassword()
      this.bindSubmit()
      this.initialSetup()
      initValidators()
    }
  }
}

module.exports = SignModal
},{}],32:[function(require,module,exports){
const account = new Object({
  init: function () {
    Object.values(this.attachEvents).forEach((fn) => {
      if (fn !== undefined && typeof fn == 'function') fn();
    })
  },
  attachEvents: {
    editAddress: function () {
      const evtEditAddress = Array.from($('[data-edit="address"]'))
      for (let i = 0; i < evtEditAddress.length; i++) {
        const el = evtEditAddress[i];

        $(el).click(function () {
          let details = $(this).closest('.profile-card').find('.profile-card__details'),
            form = details.filter('.form')
          if (elemDisplayed(form)) {
            details.hide().not(form).show()
          } else {
            details.show().not(form).hide()
          }
        })

      }
    },
    toggleInvoiceHeight: function () {
      const invoiceArr = [...document.querySelectorAll('.order__invoice')]
      for (const invoice of invoiceArr) {
        const header = invoice.querySelector('.order__invoice-header')
        const body = invoice.querySelector('.order__invoice-body')

        header.onclick = () => {
          const toClose = invoice.classList.contains(__ACTIVE)
          if (toClose) {
            invoice.classList.remove(__ACTIVE)
            body.style.height = `80px`
          } else {
            invoice.classList.add(__ACTIVE)
            const scrollHeight = body.scrollHeight
            body.style.height = `${scrollHeight}px`
          }
        }
      }
    }
  }
})

module.exports = account
},{}],33:[function(require,module,exports){
const blogPage = {
  init: function () {
    Object.values(this.initFn).forEach((fn) => {
      if (typeof fn === 'function') {
        try { fn() }
        catch { console.log('blog JS ERR') }
      }
    })
  },
  initFn: {
    attachCommentSubmit: () => {
      const commentArea = document.querySelector('[data-article="commentArea"]')
      const commentSubmit = document.querySelector('[data-article="commentSubmit"]')
      const holder = document.querySelector('.article__comments-wrap')

      if (commentArea !== null && commentSubmit !== null) {
        const submit = () => {
          const
            val = commentArea.value
          if (val.length !== 0) {
            const
              user = 'Guets',
              date = new Date().toLocaleDateString('en-us', { year: "numeric", month: "short", day: "numeric" }),
              html = `
              <div class="article-comment"><span>${user}</span><span>${val}</span><span>${date}</span></div>
              `

            holder.insertAdjacentHTML("beforeend", html)
            commentArea.value = ''
          }
        }

        commentSubmit.onclick = () => {
          submit()
        }

        commentArea.onkeydown = (e) => {
          const isEnter = e.key === 'Enter' || e.keyCode === 13
          if (isEnter) {
            e.preventDefault()
            submit()
          }
        }
      }
    },
    createProgressBar: () => {
      const readContent = document.querySelector('.article__read-content')
      if (!readContent) return
      let y = 0
      let fullHeight = (readContent.getBoundingClientRect().bottom + 120) - (window.innerHeight * 0.7)
      const calculatePercentage = (number, total) => {
        return (number / total) * 100
      }
      const setElementWidthPercent = (el, percent) => {
        el.style.width = `${percent}%`
      }

      const
        bar = document.createElement('div'),
        progress = document.createElement('div')

      bar.className = 'blog-progress'
      bar.appendChild(progress)

      document.body.appendChild(bar)

      window.onscroll = () => {
        y = window.scrollY
        let f = calculatePercentage(y, fullHeight)
        setElementWidthPercent(progress, f)
      }
    },
    setReadingTime: () => {
      const
        readContent = document.querySelector('.article__read-content'),
        timeEl = document.querySelector('.read-time')
      if (!readContent || !timeEl) return

      const
        wordsPerMinute = 200,
        textContent = readContent.textContent,
        wordCount = textContent.split(/\s/g).length,
        readingTime = Math.ceil(wordCount / wordsPerMinute)


      timeEl.textContent = `${readingTime} min reading`
    },
    attachScroll: () => {
      return
      const img = document.querySelector('.article-top-cover img')
      if (img !== null) {
        let max = img.offsetHeight + 100
        window.onscroll = () => {
          let y = window.scrollY
          if (max > y) {
            let f = 1 - (y * 100 / max * 0.01)
            img.style.marginTop = `-${y * 0.08}px`
            img.style.opacity = f
          }
        }
      }
    }
  }
}

module.exports = blogPage
},{}],34:[function(require,module,exports){
const formPage = new Object({
  uploadedImages: [],
  init: function () {
    if (document.querySelector('.main_formpage')) {
      this.bindEvents()
      // this.imgUpload()
      this.attachImagesUploader()
      this.attachWatchesUpload()
    }
  },
  bindEvents: function () {
    $('.formpage__upload-btn').click(function () {
      if ($('#image_upload').length) { $('#image_upload').trigger('click') }
    })
    // $('#formpage_form').on('submit', function (e) {
    //   e.preventDefault();
    //   formPage.submitAjax();
    // });
  },
  submitAjax: function () { },
  attachImagesUploader: () => {
    const uploadLabel = document.querySelector('#formpage_img-uploader'),
      uploadInput = document.querySelector('#image_upload'),
      imagesWrap = $('.formpage__images-thumbnails')

    // Setting drag&drop event
    if (uploadLabel !== null) {
      uploadLabel.ondragover = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.add(IS_ACTIVE)
      }
      uploadLabel.ondragleave = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.remove(IS_ACTIVE)
      }
      uploadLabel.ondrop = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.remove(IS_ACTIVE)
        $('#image_upload').prop('files', evt.dataTransfer.files);
        const files = [], items = [...evt.dataTransfer.items]
        items.forEach((item, i) => {
          if (item.kind === 'file') {
            files.push(item.getAsFile())
          }
        })
        if (files.length) {
          $('.formpage__images-thumbnails').empty()
        }
        processFiles([...files])
      }
    }

    // Setting manual files upload
    if (uploadInput !== null) {
      uploadInput.onchange = (evt) => {
        const files = [...evt.target.files]
        $('.formpage__images-thumbnails').empty()
        processFiles(files)
      }
    }

    function processFiles(files) {
      if (files.length) {
        files.forEach((file, i) => {
          if (!file.type.match('image.*')) { return }

          let getIndex = () => {
            return $('.formpage__upload').length + 1
          }

          let reader = new FileReader()
          reader.onload = function (e) {
            let html =
              `
               <div class="formpage__upload" data-img-id="${getIndex()}">
                 <div class="formpage__input-boxes">
                   <div>
                     <input value="1" name="visible_image_${i}" id="image_${i + 1}" type="checkbox" checked>
                     <label for="image_${getIndex()}"></label>
                   </div>
                 </div>
                   <div data-name="${file.name}" style="background-image: url(${e.target.result})" class="formpage__upload-bg">
                 </div>
               </div>
             `
            imagesWrap.append(html)
          }
          reader.readAsDataURL(file)
        })
      }
    }

    // Setting checkbox toggle on appended images
    $body.on('click', ".formpage__upload-bg", function () {
      lockScroll()
      let html =
        `
      <div class="formpage-zoom">
        <div data-evt="closeFormpageZoom"></div>
        <div data-block="formpageZoom"></div>
      </div>
      `
      $body.append(html)
      $('[data-block="formpageZoom"]').attr('style', $(this).attr('style'))
    });
    $body.on('click', '[data-evt="closeFormpageZoom"]', function () {
      unlockScroll()
      $('.formpage-zoom').remove()
    })
  },
  attachWatchesUpload: () => {
    const container = document.querySelector('#watches_upload_label'),
      input = document.querySelector('#watches_upload')

    container.addEventListener("dragover", (e) => {
      e.preventDefault()
    }, false)

    container.addEventListener("dragenter", () => {
      container.classList.add(__ACTIVE)
    })

    container.addEventListener("dragleave", () => {
      container.classList.remove(__ACTIVE)
    })

    container.addEventListener("drop", (e) => {
      e.preventDefault()
      container.classList.remove(__ACTIVE)
      input.files = e.dataTransfer.files
    })
  }
})

module.exports = formPage
},{}],35:[function(require,module,exports){
class Homepage {
  constructor() {
    this.init()
  }

  // Splides
  initCategoriesSplide() {
    const categoriesElem = document.querySelector('.home-categories-splide')
    if (categoriesElem) {
      let slider = new Splide(categoriesElem, {
        type: "loop",
        perPage: 7,
        perMove: 2,
        autoplay: 0,
        gap: "8px",
        arrows: 1,
        pagination: 0,
        speed: 750,
        breakpoints: {
          1680: { perPage: 6, },
          1120: { perPage: 5, },
          767: { perPage: 3, perMove: 2 },
          600: { perPage: 2, gap: 6 }
        }
      })
      slider.mount()
    }
  }

  initSplide() {
    const splideArr = [...document.querySelectorAll('.home-splide')]
    if (splideArr.length) {
      splideArr.forEach((elem) => {
        let slider = new Splide(elem, {
          type: "loop",
          perPage: 5,
          perMove: 1,
          autoplay: 0,
          gap: "8px",
          arrows: 1,
          pagination: 0,
          speed: 750,
          breakpoints: {
            1980: {
              perPage: 5
            },
            1680: {
              perPage: 4
            },
            991: {
              perPage: 4,
              perMove: 1,
            },
            767: {
              grid: {
                rows: 2,
                cols: 3,
                gap: { row: "24px", col: "8px" }
              }
            },
            478: {
              grid: {
                rows: 2,
                cols: 2
              },
            },
          },
        })
        slider.mount(window.splide.Extensions);
      })
    }
  }

  init() {
    this.initCategoriesSplide()
    this.initSplide()
  }
}

module.exports = Homepage
},{}],36:[function(require,module,exports){
class JobApp {
  constructor(holder, settings = {}) {
    this.holder = holder
    this.filesHolder = this.holder.querySelector('#job_files_upload')
    this.sections = [...this.holder.querySelectorAll('[data-loan-section]')]
    this.content = this.holder.querySelector('.loan-case__content')
    this.scroller = this.holder.querySelector('.loan-scroller')
    this.footer = this.holder.querySelector('.loan-case__footer')
    this.btnGroup = this.holder.querySelector('.loan-case__btn-group')
    this.evtGo = [...this.holder.querySelectorAll('[data-loan-evt="go"]')]
    this.evtToggle = [...this.holder.querySelectorAll('[data-loan-evt="toggle"]')]
    this.evtSubmit = [...this.holder.querySelectorAll('[data-loan-evt="submit"]')]
    this.evtBack = [...this.holder.querySelectorAll('[data-loan-evt="back"]')]
    this.bar = this.holder.querySelector('.loan-bar')
    this.bar_progress = this.holder.querySelector('.loan-bar__progress')
    this.flow = this.holder.querySelector('.loan-flow')
    this.finish = this.holder.querySelector('.loan-finish')
    this.maxSteps = undefined
    this.currentStep = undefined
    this.stepsLeft = undefined
    this.endReached = undefined
    this.atStart = undefined
    this.sliding = false
    this.data = {}
    this.settings = {
      scrollSpeed: settings.scrollSpeed || 600,
      easing: settings.easing || 'cubic-bezier(.39, .575, .565, 1)',
    }
    if (this.holder) {
      this.init()
    }
  }

  /**
   * Utils
   */
  get getLeftSteps() {
    return this.steps - this.currentStep
  }
  get getActiveSection() {
    return this.sections[this.currentStep]
  }
  get getActiveInput() {
    const section = this.getActiveSection
    if (section && section.contains(document.activeElement)) {
      if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') {
        return document.activeElement
      }
    } else {
      return undefined
    }
  }
  get getLoaderHTML() {
    return `
                            <div>
                                <div>
                                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewBox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
                                        <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"></path>
                                        <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0C22.32,8.481,24.301,9.057,26.013,10.047z"></path>
                                        <animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatCount="indefinite"></animateTransform>
                                    </svg>
                                </div>
                            </div>
    `
  }
  createElem(tagName, options) {
    const { className, id, innerHTML, style, attributes, toAppend } = options
    const elem = document.createElement(tagName)
    if (className) elem.className = className;
    if (id) elem.id = id;
    if (innerHTML) elem.innerHTML = innerHTML;
    if (style) {
      for (const key in options.style) { elem.style[key] = options.style[key] }
    }
    if (attributes) {
      for (const key in options.attributes) { elem.setAttribute(key, options.attributes[key]) }
    }
    if (toAppend) {
      for (const child of toArray(toAppend)) { elem.appendChild(child) }
    }
    return elem
  }
  toArray(target) {
    return Array.isArray(target) ? target : [target]
  }
  loadingOn(timeToRemove) {
    if (this.holder.querySelector('.loan-case-loader')) return
    const loader = createElem('div', {
      className: 'loan-case-loader',
      innerHTML: this.getLoaderHTML
    })
    this.holder.appendChild(loader)
    setTimeout(() => {
      this.holder.classList.add(__LOCKED)
      if (timeToRemove) {
        setTimeout(() => {
          this.holder.classList.remove(__LOCKED)
          setTimeout(() => {
            loader.remove()
          }, 350);
        }, timeToRemove);
      }
    }, 1);
  }
  loadingOff() {
    this.holder.classList.remove(__LOCKED)
    const loader = this.holder.querySelector('.loan-case-loader')
    if (loader) {
      setTimeout(() => {
        loader.remove()
      }, 350);
    }
  }
  showInputError(input, text) {
    const err = document.querySelector('.loan-input-error') ? document.querySelector('.loan-input-error') : createElem('div', {
      className: 'loan-input-error',
      innerHTML: text
    })
    if (input) {
      input.classList.add(__INVALID)
    }
    this.footer.prepend(err)
  }
  clearErrors() {
    const activeSection = this.getActiveSection
    const inputs = [...activeSection.querySelectorAll('input'), ...activeSection.querySelectorAll('select')]
    inputs.forEach(input => input.classList.remove(__INVALID))
    const err = this.holder.querySelector('.loan-input-error')
    if (err) err.remove()
  }
  observeBar() {
    const prevSections = this.sections.slice(0, this.currentStep).length
    const progress = (prevSections + 1) / this.steps * 100
    this.bar_progress.style.width = `${progress}%`
  }
  clearAllFields() {
    const inputs = [...this.holder.querySelectorAll('input:not([type="checkbox"])')]
    const selects = [...this.holder.querySelectorAll('select')]
    const checkboxes = [...this.holder.querySelectorAll('input[type="checkbox"]')]
    const fullArr = [...inputs, ...selects, ...checkboxes]

    inputs.forEach(input => input.value = '')
    selects.forEach(select => select.selectedIndex = 0)
    checkboxes.forEach((checkbox) => { checkbox.checked = false })
    fullArr.forEach(elem => elem.dispatchEvent(new Event('change')))
  }

  /**
   * Main
   */
  save() {
    $('#job_application_form').submit();
  }
  finishMessage() {
    this.loadingOn(1000)
    setTimeout(() => {
      this.flow.style.opacity = 0
      let currentHeight = this.holder.offsetHeight
      this.holder.style.height = `${currentHeight}px`
      setTimeout(() => {
        this.finish.style.display = 'block'
        let scrollH = this.finish.scrollHeight
        this.holder.style.height = `${scrollH}px`
        setTimeout(() => {
          this.finish.style.opacity = 1
          window.scrollTo(0, 0)
          const confetti = new PageConfetti()
          confetti.push(false)
        }, 10);
      }, getTransitionTime(this.flow) + 10)
    }, 800);
  }
  slide(section) {
    section.style.display = 'flex'
    const height = section.scrollHeight
    const pxToTransform = this.sections.slice(0, this.currentStep).reduce((acc, el) => acc + el.scrollHeight, 0)
    this.content.style.height = `${height}px`
    this.scroller.style.transform = `translateY(-${pxToTransform}px)`
    this.sections.forEach(e => e.classList.remove(IS_ACTIVE))
    section.classList.add(IS_ACTIVE)
    setTimeout(() => {
      this.sliding = false
    }, getTransitionTime(this.scroller));
  }
  go(toStep) {
    if (this.holder.classList.contains(__LOCKED)) return
    const inputs = [...this.holder.querySelectorAll('input'), ...this.holder.querySelectorAll('select')]
    const step = toStep || this.currentStep || 0
    const nextStep = step + 1
    const nextSection = this.sections[nextStep]

    if (!this.sections[nextStep + 1]) {
      this.evtGo.forEach((btn) => {
        btn.innerHTML = 'Submit'
      })
    }

    if (nextSection) {
      this.sliding = true
      inputs.forEach(input => input.blur())
      this.loadingOn()
      setTimeout(() => {
        this.currentStep = nextStep
        this.slide(nextSection)
        this.loadingOff()
        this.observeBar()
      }, 600);
    } else {
      this.save()
      this.finishMessage()
    }
  }
  back(toStep) {
    if (this.holder.classList.contains(__LOCKED)) return
    this.clearErrors()
    const step = toStep || this.currentStep || 0
    const prevStep = step - 1
    const prevSection = this.sections[prevStep]
    if (prevSection) {
      this.evtGo.forEach((btn) => {
        btn.innerHTML = 'Next'
      })
      this.currentStep = prevStep
      this.slide(prevSection)
    } else {
      this.toggle()
    }
  }
  validate(section) {
    const requiredTextInputs = [...section.querySelectorAll('input[type="text"][required]:not(.--disabled'), ...section.querySelectorAll('input[type="email"][required]')]
    const emptyInputs = requiredTextInputs.filter(input => !input.value)
    const numberInputs = section.querySelectorAll('input[data-validate="number"]')
    const selectInputs = section.querySelectorAll('select[required]')
    const emailInputs = section.querySelectorAll('input[data-validate="email"]')
    const zipInputs = section.querySelectorAll('input[data-validate="zip_code"]')
    const fileInputs = section.querySelectorAll('input[required][type="file"]')
    const sectionID = section.dataset.loanSection

    if (requiredTextInputs.some(input => input.classList.contains(__INVALID))) return false

    if (selectInputs.length) {
      for (const select of selectInputs) {
        if (!select.value) {
          this.showInputError(select, 'Please select an option')
          return false
        }
      }
    }
    if (numberInputs.length) {
      const value = numberInputs[0].value
      const regex = /^\+\d{1}\s\(\d{3}\)\s\d{3}\-\d{4}$/
      if (!regex.test(value)) {
        this.showInputError(numberInputs[0], 'Please enter a valid phone number')
        return false
      }
    }
    if (emailInputs.length) {
      const value = emailInputs[0].value
      const regex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/
      if (!regex.test(value)) {
        this.showInputError(emailInputs[0], 'Please enter a valid email')
        return false
      }
    }
    if (zipInputs.length) {
      const value = zipInputs[0].value
      const regex = /^\d{5}$/
      if (!regex.test(value)) {
        this.showInputError(zipInputs[0], 'Please enter a valid zip code')
        return false
      }
    }
    if (emptyInputs.length) {
      this.showInputError(emptyInputs[0], 'This field is required')
      return false
    }
    if (fileInputs.length) {
      for (const input of fileInputs) {
        if (!input.files[0]) {
          console.log(input.files)
          this.showInputError(null, 'Please upload a file')
          return false
        }
      }
    }
    this.clearErrors()
    return true
  }
  adjustActiveSectionHeight() {
    const activeSection = this.getActiveSection
    if (activeSection) {
      const height = activeSection.scrollHeight
      this.content.style.height = `${height}px`
    }
  }
  toggle() {
    const body = document.querySelector('body')
    const headerNav = document.querySelector('.header__sub-nav')
    const welcome = document.querySelector('.subpage__welcome')
    const footerMain = document.querySelector('.footer__wrapper > .wrapper')
    const loanWelcome = document.querySelector('.loan-welcome')
    const heading = document.querySelector('.loan-case__heading')
    const backGroup = document.querySelector('.loan-case__back-group')
    const CASE_CLASS = 'loan_case'
    const elements = [headerNav, welcome, footerMain, loanWelcome]

    const hideElement = (el) => {
      const curHeight = el.scrollHeight
      el.style.height = `${curHeight}px`
      setTimeout(() => {
        el.style.overflow = 'hidden'
        el.style.height = '0px'
      }, 1);
    }
    const showElement = (el) => {
      const curHeight = window.getComputedStyle(el).getPropertyValue('height')
      const scrollHeight = el.scrollHeight
      el.style.height = `${curHeight}`
      setTimeout(() => {
        el.style.overflow = 'visible'
        el.style.height = `${scrollHeight}px`
      }, 1)
    }

    const hideLoan = () => {
      body.classList.remove(CASE_CLASS)
      for (const element of elements) {
        if (element) showElement(element)
      }

      this.scroller.style.display = 'none'
      this.content.style.height = `0px`

      if (backGroup) {
        backGroup.style.height = `0px`
      }

      if (heading) {
        heading.innerHTML = 'Welcome To the Icebox Max Approval Financing Form'
        heading.classList.remove('--big')
      }

      this.clearErrors()
      this.back(1)
      this.clearAllFields()
    }
    const showLoan = () => {
      body.classList.add('loan_case')
      for (const element of elements) {
        if (element) hideElement(element)
      }

      this.scroller.style.display = 'flex'
      this.content.style.height = `${this.sections[0].scrollHeight}px`

      if (backGroup) {
        backGroup.style.height = `${backGroup.scrollHeight}px`
      }

      if (heading) {
        heading.innerHTML = 'Job Application'
        heading.classList.add('--big')
      }
    }

    if (body.classList.contains(CASE_CLASS)) {
      const askModal = new AskModal({
        heading: 'Are You Sure You Want To Exit Financing App?',
        subheading: 'You will lose all the progress. Keep filling out the form and get approved as soon as possible!',
        exitText: 'Exit',
        keepText: 'Keep Filling',
        exitCallback: hideLoan,
      })
      askModal.show()
    } else {
      showLoan()
    }
  }
  tabPress() {
    if (!this.sliding) {
      const activeInput = this.getActiveInput
      if (!activeInput) {
        const section = this.getActiveSection
        const inputArray = [...section.querySelectorAll('input:not(.--disabled), select:not(.--disabled)')]
        if (inputArray.length) {
          let inputToFocus
          const invalidInputs = inputArray.filter(input => input.classList.contains('--invalid'))
          if (invalidInputs.length) {
            inputToFocus = invalidInputs[0]
          } else {
            const emptyInputs = inputArray.filter(input => !input.value && input.value !== 0)
            if (emptyInputs.length) {
              inputToFocus = emptyInputs[0]
            } else {
              inputToFocus = inputArray[0]
            }
          }
          inputToFocus.focus()
        }
      } else {
        const activeInputWrap = activeInput.parentNode.closest('.loan-input-wrap')
        const nextInputWrap = activeInputWrap.nextElementSibling
        if (nextInputWrap) {
          const nextInput = nextInputWrap.querySelector('input, select')
          if (nextInput) {
            nextInput.focus()
          }
        } else {
          const firstInputWrap = this.getActiveSection.querySelector('.loan-input-wrap')
          const firstInput = firstInputWrap.querySelector('input, select')
          if (firstInput) {
            firstInput.focus()
          }
        }
      }
    }
  }

  /**
   * Bind Events
   */
  bindStepEvt() {
    this.evtGo.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        const section = this.getActiveSection
        if (this.validate(section)) this.go()
      })
    })
    this.evtBack.forEach((btn) => {
      btn.addEventListener('click', () => {
        this.back()
      })
    })
    this.evtSubmit.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        this.evtGo[0].click()
      })
    })
    this.evtToggle.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        this.toggle()
      })
    })

  }
  bindInputEvents() {
    const inputs = [...this.holder.querySelectorAll('input')]
    const selects = [...this.holder.querySelectorAll('select')]
    const noWebsiteCheckbox = this.holder.querySelector('#loan_employer_website')
    const inputWebsiteEmployer = this.holder.querySelector('#loan_employer_website')

    document.addEventListener('keydown', (e) => {
      const isTab = e.key === 'Tab'
      if (isTab) {
        if (document.body.classList.contains('loan_case')) {
          e.preventDefault()
          this.tabPress()
        }
      }
    })

    inputs.forEach((input) => {
      input.addEventListener('focus', () => {
        this.clearErrors()
        const parent = input.parentNode.closest('.loan-input-wrap')
        if (parent) {
          parent.classList.add('--focused')
        }
      })
      input.addEventListener('blur', () => {
        const parent = input.parentNode.closest('.loan-input-wrap')
        if (parent) {
          parent.classList.remove('--focused')
        }
      })
      input.addEventListener('keydown', (e) => {
        this.clearErrors()
        const isEnter = e.key === 'Enter'
        const isTab = e.key === 'Tab'
        if (isEnter) {
          this.evtGo[0].click()
        }
      })
    })
    selects.forEach((select) => {
      select.addEventListener('change', () => {
        this.clearErrors()
      })
    })
  }
  bindSSNInput() {
    const inputs = this.holder.querySelectorAll('input[data-format="ssn"]')
    for (const input of inputs) {
      input.addEventListener('input', (e) => {
        const value = e.target.value
        let newValue = ''
        for (let i = 0; i < value.length; i++) {
          const char = value.charAt(i)
          if (char.match(/^[0-9]$/) && newValue.length < 9) {
            newValue += char
          }
        }
        e.target.value = newValue
      })
      input.addEventListener('blur', (e) => {
        const value = e.target.value
        if (value) {
          let newValue = value.replace(/([^0-9])/g, '')
          newValue = newValue.slice(0, 3) + '—' + newValue.slice(3, 5) + '—' + newValue.slice(5)
          e.target.value = newValue
        }
      })
      input.addEventListener('focus', (e) => {
        e.target.value = e.target.value.replace(/([^0-9])/g, '')
      })
    }
  }
  bindNumberInput() {
    const inputs = this.holder.querySelectorAll('input[data-validate="number"]')
    for (const input of inputs) {
      let keyCode;
      function mask(event) {
        event.keyCode && (keyCode = event.keyCode);
        let pos = this.selectionStart;
        if (pos < 3) event.preventDefault()
        let matrix = "+1 (___) ___-____",
          i = 0,
          def = matrix.replace(/\D/g, ""),
          val = this.value.replace(/\D/g, ""),
          newValue = matrix.replace(/[_\d]/g, function (a) {
            return i < val.length ? val.charAt(i++) || def.charAt(i) : a;
          });
        i = newValue.indexOf("_");
        if (i != -1) {
          i < 5 && (i = 3);
          newValue = newValue.slice(0, i);
        }
        let reg = matrix.substr(0, this.value.length).replace(/_+/g,
          function (a) {
            return "\\d{1," + a.length + "}";
          }).replace(/[+()]/g, "\\$&");
        reg = new RegExp("^" + reg + "$");
        if (!reg.test(this.value) || this.value.length < 5 || keyCode > 47 && keyCode < 58) this.value = newValue;
        if (event.type == "blur" && this.value.length < 5) this.value = "";
      }

      input.addEventListener("input", mask, false);
      input.addEventListener("focus", mask, false);
      input.addEventListener("blur", mask, false);
      input.addEventListener("keydown", mask, false);
      input.addEventListener('mouseup', event => {
        event.preventDefault()
        if (input.value.length < 4) {
          input.setSelectionRange(4, 4)
        } else {
          input.setSelectionRange(input.value.length, input.value.length)
        }
      })
    }
  }
  bindResumeUpload() {
    const input = document.querySelector('#job_resume')
    const box = document.querySelector('[data-loan="files_upload"]')
    const holder = this.filesHolder
    // if (!input || !box || !holder) throw new Error('JS : Bind ID Upload : Input or Box or Holder not found')

    if (input && box && holder) {

      function processFiles(files) {
        const allowedExtensions = ['pdf', 'docx', 'doc']
        for (const file of files) {
          const name = file.name.toLowerCase()
          const extension = name.split('.').pop()
          if (allowedExtensions.includes(extension)) {
            console.log(file)
          }
        }
      }

      box.onclick = () => {
        this.clearErrors()
        input.click()
      }
      input.onchange = (e) => {
        processFiles(e.target.files)
      }
      box.ondragover = (e) => {
        this.clearErrors()
        e.preventDefault()
        box.classList.add(IS_ACTIVE)
      }
      box.ondragleave = (e) => {
        this.clearErrors()
        e.preventDefault()
        box.classList.remove(IS_ACTIVE)
      }
      box.ondrop = (e) => {
        this.clearErrors()
        e.preventDefault()
        box.classList.remove(IS_ACTIVE)
      }
    }
  }
  bindDualSelect() {
    const dualArr = this.holder.querySelectorAll('[data-loan-evt="dual_select"]')
    for (const dual of dualArr) {
      const input = dual.querySelector('input:not([type="checkbox"])')
      const checkbox = dual.querySelector('input[type="checkbox"]')
      if (input && checkbox) {
        checkbox.onchange = () => {
          let isChecked = checkbox.checked
          if (isChecked) {
            input.classList.add('--disabled')
            input.setAttribute('disabled', 'disabled')
            if (input.type !== 'range') {
              input.value = ''
            }
          } else {
            input.removeAttribute('disabled')
            input.classList.remove('--disabled')
          }
        }
      }
    }

    const rangeOutputArr = [...this.holder.querySelectorAll('.custom-range__output')]
    for (const input of rangeOutputArr) {
      const parent = input.closest('[data-loan-evt="dual_select"]')
      if (parent) {
        const rangeInput = parent.querySelector('input[type="range"]')
        if (rangeInput) {
          const maxValue = rangeInput.max
          const minValue = rangeInput.min

          input.addEventListener('input', (e) => {
            e.target.value = e.target.value.replace(/[^0-9]/g, '')
          })

          input.addEventListener('blur', (e) => {
            e.target.value = Math.max(Math.min(e.target.value, maxValue), minValue)
            rangeInput.value = e.target.value
            rangeInput.dispatchEvent(new Event('input'))
          })
        }
      }
    }
  }
  bindFormatting() {
    const currencyArr = document.querySelectorAll('[data-format="currency"]')
    for (const input of currencyArr) {
      input.addEventListener('blur', () => {
        const val = input.value
        if (val.length) {
          input.value = formatAsCurrency(val)
        }
      })
    }
  }

  /**
   * Initial
   */
  setInitialVar() {
    this.steps = this.sections.length
    if (!this.steps) throw new Error('No Loan Sections Found')
    this.currentStep = 0
    this.stepsLeft = this.steps
    this.endReached = false
    this.atTheStart = true
  }
  setInitialLayout() {
    const firstSection = this.sections[0]
    const height = firstSection.scrollHeight
    this.content.style.height = `${height}px`
    this.content.style.transition = `all ${this.settings.scrollSpeed}ms ${this.settings.easing}`
    this.scroller.style.transition = `all ${this.settings.scrollSpeed}ms ${this.settings.easing}`
    // this.sections.forEach(section => section.style.display = 'flex')
  }
  init() {
    this.setInitialLayout()
    this.setInitialVar()
    this.bindStepEvt()
    this.bindInputEvents()
    this.bindNumberInput()
    this.bindSSNInput()
    this.bindResumeUpload()
    this.bindDualSelect()
    this.bindFormatting()
  }
}

module.exports = JobApp
},{}],37:[function(require,module,exports){
class LoanApp {
  constructor(holder, settings = {}) {
    this.holder = holder
    this.filesHolder = this.holder.querySelector('#loan_files_upload')
    this.sections = [...this.holder.querySelectorAll('[data-loan-section]')]
    this.content = this.holder.querySelector('.loan-case__content')
    this.scroller = this.holder.querySelector('.loan-scroller')
    this.footer = this.holder.querySelector('.loan-case__footer')
    this.btnGroup = this.holder.querySelector('.loan-case__btn-group')
    this.evtGo = [...this.holder.querySelectorAll('[data-loan-evt="go"]')]
    this.evtToggle = [...this.holder.querySelectorAll('[data-loan-evt="toggle"]')]
    this.evtSubmit = [...this.holder.querySelectorAll('[data-loan-evt="submit"]')]
    this.evtBack = [...this.holder.querySelectorAll('[data-loan-evt="back"]')]
    this.bar = this.holder.querySelector('.loan-bar')
    this.bar_progress = this.holder.querySelector('.loan-bar__progress')
    this.flow = this.holder.querySelector('.loan-flow')
    this.finish = this.holder.querySelector('.loan-finish')
    this.maxSteps = undefined
    this.currentStep = undefined
    this.stepsLeft = undefined
    this.endReached = undefined
    this.atStart = undefined
    this.sliding = false
    this.data = {}
    this.settings = {
      scrollSpeed: settings.scrollSpeed || 600,
      easing: settings.easing || 'cubic-bezier(.39, .575, .565, 1)',
    }
    if (this.holder) {
      this.init()
    }
  }

  /**
   * Utils
   */
  get getLeftSteps() {
    return this.steps - this.currentStep
  }
  get getActiveSection() {
    return this.sections[this.currentStep]
  }
  get getActiveInput() {
    const section = this.getActiveSection
    if (section && section.contains(document.activeElement)) {
      if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') {
        return document.activeElement
      }
    } else {
      return undefined
    }
  }
  get getLoaderHTML() {
    return `
                            <div>
                                <div>
                                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewBox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
                                        <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"></path>
                                        <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0C22.32,8.481,24.301,9.057,26.013,10.047z"></path>
                                        <animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatCount="indefinite"></animateTransform>
                                    </svg>
                                </div>
                            </div>
    `
  }
  createElem(tagName, options) {
    const { className, id, innerHTML, style, attributes, toAppend } = options
    const elem = document.createElement(tagName)
    if (className) elem.className = className;
    if (id) elem.id = id;
    if (innerHTML) elem.innerHTML = innerHTML;
    if (style) {
      for (const key in options.style) { elem.style[key] = options.style[key] }
    }
    if (attributes) {
      for (const key in options.attributes) { elem.setAttribute(key, options.attributes[key]) }
    }
    if (toAppend) {
      for (const child of toArray(toAppend)) { elem.appendChild(child) }
    }
    return elem
  }
  toArray(target) {
    return Array.isArray(target) ? target : [target]
  }
  loadingOn(timeToRemove) {
    if (this.holder.querySelector('.loan-case-loader')) return
    const loader = createElem('div', {
      className: 'loan-case-loader',
      innerHTML: this.getLoaderHTML
    })
    this.holder.appendChild(loader)
    setTimeout(() => {
      this.holder.classList.add(__LOCKED)
      if (timeToRemove) {
        setTimeout(() => {
          this.holder.classList.remove(__LOCKED)
          setTimeout(() => {
            loader.remove()
          }, 350);
        }, timeToRemove);
      }
    }, 1);
  }
  loadingOff() {
    this.holder.classList.remove(__LOCKED)
    const loader = this.holder.querySelector('.loan-case-loader')
    if (loader) {
      setTimeout(() => {
        loader.remove()
      }, 350);
    }
  }
  showInputError(input, text) {
    const err = document.querySelector('.loan-input-error') ? document.querySelector('.loan-input-error') : createElem('div', {
      className: 'loan-input-error',
      innerHTML: text
    })
    input.classList.add(__INVALID)
    this.footer.prepend(err)
  }
  clearErrors() {
    const activeSection = this.getActiveSection
    const inputs = [...activeSection.querySelectorAll('input'), ...activeSection.querySelectorAll('select')]
    inputs.forEach(input => input.classList.remove(__INVALID))
    const err = this.holder.querySelector('.loan-input-error')
    if (err) err.remove()
  }
  observeBar() {
    const prevSections = this.sections.slice(0, this.currentStep).length
    const progress = (prevSections + 1) / this.steps * 100
    this.bar_progress.style.width = `${progress}%`
  }
  clearAllFields() {
    const inputs = [...this.holder.querySelectorAll('input:not([type="checkbox"])')]
    const selects = [...this.holder.querySelectorAll('select')]
    const checkboxes = [...this.holder.querySelectorAll('input[type="checkbox"]')]
    const fullArr = [...inputs, ...selects, ...checkboxes]

    inputs.forEach(input => input.value = '')
    selects.forEach(select => select.selectedIndex = 0)
    checkboxes.forEach((checkbox) => { checkbox.checked = false })
    fullArr.forEach(elem => elem.dispatchEvent(new Event('change')))
  }

  /**
   * Main
   */
  save() {
    $('#loan_form').submit();
  }
  finishMessage() {
    this.loadingOn(1000)
    setTimeout(() => {
      this.flow.style.opacity = 0
      let currentHeight = this.holder.offsetHeight
      this.holder.style.height = `${currentHeight}px`
      setTimeout(() => {
        this.finish.style.display = 'block'
        let scrollH = this.finish.scrollHeight
        this.holder.style.height = `${scrollH}px`
        setTimeout(() => {
          this.finish.style.opacity = 1
          window.scrollTo(0, 0)
          const confetti = new PageConfetti()
          confetti.push(false)
        }, 10);
      }, getTransitionTime(this.flow) + 10)
    }, 800);
  }
  slide(section) {
    section.style.display = 'flex'
    const height = section.scrollHeight
    const pxToTransform = this.sections.slice(0, this.currentStep).reduce((acc, el) => acc + el.scrollHeight, 0)
    this.content.style.height = `${height}px`
    this.scroller.style.transform = `translateY(-${pxToTransform}px)`
    this.sections.forEach(e => e.classList.remove(IS_ACTIVE))
    section.classList.add(IS_ACTIVE)
    setTimeout(() => {
      this.sliding = false
    }, getTransitionTime(this.scroller));
  }
  go(toStep) {
    if (this.holder.classList.contains(__LOCKED)) return
    const inputs = [...this.holder.querySelectorAll('input'), ...this.holder.querySelectorAll('select')]
    const step = toStep || this.currentStep || 0
    const nextStep = step + 1
    const nextSection = this.sections[nextStep]

    if (!this.sections[nextStep + 1]) {
      this.evtGo.forEach((btn) => {
        btn.innerHTML = 'Submit'
      })
    }

    if (nextSection) {
      this.sliding = true
      inputs.forEach(input => input.blur())
      this.loadingOn()
      setTimeout(() => {
        this.currentStep = nextStep
        this.slide(nextSection)
        this.loadingOff()
        this.observeBar()
      }, 600);
    } else {
      this.save()
      this.finishMessage()
    }
  }
  back(toStep) {
    if (this.holder.classList.contains(__LOCKED)) return
    this.clearErrors()
    const step = toStep || this.currentStep || 0
    const prevStep = step - 1
    const prevSection = this.sections[prevStep]
    if (prevSection) {
      this.evtGo.forEach((btn) => {
        btn.innerHTML = 'Next'
      })
      this.currentStep = prevStep
      this.slide(prevSection)
    }
  }
  validate(section) {
    const requiredTextInputs = [...section.querySelectorAll('input[type="text"][required]:not(.--disabled'), ...section.querySelectorAll('input[type="email"][required]')]
    const emptyInputs = requiredTextInputs.filter(input => !input.value)
    const numberInputs = section.querySelectorAll('input[data-validate="number"]')
    const selectInputs = section.querySelectorAll('select[required]')
    const emailInputs = section.querySelectorAll('input[data-validate="email"]')
    const zipInputs = section.querySelectorAll('input[data-validate="zip_code"]')
    const sectionID = section.dataset.loanSection

    if (requiredTextInputs.some(input => input.classList.contains(__INVALID))) return false
    if (numberInputs.length) {
      const value = numberInputs[0].value
      const regex = /^\+\d{1}\s\(\d{3}\)\s\d{3}\-\d{4}$/
      if (!regex.test(value)) {
        this.showInputError(numberInputs[0], 'Please enter a valid phone number')
        return false
      }
    }
    if (emailInputs.length) {
      const value = emailInputs[0].value
      const regex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/
      if (!regex.test(value)) {
        this.showInputError(emailInputs[0], 'Please enter a valid email')
        return false
      }
    }
    if (zipInputs.length) {
      const value = zipInputs[0].value
      const regex = /^\d{5}$/
      if (!regex.test(value)) {
        this.showInputError(zipInputs[0], 'Please enter a valid zip code')
        return false
      }
    }
    if (emptyInputs.length) {
      this.showInputError(emptyInputs[0], 'This field is required')
      return false
    }
    if (selectInputs.length) {
      for (const select of selectInputs) {
        if (!select.value) {
          this.showInputError(select, 'Please select an option')
          return false
        }
      }
    }
    return true
  }
  adjustActiveSectionHeight() {
    const activeSection = this.getActiveSection
    if (activeSection) {
      const height = activeSection.scrollHeight
      this.content.style.height = `${height}px`
    }
  }
  toggle() {
    const body = document.querySelector('body')
    const headerNav = document.querySelector('.header__sub-nav')
    const welcome = document.querySelector('.subpage__welcome')
    const footerMain = document.querySelector('.footer__wrapper > .wrapper')
    const loanWelcome = document.querySelector('.loan-welcome')
    const heading = document.querySelector('.loan-case__heading')
    const backGroup = document.querySelector('.loan-case__back-group')
    const CASE_CLASS = 'loan_case'
    const elements = [headerNav, welcome, footerMain, loanWelcome]

    const hideElement = (el) => {
      const curHeight = el.scrollHeight
      el.style.height = `${curHeight}px`
      setTimeout(() => {
        el.style.overflow = 'hidden'
        el.style.height = '0px'
      }, 1);
    }
    const showElement = (el) => {
      const curHeight = window.getComputedStyle(el).getPropertyValue('height')
      const scrollHeight = el.scrollHeight
      el.style.height = `${curHeight}`
      setTimeout(() => {
        el.style.overflow = 'visible'
        el.style.height = `${scrollHeight}px`
      }, 1)
    }

    const hideLoan = () => {
      body.classList.remove(CASE_CLASS)
      for (const element of elements) {
        if (element) showElement(element)
      }

      this.scroller.style.display = 'none'
      this.content.style.height = `0px`

      if (backGroup) {
        backGroup.style.height = `0px`
      }

      if (heading) {
        heading.innerHTML = 'Welcome To the Icebox Max Approval Financing Form'
        heading.classList.remove('--big')
      }

      this.clearErrors()
      this.back(1)
      this.clearAllFields()
    }
    const showLoan = () => {
      body.classList.add('loan_case')
      for (const element of elements) {
        if (element) hideElement(element)
      }

      this.scroller.style.display = 'flex'
      this.content.style.height = `${this.sections[0].scrollHeight}px`

      if (backGroup) {
        backGroup.style.height = `${backGroup.scrollHeight}px`
      }

      if (heading) {
        heading.innerHTML = 'Financing Application'
        heading.classList.add('--big')
      }
    }

    if (body.classList.contains(CASE_CLASS)) {
      const askModal = new AskModal({
        heading: 'Are You Sure You Want To Exit Financing App?',
        subheading: 'You will lose all the progress. Keep filling out the form and get approved as soon as possible!',
        exitText: 'Exit',
        keepText: 'Keep Filling',
        exitCallback: hideLoan,
      })
      askModal.show()
    } else {
      showLoan()
    }
  }
  tabPress() {
    if (!this.sliding) {
      const activeInput = this.getActiveInput
      if (!activeInput) {
        const section = this.getActiveSection
        const inputArray = [...section.querySelectorAll('input:not(.--disabled), select:not(.--disabled)')]
        if (inputArray.length) {
          let inputToFocus
          const invalidInputs = inputArray.filter(input => input.classList.contains('--invalid'))
          if (invalidInputs.length) {
            inputToFocus = invalidInputs[0]
          } else {
            const emptyInputs = inputArray.filter(input => !input.value && input.value !== 0)
            if (emptyInputs.length) {
              inputToFocus = emptyInputs[0]
            } else {
              inputToFocus = inputArray[0]
            }
          }
          inputToFocus.focus()
        }
      } else {
        const activeInputWrap = activeInput.parentNode.closest('.loan-input-wrap')
        const nextInputWrap = activeInputWrap.nextElementSibling
        if (nextInputWrap) {
          const nextInput = nextInputWrap.querySelector('input, select')
          if (nextInput) {
            nextInput.focus()
          }
        } else {
          const firstInputWrap = this.getActiveSection.querySelector('.loan-input-wrap')
          const firstInput = firstInputWrap.querySelector('input, select')
          if (firstInput) {
            firstInput.focus()
          }
        }
      }
    }
  }

  /**
   * Bind Events
   */
  bindStepEvt() {
    this.evtGo.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        const section = this.getActiveSection
        if (this.validate(section)) this.go()
      })
    })
    this.evtBack.forEach((btn) => {
      btn.addEventListener('click', () => {
        this.back()
      })
    })
    this.evtSubmit.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        this.evtGo[0].click()
      })
    })
    this.evtToggle.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        this.toggle()
      })
    })

  }
  bindInputEvents() {
    const inputs = [...this.holder.querySelectorAll('input')]
    const selects = [...this.holder.querySelectorAll('select')]
    const noWebsiteCheckbox = this.holder.querySelector('#loan_employer_website')
    const inputWebsiteEmployer = this.holder.querySelector('#loan_employer_website')

    document.addEventListener('keydown', (e) => {
      const isTab = e.key === 'Tab'
      if (isTab) {
        if (document.body.classList.contains('loan_case')) {
          e.preventDefault()
          this.tabPress()
        }
      }
    })

    inputs.forEach((input) => {
      input.addEventListener('focus', () => {
        this.clearErrors()
        const parent = input.parentNode.closest('.loan-input-wrap')
        if (parent) {
          parent.classList.add('--focused')
        }
      })
      input.addEventListener('blur', () => {
        const parent = input.parentNode.closest('.loan-input-wrap')
        if (parent) {
          parent.classList.remove('--focused')
        }
      })
      input.addEventListener('keydown', (e) => {
        this.clearErrors()
        const isEnter = e.key === 'Enter'
        const isTab = e.key === 'Tab'
        if (isEnter) {
          this.evtGo[0].click()
        }
      })
    })
    selects.forEach((select) => {
      select.addEventListener('change', () => {
        this.clearErrors()
      })
    })
  }
  bindSSNInput() {
    const inputs = this.holder.querySelectorAll('input[data-format="ssn"]')
    for (const input of inputs) {
      input.addEventListener('input', (e) => {
        const value = e.target.value
        let newValue = ''
        for (let i = 0; i < value.length; i++) {
          const char = value.charAt(i)
          if (char.match(/^[0-9]$/) && newValue.length < 9) {
            newValue += char
          }
        }
        e.target.value = newValue
      })
      input.addEventListener('blur', (e) => {
        const value = e.target.value
        if (value) {
          let newValue = value.replace(/([^0-9])/g, '')
          newValue = newValue.slice(0, 3) + '—' + newValue.slice(3, 5) + '—' + newValue.slice(5)
          e.target.value = newValue
        }
      })
      input.addEventListener('focus', (e) => {
        e.target.value = e.target.value.replace(/([^0-9])/g, '')
      })
    }
  }
  bindNumberInput() {
    const inputs = this.holder.querySelectorAll('input[data-validate="number"]')
    for (const input of inputs) {
      let keyCode;
      function mask(event) {
        event.keyCode && (keyCode = event.keyCode);
        let pos = this.selectionStart;
        if (pos < 3) event.preventDefault()
        let matrix = "+1 (___) ___-____",
          i = 0,
          def = matrix.replace(/\D/g, ""),
          val = this.value.replace(/\D/g, ""),
          newValue = matrix.replace(/[_\d]/g, function (a) {
            return i < val.length ? val.charAt(i++) || def.charAt(i) : a;
          });
        i = newValue.indexOf("_");
        if (i != -1) {
          i < 5 && (i = 3);
          newValue = newValue.slice(0, i);
        }
        let reg = matrix.substr(0, this.value.length).replace(/_+/g,
          function (a) {
            return "\\d{1," + a.length + "}";
          }).replace(/[+()]/g, "\\$&");
        reg = new RegExp("^" + reg + "$");
        if (!reg.test(this.value) || this.value.length < 5 || keyCode > 47 && keyCode < 58) this.value = newValue;
        if (event.type == "blur" && this.value.length < 5) this.value = "";
      }

      input.addEventListener("input", mask, false);
      input.addEventListener("focus", mask, false);
      input.addEventListener("blur", mask, false);
      input.addEventListener("keydown", mask, false);
      input.addEventListener('mouseup', event => {
        event.preventDefault()
        if (input.value.length < 4) {
          input.setSelectionRange(4, 4)
        } else {
          input.setSelectionRange(input.value.length, input.value.length)
        }
      })
    }
  }
  bindIDUpload() {
    const input = document.querySelector('#loan_id')
    const box = document.querySelector('[data-loan="files_upload"]')
    const holder = this.filesHolder
    // if (!input || !box || !holder) throw new Error('JS : Bind ID Upload : Input or Box or Holder not found')

    if (input && box && holder) {
      function processFiles(files) {
        if (!files) throw new Error('No files selected')
        files = [...files]
        if (!files.length) return
        for (const file of files) {
          if (!file.type.match('image.*')) continue
          const images = holder.querySelectorAll('img')
          for (const image of images) {
            image.remove()
          }
          let reader = new FileReader()
          reader.onload = (e) => {
            appendImage(e.target.result)
          }
          reader.readAsDataURL(file)
        }
      }

      function appendImage(imgURL) {
        const img = createElem('img', {
          style: {
            'background-image': `url(${imgURL})`
          },
        })
        holder.append(img)
      }

      box.onclick = () => { input.click() }
      input.onchange = (e) => {
        processFiles(e.target.files)
        // input.value = ''
        setTimeout(() => {
          this.adjustActiveSectionHeight()
        }, 10);
      }
      box.ondragover = (e) => {
        e.preventDefault()
        box.classList.add(IS_ACTIVE)
      }
      box.ondragleave = (e) => {
        e.preventDefault()
        box.classList.remove(IS_ACTIVE)
      }
      box.ondrop = (e) => {
        e.preventDefault()
        box.classList.remove(IS_ACTIVE)
        processFiles(e.dataTransfer.files)
      }
    }
  }
  bindDualSelect() {
    const dualArr = this.holder.querySelectorAll('[data-loan-evt="dual_select"]')
    for (const dual of dualArr) {
      const input = dual.querySelector('input:not([type="checkbox"])')
      const checkbox = dual.querySelector('input[type="checkbox"]')
      if (input && checkbox) {
        checkbox.onchange = () => {
          let isChecked = checkbox.checked
          if (isChecked) {
            input.classList.add('--disabled')
            input.setAttribute('disabled', 'disabled')
            if (input.type !== 'range') {
              input.value = ''
            }
          } else {
            input.removeAttribute('disabled')
            input.classList.remove('--disabled')
          }
        }
      }
    }

    const rangeOutputArr = [...this.holder.querySelectorAll('.custom-range__output')]
    for (const input of rangeOutputArr) {
      const parent = input.closest('[data-loan-evt="dual_select"]')
      if (parent) {
        const rangeInput = parent.querySelector('input[type="range"]')
        if (rangeInput) {
          const maxValue = rangeInput.max
          const minValue = rangeInput.min

          input.addEventListener('input', (e) => {
            e.target.value = e.target.value.replace(/[^0-9]/g, '')
          })

          input.addEventListener('blur', (e) => {
            e.target.value = Math.max(Math.min(e.target.value, maxValue), minValue)
            rangeInput.value = e.target.value
            rangeInput.dispatchEvent(new Event('input'))
          })
        }
      }
    }
  }
  bindFormatting() {
    const currencyArr = document.querySelectorAll('[data-format="currency"]')
    for (const input of currencyArr) {
      input.addEventListener('blur', () => {
        const val = input.value
        if (val.length) {
          input.value = formatAsCurrency(val)
        }
      })
    }
  }

  /**
   * Initial
   */
  setInitialVar() {
    this.steps = this.sections.length
    if (!this.steps) throw new Error('No Loan Sections Found')
    this.currentStep = 0
    this.stepsLeft = this.steps
    this.endReached = false
    this.atTheStart = true
  }
  setInitialLayout() {
    const firstSection = this.sections[0]
    const height = firstSection.scrollHeight
    this.content.style.height = `${height}px`
    this.content.style.transition = `all ${this.settings.scrollSpeed}ms ${this.settings.easing}`
    this.scroller.style.transition = `all ${this.settings.scrollSpeed}ms ${this.settings.easing}`
    // this.sections.forEach(section => section.style.display = 'flex')
  }
  init() {
    this.setInitialLayout()
    this.setInitialVar()
    this.bindStepEvt()
    this.bindInputEvents()
    this.bindNumberInput()
    this.bindSSNInput()
    this.bindIDUpload()
    this.bindDualSelect()
    this.bindFormatting()
  }
}

module.exports = LoanApp
},{}],38:[function(require,module,exports){
const locationPage = new Object({
  init: function () {
    Object.values(this.attachEvents).forEach((fn) => {
      if (fn !== undefined && typeof fn == 'function') fn();
    })
  },
  attachEvents: {
    toggleStoresVisibility: function () {
      let headArr = [...$('.store-row__head')]
      $.each(headArr, function (i) {
        $(headArr[i]).click(function () {
          let rows = $('.store-row'),
            thisRow = $(this).closest(rows)
          if (elemDisplayed(thisRow.find('.store-row__body'))) {
            return false
          } else {
            rows.find('.store-row__body').show()
            rows.not(thisRow).find('.store-row__body').hide()
          }
        })
      })
    }
  }
})

module.exports = locationPage
},{}],39:[function(require,module,exports){
class LooseDiamonds {
  constructor() {
    this.main = document.querySelector('.loose_diamonds')
    this.resultsContainer = document.querySelector('.loose__results')
    this.viewBtnArr = [...document.querySelectorAll('.loose__view-btn')]
    this.looseSelectArr = [...document.querySelectorAll('.loose-select')]
    this.dmBtnArr = [...document.querySelectorAll('.dm-filter-btn')]
    this.sortModalActive = false
    if (this.main) {
      this.init()
    }
  }

  // Methods
  listView() {
    this.main.classList.add('--list')
  }
  gridView() {
    this.main.classList.remove('--list')
  }
  observeFilters() {
    for (const select of this.looseSelectArr) {
      const btnArr = [...select.querySelectorAll('.loose-filter-btn')]
      const inputArr = [...select.querySelectorAll('input[type="text"]')]

      const someIsChecked = btnArr.some(el => el.classList.contains(__ACTIVE))
      const someIsValue = inputArr.some(el => el.value.length > 0)

      if (someIsChecked || someIsValue) {
        select.classList.add(__SELECTED)
      } else {
        select.classList.remove(__SELECTED)
      }
    }
  }
  resetFilters() {
    for (const select of this.looseSelectArr) {
      const btnArr = [...select.querySelectorAll('.loose-filter-btn')]
      const inputArr = [...select.querySelectorAll('input[type="text"]')]

      btnArr.forEach(el => el.classList.remove(__ACTIVE))
      inputArr.forEach(el => el.value = '')

      select.classList.remove(__SELECTED)
    }
  }
  openSortModal() {
    const sortModal = document.querySelector('.sort-modal')
    const closeCallback = () => { this.closeSortModal(true) }
    if (sortModal) {
      window.looseSortBackdrop = new Backdrop({
        half: true,
        callback: closeCallback
      })
      lockScroll()
      sortModal.style.display = 'block'
      setTimeout(() => {
        sortModal.classList.add(__ACTIVE)
      }, 5);
    }
  }
  closeSortModal(cond = false) {
    const sortModal = document.querySelector('.sort-modal')
    if (sortModal) {
      unlockScroll()
      sortModal.classList.remove(__ACTIVE)
      setTimeout(() => {
        sortModal.style.display = 'none'
      }, getTransitionTime(sortModal));
      if (!cond) {
        const backdrop = window.looseSortBackdrop
        if (backdrop) {
          backdrop.hide()
        }
      }

      const rowArr = [...document.querySelectorAll('.sort-modal-row')]
      for (const row of rowArr) {
        row.querySelector('.sort-modal-row__body').style.height = 0
      }
    }
  }
  applyFilters() {
    this.closeSortModal()
  }
  hideAdmin(target) {
    if (target) {
      const item = target.closest('.dm-item')
      const adminBar = item.querySelector('.dm-item__admin')
      if (adminBar) {
        adminBar.style.display = 'none'
      }
    }
  }

  // Bind Events
  bindLooseSelects() {
    for (const select of this.looseSelectArr) {
      const btn = select.querySelector('.loose-select__btn')
      const drop = select.querySelector('.loose-select__drop')
      if (btn && drop) {
        btn.addEventListener('click', () => {
          if (select.classList.contains(__ACTIVE)) {
            select.classList.remove(__ACTIVE)
          } else {
            this.looseSelectArr.forEach(el => el.classList.remove(__ACTIVE))
            select.classList.add(__ACTIVE)
          }
        })
      }
    }

    window.addEventListener('scroll', () => {
      if (this.looseSelectArr.some(el => el.classList.contains(__ACTIVE))) {
        this.looseSelectArr.forEach(el => el.classList.remove(__ACTIVE))
      }
    })

    document.addEventListener('click', (e) => {
      const target = e.target
      if (!target.closest('.loose-select')) {
        this.looseSelectArr.forEach(el => el.classList.remove(__ACTIVE))
      }
    })
  }
  bindFilterBtnGroup() {
    const groupArr = [...document.querySelectorAll('[data-filter-group]')]
    for (const group of groupArr) {
      const btnArr = [...group.querySelectorAll('.loose-filter-btn')]
      for (const btn of btnArr) {
        btn.addEventListener('click', () => {
          btn.classList.toggle(__ACTIVE)
          this.observeFilters()
        })
      }
    }

    for (const select of this.looseSelectArr) {
      const inputArr = [...select.querySelectorAll('input[type="text"]')]
      for (const input of inputArr) {
        input.addEventListener('input', () => {
          this.observeFilters()
        })
      }
    }
  }
  bindDmSelectClick() {
    const fade = (except = undefined) => {
      this.dmBtnArr.forEach(el => {
        if (el !== except && !el.classList.contains(__ACTIVE)) {
          el.classList.add(__FADE)
        }
      })
    }

    const reset = () => {
      this.dmBtnArr.forEach(el => {
        el.classList.remove(__ACTIVE)
        el.classList.remove(__FADE)
      })
    }

    for (const btn of this.dmBtnArr) {
      btn.addEventListener('click', () => {
        const someFaded = this.dmBtnArr.some(el => el.classList.contains(__FADE))
        const targetActive = btn.classList.contains(__ACTIVE)
        const targetFaded = btn.classList.contains(__FADE)
        const target = btn

        if (targetActive) {
          target.classList.remove(__ACTIVE)
          if (this.dmBtnArr.some(el => el.classList.contains(__ACTIVE))) {
            target.classList.add(__FADE)
          } else {
            reset()
          }
        } else {
          target.classList.add(__ACTIVE)
          target.classList.remove(__FADE)
          fade(target)
        }

      })
    }
  }
  bindSortModalEvents() {
    const modal = document.querySelector('.sort-modal')
    if (modal) {
      const rowArr = [...modal.querySelectorAll('.sort-modal-row')]
      for (const row of rowArr) {
        const head = row.querySelector('.sort-modal-row__head')
        const body = row.querySelector('.sort-modal-row__body')

        if (head && body) {
          head.addEventListener('click', () => {
            if (body.clientHeight > 0) {
              row.classList.remove(__ACTIVE)
              body.style.height = 0
            } else {
              rowArr.forEach((r) => {
                if (r !== row) {
                  r.classList.remove(__ACTIVE)
                  r.querySelector('.sort-modal-row__body').style.height = 0
                }
              })
              row.classList.add(__ACTIVE)
              const content = body.querySelector('.sort-modal-row__content')
              body.style.height = `${content.scrollHeight + 1}px`
            }
          })
        }
      }
    }
  }

  init() {
    this.bindLooseSelects()
    this.bindFilterBtnGroup()
    this.bindDmSelectClick()
    this.observeFilters()
    this.bindSortModalEvents()
  }
}

module.exports = LooseDiamonds
},{}],40:[function(require,module,exports){
const myBag = new Object({
  init: function () {
    Object.values(this.attachEvents).forEach((fn) => {
      if (fn !== undefined && typeof fn == 'function') fn();
    })
  },
  attachEvents: {
    formatSummaryPrice: function () {
      const lines = [...document.querySelectorAll('.summary-price')]
      for (const line of lines) {
        const span = line.querySelector('span:last-child')
        if (span) {
          const text = span.innerText
          let num = Number(text.replace(/[^0-9.-]/g, ''))
          if (num !== 0) {
            num = num.toFixed(2)
            num = num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            span.innerText = `$ ${num}`
          }
        }
      }
    },
    setSalePercentValues: function () {
      const cards = [...document.querySelectorAll('.mybag-card')]
      for (const card of cards) {
        const newPrice = card.querySelector('.card-price_new')
        const oldPrice = card.querySelector('.card-price_old')
        const saleElem = card.querySelector('.mybag-card-sale')
        if (newPrice && oldPrice && saleElem) {
          const newPriceNum = Number(newPrice.innerText.replace(/[^0-9]/g, ''))
          const oldPriceNum = Number(oldPrice.innerText.replace(/[^0-9]/g, ''))
          let sale = ((oldPriceNum - newPriceNum) / oldPriceNum) * 100
          sale = Math.round(sale / 10) * 10;
          if (sale % 10 >= 5) {
            sale = Math.ceil(sale / 10) * 10;
          } else {
            sale = Math.floor(sale / 10) * 10;
          }
          saleElem.innerText = `${sale}% OFF`
        }
      }
    },
    setCapitalizeCheckoutBtn: function () {
      const btnArr = [...document.querySelectorAll('.checkout__main-btn')]
      for (const btn of btnArr) {
        const text = btn.innerText.split(' ').reduce((acc, el) => {
          acc.push(el.charAt(0).toUpperCase() + el.slice(1).toLowerCase())
          return acc
        }, [])
        btn.innerText = text.join(' ')
      }
    }

  }
})

module.exports = myBag
},{}],41:[function(require,module,exports){
const passReset = {
  IS_EMPTY: 'is-empty',
  IS_DISABLED: 'is-disabled',
  init: function () {
    if ($('.pass-reset-page').length) {
      this.renderDOM()
      this.bindEvents()
    }
  },
  renderDOM: function () {
    this.form = $('#passResetForm')
    this.submitBtn = $('#passResetSubmit')
    this.inputArr = [...this.form.find('input[type="password"]')]
    this.error = $('.pass-reset-error')
    this.loader = $('.pass-reset-loader')
    this.main = $('.pass-reset__main')
    this.result = $('.pass-reset__result')
  },
  bindEvents: function () {
    // submit click
    $.each(this.submitBtn, function (i) {
      passReset.submitBtn[i].onclick = (e) => {
        e.preventDefault()
        passReset.form.submit()
      }
    })
    // input events
    $.each(this.inputArr, function (i) {
      passReset.inputArr[i].oninput = () => {
        let arr = passReset.inputArr
        let pass1 = arr[0].value, pass2 = arr[1].value
        if (pass2.length == 0) {
          passReset.hideError()
        } else {
          if (pass1.length !== pass2.length) { passReset.showError('Different password length') }
          else {
            passReset.hideError(); if (pass1 === pass2) { passReset.successError() }
            else { passReset.showError("Passwords don't match") }
          }
        }
      }
    })
    // form submit
    this.form[0].onsubmit = (e) => {
      e.preventDefault()
      if (passReset.formValid()) {
        Object.assign(passReset.submitBtn[0].style, { color: 'transparent', height: '14px', 'border-radius': '50px' })
        passReset.form.addClass(passReset.IS_DISABLED)
        passReset.hideError()
        passReset.loader[0].animate({ width: '100%' }, { duration: 3000, fill: 'forwards' }).onfinish = () => {
          const formData = new FormData(e.target), obj = {}
          formData.forEach((value, key) => (obj[key] = value))
          Object.assign(passReset.main[0].style, { opacity: 0 }); Object.assign(passReset.result[0].style, { opacity: 0 })
          setTimeout(() => {
            passReset.main.hide()
            passReset.result.show()
            setTimeout(() => {
              Object.assign(passReset.result[0].style, { opacity: 1 })
            }, 5);
          }, 401);
          // alert(JSON.stringify(obj))
        }
      }
    }
  },
  formValid: function () {
    let arr = passReset.inputArr
    arr.forEach(el => el.classList.remove(passReset.IS_EMPTY))

    if (arr.length !== 0) {
      let emptyInput = arr.filter(el => el.value.length == 0)

      if (emptyInput.length !== 0) {
        $.each(emptyInput, function (i) {
          emptyInput[i].classList.add(passReset.IS_EMPTY)
          setTimeout(() => {
            emptyInput[i].classList.remove(passReset.IS_EMPTY)
          }, 400);
        })
      } else {
        let pass1 = arr[0].value, pass2 = arr[1].value
        if (pass1 === pass2) {
          return true
        } else {
          return false
        }
      }

    }
  },
  showError: function (text = 'Something went wrong...') {
    this.error.html(text)
    Object.assign(this.error[0].style, { color: '#c02942', opacity: 1, transform: 'translateX(-50%) translateY(0px)' })
  },
  hideError: function () {
    Object.assign(this.error[0].style, { color: '#c02942', opacity: 0, transform: 'translateX(-50%) translateY(14px)' })
  },
  successError: function (text = 'Passwords match!') {
    this.error.html(text)
    Object.assign(this.error[0].style, { color: '#088d7b', opacity: 1, transform: 'translateX(-50%) translateY(0px)' })
  }
}

module.exports = passReset
},{}],42:[function(require,module,exports){
class ProductPage {
  constructor() {
    this.optionsArr = [...document.querySelectorAll('.product__item-option:not(.--static)')]
    this.optionsRow = document.querySelector('.side-row__options')
    this.colorPickArr = [...document.querySelectorAll('.color-pick')]
    this.toggleRowArr = [...document.querySelectorAll('.toggle-row')]
    this.description = document.querySelector('#product_description')
    this.galleryDesktopArr = [...document.querySelector('#gallery_desktop').querySelectorAll('.product__gallery')]
    this.galleryMobileArr = [...document.querySelector('#gallery_mobile').querySelectorAll('.product__gallery')]

    this.optionModal = document.querySelector('.option-modal')
    this.optionModalContent = document.querySelector('.option-modal__content')
    this.optionModalNextElem = document.querySelector('[data-option-modal-next]')
    this.optionModalName = document.querySelector('[data-option-modal-name]')
    this.evtNextOption = document.querySelector('[data-evt="optionModalNext"]')
    this.evtCloseOptionModalArr = document.querySelectorAll('[data-evt="optionModalClose"]')
    this.favBtn = document.querySelector('.product__add-fav')
    this.activeOptionIndex = undefined

    this.fixedBar = document.querySelector('.fixed-bar')
    this.fixedBarTrigger = document.querySelector('.side-row__payments')
    this.init()
  }

  // Gallery
  setupDesktopGallery() {
    for (const gallery of this.galleryDesktopArr) {
      const thumbs = [...gallery.querySelector('.product__thumb-gallery').querySelectorAll('.product-media')]
      const media = [...gallery.querySelector('.product__main-gallery').querySelectorAll('.product-media')]

      if (thumbs.length && media.length) {
        thumbs.forEach((thumb, index) => {
          thumb.addEventListener('click', () => {
            media.forEach(el => el.style.display = 'none')
            media[index].style.display = 'block'
          })
        })
      }
    }
  }
  setupMobileGallery() {
    for (const gallery of this.galleryMobileArr) {
      const mainSplide = gallery.querySelector('.product__main-gallery.splide')
      const thumbsSplide = gallery.querySelector('.product__thumb-gallery.splide')

      if (mainSplide && thumbsSplide) {
        const main = new Splide(mainSplide, {
          type: "loop",
          perPage: 1,
          perMove: 1,
          gap: 8,
          arrows: false,
          pagination: false,
          speed: 750,
        })

        const thumbs = new Splide(thumbsSplide, {
          rewind: true,
          pagination: false,
          arrows: false,
          cover: true,
          isNavigation: true,
          fixedWidth: 38,
          gap: 4
        })
        main.sync(thumbs)
        main.mount()
        thumbs.mount()
      }
    }
  }
  setupGallery() {
    if (window.innerWidth > 991) {
      this.setupDesktopGallery()
    } else {
      this.setupMobileGallery()
    }
  }

  // Methods
  setActiveOptionsText() {
    for (const option of this.optionsArr) {
      const holder = option.querySelector('.product-option__head-right')
      const activeBtn = option.querySelector('.option-btn.is-active')

      if (holder && activeBtn) {
        const textContent = activeBtn.textContent.trim()
        if (textContent.length) {
          const selectedElem = createElem('div', {
            className: 'product-option-current',
            innerHTML: textContent
          })

          holder.prepend(selectedElem)
        }
      }
    }
  }
  setActiveColor(color) {
    const currentElem = document.querySelector('[data-current-color]')
    if (currentElem) {
      currentElem.innerHTML = color
    }
  }
  setActiveColorPickElem(elem) {
    this.colorPickArr.forEach((pick) => {
      if (pick === elem) {
        pick.classList.add('--active')
      } else {
        pick.classList.remove('--active')
      }
    })
  }
  setupDescription() {
    if (this.description) {
      const textContent = this.description.textContent

      const extractLastParagraph = () => {
        let elements = this.description.querySelectorAll('p, div, li')
        let holder = document.querySelector('#itemDetails')

        if (holder) {
          for (let element of elements) {
            if (element.textContent.trim().startsWith("These pieces are handcrafted and manufactured by Icebox")) {
              holder.appendChild(element);
              element.classList.add('product__more-typo')
              break
            }
          }
        }
      }
      extractLastParagraph()
    }
  }
  setupSplide() {
    const splideArr = [...document.querySelectorAll('.more-row__splide')]
    for (const el of splideArr) {
      let main = new Splide(el, {
        type: "loop",
        perPage: 4,
        perMove: 1,
        autoplay: 0,
        gap: "8px",
        arrows: 1,
        pagination: 0,
        speed: 750,
        breakpoints: {
          1980: {
            perPage: 5,
            perMove: 1,
          },
          1680: {
            perPage: 4,
            perMove: 1,
          },
          1120: {
            perPage: 4,
            perMove: 1,
          },
          991: {
            perPage: 4,
            perMove: 1,
          },
          767: {
            grid: {
              rows: 2,
              cols: 3,
              gap: { row: "10px", col: "8px" },
            },
          },
          478: {
            grid: {
              rows: 2,
              cols: 2,
              gap: { row: "24px", col: "8px" },
            },
          },
        },
      }).mount(window.splide.Extensions)
    }
  }

  // Option Modal
  revertOptions() {
    const body = this.optionModal.querySelector('.product-option__body')
    const guideBtn = this.optionModal.querySelector('.option-guide-btn')
    const emptyOption = this.optionsArr.find(option => !option.querySelector('.product-option__body'))
    if (body && emptyOption) {
      if (guideBtn) {
        body.append(guideBtn)
      }
      emptyOption.append(body)
    }
  }
  appendOption(option = this.optionsArr[0]) {
    this.revertOptions()
    if (option) {
      const optionName = option.querySelector('.product-option-name')
      const currentIndex = this.optionsArr.indexOf(option)
      this.activeOptionIndex = currentIndex
      const nextOption = this.optionsArr[currentIndex + 1] || this.optionsArr[0]
      const nextOptionName = nextOption.querySelector('.product-option-name')
      const body = option.querySelector('.product-option__body')

      const guideBtn = option.querySelector('.option-guide-btn')
      const modalWrapper = this.optionModal.querySelector('.option-modal__wrapper')

      if (body) {
        this.optionModalName.innerHTML = optionName.textContent
        this.optionModalNextElem.innerHTML = nextOptionName.textContent
        this.optionModalContent.appendChild(body)

        if (guideBtn && modalWrapper) {
          modalWrapper.append(guideBtn)
        }
      }
    }
  }
  bindOptionModalEvents() {
    this.evtNextOption.addEventListener('click', () => {
      this.appendOption(this.optionsArr[this.activeOptionIndex + 1] || this.optionsArr[0])
    })
    this.evtCloseOptionModalArr.forEach((elem) => {
      elem.addEventListener('click', () => {
        this.closeOptionModal()
      })
    })
  }
  bindOptionToggleMobile() {
    for (const option of this.optionsArr) {
      const head = option.querySelector('.product-option__head')
      const body = option.querySelector('.product-option__body')

      if (head && body) {
        head.addEventListener('click', () => {
          this.appendOption(option)
          this.showOptionModal()
        })
      }
    }
  }
  showOptionModal() {
    lockScroll()
    window.optionModalBackdrop = new Backdrop({
      half: true,
      callback: () => { this.closeOptionModal() }
    })
    this.optionModal.style.display = 'block'
    setTimeout(() => {
      this.optionModal.classList.add('--visible')
    }, 3);
  }
  closeOptionModal() {
    unlockScroll()
    this.optionModal.classList.remove('--visible')
    setTimeout(() => {
      this.optionModal.style.display = 'none'
      this.revertOptions()
    }, getTransitionTime(this.optionModal));
    if (window.optionModalBackdrop) {
      window.optionModalBackdrop.hide(true)
    }
  }

  // Methods - Options
  hideAllOptions(exclude = null) {
    this.optionsArr.forEach(option => {
      if (option !== exclude) {
        this.hideOption(option)
      } else {
        this.showOption(option)
      }
    })
    if (exclude == null) {
      this.optionsRow.classList.remove('--active')
    }
  }
  showOption(option) {
    option.classList.add('--active')
  }
  hideOption(option) {
    option.classList.remove('--active')
  }

  // Bind Events
  bindOptionToggleDesktop() {
    for (const option of this.optionsArr) {
      const head = option.querySelector('.product-option__head')
      const btnArr = [...option.querySelectorAll('.option-btn')]
      if (head) {
        head.addEventListener('click', () => {
          if (option.classList.contains('--active')) {
            this.hideOption(option)
            this.optionsRow.classList.remove('--active')
          } else {
            this.hideAllOptions(option)
            this.optionsRow.classList.add('--active')
          }
        })
      }
    }

    document.addEventListener('click', (e) => {
      const target = e.target
      if (!target.closest('.product__item-option')) {
        this.hideAllOptions()
      }
    })
  }
  bindOptionButtonClick() {
    for (const option of this.optionsArr) {
      const btnArr = [...option.querySelectorAll('.option-btn')]
      const selectedElem = option.querySelector('.product-option-current')

      if (btnArr.length) {
        for (const btn of btnArr) {
          btn.addEventListener('click', () => {
            this.hideAllOptions()

            const textContent = btn.textContent.trim()
            if (textContent.length) {
              if (selectedElem) {
                selectedElem.innerHTML = textContent
              }
            }

            btnArr.forEach(el => el.classList.remove(IS_ACTIVE))
            btn.classList.add(IS_ACTIVE)
          })
        }
      }
    }
  }
  bindOptionButtonClickInputValue() {
    const btnArr = [...document.querySelectorAll('.option-btn')]
    for (const btn of btnArr) {
      btn.addEventListener('click', () => {
        const value = btn.dataset.value
        if (!value) throw new Error('data-value attribute is required')
        const input = btn.closest('.product__item-option').querySelector('.custom-fields-fetch')
        if (!input) throw new Error('custom-fields-fetch element is required')
          
        input.value = value
        const event = new Event('change', { bubbles: true })
        input.dispatchEvent(event)
      })
    }
  }
  bindColorPick() {
    this.colorPickArr.forEach((btn) => {
      btn.addEventListener('click', () => {
        const attr = btn.dataset.color
        if (attr) {
          this.setActiveColor(attr)
          this.setActiveColorPickElem(btn)

          if (this.fixedBar) {
            this.fixedBar.classList.remove('--filled')
          }
        }
      })
    })
  }
  bindToggleRow() {
    this.toggleRowArr.forEach((row) => {
      const head = row.querySelector('.toggle-row__head')
      const body = row.querySelector('.toggle-row__body')
      const wrapper = row.querySelector('.toggle-row__wrapper')

      if (head && body && wrapper) {
        head.addEventListener('click', () => {
          const scrollHeight = wrapper.scrollHeight
          const isActive = body.offsetHeight > 0 && row.classList.contains('--active')

          if (isActive) {
            body.style.height = `0px`
            row.classList.remove('--active')
          } else {
            body.style.height = `${scrollHeight}px`
            row.classList.add('--active')
          }
        })
      }
    })
  }
  bindToggleFav() {
    if (this.favBtn) {
      this.favBtn.addEventListener('click', () => {
        this.favBtn.classList.toggle('is-active')
      })
    }
  }

  // Fixed Bar
  positionFixedBar() {
    const header = document.querySelector('header')
    if (header && this.fixedBar && this.fixedBarTrigger) {
      this.fixedBar.style.display = 'block'

      const update = () => {
        if (window.innerWidth > 991) {
          this.fixedBar.style.zIndex = -1
          this.fixedBar.style.position = 'absolute'
          this.fixedBar.style.top = '100%'
          if (!header.contains(this.fixedBar)) {
            header.appendChild(this.fixedBar)
          }
        } else {
          const headerZIndex = window.getComputedStyle(header).getPropertyValue('z-index')
          this.fixedBar.style.zIndex = parseInt(headerZIndex, 10) - 1
          this.fixedBar.style.top = 'auto'
          this.fixedBar.style.position = 'fixed'
          if (!document.body.contains(this.fixedBar)) {
            document.body.appendChild(this.fixedBar)
          }
        }
      }

      window.addEventListener('resize', update)
      update()
    }
  }
  observeFixedBar() {
    const triggerElem = this.fixedBarTrigger
    const bar = this.fixedBar
    let header = document.querySelector('header')

    if (triggerElem && bar) {
      let headerOffset = header ? header.offsetHeight : 0
      let observer = null

      const updateObserver = () => {
        headerOffset = header ? header.offsetHeight : 0

        if (observer) {
          observer.disconnect()
        }

        const observerCallback = (entries) => {
          entries.forEach(entry => {
            if (entry.boundingClientRect.top < headerOffset && !entry.isIntersecting) {
              bar.classList.add(__VISIBLE)
              this.setFixedBarMedia()
            } else {
              bar.classList.remove(__VISIBLE)
            }
          })
        }

        observer = new IntersectionObserver(observerCallback, {
          root: null,
          rootMargin: `-${headerOffset}px 0px 0px 0px`,
          threshold: 0
        })

        observer.observe(triggerElem)
      }

      updateObserver()

      window.addEventListener('resize', updateObserver)
    }
  }
  setFixedBarMedia() {
    if (this.fixedBar) {

      if (!this.fixedBar.querySelector('img')) {
        this.fixedBar.classList.remove('--filled')
      }

      const visibleGallery = [...document.querySelectorAll('.product__gallery')].find((el) => {
        return window.getComputedStyle(el).getPropertyValue('display') !== 'none'
      })

      if (visibleGallery) {
        const mainGallery = visibleGallery.querySelector('.product__main-gallery')
        const fixedBarMedia = document.querySelector('.fixed-bar__media')

        if (mainGallery && fixedBarMedia) {
          const image = mainGallery.querySelector('img')
          const fixedBarImage = fixedBarMedia.querySelector('img')

          if (image) {
            if (!fixedBarImage) {
              const newImg = document.createElement('img')
              newImg.src = image.src
              fixedBarMedia.appendChild(newImg)
            } else {
              fixedBarImage.src = image.src
            }

            this.fixedBar.classList.add('--filled')
          }
        }
      }
    }
  }



  init() {
    if (window.innerWidth > 991) {
      this.bindOptionToggleDesktop()
    } else {
      this.bindOptionToggleMobile()
      this.bindOptionModalEvents()
    }
    this.setActiveOptionsText()
    this.bindOptionButtonClick()
    this.bindOptionButtonClickInputValue()
    // this.bindColorPick()
    this.bindToggleRow()
    this.bindToggleFav()
    this.setupDescription()
    this.setupSplide()
    this.setupGallery()
    this.observeFixedBar()
    this.positionFixedBar()
    this.setFixedBarMedia()
  }
}

module.exports = ProductPage
},{}],43:[function(require,module,exports){
class ResultsPage {
  constructor() {
    this.rootEl = document.querySelector('.main_results');
    this.filterBoxArr = [...document.querySelectorAll('.page-filter-box')];
    this.filterModal = document.querySelector('.filter-modal');
    this.cardsGrid = document.querySelector('.cards-grid');
    this.filterModalActive = false;
    this.filters = {};
    this.init();
  }

  // Methods
  showFilterModal() {
    lockScroll();
    window.filterModalBackdrop = new Backdrop({
      half: true,
      callback: () => { this.hideFilterModal(); }
    });

    this.filterModal.style.display = "flex";
    setTimeout(() => {
      this.filterModal.style.transform = "translateY(0)";
    }, 3);
  }

  hideFilterModal() {
    unlockScroll();
    if (window.filterModalBackdrop) {
      window.filterModalBackdrop.hide(true);
    }
    this.filterModal.style.transform = "translateY(100%)";
    setTimeout(() => {
      this.filterModal.style.display = "none";
    }, getTransitionTime(this.filterModal));
  }

  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout)
        func(...args)
      }
      clearTimeout(timeout)
      timeout = setTimeout(later, wait)
    };
  }


  observeFilters() {
    for (const filter in this.filters) {
      if (this.filters.hasOwnProperty(filter)) {
        const { btnArr, list } = this.filters[filter];

        const radios = [...list.querySelectorAll('input[type="radio"]')];
        const checkboxes = [...list.querySelectorAll('input[type="checkbox"]')];
        const links = [...list.querySelectorAll('a')];

        const isFilled = radios.some(radio => radio.checked) ||
          checkboxes.some(checkbox => checkbox.checked) ||
          links.some(link => link.classList.contains('is-active'));

        btnArr.forEach(btn => btn.classList.toggle('--filled', isFilled));
      }
    }
  }

  // Desktop
  setupDesktopFilters() {
    this.filterBoxArr.forEach((box, index) => {
      const btn = box.querySelector('.page-filter-btn');
      const drop = box.querySelector('.page-filter-drop');
      const optionsArr = drop.querySelector('a') ? [...drop.querySelectorAll('a')] : [...drop.querySelectorAll('label')];

      if (optionsArr.length) {
        this.filters[index] = { btnArr: [btn], list: drop };

        optionsArr.forEach(option => {
          option.addEventListener('change', () => this.observeFilters());
        });
      }

      btn.addEventListener('click', () => {
        const isFocused = box.classList.contains('--focused');
        this.filterBoxArr.forEach(el => el.classList.remove('--focused'));
        if (!isFocused) box.classList.add('--focused');
      });
    });

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.page-filter-box')) {
        this.filterBoxArr.forEach(box => box.classList.remove('--focused'));
      }
    });
  }

  // Mobile
  setupMobileFilters() {
    const filterList = document.querySelector('.filter-modal__filter-list');
    const optionsHolder = document.querySelector('.filter-modal__options');
    let filterBtnArr = [];
    let listsArr = [];

    this.filterBoxArr.forEach((filter, index) => {
      const btn = filter.querySelector('.page-filter-btn');
      const drop = filter.querySelector('.page-filter-drop');
      const optionsArr = drop.querySelector('a') ? [...drop.querySelectorAll('a')] : [...drop.querySelectorAll('label')];

      if (!optionsArr.length) return;

      optionsArr.forEach(option => {
        option.addEventListener('change', () => this.observeFilters());
      });

      const displayName = this.getFilterDisplayName(btn, filter);
      const filterModalButton = this.createFilterButton(displayName);
      const list = this.createFilterList(optionsArr);

      filterList.appendChild(filterModalButton);
      optionsHolder.appendChild(list);

      filterBtnArr.push(filterModalButton);
      listsArr.push(list);

      this.setupFilterModalButtonBehavior(filterModalButton, list, filterBtnArr, listsArr);
      this.setupFilterObject(index, btn, filterModalButton, list);
      this.bindFilterButtonClick(btn, filterModalButton, list, filterBtnArr, listsArr);
    });
  }

  getFilterDisplayName(btn, filter) {
    const filterId = filter.id ? filter.id : null;
    const btnSpan = btn.querySelector('span');
    const rawName = (filterId && btnSpan) ? btnSpan.innerText.toLowerCase() : 'Sort By';
    return (rawName.includes('subcategories') || rawName.includes('subcategory')) ? 'Subcategories' :
      (rawName.includes('price') || rawName.includes('price range')) ? 'Price' : rawName;
  }

  createFilterButton(displayName) {
    return createElem('button', {
      className: 'filter-modal__filter-btn',
      innerHTML: `<span>${displayName}</span>`
    });
  }

  createFilterList(optionsArr) {
    const list = createElem('div', {
      className: 'filter-modal__options-list',
      style: { display: 'none' }
    });
    optionsArr.forEach(el => list.appendChild(el));
    return list;
  }

  setupFilterModalButtonBehavior(filterModalButton, list, filterBtnArr, listsArr) {
    filterModalButton.addEventListener('click', () => {
      filterBtnArr.forEach(btn => btn.classList.toggle('--active', btn === filterModalButton));
      listsArr.forEach(l => l.style.display = (l === list) ? 'block' : 'none');
    });
  }

  setupFilterObject(index, btn, filterModalButton, list) {
    this.filters[index] = { btnArr: [btn, filterModalButton], list: list };
  }

  bindFilterButtonClick(btn, filterModalButton, list, filterBtnArr, listsArr) {
    btn.addEventListener('click', () => {
      this.showFilterModal();
      filterBtnArr.forEach(btn => btn.classList.remove('--active'));
      listsArr.forEach(l => l.style.display = 'none');
      filterModalButton.classList.add('--active');
      list.style.display = 'block';
    });
  }

  unwrapFilters() {
    const groups = [...document.querySelectorAll('.page-filters__group')];
    groups.forEach(group => {
      while (group.firstChild) {
        group.parentNode.insertBefore(group.firstChild, group);
      }
      group.remove();
    });
  }

  bindTouchEvents() {
    let startY = 0;
    let currentY = 0;
    let isDragging = false;

    const container = this.filterModal;
    const handler = this.filterModal.querySelector('.filter-modal__header');

    handler.addEventListener('touchstart', (e) => {
      startY = e.touches[0].clientY;
      isDragging = true;
      container.style.transition = 'none';
    });

    handler.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      currentY = e.touches[0].clientY;
      let diffY = currentY - startY;

      if (diffY > 0) {
        container.style.transform = `translateY(${diffY}px)`;
      }
    });

    handler.addEventListener('touchend', () => {
      if (!isDragging) return;
      isDragging = false;

      let diffY = currentY - startY;
      let hideOffset = container.offsetHeight * 0.5;
      container.style.transition = 'all .35s ease';

      if (diffY > hideOffset) {
        this.hideFilterModal();
      } else {
        container.style.transform = `translateY(0%)`;
      }
    });
  }

  bindClickEvents() {
    const closeArr = [...document.querySelectorAll('[data-evt="closeFilterModal"]')];
    closeArr.forEach(close => {
      close.addEventListener('click', () => this.hideFilterModal());
    });
  }

  formatGoldChainsSubheading() {
    const subheading = document.querySelector('.results__subheading')
    if (subheading) {
      const text = 'Welcome to our collection of fine 14k solid gold chains, where luxury meets affordability'
      if (subheading.innerHTML.includes(text)) {
        const sentences = subheading.innerHTML.split('.').filter(sentence => sentence.trim() !== '')
        if (sentences[0] === text) {
          subheading.innerHTML = `
          <strong>${text}.</strong>
          ${sentences.slice(1).join('. ')}
          `
        }
      }
    }
  }

  setStickyBar() {
    const bar = document.querySelector('.page-filters');
    if (!bar) return;

    let topOffset = 0;

    const topBanner = document.querySelector('.top-banner');
    const header = document.querySelector('.header');

    if (topBanner) {
      if (window.getComputedStyle(topBanner).position === 'sticky') {
        const bannerHeight = topBanner.offsetHeight;
        if (bannerHeight > 0) {
          topOffset += bannerHeight;
        }
      }
    }

    if (header) {
      topOffset += header.offsetHeight;
    }

    if (topOffset > 0) {
      bar.style.position = 'sticky';
      bar.style.top = `${topOffset}px`;
    }
  }

  adjustStickyBarOnResize() {
    window.addEventListener('resize', this.debounce(() => {
      this.setStickyBar();
    }, 100))
  }

  formatFilterTitles() {
    const arr = [...document.querySelectorAll('.page-filter-btn')]
    for (const btn of arr) {
      const span = btn.querySelector('span:first-child')
      if (span) {
        const rawName = span.innerText.toLowerCase()
        const name = (rawName.includes('subcategories') || rawName.includes('subcategory')) ? 'Subcategories' :
          (rawName.includes('price') || rawName.includes('price range')) ? 'Price' : rawName;

        if (name.toLowerCase() !== rawName.toLowerCase()) {
          span.innerText = name
        }
      }
    }
  }

  // View
  switchView(mode) {
    if (!this.cardsGrid) return

    const isLess = mode === 'less'
    this.cardsGrid.classList.add('--hidden')

    setTimeout(() => {
      this.cardsGrid.classList.toggle('--less', isLess)
      setTimeout(() => {
        this.cardsGrid.classList.remove('--hidden')
      }, 100)
    }, getTransitionTime(this.cardsGrid))
  }

  bindViewSwitch() {
    const buttons = {
      more: document.querySelector('[data-results-evt="viewMore"]'),
      less: document.querySelector('[data-results-evt="viewLess"]')
    };

    const toggleView = (activeBtn, inactiveBtn, mode) => {
      if (!activeBtn.classList.contains('is-active')) {
        activeBtn.classList.add('is-active');
        inactiveBtn.classList.remove('is-active');
        this.switchView(mode);
      }
    };

    if (buttons.more && buttons.less) {
      buttons.more.addEventListener('click', () => toggleView(buttons.more, buttons.less, 'more'));
      buttons.less.addEventListener('click', () => toggleView(buttons.less, buttons.more, 'less'));
    }
  }

  init() {
    if (window.innerWidth > 991) {
      this.setupDesktopFilters();
    } else {
      this.setupMobileFilters();
      this.unwrapFilters();
      this.bindTouchEvents();
      this.bindClickEvents();
    }
    this.observeFilters();
    this.formatGoldChainsSubheading()
    this.setStickyBar()
    this.adjustStickyBarOnResize()
    this.formatFilterTitles()
    this.bindViewSwitch()
  }
}

module.exports = ResultsPage;
},{}],44:[function(require,module,exports){
const sellPage = {
  faqItems: [...document.querySelectorAll('.sell-faq-item')],
  init: function () {
    if (this.faqItems.length) {
      this.attachFaq()
      $('.sell-faq-item__main').eq(0).trigger('click')
    }
  },
  attachFaq: function () {
    this.faqItems.forEach((el, index) => {
      $(el).click(function () {
        let main = $(this).find('.sell-faq-item__main'),
          p = $(this).find('p'), svg = $(this).find('svg')
        if (main.height() == 0) {
          $(this).addClass(IS_ACTIVE)
          main.css({ height: `${p[0].scrollHeight}px` })
          svg.css({ transform: 'rotate(180deg)' })
        } else {
          $(this).removeClass(IS_ACTIVE)
          main.css({ height: `0px` })
          svg.css({ transform: 'rotate(0deg)' })
        }
      })
    })
  }
}

module.exports = sellPage
},{}],45:[function(require,module,exports){
class SellWatch {
  constructor() {
    this.form = document.querySelector('form#sell_my_watch')
    if (!this.form) {
      return
    }
    this.sectionsArr = [...document.querySelectorAll('[data-ask-section]')]
    this.progressBar = document.querySelector('.ask-page__progress-bar')
    this.currentStepElem = document.querySelector('[data-step-current]')
    this.countStepElem = document.querySelector('[data-step-count]')
    this.contentContainer = document.querySelector('.ask-page__quiz-content')
    this.adjustContainer = document.querySelector('.ask-page__quiz-adjust')

    this.focusedEl = undefined
    this.watchBrand = {
      name: undefined
    }
    this.uploadInput = this.form.querySelector('input[type="file"]')
    this.regExp = {
      rolex: /\brolex\b/i,
      audemars: /\baudemars\b/i,
      richard: /\brichard\b/i,
      patek: /\bpatek\b/i,
      cartier: /\bcartier\b/i,
      breitling: /\bbreitling\b/i
    }

    this.locked = false
    this.steps = this.sectionsArr.length
    this.currentStep = 1
    this.activeSection = this.sectionsArr[0]
    this.endReached = false
    this.atTheStart = true
    this.init()
  }

  /**
   * Getters
   */
  get getActiveSection() {
    return this.activeSection
  }
  get getCurrentStep() {
    return this.currentStep
  }
  get getFocusedEl() {
    return this.focusedEl
  }

  /**
   * Methods
   */
  toggleSectionStatus(section, condition) {
    if (condition === false) {
      section.classList.remove(__VALID)
    } else {
      section.classList.add(__VALID)
    }
    const btn = [...section.querySelectorAll('[data-sell-evt="next"]')]
    btn.forEach(btn => btn.disabled = !condition)
  }
  validateSection(section) {
    section = this.getActiveSection

    const
      requiredArr = [...section.querySelectorAll('[required]:not([disabled])')],
      radioArr = [...section.querySelectorAll('input[type="radio"]:not([disabled])')],
      checkboxArr = [...section.querySelectorAll('input[type="checkbox"]:not([disabled])')],
      inputArr = [...section.querySelectorAll('input:not([type="checkbox"]):not([type="radio"])')],
      selectArr = [...section.querySelectorAll('select[required]')],
      phoneArr = [...section.querySelectorAll('[data-validate="phone"]')],
      fileArr = [...section.querySelectorAll('input[type="file"]')]

    const radioArrByName = Array.from(
      new Set(radioArr.map(radio => radio.name)),
      name => radioArr.filter(radio => radio.name === name)
    )

    if (requiredArr.some(input => !input.value)) {
      this.toggleSectionStatus(section, false)
      return false
    }

    for (const radioGroup of radioArrByName) {
      if (radioGroup.every(radio => !radio.checked)) {
        this.toggleSectionStatus(section, false)
        return false
      }
    }

    if (checkboxArr.length && checkboxArr.every(checkbox => !checkbox.checked)) {
      this.toggleSectionStatus(section, false)
      return false
    }

    if (phoneArr.length) {
      for (const input of phoneArr) {
        const value = input.value
        const valueDigits = value.replace(/\D/g, '').length
        const regex = /^\+\d{1}\s\(\d{3}\)\s\d{3}\-\d{4}$/
        if (!regex.test(value) && valueDigits < 11) {
          this.toggleSectionStatus(section, false)
          return false
        }
      }
    }

    for (const fileInput of fileArr) {
      const files = fileInput.files
      if (!files.length) {
        this.toggleSectionStatus(section, false)
        return false
      }
    }

    this.toggleSectionStatus(section, true)
    return true
  }
  arrangeModels(string) {
    const
      inputArr = [...this.form.querySelectorAll('input[type="radio"][name="model"]')],
      groupInputArr = inputArr.filter(input => input.dataset.group),
      filteredArr = groupInputArr.filter(input => { return string.toLowerCase().includes(input.dataset.group) }),
      modelGrid = this.form.querySelector('[data-sell-grid="model"]'),
      modelInput = this.form.querySelector('input#watch_model'),
      modelInputParent = modelInput.closest('.survey-box__named-grid')

    inputArr.forEach(input => input.checked = false)
    // inputArr.forEach(input => input.dispatchEvent(new Event('change')))
    modelInput.value = ''
    modelInput.dispatchEvent(new Event('input'))

    if (!filteredArr.length) {
      modelGrid.style.display = 'none'
      modelInputParent.style.display = 'flex'
      modelInput.disabled = false
      inputArr.forEach(input => {
        input.disabled = true
        input.checked = false
        // input.dispatchEvent(new Event('change'))
      })
    } else {
      modelGrid.style.display = 'flex'
      modelInputParent.style.display = 'none'
      modelInput.disabled = true
      inputArr.forEach(input => {
        const label = input.closest('label')
        input.disabled = false
        input.checked = false
        if (!filteredArr.includes(input) && input.value !== 'Other') {
          if (input.value) {
            label.style.display = 'none'
          }
        } else {
          label.style.display = 'block'
        }
        // input.dispatchEvent(new Event('change'))
      })
    }
  }

  /**
   * Utils
   */
  observeStepsElements() {
    this.currentStepElem.innerHTML = this.currentStep
  }
  observeBarElements() {
    const elements = this.progressBar.querySelectorAll('span')
    elements.forEach((element, index) => {
      if (index < this.currentStep) {
        element.classList.add(__ACTIVE)
      } else {
        element.classList.remove(__ACTIVE)
      }
    })
  }
  scrollToForm() {
    if (this.form) {
      const headerHeight = parseInt(window.getComputedStyle(document.querySelector('header')).getPropertyValue('height'))
      const boundTop = this.form.getBoundingClientRect().top
      if ((boundTop - headerHeight) < -30) {
        const distance = (window.scrollY + this.form.getBoundingClientRect().top) - (headerHeight + 70)
        zenscroll.toY(distance)
      }
    }
  }
  dispatchFocusEvent(elem) {
    if (elem) {
      const tag = elem.tagName
      switch (tag) {
        case 'INPUT' || 'TEXTAREA':
          const type = elem.type
          if (type === 'radio' || type === 'checkbox') {
            elem.click()
          } else {
            if (type === 'file') {
              elem.click()
            } else {
              elem.focus()
            }
          }
          break;
        case 'SELECT':
          elem.focus()
          break;
        default:
          elem.dispatchEvent(new Event('focus'))
          break;
      }
    }
  }

  /**
   * Events
   */
  slide(section, activeSection, number) {
    const sectionIndex = this.sectionsArr.indexOf(section)
    const activeSectionIndex = this.sectionsArr.indexOf(activeSection)

    let fromTranslate = 'translateY(24px)'
    let toTranslate = 'translateY(-24px)'

    if (activeSectionIndex > sectionIndex) {
      fromTranslate = 'translateY(-24px)'
      toTranslate = 'translateY(24px)'

      const inputs = [...activeSection.querySelectorAll('input')]
    }

    this.locked = true
    activeSection.style.opacity = 0
    activeSection.style.pointerEvents = 'none'
    activeSection.style.transform = toTranslate
    section.style.opacity = 0
    section.style.pointerEvents = 'none'
    section.style.transform = fromTranslate
    setTimeout(() => {
      activeSection.style.display = 'none'
      activeSection.classList.remove(__ACTIVE)
      section.style.display = 'flex'
      section.classList.add(__ACTIVE)
      setTimeout(() => {
        section.style.opacity = 1
        section.style.transform = 'translateY(0px)'
        section.style.pointerEvents = 'auto'

        this.locked = false
        this.activeSection = section
        this.currentStep = number
        this.observeStepsElements()
        this.observeBarElements()

        if (section === this.sectionsArr[this.sectionsArr.length - 1]) {
          this.form.submit()
        }
      }, 30)
    }, getTransitionTime(activeSection))
  }
  finish() {
    const confetti = new PageConfetti()
    confetti.push()
  }
  go(number) {
    if (!this.locked) {
      const section = this.sectionsArr[number - 1]
      const activeSection = this.getActiveSection

      if (!section) {
        const error = number < 1 ? 'Section number cannot be less than 1' : 'Section number cannot be greater than ' + this.sectionsArr.length
        throw new Error(error)
      }
      if (!activeSection) {
        throw new Error('No active section')
      }

      if (section !== activeSection) {
        this.slide(section, activeSection, number)
        this.scrollToForm()
        this.focusedEl = undefined
      }
    }
  }


  /**
   * Bind Events
   */
  bindToggleStepsControls() {
    for (const section of this.sectionsArr) {
      const inputs = [...section.querySelectorAll('input, select')]
      inputs.forEach((input) => {
        const isCheckboxOrRadio = input.type === 'checkbox' || input.type === 'radio' || input.type === 'file'
        if (isCheckboxOrRadio) {
          input.addEventListener('change', (e) => {
            this.validateSection(section)
          })
        } else {
          input.addEventListener('input', (e) => {
            this.validateSection(section)
          })
        }
      })
    }
  }
  bindDualSelect() {
    const dualArr = [...this.form.querySelectorAll('input[data-dual]')]
    for (const input of dualArr) {
      const
        name = input.name,
        dualName = input.dataset.dual,
        nameInputArr = [...this.form.querySelectorAll(`input[name="${name}"]`)],
        holder = this.form.querySelector(`div[data-dual="${dualName}"]`)

      if (holder) {
        const select = holder.querySelector('select, input')
        if (select) {
          nameInputArr.forEach((nameInput) => {
            nameInput.addEventListener('change', () => {
              if (input.checked) {
                select.disabled = false
                holder.style.display = 'flex'
              } else {
                select.disabled = true
                holder.style.display = 'none'
              }
            })
          })
        }
      }
    }
  }
  bindBrandSelect() {
    const brandSelectArr = [...this.form.querySelectorAll('*[name="brand"]')]
    const elsToName = [...this.form.querySelectorAll('[data-sell-brand]')]
    for (const input of brandSelectArr) {
      input.addEventListener('change', (e) => {
        if (input.disabled) return
        const value = input.value
        if (value && value.toLowerCase() !== 'other') {
          this.watchBrand.name = value
          elsToName.forEach(el => el.innerHTML = this.watchBrand.name)
        } else {
          this.watchBrand.name = undefined
          elsToName.forEach(el => el.innerHTML = 'your brand')
        }

        // Setup models
        this.arrangeModels(value)
      })
    }
  }
  bindPhoneInput() {
    const inputs = [...this.form.querySelectorAll('input[data-validate="phone"]')]
    for (const input of inputs) {
      let keyCode;
      function mask(event) {
        event.keyCode && (keyCode = event.keyCode);
        let pos = this.selectionStart;
        if (pos < 3) event.preventDefault()
        let matrix = "+1 (___) ___-____",
          i = 0,
          def = matrix.replace(/\D/g, ""),
          val = this.value.replace(/\D/g, ""),
          newValue = matrix.replace(/[_\d]/g, function (a) {
            return i < val.length ? val.charAt(i++) || def.charAt(i) : a;
          });
        i = newValue.indexOf("_");
        if (i != -1) {
          i < 5 && (i = 3);
          newValue = newValue.slice(0, i);
        }
        let reg = matrix.substr(0, this.value.length).replace(/_+/g,
          function (a) {
            return "\\d{1," + a.length + "}";
          }).replace(/[+()]/g, "\\$&");
        reg = new RegExp("^" + reg + "$");
        if (!reg.test(this.value) || this.value.length < 5 || keyCode > 47 && keyCode < 58) this.value = newValue;
        if (event.type == "blur" && this.value.length < 5) this.value = "";
      }

      input.addEventListener("input", mask, false);
      input.addEventListener("focus", mask, false);
      input.addEventListener("blur", mask, false);
      input.addEventListener("keydown", mask, false);
      input.addEventListener('mouseup', event => {
        event.preventDefault()
        if (input.value.length < 4) {
          input.setSelectionRange(4, 4)
        } else {
          input.setSelectionRange(input.value.length, input.value.length)
        }
      })
    }
  }
  bindCurrencyInput() {
    const inputArr = [...this.form.querySelectorAll('input[data-format="currency"]')]
    for (const input of inputArr) {
      input.addEventListener('blur', () => {
        if (input.value) {
          input.value = formatAsCurrency(input.value)
        }
      })
    }
  }
  bindHandlers() {
    const nextArr = [...this.form.querySelectorAll('[data-sell-evt="next"]')]
    const backArr = [...this.form.querySelectorAll('[data-sell-evt="back"]')]

    for (const btn of nextArr) {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        if (!btn.disabled) {
          this.go(this.getCurrentStep + 1)
        }
      })
    }

    for (const btn of backArr) {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        if (!btn.disabled) {
          this.go(this.getCurrentStep - 1)
        }
      })
    }
  }
  bindSetFocusedElement() {
    const inputs = [...this.form.querySelectorAll('input, select, textarea')]
    for (const input of inputs) {
      input.addEventListener('change', () => { this.focusedEl = input })
      input.addEventListener('focus', () => { this.focusedEl = input })
    }
  }
  bindKeyEvents() {
    document.addEventListener('keydown', (e) => {
      if (this.locked) return
      if (!this.getActiveSection) return

      const section = this.getActiveSection
      const key = e.key
      const keyIsTab = key === 'Tab'
      const keyIsEnter = key === 'Enter'
      const isBackspace = key === 'Backspace'

      if (isBackspace) {
        if (!document.activeElement || !document.activeElement.contains(section)) return
        const btn = section.querySelector('[data-sell-evt="back"]')
        if (btn && !btn.disabled) {
          e.preventDefault()
          btn.click()
        }
      }

      if (keyIsEnter) {
        const btn = section.querySelector('[data-sell-evt="next"]')
        if (btn) {
          e.preventDefault()
          if (!btn.disabled) {
            btn.click()
          }
        }
      }

      if (keyIsTab) {
        e.preventDefault()
        const focusedEl = this.getFocusedEl
        const inputs = [...section.querySelectorAll('input, select, textarea')].filter((input) => {
          if (!input.disabled) {
            const selectBox = input.parentNode.closest('.survey-select')
            if (selectBox) {
              if (selectBox.style.display !== 'none') {
                return input
              }
            } else {
              return input
            }
          }
        }).sort((a, b) => a.compareDocumentPosition(b) - 2)
        let elem

        if (!focusedEl) {
          elem = inputs[0]
        } else {
          const elemWithinSection = inputs.includes(focusedEl)
          if (elemWithinSection) {
            const nextElem = inputs[inputs.indexOf(focusedEl) + 1]
            if (nextElem) {
              elem = nextElem
            } else {
              elem = inputs[0]
            }
          } else {
            elem = inputs[0]
          }
        }

        this.dispatchFocusEvent(elem)
      }
    })
  }
  bindSubmit() {
    $(this.form).on('submit', function (e) {
      e.preventDefault();
      var form = $(this);
      var formData = new FormData(this);
      var actionUrl = form.attr('action');
      $.ajax({
        url: actionUrl,
        type: 'POST',
        data: formData,
        cache: false,
        contentType: false,
        processData: false,
        success: function (data) {
          var r = $.parseJSON(data);
          if (!r.error) {
            this.finish()
          } else {
            //show error message 
            alert(r.msg);
          }
        }
      })
    });
  }

  /**
   * Setup
   */
  setupBar() {
    if (this.progressBar) {
      let html = ''
      this.sectionsArr.forEach((section, index) => {
        html += `<span data-bar-id="${index}"></span>`
      })
      this.progressBar.innerHTML = html
    }
    if (this.currentStepElem && this.countStepElem) {
      this.currentStepElem.innerHTML = 1
      this.countStepElem.innerHTML = this.sectionsArr.length
    }
  }
  setup() {
    this.setupBar()
    this.go(1)
    this.observeStepsElements()
    this.observeBarElements()
    this.bindHandlers()
  }


  /**
   * Initialize
   */
  init() {
    if (this.form) {
      this.bindDualSelect()
      this.bindToggleStepsControls()
      this.bindBrandSelect()
      this.bindPhoneInput()
      this.bindCurrencyInput()
      this.bindSetFocusedElement()
      this.bindKeyEvents()
      this.bindSubmit()
      this.setup()
    }
  }
}

module.exports = SellWatch
},{}],46:[function(require,module,exports){
const tagPreview = {
  init: function () {
    try {
      if (document.querySelector('.main_print-tag') !== null) {
        this.resetOutput()
        this.attachInput()
        this.attachImageUploader()
        this.attachPreviewControls()
      }
    } catch {
      console.log('TAG PREVIEW ERR')
    }
  },
  resetOutput: function () {
    const outputHolder = document.querySelector('.tag-preview__output'),
      outputImage = document.querySelector('.tag-preview__pic')
    outputHolder.innerHTML = ''
    outputHolder.classList.add(IS_EMPTY)
    outputImage.classList.add(IS_EMPTY)
  },
  attachInput: function () {
    const outputObj = new Object(),
      inputs = [...document.querySelectorAll('input[type="text"].formpage__input')],
      outputHolder = document.querySelector('.tag-preview__output'),
      updateOutput = () => {
        let filled = 0, html = ``
        for (const key in outputObj) {
          if (outputObj.hasOwnProperty(key)) {
            const obj = outputObj[key]
            if (obj.value.length !== 0) {
              ++filled
              html += `
                <div id="${obj.id}" class="tag-output-row">
                  <span>${obj.title}</span>
                  <span>${obj.value}</span>
                </div>
                `
            }
          }
        }
        if (filled !== 0) {
          outputHolder.innerHTML = html
          outputHolder.classList.remove(IS_EMPTY)
        } else {
          outputHolder.innerHTML = ''
          outputHolder.classList.add(IS_EMPTY)
        }
      }

    inputs.forEach((input, index) => {
      outputObj[index] = {
        id: input.id,
        value: '',
        title: input.closest('.formpage__input-box').querySelector('label').innerHTML
      }

      input.oninput = () => {
        outputObj[index].value = input.value || ''
        updateOutput()
      }
      input.onkeydown = (e) => {
        const
          isEnter = e.key === 'Enter' || e.keyCode === 13,
          isBackscape = e.key === 'Backspace' || e.key === 'Delete',
          isEsc = e.key === 'Escape' || e.key === 'Esc',
          isUp = e.key === 'ArrowUp',
          isDown = e.key === 'ArrowDown',
          next = inputs[index + 1],
          prev = inputs[index - 1]

        if (isEnter || isDown) {
          if (next !== undefined) { next.focus() }
        }
        if (isBackscape) {
          if (input.value.length == 0 && prev !== undefined) { prev.focus() }
        }
        if (isEsc) {
          e.preventDefault(); input.blur()
        }
        if (isUp) {
          if (prev !== undefined) { prev.focus() }
        }
      }
      ['focus', 'blur'].forEach((ev) => {
        if (window.innerWidth <= 479) {
          const label = input.closest('.formpage__input-box').querySelector('label')
          input.addEventListener(ev, function () {
            switch (ev) {
              case 'focus':
                label.style.opacity = 0
                break;
              case 'blur':
                if (input.value.length !== 0) { label.style.opacity = 0 } else {
                  label.style.opacity = 0.5
                }
                break;
            }
          })
        }
      })

    })
  },
  attachImageUploader: function () {
    const uploadLabel = document.querySelector('#printTag_uploader'),
      uploadInput = document.querySelector('#image_upload_tag'),
      imgPreview = document.querySelector('.tag-preview__pic')

    // DRAG & DROP
    if (uploadLabel !== null) {
      uploadLabel.ondragover = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.add(IS_ACTIVE)
      }
      uploadLabel.ondragleave = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.remove(IS_ACTIVE)
      }
      uploadLabel.ondrop = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.remove(IS_ACTIVE)
        $('#image_upload_tag').prop('files', evt.dataTransfer.files);
        const files = [...evt.dataTransfer.items],
          file = files.find((item) => { if (item.kind === 'file') { return item } })
        processImage(file.getAsFile())
      }

      // MANUAL
      if (uploadInput !== null) {
        uploadInput.onchange = (evt) => {
          const file = [...evt.target.files][0]
          processImage(file)
          uploadInput.value = ''
        }
      }

      // PROCESS IMAGE
      function processImage(file) {
        if (file) {
          let reader = new FileReader()
          reader.onload = (e) => {
            imgPreview.classList.remove(IS_EMPTY)
            imgPreview.style.backgroundImage = `url(${e.target.result})`
          }
          reader.readAsDataURL(file)
        }
      }

    }
  },
  attachPreviewControls: function () {
    const modal = document.querySelector('.tag-preview-modal')
    if (modal !== null) {
      const holder = document.querySelector('.tag-preview-modal__wrapper')
      const toggle = () => {
        let displayed = window.getComputedStyle(modal).getPropertyValue('display') !== 'none'
        if (displayed) {
          unlockScroll()
          const preview = holder.querySelector('.formpage__tag-preview')
          if (preview !== null) { preview.remove() }
          modal.style.display = 'none'
        } else {
          lockScroll()
          const preview = document.querySelector('.formpage__tag-preview')
          holder.appendChild(preview.cloneNode(true))
          modal.style.display = 'block'
        }
      }

      document.addEventListener('click', function (e) {
        const target = e.target
        if (target.getAttribute('data-evt') == 'togglePrintTagPreview') {
          toggle()
        }
      })
    }
  }
}

module.exports = tagPreview
},{}],47:[function(require,module,exports){
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function lockScroll() {
  setTimeout(function () {
    if (!document.body.hasAttribute("ib-scroll-lock")) {
      let o = window.pageYOffset || document.documentElement.scrollTop;
      document.body.setAttribute("ib-scroll-lock", o),
        (document.body.style.overflow = "hidden"),
        (document.body.style.position = "fixed"),
        (document.body.style.top = "-" + o + "px"),
        (document.body.style.left = "0"),
        (document.body.style.width = "100%");
    }
  }, 1);
}
function unlockScroll() {
  if (document.body.hasAttribute("ib-scroll-lock")) {
    let o = document.body.getAttribute("ib-scroll-lock");
    document.body.removeAttribute("ib-scroll-lock"),
      (document.body.style.overflow = ""),
      (document.body.style.position = ""),
      (document.body.style.top = ""),
      (document.body.style.left = ""),
      (document.body.style.width = ""),
      window.scroll(0, o);
  }
}
function elemDisplayed(elem) {
  if (!elem) return false
  let target = elem instanceof jQuery ? elem.get(0) : elem
  return window.getComputedStyle(target).getPropertyValue('display') !== 'none'
}
function createElem(tagName, options) {
  const { className, id, innerHTML, style, attributes, toAppend } = options
  const elem = document.createElement(tagName)
  if (className) elem.className = className;
  if (id) elem.id = id;
  if (innerHTML) elem.innerHTML = innerHTML;
  if (style) {
    for (const key in options.style) { elem.style[key] = options.style[key] }
  }
  if (attributes) {
    for (const key in options.attributes) { elem.setAttribute(key, options.attributes[key]) }
  }
  if (toAppend) {
    for (const child of toArray(toAppend)) { elem.appendChild(child) }
  }
  return elem
}
function removeClasses(elem, ...classes) {
  for (const cls of classes) {
    elem.classList.remove(cls)
  }
}
function addClasses(elem, ...classes) {
  for (const cls of classes) {
    elem.classList.add(cls)
  }
}
function formatAsCurrency(string) {
  string = typeof string === 'string' ? string : string.toString()
  const number = parseFloat(string.replace(/,/g, ''))
  const parts = number.toFixed(2).split('.')
  const digits = parts[0]
  const decimal = parts[1]
  const integer = digits.replace(/\B(?=(\d{3})+(?!\d))/g, ',')
  return `${integer}.${decimal}`
}
function getEvtDOM(attr) {
  return $(`[data-evt="${attr}"]`);
}
function getTransitionTime(elem) {
  let el = elem instanceof jQuery ? elem[0] : elem;
  return parseFloat(window.getComputedStyle(el).transitionDuration) * 1000;
}
function getOrdinalTxt(n) {
  return n % 10 == 1 && n % 100 != 11 ? 'st' : n % 10 == 2 && n % 100 != 12 ? 'nd' : n % 10 == 3 && n % 100 != 13 ? 'rd' : 'th'
}
function getZIndex(elem) {
  return parseInt(window.getComputedStyle(elem).getPropertyValue('z-index'))
}
function toggleAdminBar() {
  let bar = document.querySelector('.iba-toolbar')
  if (bar && bar !== null) {
    if (bar.classList.contains(IS_MINIMIZED)) {
      bar.classList.remove(IS_MINIMIZED)
    } else {
      bar.classList.add(IS_MINIMIZED)
    }
  }
}
function isEmail(email) {
  var regex = /^([a-zA-Z0-9_.+-])+\@(([a-zA-Z0-9-])+\.)+([a-zA-Z0-9]{2,4})+$/;
  return regex.test(email);
}
function saveCartEmail() {
  var email = $('#cart_email').val();
  if (email != '' && isEmail(email)) {
    $.ajax({
      type: "POST",
      url: '/json/cart-email',
      data: { email_address: email },
      success: function (data) {
        klaviyo.identify({ '$email': email });
        mailModal.close();
        showMessage('success', 'Thank you', 'Item was added to your cart.');
        $('.cart_trigger').click();
      }
    });
  } else {
    showMessage('error', 'Error', 'Please enter a valid email address !');
  }
}
function showMessage(type, title, msg) {
  var alert_type = (type === 'success') ? pageAlerts.classes.info : pageAlerts.classes.error;
  pageAlerts.showAlert(alert_type, title, msg);
}

function debounce(func, wait) {
  let timeout
  return function(...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

module.exports = {
  toArray,
  lockScroll,
  unlockScroll,
  elemDisplayed,
  createElem,
  removeClasses,
  addClasses,
  formatAsCurrency,
  getEvtDOM,
  getTransitionTime,
  getOrdinalTxt,
  getZIndex,
  toggleAdminBar,
  isEmail,
  saveCartEmail,
  showMessage,
  debounce
}
},{}],48:[function(require,module,exports){
let variables = {
  UPLOADED_BLOG_IMG: null,
  alertTimer: null,
  sirvTimer: null
}

module.exports = variables;
},{}],49:[function(require,module,exports){
(function (global){(function (){
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("jquery")) : "function" == typeof define && define.amd ? define(["jquery"], e) : (t = t || self).parsley = e(t.jQuery) }(this, function (h) { "use strict"; function n(t) { return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function l() { return (l = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r]) } return t }).apply(this, arguments) } function o(t, e) { return function (t) { if (Array.isArray(t)) return t }(t) || function (t, e) { if (!(Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t))) return; var i = [], r = !0, n = !1, s = void 0; try { for (var a, o = t[Symbol.iterator](); !(r = (a = o.next()).done) && (i.push(a.value), !e || i.length !== e); r = !0); } catch (t) { n = !0, s = t } finally { try { r || null == o.return || o.return() } finally { if (n) throw s } } return i }(t, e) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance") }() } function u(t) { return function (t) { if (Array.isArray(t)) { for (var e = 0, i = new Array(t.length); e < t.length; e++)i[e] = t[e]; return i } }(t) || function (t) { if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) return Array.from(t) }(t) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance") }() } var t = 1, e = {}, d = { attr: function (t, e, i) { var r, n, s, a = new RegExp("^" + e, "i"); if (void 0 === i) i = {}; else for (r in i) i.hasOwnProperty(r) && delete i[r]; if (!t) return i; for (r = (s = t.attributes).length; r--;)(n = s[r]) && n.specified && a.test(n.name) && (i[this.camelize(n.name.slice(e.length))] = this.deserializeValue(n.value)); return i }, checkAttr: function (t, e, i) { return t.hasAttribute(e + i) }, setAttr: function (t, e, i, r) { t.setAttribute(this.dasherize(e + i), String(r)) }, getType: function (t) { return t.getAttribute("type") || "text" }, generateID: function () { return "" + t++ }, deserializeValue: function (e) { var t; try { return e ? "true" == e || "false" != e && ("null" == e ? null : isNaN(t = Number(e)) ? /^[\[\{]/.test(e) ? JSON.parse(e) : e : t) : e } catch (t) { return e } }, camelize: function (t) { return t.replace(/-+(.)?/g, function (t, e) { return e ? e.toUpperCase() : "" }) }, dasherize: function (t) { return t.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/_/g, "-").toLowerCase() }, warn: function () { var t; window.console && "function" == typeof window.console.warn && (t = window.console).warn.apply(t, arguments) }, warnOnce: function (t) { e[t] || (e[t] = !0, this.warn.apply(this, arguments)) }, _resetWarnings: function () { e = {} }, trimString: function (t) { return t.replace(/^\s+|\s+$/g, "") }, parse: { date: function (t) { var e = t.match(/^(\d{4,})-(\d\d)-(\d\d)$/); if (!e) return null; var i = o(e.map(function (t) { return parseInt(t, 10) }), 4), r = (i[0], i[1]), n = i[2], s = i[3], a = new Date(r, n - 1, s); return a.getFullYear() !== r || a.getMonth() + 1 !== n || a.getDate() !== s ? null : a }, string: function (t) { return t }, integer: function (t) { return isNaN(t) ? null : parseInt(t, 10) }, number: function (t) { if (isNaN(t)) throw null; return parseFloat(t) }, boolean: function (t) { return !/^\s*false\s*$/i.test(t) }, object: function (t) { return d.deserializeValue(t) }, regexp: function (t) { var e = ""; return t = /^\/.*\/(?:[gimy]*)$/.test(t) ? (e = t.replace(/.*\/([gimy]*)$/, "$1"), t.replace(new RegExp("^/(.*?)/" + e + "$"), "$1")) : "^" + t + "$", new RegExp(t, e) } }, parseRequirement: function (t, e) { var i = this.parse[t || "string"]; if (!i) throw 'Unknown requirement specification: "' + t + '"'; var r = i(e); if (null === r) throw "Requirement is not a ".concat(t, ': "').concat(e, '"'); return r }, namespaceEvents: function (t, e) { return (t = this.trimString(t || "").split(/\s+/))[0] ? h.map(t, function (t) { return "".concat(t, ".").concat(e) }).join(" ") : "" }, difference: function (t, i) { var r = []; return h.each(t, function (t, e) { -1 == i.indexOf(e) && r.push(e) }), r }, all: function (t) { return h.when.apply(h, u(t).concat([42, 42])) }, objectCreate: Object.create || function (t) { if (1 < arguments.length) throw Error("Second argument not supported"); if ("object" != n(t)) throw TypeError("Argument must be an object"); i.prototype = t; var e = new i; return i.prototype = null, e }, _SubmitSelector: 'input[type="submit"], button:submit' }; function i() { } function r() { this.__id__ = d.generateID() } var s = { namespace: "data-parsley-", inputs: "input, textarea, select", excluded: "input[type=button], input[type=submit], input[type=reset], input[type=hidden]", priorityEnabled: !0, multiple: null, group: null, uiEnabled: !0, validationThreshold: 3, focus: "first", trigger: !1, triggerAfterFailure: "input", errorClass: "parsley-error", successClass: "parsley-success", classHandler: function () { }, errorsContainer: function () { }, errorsWrapper: '<ul class="parsley-errors-list"></ul>', errorTemplate: "<li></li>" }; r.prototype = { asyncSupport: !0, _pipeAccordingToValidationResult: function () { function t() { var t = h.Deferred(); return !0 !== e.validationResult && t.reject(), t.resolve().promise() } var e = this; return [t, t] }, actualizeOptions: function () { return d.attr(this.element, this.options.namespace, this.domOptions), this.parent && this.parent.actualizeOptions && this.parent.actualizeOptions(), this }, _resetOptions: function (t) { for (var e in this.domOptions = d.objectCreate(this.parent.options), this.options = d.objectCreate(this.domOptions), t) t.hasOwnProperty(e) && (this.options[e] = t[e]); this.actualizeOptions() }, _listeners: null, on: function (t, e) { return this._listeners = this._listeners || {}, (this._listeners[t] = this._listeners[t] || []).push(e), this }, subscribe: function (t, e) { h.listenTo(this, t.toLowerCase(), e) }, off: function (t, e) { var i = this._listeners && this._listeners[t]; if (i) if (e) for (var r = i.length; r--;)i[r] === e && i.splice(r, 1); else delete this._listeners[t]; return this }, unsubscribe: function (t) { h.unsubscribeTo(this, t.toLowerCase()) }, trigger: function (t, e, i) { e = e || this; var r, n = this._listeners && this._listeners[t]; if (n) for (var s = n.length; s--;)if (!1 === (r = n[s].call(e, e, i))) return r; return !this.parent || this.parent.trigger(t, e, i) }, asyncIsValid: function (t, e) { return d.warnOnce("asyncIsValid is deprecated; please use whenValid instead"), this.whenValid({ group: t, force: e }) }, _findRelated: function () { return this.options.multiple ? h(this.parent.element.querySelectorAll("[".concat(this.options.namespace, 'multiple="').concat(this.options.multiple, '"]'))) : this.$element } }; function c(t) { h.extend(!0, this, t) } c.prototype = { validate: function (t, e) { if (this.fn) return 3 < arguments.length && (e = [].slice.call(arguments, 1, -1)), this.fn(t, e); if (Array.isArray(t)) { if (!this.validateMultiple) throw "Validator `" + this.name + "` does not handle multiple values"; return this.validateMultiple.apply(this, arguments) } var i = arguments[arguments.length - 1]; if (this.validateDate && i._isDateInput()) return arguments[0] = d.parse.date(arguments[0]), null !== arguments[0] && this.validateDate.apply(this, arguments); if (this.validateNumber) return !t || !isNaN(t) && (arguments[0] = parseFloat(arguments[0]), this.validateNumber.apply(this, arguments)); if (this.validateString) return this.validateString.apply(this, arguments); throw "Validator `" + this.name + "` only handles multiple values" }, parseRequirements: function (t, e) { if ("string" != typeof t) return Array.isArray(t) ? t : [t]; var i = this.requirementType; if (Array.isArray(i)) { for (var r = function (t, e) { var i = t.match(/^\s*\[(.*)\]\s*$/); if (!i) throw 'Requirement is not an array: "' + t + '"'; var r = i[1].split(",").map(d.trimString); if (r.length !== e) throw "Requirement has " + r.length + " values when " + e + " are needed"; return r }(t, i.length), n = 0; n < r.length; n++)r[n] = d.parseRequirement(i[n], r[n]); return r } return h.isPlainObject(i) ? function (t, e, i) { var r = null, n = {}; for (var s in t) if (s) { var a = i(s); "string" == typeof a && (a = d.parseRequirement(t[s], a)), n[s] = a } else r = d.parseRequirement(t[s], e); return [r, n] }(i, t, e) : [d.parseRequirement(i, t)] }, requirementType: "string", priority: 2 }; function a(t, e) { this.__class__ = "ValidatorRegistry", this.locale = "en", this.init(t || {}, e || {}) } var p = { email: /^((([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))$/, number: /^-?(\d*\.)?\d+(e[-+]?\d+)?$/i, integer: /^-?\d+$/, digits: /^\d+$/, alphanum: /^\w+$/i, date: { test: function (t) { return null !== d.parse.date(t) } }, url: new RegExp("^(?:(?:https?|ftp)://)?(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-zA-Z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:/\\S*)?$") }; p.range = p.number; function f(t) { var e = ("" + t).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/); return e ? Math.max(0, (e[1] ? e[1].length : 0) - (e[2] ? +e[2] : 0)) : 0 } function m(s, a) { return function (t) { for (var e = arguments.length, i = new Array(1 < e ? e - 1 : 0), r = 1; r < e; r++)i[r - 1] = arguments[r]; return i.pop(), a.apply(void 0, [t].concat(u((n = s, i.map(d.parse[n]))))); var n } } function g(t) { return { validateDate: m("date", t), validateNumber: m("number", t), requirementType: t.length <= 2 ? "string" : ["string", "string"], priority: 30 } } a.prototype = { init: function (t, e) { for (var i in this.catalog = e, this.validators = l({}, this.validators), t) this.addValidator(i, t[i].fn, t[i].priority); window.Parsley.trigger("parsley:validator:init") }, setLocale: function (t) { if (void 0 === this.catalog[t]) throw new Error(t + " is not available in the catalog"); return this.locale = t, this }, addCatalog: function (t, e, i) { return "object" === n(e) && (this.catalog[t] = e), !0 === i ? this.setLocale(t) : this }, addMessage: function (t, e, i) { return void 0 === this.catalog[t] && (this.catalog[t] = {}), this.catalog[t][e] = i, this }, addMessages: function (t, e) { for (var i in e) this.addMessage(t, i, e[i]); return this }, addValidator: function (t, e, i) { if (this.validators[t]) d.warn('Validator "' + t + '" is already defined.'); else if (s.hasOwnProperty(t)) return void d.warn('"' + t + '" is a restricted keyword and is not a valid validator name.'); return this._setValidator.apply(this, arguments) }, hasValidator: function (t) { return !!this.validators[t] }, updateValidator: function (t, e, i) { return this.validators[t] ? this._setValidator.apply(this, arguments) : (d.warn('Validator "' + t + '" is not already defined.'), this.addValidator.apply(this, arguments)) }, removeValidator: function (t) { return this.validators[t] || d.warn('Validator "' + t + '" is not defined.'), delete this.validators[t], this }, _setValidator: function (t, e, i) { for (var r in "object" !== n(e) && (e = { fn: e, priority: i }), e.validate || (e = new c(e)), (this.validators[t] = e).messages || {}) this.addMessage(r, t, e.messages[r]); return this }, getErrorMessage: function (t) { var e; "type" === t.name ? e = (this.catalog[this.locale][t.name] || {})[t.requirements] : e = this.formatMessage(this.catalog[this.locale][t.name], t.requirements); return e || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage }, formatMessage: function (t, e) { if ("object" !== n(e)) return "string" == typeof t ? t.replace(/%s/i, e) : ""; for (var i in e) t = this.formatMessage(t, e[i]); return t }, validators: { notblank: { validateString: function (t) { return /\S/.test(t) }, priority: 2 }, required: { validateMultiple: function (t) { return 0 < t.length }, validateString: function (t) { return /\S/.test(t) }, priority: 512 }, type: { validateString: function (t, e, i) { var r = 2 < arguments.length && void 0 !== i ? i : {}, n = r.step, s = void 0 === n ? "any" : n, a = r.base, o = void 0 === a ? 0 : a, l = p[e]; if (!l) throw new Error("validator type `" + e + "` is not supported"); if (!t) return !0; if (!l.test(t)) return !1; if ("number" === e && !/^any$/i.test(s || "")) { var u = Number(t), d = Math.max(f(s), f(o)); if (f(u) > d) return !1; var h = function (t) { return Math.round(t * Math.pow(10, d)) }; if ((h(u) - h(o)) % h(s) != 0) return !1 } return !0 }, requirementType: { "": "string", step: "string", base: "number" }, priority: 256 }, pattern: { validateString: function (t, e) { return !t || e.test(t) }, requirementType: "regexp", priority: 64 }, minlength: { validateString: function (t, e) { return !t || t.length >= e }, requirementType: "integer", priority: 30 }, maxlength: { validateString: function (t, e) { return t.length <= e }, requirementType: "integer", priority: 30 }, length: { validateString: function (t, e, i) { return !t || t.length >= e && t.length <= i }, requirementType: ["integer", "integer"], priority: 30 }, mincheck: { validateMultiple: function (t, e) { return t.length >= e }, requirementType: "integer", priority: 30 }, maxcheck: { validateMultiple: function (t, e) { return t.length <= e }, requirementType: "integer", priority: 30 }, check: { validateMultiple: function (t, e, i) { return t.length >= e && t.length <= i }, requirementType: ["integer", "integer"], priority: 30 }, min: g(function (t, e) { return e <= t }), max: g(function (t, e) { return t <= e }), range: g(function (t, e, i) { return e <= t && t <= i }), equalto: { validateString: function (t, e) { if (!t) return !0; var i = h(e); return i.length ? t === i.val() : t === e }, priority: 256 }, euvatin: { validateString: function (t) { if (!t) return !0; return /^[A-Z][A-Z][A-Za-z0-9 -]{2,}$/.test(t) }, priority: 30 } } }; var v = {}; v.Form = { _actualizeTriggers: function () { var e = this; this.$element.on("submit.Parsley", function (t) { e.onSubmitValidate(t) }), this.$element.on("click.Parsley", d._SubmitSelector, function (t) { e.onSubmitButton(t) }), !1 !== this.options.uiEnabled && this.element.setAttribute("novalidate", "") }, focus: function () { if (!(this._focusedField = null) === this.validationResult || "none" === this.options.focus) return null; for (var t = 0; t < this.fields.length; t++) { var e = this.fields[t]; if (!0 !== e.validationResult && 0 < e.validationResult.length && void 0 === e.options.noFocus && (this._focusedField = e.$element, "first" === this.options.focus)) break } return null === this._focusedField ? null : this._focusedField.focus() }, _destroyUI: function () { this.$element.off(".Parsley") } }, v.Field = { _reflowUI: function () { if (this._buildUI(), this._ui) { var t = function t(e, i, r) { for (var n = [], s = [], a = 0; a < e.length; a++) { for (var o = !1, l = 0; l < i.length; l++)if (e[a].assert.name === i[l].assert.name) { o = !0; break } o ? s.push(e[a]) : n.push(e[a]) } return { kept: s, added: n, removed: r ? [] : t(i, e, !0).added } }(this.validationResult, this._ui.lastValidationResult); this._ui.lastValidationResult = this.validationResult, this._manageStatusClass(), this._manageErrorsMessages(t), this._actualizeTriggers(), !t.kept.length && !t.added.length || this._failedOnce || (this._failedOnce = !0, this._actualizeTriggers()) } }, getErrorsMessages: function () { if (!0 === this.validationResult) return []; for (var t = [], e = 0; e < this.validationResult.length; e++)t.push(this.validationResult[e].errorMessage || this._getErrorMessage(this.validationResult[e].assert)); return t }, addError: function (t, e) { var i = 1 < arguments.length && void 0 !== e ? e : {}, r = i.message, n = i.assert, s = i.updateClass, a = void 0 === s || s; this._buildUI(), this._addError(t, { message: r, assert: n }), a && this._errorClass() }, updateError: function (t, e) { var i = 1 < arguments.length && void 0 !== e ? e : {}, r = i.message, n = i.assert, s = i.updateClass, a = void 0 === s || s; this._buildUI(), this._updateError(t, { message: r, assert: n }), a && this._errorClass() }, removeError: function (t, e) { var i = (1 < arguments.length && void 0 !== e ? e : {}).updateClass, r = void 0 === i || i; this._buildUI(), this._removeError(t), r && this._manageStatusClass() }, _manageStatusClass: function () { this.hasConstraints() && this.needsValidation() && !0 === this.validationResult ? this._successClass() : 0 < this.validationResult.length ? this._errorClass() : this._resetClass() }, _manageErrorsMessages: function (t) { if (void 0 === this.options.errorsMessagesDisabled) { if (void 0 !== this.options.errorMessage) return t.added.length || t.kept.length ? (this._insertErrorWrapper(), 0 === this._ui.$errorsWrapper.find(".parsley-custom-error-message").length && this._ui.$errorsWrapper.append(h(this.options.errorTemplate).addClass("parsley-custom-error-message")), this._ui.$errorClassHandler.attr("aria-describedby", this._ui.errorsWrapperId), this._ui.$errorsWrapper.addClass("filled").attr("aria-hidden", "false").find(".parsley-custom-error-message").html(this.options.errorMessage)) : (this._ui.$errorClassHandler.removeAttr("aria-describedby"), this._ui.$errorsWrapper.removeClass("filled").attr("aria-hidden", "true").find(".parsley-custom-error-message").remove()); for (var e = 0; e < t.removed.length; e++)this._removeError(t.removed[e].assert.name); for (e = 0; e < t.added.length; e++)this._addError(t.added[e].assert.name, { message: t.added[e].errorMessage, assert: t.added[e].assert }); for (e = 0; e < t.kept.length; e++)this._updateError(t.kept[e].assert.name, { message: t.kept[e].errorMessage, assert: t.kept[e].assert }) } }, _addError: function (t, e) { var i = e.message, r = e.assert; this._insertErrorWrapper(), this._ui.$errorClassHandler.attr("aria-describedby", this._ui.errorsWrapperId), this._ui.$errorsWrapper.addClass("filled").attr("aria-hidden", "false").append(h(this.options.errorTemplate).addClass("parsley-" + t).html(i || this._getErrorMessage(r))) }, _updateError: function (t, e) { var i = e.message, r = e.assert; this._ui.$errorsWrapper.addClass("filled").find(".parsley-" + t).html(i || this._getErrorMessage(r)) }, _removeError: function (t) { this._ui.$errorClassHandler.removeAttr("aria-describedby"), this._ui.$errorsWrapper.removeClass("filled").attr("aria-hidden", "true").find(".parsley-" + t).remove() }, _getErrorMessage: function (t) { var e = t.name + "Message"; return void 0 !== this.options[e] ? window.Parsley.formatMessage(this.options[e], t.requirements) : window.Parsley.getErrorMessage(t) }, _buildUI: function () { if (!this._ui && !1 !== this.options.uiEnabled) { var t = {}; this.element.setAttribute(this.options.namespace + "id", this.__id__), t.$errorClassHandler = this._manageClassHandler(), t.errorsWrapperId = "parsley-id-" + (this.options.multiple ? "multiple-" + this.options.multiple : this.__id__), t.$errorsWrapper = h(this.options.errorsWrapper).attr("id", t.errorsWrapperId), t.lastValidationResult = [], t.validationInformationVisible = !1, this._ui = t } }, _manageClassHandler: function () { if ("string" == typeof this.options.classHandler && h(this.options.classHandler).length) return h(this.options.classHandler); var t = this.options.classHandler; if ("string" == typeof this.options.classHandler && "function" == typeof window[this.options.classHandler] && (t = window[this.options.classHandler]), "function" == typeof t) { var e = t.call(this, this); if (void 0 !== e && e.length) return e } else { if ("object" === n(t) && t instanceof jQuery && t.length) return t; t && d.warn("The class handler `" + t + "` does not exist in DOM nor as a global JS function") } return this._inputHolder() }, _inputHolder: function () { return this.options.multiple && "SELECT" !== this.element.nodeName ? this.$element.parent() : this.$element }, _insertErrorWrapper: function () { var t = this.options.errorsContainer; if (0 !== this._ui.$errorsWrapper.parent().length) return this._ui.$errorsWrapper.parent(); if ("string" == typeof t) { if (h(t).length) return h(t).append(this._ui.$errorsWrapper); "function" == typeof window[t] ? t = window[t] : d.warn("The errors container `" + t + "` does not exist in DOM nor as a global JS function") } return "function" == typeof t && (t = t.call(this, this)), "object" === n(t) && t.length ? t.append(this._ui.$errorsWrapper) : this._inputHolder().after(this._ui.$errorsWrapper) }, _actualizeTriggers: function () { var t, e = this, i = this._findRelated(); i.off(".Parsley"), this._failedOnce ? i.on(d.namespaceEvents(this.options.triggerAfterFailure, "Parsley"), function () { e._validateIfNeeded() }) : (t = d.namespaceEvents(this.options.trigger, "Parsley")) && i.on(t, function (t) { e._validateIfNeeded(t) }) }, _validateIfNeeded: function (t) { var e = this; t && /key|input/.test(t.type) && (!this._ui || !this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold || (this.options.debounce ? (window.clearTimeout(this._debounced), this._debounced = window.setTimeout(function () { return e.validate() }, this.options.debounce)) : this.validate()) }, _resetUI: function () { this._failedOnce = !1, this._actualizeTriggers(), void 0 !== this._ui && (this._ui.$errorsWrapper.removeClass("filled").children().remove(), this._resetClass(), this._ui.lastValidationResult = [], this._ui.validationInformationVisible = !1) }, _destroyUI: function () { this._resetUI(), void 0 !== this._ui && this._ui.$errorsWrapper.remove(), delete this._ui }, _successClass: function () { this._ui.validationInformationVisible = !0, this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass) }, _errorClass: function () { this._ui.validationInformationVisible = !0, this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass) }, _resetClass: function () { this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass) } }; function y(t, e, i) { this.__class__ = "Form", this.element = t, this.$element = h(t), this.domOptions = e, this.options = i, this.parent = window.Parsley, this.fields = [], this.validationResult = null } var _ = { pending: null, resolved: !0, rejected: !1 }; y.prototype = { onSubmitValidate: function (t) { var e = this; if (!0 !== t.parsley) { var i = this._submitSource || this.$element.find(d._SubmitSelector)[0]; if (this._submitSource = null, this.$element.find(".parsley-synthetic-submit-button").prop("disabled", !0), !i || null === i.getAttribute("formnovalidate")) { window.Parsley._remoteCache = {}; var r = this.whenValidate({ event: t }); "resolved" === r.state() && !1 !== this._trigger("submit") || (t.stopImmediatePropagation(), t.preventDefault(), "pending" === r.state() && r.done(function () { e._submit(i) })) } } }, onSubmitButton: function (t) { this._submitSource = t.currentTarget }, _submit: function (t) { if (!1 !== this._trigger("submit")) { if (t) { var e = this.$element.find(".parsley-synthetic-submit-button").prop("disabled", !1); 0 === e.length && (e = h('<input class="parsley-synthetic-submit-button" type="hidden">').appendTo(this.$element)), e.attr({ name: t.getAttribute("name"), value: t.getAttribute("value") }) } this.$element.trigger(l(h.Event("submit"), { parsley: !0 })) } }, validate: function (t) { if (1 <= arguments.length && !h.isPlainObject(t)) { d.warnOnce("Calling validate on a parsley form without passing arguments as an object is deprecated."); var e = Array.prototype.slice.call(arguments); t = { group: e[0], force: e[1], event: e[2] } } return _[this.whenValidate(t).state()] }, whenValidate: function (t) { var e, i = this, r = 0 < arguments.length && void 0 !== t ? t : {}, n = r.group, s = r.force, a = r.event; (this.submitEvent = a) && (this.submitEvent = l({}, a, { preventDefault: function () { d.warnOnce("Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`"), i.validationResult = !1 } })), this.validationResult = !0, this._trigger("validate"), this._refreshFields(); var o = this._withoutReactualizingFormOptions(function () { return h.map(i.fields, function (t) { return t.whenValidate({ force: s, group: n }) }) }); return (e = d.all(o).done(function () { i._trigger("success") }).fail(function () { i.validationResult = !1, i.focus(), i._trigger("error") }).always(function () { i._trigger("validated") })).pipe.apply(e, u(this._pipeAccordingToValidationResult())) }, isValid: function (t) { if (1 <= arguments.length && !h.isPlainObject(t)) { d.warnOnce("Calling isValid on a parsley form without passing arguments as an object is deprecated."); var e = Array.prototype.slice.call(arguments); t = { group: e[0], force: e[1] } } return _[this.whenValid(t).state()] }, whenValid: function (t) { var e = this, i = 0 < arguments.length && void 0 !== t ? t : {}, r = i.group, n = i.force; this._refreshFields(); var s = this._withoutReactualizingFormOptions(function () { return h.map(e.fields, function (t) { return t.whenValid({ group: r, force: n }) }) }); return d.all(s) }, refresh: function () { return this._refreshFields(), this }, reset: function () { for (var t = 0; t < this.fields.length; t++)this.fields[t].reset(); this._trigger("reset") }, destroy: function () { this._destroyUI(); for (var t = 0; t < this.fields.length; t++)this.fields[t].destroy(); this.$element.removeData("Parsley"), this._trigger("destroy") }, _refreshFields: function () { return this.actualizeOptions()._bindFields() }, _bindFields: function () { var n = this, t = this.fields; return this.fields = [], this.fieldsMappedById = {}, this._withoutReactualizingFormOptions(function () { n.$element.find(n.options.inputs).not(n.options.excluded).not("[".concat(n.options.namespace, "excluded=true]")).each(function (t, e) { var i = new window.Parsley.Factory(e, {}, n); if ("Field" === i.__class__ || "FieldMultiple" === i.__class__) { var r = i.__class__ + "-" + i.__id__; void 0 === n.fieldsMappedById[r] && (n.fieldsMappedById[r] = i, n.fields.push(i)) } }), h.each(d.difference(t, n.fields), function (t, e) { e.reset() }) }), this }, _withoutReactualizingFormOptions: function (t) { var e = this.actualizeOptions; this.actualizeOptions = function () { return this }; var i = t(); return this.actualizeOptions = e, i }, _trigger: function (t) { return this.trigger("form:" + t) } }; function b(t, e, i, r, n) { var s = window.Parsley._validatorRegistry.validators[e], a = new c(s); l(this, { validator: a, name: e, requirements: i, priority: r = r || t.options[e + "Priority"] || a.priority, isDomConstraint: n = !0 === n }), this._parseRequirements(t.options) } function w(t, e, i, r) { this.__class__ = "Field", this.element = t, this.$element = h(t), void 0 !== r && (this.parent = r), this.options = i, this.domOptions = e, this.constraints = [], this.constraintsByName = {}, this.validationResult = !0, this._bindConstraints() } var F = { pending: null, resolved: !0, rejected: !(b.prototype = { validate: function (t, e) { var i; return (i = this.validator).validate.apply(i, [t].concat(u(this.requirementList), [e])) }, _parseRequirements: function (i) { var r = this; this.requirementList = this.validator.parseRequirements(this.requirements, function (t) { return i[r.name + ((e = t)[0].toUpperCase() + e.slice(1))]; var e }) } }) }; w.prototype = { validate: function (t) { 1 <= arguments.length && !h.isPlainObject(t) && (d.warnOnce("Calling validate on a parsley field without passing arguments as an object is deprecated."), t = { options: t }); var e = this.whenValidate(t); if (!e) return !0; switch (e.state()) { case "pending": return null; case "resolved": return !0; case "rejected": return this.validationResult } }, whenValidate: function (t) { var e, i = this, r = 0 < arguments.length && void 0 !== t ? t : {}, n = r.force, s = r.group; if (this.refresh(), !s || this._isInGroup(s)) return this.value = this.getValue(), this._trigger("validate"), (e = this.whenValid({ force: n, value: this.value, _refreshed: !0 }).always(function () { i._reflowUI() }).done(function () { i._trigger("success") }).fail(function () { i._trigger("error") }).always(function () { i._trigger("validated") })).pipe.apply(e, u(this._pipeAccordingToValidationResult())) }, hasConstraints: function () { return 0 !== this.constraints.length }, needsValidation: function (t) { return void 0 === t && (t = this.getValue()), !(!t.length && !this._isRequired() && void 0 === this.options.validateIfEmpty) }, _isInGroup: function (t) { return Array.isArray(this.options.group) ? -1 !== h.inArray(t, this.options.group) : this.options.group === t }, isValid: function (t) { if (1 <= arguments.length && !h.isPlainObject(t)) { d.warnOnce("Calling isValid on a parsley field without passing arguments as an object is deprecated."); var e = Array.prototype.slice.call(arguments); t = { force: e[0], value: e[1] } } var i = this.whenValid(t); return !i || F[i.state()] }, whenValid: function (t) { var r = this, e = 0 < arguments.length && void 0 !== t ? t : {}, i = e.force, n = void 0 !== i && i, s = e.value, a = e.group; if (e._refreshed || this.refresh(), !a || this._isInGroup(a)) { if (this.validationResult = !0, !this.hasConstraints()) return h.when(); if (null == s && (s = this.getValue()), !this.needsValidation(s) && !0 !== n) return h.when(); var o = this._getGroupedConstraints(), l = []; return h.each(o, function (t, e) { var i = d.all(h.map(e, function (t) { return r._validateConstraint(s, t) })); if (l.push(i), "rejected" === i.state()) return !1 }), d.all(l) } }, _validateConstraint: function (t, e) { var i = this, r = e.validate(t, this); return !1 === r && (r = h.Deferred().reject()), d.all([r]).fail(function (t) { i.validationResult instanceof Array || (i.validationResult = []), i.validationResult.push({ assert: e, errorMessage: "string" == typeof t && t }) }) }, getValue: function () { var t; return null == (t = "function" == typeof this.options.value ? this.options.value(this) : void 0 !== this.options.value ? this.options.value : this.$element.val()) ? "" : this._handleWhitespace(t) }, reset: function () { return this._resetUI(), this._trigger("reset") }, destroy: function () { this._destroyUI(), this.$element.removeData("Parsley"), this.$element.removeData("FieldMultiple"), this._trigger("destroy") }, refresh: function () { return this._refreshConstraints(), this }, _refreshConstraints: function () { return this.actualizeOptions()._bindConstraints() }, refreshConstraints: function () { return d.warnOnce("Parsley's refreshConstraints is deprecated. Please use refresh"), this.refresh() }, addConstraint: function (t, e, i, r) { if (window.Parsley._validatorRegistry.validators[t]) { var n = new b(this, t, e, i, r); "undefined" !== this.constraintsByName[n.name] && this.removeConstraint(n.name), this.constraints.push(n), this.constraintsByName[n.name] = n } return this }, removeConstraint: function (t) { for (var e = 0; e < this.constraints.length; e++)if (t === this.constraints[e].name) { this.constraints.splice(e, 1); break } return delete this.constraintsByName[t], this }, updateConstraint: function (t, e, i) { return this.removeConstraint(t).addConstraint(t, e, i) }, _bindConstraints: function () { for (var t = [], e = {}, i = 0; i < this.constraints.length; i++)!1 === this.constraints[i].isDomConstraint && (t.push(this.constraints[i]), e[this.constraints[i].name] = this.constraints[i]); for (var r in this.constraints = t, this.constraintsByName = e, this.options) this.addConstraint(r, this.options[r], void 0, !0); return this._bindHtml5Constraints() }, _bindHtml5Constraints: function () { null !== this.element.getAttribute("required") && this.addConstraint("required", !0, void 0, !0), null !== this.element.getAttribute("pattern") && this.addConstraint("pattern", this.element.getAttribute("pattern"), void 0, !0); var t = this.element.getAttribute("min"), e = this.element.getAttribute("max"); null !== t && null !== e ? this.addConstraint("range", [t, e], void 0, !0) : null !== t ? this.addConstraint("min", t, void 0, !0) : null !== e && this.addConstraint("max", e, void 0, !0), null !== this.element.getAttribute("minlength") && null !== this.element.getAttribute("maxlength") ? this.addConstraint("length", [this.element.getAttribute("minlength"), this.element.getAttribute("maxlength")], void 0, !0) : null !== this.element.getAttribute("minlength") ? this.addConstraint("minlength", this.element.getAttribute("minlength"), void 0, !0) : null !== this.element.getAttribute("maxlength") && this.addConstraint("maxlength", this.element.getAttribute("maxlength"), void 0, !0); var i = d.getType(this.element); return "number" === i ? this.addConstraint("type", ["number", { step: this.element.getAttribute("step") || "1", base: t || this.element.getAttribute("value") }], void 0, !0) : /^(email|url|range|date)$/i.test(i) ? this.addConstraint("type", i, void 0, !0) : this }, _isRequired: function () { return void 0 !== this.constraintsByName.required && !1 !== this.constraintsByName.required.requirements }, _trigger: function (t) { return this.trigger("field:" + t) }, _handleWhitespace: function (t) { return !0 === this.options.trimValue && d.warnOnce('data-parsley-trim-value="true" is deprecated, please use data-parsley-whitespace="trim"'), "squish" === this.options.whitespace && (t = t.replace(/\s{2,}/g, " ")), "trim" !== this.options.whitespace && "squish" !== this.options.whitespace && !0 !== this.options.trimValue || (t = d.trimString(t)), t }, _isDateInput: function () { var t = this.constraintsByName.type; return t && "date" === t.requirements }, _getGroupedConstraints: function () { if (!1 === this.options.priorityEnabled) return [this.constraints]; for (var t = [], e = {}, i = 0; i < this.constraints.length; i++) { var r = this.constraints[i].priority; e[r] || t.push(e[r] = []), e[r].push(this.constraints[i]) } return t.sort(function (t, e) { return e[0].priority - t[0].priority }), t } }; function C() { this.__class__ = "FieldMultiple" } C.prototype = { addElement: function (t) { return this.$elements.push(t), this }, _refreshConstraints: function () { var t; if (this.constraints = [], "SELECT" === this.element.nodeName) return this.actualizeOptions()._bindConstraints(), this; for (var e = 0; e < this.$elements.length; e++)if (h("html").has(this.$elements[e]).length) { t = this.$elements[e].data("FieldMultiple")._refreshConstraints().constraints; for (var i = 0; i < t.length; i++)this.addConstraint(t[i].name, t[i].requirements, t[i].priority, t[i].isDomConstraint) } else this.$elements.splice(e, 1); return this }, getValue: function () { if ("function" == typeof this.options.value) return this.options.value(this); if (void 0 !== this.options.value) return this.options.value; if ("INPUT" === this.element.nodeName) { var t = d.getType(this.element); if ("radio" === t) return this._findRelated().filter(":checked").val() || ""; if ("checkbox" === t) { var e = []; return this._findRelated().filter(":checked").each(function () { e.push(h(this).val()) }), e } } return "SELECT" === this.element.nodeName && null === this.$element.val() ? [] : this.$element.val() }, _init: function () { return this.$elements = [this.$element], this } }; function A(t, e, i) { this.element = t, this.$element = h(t); var r = this.$element.data("Parsley"); if (r) return void 0 !== i && r.parent === window.Parsley && (r.parent = i, r._resetOptions(r.options)), "object" === n(e) && l(r.options, e), r; if (!this.$element.length) throw new Error("You must bind Parsley on an existing element."); if (void 0 !== i && "Form" !== i.__class__) throw new Error("Parent instance must be a Form instance"); return this.parent = i || window.Parsley, this.init(e) } A.prototype = { init: function (t) { return this.__class__ = "Parsley", this.__version__ = "2.9.2", this.__id__ = d.generateID(), this._resetOptions(t), "FORM" === this.element.nodeName || d.checkAttr(this.element, this.options.namespace, "validate") && !this.$element.is(this.options.inputs) ? this.bind("parsleyForm") : this.isMultiple() ? this.handleMultiple() : this.bind("parsleyField") }, isMultiple: function () { var t = d.getType(this.element); return "radio" === t || "checkbox" === t || "SELECT" === this.element.nodeName && null !== this.element.getAttribute("multiple") }, handleMultiple: function () { var t, e, r = this; if (this.options.multiple = this.options.multiple || (t = this.element.getAttribute("name")) || this.element.getAttribute("id"), "SELECT" === this.element.nodeName && null !== this.element.getAttribute("multiple")) return this.options.multiple = this.options.multiple || this.__id__, this.bind("parsleyFieldMultiple"); if (!this.options.multiple) return d.warn("To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.", this.$element), this; this.options.multiple = this.options.multiple.replace(/(:|\.|\[|\]|\{|\}|\$)/g, ""), t && h('input[name="' + t + '"]').each(function (t, e) { var i = d.getType(e); "radio" !== i && "checkbox" !== i || e.setAttribute(r.options.namespace + "multiple", r.options.multiple) }); for (var i = this._findRelated(), n = 0; n < i.length; n++)if (void 0 !== (e = h(i.get(n)).data("Parsley"))) { this.$element.data("FieldMultiple") || e.addElement(this.$element); break } return this.bind("parsleyField", !0), e || this.bind("parsleyFieldMultiple") }, bind: function (t, e) { var i; switch (t) { case "parsleyForm": i = h.extend(new y(this.element, this.domOptions, this.options), new r, window.ParsleyExtend)._bindFields(); break; case "parsleyField": i = h.extend(new w(this.element, this.domOptions, this.options, this.parent), new r, window.ParsleyExtend); break; case "parsleyFieldMultiple": i = h.extend(new w(this.element, this.domOptions, this.options, this.parent), new C, new r, window.ParsleyExtend)._init(); break; default: throw new Error(t + "is not a supported Parsley type") }return this.options.multiple && d.setAttr(this.element, this.options.namespace, "multiple", this.options.multiple), void 0 !== e ? this.$element.data("FieldMultiple", i) : (this.$element.data("Parsley", i), i._actualizeTriggers(), i._trigger("init")), i } }; var E = h.fn.jquery.split("."); if (parseInt(E[0]) <= 1 && parseInt(E[1]) < 8) throw "The loaded version of jQuery is too old. Please upgrade to 1.8.x or better."; E.forEach || d.warn("Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim"); var x = l(new r, { element: document, $element: h(document), actualizeOptions: null, _resetOptions: null, Factory: A, version: "2.9.2" }); l(w.prototype, v.Field, r.prototype), l(y.prototype, v.Form, r.prototype), l(A.prototype, r.prototype), h.fn.parsley = h.fn.psly = function (t) { if (1 < this.length) { var e = []; return this.each(function () { e.push(h(this).parsley(t)) }), e } if (0 != this.length) return new A(this[0], t) }, void 0 === window.ParsleyExtend && (window.ParsleyExtend = {}), x.options = l(d.objectCreate(s), window.ParsleyConfig), window.ParsleyConfig = x.options, window.Parsley = window.psly = x, x.Utils = d, window.ParsleyUtils = {}, h.each(d, function (t, e) { "function" == typeof e && (window.ParsleyUtils[t] = function () { return d.warnOnce("Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead."), d[t].apply(d, arguments) }) }); var $ = window.Parsley._validatorRegistry = new a(window.ParsleyConfig.validators, window.ParsleyConfig.i18n); window.ParsleyValidator = {}, h.each("setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator hasValidator".split(" "), function (t, e) { window.Parsley[e] = function () { return $[e].apply($, arguments) }, window.ParsleyValidator[e] = function () { var t; return d.warnOnce("Accessing the method '".concat(e, "' through Validator is deprecated. Simply call 'window.Parsley.").concat(e, "(...)'")), (t = window.Parsley)[e].apply(t, arguments) } }), window.Parsley.UI = v, window.ParsleyUI = { removeError: function (t, e, i) { var r = !0 !== i; return d.warnOnce("Accessing UI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method."), t.removeError(e, { updateClass: r }) }, getErrorsMessages: function (t) { return d.warnOnce("Accessing UI is deprecated. Call 'getErrorsMessages' on the instance directly."), t.getErrorsMessages() } }, h.each("addError updateError".split(" "), function (t, a) { window.ParsleyUI[a] = function (t, e, i, r, n) { var s = !0 !== n; return d.warnOnce("Accessing UI is deprecated. Call '".concat(a, "' on the instance directly. Please comment in issue 1073 as to your need to call this method.")), t[a](e, { message: i, assert: r, updateClass: s }) } }), !1 !== window.ParsleyConfig.autoBind && h(function () { h("[data-parsley-validate]").length && h("[data-parsley-validate]").parsley() }); function V() { d.warnOnce("Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley") } var P = h({}); function O(e, i) { return e.parsleyAdaptedCallback || (e.parsleyAdaptedCallback = function () { var t = Array.prototype.slice.call(arguments, 0); t.unshift(this), e.apply(i || P, t) }), e.parsleyAdaptedCallback } var T = "parsley:"; function M(t) { return 0 === t.lastIndexOf(T, 0) ? t.substr(T.length) : t } return h.listen = function (t, e) { var i; if (V(), "object" === n(arguments[1]) && "function" == typeof arguments[2] && (i = arguments[1], e = arguments[2]), "function" != typeof e) throw new Error("Wrong parameters"); window.Parsley.on(M(t), O(e, i)) }, h.listenTo = function (t, e, i) { if (V(), !(t instanceof w || t instanceof y)) throw new Error("Must give Parsley instance"); if ("string" != typeof e || "function" != typeof i) throw new Error("Wrong parameters"); t.on(M(e), O(i)) }, h.unsubscribe = function (t, e) { if (V(), "string" != typeof t || "function" != typeof e) throw new Error("Wrong arguments"); window.Parsley.off(M(t), e.parsleyAdaptedCallback) }, h.unsubscribeTo = function (t, e) { if (V(), !(t instanceof w || t instanceof y)) throw new Error("Must give Parsley instance"); t.off(M(e)) }, h.unsubscribeAll = function (e) { V(), window.Parsley.off(M(e)), h("form,input,textarea,select").each(function () { var t = h(this).data("Parsley"); t && t.off(M(e)) }) }, h.emit = function (t, e) { V(); var i = e instanceof w || e instanceof y, r = Array.prototype.slice.call(arguments, i ? 2 : 1); r.unshift(M(t)), i || (e = window.Parsley), e.trigger.apply(e, u(r)) }, h.extend(!0, x, { asyncValidators: { default: { fn: function (t) { return 200 <= t.status && t.status < 300 }, url: !1 }, reverse: { fn: function (t) { return t.status < 200 || 300 <= t.status }, url: !1 } }, addAsyncValidator: function (t, e, i, r) { return x.asyncValidators[t] = { fn: e, url: i || !1, options: r || {} }, this } }), x.addValidator("remote", { requirementType: { "": "string", validator: "string", reverse: "boolean", options: "object" }, validateString: function (t, e, i, r) { var n, s, a = {}, o = i.validator || (!0 === i.reverse ? "reverse" : "default"); if (void 0 === x.asyncValidators[o]) throw new Error("Calling an undefined async validator: `" + o + "`"); -1 < (e = x.asyncValidators[o].url || e).indexOf("{value}") ? e = e.replace("{value}", encodeURIComponent(t)) : a[r.element.getAttribute("name") || r.element.getAttribute("id")] = t; var l = h.extend(!0, i.options || {}, x.asyncValidators[o].options); n = h.extend(!0, {}, { url: e, data: a, type: "GET" }, l), r.trigger("field:ajaxoptions", r, n), s = h.param(n), void 0 === x._remoteCache && (x._remoteCache = {}); function u() { var t = x.asyncValidators[o].fn.call(r, d, e, i); return t = t || h.Deferred().reject(), h.when(t) } var d = x._remoteCache[s] = x._remoteCache[s] || h.ajax(n); return d.then(u, u) }, priority: -1 }), x.on("form:submit", function () { x._remoteCache = {} }), r.prototype.addAsyncValidator = function () { return d.warnOnce("Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`"), x.addAsyncValidator.apply(x, arguments) }, x.addMessages("en", { defaultMessage: "This value seems to be invalid.", type: { email: "This value should be a valid email.", url: "This value should be a valid url.", number: "This value should be a valid number.", integer: "This value should be a valid integer.", digits: "This value should be digits.", alphanum: "This value should be alphanumeric." }, notblank: "This value should not be blank.", required: "This value is required.", pattern: "This value seems to be invalid.", min: "This value should be greater than or equal to %s.", max: "This value should be lower than or equal to %s.", range: "This value should be between %s and %s.", minlength: "This value is too short. It should have %s characters or more.", maxlength: "This value is too long. It should have %s characters or fewer.", length: "This value length is invalid. It should be between %s and %s characters long.", mincheck: "You must select at least %s choices.", maxcheck: "You must select %s choices or fewer.", check: "You must select between %s and %s choices.", equalto: "This value should be the same.", euvatin: "It's not a valid VAT Identification Number." }), x.setLocale("en"), (new function () { var r = this, n = window || global; l(this, { isNativeEvent: function (t) { return t.originalEvent && !1 !== t.originalEvent.isTrusted }, fakeInputEvent: function (t) { r.isNativeEvent(t) && h(t.target).trigger("input") }, misbehaves: function (t) { r.isNativeEvent(t) && (r.behavesOk(t), h(document).on("change.inputevent", t.data.selector, r.fakeInputEvent), r.fakeInputEvent(t)) }, behavesOk: function (t) { r.isNativeEvent(t) && h(document).off("input.inputevent", t.data.selector, r.behavesOk).off("change.inputevent", t.data.selector, r.misbehaves) }, install: function () { if (!n.inputEventPatched) { n.inputEventPatched = "0.0.3"; for (var t = 0, e = ["select", 'input[type="checkbox"]', 'input[type="radio"]', 'input[type="file"]']; t < e.length; t++) { var i = e[t]; h(document).on("input.inputevent", i, { selector: i }, r.behavesOk).on("change.inputevent", i, { selector: i }, r.misbehaves) } } }, uninstall: function () { delete n.inputEventPatched, h(document).off(".inputevent") } }) }).install(), x });

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"jquery":2}],50:[function(require,module,exports){
/**
 * @popperjs/core v2.11.8 - MIT License
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Popper={})}(this,(function(e){"use strict";function t(e){if(null==e)return window;if("[object Window]"!==e.toString()){var t=e.ownerDocument;return t&&t.defaultView||window}return e}function n(e){return e instanceof t(e).Element||e instanceof Element}function r(e){return e instanceof t(e).HTMLElement||e instanceof HTMLElement}function o(e){return"undefined"!=typeof ShadowRoot&&(e instanceof t(e).ShadowRoot||e instanceof ShadowRoot)}var i=Math.max,a=Math.min,s=Math.round;function f(){var e=navigator.userAgentData;return null!=e&&e.brands&&Array.isArray(e.brands)?e.brands.map((function(e){return e.brand+"/"+e.version})).join(" "):navigator.userAgent}function c(){return!/^((?!chrome|android).)*safari/i.test(f())}function p(e,o,i){void 0===o&&(o=!1),void 0===i&&(i=!1);var a=e.getBoundingClientRect(),f=1,p=1;o&&r(e)&&(f=e.offsetWidth>0&&s(a.width)/e.offsetWidth||1,p=e.offsetHeight>0&&s(a.height)/e.offsetHeight||1);var u=(n(e)?t(e):window).visualViewport,l=!c()&&i,d=(a.left+(l&&u?u.offsetLeft:0))/f,h=(a.top+(l&&u?u.offsetTop:0))/p,m=a.width/f,v=a.height/p;return{width:m,height:v,top:h,right:d+m,bottom:h+v,left:d,x:d,y:h}}function u(e){var n=t(e);return{scrollLeft:n.pageXOffset,scrollTop:n.pageYOffset}}function l(e){return e?(e.nodeName||"").toLowerCase():null}function d(e){return((n(e)?e.ownerDocument:e.document)||window.document).documentElement}function h(e){return p(d(e)).left+u(e).scrollLeft}function m(e){return t(e).getComputedStyle(e)}function v(e){var t=m(e),n=t.overflow,r=t.overflowX,o=t.overflowY;return/auto|scroll|overlay|hidden/.test(n+o+r)}function y(e,n,o){void 0===o&&(o=!1);var i,a,f=r(n),c=r(n)&&function(e){var t=e.getBoundingClientRect(),n=s(t.width)/e.offsetWidth||1,r=s(t.height)/e.offsetHeight||1;return 1!==n||1!==r}(n),m=d(n),y=p(e,c,o),g={scrollLeft:0,scrollTop:0},b={x:0,y:0};return(f||!f&&!o)&&(("body"!==l(n)||v(m))&&(g=(i=n)!==t(i)&&r(i)?{scrollLeft:(a=i).scrollLeft,scrollTop:a.scrollTop}:u(i)),r(n)?((b=p(n,!0)).x+=n.clientLeft,b.y+=n.clientTop):m&&(b.x=h(m))),{x:y.left+g.scrollLeft-b.x,y:y.top+g.scrollTop-b.y,width:y.width,height:y.height}}function g(e){var t=p(e),n=e.offsetWidth,r=e.offsetHeight;return Math.abs(t.width-n)<=1&&(n=t.width),Math.abs(t.height-r)<=1&&(r=t.height),{x:e.offsetLeft,y:e.offsetTop,width:n,height:r}}function b(e){return"html"===l(e)?e:e.assignedSlot||e.parentNode||(o(e)?e.host:null)||d(e)}function x(e){return["html","body","#document"].indexOf(l(e))>=0?e.ownerDocument.body:r(e)&&v(e)?e:x(b(e))}function w(e,n){var r;void 0===n&&(n=[]);var o=x(e),i=o===(null==(r=e.ownerDocument)?void 0:r.body),a=t(o),s=i?[a].concat(a.visualViewport||[],v(o)?o:[]):o,f=n.concat(s);return i?f:f.concat(w(b(s)))}function O(e){return["table","td","th"].indexOf(l(e))>=0}function j(e){return r(e)&&"fixed"!==m(e).position?e.offsetParent:null}function E(e){for(var n=t(e),i=j(e);i&&O(i)&&"static"===m(i).position;)i=j(i);return i&&("html"===l(i)||"body"===l(i)&&"static"===m(i).position)?n:i||function(e){var t=/firefox/i.test(f());if(/Trident/i.test(f())&&r(e)&&"fixed"===m(e).position)return null;var n=b(e);for(o(n)&&(n=n.host);r(n)&&["html","body"].indexOf(l(n))<0;){var i=m(n);if("none"!==i.transform||"none"!==i.perspective||"paint"===i.contain||-1!==["transform","perspective"].indexOf(i.willChange)||t&&"filter"===i.willChange||t&&i.filter&&"none"!==i.filter)return n;n=n.parentNode}return null}(e)||n}var D="top",A="bottom",L="right",P="left",M="auto",k=[D,A,L,P],W="start",B="end",H="viewport",T="popper",R=k.reduce((function(e,t){return e.concat([t+"-"+W,t+"-"+B])}),[]),S=[].concat(k,[M]).reduce((function(e,t){return e.concat([t,t+"-"+W,t+"-"+B])}),[]),V=["beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite"];function q(e){var t=new Map,n=new Set,r=[];function o(e){n.add(e.name),[].concat(e.requires||[],e.requiresIfExists||[]).forEach((function(e){if(!n.has(e)){var r=t.get(e);r&&o(r)}})),r.push(e)}return e.forEach((function(e){t.set(e.name,e)})),e.forEach((function(e){n.has(e.name)||o(e)})),r}function C(e,t){var n=t.getRootNode&&t.getRootNode();if(e.contains(t))return!0;if(n&&o(n)){var r=t;do{if(r&&e.isSameNode(r))return!0;r=r.parentNode||r.host}while(r)}return!1}function N(e){return Object.assign({},e,{left:e.x,top:e.y,right:e.x+e.width,bottom:e.y+e.height})}function I(e,r,o){return r===H?N(function(e,n){var r=t(e),o=d(e),i=r.visualViewport,a=o.clientWidth,s=o.clientHeight,f=0,p=0;if(i){a=i.width,s=i.height;var u=c();(u||!u&&"fixed"===n)&&(f=i.offsetLeft,p=i.offsetTop)}return{width:a,height:s,x:f+h(e),y:p}}(e,o)):n(r)?function(e,t){var n=p(e,!1,"fixed"===t);return n.top=n.top+e.clientTop,n.left=n.left+e.clientLeft,n.bottom=n.top+e.clientHeight,n.right=n.left+e.clientWidth,n.width=e.clientWidth,n.height=e.clientHeight,n.x=n.left,n.y=n.top,n}(r,o):N(function(e){var t,n=d(e),r=u(e),o=null==(t=e.ownerDocument)?void 0:t.body,a=i(n.scrollWidth,n.clientWidth,o?o.scrollWidth:0,o?o.clientWidth:0),s=i(n.scrollHeight,n.clientHeight,o?o.scrollHeight:0,o?o.clientHeight:0),f=-r.scrollLeft+h(e),c=-r.scrollTop;return"rtl"===m(o||n).direction&&(f+=i(n.clientWidth,o?o.clientWidth:0)-a),{width:a,height:s,x:f,y:c}}(d(e)))}function _(e,t,o,s){var f="clippingParents"===t?function(e){var t=w(b(e)),o=["absolute","fixed"].indexOf(m(e).position)>=0&&r(e)?E(e):e;return n(o)?t.filter((function(e){return n(e)&&C(e,o)&&"body"!==l(e)})):[]}(e):[].concat(t),c=[].concat(f,[o]),p=c[0],u=c.reduce((function(t,n){var r=I(e,n,s);return t.top=i(r.top,t.top),t.right=a(r.right,t.right),t.bottom=a(r.bottom,t.bottom),t.left=i(r.left,t.left),t}),I(e,p,s));return u.width=u.right-u.left,u.height=u.bottom-u.top,u.x=u.left,u.y=u.top,u}function F(e){return e.split("-")[0]}function U(e){return e.split("-")[1]}function z(e){return["top","bottom"].indexOf(e)>=0?"x":"y"}function X(e){var t,n=e.reference,r=e.element,o=e.placement,i=o?F(o):null,a=o?U(o):null,s=n.x+n.width/2-r.width/2,f=n.y+n.height/2-r.height/2;switch(i){case D:t={x:s,y:n.y-r.height};break;case A:t={x:s,y:n.y+n.height};break;case L:t={x:n.x+n.width,y:f};break;case P:t={x:n.x-r.width,y:f};break;default:t={x:n.x,y:n.y}}var c=i?z(i):null;if(null!=c){var p="y"===c?"height":"width";switch(a){case W:t[c]=t[c]-(n[p]/2-r[p]/2);break;case B:t[c]=t[c]+(n[p]/2-r[p]/2)}}return t}function Y(e){return Object.assign({},{top:0,right:0,bottom:0,left:0},e)}function G(e,t){return t.reduce((function(t,n){return t[n]=e,t}),{})}function J(e,t){void 0===t&&(t={});var r=t,o=r.placement,i=void 0===o?e.placement:o,a=r.strategy,s=void 0===a?e.strategy:a,f=r.boundary,c=void 0===f?"clippingParents":f,u=r.rootBoundary,l=void 0===u?H:u,h=r.elementContext,m=void 0===h?T:h,v=r.altBoundary,y=void 0!==v&&v,g=r.padding,b=void 0===g?0:g,x=Y("number"!=typeof b?b:G(b,k)),w=m===T?"reference":T,O=e.rects.popper,j=e.elements[y?w:m],E=_(n(j)?j:j.contextElement||d(e.elements.popper),c,l,s),P=p(e.elements.reference),M=X({reference:P,element:O,strategy:"absolute",placement:i}),W=N(Object.assign({},O,M)),B=m===T?W:P,R={top:E.top-B.top+x.top,bottom:B.bottom-E.bottom+x.bottom,left:E.left-B.left+x.left,right:B.right-E.right+x.right},S=e.modifiersData.offset;if(m===T&&S){var V=S[i];Object.keys(R).forEach((function(e){var t=[L,A].indexOf(e)>=0?1:-1,n=[D,A].indexOf(e)>=0?"y":"x";R[e]+=V[n]*t}))}return R}var K={placement:"bottom",modifiers:[],strategy:"absolute"};function Q(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return!t.some((function(e){return!(e&&"function"==typeof e.getBoundingClientRect)}))}function Z(e){void 0===e&&(e={});var t=e,r=t.defaultModifiers,o=void 0===r?[]:r,i=t.defaultOptions,a=void 0===i?K:i;return function(e,t,r){void 0===r&&(r=a);var i,s,f={placement:"bottom",orderedModifiers:[],options:Object.assign({},K,a),modifiersData:{},elements:{reference:e,popper:t},attributes:{},styles:{}},c=[],p=!1,u={state:f,setOptions:function(r){var i="function"==typeof r?r(f.options):r;l(),f.options=Object.assign({},a,f.options,i),f.scrollParents={reference:n(e)?w(e):e.contextElement?w(e.contextElement):[],popper:w(t)};var s,p,d=function(e){var t=q(e);return V.reduce((function(e,n){return e.concat(t.filter((function(e){return e.phase===n})))}),[])}((s=[].concat(o,f.options.modifiers),p=s.reduce((function(e,t){var n=e[t.name];return e[t.name]=n?Object.assign({},n,t,{options:Object.assign({},n.options,t.options),data:Object.assign({},n.data,t.data)}):t,e}),{}),Object.keys(p).map((function(e){return p[e]}))));return f.orderedModifiers=d.filter((function(e){return e.enabled})),f.orderedModifiers.forEach((function(e){var t=e.name,n=e.options,r=void 0===n?{}:n,o=e.effect;if("function"==typeof o){var i=o({state:f,name:t,instance:u,options:r}),a=function(){};c.push(i||a)}})),u.update()},forceUpdate:function(){if(!p){var e=f.elements,t=e.reference,n=e.popper;if(Q(t,n)){f.rects={reference:y(t,E(n),"fixed"===f.options.strategy),popper:g(n)},f.reset=!1,f.placement=f.options.placement,f.orderedModifiers.forEach((function(e){return f.modifiersData[e.name]=Object.assign({},e.data)}));for(var r=0;r<f.orderedModifiers.length;r++)if(!0!==f.reset){var o=f.orderedModifiers[r],i=o.fn,a=o.options,s=void 0===a?{}:a,c=o.name;"function"==typeof i&&(f=i({state:f,options:s,name:c,instance:u})||f)}else f.reset=!1,r=-1}}},update:(i=function(){return new Promise((function(e){u.forceUpdate(),e(f)}))},function(){return s||(s=new Promise((function(e){Promise.resolve().then((function(){s=void 0,e(i())}))}))),s}),destroy:function(){l(),p=!0}};if(!Q(e,t))return u;function l(){c.forEach((function(e){return e()})),c=[]}return u.setOptions(r).then((function(e){!p&&r.onFirstUpdate&&r.onFirstUpdate(e)})),u}}var $={passive:!0};var ee={name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(e){var n=e.state,r=e.instance,o=e.options,i=o.scroll,a=void 0===i||i,s=o.resize,f=void 0===s||s,c=t(n.elements.popper),p=[].concat(n.scrollParents.reference,n.scrollParents.popper);return a&&p.forEach((function(e){e.addEventListener("scroll",r.update,$)})),f&&c.addEventListener("resize",r.update,$),function(){a&&p.forEach((function(e){e.removeEventListener("scroll",r.update,$)})),f&&c.removeEventListener("resize",r.update,$)}},data:{}};var te={name:"popperOffsets",enabled:!0,phase:"read",fn:function(e){var t=e.state,n=e.name;t.modifiersData[n]=X({reference:t.rects.reference,element:t.rects.popper,strategy:"absolute",placement:t.placement})},data:{}},ne={top:"auto",right:"auto",bottom:"auto",left:"auto"};function re(e){var n,r=e.popper,o=e.popperRect,i=e.placement,a=e.variation,f=e.offsets,c=e.position,p=e.gpuAcceleration,u=e.adaptive,l=e.roundOffsets,h=e.isFixed,v=f.x,y=void 0===v?0:v,g=f.y,b=void 0===g?0:g,x="function"==typeof l?l({x:y,y:b}):{x:y,y:b};y=x.x,b=x.y;var w=f.hasOwnProperty("x"),O=f.hasOwnProperty("y"),j=P,M=D,k=window;if(u){var W=E(r),H="clientHeight",T="clientWidth";if(W===t(r)&&"static"!==m(W=d(r)).position&&"absolute"===c&&(H="scrollHeight",T="scrollWidth"),W=W,i===D||(i===P||i===L)&&a===B)M=A,b-=(h&&W===k&&k.visualViewport?k.visualViewport.height:W[H])-o.height,b*=p?1:-1;if(i===P||(i===D||i===A)&&a===B)j=L,y-=(h&&W===k&&k.visualViewport?k.visualViewport.width:W[T])-o.width,y*=p?1:-1}var R,S=Object.assign({position:c},u&&ne),V=!0===l?function(e,t){var n=e.x,r=e.y,o=t.devicePixelRatio||1;return{x:s(n*o)/o||0,y:s(r*o)/o||0}}({x:y,y:b},t(r)):{x:y,y:b};return y=V.x,b=V.y,p?Object.assign({},S,((R={})[M]=O?"0":"",R[j]=w?"0":"",R.transform=(k.devicePixelRatio||1)<=1?"translate("+y+"px, "+b+"px)":"translate3d("+y+"px, "+b+"px, 0)",R)):Object.assign({},S,((n={})[M]=O?b+"px":"",n[j]=w?y+"px":"",n.transform="",n))}var oe={name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(e){var t=e.state,n=e.options,r=n.gpuAcceleration,o=void 0===r||r,i=n.adaptive,a=void 0===i||i,s=n.roundOffsets,f=void 0===s||s,c={placement:F(t.placement),variation:U(t.placement),popper:t.elements.popper,popperRect:t.rects.popper,gpuAcceleration:o,isFixed:"fixed"===t.options.strategy};null!=t.modifiersData.popperOffsets&&(t.styles.popper=Object.assign({},t.styles.popper,re(Object.assign({},c,{offsets:t.modifiersData.popperOffsets,position:t.options.strategy,adaptive:a,roundOffsets:f})))),null!=t.modifiersData.arrow&&(t.styles.arrow=Object.assign({},t.styles.arrow,re(Object.assign({},c,{offsets:t.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:f})))),t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-placement":t.placement})},data:{}};var ie={name:"applyStyles",enabled:!0,phase:"write",fn:function(e){var t=e.state;Object.keys(t.elements).forEach((function(e){var n=t.styles[e]||{},o=t.attributes[e]||{},i=t.elements[e];r(i)&&l(i)&&(Object.assign(i.style,n),Object.keys(o).forEach((function(e){var t=o[e];!1===t?i.removeAttribute(e):i.setAttribute(e,!0===t?"":t)})))}))},effect:function(e){var t=e.state,n={popper:{position:t.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(t.elements.popper.style,n.popper),t.styles=n,t.elements.arrow&&Object.assign(t.elements.arrow.style,n.arrow),function(){Object.keys(t.elements).forEach((function(e){var o=t.elements[e],i=t.attributes[e]||{},a=Object.keys(t.styles.hasOwnProperty(e)?t.styles[e]:n[e]).reduce((function(e,t){return e[t]="",e}),{});r(o)&&l(o)&&(Object.assign(o.style,a),Object.keys(i).forEach((function(e){o.removeAttribute(e)})))}))}},requires:["computeStyles"]};var ae={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(e){var t=e.state,n=e.options,r=e.name,o=n.offset,i=void 0===o?[0,0]:o,a=S.reduce((function(e,n){return e[n]=function(e,t,n){var r=F(e),o=[P,D].indexOf(r)>=0?-1:1,i="function"==typeof n?n(Object.assign({},t,{placement:e})):n,a=i[0],s=i[1];return a=a||0,s=(s||0)*o,[P,L].indexOf(r)>=0?{x:s,y:a}:{x:a,y:s}}(n,t.rects,i),e}),{}),s=a[t.placement],f=s.x,c=s.y;null!=t.modifiersData.popperOffsets&&(t.modifiersData.popperOffsets.x+=f,t.modifiersData.popperOffsets.y+=c),t.modifiersData[r]=a}},se={left:"right",right:"left",bottom:"top",top:"bottom"};function fe(e){return e.replace(/left|right|bottom|top/g,(function(e){return se[e]}))}var ce={start:"end",end:"start"};function pe(e){return e.replace(/start|end/g,(function(e){return ce[e]}))}function ue(e,t){void 0===t&&(t={});var n=t,r=n.placement,o=n.boundary,i=n.rootBoundary,a=n.padding,s=n.flipVariations,f=n.allowedAutoPlacements,c=void 0===f?S:f,p=U(r),u=p?s?R:R.filter((function(e){return U(e)===p})):k,l=u.filter((function(e){return c.indexOf(e)>=0}));0===l.length&&(l=u);var d=l.reduce((function(t,n){return t[n]=J(e,{placement:n,boundary:o,rootBoundary:i,padding:a})[F(n)],t}),{});return Object.keys(d).sort((function(e,t){return d[e]-d[t]}))}var le={name:"flip",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name;if(!t.modifiersData[r]._skip){for(var o=n.mainAxis,i=void 0===o||o,a=n.altAxis,s=void 0===a||a,f=n.fallbackPlacements,c=n.padding,p=n.boundary,u=n.rootBoundary,l=n.altBoundary,d=n.flipVariations,h=void 0===d||d,m=n.allowedAutoPlacements,v=t.options.placement,y=F(v),g=f||(y===v||!h?[fe(v)]:function(e){if(F(e)===M)return[];var t=fe(e);return[pe(e),t,pe(t)]}(v)),b=[v].concat(g).reduce((function(e,n){return e.concat(F(n)===M?ue(t,{placement:n,boundary:p,rootBoundary:u,padding:c,flipVariations:h,allowedAutoPlacements:m}):n)}),[]),x=t.rects.reference,w=t.rects.popper,O=new Map,j=!0,E=b[0],k=0;k<b.length;k++){var B=b[k],H=F(B),T=U(B)===W,R=[D,A].indexOf(H)>=0,S=R?"width":"height",V=J(t,{placement:B,boundary:p,rootBoundary:u,altBoundary:l,padding:c}),q=R?T?L:P:T?A:D;x[S]>w[S]&&(q=fe(q));var C=fe(q),N=[];if(i&&N.push(V[H]<=0),s&&N.push(V[q]<=0,V[C]<=0),N.every((function(e){return e}))){E=B,j=!1;break}O.set(B,N)}if(j)for(var I=function(e){var t=b.find((function(t){var n=O.get(t);if(n)return n.slice(0,e).every((function(e){return e}))}));if(t)return E=t,"break"},_=h?3:1;_>0;_--){if("break"===I(_))break}t.placement!==E&&(t.modifiersData[r]._skip=!0,t.placement=E,t.reset=!0)}},requiresIfExists:["offset"],data:{_skip:!1}};function de(e,t,n){return i(e,a(t,n))}var he={name:"preventOverflow",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name,o=n.mainAxis,s=void 0===o||o,f=n.altAxis,c=void 0!==f&&f,p=n.boundary,u=n.rootBoundary,l=n.altBoundary,d=n.padding,h=n.tether,m=void 0===h||h,v=n.tetherOffset,y=void 0===v?0:v,b=J(t,{boundary:p,rootBoundary:u,padding:d,altBoundary:l}),x=F(t.placement),w=U(t.placement),O=!w,j=z(x),M="x"===j?"y":"x",k=t.modifiersData.popperOffsets,B=t.rects.reference,H=t.rects.popper,T="function"==typeof y?y(Object.assign({},t.rects,{placement:t.placement})):y,R="number"==typeof T?{mainAxis:T,altAxis:T}:Object.assign({mainAxis:0,altAxis:0},T),S=t.modifiersData.offset?t.modifiersData.offset[t.placement]:null,V={x:0,y:0};if(k){if(s){var q,C="y"===j?D:P,N="y"===j?A:L,I="y"===j?"height":"width",_=k[j],X=_+b[C],Y=_-b[N],G=m?-H[I]/2:0,K=w===W?B[I]:H[I],Q=w===W?-H[I]:-B[I],Z=t.elements.arrow,$=m&&Z?g(Z):{width:0,height:0},ee=t.modifiersData["arrow#persistent"]?t.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},te=ee[C],ne=ee[N],re=de(0,B[I],$[I]),oe=O?B[I]/2-G-re-te-R.mainAxis:K-re-te-R.mainAxis,ie=O?-B[I]/2+G+re+ne+R.mainAxis:Q+re+ne+R.mainAxis,ae=t.elements.arrow&&E(t.elements.arrow),se=ae?"y"===j?ae.clientTop||0:ae.clientLeft||0:0,fe=null!=(q=null==S?void 0:S[j])?q:0,ce=_+ie-fe,pe=de(m?a(X,_+oe-fe-se):X,_,m?i(Y,ce):Y);k[j]=pe,V[j]=pe-_}if(c){var ue,le="x"===j?D:P,he="x"===j?A:L,me=k[M],ve="y"===M?"height":"width",ye=me+b[le],ge=me-b[he],be=-1!==[D,P].indexOf(x),xe=null!=(ue=null==S?void 0:S[M])?ue:0,we=be?ye:me-B[ve]-H[ve]-xe+R.altAxis,Oe=be?me+B[ve]+H[ve]-xe-R.altAxis:ge,je=m&&be?function(e,t,n){var r=de(e,t,n);return r>n?n:r}(we,me,Oe):de(m?we:ye,me,m?Oe:ge);k[M]=je,V[M]=je-me}t.modifiersData[r]=V}},requiresIfExists:["offset"]};var me={name:"arrow",enabled:!0,phase:"main",fn:function(e){var t,n=e.state,r=e.name,o=e.options,i=n.elements.arrow,a=n.modifiersData.popperOffsets,s=F(n.placement),f=z(s),c=[P,L].indexOf(s)>=0?"height":"width";if(i&&a){var p=function(e,t){return Y("number"!=typeof(e="function"==typeof e?e(Object.assign({},t.rects,{placement:t.placement})):e)?e:G(e,k))}(o.padding,n),u=g(i),l="y"===f?D:P,d="y"===f?A:L,h=n.rects.reference[c]+n.rects.reference[f]-a[f]-n.rects.popper[c],m=a[f]-n.rects.reference[f],v=E(i),y=v?"y"===f?v.clientHeight||0:v.clientWidth||0:0,b=h/2-m/2,x=p[l],w=y-u[c]-p[d],O=y/2-u[c]/2+b,j=de(x,O,w),M=f;n.modifiersData[r]=((t={})[M]=j,t.centerOffset=j-O,t)}},effect:function(e){var t=e.state,n=e.options.element,r=void 0===n?"[data-popper-arrow]":n;null!=r&&("string"!=typeof r||(r=t.elements.popper.querySelector(r)))&&C(t.elements.popper,r)&&(t.elements.arrow=r)},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function ve(e,t,n){return void 0===n&&(n={x:0,y:0}),{top:e.top-t.height-n.y,right:e.right-t.width+n.x,bottom:e.bottom-t.height+n.y,left:e.left-t.width-n.x}}function ye(e){return[D,L,A,P].some((function(t){return e[t]>=0}))}var ge={name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(e){var t=e.state,n=e.name,r=t.rects.reference,o=t.rects.popper,i=t.modifiersData.preventOverflow,a=J(t,{elementContext:"reference"}),s=J(t,{altBoundary:!0}),f=ve(a,r),c=ve(s,o,i),p=ye(f),u=ye(c);t.modifiersData[n]={referenceClippingOffsets:f,popperEscapeOffsets:c,isReferenceHidden:p,hasPopperEscaped:u},t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-reference-hidden":p,"data-popper-escaped":u})}},be=Z({defaultModifiers:[ee,te,oe,ie]}),xe=[ee,te,oe,ie,ae,le,he,me,ge],we=Z({defaultModifiers:xe});e.applyStyles=ie,e.arrow=me,e.computeStyles=oe,e.createPopper=we,e.createPopperLite=be,e.defaultModifiers=xe,e.detectOverflow=J,e.eventListeners=ee,e.flip=le,e.hide=ge,e.offset=ae,e.popperGenerator=Z,e.popperOffsets=te,e.preventOverflow=he,Object.defineProperty(e,"__esModule",{value:!0})}));

},{}],51:[function(require,module,exports){
/*!
 * @splidejs/splide-extension-grid
 * Version  : 0.4.1
 * License  : MIT
 * Copyright: 2022 Naotoshi Fujita
*/(function(O){typeof define=="function"&&define.amd?define(O):O()})(function(){"use strict";function O(n){n.length=0}function S(n,t,i){return Array.prototype.slice.call(n,t,i)}function T(n){return n.bind.apply(n,[null].concat(S(arguments,1)))}function V(n,t){return typeof t===n}var Q=Array.isArray;T(V,"function"),T(V,"string"),T(V,"undefined");function X(n){return Q(n)?n:[n]}function Z(n,t){X(n).forEach(t)}var hn=Object.keys;function En(n,t,i){if(n){var r=hn(n);r=i?r.reverse():r;for(var f=0;f<r.length;f++){var a=r[f];if(a!=="__proto__"&&t(n[a],a)===!1)break}}return n}function gn(n){return S(arguments,1).forEach(function(t){En(t,function(i,r){n[r]=t[r]})}),n}var j="splide";function mn(){var n=[];function t(u,c,l,v){f(u,c,function(d,g,m){var _="addEventListener"in d,C=_?d.removeEventListener.bind(d,g,l,v):d.removeListener.bind(d,l);_?d.addEventListener(g,l,v):d.addListener(l),n.push([d,g,m,l,C])})}function i(u,c,l){f(u,c,function(v,d,g){n=n.filter(function(m){return m[0]===v&&m[1]===d&&m[2]===g&&(!l||m[3]===l)?(m[4](),!1):!0})})}function r(u,c,l){var v,d=!0;return typeof CustomEvent=="function"?v=new CustomEvent(c,{bubbles:d,detail:l}):(v=document.createEvent("CustomEvent"),v.initCustomEvent(c,d,!1,l)),u.dispatchEvent(v),v}function f(u,c,l){Z(u,function(v){v&&Z(c,function(d){d.split(" ").forEach(function(g){var m=g.split(".");l(v,m[0],m[1])})})})}function a(){n.forEach(function(u){u[4]()}),O(n)}return{bind:t,unbind:i,dispatch:r,destroy:a}}var pn="visible",yn="hidden",H="refresh",wn="updated",_n="destroy";function k(n){var t=n?n.event.bus:document.createDocumentFragment(),i=mn();function r(a,u){i.bind(t,X(a).join(" "),function(c){u.apply(u,Q(c.detail)?c.detail:[])})}function f(a){i.dispatch(t,a,S(arguments,1))}return n&&n.event.on(_n,i.destroy),gn(i,{bus:t,on:r,off:T(i.unbind,t),emit:f})}var Cn=j,$=j+"__slide",An=$+"__container";function nn(n){n.length=0}function I(n,t,i){return Array.prototype.slice.call(n,t,i)}function B(n){return n.bind.apply(n,[null].concat(I(arguments,1)))}function N(n,t){return typeof t===n}function bn(n){return!P(n)&&N("object",n)}var F=Array.isArray;B(N,"function");var G=B(N,"string"),Ln=B(N,"undefined");function P(n){return n===null}function Dn(n){return n instanceof HTMLElement}function U(n){return F(n)?n:[n]}function A(n,t){U(n).forEach(t)}function tn(n,t){return n.push.apply(n,U(t)),n}function rn(n,t,i){n&&A(t,function(r){r&&n.classList[i?"add":"remove"](r)})}function q(n,t){rn(n,G(t)?t.split(" "):t,!0)}function R(n,t){A(t,n.appendChild.bind(n))}function On(n,t){return Dn(n)&&(n.msMatchesSelector||n.matches).call(n,t)}function Tn(n,t){var i=n?I(n.children):[];return t?i.filter(function(r){return On(r,t)}):i}function on(n,t){return t?Tn(n,t)[0]:n.firstElementChild}var en=Object.keys;function un(n,t,i){if(n){var r=en(n);r=i?r.reverse():r;for(var f=0;f<r.length;f++){var a=r[f];if(a!=="__proto__"&&t(n[a],a)===!1)break}}return n}function $n(n){return I(arguments,1).forEach(function(t){un(t,function(i,r){n[r]=t[r]})}),n}function In(n,t){U(t||en(n)).forEach(function(i){delete n[i]})}function J(n,t){A(n,function(i){A(t,function(r){i&&i.removeAttribute(r)})})}function K(n,t,i){bn(t)?un(t,function(r,f){K(n,f,r)}):A(n,function(r){P(i)||i===""?J(r,t):r.setAttribute(t,String(i))})}function fn(n,t,i){var r=document.createElement(n);return t&&(G(t)?q(r,t):K(r,t)),i&&R(i,r),r}function p(n,t,i){if(Ln(i))return getComputedStyle(n)[t];P(i)||(n.style[t]=""+i)}function Nn(n,t){return n&&n.classList.contains(t)}function Rn(n){A(n,function(t){t&&t.parentNode&&t.parentNode.removeChild(t)})}function an(n,t){return t?I(n.querySelectorAll(t)):[]}function cn(n,t){rn(n,t,!1)}function x(n){return G(n)?n:n?n+"px":""}var xn="splide";function Mn(n,t){if(!n)throw new Error("["+xn+"] "+(t||""))}var Sn=Math.min,Un=Math.max,qn=Math.floor,Jn=Math.ceil,Kn=Math.abs;function Vn(n){return n<10?"0"+n:""+n}var sn=$+"__row",z=$+"--col",Hn={rows:1,cols:1,dimensions:[],gap:{}};function Bn(n){function t(){var f=n.rows,a=n.cols,u=n.dimensions;return F(u)&&u.length?u:[[f,a]]}function i(f){var a=t();return a[Sn(f,a.length-1)]}function r(f){for(var a=t(),u,c,l=0,v=0;v<a.length;v++){var d=a[v];if(u=d[0]||1,c=d[1]||1,l+=u*c,f<l)break}return Mn(u&&c,"Invalid dimension"),[u,c]}return{get:i,getAt:r}}function Fn(n,t,i){var r=k(n),f=r.on,a=r.destroy,u=n.Components,c=n.options,l=u.Direction.resolve,v=u.Slides.forEach;function d(){m(),c.slideFocus&&(f(pn,W),f(yn,Y))}function g(){v(function(e){var s=e.slide;D(s,!1),M(s).forEach(function(o){J(o,"style")}),b(s).forEach(function(o){L(o,!0),J(o,"style")})}),a()}function m(){v(function(e){var s=e.slide,o=i.get(e.isClone?e.slideIndex:e.index),h=o[0],E=o[1];_(h,s),C(E,s),b(e.slide).forEach(function(y,w){y.id=e.slide.id+"-col"+Vn(w+1),n.options.cover&&L(y)})})}function _(e,s){var o=t.gap.row,h="calc("+100/e+"%"+(o?" - "+x(o)+" * "+(e-1)/e:"")+")";M(s).forEach(function(E,y,w){p(E,"height",h),p(E,"display","flex"),p(E,"margin","0 0 "+x(o)+" 0"),p(E,"padding",0),y===w.length-1&&p(E,"marginBottom",0)})}function C(e,s){var o=t.gap.col,h="calc("+100/e+"%"+(o?" - "+x(o)+" * "+(e-1)/e:"")+")";b(s).forEach(function(E,y,w){p(E,"width",h),y!==w.length-1&&p(E,l("marginRight"),x(o))})}function L(e,s){var o=on(e,"."+An),h=on(o||e,"img");h&&h.src&&(p(o||e,"background",s?"":'center/cover no-repeat url("'+h.src+'")'),p(h,"display",s?"":"none"))}function M(e){return an(e,"."+sn)}function b(e){return an(e,"."+z)}function D(e,s){b(e).forEach(function(o){K(o,"tabindex",s?0:null)})}function W(e){D(e.slide,!0)}function Y(e){D(e.slide,!1)}return{mount:d,destroy:g}}function Gn(n,t,i){var r=k(n),f=r.on,a=r.off,u=t.Elements,c={},l=Bn(c),v=Fn(n,c,l),d=Cn+"--grid",g=[];function m(){_(),f(wn,_)}function _(){In(c),$n(c,Hn,i.grid||{}),Y()?(C(),tn(g,u.slides),q(n.root,d),R(u.list,b()),a(H),f(H,M),L()):e()&&(C(),L())}function C(){if(e()){var s=u.slides;v.destroy(),g.forEach(function(o){cn(o,z),R(u.list,o)}),Rn(s),cn(n.root,d),nn(s),tn(s,g),nn(g),a(H)}}function L(){n.refresh()}function M(){e()&&v.mount()}function b(){var s=[],o=0,h=0,E,y;return g.forEach(function(w,Pn){var dn=l.getAt(Pn),vn=dn[0],ln=dn[1];h||(o||(E=fn(w.tagName,$),s.push(E)),y=D(vn,w,E)),W(ln,w,y),++h>=ln&&(h=0,o=++o>=vn?0:o)}),s}function D(s,o,h){var E=o.tagName.toLowerCase()==="li"?"ul":"div";return fn(E,sn,h)}function W(s,o,h){return q(o,z),R(h,o),o}function Y(){if(i.grid){var s=c.rows,o=c.cols,h=c.dimensions;return s>1||o>1||F(h)&&h.length>0}return!1}function e(){return Nn(n.root,d)}return{mount:m,destroy:C}}typeof window<"u"&&(window.splide=window.splide||{},window.splide.Extensions=window.splide.Extensions||{},window.splide.Extensions.Grid=Gn)});

},{}],52:[function(require,module,exports){
function r(n,t){for(var i=0;i<t.length;i++){var r=t[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function Jt(n,t,i){t&&r(n.prototype,t),i&&r(n,i),Object.defineProperty(n,"prototype",{writable:!1})}
/*!
 * Splide.js
 * Version  : 4.1.4
 * License  : MIT
 * Copyright: 2022 Naotoshi Fujita
 */
var n,t;n=this,t=function(){"use strict";var v="(prefers-reduced-motion: reduce)",G=4,rn=5,r={CREATED:1,MOUNTED:2,IDLE:3,MOVING:G,SCROLLING:rn,DRAGGING:6,DESTROYED:7};function D(n){n.length=0}function o(n,t,i){return Array.prototype.slice.call(n,t,i)}function R(n){return n.bind.apply(n,[null].concat(o(arguments,1)))}function on(){}var p=setTimeout;function h(n){return requestAnimationFrame(n)}function u(n,t){return typeof t===n}function un(n){return!c(n)&&u("object",n)}var e=Array.isArray,x=R(u,"function"),C=R(u,"string"),en=R(u,"undefined");function c(n){return null===n}function m(n){try{return n instanceof(n.ownerDocument.defaultView||window).HTMLElement}catch(n){return!1}}function y(n){return e(n)?n:[n]}function g(n,t){y(n).forEach(t)}function b(n,t){return-1<n.indexOf(t)}function k(n,t){return n.push.apply(n,y(t)),n}function A(t,n,i){t&&g(n,function(n){n&&t.classList[i?"add":"remove"](n)})}function M(n,t){A(n,C(t)?t.split(" "):t,!0)}function L(n,t){g(t,n.appendChild.bind(n))}function O(n,i){g(n,function(n){var t=(i||n).parentNode;t&&t.insertBefore(n,i)})}function cn(n,t){return m(n)&&(n.msMatchesSelector||n.matches).call(n,t)}function S(n,t){n=n?o(n.children):[];return t?n.filter(function(n){return cn(n,t)}):n}function fn(n,t){return t?S(n,t)[0]:n.firstElementChild}var E=Object.keys;function w(t,i,n){t&&(n?E(t).reverse():E(t)).forEach(function(n){"__proto__"!==n&&i(t[n],n)})}function an(r){return o(arguments,1).forEach(function(i){w(i,function(n,t){r[t]=i[t]})}),r}function d(i){return o(arguments,1).forEach(function(n){w(n,function(n,t){e(n)?i[t]=n.slice():un(n)?i[t]=d({},un(i[t])?i[t]:{},n):i[t]=n})}),i}function sn(t,n){g(n||E(t),function(n){delete t[n]})}function P(n,i){g(n,function(t){g(i,function(n){t&&t.removeAttribute(n)})})}function I(i,t,r){un(t)?w(t,function(n,t){I(i,t,n)}):g(i,function(n){c(r)||""===r?P(n,t):n.setAttribute(t,String(r))})}function j(n,t,i){n=document.createElement(n);return t&&(C(t)?M:I)(n,t),i&&L(i,n),n}function _(n,t,i){if(en(i))return getComputedStyle(n)[t];c(i)||(n.style[t]=""+i)}function ln(n,t){_(n,"display",t)}function dn(n){n.setActive&&n.setActive()||n.focus({preventScroll:!0})}function z(n,t){return n.getAttribute(t)}function vn(n,t){return n&&n.classList.contains(t)}function N(n){return n.getBoundingClientRect()}function T(n){g(n,function(n){n&&n.parentNode&&n.parentNode.removeChild(n)})}function hn(n){return fn((new DOMParser).parseFromString(n,"text/html").body)}function F(n,t){n.preventDefault(),t&&(n.stopPropagation(),n.stopImmediatePropagation())}function pn(n,t){return n&&n.querySelector(t)}function gn(n,t){return t?o(n.querySelectorAll(t)):[]}function X(n,t){A(n,t,!1)}function mn(n){return n.timeStamp}function W(n){return C(n)?n:n?n+"px":""}var yn="splide",f="data-"+yn;function bn(n,t){if(!n)throw new Error("["+yn+"] "+(t||""))}var Y=Math.min,wn=Math.max,xn=Math.floor,kn=Math.ceil,U=Math.abs;function Sn(n,t,i){return U(n-t)<i}function En(n,t,i,r){var o=Y(t,i),t=wn(t,i);return r?o<n&&n<t:o<=n&&n<=t}function q(n,t,i){var r=Y(t,i),t=wn(t,i);return Y(wn(r,n),t)}function Ln(n){return(0<n)-(n<0)}function On(t,n){return g(n,function(n){t=t.replace("%s",""+n)}),t}function An(n){return n<10?"0"+n:""+n}var _n={};function zn(){var c=[];function i(n,i,r){g(n,function(t){t&&g(i,function(n){n.split(" ").forEach(function(n){n=n.split(".");r(t,n[0],n[1])})})})}return{bind:function(n,t,u,e){i(n,t,function(n,t,i){var r="addEventListener"in n,o=r?n.removeEventListener.bind(n,t,u,e):n.removeListener.bind(n,u);r?n.addEventListener(t,u,e):n.addListener(u),c.push([n,t,i,u,o])})},unbind:function(n,t,o){i(n,t,function(t,i,r){c=c.filter(function(n){return!!(n[0]!==t||n[1]!==i||n[2]!==r||o&&n[3]!==o)||(n[4](),!1)})})},dispatch:function(n,t,i){var r;return"function"==typeof CustomEvent?r=new CustomEvent(t,{bubbles:!0,detail:i}):(r=document.createEvent("CustomEvent")).initCustomEvent(t,!0,!1,i),n.dispatchEvent(r),r},destroy:function(){c.forEach(function(n){n[4]()}),D(c)}}}var B="mounted",H="move",Dn="moved",Mn="click",Pn="active",In="inactive",Rn="visible",Cn="hidden",J="refresh",K="updated",jn="resize",Nn="resized",Tn="scroll",V="scrolled",a="destroy",Gn="navigation:mounted",Fn="autoplay:play",Xn="autoplay:pause",Wn="lazyload:loaded",Yn="sk",Un="sh";function Q(n){var i=n?n.event.bus:document.createDocumentFragment(),r=zn();return n&&n.event.on(a,r.destroy),an(r,{bus:i,on:function(n,t){r.bind(i,y(n).join(" "),function(n){t.apply(t,e(n.detail)?n.detail:[])})},off:R(r.unbind,i),emit:function(n){r.dispatch(i,n,o(arguments,1))}})}function qn(t,n,i,r){var o,u,e=Date.now,c=0,f=!0,a=0;function s(){if(!f){if(c=t?Y((e()-o)/t,1):1,i&&i(c),1<=c&&(n(),o=e(),r&&++a>=r))return l();u=h(s)}}function l(){f=!0}function d(){u&&cancelAnimationFrame(u),f=!(u=c=0)}return{start:function(n){n||d(),o=e()-(n?c*t:0),f=!1,u=h(s)},rewind:function(){o=e(),c=0,i&&i(c)},pause:l,cancel:d,set:function(n){t=n},isPaused:function(){return f}}}function s(n){var t=n;return{set:function(n){t=n},is:function(n){return b(y(n),t)}}}var n="Arrow",Bn=n+"Left",Hn=n+"Right",t=n+"Up",n=n+"Down",Jn="ttb",l={width:["height"],left:["top","right"],right:["bottom","left"],x:["y"],X:["Y"],Y:["X"],ArrowLeft:[t,Hn],ArrowRight:[n,Bn]};var Z="role",$="tabindex",i="aria-",Kn=i+"controls",Vn=i+"current",Qn=i+"selected",nn=i+"label",Zn=i+"labelledby",$n=i+"hidden",nt=i+"orientation",tt=i+"roledescription",it=i+"live",rt=i+"busy",ot=i+"atomic",ut=[Z,$,"disabled",Kn,Vn,nn,Zn,$n,nt,tt],i=yn+"__",et=yn,ct=i+"track",ft=i+"list",at=i+"slide",st=at+"--clone",lt=at+"__container",dt=i+"arrows",vt=i+"arrow",ht=vt+"--prev",pt=vt+"--next",gt=i+"pagination",mt=gt+"__page",yt=i+"progress"+"__bar",bt=i+"toggle",wt=i+"sr",tn="is-active",xt="is-prev",kt="is-next",St="is-visible",Et="is-loading",Lt="is-focus-in",Ot="is-overflow",At=[tn,St,xt,kt,Et,Lt,Ot];var _t="touchstart mousedown",zt="touchmove mousemove",Dt="touchend touchcancel mouseup click";var Mt="slide",Pt="loop",It="fade";function Rt(o,r,t,u){var e,n=Q(o),i=n.on,c=n.emit,f=n.bind,a=o.Components,s=o.root,l=o.options,d=l.isNavigation,v=l.updateOnMove,h=l.i18n,p=l.pagination,g=l.slideFocus,m=a.Direction.resolve,y=z(u,"style"),b=z(u,nn),w=-1<t,x=fn(u,"."+lt);function k(){var n=o.splides.map(function(n){n=n.splide.Components.Slides.getAt(r);return n?n.slide.id:""}).join(" ");I(u,nn,On(h.slideX,(w?t:r)+1)),I(u,Kn,n),I(u,Z,g?"button":""),g&&P(u,tt)}function S(){e||E()}function E(){var n,t,i;e||(n=o.index,(i=L())!==vn(u,tn)&&(A(u,tn,i),I(u,Vn,d&&i||""),c(i?Pn:In,O)),i=function(){if(o.is(It))return L();var n=N(a.Elements.track),t=N(u),i=m("left",!0),r=m("right",!0);return xn(n[i])<=kn(t[i])&&xn(t[r])<=kn(n[r])}(),t=!i&&(!L()||w),o.state.is([G,rn])||I(u,$n,t||""),I(gn(u,l.focusableNodes||""),$,t?-1:""),g&&I(u,$,t?-1:0),i!==vn(u,St)&&(A(u,St,i),c(i?Rn:Cn,O)),i||document.activeElement!==u||(t=a.Slides.getAt(o.index))&&dn(t.slide),A(u,xt,r===n-1),A(u,kt,r===n+1))}function L(){var n=o.index;return n===r||l.cloneStatus&&n===t}var O={index:r,slideIndex:t,slide:u,container:x,isClone:w,mount:function(){w||(u.id=s.id+"-slide"+An(r+1),I(u,Z,p?"tabpanel":"group"),I(u,tt,h.slide),I(u,nn,b||On(h.slideLabel,[r+1,o.length]))),f(u,"click",R(c,Mn,O)),f(u,"keydown",R(c,Yn,O)),i([Dn,Un,V],E),i(Gn,k),v&&i(H,S)},destroy:function(){e=!0,n.destroy(),X(u,At),P(u,ut),I(u,"style",y),I(u,nn,b||"")},update:E,style:function(n,t,i){_(i&&x||u,n,t)},isWithin:function(n,t){return n=U(n-r),(n=w||!l.rewind&&!o.is(Pt)?n:Y(n,o.length-n))<=t}};return O}var Ct=f+"-interval";var jt={passive:!1,capture:!0};var Nt={Spacebar:" ",Right:Hn,Left:Bn,Up:t,Down:n};function Tt(n){return n=C(n)?n:n.key,Nt[n]||n}var Gt="keydown";var Ft=f+"-lazy",Xt=Ft+"-srcset",Wt="["+Ft+"], ["+Xt+"]";var Yt=[" ","Enter"];var Ut=Object.freeze({__proto__:null,Media:function(r,n,o){var u=r.state,t=o.breakpoints||{},e=o.reducedMotion||{},i=zn(),c=[];function f(n){n&&i.destroy()}function a(n,t){t=matchMedia(t);i.bind(t,"change",s),c.push([n,t])}function s(){var n=u.is(7),t=o.direction,i=c.reduce(function(n,t){return d(n,t[1].matches?t[0]:{})},{});sn(o),l(i),o.destroy?r.destroy("completely"===o.destroy):n?(f(!0),r.mount()):t!==o.direction&&r.refresh()}function l(n,t,i){d(o,n),t&&d(Object.getPrototypeOf(o),n),!i&&u.is(1)||r.emit(K,o)}return{setup:function(){var i="min"===o.mediaQuery;E(t).sort(function(n,t){return i?+n-+t:+t-+n}).forEach(function(n){a(t[n],"("+(i?"min":"max")+"-width:"+n+"px)")}),a(e,v),s()},destroy:f,reduce:function(n){matchMedia(v).matches&&(n?d(o,e):sn(o,E(e)))},set:l}},Direction:function(n,t,o){return{resolve:function(n,t,i){var r="rtl"!==(i=i||o.direction)||t?i===Jn?0:-1:1;return l[n]&&l[n][r]||n.replace(/width|left|right/i,function(n,t){n=l[n.toLowerCase()][r]||n;return 0<t?n.charAt(0).toUpperCase()+n.slice(1):n})},orient:function(n){return n*("rtl"===o.direction?1:-1)}}},Elements:function(n,t,i){var r,o,u,e=Q(n),c=e.on,f=e.bind,a=n.root,s=i.i18n,l={},d=[],v=[],h=[];function p(){r=y("."+ct),o=fn(r,"."+ft),bn(r&&o,"A track/list element is missing."),k(d,S(o,"."+at+":not(."+st+")")),w({arrows:dt,pagination:gt,prev:ht,next:pt,bar:yt,toggle:bt},function(n,t){l[t]=y("."+n)}),an(l,{root:a,track:r,list:o,slides:d});var n=a.id||function(n){return""+n+An(_n[n]=(_n[n]||0)+1)}(yn),t=i.role;a.id=n,r.id=r.id||n+"-track",o.id=o.id||n+"-list",!z(a,Z)&&"SECTION"!==a.tagName&&t&&I(a,Z,t),I(a,tt,s.carousel),I(o,Z,"presentation"),m()}function g(n){var t=ut.concat("style");D(d),X(a,v),X(r,h),P([r,o],t),P(a,n?t:["style",tt])}function m(){X(a,v),X(r,h),v=b(et),h=b(ct),M(a,v),M(r,h),I(a,nn,i.label),I(a,Zn,i.labelledby)}function y(n){n=pn(a,n);return n&&function(n,t){if(x(n.closest))return n.closest(t);for(var i=n;i&&1===i.nodeType&&!cn(i,t);)i=i.parentElement;return i}(n,"."+et)===a?n:void 0}function b(n){return[n+"--"+i.type,n+"--"+i.direction,i.drag&&n+"--draggable",i.isNavigation&&n+"--nav",n===et&&tn]}return an(l,{setup:p,mount:function(){c(J,g),c(J,p),c(K,m),f(document,_t+" keydown",function(n){u="keydown"===n.type},{capture:!0}),f(a,"focusin",function(){A(a,Lt,!!u)})},destroy:g})},Slides:function(r,o,u){var n=Q(r),t=n.on,e=n.emit,c=n.bind,f=(n=o.Elements).slides,a=n.list,s=[];function i(){f.forEach(function(n,t){d(n,t,-1)})}function l(){h(function(n){n.destroy()}),D(s)}function d(n,t,i){t=Rt(r,t,i,n);t.mount(),s.push(t),s.sort(function(n,t){return n.index-t.index})}function v(n){return n?p(function(n){return!n.isClone}):s}function h(n,t){v(t).forEach(n)}function p(t){return s.filter(x(t)?t:function(n){return C(t)?cn(n.slide,t):b(y(t),n.index)})}return{mount:function(){i(),t(J,l),t(J,i)},destroy:l,update:function(){h(function(n){n.update()})},register:d,get:v,getIn:function(n){var t=o.Controller,i=t.toIndex(n),r=t.hasFocus()?1:u.perPage;return p(function(n){return En(n.index,i,i+r-1)})},getAt:function(n){return p(n)[0]},add:function(n,o){g(n,function(n){var t,i,r;m(n=C(n)?hn(n):n)&&((t=f[o])?O(n,t):L(a,n),M(n,u.classes.slide),t=n,i=R(e,jn),t=gn(t,"img"),(r=t.length)?t.forEach(function(n){c(n,"load error",function(){--r||i()})}):i())}),e(J)},remove:function(n){T(p(n).map(function(n){return n.slide})),e(J)},forEach:h,filter:p,style:function(t,i,r){h(function(n){n.style(t,i,r)})},getLength:function(n){return(n?f:s).length},isEnough:function(){return s.length>u.perPage}}},Layout:function(t,n,i){var r,o,u,e=(a=Q(t)).on,c=a.bind,f=a.emit,a=n.Slides,s=n.Direction.resolve,l=(n=n.Elements).root,d=n.track,v=n.list,h=a.getAt,p=a.style;function g(){r=i.direction===Jn,_(l,"maxWidth",W(i.width)),_(d,s("paddingLeft"),y(!1)),_(d,s("paddingRight"),y(!0)),m(!0)}function m(n){var t=N(l);!n&&o.width===t.width&&o.height===t.height||(_(d,"height",function(){var n="";r&&(bn(n=b(),"height or heightRatio is missing."),n="calc("+n+" - "+y(!1)+" - "+y(!0)+")");return n}()),p(s("marginRight"),W(i.gap)),p("width",i.autoWidth?null:W(i.fixedWidth)||(r?"":w())),p("height",W(i.fixedHeight)||(r?i.autoHeight?null:w():b()),!0),o=t,f(Nn),u!==(u=O())&&(A(l,Ot,u),f("overflow",u)))}function y(n){var t=i.padding,n=s(n?"right":"left");return t&&W(t[n]||(un(t)?0:t))||"0px"}function b(){return W(i.height||N(v).width*i.heightRatio)}function w(){var n=W(i.gap);return"calc((100%"+(n&&" + "+n)+")/"+(i.perPage||1)+(n&&" - "+n)+")"}function x(){return N(v)[s("width")]}function k(n,t){n=h(n||0);return n?N(n.slide)[s("width")]+(t?0:L()):0}function S(n,t){var i,n=h(n);return n?(n=N(n.slide)[s("right")],i=N(v)[s("left")],U(n-i)+(t?0:L())):0}function E(n){return S(t.length-1)-S(0)+k(0,n)}function L(){var n=h(0);return n&&parseFloat(_(n.slide,s("marginRight")))||0}function O(){return t.is(It)||E(!0)>x()}return{mount:function(){var n,t,i;g(),c(window,"resize load",(n=R(f,jn),i=qn(t||0,n,null,1),function(){i.isPaused()&&i.start()})),e([K,J],g),e(jn,m)},resize:m,listSize:x,slideSize:k,sliderSize:E,totalSize:S,getPadding:function(n){return parseFloat(_(d,s("padding"+(n?"Right":"Left"))))||0},isOverflow:O}},Clones:function(c,i,f){var t,r=Q(c),n=r.on,a=i.Elements,s=i.Slides,o=i.Direction.resolve,l=[];function u(){if(n(J,d),n([K,jn],v),t=h()){var o=t,u=s.get().slice(),e=u.length;if(e){for(;u.length<o;)k(u,u);k(u.slice(-o),u.slice(0,o)).forEach(function(n,t){var i=t<o,r=function(n,t){n=n.cloneNode(!0);return M(n,f.classes.clone),n.id=c.root.id+"-clone"+An(t+1),n}(n.slide,t);i?O(r,u[0].slide):L(a.list,r),k(l,r),s.register(r,t-o+(i?0:e),n.index)})}i.Layout.resize(!0)}}function d(){e(),u()}function e(){T(l),D(l),r.destroy()}function v(){var n=h();t!==n&&(t<n||!n)&&r.emit(J)}function h(){var n,t=f.clones;return c.is(Pt)?en(t)&&(t=(n=f[o("fixedWidth")]&&i.Layout.slideSize(0))&&kn(N(a.track)[o("width")]/n)||f[o("autoWidth")]&&c.length||2*f.perPage):t=0,t}return{mount:u,destroy:e}},Move:function(r,c,o){var e,n=Q(r),t=n.on,f=n.emit,a=r.state.set,u=(n=c.Layout).slideSize,i=n.getPadding,s=n.totalSize,l=n.listSize,d=n.sliderSize,v=(n=c.Direction).resolve,h=n.orient,p=(n=c.Elements).list,g=n.track;function m(){c.Controller.isBusy()||(c.Scroll.cancel(),y(r.index),c.Slides.update())}function y(n){b(S(n,!0))}function b(n,t){r.is(It)||(t=t?n:function(n){{var t,i;r.is(Pt)&&(t=k(n),i=t>c.Controller.getEnd(),(t<0||i)&&(n=w(n,i)))}return n}(n),_(p,"transform","translate"+v("X")+"("+t+"px)"),n!==t&&f(Un))}function w(n,t){var i=n-L(t),r=d();return n-=h(r*(kn(U(i)/r)||1))*(t?1:-1)}function x(){b(E(),!0),e.cancel()}function k(n){for(var t=c.Slides.get(),i=0,r=1/0,o=0;o<t.length;o++){var u=t[o].index,e=U(S(u,!0)-n);if(!(e<=r))break;r=e,i=u}return i}function S(n,t){var i=h(s(n-1)-(n=n,"center"===(i=o.focus)?(l()-u(n,!0))/2:+i*u(n)||0));return t?(n=i,n=o.trimSpace&&r.is(Mt)?q(n,0,h(d(!0)-l())):n):i}function E(){var n=v("left");return N(p)[n]-N(g)[n]+h(i(!1))}function L(n){return S(n?c.Controller.getEnd():0,!!o.trimSpace)}return{mount:function(){e=c.Transition,t([B,Nn,K,J],m)},move:function(n,t,i,r){var o,u;n!==t&&(o=i<n,u=h(w(E(),o)),o?0<=u:u<=p[v("scrollWidth")]-N(g)[v("width")])&&(x(),b(w(E(),i<n),!0)),a(G),f(H,t,i,n),e.start(t,function(){a(3),f(Dn,t,i,n),r&&r()})},jump:y,translate:b,shift:w,cancel:x,toIndex:k,toPosition:S,getPosition:E,getLimit:L,exceededLimit:function(n,t){t=en(t)?E():t;var i=!0!==n&&h(t)<h(L(!1)),n=!1!==n&&h(t)>h(L(!0));return i||n},reposition:m}},Controller:function(o,u,e){var c,f,a,s,n=Q(o),t=n.on,i=n.emit,l=u.Move,d=l.getPosition,r=l.getLimit,v=l.toPosition,h=(n=u.Slides).isEnough,p=n.getLength,g=e.omitEnd,m=o.is(Pt),y=o.is(Mt),b=R(L,!1),w=R(L,!0),x=e.start||0,k=x;function S(){f=p(!0),a=e.perMove,s=e.perPage,c=_();var n=q(x,0,g?c:f-1);n!==x&&(x=n,l.reposition())}function E(){c!==_()&&i("ei")}function L(n,t){var i=a||(P()?1:s),i=O(x+i*(n?-1:1),x,!(a||P()));return-1===i&&y&&!Sn(d(),r(!n),1)?n?0:c:t?i:A(i)}function O(n,t,i){var r;return h()||P()?((r=function(n){if(y&&"move"===e.trimSpace&&n!==x)for(var t=d();t===v(n,!0)&&En(n,0,o.length-1,!e.rewind);)n<x?--n:++n;return n}(n))!==n&&(t=n,n=r,i=!1),n<0||c<n?n=a||!En(0,n,t,!0)&&!En(c,t,n,!0)?m?i?n<0?-(f%s||s):f:n:e.rewind?n<0?c:0:-1:z(D(n)):i&&n!==t&&(n=z(D(t)+(n<t?-1:1)))):n=-1,n}function A(n){return m?(n+f)%f||0:n}function _(){for(var n=f-(P()||m&&a?1:s);g&&0<n--;)if(v(f-1,!0)!==v(n,!0)){n++;break}return q(n,0,f-1)}function z(n){return q(P()?n:s*n,0,c)}function D(n){return P()?Y(n,c):xn((c<=n?f-1:n)/s)}function M(n){n!==x&&(k=x,x=n)}function P(){return!en(e.focus)||e.isNavigation}function I(){return o.state.is([G,rn])&&!!e.waitForTransition}return{mount:function(){S(),t([K,J,"ei"],S),t(Nn,E)},go:function(n,t,i){var r;I()||-1<(r=A(n=function(n){var t=x;{var i,r;C(n)?(r=n.match(/([+\-<>])(\d+)?/)||[],i=r[1],r=r[2],"+"===i||"-"===i?t=O(x+ +(""+i+(+r||1)),x):">"===i?t=r?z(+r):b(!0):"<"===i&&(t=w(!0))):t=m?n:q(n,0,c)}return t}(n)))&&(t||r!==x)&&(M(r),l.move(n,r,k,i))},scroll:function(n,t,i,r){u.Scroll.scroll(n,t,i,function(){var n=A(l.toIndex(d()));M(g?Y(n,c):n),r&&r()})},getNext:b,getPrev:w,getAdjacent:L,getEnd:_,setIndex:M,getIndex:function(n){return n?k:x},toIndex:z,toPage:D,toDest:function(n){return n=l.toIndex(n),y?q(n,0,c):n},hasFocus:P,isBusy:I}},Arrows:function(o,n,t){var i,r,u=Q(o),e=u.on,c=u.bind,f=u.emit,a=t.classes,s=t.i18n,l=n.Elements,d=n.Controller,v=l.arrows,h=l.track,p=v,g=l.prev,m=l.next,y={};function b(){var n=t.arrows;!n||g&&m||(p=v||j("div",a.arrows),g=S(!0),m=S(!1),i=!0,L(p,[g,m]),v||O(p,h)),g&&m&&(an(y,{prev:g,next:m}),ln(p,n?"":"none"),M(p,r=dt+"--"+t.direction),n&&(e([B,Dn,J,V,"ei"],E),c(m,"click",R(k,">")),c(g,"click",R(k,"<")),E(),I([g,m],Kn,h.id),f("arrows:mounted",g,m))),e(K,w)}function w(){x(),b()}function x(){u.destroy(),X(p,r),i?(T(v?[g,m]:p),g=m=null):P([g,m],ut)}function k(n){d.go(n,!0)}function S(n){return hn('<button class="'+a.arrow+" "+(n?a.prev:a.next)+'" type="button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40" width="40" height="40" focusable="false"><path d="'+(t.arrowPath||"m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z")+'" />')}function E(){var n,t,i,r;g&&m&&(r=o.index,n=d.getPrev(),t=d.getNext(),i=-1<n&&r<n?s.last:s.prev,r=-1<t&&t<r?s.first:s.next,g.disabled=n<0,m.disabled=t<0,I(g,nn,i),I(m,nn,r),f("arrows:updated",g,m,n,t))}return{arrows:y,mount:b,destroy:x,update:E}},Autoplay:function(n,t,i){var r,o,u=Q(n),e=u.on,c=u.bind,f=u.emit,a=qn(i.interval,n.go.bind(n,">"),function(n){var t=l.bar;t&&_(t,"width",100*n+"%"),f("autoplay:playing",n)}),s=a.isPaused,l=t.Elements,d=(u=t.Elements).root,v=u.toggle,h=i.autoplay,p="pause"===h;function g(){s()&&t.Slides.isEnough()&&(a.start(!i.resetProgress),o=r=p=!1,b(),f(Fn))}function m(n){p=!!(n=void 0===n?!0:n),b(),s()||(a.pause(),f(Xn))}function y(){p||(r||o?m(!1):g())}function b(){v&&(A(v,tn,!p),I(v,nn,i.i18n[p?"play":"pause"]))}function w(n){n=t.Slides.getAt(n);a.set(n&&+z(n.slide,Ct)||i.interval)}return{mount:function(){h&&(i.pauseOnHover&&c(d,"mouseenter mouseleave",function(n){r="mouseenter"===n.type,y()}),i.pauseOnFocus&&c(d,"focusin focusout",function(n){o="focusin"===n.type,y()}),v&&c(v,"click",function(){p?g():m(!0)}),e([H,Tn,J],a.rewind),e(H,w),v&&I(v,Kn,l.track.id),p||g(),b())},destroy:a.cancel,play:g,pause:m,isPaused:s}},Cover:function(n,t,i){var r=Q(n).on;function o(i){t.Slides.forEach(function(n){var t=fn(n.container||n.slide,"img");t&&t.src&&u(i,t,n)})}function u(n,t,i){i.style("background",n?'center/cover no-repeat url("'+t.src+'")':"",!0),ln(t,n?"none":"")}return{mount:function(){i.cover&&(r(Wn,R(u,!0)),r([B,K,J],R(o,!0)))},destroy:R(o,!1)}},Scroll:function(n,c,u){var f,a,t=Q(n),i=t.on,s=t.emit,l=n.state.set,d=c.Move,v=d.getPosition,e=d.getLimit,h=d.exceededLimit,p=d.translate,g=n.is(Mt),m=1;function y(n,t,i,r,o){var u,e=v(),i=(x(),!i||g&&h()||(i=c.Layout.sliderSize(),u=Ln(n)*i*xn(U(n)/i)||0,n=d.toPosition(c.Controller.toDest(n%i))+u),Sn(e,n,1));m=1,t=i?0:t||wn(U(n-e)/1.5,800),a=r,f=qn(t,b,R(w,e,n,o),1),l(rn),s(Tn),f.start()}function b(){l(3),a&&a(),s(V)}function w(n,t,i,r){var o=v(),r=(n+(t-n)*(t=r,(n=u.easingFunc)?n(t):1-Math.pow(1-t,4))-o)*m;p(o+r),g&&!i&&h()&&(m*=.6,U(r)<10&&y(e(h(!0)),600,!1,a,!0))}function x(){f&&f.cancel()}function r(){f&&!f.isPaused()&&(x(),b())}return{mount:function(){i(H,x),i([K,J],r)},destroy:x,scroll:y,cancel:r}},Drag:function(e,o,c){var f,t,u,a,s,l,d,v,n=Q(e),i=n.on,h=n.emit,p=n.bind,g=n.unbind,m=e.state,y=o.Move,b=o.Scroll,w=o.Controller,x=o.Elements.track,k=o.Media.reduce,r=(n=o.Direction).resolve,S=n.orient,E=y.getPosition,L=y.exceededLimit,O=!1;function j(){var n=c.drag;C(!n),a="free"===n}function N(n){var t,i,r;l=!1,d||(t=R(n),i=n.target,r=c.noDrag,cn(i,"."+mt+", ."+vt)||r&&cn(i,r)||!t&&n.button||(w.isBusy()?F(n,!0):(v=t?x:window,s=m.is([G,rn]),u=null,p(v,zt,A,jt),p(v,Dt,_,jt),y.cancel(),b.cancel(),z(n))))}function A(n){var t,i,r,o,u;m.is(6)||(m.set(6),h("drag")),n.cancelable&&(s?(y.translate(f+D(n)/(O&&e.is(Mt)?5:1)),u=200<M(n),t=O!==(O=L()),(u||t)&&z(n),l=!0,h("dragging"),F(n)):U(D(u=n))>U(D(u,!0))&&(t=n,i=c.dragMinThreshold,r=un(i),o=r&&i.mouse||0,r=(r?i.touch:+i)||10,s=U(D(t))>(R(t)?r:o),F(n)))}function _(n){var t,i,r;m.is(6)&&(m.set(3),h("dragged")),s&&(i=function(n){return E()+Ln(n)*Y(U(n)*(c.flickPower||600),a?1/0:o.Layout.listSize()*(c.flickMaxPages||1))}(t=function(n){if(e.is(Pt)||!O){var t=M(n);if(t&&t<200)return D(n)/t}return 0}(t=n)),r=c.rewind&&c.rewindByDrag,k(!1),a?w.scroll(i,0,c.snap):e.is(It)?w.go(S(Ln(t))<0?r?"<":"-":r?">":"+"):e.is(Mt)&&O&&r?w.go(L(!0)?">":"<"):w.go(w.toDest(i),!0),k(!0),F(n)),g(v,zt,A),g(v,Dt,_),s=!1}function T(n){!d&&l&&F(n,!0)}function z(n){u=t,t=n,f=E()}function D(n,t){return I(n,t)-I(P(n),t)}function M(n){return mn(n)-mn(P(n))}function P(n){return t===n&&u||t}function I(n,t){return(R(n)?n.changedTouches[0]:n)["page"+r(t?"Y":"X")]}function R(n){return"undefined"!=typeof TouchEvent&&n instanceof TouchEvent}function C(n){d=n}return{mount:function(){p(x,zt,on,jt),p(x,Dt,on,jt),p(x,_t,N,jt),p(x,"click",T,{capture:!0}),p(x,"dragstart",F),i([B,K],j)},disable:C,isDragging:function(){return s}}},Keyboard:function(t,n,i){var r,o,u=Q(t),e=u.on,c=u.bind,f=u.unbind,a=t.root,s=n.Direction.resolve;function l(){var n=i.keyboard;n&&(r="global"===n?window:a,c(r,Gt,h))}function d(){f(r,Gt)}function v(){var n=o;o=!0,p(function(){o=n})}function h(n){o||((n=Tt(n))===s(Bn)?t.go("<"):n===s(Hn)&&t.go(">"))}return{mount:function(){l(),e(K,d),e(K,l),e(H,v)},destroy:d,disable:function(n){o=n}}},LazyLoad:function(i,n,o){var t=Q(i),r=t.on,u=t.off,e=t.bind,c=t.emit,f="sequential"===o.lazyLoad,a=[Dn,V],s=[];function l(){D(s),n.Slides.forEach(function(r){gn(r.slide,Wt).forEach(function(n){var t=z(n,Ft),i=z(n,Xt);t===n.src&&i===n.srcset||(t=o.classes.spinner,t=fn(i=n.parentElement,"."+t)||j("span",t,i),s.push([n,r,t]),n.src||ln(n,"none"))})}),(f?p:(u(a),r(a,d),d))()}function d(){(s=s.filter(function(n){var t=o.perPage*((o.preloadPages||1)+1)-1;return!n[1].isWithin(i.index,t)||v(n)})).length||u(a)}function v(n){var t=n[0];M(n[1].slide,Et),e(t,"load error",R(h,n)),I(t,"src",z(t,Ft)),I(t,"srcset",z(t,Xt)),P(t,Ft),P(t,Xt)}function h(n,t){var i=n[0],r=n[1];X(r.slide,Et),"error"!==t.type&&(T(n[2]),ln(i,""),c(Wn,i,r),c(jn)),f&&p()}function p(){s.length&&v(s.shift())}return{mount:function(){o.lazyLoad&&(l(),r(J,l))},destroy:R(D,s),check:d}},Pagination:function(l,n,d){var v,h,t=Q(l),p=t.on,g=t.emit,m=t.bind,y=n.Slides,b=n.Elements,w=n.Controller,x=w.hasFocus,r=w.getIndex,e=w.go,c=n.Direction.resolve,k=b.pagination,S=[];function E(){v&&(T(k?o(v.children):v),X(v,h),D(S),v=null),t.destroy()}function L(n){e(">"+n,!0)}function O(n,t){var i=S.length,r=Tt(t),o=A(),u=-1,o=(r===c(Hn,!1,o)?u=++n%i:r===c(Bn,!1,o)?u=(--n+i)%i:"Home"===r?u=0:"End"===r&&(u=i-1),S[u]);o&&(dn(o.button),e(">"+u),F(t,!0))}function A(){return d.paginationDirection||d.direction}function _(n){return S[w.toPage(n)]}function z(){var n,t=_(r(!0)),i=_(r());t&&(X(n=t.button,tn),P(n,Qn),I(n,$,-1)),i&&(M(n=i.button,tn),I(n,Qn,!0),I(n,$,"")),g("pagination:updated",{list:v,items:S},t,i)}return{items:S,mount:function n(){E(),p([K,J,"ei"],n);var t=d.pagination;if(k&&ln(k,t?"":"none"),t){p([H,Tn,V],z);var t=l.length,i=d.classes,r=d.i18n,o=d.perPage,u=x()?w.getEnd()+1:kn(t/o);M(v=k||j("ul",i.pagination,b.track.parentElement),h=gt+"--"+A()),I(v,Z,"tablist"),I(v,nn,r.select),I(v,nt,A()===Jn?"vertical":"");for(var e=0;e<u;e++){var c=j("li",null,v),f=j("button",{class:i.page,type:"button"},c),a=y.getIn(e).map(function(n){return n.slide.id}),s=!x()&&1<o?r.pageX:r.slideX;m(f,"click",R(L,e)),d.paginationKeyboard&&m(f,"keydown",R(O,e)),I(c,Z,"presentation"),I(f,Z,"tab"),I(f,Kn,a.join(" ")),I(f,nn,On(s,e+1)),I(f,$,-1),S.push({li:c,button:f,page:e})}z(),g("pagination:mounted",{list:v,items:S},_(l.index))}},destroy:E,getAt:_,update:z}},Sync:function(i,n,t){var r=t.isNavigation,o=t.slideFocus,u=[];function e(){var n,t;i.splides.forEach(function(n){n.isParent||(f(i,n.splide),f(n.splide,i))}),r&&(n=Q(i),(t=n.on)(Mn,s),t(Yn,l),t([B,K],a),u.push(n),n.emit(Gn,i.splides))}function c(){u.forEach(function(n){n.destroy()}),D(u)}function f(n,r){n=Q(n);n.on(H,function(n,t,i){r.go(r.is(Pt)?i:n)}),u.push(n)}function a(){I(n.Elements.list,nt,t.direction===Jn?"vertical":"")}function s(n){i.go(n.index)}function l(n,t){b(Yt,Tt(t))&&(s(n),F(t))}return{setup:R(n.Media.set,{slideFocus:en(o)?r:o},!0),mount:e,destroy:c,remount:function(){c(),e()}}},Wheel:function(e,c,f){var n=Q(e).bind,a=0;function t(n){var t,i,r,o,u;n.cancelable&&(t=(u=n.deltaY)<0,i=mn(n),r=f.wheelMinThreshold||0,o=f.wheelSleep||0,U(u)>r&&o<i-a&&(e.go(t?"<":">"),a=i),u=t,f.releaseWheel&&!e.state.is(G)&&-1===c.Controller.getAdjacent(u)||F(n))}return{mount:function(){f.wheel&&n(c.Elements.track,"wheel",t,jt)}}},Live:function(n,t,i){var r=Q(n).on,o=t.Elements.track,u=i.live&&!i.isNavigation,e=j("span",wt),c=qn(90,R(f,!1));function f(n){I(o,rt,n),n?(L(o,e),c.start()):(T(e),c.cancel())}function a(n){u&&I(o,it,n?"off":"polite")}return{mount:function(){u&&(a(!t.Autoplay.isPaused()),I(o,ot,!0),e.textContent="…",r(Fn,R(a,!0)),r(Xn,R(a,!1)),r([Dn,V],R(f,!0)))},disable:a,destroy:function(){P(o,[it,ot,rt]),T(e)}}}}),qt={type:"slide",role:"region",speed:400,perPage:1,cloneStatus:!0,arrows:!0,pagination:!0,paginationKeyboard:!0,interval:5e3,pauseOnHover:!0,pauseOnFocus:!0,resetProgress:!0,easing:"cubic-bezier(0.25, 1, 0.5, 1)",drag:!0,direction:"ltr",trimSpace:!0,focusableNodes:"a, button, textarea, input, select, iframe",live:!0,classes:{slide:at,clone:st,arrows:dt,arrow:vt,prev:ht,next:pt,pagination:gt,page:mt,spinner:i+"spinner"},i18n:{prev:"Previous slide",next:"Next slide",first:"Go to first slide",last:"Go to last slide",slideX:"Go to slide %s",pageX:"Go to page %s",play:"Start autoplay",pause:"Pause autoplay",carousel:"carousel",slide:"slide",select:"Select a slide to show",slideLabel:"%s of %s"},reducedMotion:{speed:0,rewindSpeed:0,autoplay:"pause"}};function Bt(n,t,i){var r=t.Slides;function o(){r.forEach(function(n){n.style("transform","translateX(-"+100*n.index+"%)")})}return{mount:function(){Q(n).on([B,J],o)},start:function(n,t){r.style("transition","opacity "+i.speed+"ms "+i.easing),p(t)},cancel:on}}function Ht(u,n,e){var c,f=n.Move,a=n.Controller,s=n.Scroll,t=n.Elements.list,l=R(_,t,"transition");function i(){l(""),s.cancel()}return{mount:function(){Q(u).bind(t,"transitionend",function(n){n.target===t&&c&&(i(),c())})},start:function(n,t){var i=f.toPosition(n,!0),r=f.getPosition(),o=function(n){var t=e.rewindSpeed;if(u.is(Mt)&&t){var i=a.getIndex(!0),r=a.getEnd();if(0===i&&r<=n||r<=i&&0===n)return t}return e.speed}(n);1<=U(i-r)&&1<=o?e.useScroll?s.scroll(i,o,!1,t):(l("transform "+o+"ms "+e.easing),f.translate(i,!0),c=t):(f.jump(n),t())},cancel:i}}t=function(){function i(n,t){this.event=Q(),this.Components={},this.state=s(1),this.splides=[],this.n={},this.t={};n=C(n)?pn(document,n):n;bn(n,n+" is invalid."),t=d({label:z(this.root=n,nn)||"",labelledby:z(n,Zn)||""},qt,i.defaults,t||{});try{d(t,JSON.parse(z(n,f)))}catch(n){bn(!1,"Invalid JSON")}this.n=Object.create(d({},t))}var n=i.prototype;return n.mount=function(n,t){var i=this,r=this.state,o=this.Components;return bn(r.is([1,7]),"Already mounted!"),r.set(1),this.i=o,this.r=t||this.r||(this.is(It)?Bt:Ht),this.t=n||this.t,w(an({},Ut,this.t,{Transition:this.r}),function(n,t){n=n(i,o,i.n);(o[t]=n).setup&&n.setup()}),w(o,function(n){n.mount&&n.mount()}),this.emit(B),M(this.root,"is-initialized"),r.set(3),this.emit("ready"),this},n.sync=function(n){return this.splides.push({splide:n}),n.splides.push({splide:this,isParent:!0}),this.state.is(3)&&(this.i.Sync.remount(),n.Components.Sync.remount()),this},n.go=function(n){return this.i.Controller.go(n),this},n.on=function(n,t){return this.event.on(n,t),this},n.off=function(n){return this.event.off(n),this},n.emit=function(n){var t;return(t=this.event).emit.apply(t,[n].concat(o(arguments,1))),this},n.add=function(n,t){return this.i.Slides.add(n,t),this},n.remove=function(n){return this.i.Slides.remove(n),this},n.is=function(n){return this.n.type===n},n.refresh=function(){return this.emit(J),this},n.destroy=function(t){void 0===t&&(t=!0);var n=this.event,i=this.state;return i.is(1)?Q(this).on("ready",this.destroy.bind(this,t)):(w(this.i,function(n){n.destroy&&n.destroy(t)},!0),n.emit(a),n.destroy(),t&&D(this.splides),i.set(7)),this},Jt(i,[{key:"options",get:function(){return this.n},set:function(n){this.i.Media.set(n,!0,!0)}},{key:"length",get:function(){return this.i.Slides.getLength(!0)}},{key:"index",get:function(){return this.i.Controller.getIndex()}}]),i}();return t.defaults={},t.STATES=r,t},"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(n="undefined"!=typeof globalThis?globalThis:n||self).Splide=t();

},{}],53:[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("@popperjs/core")):"function"==typeof define&&define.amd?define(["@popperjs/core"],e):(t=t||self).tippy=e(t.Popper)}(this,(function(t){"use strict";var e="undefined"!=typeof window&&"undefined"!=typeof document,n=!!e&&!!window.msCrypto,r={passive:!0,capture:!0},o=function(){return document.body};function i(t,e,n){if(Array.isArray(t)){var r=t[e];return null==r?Array.isArray(n)?n[e]:n:r}return t}function a(t,e){var n={}.toString.call(t);return 0===n.indexOf("[object")&&n.indexOf(e+"]")>-1}function s(t,e){return"function"==typeof t?t.apply(void 0,e):t}function u(t,e){return 0===e?t:function(r){clearTimeout(n),n=setTimeout((function(){t(r)}),e)};var n}function p(t,e){var n=Object.assign({},t);return e.forEach((function(t){delete n[t]})),n}function c(t){return[].concat(t)}function f(t,e){-1===t.indexOf(e)&&t.push(e)}function l(t){return t.split("-")[0]}function d(t){return[].slice.call(t)}function v(t){return Object.keys(t).reduce((function(e,n){return void 0!==t[n]&&(e[n]=t[n]),e}),{})}function m(){return document.createElement("div")}function g(t){return["Element","Fragment"].some((function(e){return a(t,e)}))}function h(t){return a(t,"MouseEvent")}function b(t){return!(!t||!t._tippy||t._tippy.reference!==t)}function y(t){return g(t)?[t]:function(t){return a(t,"NodeList")}(t)?d(t):Array.isArray(t)?t:d(document.querySelectorAll(t))}function w(t,e){t.forEach((function(t){t&&(t.style.transitionDuration=e+"ms")}))}function x(t,e){t.forEach((function(t){t&&t.setAttribute("data-state",e)}))}function E(t){var e,n=c(t)[0];return null!=n&&null!=(e=n.ownerDocument)&&e.body?n.ownerDocument:document}function O(t,e,n){var r=e+"EventListener";["transitionend","webkitTransitionEnd"].forEach((function(e){t[r](e,n)}))}function C(t,e){for(var n=e;n;){var r;if(t.contains(n))return!0;n=null==n.getRootNode||null==(r=n.getRootNode())?void 0:r.host}return!1}var T={isTouch:!1},A=0;function L(){T.isTouch||(T.isTouch=!0,window.performance&&document.addEventListener("mousemove",D))}function D(){var t=performance.now();t-A<20&&(T.isTouch=!1,document.removeEventListener("mousemove",D)),A=t}function k(){var t=document.activeElement;if(b(t)){var e=t._tippy;t.blur&&!e.state.isVisible&&t.blur()}}var R=Object.assign({appendTo:o,aria:{content:"auto",expanded:"auto"},delay:0,duration:[300,250],getReferenceClientRect:null,hideOnClick:!0,ignoreAttributes:!1,interactive:!1,interactiveBorder:2,interactiveDebounce:0,moveTransition:"",offset:[0,10],onAfterUpdate:function(){},onBeforeUpdate:function(){},onCreate:function(){},onDestroy:function(){},onHidden:function(){},onHide:function(){},onMount:function(){},onShow:function(){},onShown:function(){},onTrigger:function(){},onUntrigger:function(){},onClickOutside:function(){},placement:"top",plugins:[],popperOptions:{},render:null,showOnCreate:!1,touch:!0,trigger:"mouseenter focus",triggerTarget:null},{animateFill:!1,followCursor:!1,inlinePositioning:!1,sticky:!1},{allowHTML:!1,animation:"fade",arrow:!0,content:"",inertia:!1,maxWidth:350,role:"tooltip",theme:"",zIndex:9999}),P=Object.keys(R);function j(t){var e=(t.plugins||[]).reduce((function(e,n){var r,o=n.name,i=n.defaultValue;o&&(e[o]=void 0!==t[o]?t[o]:null!=(r=R[o])?r:i);return e}),{});return Object.assign({},t,e)}function M(t,e){var n=Object.assign({},e,{content:s(e.content,[t])},e.ignoreAttributes?{}:function(t,e){return(e?Object.keys(j(Object.assign({},R,{plugins:e}))):P).reduce((function(e,n){var r=(t.getAttribute("data-tippy-"+n)||"").trim();if(!r)return e;if("content"===n)e[n]=r;else try{e[n]=JSON.parse(r)}catch(t){e[n]=r}return e}),{})}(t,e.plugins));return n.aria=Object.assign({},R.aria,n.aria),n.aria={expanded:"auto"===n.aria.expanded?e.interactive:n.aria.expanded,content:"auto"===n.aria.content?e.interactive?null:"describedby":n.aria.content},n}function V(t,e){t.innerHTML=e}function I(t){var e=m();return!0===t?e.className="tippy-arrow":(e.className="tippy-svg-arrow",g(t)?e.appendChild(t):V(e,t)),e}function S(t,e){g(e.content)?(V(t,""),t.appendChild(e.content)):"function"!=typeof e.content&&(e.allowHTML?V(t,e.content):t.textContent=e.content)}function B(t){var e=t.firstElementChild,n=d(e.children);return{box:e,content:n.find((function(t){return t.classList.contains("tippy-content")})),arrow:n.find((function(t){return t.classList.contains("tippy-arrow")||t.classList.contains("tippy-svg-arrow")})),backdrop:n.find((function(t){return t.classList.contains("tippy-backdrop")}))}}function N(t){var e=m(),n=m();n.className="tippy-box",n.setAttribute("data-state","hidden"),n.setAttribute("tabindex","-1");var r=m();function o(n,r){var o=B(e),i=o.box,a=o.content,s=o.arrow;r.theme?i.setAttribute("data-theme",r.theme):i.removeAttribute("data-theme"),"string"==typeof r.animation?i.setAttribute("data-animation",r.animation):i.removeAttribute("data-animation"),r.inertia?i.setAttribute("data-inertia",""):i.removeAttribute("data-inertia"),i.style.maxWidth="number"==typeof r.maxWidth?r.maxWidth+"px":r.maxWidth,r.role?i.setAttribute("role",r.role):i.removeAttribute("role"),n.content===r.content&&n.allowHTML===r.allowHTML||S(a,t.props),r.arrow?s?n.arrow!==r.arrow&&(i.removeChild(s),i.appendChild(I(r.arrow))):i.appendChild(I(r.arrow)):s&&i.removeChild(s)}return r.className="tippy-content",r.setAttribute("data-state","hidden"),S(r,t.props),e.appendChild(n),n.appendChild(r),o(t.props,t.props),{popper:e,onUpdate:o}}N.$$tippy=!0;var H=1,U=[],_=[];function z(e,a){var p,g,b,y,A,L,D,k,P=M(e,Object.assign({},R,j(v(a)))),V=!1,I=!1,S=!1,N=!1,z=[],F=u(wt,P.interactiveDebounce),W=H++,X=(k=P.plugins).filter((function(t,e){return k.indexOf(t)===e})),Y={id:W,reference:e,popper:m(),popperInstance:null,props:P,state:{isEnabled:!0,isVisible:!1,isDestroyed:!1,isMounted:!1,isShown:!1},plugins:X,clearDelayTimeouts:function(){clearTimeout(p),clearTimeout(g),cancelAnimationFrame(b)},setProps:function(t){if(Y.state.isDestroyed)return;at("onBeforeUpdate",[Y,t]),bt();var n=Y.props,r=M(e,Object.assign({},n,v(t),{ignoreAttributes:!0}));Y.props=r,ht(),n.interactiveDebounce!==r.interactiveDebounce&&(pt(),F=u(wt,r.interactiveDebounce));n.triggerTarget&&!r.triggerTarget?c(n.triggerTarget).forEach((function(t){t.removeAttribute("aria-expanded")})):r.triggerTarget&&e.removeAttribute("aria-expanded");ut(),it(),J&&J(n,r);Y.popperInstance&&(Ct(),At().forEach((function(t){requestAnimationFrame(t._tippy.popperInstance.forceUpdate)})));at("onAfterUpdate",[Y,t])},setContent:function(t){Y.setProps({content:t})},show:function(){var t=Y.state.isVisible,e=Y.state.isDestroyed,n=!Y.state.isEnabled,r=T.isTouch&&!Y.props.touch,a=i(Y.props.duration,0,R.duration);if(t||e||n||r)return;if(et().hasAttribute("disabled"))return;if(at("onShow",[Y],!1),!1===Y.props.onShow(Y))return;Y.state.isVisible=!0,tt()&&($.style.visibility="visible");it(),dt(),Y.state.isMounted||($.style.transition="none");if(tt()){var u=rt(),p=u.box,c=u.content;w([p,c],0)}L=function(){var t;if(Y.state.isVisible&&!N){if(N=!0,$.offsetHeight,$.style.transition=Y.props.moveTransition,tt()&&Y.props.animation){var e=rt(),n=e.box,r=e.content;w([n,r],a),x([n,r],"visible")}st(),ut(),f(_,Y),null==(t=Y.popperInstance)||t.forceUpdate(),at("onMount",[Y]),Y.props.animation&&tt()&&function(t,e){mt(t,e)}(a,(function(){Y.state.isShown=!0,at("onShown",[Y])}))}},function(){var t,e=Y.props.appendTo,n=et();t=Y.props.interactive&&e===o||"parent"===e?n.parentNode:s(e,[n]);t.contains($)||t.appendChild($);Y.state.isMounted=!0,Ct()}()},hide:function(){var t=!Y.state.isVisible,e=Y.state.isDestroyed,n=!Y.state.isEnabled,r=i(Y.props.duration,1,R.duration);if(t||e||n)return;if(at("onHide",[Y],!1),!1===Y.props.onHide(Y))return;Y.state.isVisible=!1,Y.state.isShown=!1,N=!1,V=!1,tt()&&($.style.visibility="hidden");if(pt(),vt(),it(!0),tt()){var o=rt(),a=o.box,s=o.content;Y.props.animation&&(w([a,s],r),x([a,s],"hidden"))}st(),ut(),Y.props.animation?tt()&&function(t,e){mt(t,(function(){!Y.state.isVisible&&$.parentNode&&$.parentNode.contains($)&&e()}))}(r,Y.unmount):Y.unmount()},hideWithInteractivity:function(t){nt().addEventListener("mousemove",F),f(U,F),F(t)},enable:function(){Y.state.isEnabled=!0},disable:function(){Y.hide(),Y.state.isEnabled=!1},unmount:function(){Y.state.isVisible&&Y.hide();if(!Y.state.isMounted)return;Tt(),At().forEach((function(t){t._tippy.unmount()})),$.parentNode&&$.parentNode.removeChild($);_=_.filter((function(t){return t!==Y})),Y.state.isMounted=!1,at("onHidden",[Y])},destroy:function(){if(Y.state.isDestroyed)return;Y.clearDelayTimeouts(),Y.unmount(),bt(),delete e._tippy,Y.state.isDestroyed=!0,at("onDestroy",[Y])}};if(!P.render)return Y;var q=P.render(Y),$=q.popper,J=q.onUpdate;$.setAttribute("data-tippy-root",""),$.id="tippy-"+Y.id,Y.popper=$,e._tippy=Y,$._tippy=Y;var G=X.map((function(t){return t.fn(Y)})),K=e.hasAttribute("aria-expanded");return ht(),ut(),it(),at("onCreate",[Y]),P.showOnCreate&&Lt(),$.addEventListener("mouseenter",(function(){Y.props.interactive&&Y.state.isVisible&&Y.clearDelayTimeouts()})),$.addEventListener("mouseleave",(function(){Y.props.interactive&&Y.props.trigger.indexOf("mouseenter")>=0&&nt().addEventListener("mousemove",F)})),Y;function Q(){var t=Y.props.touch;return Array.isArray(t)?t:[t,0]}function Z(){return"hold"===Q()[0]}function tt(){var t;return!(null==(t=Y.props.render)||!t.$$tippy)}function et(){return D||e}function nt(){var t=et().parentNode;return t?E(t):document}function rt(){return B($)}function ot(t){return Y.state.isMounted&&!Y.state.isVisible||T.isTouch||y&&"focus"===y.type?0:i(Y.props.delay,t?0:1,R.delay)}function it(t){void 0===t&&(t=!1),$.style.pointerEvents=Y.props.interactive&&!t?"":"none",$.style.zIndex=""+Y.props.zIndex}function at(t,e,n){var r;(void 0===n&&(n=!0),G.forEach((function(n){n[t]&&n[t].apply(n,e)})),n)&&(r=Y.props)[t].apply(r,e)}function st(){var t=Y.props.aria;if(t.content){var n="aria-"+t.content,r=$.id;c(Y.props.triggerTarget||e).forEach((function(t){var e=t.getAttribute(n);if(Y.state.isVisible)t.setAttribute(n,e?e+" "+r:r);else{var o=e&&e.replace(r,"").trim();o?t.setAttribute(n,o):t.removeAttribute(n)}}))}}function ut(){!K&&Y.props.aria.expanded&&c(Y.props.triggerTarget||e).forEach((function(t){Y.props.interactive?t.setAttribute("aria-expanded",Y.state.isVisible&&t===et()?"true":"false"):t.removeAttribute("aria-expanded")}))}function pt(){nt().removeEventListener("mousemove",F),U=U.filter((function(t){return t!==F}))}function ct(t){if(!T.isTouch||!S&&"mousedown"!==t.type){var n=t.composedPath&&t.composedPath()[0]||t.target;if(!Y.props.interactive||!C($,n)){if(c(Y.props.triggerTarget||e).some((function(t){return C(t,n)}))){if(T.isTouch)return;if(Y.state.isVisible&&Y.props.trigger.indexOf("click")>=0)return}else at("onClickOutside",[Y,t]);!0===Y.props.hideOnClick&&(Y.clearDelayTimeouts(),Y.hide(),I=!0,setTimeout((function(){I=!1})),Y.state.isMounted||vt())}}}function ft(){S=!0}function lt(){S=!1}function dt(){var t=nt();t.addEventListener("mousedown",ct,!0),t.addEventListener("touchend",ct,r),t.addEventListener("touchstart",lt,r),t.addEventListener("touchmove",ft,r)}function vt(){var t=nt();t.removeEventListener("mousedown",ct,!0),t.removeEventListener("touchend",ct,r),t.removeEventListener("touchstart",lt,r),t.removeEventListener("touchmove",ft,r)}function mt(t,e){var n=rt().box;function r(t){t.target===n&&(O(n,"remove",r),e())}if(0===t)return e();O(n,"remove",A),O(n,"add",r),A=r}function gt(t,n,r){void 0===r&&(r=!1),c(Y.props.triggerTarget||e).forEach((function(e){e.addEventListener(t,n,r),z.push({node:e,eventType:t,handler:n,options:r})}))}function ht(){var t;Z()&&(gt("touchstart",yt,{passive:!0}),gt("touchend",xt,{passive:!0})),(t=Y.props.trigger,t.split(/\s+/).filter(Boolean)).forEach((function(t){if("manual"!==t)switch(gt(t,yt),t){case"mouseenter":gt("mouseleave",xt);break;case"focus":gt(n?"focusout":"blur",Et);break;case"focusin":gt("focusout",Et)}}))}function bt(){z.forEach((function(t){var e=t.node,n=t.eventType,r=t.handler,o=t.options;e.removeEventListener(n,r,o)})),z=[]}function yt(t){var e,n=!1;if(Y.state.isEnabled&&!Ot(t)&&!I){var r="focus"===(null==(e=y)?void 0:e.type);y=t,D=t.currentTarget,ut(),!Y.state.isVisible&&h(t)&&U.forEach((function(e){return e(t)})),"click"===t.type&&(Y.props.trigger.indexOf("mouseenter")<0||V)&&!1!==Y.props.hideOnClick&&Y.state.isVisible?n=!0:Lt(t),"click"===t.type&&(V=!n),n&&!r&&Dt(t)}}function wt(t){var e=t.target,n=et().contains(e)||$.contains(e);"mousemove"===t.type&&n||function(t,e){var n=e.clientX,r=e.clientY;return t.every((function(t){var e=t.popperRect,o=t.popperState,i=t.props.interactiveBorder,a=l(o.placement),s=o.modifiersData.offset;if(!s)return!0;var u="bottom"===a?s.top.y:0,p="top"===a?s.bottom.y:0,c="right"===a?s.left.x:0,f="left"===a?s.right.x:0,d=e.top-r+u>i,v=r-e.bottom-p>i,m=e.left-n+c>i,g=n-e.right-f>i;return d||v||m||g}))}(At().concat($).map((function(t){var e,n=null==(e=t._tippy.popperInstance)?void 0:e.state;return n?{popperRect:t.getBoundingClientRect(),popperState:n,props:P}:null})).filter(Boolean),t)&&(pt(),Dt(t))}function xt(t){Ot(t)||Y.props.trigger.indexOf("click")>=0&&V||(Y.props.interactive?Y.hideWithInteractivity(t):Dt(t))}function Et(t){Y.props.trigger.indexOf("focusin")<0&&t.target!==et()||Y.props.interactive&&t.relatedTarget&&$.contains(t.relatedTarget)||Dt(t)}function Ot(t){return!!T.isTouch&&Z()!==t.type.indexOf("touch")>=0}function Ct(){Tt();var n=Y.props,r=n.popperOptions,o=n.placement,i=n.offset,a=n.getReferenceClientRect,s=n.moveTransition,u=tt()?B($).arrow:null,p=a?{getBoundingClientRect:a,contextElement:a.contextElement||et()}:e,c=[{name:"offset",options:{offset:i}},{name:"preventOverflow",options:{padding:{top:2,bottom:2,left:5,right:5}}},{name:"flip",options:{padding:5}},{name:"computeStyles",options:{adaptive:!s}},{name:"$$tippy",enabled:!0,phase:"beforeWrite",requires:["computeStyles"],fn:function(t){var e=t.state;if(tt()){var n=rt().box;["placement","reference-hidden","escaped"].forEach((function(t){"placement"===t?n.setAttribute("data-placement",e.placement):e.attributes.popper["data-popper-"+t]?n.setAttribute("data-"+t,""):n.removeAttribute("data-"+t)})),e.attributes.popper={}}}}];tt()&&u&&c.push({name:"arrow",options:{element:u,padding:3}}),c.push.apply(c,(null==r?void 0:r.modifiers)||[]),Y.popperInstance=t.createPopper(p,$,Object.assign({},r,{placement:o,onFirstUpdate:L,modifiers:c}))}function Tt(){Y.popperInstance&&(Y.popperInstance.destroy(),Y.popperInstance=null)}function At(){return d($.querySelectorAll("[data-tippy-root]"))}function Lt(t){Y.clearDelayTimeouts(),t&&at("onTrigger",[Y,t]),dt();var e=ot(!0),n=Q(),r=n[0],o=n[1];T.isTouch&&"hold"===r&&o&&(e=o),e?p=setTimeout((function(){Y.show()}),e):Y.show()}function Dt(t){if(Y.clearDelayTimeouts(),at("onUntrigger",[Y,t]),Y.state.isVisible){if(!(Y.props.trigger.indexOf("mouseenter")>=0&&Y.props.trigger.indexOf("click")>=0&&["mouseleave","mousemove"].indexOf(t.type)>=0&&V)){var e=ot(!1);e?g=setTimeout((function(){Y.state.isVisible&&Y.hide()}),e):b=requestAnimationFrame((function(){Y.hide()}))}}else vt()}}function F(t,e){void 0===e&&(e={});var n=R.plugins.concat(e.plugins||[]);document.addEventListener("touchstart",L,r),window.addEventListener("blur",k);var o=Object.assign({},e,{plugins:n}),i=y(t).reduce((function(t,e){var n=e&&z(e,o);return n&&t.push(n),t}),[]);return g(t)?i[0]:i}F.defaultProps=R,F.setDefaultProps=function(t){Object.keys(t).forEach((function(e){R[e]=t[e]}))},F.currentInput=T;var W=Object.assign({},t.applyStyles,{effect:function(t){var e=t.state,n={popper:{position:e.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};Object.assign(e.elements.popper.style,n.popper),e.styles=n,e.elements.arrow&&Object.assign(e.elements.arrow.style,n.arrow)}}),X={mouseover:"mouseenter",focusin:"focus",click:"click"};var Y={name:"animateFill",defaultValue:!1,fn:function(t){var e;if(null==(e=t.props.render)||!e.$$tippy)return{};var n=B(t.popper),r=n.box,o=n.content,i=t.props.animateFill?function(){var t=m();return t.className="tippy-backdrop",x([t],"hidden"),t}():null;return{onCreate:function(){i&&(r.insertBefore(i,r.firstElementChild),r.setAttribute("data-animatefill",""),r.style.overflow="hidden",t.setProps({arrow:!1,animation:"shift-away"}))},onMount:function(){if(i){var t=r.style.transitionDuration,e=Number(t.replace("ms",""));o.style.transitionDelay=Math.round(e/10)+"ms",i.style.transitionDuration=t,x([i],"visible")}},onShow:function(){i&&(i.style.transitionDuration="0ms")},onHide:function(){i&&x([i],"hidden")}}}};var q={clientX:0,clientY:0},$=[];function J(t){var e=t.clientX,n=t.clientY;q={clientX:e,clientY:n}}var G={name:"followCursor",defaultValue:!1,fn:function(t){var e=t.reference,n=E(t.props.triggerTarget||e),r=!1,o=!1,i=!0,a=t.props;function s(){return"initial"===t.props.followCursor&&t.state.isVisible}function u(){n.addEventListener("mousemove",f)}function p(){n.removeEventListener("mousemove",f)}function c(){r=!0,t.setProps({getReferenceClientRect:null}),r=!1}function f(n){var r=!n.target||e.contains(n.target),o=t.props.followCursor,i=n.clientX,a=n.clientY,s=e.getBoundingClientRect(),u=i-s.left,p=a-s.top;!r&&t.props.interactive||t.setProps({getReferenceClientRect:function(){var t=e.getBoundingClientRect(),n=i,r=a;"initial"===o&&(n=t.left+u,r=t.top+p);var s="horizontal"===o?t.top:r,c="vertical"===o?t.right:n,f="horizontal"===o?t.bottom:r,l="vertical"===o?t.left:n;return{width:c-l,height:f-s,top:s,right:c,bottom:f,left:l}}})}function l(){t.props.followCursor&&($.push({instance:t,doc:n}),function(t){t.addEventListener("mousemove",J)}(n))}function d(){0===($=$.filter((function(e){return e.instance!==t}))).filter((function(t){return t.doc===n})).length&&function(t){t.removeEventListener("mousemove",J)}(n)}return{onCreate:l,onDestroy:d,onBeforeUpdate:function(){a=t.props},onAfterUpdate:function(e,n){var i=n.followCursor;r||void 0!==i&&a.followCursor!==i&&(d(),i?(l(),!t.state.isMounted||o||s()||u()):(p(),c()))},onMount:function(){t.props.followCursor&&!o&&(i&&(f(q),i=!1),s()||u())},onTrigger:function(t,e){h(e)&&(q={clientX:e.clientX,clientY:e.clientY}),o="focus"===e.type},onHidden:function(){t.props.followCursor&&(c(),p(),i=!0)}}}};var K={name:"inlinePositioning",defaultValue:!1,fn:function(t){var e,n=t.reference;var r=-1,o=!1,i=[],a={name:"tippyInlinePositioning",enabled:!0,phase:"afterWrite",fn:function(o){var a=o.state;t.props.inlinePositioning&&(-1!==i.indexOf(a.placement)&&(i=[]),e!==a.placement&&-1===i.indexOf(a.placement)&&(i.push(a.placement),t.setProps({getReferenceClientRect:function(){return function(t){return function(t,e,n,r){if(n.length<2||null===t)return e;if(2===n.length&&r>=0&&n[0].left>n[1].right)return n[r]||e;switch(t){case"top":case"bottom":var o=n[0],i=n[n.length-1],a="top"===t,s=o.top,u=i.bottom,p=a?o.left:i.left,c=a?o.right:i.right;return{top:s,bottom:u,left:p,right:c,width:c-p,height:u-s};case"left":case"right":var f=Math.min.apply(Math,n.map((function(t){return t.left}))),l=Math.max.apply(Math,n.map((function(t){return t.right}))),d=n.filter((function(e){return"left"===t?e.left===f:e.right===l})),v=d[0].top,m=d[d.length-1].bottom;return{top:v,bottom:m,left:f,right:l,width:l-f,height:m-v};default:return e}}(l(t),n.getBoundingClientRect(),d(n.getClientRects()),r)}(a.placement)}})),e=a.placement)}};function s(){var e;o||(e=function(t,e){var n;return{popperOptions:Object.assign({},t.popperOptions,{modifiers:[].concat(((null==(n=t.popperOptions)?void 0:n.modifiers)||[]).filter((function(t){return t.name!==e.name})),[e])})}}(t.props,a),o=!0,t.setProps(e),o=!1)}return{onCreate:s,onAfterUpdate:s,onTrigger:function(e,n){if(h(n)){var o=d(t.reference.getClientRects()),i=o.find((function(t){return t.left-2<=n.clientX&&t.right+2>=n.clientX&&t.top-2<=n.clientY&&t.bottom+2>=n.clientY})),a=o.indexOf(i);r=a>-1?a:r}},onHidden:function(){r=-1}}}};var Q={name:"sticky",defaultValue:!1,fn:function(t){var e=t.reference,n=t.popper;function r(e){return!0===t.props.sticky||t.props.sticky===e}var o=null,i=null;function a(){var s=r("reference")?(t.popperInstance?t.popperInstance.state.elements.reference:e).getBoundingClientRect():null,u=r("popper")?n.getBoundingClientRect():null;(s&&Z(o,s)||u&&Z(i,u))&&t.popperInstance&&t.popperInstance.update(),o=s,i=u,t.state.isMounted&&requestAnimationFrame(a)}return{onMount:function(){t.props.sticky&&a()}}}};function Z(t,e){return!t||!e||(t.top!==e.top||t.right!==e.right||t.bottom!==e.bottom||t.left!==e.left)}return e&&function(t){var e=document.createElement("style");e.textContent=t,e.setAttribute("data-tippy-stylesheet","");var n=document.head,r=document.querySelector("head>style,head>link");r?n.insertBefore(e,r):n.appendChild(e)}('.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:"";position:absolute;border-color:transparent;border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}'),F.setDefaultProps({plugins:[Y,G,K,Q],render:N}),F.createSingleton=function(t,e){var n;void 0===e&&(e={});var r,o=t,i=[],a=[],s=e.overrides,u=[],f=!1;function l(){a=o.map((function(t){return c(t.props.triggerTarget||t.reference)})).reduce((function(t,e){return t.concat(e)}),[])}function d(){i=o.map((function(t){return t.reference}))}function v(t){o.forEach((function(e){t?e.enable():e.disable()}))}function g(t){return o.map((function(e){var n=e.setProps;return e.setProps=function(o){n(o),e.reference===r&&t.setProps(o)},function(){e.setProps=n}}))}function h(t,e){var n=a.indexOf(e);if(e!==r){r=e;var u=(s||[]).concat("content").reduce((function(t,e){return t[e]=o[n].props[e],t}),{});t.setProps(Object.assign({},u,{getReferenceClientRect:"function"==typeof u.getReferenceClientRect?u.getReferenceClientRect:function(){var t;return null==(t=i[n])?void 0:t.getBoundingClientRect()}}))}}v(!1),d(),l();var b={fn:function(){return{onDestroy:function(){v(!0)},onHidden:function(){r=null},onClickOutside:function(t){t.props.showOnCreate&&!f&&(f=!0,r=null)},onShow:function(t){t.props.showOnCreate&&!f&&(f=!0,h(t,i[0]))},onTrigger:function(t,e){h(t,e.currentTarget)}}}},y=F(m(),Object.assign({},p(e,["overrides"]),{plugins:[b].concat(e.plugins||[]),triggerTarget:a,popperOptions:Object.assign({},e.popperOptions,{modifiers:[].concat((null==(n=e.popperOptions)?void 0:n.modifiers)||[],[W])})})),w=y.show;y.show=function(t){if(w(),!r&&null==t)return h(y,i[0]);if(!r||null!=t){if("number"==typeof t)return i[t]&&h(y,i[t]);if(o.indexOf(t)>=0){var e=t.reference;return h(y,e)}return i.indexOf(t)>=0?h(y,t):void 0}},y.showNext=function(){var t=i[0];if(!r)return y.show(0);var e=i.indexOf(r);y.show(i[e+1]||t)},y.showPrevious=function(){var t=i[i.length-1];if(!r)return y.show(t);var e=i.indexOf(r),n=i[e-1]||t;y.show(n)};var x=y.setProps;return y.setProps=function(t){s=t.overrides||s,x(t)},y.setInstances=function(t){v(!0),u.forEach((function(t){return t()})),o=t,v(!1),d(),l(),u=g(y),y.setProps({triggerTarget:a})},u=g(y),y},F.delegate=function(t,e){var n=[],o=[],i=!1,a=e.target,s=p(e,["target"]),u=Object.assign({},s,{trigger:"manual",touch:!1}),f=Object.assign({touch:R.touch},s,{showOnCreate:!0}),l=F(t,u);function d(t){if(t.target&&!i){var n=t.target.closest(a);if(n){var r=n.getAttribute("data-tippy-trigger")||e.trigger||R.trigger;if(!n._tippy&&!("touchstart"===t.type&&"boolean"==typeof f.touch||"touchstart"!==t.type&&r.indexOf(X[t.type])<0)){var s=F(n,f);s&&(o=o.concat(s))}}}}function v(t,e,r,o){void 0===o&&(o=!1),t.addEventListener(e,r,o),n.push({node:t,eventType:e,handler:r,options:o})}return c(l).forEach((function(t){var e=t.destroy,a=t.enable,s=t.disable;t.destroy=function(t){void 0===t&&(t=!0),t&&o.forEach((function(t){t.destroy()})),o=[],n.forEach((function(t){var e=t.node,n=t.eventType,r=t.handler,o=t.options;e.removeEventListener(n,r,o)})),n=[],e()},t.enable=function(){a(),o.forEach((function(t){return t.enable()})),i=!1},t.disable=function(){s(),o.forEach((function(t){return t.disable()})),i=!0},function(t){var e=t.reference;v(e,"touchstart",d,r),v(e,"mouseover",d),v(e,"focusin",d),v(e,"click",d)}(t)})),l},F.hideAll=function(t){var e=void 0===t?{}:t,n=e.exclude,r=e.duration;_.forEach((function(t){var e=!1;if(n&&(e=b(n)?t.reference===n:t.popper===n.popper),!e){var o=t.props.duration;t.setProps({duration:r}),t.hide(),t.state.isDestroyed||t.setProps({duration:o})}}))},F.roundArrow='<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>',F}));

},{"@popperjs/core":1}],54:[function(require,module,exports){
(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    define([], factory())
  } else if (typeof module === "object" && module.exports) {
    module.exports = factory()
  } else {
    (function install() {
      // To make sure Zenscroll can be referenced from the header, before `body` is available
      if (document && document.body) {
        root.zenscroll = factory()
      } else {
        // retry 9ms later
        setTimeout(install, 9)
      }
    })()
  }
}(this, function () {
  "use strict"


  // Detect if the browser already supports native smooth scrolling (e.g., Firefox 36+ and Chrome 49+) and it is enabled:
  var isNativeSmoothScrollEnabledOn = function (elem) {
    return elem && "getComputedStyle" in window &&
      window.getComputedStyle(elem)["scroll-behavior"] === "smooth"
  }


  // Exit if it’s not a browser environment:
  if (typeof window === "undefined" || !("document" in window)) {
    return {}
  }


  var makeScroller = function (container, defaultDuration, edgeOffset) {

    // Use defaults if not provided
    defaultDuration = defaultDuration || 999 //ms
    if (!edgeOffset && edgeOffset !== 0) {
      // When scrolling, this amount of distance is kept from the edges of the container:
      edgeOffset = 9 //px
    }

    // Handling the life-cycle of the scroller
    var scrollTimeoutId
    var setScrollTimeoutId = function (newValue) {
      scrollTimeoutId = newValue
    }

    /**
     * Stop the current smooth scroll operation immediately
     */
    var stopScroll = function () {
      clearTimeout(scrollTimeoutId)
      setScrollTimeoutId(0)
    }

    var getTopWithEdgeOffset = function (elem) {
      return Math.max(0, container.getTopOf(elem) - edgeOffset)
    }

    /**
     * Scrolls to a specific vertical position in the document.
     *
     * @param {targetY} The vertical position within the document.
     * @param {duration} Optionally the duration of the scroll operation.
     *        If not provided the default duration is used.
     * @param {onDone} An optional callback function to be invoked once the scroll finished.
     */
    var scrollToY = function (targetY, duration, onDone) {
      stopScroll()
      if (duration === 0 || (duration && duration < 0) || isNativeSmoothScrollEnabledOn(container.body)) {
        container.toY(targetY)
        if (onDone) {
          onDone()
        }
      } else {
        var startY = container.getY()
        var distance = Math.max(0, targetY) - startY
        var startTime = new Date().getTime()
        duration = duration || Math.min(Math.abs(distance), defaultDuration);
        (function loopScroll() {
          setScrollTimeoutId(setTimeout(function () {
            // Calculate percentage:
            var p = Math.min(1, (new Date().getTime() - startTime) / duration)
            // Calculate the absolute vertical position:
            var y = Math.max(0, Math.floor(startY + distance * (p < 0.5 ? 2 * p * p : p * (4 - p * 2) - 1)))
            container.toY(y)
            if (p < 1 && (container.getHeight() + y) < container.body.scrollHeight) {
              loopScroll()
            } else {
              setTimeout(stopScroll, 99) // with cooldown time
              if (onDone) {
                onDone()
              }
            }
          }, 9))
        })()
      }
    }

    /**
     * Scrolls to the top of a specific element.
     *
     * @param {elem} The element to scroll to.
     * @param {duration} Optionally the duration of the scroll operation.
     * @param {onDone} An optional callback function to be invoked once the scroll finished.
     */
    var scrollToElem = function (elem, duration, onDone) {
      scrollToY(getTopWithEdgeOffset(elem), duration, onDone)
    }

    /**
     * Scrolls an element into view if necessary.
     *
     * @param {elem} The element.
     * @param {duration} Optionally the duration of the scroll operation.
     * @param {onDone} An optional callback function to be invoked once the scroll finished.
     */
    var scrollIntoView = function (elem, duration, onDone) {
      var elemHeight = elem.getBoundingClientRect().height
      var elemBottom = container.getTopOf(elem) + elemHeight
      var containerHeight = container.getHeight()
      var y = container.getY()
      var containerBottom = y + containerHeight
      if (getTopWithEdgeOffset(elem) < y || (elemHeight + edgeOffset) > containerHeight) {
        // Element is clipped at top or is higher than screen.
        scrollToElem(elem, duration, onDone)
      } else if ((elemBottom + edgeOffset) > containerBottom) {
        // Element is clipped at the bottom.
        scrollToY(elemBottom - containerHeight + edgeOffset, duration, onDone)
      } else if (onDone) {
        onDone()
      }
    }

    /**
     * Scrolls to the center of an element.
     *
     * @param {elem} The element.
     * @param {duration} Optionally the duration of the scroll operation.
     * @param {offset} Optionally the offset of the top of the element from the center of the screen.
     *        A value of 0 is ignored.
     * @param {onDone} An optional callback function to be invoked once the scroll finished.
     */
    var scrollToCenterOf = function (elem, duration, offset, onDone) {
      scrollToY(Math.max(0, container.getTopOf(elem) - container.getHeight() / 2 + (offset || elem.getBoundingClientRect().height / 2)), duration, onDone)
    }

    /**
     * Changes default settings for this scroller.
     *
     * @param {newDefaultDuration} Optionally a new value for default duration, used for each scroll method by default.
     *        Ignored if null or undefined.
     * @param {newEdgeOffset} Optionally a new value for the edge offset, used by each scroll method by default. Ignored if null or undefined.
     * @returns An object with the current values.
     */
    var setup = function (newDefaultDuration, newEdgeOffset) {
      if (newDefaultDuration === 0 || newDefaultDuration) {
        defaultDuration = newDefaultDuration
      }
      if (newEdgeOffset === 0 || newEdgeOffset) {
        edgeOffset = newEdgeOffset
      }
      return {
        defaultDuration: defaultDuration,
        edgeOffset: edgeOffset
      }
    }

    return {
      setup: setup,
      to: scrollToElem,
      toY: scrollToY,
      intoView: scrollIntoView,
      center: scrollToCenterOf,
      stop: stopScroll,
      moving: function () { return !!scrollTimeoutId },
      getY: container.getY,
      getTopOf: container.getTopOf
    }

  }


  var docElem = document.documentElement
  var getDocY = function () { return window.scrollY || docElem.scrollTop }

  // Create a scroller for the document:
  var zenscroll = makeScroller({
    body: document.scrollingElement || document.body,
    toY: function (y) { window.scrollTo(0, y) },
    getY: getDocY,
    getHeight: function () { return window.innerHeight || docElem.clientHeight },
    getTopOf: function (elem) { return elem.getBoundingClientRect().top + getDocY() - docElem.offsetTop }
  })


  /**
   * Creates a scroller from the provided container element (e.g., a DIV)
   *
   * @param {scrollContainer} The vertical position within the document.
   * @param {defaultDuration} Optionally a value for default duration, used for each scroll method by default.
   *        Ignored if 0 or null or undefined.
   * @param {edgeOffset} Optionally a value for the edge offset, used by each scroll method by default. 
   *        Ignored if null or undefined.
   * @returns A scroller object, similar to `zenscroll` but controlling the provided element.
   */
  zenscroll.createScroller = function (scrollContainer, defaultDuration, edgeOffset) {
    return makeScroller({
      body: scrollContainer,
      toY: function (y) { scrollContainer.scrollTop = y },
      getY: function () { return scrollContainer.scrollTop },
      getHeight: function () { return Math.min(scrollContainer.clientHeight, window.innerHeight || docElem.clientHeight) },
      getTopOf: function (elem) { return elem.offsetTop }
    }, defaultDuration, edgeOffset)
  }


  // Automatic link-smoothing on achors
  // Exclude IE8- or when native is enabled or Zenscroll auto- is disabled
  if ("addEventListener" in window && !window.noZensmooth && !isNativeSmoothScrollEnabledOn(document.body)) {

    var isHistorySupported = "history" in window && "pushState" in history
    var isScrollRestorationSupported = isHistorySupported && "scrollRestoration" in history

    // On first load & refresh make sure the browser restores the position first
    if (isScrollRestorationSupported) {
      history.scrollRestoration = "auto"
    }

    window.addEventListener("load", function () {

      if (isScrollRestorationSupported) {
        // Set it to manual
        setTimeout(function () { history.scrollRestoration = "manual" }, 9)
        window.addEventListener("popstate", function (event) {
          if (event.state && "zenscrollY" in event.state) {
            zenscroll.toY(event.state.zenscrollY)
          }
        }, false)
      }

      // Add edge offset on first load if necessary
      // This may not work on IE (or older computer?) as it requires more timeout, around 100 ms
      if (window.location.hash) {
        setTimeout(function () {
          // Adjustment is only needed if there is an edge offset:
          var edgeOffset = zenscroll.setup().edgeOffset
          if (edgeOffset) {
            var targetElem = document.getElementById(window.location.href.split("#")[1])
            if (targetElem) {
              var targetY = Math.max(0, zenscroll.getTopOf(targetElem) - edgeOffset)
              var diff = zenscroll.getY() - targetY
              // Only do the adjustment if the browser is very close to the element:
              if (0 <= diff && diff < 9) {
                window.scrollTo(0, targetY)
              }
            }
          }
        }, 9)
      }

    }, false)

    // Handling clicks on anchors
    var RE_noZensmooth = new RegExp("(^|\\s)noZensmooth(\\s|$)")
    window.addEventListener("click", function (event) {
      var anchor = event.target
      while (anchor && anchor.tagName !== "A") {
        anchor = anchor.parentNode
      }
      // Let the browser handle the click if it wasn't with the primary button, or with some modifier keys:
      if (!anchor || event.which !== 1 || event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {
        return
      }
      // Save the current scrolling position so it can be used for scroll restoration:
      if (isScrollRestorationSupported) {
        var historyState = history.state && typeof history.state === "object" ? history.state : {}
        historyState.zenscrollY = zenscroll.getY()
        try {
          history.replaceState(historyState, "")
        } catch (e) {
          // Avoid the Chrome Security exception on file protocol, e.g., file://index.html
        }
      }
      // Find the referenced ID:
      var href = anchor.getAttribute("href") || ""
      if (href.indexOf("#") === 0 && !RE_noZensmooth.test(anchor.className)) {
        var targetY = 0
        var targetElem = document.getElementById(href.substring(1))
        if (href !== "#") {
          if (!targetElem) {
            // Let the browser handle the click if the target ID is not found.
            return
          }
          targetY = zenscroll.getTopOf(targetElem)
        }
        event.preventDefault()
        // By default trigger the browser's `hashchange` event...
        var onDone = function () { window.location = href }
        // ...unless there is an edge offset specified
        var edgeOffset = zenscroll.setup().edgeOffset
        if (edgeOffset) {
          targetY = Math.max(0, targetY - edgeOffset)
          if (isHistorySupported) {
            onDone = function () { history.pushState({}, "", href) }
          }
        }
        zenscroll.toY(targetY, null, onDone)
      }
    }, false)

  }


  return zenscroll
}));
},{}]},{},[7])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvZGlzdC9janMvcG9wcGVyLmpzIiwibm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsInNyYy9qcy9mYW5jeWJveC5taW4uanMiLCJzcmMvanMvaW50bFRlbElucHV0LmpzIiwic3JjL2pzL2pRdWVyeS16b29tLmpzIiwic3JjL2pzL2pxdWVyeS5jcnMubWluLmpzIiwic3JjL2pzL21haW4uanMiLCJzcmMvanMvbW9kdWxlcy9hamF4LmpzIiwic3JjL2pzL21vZHVsZXMvY29uc3RhbnRzLmpzIiwic3JjL2pzL21vZHVsZXMvZHluYW1pYy9hc2stbW9kYWwuanMiLCJzcmMvanMvbW9kdWxlcy9keW5hbWljL2JhY2tkcm9wLmpzIiwic3JjL2pzL21vZHVsZXMvZHluYW1pYy9wYWdlLWNvbmZldHRpLmpzIiwic3JjL2pzL21vZHVsZXMvZHluYW1pYy9wYWdlVGlwLmpzIiwic3JjL2pzL21vZHVsZXMvZHluYW1pYy9yb290LWxvYWRlci5qcyIsInNyYy9qcy9tb2R1bGVzL2VsZW1lbnRzL2Zvb3Rlci5qcyIsInNyYy9qcy9tb2R1bGVzL2VsZW1lbnRzL2hlYWRlci5qcyIsInNyYy9qcy9tb2R1bGVzL2VsZW1lbnRzL2hlcm8tc3BsaWRlLmpzIiwic3JjL2pzL21vZHVsZXMvZWxlbWVudHMvcGFnZS1hbGVydHMuanMiLCJzcmMvanMvbW9kdWxlcy9lbGVtZW50cy9wYWdlLWVsZW1lbnRzLmpzIiwic3JjL2pzL21vZHVsZXMvZWxlbWVudHMvcGFnZS1yZXZpZXdzLmpzIiwic3JjL2pzL21vZHVsZXMvZWxlbWVudHMvcGctbW9kYWwuanMiLCJzcmMvanMvbW9kdWxlcy9lbGVtZW50cy9wZy1zZWxlY3QuanMiLCJzcmMvanMvbW9kdWxlcy9sb2dpbi5qcyIsInNyYy9qcy9tb2R1bGVzL21vZGFscy9ib29rLW1vZGFsLmpzIiwic3JjL2pzL21vZHVsZXMvbW9kYWxzL2NhcnQtbW9kYWwuanMiLCJzcmMvanMvbW9kdWxlcy9tb2RhbHMvY3VycmVuY3ktbW9kYWwuanMiLCJzcmMvanMvbW9kdWxlcy9tb2RhbHMvbWFpbC1tb2RhbC5qcyIsInNyYy9qcy9tb2R1bGVzL21vZGFscy9tZW51LmpzIiwic3JjL2pzL21vZHVsZXMvbW9kYWxzL3F1aXotbW9kYWwuanMiLCJzcmMvanMvbW9kdWxlcy9tb2RhbHMvc2FsZXMtbW9kYWwuanMiLCJzcmMvanMvbW9kdWxlcy9tb2RhbHMvc2lnbi1tb2RhbC5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2FjY291bnQtcGFnZS5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2Jsb2ctcGFnZS5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2Zvcm0tcGFnZS5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2hvbWVwYWdlLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvam9iLWFwcC5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2xvYW4tYXBwLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvbG9jYXRpb24tcGFnZS5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2xvb3NlLWRpYW1vbmRzLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvbXktYmFnLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvcGFzcy1yZXNldC5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL3Byb2R1Y3QuanMiLCJzcmMvanMvbW9kdWxlcy9wYWdlcy9yZXN1bHRzLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvc2VsbC1wYWdlLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvc2VsbC13YXRjaC5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL3RhZy1wcmV2aWV3LmpzIiwic3JjL2pzL21vZHVsZXMvdXRpbHMuanMiLCJzcmMvanMvbW9kdWxlcy92YXJpYWJsZXMuanMiLCJzcmMvanMvcGFyc2xleS5taW4uanMiLCJzcmMvanMvcG9wcGVyLmpzIiwic3JjL2pzL3NwbGlkZS1ncmlkLmpzIiwic3JjL2pzL3NwbGlkZS5qcyIsInNyYy9qcy90aXBweS5qcyIsInNyYy9qcy96ZW5zY3JvbGwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNTlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3p3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qKlxuICogQHBvcHBlcmpzL2NvcmUgdjIuMTEuOCAtIE1JVCBMaWNlbnNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKSB7XG4gIHZhciB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcyAmJiBBcnJheS5pc0FycmF5KHVhRGF0YS5icmFuZHMpKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5icmFuZCArIFwiL1wiICsgaXRlbS52ZXJzaW9uO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuXG5mdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gMTtcbiAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgc2NhbGVYID0gZWxlbWVudC5vZmZzZXRXaWR0aCA+IDAgPyByb3VuZChjbGllbnRSZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSA6IDE7XG4gICAgc2NhbGVZID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSA6IDE7XG4gIH1cblxuICB2YXIgX3JlZiA9IGlzRWxlbWVudChlbGVtZW50KSA/IGdldFdpbmRvdyhlbGVtZW50KSA6IHdpbmRvdyxcbiAgICAgIHZpc3VhbFZpZXdwb3J0ID0gX3JlZi52aXN1YWxWaWV3cG9ydDtcblxuICB2YXIgYWRkVmlzdWFsT2Zmc2V0cyA9ICFpc0xheW91dFZpZXdwb3J0KCkgJiYgaXNGaXhlZFN0cmF0ZWd5O1xuICB2YXIgeCA9IChjbGllbnRSZWN0LmxlZnQgKyAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQgOiAwKSkgLyBzY2FsZVg7XG4gIHZhciB5ID0gKGNsaWVudFJlY3QudG9wICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3AgOiAwKSkgLyBzY2FsZVk7XG4gIHZhciB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZVg7XG4gIHZhciBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlWTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIGxlZnQ6IHgsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQsIGlzRml4ZWQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5mdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn1cblxuLypcbmdpdmVuIGEgRE9NIGVsZW1lbnQsIHJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2Nyb2xsIHBhcmVudHMsIHVwIHRoZSBsaXN0IG9mIGFuY2Vzb3JzXG51bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xudG8sIGJlY2F1c2UgaWYgYW55IG9mIHRoZXNlIHBhcmVudCBlbGVtZW50cyBzY3JvbGwsIHdlJ2xsIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZVxucmVmZXJlbmNlIGVsZW1lbnQncyBwb3NpdGlvbi5cbiovXG5cbmZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG5cbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gKChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSk7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG59XG5cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIHZhciBpc0ZpcmVmb3ggPSAvZmlyZWZveC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG4gIHZhciBpc0lFID0gL1RyaWRlbnQvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuXG4gIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGVsZW1lbnRDc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgaWYgKGlzU2hhZG93Um9vdChjdXJyZW50Tm9kZSkpIHtcbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmhvc3Q7XG4gIH1cblxuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG5cbiAgICBpZiAoY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufVxuXG52YXIgdG9wID0gJ3RvcCc7XG52YXIgYm90dG9tID0gJ2JvdHRvbSc7XG52YXIgcmlnaHQgPSAncmlnaHQnO1xudmFyIGxlZnQgPSAnbGVmdCc7XG52YXIgYXV0byA9ICdhdXRvJztcbnZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xudmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbnZhciBlbmQgPSAnZW5kJztcbnZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbnZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG52YXIgcG9wcGVyID0gJ3BvcHBlcic7XG52YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG52YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xudmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxudmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG52YXIgcmVhZCA9ICdyZWFkJztcbnZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxudmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG52YXIgbWFpbiA9ICdtYWluJztcbnZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG52YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xudmFyIHdyaXRlID0gJ3dyaXRlJztcbnZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xudmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdO1xuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICB2YXIgbGF5b3V0Vmlld3BvcnQgPSBpc0xheW91dFZpZXdwb3J0KCk7XG5cbiAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufVxuXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIHZhciBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xuICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5IHx8IGh0bWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuXG5mdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBzdHJhdGVneSA9IF9vcHRpb25zJHN0cmF0ZWd5ID09PSB2b2lkIDAgPyBzdGF0ZS5zdHJhdGVneSA6IF9vcHRpb25zJHN0cmF0ZWd5LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn1cblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHNldE9wdGlvbnNBY3Rpb24gPT09ICdmdW5jdGlvbicgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpIDogc2V0T3B0aW9uc0FjdGlvbjtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICAgICAgX3JlZiRvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QkMihfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIGV2ZW50TGlzdGVuZXJzID0ge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0JDIsXG4gIGRhdGE6IHt9XG59O1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBwb3BwZXJPZmZzZXRzJDEgPSB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59O1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYsIHdpbikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXG4gICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcbiAgdmFyIF9vZmZzZXRzJHggPSBvZmZzZXRzLngsXG4gICAgICB4ID0gX29mZnNldHMkeCA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHgsXG4gICAgICBfb2Zmc2V0cyR5ID0gb2Zmc2V0cy55LFxuICAgICAgeSA9IF9vZmZzZXRzJHkgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR5O1xuXG4gIHZhciBfcmVmMyA9IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjMueDtcbiAgeSA9IF9yZWYzLnk7XG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgdmFyIG9mZnNldFkgPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcbiAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCAocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWCA9IHJpZ2h0O1xuICAgICAgdmFyIG9mZnNldFggPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF07XG4gICAgICB4IC09IG9mZnNldFggLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICB2YXIgX3JlZjQgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUih7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0sIGdldFdpbmRvdyhwb3BwZXIpKSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjQueDtcbiAgeSA9IF9yZWY0Lnk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjUpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjUuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjUub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXG4gICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XG4gIHZhciBjb21tb25TdHlsZXMgPSB7XG4gICAgcGxhY2VtZW50OiBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCksXG4gICAgdmFyaWF0aW9uOiBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb24sXG4gICAgaXNGaXhlZDogc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJ1xuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBjb21wdXRlU3R5bGVzJDEgPSB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTtcblxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0JDEoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBhcHBseVN0eWxlcyQxID0ge1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGVmZmVjdCQxLFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07XG5cbmZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgb2Zmc2V0JDEgPSB7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRcbn07XG5cbnZhciBoYXNoJDEgPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaCQxW21hdGNoZWRdO1xuICB9KTtcbn1cblxudmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IHBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcbiAgdmFyIHBsYWNlbWVudHMkMSA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyQxLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyQxO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG5cblxuICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIGZsaXAkMSA9IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn1cblxuZnVuY3Rpb24gd2l0aGluKG1pbiQxLCB2YWx1ZSwgbWF4JDEpIHtcbiAgcmV0dXJuIG1heChtaW4kMSwgbWluKHZhbHVlLCBtYXgkMSkpO1xufVxuZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gIHZhciB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcbn1cblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcbiAgICBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZVxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkO1xuXG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4kMSA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4JDEgPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWluKG1pbiQxLCB0ZXRoZXJNaW4pIDogbWluJDEsIG9mZnNldCwgdGV0aGVyID8gbWF4KG1heCQxLCB0ZXRoZXJNYXgpIDogbWF4JDEpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBwcmV2ZW50T3ZlcmZsb3ckMSA9IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07XG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBhcnJvdyQxID0ge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn07XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBoaWRlJDEgPSB7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn07XG5cbnZhciBkZWZhdWx0TW9kaWZpZXJzJDEgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMkMSwgY29tcHV0ZVN0eWxlcyQxLCBhcHBseVN0eWxlcyQxXTtcbnZhciBjcmVhdGVQb3BwZXIkMSA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzJDFcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzJDEsIGNvbXB1dGVTdHlsZXMkMSwgYXBwbHlTdHlsZXMkMSwgb2Zmc2V0JDEsIGZsaXAkMSwgcHJldmVudE92ZXJmbG93JDEsIGFycm93JDEsIGhpZGUkMV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydHMuYXBwbHlTdHlsZXMgPSBhcHBseVN0eWxlcyQxO1xuZXhwb3J0cy5hcnJvdyA9IGFycm93JDE7XG5leHBvcnRzLmNvbXB1dGVTdHlsZXMgPSBjb21wdXRlU3R5bGVzJDE7XG5leHBvcnRzLmNyZWF0ZVBvcHBlciA9IGNyZWF0ZVBvcHBlcjtcbmV4cG9ydHMuY3JlYXRlUG9wcGVyTGl0ZSA9IGNyZWF0ZVBvcHBlciQxO1xuZXhwb3J0cy5kZWZhdWx0TW9kaWZpZXJzID0gZGVmYXVsdE1vZGlmaWVycztcbmV4cG9ydHMuZGV0ZWN0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdztcbmV4cG9ydHMuZXZlbnRMaXN0ZW5lcnMgPSBldmVudExpc3RlbmVycztcbmV4cG9ydHMuZmxpcCA9IGZsaXAkMTtcbmV4cG9ydHMuaGlkZSA9IGhpZGUkMTtcbmV4cG9ydHMub2Zmc2V0ID0gb2Zmc2V0JDE7XG5leHBvcnRzLnBvcHBlckdlbmVyYXRvciA9IHBvcHBlckdlbmVyYXRvcjtcbmV4cG9ydHMucG9wcGVyT2Zmc2V0cyA9IHBvcHBlck9mZnNldHMkMTtcbmV4cG9ydHMucHJldmVudE92ZXJmbG93ID0gcHJldmVudE92ZXJmbG93JDE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXIuanMubWFwXG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNy4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIzLTA4LTI4VDEzOjM3WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCB0cmFjLTE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgZmxhdCA9IGFyci5mbGF0ID8gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmZsYXQuY2FsbCggYXJyYXkgKTtcbn0gOiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuY29uY2F0LmFwcGx5KCBbXSwgYXJyYXkgKTtcbn07XG5cblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcblx0XHQvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcblx0XHQvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuXHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cblx0XHQvLyBTdXBwb3J0OiBRdFdlYiA8PTMuOC41LCBXZWJLaXQgPD01MzQuMzQsIHdraHRtbHRvcGRmIHRvb2wgPD0wLjEyLjVcblx0XHQvLyBQbHVzIGZvciBvbGQgV2ViS2l0LCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgY29sbGVjdGlvbnNcblx0XHQvLyAoZS5nLiwgYHR5cGVvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKSA9PT0gXCJmdW5jdGlvblwiYCkuIChnaC00NzU2KVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIiAmJlxuXHRcdFx0dHlwZW9mIG9iai5pdGVtICE9PSBcImZ1bmN0aW9uXCI7XG5cdH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhciB2ZXJzaW9uID0gXCIzLjcuMVwiLFxuXG5cdHJodG1sU3VmZml4ID0gL0hUTUwkL2ksXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRldmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gKCBpICsgMSApICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRvZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBpICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IFwiX19wcm90b19fXCIgfHwgdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXHRcdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSAmJiAhQXJyYXkuaXNBcnJheSggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IFtdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICFjb3B5SXNBcnJheSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSB7fTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgcHJvdmlkZWQgY29udGV4dDsgZmFsbHMgYmFjayB0byB0aGUgZ2xvYmFsIG9uZVxuXHQvLyBpZiBub3Qgc3BlY2lmaWVkLlxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSwgb3B0aW9ucywgZG9jICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9LCBkb2MgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmUgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG5cdHRleHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBub2RlLFxuXHRcdFx0cmV0ID0gXCJcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cblx0XHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0XHR3aGlsZSAoICggbm9kZSA9IGVsZW1bIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdFx0cmV0ICs9IGpRdWVyeS50ZXh0KCBub2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fVxuXHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kb2N1bWVudEVsZW1lbnQudGV4dENvbnRlbnQ7XG5cdFx0fVxuXHRcdGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdFx0fVxuXG5cdFx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHRpc1hNTERvYzogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWVzcGFjZSA9IGVsZW0gJiYgZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0XHRkb2NFbGVtID0gZWxlbSAmJiAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlXG5cdFx0Ly8gZG9jdW1lbnQgZnJhZ21lbnRzLlxuXHRcdHJldHVybiAhcmh0bWxTdWZmaXgudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGZsYXQoIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdFx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG5cdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59XG52YXIgcG9wID0gYXJyLnBvcDtcblxuXG52YXIgc29ydCA9IGFyci5zb3J0O1xuXG5cbnZhciBzcGxpY2UgPSBhcnIuc3BsaWNlO1xuXG5cbnZhciB3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiO1xuXG5cbnZhciBydHJpbUNTUyA9IG5ldyBSZWdFeHAoXG5cdFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsXG5cdFwiZ1wiXG4pO1xuXG5cblxuXG4vLyBOb3RlOiBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5qUXVlcnkuY29udGFpbnMgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0dmFyIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXG5cdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHRcdC8vIElFIGRvZXNuJ3QgaGF2ZSBgY29udGFpbnNgIG9uIFNWRy5cblx0XHRhLmNvbnRhaW5zID9cblx0XHRcdGEuY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHQpICk7XG59O1xuXG5cblxuXG4vLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG52YXIgcmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxceDgwLVxcdUZGRkZcXHctXS9nO1xuXG5mdW5jdGlvbiBmY3NzZXNjYXBlKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdH1cblxuXHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0fVxuXG5cdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG59XG5cbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoIHNlbCArIFwiXCIgKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5cblxuXG52YXIgcHJlZmVycmVkRG9jID0gZG9jdW1lbnQsXG5cdHB1c2hOYXRpdmUgPSBwdXNoO1xuXG4oIGZ1bmN0aW9uKCkge1xuXG52YXIgaSxcblx0RXhwcixcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cdHB1c2ggPSBwdXNoTmF0aXZlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0ZG9jdW1lbnQsXG5cdGRvY3VtZW50RWxlbWVudCxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0bWF0Y2hlcyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRub25uYXRpdmVTZWxlY3RvckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxcIiArXG5cdFx0XCJsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lkZW50LXRva2VuLWRpYWdyYW1cblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiP3xcXFxcXFxcXFteXFxcXHJcXFxcblxcXFxmXXxbXFxcXHctXXxbXlxcMC1cXFxceDdmXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblxuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmxlYWRpbmdDb21iaW5hdG9yID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmRlc2NlbmQgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCJ8PlwiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRJRDogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdENMQVNTOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFRBRzogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdEFUVFI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFBTRVVETzogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0Q0hJTEQ6IG5ldyBSZWdFeHAoXG5cdFx0XHRcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgK1xuXHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgK1xuXHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0Ym9vbDogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRuZWVkc0NvbnRleHQ6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIj98XFxcXFxcXFwoW15cXFxcclxcXFxuXFxcXGZdKVwiLCBcImdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggZXNjYXBlLCBub25IZXggKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGUuc2xpY2UoIDEgKSAtIDB4MTAwMDA7XG5cblx0XHRpZiAoIG5vbkhleCApIHtcblxuXHRcdFx0Ly8gU3RyaXAgdGhlIGJhY2tzbGFzaCBwcmVmaXggZnJvbSBhIG5vbi1oZXggZXNjYXBlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gbm9uSGV4O1xuXHRcdH1cblxuXHRcdC8vIFJlcGxhY2UgYSBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2Ugd2l0aCB0aGUgZW5jb2RlZCBVbmljb2RlIGNvZGUgcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExK1xuXHRcdC8vIEZvciB2YWx1ZXMgb3V0c2lkZSB0aGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lIChCTVApLCBtYW51YWxseSBjb25zdHJ1Y3QgYVxuXHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0cmV0dXJuIGhpZ2ggPCAwID9cblx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lczsgc2VlIGBzZXREb2N1bWVudGAuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFL0VkZ2UuXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBub2RlTmFtZSggZWxlbSwgXCJmaWVsZHNldFwiICk7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoIGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkgKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHtcblx0XHRhcHBseTogZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaE5hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKCBlbHMgKSApO1xuXHRcdH0sXG5cdFx0Y2FsbDogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHRcdHB1c2hOYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICkgKTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGZpbmQoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAoIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAoIG0gPSBtYXRjaFsgMSBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHB1c2guY2FsbCggcmVzdWx0cywgZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmICggZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICYmXG5cdFx0XHRcdFx0XHRcdGZpbmQuY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHB1c2guY2FsbCggcmVzdWx0cywgZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMiBdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIG0gPSBtYXRjaFsgMyBdICkgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCAhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhlIHRlY2huaXF1ZSBoYXMgdG8gYmUgdXNlZCBhcyB3ZWxsIHdoZW4gYSBsZWFkaW5nIGNvbWJpbmF0b3IgaXMgdXNlZFxuXHRcdFx0XHQvLyBhcyBzdWNoIHNlbGVjdG9ycyBhcmUgbm90IHJlY29nbml6ZWQgYnkgcXVlcnlTZWxlY3RvckFsbC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCByZGVzY2VuZC50ZXN0KCBzZWxlY3RvciApIHx8IHJsZWFkaW5nQ29tYmluYXRvci50ZXN0KCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBXZSBjYW4gdXNlIDpzY29wZSBpbnN0ZWFkIG9mIHRoZSBJRCBoYWNrIGlmIHRoZSBicm93c2VyXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydHMgaXQgJiBpZiB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIGNvbnRleHQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlblxuXHRcdFx0XHRcdC8vIHN0cmljdC1jb21wYXJpbmcgdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgIT0gY29udGV4dCB8fCAhc3VwcG9ydC5zY29wZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRcdGlmICggKCBuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkgKSApIHtcblx0XHRcdFx0XHRcdFx0bmlkID0galF1ZXJ5LmVzY2FwZVNlbGVjdG9yKCBuaWQgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsICggbmlkID0gZXhwYW5kbyApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbIGkgXSA9ICggbmlkID8gXCIjXCIgKyBuaWQgOiBcIjpzY29wZVwiICkgKyBcIiBcIiArXG5cdFx0XHRcdFx0XHRcdHRvU2VsZWN0b3IoIGdyb3Vwc1sgaSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllc1xuXHRcdC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvaXNzdWVzLzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuICggY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSApO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IGpRdWVyeSBzZWxlY3RvciBtb2R1bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICk7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgfHwgbm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKSApICYmXG5cdFx0XHRlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTErXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbICggaiA9IG1hdGNoSW5kZXhlc1sgaSBdICkgXSApIHtcblx0XHRcdFx0XHRzZWVkWyBqIF0gPSAhKCBtYXRjaGVzWyBqIF0gPSBzZWVkWyBqIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgalF1ZXJ5IHNlbGVjdG9yIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbbm9kZV0gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0RG9jdW1lbnQoIG5vZGUgKSB7XG5cdHZhciBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggZG9jID09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFqUXVlcnkuaXNYTUxEb2MoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDcgb25seSwgSUUgOSAtIDExK1xuXHQvLyBPbGRlciBicm93c2VycyBkaWRuJ3Qgc3VwcG9ydCB1bnByZWZpeGVkIGBtYXRjaGVzYC5cblx0bWF0Y2hlcyA9IGRvY3VtZW50RWxlbWVudC5tYXRjaGVzIHx8XG5cdFx0ZG9jdW1lbnRFbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY3VtZW50RWxlbWVudC5tc01hdGNoZXNTZWxlY3RvcjtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yc1xuXHQvLyAoc2VlIHRyYWMtMTM5MzYpLlxuXHQvLyBMaW1pdCB0aGUgZml4IHRvIElFICYgRWRnZSBMZWdhY3k7IGRlc3BpdGUgRWRnZSAxNSsgaW1wbGVtZW50aW5nIGBtYXRjaGVzYCxcblx0Ly8gYWxsIElFIDkrIGFuZCBFZGdlIExlZ2FjeSB2ZXJzaW9ucyBpbXBsZW1lbnQgYG1zTWF0Y2hlc1NlbGVjdG9yYCBhcyB3ZWxsLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5tc01hdGNoZXNTZWxlY3RvciAmJlxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRwcmVmZXJyZWREb2MgIT0gZG9jdW1lbnQgJiZcblx0XHQoIHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ICkgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBlbCApLmlkID0galF1ZXJ5LmV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fFxuXHRcdFx0IWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBqUXVlcnkuZXhwYW5kbyApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZS5cblx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdHJldHVybiBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBJRS9FZGdlIGRvbid0IHN1cHBvcnQgdGhlIDpzY29wZSBwc2V1ZG8tY2xhc3MuXG5cdHN1cHBvcnQuc2NvcGUgPSBhc3NlcnQoIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpzY29wZVwiICk7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBDaHJvbWUgMTA1IC0gMTExIG9ubHksIFNhZmFyaSAxNS40IC0gMTYuMyBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0aGUgYDpoYXMoKWAgYXJndW1lbnQgaXMgcGFyc2VkIHVuZm9yZ2l2aW5nbHkuXG5cdC8vIFdlIGluY2x1ZGUgYCpgIGluIHRoZSB0ZXN0IHRvIGRldGVjdCBidWdneSBpbXBsZW1lbnRhdGlvbnMgdGhhdCBhcmVcblx0Ly8gX3NlbGVjdGl2ZWx5XyBmb3JnaXZpbmcgKHNwZWNpZmljYWxseSB3aGVuIHRoZSBsaXN0IGluY2x1ZGVzIGF0IGxlYXN0XG5cdC8vIG9uZSB2YWxpZCBzZWxlY3RvcikuXG5cdC8vIE5vdGUgdGhhdCB3ZSB0cmVhdCBjb21wbGV0ZSBsYWNrIG9mIHN1cHBvcnQgZm9yIGA6aGFzKClgIGFzIGlmIGl0IHdlcmVcblx0Ly8gc3BlYy1jb21wbGlhbnQgc3VwcG9ydCwgd2hpY2ggaXMgZmluZSBiZWNhdXNlIHVzZSBvZiBgOmhhcygpYCBpbiBzdWNoXG5cdC8vIGVudmlyb25tZW50cyB3aWxsIGZhaWwgaW4gdGhlIHFTQSBwYXRoIGFuZCBmYWxsIGJhY2sgdG8galF1ZXJ5IHRyYXZlcnNhbFxuXHQvLyBhbnl3YXkuXG5cdHN1cHBvcnQuY3NzSGFzID0gYXNzZXJ0KCBmdW5jdGlvbigpIHtcblx0XHR0cnkge1xuXHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvciggXCI6aGFzKCosOmpxZmFrZSlcIiApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9ICk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyLklEID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJpZFwiICkgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmQuSUQgPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyLklEID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZC5JRCA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kLlRBRyA9IGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kLkNMQVNTID0gZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdC8vIEJ1aWxkIFFTQSByZWdleFxuXHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0dmFyIGlucHV0O1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9XG5cdFx0XHRcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIicgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIGRpc2FibGVkPSdkaXNhYmxlZCc+XCIgK1xuXHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogaU9TIDw9NyAtIDggb25seVxuXHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHkgaW4gc29tZSBYTUwgZG9jdW1lbnRzXG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbc2VsZWN0ZWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA8PTcgLSA4IG9ubHlcblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwifj1cIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA4IG9ubHlcblx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIuIy4rWyt+XVwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MTA1KywgRmlyZWZveCA8PTEwNCssIFNhZmFyaSA8PTE1LjQrXG5cdFx0Ly8gSW4gc29tZSBvZiB0aGUgZG9jdW1lbnQga2luZHMsIHRoZXNlIHNlbGVjdG9ycyB3b3VsZG4ndCB3b3JrIG5hdGl2ZWx5LlxuXHRcdC8vIFRoaXMgaXMgcHJvYmFibHkgT0sgYnV0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3ZSB3YW50IHRvIG1haW50YWluXG5cdFx0Ly8gaGFuZGxpbmcgdGhlbSB0aHJvdWdoIGpRdWVyeSB0cmF2ZXJzYWwgaW4galF1ZXJ5IDMueC5cblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpjaGVja2VkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6Y2hlY2tlZFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0xMDUrLCBGaXJlZm94IDw9MTA0KywgU2FmYXJpIDw9MTUuNCtcblx0XHQvLyBJbiBzb21lIG9mIHRoZSBkb2N1bWVudCBraW5kcywgdGhlc2Ugc2VsZWN0b3JzIHdvdWxkbid0IHdvcmsgbmF0aXZlbHkuXG5cdFx0Ly8gVGhpcyBpcyBwcm9iYWJseSBPSyBidXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdlIHdhbnQgdG8gbWFpbnRhaW5cblx0XHQvLyBoYW5kbGluZyB0aGVtIHRocm91Z2ggalF1ZXJ5IHRyYXZlcnNhbCBpbiBqUXVlcnkgMy54LlxuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpkaXNhYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXG5cdFx0Ly8gQWRkaW5nIGEgdGVtcG9yYXJ5IGF0dHJpYnV0ZSB0byB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBzZWxlY3Rpb24gd29ya3Ncblx0XHQvLyBhcm91bmQgdGhlIGlzc3VlLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiXCIgKTtcblx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIipuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqPVwiICtcblx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0aWYgKCAhc3VwcG9ydC5jc3NIYXMgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgMTA1IC0gMTEwKywgU2FmYXJpIDE1LjQgLSAxNi4zK1xuXHRcdC8vIE91ciByZWd1bGFyIGB0cnktY2F0Y2hgIG1lY2hhbmlzbSBmYWlscyB0byBkZXRlY3QgbmF0aXZlbHktdW5zdXBwb3J0ZWRcblx0XHQvLyBwc2V1ZG8tY2xhc3NlcyBpbnNpZGUgYDpoYXMoKWAgKHN1Y2ggYXMgYDpoYXMoOmNvbnRhaW5zKFwiRm9vXCIpKWApXG5cdFx0Ly8gaW4gYnJvd3NlcnMgdGhhdCBwYXJzZSB0aGUgYDpoYXMoKWAgYXJndW1lbnQgYXMgYSBmb3JnaXZpbmcgc2VsZWN0b3IgbGlzdC5cblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvc2VsZWN0b3JzLyNyZWxhdGlvbmFsIG5vdyByZXF1aXJlcyB0aGUgYXJndW1lbnRcblx0XHQvLyB0byBiZSBwYXJzZWQgdW5mb3JnaXZpbmdseSwgYnV0IGJyb3dzZXJzIGhhdmUgbm90IHlldCBmdWxseSBhZGp1c3RlZC5cblx0XHRyYnVnZ3lRU0EucHVzaCggXCI6aGFzXCIgKTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oIFwifFwiICkgKTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoICFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUgKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGZpbmQuY29udGFpbnMoIHByZWZlcnJlZERvYywgYSApICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0ZmluZC5jb250YWlucyggcHJlZmVycmVkRG9jLCBiICkgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn1cblxuZmluZC5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gZmluZCggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cbmZpbmQubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdHNldERvY3VtZW50KCBlbGVtICk7XG5cblx0aWYgKCBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmluZCggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cbmZpbmQuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5cbmZpbmQuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgdHJhYy0xMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdGlmICggdmFsICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xufTtcblxuZmluZC5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5qUXVlcnkudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHQvL1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wK1xuXHQvLyBUZXN0aW5nIGZvciBkZXRlY3RpbmcgZHVwbGljYXRlcyBpcyB1bnByZWRpY3RhYmxlIHNvIGluc3RlYWQgYXNzdW1lIHdlIGNhbid0XG5cdC8vIGRlcGVuZCBvbiBkdXBsaWNhdGUgZGV0ZWN0aW9uIGluIGFsbCBicm93c2VycyB3aXRob3V0IGEgc3RhYmxlIHNvcnQuXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LnNvcnRTdGFibGU7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgc2xpY2UuY2FsbCggcmVzdWx0cywgMCApO1xuXHRzb3J0LmNhbGwoIHJlc3VsdHMsIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKCBlbGVtID0gcmVzdWx0c1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0c3BsaWNlLmNhbGwoIHJlc3VsdHMsIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxualF1ZXJ5LmZuLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkudW5pcXVlU29ydCggc2xpY2UuYXBwbHkoIHRoaXMgKSApICk7XG59O1xuXG5FeHByID0galF1ZXJ5LmV4cHIgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0QVRUUjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWyAzIF0gPSAoIG1hdGNoWyAzIF0gfHwgbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCIgKVxuXHRcdFx0XHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMiBdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWyAzIF0gPSBcIiBcIiArIG1hdGNoWyAzIF0gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdENISUxEOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAxIF0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblxuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRcdGZpbmQuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWyA0IF0gPSArKCBtYXRjaFsgNCBdID9cblx0XHRcdFx0XHRtYXRjaFsgNSBdICsgKCBtYXRjaFsgNiBdIHx8IDEgKSA6XG5cdFx0XHRcdFx0MiAqICggbWF0Y2hbIDMgXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG1hdGNoWyA1IF0gPSArKCAoIG1hdGNoWyA3IF0gKyBtYXRjaFsgOCBdICkgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdGZpbmQuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRQU0VVRE86IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWyA2IF0gJiYgbWF0Y2hbIDIgXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHIuQ0hJTEQudGVzdCggbWF0Y2hbIDAgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IG1hdGNoWyA0IF0gfHwgbWF0Y2hbIDUgXSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KCBleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSApICYmXG5cblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdCggZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFRBRzogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgZXhwZWN0ZWROb2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGVsZW0sIGV4cGVjdGVkTm9kZU5hbWUgKTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Q0xBU1M6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdCggcGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgK1xuXHRcdFx0XHRcdFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSApICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdChcblx0XHRcdFx0XHRcdHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fFxuXHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHxcblx0XHRcdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0QVRUUjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IGZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIj1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0ID09PSBjaGVjaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIiE9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCAhPT0gY2hlY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCJePVwiICkge1xuXHRcdFx0XHRcdHJldHVybiBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIio9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCIkPVwiICkge1xuXHRcdFx0XHRcdHJldHVybiBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRcdHJldHVybiAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKVxuXHRcdFx0XHRcdFx0LmluZGV4T2YoIGNoZWNrICkgPiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcInw9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRDSElMRDogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIF9hcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9IG5vZGVbIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGVOYW1lKCBub2RlLCBuYW1lICkgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBwYXJlbnRbIGV4cGFuZG8gXSB8fCAoIHBhcmVudFsgZXhwYW5kbyBdID0ge30gKTtcblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IG91dGVyQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZU5hbWUoIG5vZGUsIG5hbWUgKSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRQU0VVRE86IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRmaW5kLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgalF1ZXJ5IGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mLmNhbGwoIHNlZWQsIG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0bm90OiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblxuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGkgXSA9ICEoIG1hdGNoZXNbIGkgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblxuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHQvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2lzc3Vlcy8yOTkpXG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdGhhczogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBmaW5kKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdGNvbnRhaW5zOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBqUXVlcnkudGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdGxhbmc6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QoIGxhbmcgfHwgXCJcIiApICkge1xuXHRcdFx0XHRmaW5kLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwieG1sOmxhbmdcIiApIHx8IGVsZW0uZ2V0QXR0cmlidXRlKCBcImxhbmdcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoIGVsZW0gPSBlbGVtLnBhcmVudE5vZGUgKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdHRhcmdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0cm9vdDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0sXG5cblx0XHRmb2N1czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJlxuXHRcdFx0XHRkb2N1bWVudC5oYXNGb2N1cygpICYmXG5cdFx0XHRcdCEhKCBlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4ICk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdGVuYWJsZWQ6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdGRpc2FibGVkOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0Y2hlY2tlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHRyZXR1cm4gKCBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgISFlbGVtLmNoZWNrZWQgKSB8fFxuXHRcdFx0XHQoIG5vZGVOYW1lKCBlbGVtLCBcIm9wdGlvblwiICkgJiYgISFlbGVtLnNlbGVjdGVkICk7XG5cdFx0fSxcblxuXHRcdHNlbGVjdGVkOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMStcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuXHRcdFx0Ly8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHRyZWF0IHRoZSBkZWZhdWx0IG9wdGlvbiBhc1xuXHRcdFx0Ly8gc2VsZWN0ZWQgd2hlbiBpbiBhbiBvcHRncm91cC5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRlbXB0eTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvcy5lbXB0eSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0aGVhZGVyOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0aW5wdXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRidXR0b246IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHxcblx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKTtcblx0XHR9LFxuXG5cdFx0dGV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDwxMCBvbmx5XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXJcblx0XHRcdFx0Ly8gd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKCBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgKSA9PSBudWxsIHx8XG5cdFx0XHRcdFx0YXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0Zmlyc3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0gKSxcblxuXHRcdGxhc3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSApLFxuXG5cdFx0ZXE6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0gKSxcblxuXHRcdGV2ZW46IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRvZGQ6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRsdDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRpZiAoIGFyZ3VtZW50IDwgMCApIHtcblx0XHRcdFx0aSA9IGFyZ3VtZW50ICsgbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmICggYXJndW1lbnQgPiBsZW5ndGggKSB7XG5cdFx0XHRcdGkgPSBsZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gYXJndW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRndDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApXG5cdH1cbn07XG5cbkV4cHIucHNldWRvcy5udGggPSBFeHByLnBzZXVkb3MuZXE7XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxuZnVuY3Rpb24gdG9rZW5pemUoIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAoIG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbIDAgXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAoIHRva2VucyA9IFtdICkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKCBtYXRjaCA9IHJsZWFkaW5nQ29tYmluYXRvci5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFsgMCBdLnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiBcIiApXG5cdFx0XHR9ICk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAoIG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSApICYmICggIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQoIG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApICkgKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdGlmICggcGFyc2VPbmx5ICkge1xuXHRcdHJldHVybiBzb0Zhci5sZW5ndGg7XG5cdH1cblxuXHRyZXR1cm4gc29GYXIgP1xuXHRcdGZpbmQuZXJyb3IoIHNlbGVjdG9yICkgOlxuXG5cdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufVxuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zWyBpIF0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblxuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBub2RlTmFtZSggZWxlbSwgc2tpcCApICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoICggb2xkQ2FjaGUgPSBvdXRlckNhY2hlWyBrZXkgXSApICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuICggbmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoICggbmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbIGkgXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1sgMCBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGZpbmQoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sIG1hdGNoZXJPdXQsXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHxcblx0XHRcdFx0bXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsXG5cdFx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcztcblxuXHRcdGlmICggbWF0Y2hlciApIHtcblxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXJcblx0XHRcdC8vIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRtYXRjaGVyT3V0ID0gcG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdHJlc3VsdHM7XG5cblx0XHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlckluO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKCBlbGVtID0gdGVtcFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFsgaSBdIF0gPSAhKCBtYXRjaGVySW5bIHBvc3RNYXBbIGkgXSBdID0gZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAoIG1hdGNoZXJJblsgaSBdID0gZWxlbSApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsICggbWF0Y2hlck91dCA9IFtdICksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICYmXG5cdFx0XHRcdFx0XHQoIHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZi5jYWxsKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbIGkgXSApID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbIHRlbXAgXSA9ICEoIHJlc3VsdHNbIHRlbXAgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDAgXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlWyBcIiBcIiBdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KCBjaGVja0NvbnRleHQgPSBjb250ZXh0ICkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblxuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnRcblx0XHRcdC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvaXNzdWVzLzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggbWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaSBdLnR5cGUgXSApICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyICkgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbIGkgXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1sgaSBdLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaiBdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApXG5cdFx0XHRcdFx0XHRcdC5jb25jYXQoIHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9IClcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICggdG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkgKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmQuVEFHKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9ICggZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEgKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IGlPUyA8PTcgLSA5IG9ubHlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZ1xuXHRcdFx0Ly8gZWxlbWVudHMgYnkgaWQuIChzZWUgdHJhYy0xNDE0Milcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRwdXNoLmNhbGwoIHJlc3VsdHMsIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gc2V0TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblxuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKCB1bm1hdGNoZWRbIGkgXSB8fCBzZXRNYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkWyBpIF0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoWyBpIF0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLFxuXHRcdFx0bWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBqUXVlcnkncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIGpRdWVyeSBzZWxlY3RvciBjb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuZnVuY3Rpb24gc2VsZWN0KCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoIHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IgKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAoIHRva2VuID0gdG9rZW5zWyAwIF0gKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDEgXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZC5JRChcblx0XHRcdFx0dG9rZW4ubWF0Y2hlc1sgMCBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdGNvbnRleHRcblx0XHRcdCkgfHwgW10gKVsgMCBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwci5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbIGkgXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAoIHR5cGUgPSB0b2tlbi50eXBlICkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICggZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdICkgKSB7XG5cblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKCBzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWyAwIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbIDAgXS50eXBlICkgJiZcblx0XHRcdFx0XHRcdHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkgKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgLSA0LjErXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdCggXCJcIiApLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oIFwiXCIgKSA9PT0gZXhwYW5kbztcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIC0gNC4xK1xuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApICkgJiAxO1xufSApO1xuXG5qUXVlcnkuZmluZCA9IGZpbmQ7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWUgPSBqUXVlcnkudW5pcXVlU29ydDtcblxuLy8gVGhlc2UgaGF2ZSBhbHdheXMgYmVlbiBwcml2YXRlLCBidXQgdGhleSB1c2VkIHRvIGJlIGRvY3VtZW50ZWQgYXMgcGFydCBvZlxuLy8gU2l6emxlIHNvIGxldCdzIG1haW50YWluIHRoZW0gZm9yIG5vdyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcHVycG9zZXMuXG5maW5kLmNvbXBpbGUgPSBjb21waWxlO1xuZmluZC5zZWxlY3QgPSBzZWxlY3Q7XG5maW5kLnNldERvY3VtZW50ID0gc2V0RG9jdW1lbnQ7XG5maW5kLnRva2VuaXplID0gdG9rZW5pemU7XG5cbmZpbmQuZXNjYXBlID0galF1ZXJ5LmVzY2FwZVNlbGVjdG9yO1xuZmluZC5nZXRUZXh0ID0galF1ZXJ5LnRleHQ7XG5maW5kLmlzWE1MID0galF1ZXJ5LmlzWE1MRG9jO1xuZmluZC5zZWxlY3RvcnMgPSBqUXVlcnkuZXhwcjtcbmZpbmQuc3VwcG9ydCA9IGpRdWVyeS5zdXBwb3J0O1xuZmluZC51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZVNvcnQ7XG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG59ICkoKTtcblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAodHJhYy05NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAodHJhYy0xMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8galF1ZXJ5I2ZpbmRcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCBlbGVtLmNvbnRlbnREb2N1bWVudCAhPSBudWxsICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gPG9iamVjdD4gZWxlbWVudHMgd2l0aCBubyBgZGF0YWAgYXR0cmlidXRlIGhhcyBhbiBvYmplY3Rcblx0XHRcdC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxuXHRcdFx0Z2V0UHJvdG8oIGVsZW0uY29udGVudERvY3VtZW50ICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5lcnJvciApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBlcnJvciwgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRFcnJvckhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLmVycm9yID0galF1ZXJ5LkRlZmVycmVkLmdldEVycm9ySG9vaygpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGRlcHJlY2F0ZWQgYWxpYXMgb2YgdGhlIGFib3ZlLiBXaGlsZSB0aGUgbmFtZSBzdWdnZXN0c1xuXHRcdFx0XHRcdFx0XHRcdC8vIHJldHVybmluZyB0aGUgc3RhY2ssIG5vdCBhbiBlcnJvciBpbnN0YW5jZSwgalF1ZXJ5IGp1c3QgcGFzc2VzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaXQgZGlyZWN0bHkgdG8gYGNvbnNvbGUud2FybmAgc28gYm90aCB3aWxsIHdvcms7IGFuIGluc3RhbmNlXG5cdFx0XHRcdFx0XHRcdFx0Ly8ganVzdCBiZXR0ZXIgY29vcGVyYXRlcyB3aXRoIHNvdXJjZSBtYXBzLlxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLmVycm9yID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIHByaW1hcnkgRGVmZXJyZWRcblx0XHRcdHByaW1hcnkgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0cHJpbWFyeS5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgcHJpbWFyeS5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBwcmltYXJ5LnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIHByaW1hcnkuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHByaW1hcnkudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgcHJpbWFyeS5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJpbWFyeS5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbi8vIElmIGBqUXVlcnkuRGVmZXJyZWQuZ2V0RXJyb3JIb29rYCBpcyBkZWZpbmVkLCBgYXN5bmNFcnJvcmAgaXMgYW4gZXJyb3Jcbi8vIGNhcHR1cmVkIGJlZm9yZSB0aGUgYXN5bmMgYmFycmllciB0byBnZXQgdGhlIG9yaWdpbmFsIGVycm9yIGNhdXNlXG4vLyB3aGljaCBtYXkgb3RoZXJ3aXNlIGJlIGhpZGRlbi5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBhc3luY0Vycm9yICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSxcblx0XHRcdGVycm9yLnN0YWNrLCBhc3luY0Vycm9yICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSB0cmFjLTY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIF9rZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIF9hbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAodHJhYy05NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgdHJhYy04MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAodHJhYy0xNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxuXHRcdFx0KCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAodHJhYy0xMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKHRyYWMtMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBJRSA8PTkgcmVwbGFjZXMgPG9wdGlvbj4gdGFncyB3aXRoIHRoZWlyIGNvbnRlbnRzIHdoZW4gaW5zZXJ0ZWQgb3V0c2lkZSBvZlxuXHQvLyB0aGUgc2VsZWN0IGVsZW1lbnQuXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxvcHRpb24+PC9vcHRpb24+XCI7XG5cdHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xufSApKCk7XG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKHRyYWMtMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbmlmICggIXN1cHBvcnQub3B0aW9uICkge1xuXHR3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb24gPSBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF07XG59XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICh0cmFjLTE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGF0dGFjaGVkLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAodHJhYy0xMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG52YXIgcnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBPbmx5IGF0dGFjaCBldmVudHMgdG8gb2JqZWN0cyB0aGF0IGFjY2VwdCBkYXRhXG5cdFx0aWYgKCAhYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUoIG51bGwgKTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblxuXHRcdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICksXG5cblx0XHRcdGhhbmRsZXJzID0gKFxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKHRyYWMtMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICh0cmFjLTY5MTEsIHRyYWMtODE2NSwgdHJhYy0xMTM4MiwgdHJhYy0xMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICh0cmFjLTEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IHRvIGVuc3VyZSBjb3JyZWN0IHN0YXRlIGZvciBjaGVja2FibGUgaW5wdXRzXG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHQvLyBkYXRhUHJpdi5zZXQoIGVsLCBcImNsaWNrXCIsIC4uLiApXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyaW5nIGEgY2xpY2tcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgc3VwcHJlc3MgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHQvLyBBbHNvIHByZXZlbnQgaXQgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cdFx0XHRcdHJldHVybiByY2hlY2thYmxlVHlwZS50ZXN0KCB0YXJnZXQudHlwZSApICYmXG5cdFx0XHRcdFx0dGFyZ2V0LmNsaWNrICYmIG5vZGVOYW1lKCB0YXJnZXQsIFwiaW5wdXRcIiApICYmXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0YXJnZXQsIFwiY2xpY2tcIiApIHx8XG5cdFx0XHRcdFx0bm9kZU5hbWUoIHRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBFbnN1cmUgdGhlIHByZXNlbmNlIG9mIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaGFuZGxlcyBtYW51YWxseS10cmlnZ2VyZWRcbi8vIHN5bnRoZXRpYyBldmVudHMgYnkgaW50ZXJydXB0aW5nIHByb2dyZXNzIHVudGlsIHJlaW52b2tlZCBpbiByZXNwb25zZSB0b1xuLy8gKm5hdGl2ZSogZXZlbnRzIHRoYXQgaXQgZmlyZXMgZGlyZWN0bHksIGVuc3VyaW5nIHRoYXQgc3RhdGUgY2hhbmdlcyBoYXZlXG4vLyBhbHJlYWR5IG9jY3VycmVkIGJlZm9yZSBvdGhlciBsaXN0ZW5lcnMgYXJlIGludm9rZWQuXG5mdW5jdGlvbiBsZXZlcmFnZU5hdGl2ZSggZWwsIHR5cGUsIGlzU2V0dXAgKSB7XG5cblx0Ly8gTWlzc2luZyBgaXNTZXR1cGAgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuXHRpZiAoICFpc1NldHVwICkge1xuXHRcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cdGRhdGFQcml2LnNldCggZWwsIHR5cGUsIGZhbHNlICk7XG5cdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCB7XG5cdFx0bmFtZXNwYWNlOiBmYWxzZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHRpZiAoICFzYXZlZCApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGFyZ3VtZW50cyBmb3IgdXNlIHdoZW4gaGFuZGxpbmcgdGhlIGlubmVyIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRcdC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSBhcmd1bWVudCAoYW4gZXZlbnQgb2JqZWN0KSwgc28gdGhpcyBhcnJheVxuXHRcdFx0XHRcdC8vIHdpbGwgbm90IGJlIGNvbmZ1c2VkIHdpdGggYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdC5cblx0XHRcdFx0XHRzYXZlZCA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgc2F2ZWQgKTtcblxuXHRcdFx0XHRcdC8vIFRyaWdnZXIgdGhlIG5hdGl2ZSBldmVudCBhbmQgY2FwdHVyZSBpdHMgcmVzdWx0XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCBmb3IgYW4gZXZlbnQgd2l0aCBhIGJ1YmJsaW5nIHN1cnJvZ2F0ZVxuXHRcdFx0XHQvLyAoZm9jdXMgb3IgYmx1ciksIGFzc3VtZSB0aGF0IHRoZSBzdXJyb2dhdGUgYWxyZWFkeSBwcm9wYWdhdGVkIGZyb20gdHJpZ2dlcmluZ1xuXHRcdFx0XHQvLyB0aGUgbmF0aXZlIGV2ZW50IGFuZCBwcmV2ZW50IHRoYXQgZnJvbSBoYXBwZW5pbmcgYWdhaW4gaGVyZS5cblx0XHRcdFx0Ly8gVGhpcyB0ZWNobmljYWxseSBnZXRzIHRoZSBvcmRlcmluZyB3cm9uZyB3LnIudC4gdG8gYC50cmlnZ2VyKClgIChpbiB3aGljaCB0aGVcblx0XHRcdFx0Ly8gYnViYmxpbmcgc3Vycm9nYXRlIHByb3BhZ2F0ZXMgKmFmdGVyKiB0aGUgbm9uLWJ1YmJsaW5nIGJhc2UpLCBidXQgdGhhdCBzZWVtc1xuXHRcdFx0XHQvLyBsZXNzIGJhZCB0aGFuIGR1cGxpY2F0aW9uLlxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge30gKS5kZWxlZ2F0ZVR5cGUgKSB7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXG5cdFx0XHQvLyBGaXJlIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCB3aXRoIHRoZSBvcmlnaW5hbCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHNhdmVkICkge1xuXG5cdFx0XHRcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBqUXVlcnkuZXZlbnQudHJpZ2dlcihcblx0XHRcdFx0XHRzYXZlZFsgMCBdLFxuXHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHQpICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudCBieSBhbGwgalF1ZXJ5IGhhbmRsZXJzIHdoaWxlIGFsbG93aW5nXG5cdFx0XHRcdC8vIG5hdGl2ZSBoYW5kbGVycyBvbiB0aGUgc2FtZSBlbGVtZW50IHRvIHJ1bi4gT24gdGFyZ2V0LCB0aGlzIGlzIGFjaGlldmVkXG5cdFx0XHRcdC8vIGJ5IHN0b3BwaW5nIGltbWVkaWF0ZSBwcm9wYWdhdGlvbiBqdXN0IG9uIHRoZSBqUXVlcnkgZXZlbnQuIEhvd2V2ZXIsXG5cdFx0XHRcdC8vIHRoZSBuYXRpdmUgZXZlbnQgaXMgcmUtd3JhcHBlZCBieSBhIGpRdWVyeSBvbmUgb24gZWFjaCBsZXZlbCBvZiB0aGVcblx0XHRcdFx0Ly8gcHJvcGFnYXRpb24gc28gdGhlIG9ubHkgd2F5IHRvIHN0b3AgaXQgZm9yIGpRdWVyeSBpcyB0byBzdG9wIGl0IGZvclxuXHRcdFx0XHQvLyBldmVyeW9uZSB2aWEgbmF0aXZlIGBzdG9wUHJvcGFnYXRpb24oKWAuIFRoaXMgaXMgbm90IGEgcHJvYmxlbSBmb3Jcblx0XHRcdFx0Ly8gZm9jdXMvYmx1ciB3aGljaCBkb24ndCBidWJibGUsIGJ1dCBpdCBkb2VzIGFsc28gc3RvcCBjbGljayBvbiBjaGVja2JveGVzXG5cdFx0XHRcdC8vIGFuZCByYWRpb3MuIFdlIGFjY2VwdCB0aGlzIGxpbWl0YXRpb24uXG5cdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAodHJhYy01MDQsIHRyYWMtMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblx0d2hpY2g6IHRydWVcbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cblx0ZnVuY3Rpb24gZm9jdXNNYXBwZWRIYW5kbGVyKCBuYXRpdmVFdmVudCApIHtcblx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErXG5cdFx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgZm9jdXNpbi9mb2N1c291dCBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzXG5cdFx0XHQvLyBmb2N1cy9ibHVyLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGZvcm1lciBhcmUgc3luY2hyb25vdXMgaW4gSUUgd2hpbGUgdGhlIGxhdHRlclxuXHRcdFx0Ly8gYXJlIGFzeW5jLiBJbiBvdGhlciBicm93c2VycywgYWxsIHRob3NlIGhhbmRsZXJzIGFyZSBpbnZva2VkIHN5bmNocm9ub3VzbHkuXG5cblx0XHRcdC8vIGBoYW5kbGVgIGZyb20gcHJpdmF0ZSBkYXRhIHdvdWxkIGFscmVhZHkgd3JhcCB0aGUgZXZlbnQsIGJ1dCB3ZSBuZWVkXG5cdFx0XHQvLyB0byBjaGFuZ2UgdGhlIGB0eXBlYCBoZXJlLlxuXHRcdFx0dmFyIGhhbmRsZSA9IGRhdGFQcml2LmdldCggdGhpcywgXCJoYW5kbGVcIiApLFxuXHRcdFx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cdFx0XHRldmVudC50eXBlID0gbmF0aXZlRXZlbnQudHlwZSA9PT0gXCJmb2N1c2luXCIgPyBcImZvY3VzXCIgOiBcImJsdXJcIjtcblx0XHRcdGV2ZW50LmlzU2ltdWxhdGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRmlyc3QsIGhhbmRsZSBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0XHRoYW5kbGUoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHRcdC8vIC4uLnRoZW4sIGhhbmRsZSBmb2N1cy9ibHVyXG5cdFx0XHQvL1xuXHRcdFx0Ly8gZm9jdXMvYmx1ciBkb24ndCBidWJibGUgd2hpbGUgZm9jdXNpbi9mb2N1c291dCBkbzsgc2ltdWxhdGUgdGhlIGZvcm1lciBieSBvbmx5XG5cdFx0XHQvLyBpbnZva2luZyB0aGUgaGFuZGxlciBhdCB0aGUgbG93ZXIgbGV2ZWwuXG5cdFx0XHRpZiAoIGV2ZW50LnRhcmdldCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCApIHtcblxuXHRcdFx0XHQvLyBUaGUgc2V0dXAgcGFydCBjYWxscyBgbGV2ZXJhZ2VOYXRpdmVgLCB3aGljaCwgaW4gdHVybiwgY2FsbHNcblx0XHRcdFx0Ly8gYGpRdWVyeS5ldmVudC5hZGRgLCBzbyBldmVudCBoYW5kbGUgd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiBzZXRcblx0XHRcdFx0Ly8gYnkgdGhpcyBwb2ludC5cblx0XHRcdFx0aGFuZGxlKCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBub24tSUUgYnJvd3NlcnMsIGF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnRcblx0XHRcdC8vIHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dC5cblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZGVsZWdhdGVUeXBlLCBuYXRpdmVFdmVudC50YXJnZXQsXG5cdFx0XHRcdGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICkgKTtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG5cdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR2YXIgYXR0YWNoZXM7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdFx0XHRcdC8vIFdlIHVzZSB0aGUgc2FtZSBuYXRpdmUgaGFuZGxlciBmb3IgZm9jdXNpbiAmIGZvY3VzIChhbmQgZm9jdXNvdXQgJiBibHVyKVxuXHRcdFx0XHQvLyBzbyB3ZSBuZWVkIHRvIGNvb3JkaW5hdGUgc2V0dXAgJiB0ZWFyZG93biBwYXJ0cyBiZXR3ZWVuIHRob3NlIGV2ZW50cy5cblx0XHRcdFx0Ly8gVXNlIGBkZWxlZ2F0ZVR5cGVgIGFzIHRoZSBrZXkgYXMgYHR5cGVgIGlzIGFscmVhZHkgdXNlZCBieSBgbGV2ZXJhZ2VOYXRpdmVgLlxuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggdGhpcywgZGVsZWdhdGVUeXBlICk7XG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggZGVsZWdhdGVUeXBlLCBmb2N1c01hcHBlZEhhbmRsZXIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIGRlbGVnYXRlVHlwZSwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhdHRhY2hlcztcblxuXHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KCB0aGlzLCBkZWxlZ2F0ZVR5cGUgKSAtIDE7XG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggZGVsZWdhdGVUeXBlLCBmb2N1c01hcHBlZEhhbmRsZXIgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIHRoaXMsIGRlbGVnYXRlVHlwZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgZGVsZWdhdGVUeXBlLCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBpbmRpY2F0ZSBzdGFuZGFyZCB0ZWFyZG93biBzaG91bGQgYmUgYXBwbGllZFxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIFN1cHByZXNzIG5hdGl2ZSBmb2N1cyBvciBibHVyIGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGVcblx0XHQvLyBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcblx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZXZlbnQudGFyZ2V0LCB0eXBlICk7XG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG5cdH07XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG5cdC8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcblx0Ly8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcblx0Ly9cblx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG5cdC8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuXHQvLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcblx0Ly8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcblx0Ly9cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHQvLyBUbyBwcmVzZXJ2ZSByZWxhdGl2ZSBmb2N1c2luL2ZvY3VzICYgZm9jdXNvdXQvYmx1ciBldmVudCBvcmRlciBndWFyYW50ZWVkIG9uIHRoZSAzLnggYnJhbmNoLFxuXHQvLyBhdHRhY2ggYSBzaW5nbGUgaGFuZGxlciBmb3IgYm90aCBldmVudHMgaW4gSUUuXG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBkZWxlZ2F0ZVR5cGUgXSA9IHtcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEhhbmRsZTogcmVndWxhciBub2RlcyAodmlhIGB0aGlzLm93bmVyRG9jdW1lbnRgKSwgd2luZG93XG5cdFx0XHQvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG5cdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0ZGF0YUhvbGRlciA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSA/IHRoaXMgOiBkb2MsXG5cdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHRcdFx0Ly8gV2UgdXNlIHRoZSBzYW1lIG5hdGl2ZSBoYW5kbGVyIGZvciBmb2N1c2luICYgZm9jdXMgKGFuZCBmb2N1c291dCAmIGJsdXIpXG5cdFx0XHQvLyBzbyB3ZSBuZWVkIHRvIGNvb3JkaW5hdGUgc2V0dXAgJiB0ZWFyZG93biBwYXJ0cyBiZXR3ZWVuIHRob3NlIGV2ZW50cy5cblx0XHRcdC8vIFVzZSBgZGVsZWdhdGVUeXBlYCBhcyB0aGUga2V5IGFzIGB0eXBlYCBpcyBhbHJlYWR5IHVzZWQgYnkgYGxldmVyYWdlTmF0aXZlYC5cblx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblx0XHRcdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkYXRhUHJpdi5zZXQoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0fSxcblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0ZGF0YUhvbGRlciA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSA/IHRoaXMgOiBkb2MsXG5cdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUgKSAtIDE7XG5cblx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSwgYXR0YWNoZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhXFxbQ0RBVEFcXFt8XFxdXFxdPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5nZXQoIHNyYyApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkZXN0LCBcImhhbmRsZSBldmVudHNcIiApO1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gZmxhdCggYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICh0cmFjLTgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlLWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZSggXCJub25jZVwiIClcblx0XHRcdFx0XHRcdFx0XHR9LCBkb2MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBVbndyYXAgYSBDREFUQSBzZWN0aW9uIGNvbnRhaW5pbmcgc2NyaXB0IGNvbnRlbnRzLiBUaGlzIHNob3VsZG4ndCBiZVxuXHRcdFx0XHRcdFx0XHQvLyBuZWVkZWQgYXMgaW4gWE1MIGRvY3VtZW50cyB0aGV5J3JlIGFscmVhZHkgbm90IHZpc2libGUgd2hlblxuXHRcdFx0XHRcdFx0XHQvLyBpbnNwZWN0aW5nIGVsZW1lbnQgY29udGVudHMgYW5kIGluIEhUTUwgZG9jdW1lbnRzIHRoZXkgaGF2ZSBub1xuXHRcdFx0XHRcdFx0XHQvLyBtZWFuaW5nIGJ1dCB3ZSdyZSBwcmVzZXJ2aW5nIHRoYXQgbG9naWMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBjb21wbGV0ZWx5IGluIDQuMC4gU2VlIGdoLTQ5MDQuXG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgalF1ZXJ5I2ZpbmQgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczpcblx0XHRcdC8vIGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIHJjdXN0b21Qcm9wID0gL14tLS87XG5cblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKHRyYWMtMTUwOTgsIHRyYWMtMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmNhbGwoIGVsZW0gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG5cdFx0Ly8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICh0cmFjLTg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBCZWhhdmlvciBpbiBJRSA5IGlzIG1vcmUgc3VidGxlIHRoYW4gaW4gbmV3ZXIgdmVyc2lvbnMgJiBpdCBwYXNzZXNcblx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG5cdFx0Ly9cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDcwK1xuXHRcdC8vIE9ubHkgRmlyZWZveCBpbmNsdWRlcyBib3JkZXIgd2lkdGhzXG5cdFx0Ly8gaW4gY29tcHV0ZWQgZGltZW5zaW9ucy4gKGdoLTQ1MjkpXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRhYmxlLCB0ciwgdHJDaGlsZCwgdHJTdHlsZTtcblx0XHRcdGlmICggcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRhYmxlXCIgKTtcblx0XHRcdFx0dHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRyXCIgKTtcblx0XHRcdFx0dHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRcdFx0XHR0YWJsZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZVwiO1xuXHRcdFx0XHR0ci5zdHlsZS5jc3NUZXh0ID0gXCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JvcmRlcjoxcHggc29saWRcIjtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgODYrXG5cdFx0XHRcdC8vIEhlaWdodCBzZXQgdGhyb3VnaCBjc3NUZXh0IGRvZXMgbm90IGdldCBhcHBsaWVkLlxuXHRcdFx0XHQvLyBDb21wdXRlZCBoZWlnaHQgdGhlbiBjb21lcyBiYWNrIGFzIDAuXG5cdFx0XHRcdHRyLnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCI5cHhcIjtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDggQ2hyb21lIDg2K1xuXHRcdFx0XHQvLyBJbiBvdXIgYm9keUJhY2tncm91bmQuaHRtbCBpZnJhbWUsXG5cdFx0XHRcdC8vIGRpc3BsYXkgZm9yIGFsbCBkaXYgZWxlbWVudHMgaXMgc2V0IHRvIFwiaW5saW5lXCIsXG5cdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBhIHByb2JsZW0gb25seSBpbiBBbmRyb2lkIDggQ2hyb21lIDg2LlxuXHRcdFx0XHQvLyBFbnN1cmluZyB0aGUgZGl2IGlzIGBkaXNwbGF5OiBibG9ja2Bcblx0XHRcdFx0Ly8gZ2V0cyBhcm91bmQgdGhpcyBpc3N1ZS5cblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudFxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdGFibGUgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHIgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHJDaGlsZCApO1xuXG5cdFx0XHRcdHRyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggdHIgKTtcblx0XHRcdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPSAoIHBhcnNlSW50KCB0clN0eWxlLmhlaWdodCwgMTAgKSArXG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRyU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwICkgK1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0clN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCApICkgPT09IHRyLm9mZnNldEhlaWdodDtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRhYmxlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVUckRpbWVuc2lvbnNWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCB0cmFjLTEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpIChnaC0zMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXG5cdFx0Ly8gSUUgb25seSBzdXBwb3J0cyBgXCJmbG9hdFwiYCBpbiBgZ2V0UHJvcGVydHlWYWx1ZWA7IGluIGNvbXB1dGVkIHN0eWxlc1xuXHRcdC8vIGl0J3Mgb25seSBhdmFpbGFibGUgYXMgYFwiY3NzRmxvYXRcImAuIFdlIG5vIGxvbmdlciBtb2RpZnkgcHJvcGVydGllc1xuXHRcdC8vIHNlbnQgdG8gYC5jc3MoKWAgYXBhcnQgZnJvbSBjYW1lbENhc2luZywgc28gd2UgbmVlZCB0byBjaGVjayBib3RoLlxuXHRcdC8vIE5vcm1hbGx5LCB0aGlzIHdvdWxkIGNyZWF0ZSBkaWZmZXJlbmNlIGluIGJlaGF2aW9yOiBpZlxuXHRcdC8vIGBnZXRQcm9wZXJ0eVZhbHVlYCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZywgdGhlIHZhbHVlIHJldHVybmVkXG5cdFx0Ly8gYnkgYC5jc3MoKWAgd291bGQgYmUgYHVuZGVmaW5lZGAuIFRoaXMgaXMgdXN1YWxseSB0aGUgY2FzZSBmb3Jcblx0XHQvLyBkaXNjb25uZWN0ZWQgZWxlbWVudHMuIEhvd2V2ZXIsIGluIElFIGV2ZW4gZGlzY29ubmVjdGVkIGVsZW1lbnRzXG5cdFx0Ly8gd2l0aCBubyBzdHlsZXMgcmV0dXJuIGBcIm5vbmVcImAgZm9yIGBnZXRQcm9wZXJ0eVZhbHVlKCBcImZsb2F0XCIgKWBcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggaXNDdXN0b21Qcm9wICYmIHJldCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAxMDUrLCBDaHJvbWUgPD0xMDUrXG5cdFx0XHQvLyBTcGVjIHJlcXVpcmVzIHRyaW1taW5nIHdoaXRlc3BhY2UgZm9yIGN1c3RvbSBwcm9wZXJ0aWVzIChnaC00OTI2KS5cblx0XHRcdC8vIEZpcmVmb3ggb25seSB0cmltcyBsZWFkaW5nIHdoaXRlc3BhY2UuIENocm9tZSBqdXN0IGNvbGxhcHNlc1xuXHRcdFx0Ly8gYm90aCBsZWFkaW5nICYgdHJhaWxpbmcgd2hpdGVzcGFjZSB0byBhIHNpbmdsZSBzcGFjZS5cblx0XHRcdC8vXG5cdFx0XHQvLyBGYWxsIGJhY2sgdG8gYHVuZGVmaW5lZGAgaWYgZW1wdHkgc3RyaW5nIHJldHVybmVkLlxuXHRcdFx0Ly8gVGhpcyBjb2xsYXBzZXMgYSBtaXNzaW5nIGRlZmluaXRpb24gd2l0aCBwcm9wZXJ0eSBkZWZpbmVkXG5cdFx0XHQvLyBhbmQgc2V0IHRvIGFuIGVtcHR5IHN0cmluZyBidXQgdGhlcmUncyBubyBzdGFuZGFyZCBBUElcblx0XHRcdC8vIGFsbG93aW5nIHVzIHRvIGRpZmZlcmVudGlhdGUgdGhlbSB3aXRob3V0IGEgcGVyZm9ybWFuY2UgcGVuYWx0eVxuXHRcdFx0Ly8gYW5kIHJldHVybmluZyBgdW5kZWZpbmVkYCBhbGlnbnMgd2l0aCBvbGRlciBqUXVlcnkuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gcnRyaW1DU1MgdHJlYXRzIFUrMDAwRCBDQVJSSUFHRSBSRVRVUk4gYW5kIFUrMDAwQyBGT1JNIEZFRURcblx0XHRcdC8vIGFzIHdoaXRlc3BhY2Ugd2hpbGUgQ1NTIGRvZXMgbm90LCBidXQgdGhpcyBpcyBub3QgYSBwcm9ibGVtXG5cdFx0XHQvLyBiZWNhdXNlIENTUyBwcmVwcm9jZXNzaW5nIHJlcGxhY2VzIHRoZW0gd2l0aCBVKzAwMEEgTElORSBGRUVEXG5cdFx0XHQvLyAod2hpY2ggKmlzKiBDU1Mgd2hpdGVzcGFjZSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lucHV0LXByZXByb2Nlc3Npbmdcblx0XHRcdHJldCA9IHJldC5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICkgfHwgdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG5cdHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuXHRpZiAoIGZpbmFsICkge1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXHRyZXR1cm4gdmVuZG9yUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fTtcblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIF9lbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMCxcblx0XHRtYXJnaW5EZWx0YSA9IDA7XG5cblx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0Ly8gQ291bnQgbWFyZ2luIGRlbHRhIHNlcGFyYXRlbHkgdG8gb25seSBhZGQgaXQgYWZ0ZXIgc2Nyb2xsIGd1dHRlciBhZGp1c3RtZW50LlxuXHRcdC8vIFRoaXMgaXMgbmVlZGVkIHRvIG1ha2UgbmVnYXRpdmUgbWFyZ2lucyB3b3JrIHdpdGggYG91dGVySGVpZ2h0KCB0cnVlIClgIChnaC0zOTgyKS5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdG1hcmdpbkRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YSArIG1hcmdpbkRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG5cdFx0Ly8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG5cdFx0Ym94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcblx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBVc2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciB3aGVuIGJveCBzaXppbmcgaXMgdW5yZWxpYWJsZS5cblx0Ly8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94LlxuXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTAgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIGluIHNvbWUgY2FzZXMgSUUgOSBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoaXMgaXNzdWUuXG5cdFx0IXN1cHBvcnQucmVsaWFibGVUckRpbWVuc2lvbnMoKSAmJiBub2RlTmFtZSggZWxlbSwgXCJ0clwiICkgfHxcblxuXHRcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHRcdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0XHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlICYgY29ubmVjdGVkXG5cdFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHRcdC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cblx0XHQvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG5cdFx0Ly8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XG5cdFx0aWYgKCB2YWx1ZUlzQm9yZGVyQm94ICkge1xuXHRcdFx0dmFsID0gZWxlbVsgb2Zmc2V0UHJvcCBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcblx0XHRhc3BlY3RSYXRpbzogdHJ1ZSxcblx0XHRib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuXHRcdGNvbHVtbkNvdW50OiB0cnVlLFxuXHRcdGZsZXhHcm93OiB0cnVlLFxuXHRcdGZsZXhTaHJpbms6IHRydWUsXG5cdFx0Zm9udFdlaWdodDogdHJ1ZSxcblx0XHRncmlkQXJlYTogdHJ1ZSxcblx0XHRncmlkQ29sdW1uOiB0cnVlLFxuXHRcdGdyaWRDb2x1bW5FbmQ6IHRydWUsXG5cdFx0Z3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuXHRcdGdyaWRSb3c6IHRydWUsXG5cdFx0Z3JpZFJvd0VuZDogdHJ1ZSxcblx0XHRncmlkUm93U3RhcnQ6IHRydWUsXG5cdFx0bGluZUhlaWdodDogdHJ1ZSxcblx0XHRvcGFjaXR5OiB0cnVlLFxuXHRcdG9yZGVyOiB0cnVlLFxuXHRcdG9ycGhhbnM6IHRydWUsXG5cdFx0c2NhbGU6IHRydWUsXG5cdFx0d2lkb3dzOiB0cnVlLFxuXHRcdHpJbmRleDogdHJ1ZSxcblx0XHR6b29tOiB0cnVlLFxuXG5cdFx0Ly8gU1ZHLXJlbGF0ZWRcblx0XHRmaWxsT3BhY2l0eTogdHJ1ZSxcblx0XHRmbG9vZE9wYWNpdHk6IHRydWUsXG5cdFx0c3RvcE9wYWNpdHk6IHRydWUsXG5cdFx0c3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcblx0XHRzdHJva2VPcGFjaXR5OiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICh0cmFjLTczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyB0cmFjLTkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAodHJhYy03MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcblx0XHRcdC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIF9pLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHRcdFx0Ly8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuXHRcdFx0XHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuXHRcdFx0XHRzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcblx0XHRcdFx0XHRzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuXHRcdFx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuXHRcdFx0XHRib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSA/XG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKHRyYWMtMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwgKHRyYWMtMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjdXIsIGN1clZhbHVlLCBjbGFzc05hbWUsIGksIGZpbmFsVmFsdWU7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3NOYW1lcy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRjdXIgPSB0aGlzLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhc3NOYW1lICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjdXIsIGN1clZhbHVlLCBjbGFzc05hbWUsIGksIGZpbmFsVmFsdWU7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzTmFtZXMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSB0aGlzLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBjbGFzc05hbWUsIGksIHNlbGYsXG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICh0cmFjLTE0Njg2LCB0cmFjLTE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAodHJhYy0yNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IHsgZ3VpZDogRGF0ZS5ub3coKSB9O1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWwsIHBhcnNlckVycm9yRWxlbTtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge31cblxuXHRwYXJzZXJFcnJvckVsZW0gPSB4bWwgJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKVsgMCBdO1xuXHRpZiAoICF4bWwgfHwgcGFyc2VyRXJyb3JFbGVtICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyAoXG5cdFx0XHRwYXJzZXJFcnJvckVsZW0gP1xuXHRcdFx0XHRqUXVlcnkubWFwKCBwYXJzZXJFcnJvckVsZW0uY2hpbGROb2RlcywgZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0XHRcdHJldHVybiBlbC50ZXh0Q29udGVudDtcblx0XHRcdFx0fSApLmpvaW4oIFwiXFxuXCIgKSA6XG5cdFx0XHRcdGRhdGFcblx0XHQpICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKHRyYWMtOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKHRyYWMtOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApIClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAodHJhYy02MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHRpZiAoIGEgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9ICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApLm1hcCggZnVuY3Rpb24oIF9pLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyB0cmFjLTc2NTMsIHRyYWMtODEyNSwgdHJhYy04MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICh0cmFjLTEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxub3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzIHRyYWMtOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gPVxuXHRcdFx0XHRcdFx0XHRcdFx0KCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY29uY2F0KCBtYXRjaFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSArIFwiIFwiIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKHRyYWMtMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgdHJhYy0xMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKHRyYWMtMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyB0cmFjLTk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlLmd1aWQrKyApICtcblx0XHRcdFx0XHR1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXNlIGEgbm9vcCBjb252ZXJ0ZXIgZm9yIG1pc3Npbmcgc2NyaXB0IGJ1dCBub3QgaWYganNvbnBcblx0XHRcdGlmICggIWlzU3VjY2VzcyAmJlxuXHRcdFx0XHRqUXVlcnkuaW5BcnJheSggXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMgKSA+IC0xICYmXG5cdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBcImpzb25cIiwgcy5kYXRhVHlwZXMgKSA8IDAgKSB7XG5cdFx0XHRcdHMuY29udmVydGVyc1sgXCJ0ZXh0IHNjcmlwdFwiIF0gPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBfaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdHZhciBpO1xuXHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRpZiAoIGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIiApIHtcblx0XHRcdHMuY29udGVudFR5cGUgPSBzLmhlYWRlcnNbIGkgXSB8fCBcIlwiO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMsIGRvYyApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKHRyYWMtMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucywgZG9jICk7XG5cdFx0fVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vIHRyYWMtMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlIHRyYWMtODYwNSwgdHJhYy0xNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gdHJhYy0xNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlLmd1aWQrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIF9pLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7XG5cdFx0cGFkZGluZzogXCJpbm5lclwiICsgbmFtZSxcblx0XHRjb250ZW50OiB0eXBlLFxuXHRcdFwiXCI6IFwib3V0ZXJcIiArIG5hbWVcblx0fSwgZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggX2ksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0Lm9uKCBcIm1vdXNlZW50ZXJcIiwgZm5PdmVyIClcblx0XHRcdC5vbiggXCJtb3VzZWxlYXZlXCIsIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKFxuXHQoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXG5cdFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXHR9XG4pO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbi8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuLy8gUmVxdWlyZSB0aGF0IHRoZSBcIndoaXRlc3BhY2UgcnVuXCIgc3RhcnRzIGZyb20gYSBub24td2hpdGVzcGFjZVxuLy8gdG8gYXZvaWQgTyhOXjIpIGJlaGF2aW9yIHdoZW4gdGhlIGVuZ2luZSB3b3VsZCB0cnkgbWF0Y2hpbmcgXCJcXHMrJFwiIGF0IGVhY2ggc3BhY2UgcG9zaXRpb24uXG52YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3woW15cXHNcXHVGRUZGXFx4QTBdKVtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxualF1ZXJ5LnRyaW0gPSBmdW5jdGlvbiggdGV4dCApIHtcblx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XCJcIiA6XG5cdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKTtcbn07XG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKHRyYWMtNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKHRyYWMtMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGZhbmN5Qm94IHYzLjUuN1xuLy9cbi8vIExpY2Vuc2VkIEdQTHYzIGZvciBvcGVuIHNvdXJjZSB1c2Vcbi8vIG9yIGZhbmN5Qm94IENvbW1lcmNpYWwgTGljZW5zZSBmb3IgY29tbWVyY2lhbCB1c2Vcbi8vXG4vLyBodHRwOi8vZmFuY3lhcHBzLmNvbS9mYW5jeWJveC9cbi8vIENvcHlyaWdodCAyMDE5IGZhbmN5QXBwc1xuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4hZnVuY3Rpb24odCxlLG4sbyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaSh0LGUpe3ZhciBvLGksYSxzPVtdLHI9MDt0JiZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpfHwodC5wcmV2ZW50RGVmYXVsdCgpLGU9ZXx8e30sdCYmdC5kYXRhJiYoZT1oKHQuZGF0YS5vcHRpb25zLGUpKSxvPWUuJHRhcmdldHx8bih0LmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoXCJibHVyXCIpLChhPW4uZmFuY3lib3guZ2V0SW5zdGFuY2UoKSkmJmEuJHRyaWdnZXImJmEuJHRyaWdnZXIuaXMobyl8fChlLnNlbGVjdG9yP3M9bihlLnNlbGVjdG9yKTooaT1vLmF0dHIoXCJkYXRhLWZhbmN5Ym94XCIpfHxcIlwiLGk/KHM9dC5kYXRhP3QuZGF0YS5pdGVtczpbXSxzPXMubGVuZ3RoP3MuZmlsdGVyKCdbZGF0YS1mYW5jeWJveD1cIicraSsnXCJdJyk6bignW2RhdGEtZmFuY3lib3g9XCInK2krJ1wiXScpKTpzPVtvXSkscj1uKHMpLmluZGV4KG8pLHI8MCYmKHI9MCksYT1uLmZhbmN5Ym94Lm9wZW4ocyxlLHIpLGEuJHRyaWdnZXI9bykpfWlmKHQuY29uc29sZT10LmNvbnNvbGV8fHtpbmZvOmZ1bmN0aW9uKHQpe319LG4pe2lmKG4uZm4uZmFuY3lib3gpcmV0dXJuIHZvaWQgY29uc29sZS5pbmZvKFwiZmFuY3lCb3ggYWxyZWFkeSBpbml0aWFsaXplZFwiKTt2YXIgYT17Y2xvc2VFeGlzdGluZzohMSxsb29wOiExLGd1dHRlcjo1MCxrZXlib2FyZDohMCxwcmV2ZW50Q2FwdGlvbk92ZXJsYXA6ITAsYXJyb3dzOiEwLGluZm9iYXI6ITAsc21hbGxCdG46XCJhdXRvXCIsdG9vbGJhcjpcImF1dG9cIixidXR0b25zOltcInpvb21cIixcInNsaWRlU2hvd1wiLFwidGh1bWJzXCIsXCJjbG9zZVwiXSxpZGxlVGltZTozLHByb3RlY3Q6ITEsbW9kYWw6ITEsaW1hZ2U6e3ByZWxvYWQ6ITF9LGFqYXg6e3NldHRpbmdzOntkYXRhOntmYW5jeWJveDohMH19fSxpZnJhbWU6e3RwbDonPGlmcmFtZSBpZD1cImZhbmN5Ym94LWZyYW1le3JuZH1cIiBuYW1lPVwiZmFuY3lib3gtZnJhbWV7cm5kfVwiIGNsYXNzPVwiZmFuY3lib3gtaWZyYW1lXCIgYWxsb3dmdWxsc2NyZWVuPVwiYWxsb3dmdWxsc2NyZWVuXCIgYWxsb3c9XCJhdXRvcGxheTsgZnVsbHNjcmVlblwiIHNyYz1cIlwiPjwvaWZyYW1lPicscHJlbG9hZDohMCxjc3M6e30sYXR0cjp7c2Nyb2xsaW5nOlwiYXV0b1wifX0sdmlkZW86e3RwbDonPHZpZGVvIGNsYXNzPVwiZmFuY3lib3gtdmlkZW9cIiBjb250cm9scyBjb250cm9sc0xpc3Q9XCJub2Rvd25sb2FkXCIgcG9zdGVyPVwie3twb3N0ZXJ9fVwiPjxzb3VyY2Ugc3JjPVwie3tzcmN9fVwiIHR5cGU9XCJ7e2Zvcm1hdH19XCIgLz5Tb3JyeSwgeW91ciBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IGVtYmVkZGVkIHZpZGVvcywgPGEgaHJlZj1cInt7c3JjfX1cIj5kb3dubG9hZDwvYT4gYW5kIHdhdGNoIHdpdGggeW91ciBmYXZvcml0ZSB2aWRlbyBwbGF5ZXIhPC92aWRlbz4nLGZvcm1hdDpcIlwiLGF1dG9TdGFydDohMH0sZGVmYXVsdFR5cGU6XCJpbWFnZVwiLGFuaW1hdGlvbkVmZmVjdDpcInpvb21cIixhbmltYXRpb25EdXJhdGlvbjozNjYsem9vbU9wYWNpdHk6XCJhdXRvXCIsdHJhbnNpdGlvbkVmZmVjdDpcImZhZGVcIix0cmFuc2l0aW9uRHVyYXRpb246MzY2LHNsaWRlQ2xhc3M6XCJcIixiYXNlQ2xhc3M6XCJcIixiYXNlVHBsOic8ZGl2IGNsYXNzPVwiZmFuY3lib3gtY29udGFpbmVyXCIgcm9sZT1cImRpYWxvZ1wiIHRhYmluZGV4PVwiLTFcIj48ZGl2IGNsYXNzPVwiZmFuY3lib3gtYmdcIj48L2Rpdj48ZGl2IGNsYXNzPVwiZmFuY3lib3gtaW5uZXJcIj48ZGl2IGNsYXNzPVwiZmFuY3lib3gtaW5mb2JhclwiPjxzcGFuIGRhdGEtZmFuY3lib3gtaW5kZXg+PC9zcGFuPiZuYnNwOy8mbmJzcDs8c3BhbiBkYXRhLWZhbmN5Ym94LWNvdW50Pjwvc3Bhbj48L2Rpdj48ZGl2IGNsYXNzPVwiZmFuY3lib3gtdG9vbGJhclwiPnt7YnV0dG9uc319PC9kaXY+PGRpdiBjbGFzcz1cImZhbmN5Ym94LW5hdmlnYXRpb25cIj57e2Fycm93c319PC9kaXY+PGRpdiBjbGFzcz1cImZhbmN5Ym94LXN0YWdlXCI+PC9kaXY+PGRpdiBjbGFzcz1cImZhbmN5Ym94LWNhcHRpb25cIj48ZGl2IGNsYXNzPVwiZmFuY3lib3gtY2FwdGlvbl9fYm9keVwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2Picsc3Bpbm5lclRwbDonPGRpdiBjbGFzcz1cImZhbmN5Ym94LWxvYWRpbmdcIj48L2Rpdj4nLGVycm9yVHBsOic8ZGl2IGNsYXNzPVwiZmFuY3lib3gtZXJyb3JcIj48cD57e0VSUk9SfX08L3A+PC9kaXY+JyxidG5UcGw6e2Rvd25sb2FkOic8YSBkb3dubG9hZCBkYXRhLWZhbmN5Ym94LWRvd25sb2FkIGNsYXNzPVwiZmFuY3lib3gtYnV0dG9uIGZhbmN5Ym94LWJ1dHRvbi0tZG93bmxvYWRcIiB0aXRsZT1cInt7RE9XTkxPQUR9fVwiIGhyZWY9XCJqYXZhc2NyaXB0OjtcIj48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xOC42MiAxNy4wOVYxOUg1LjM4di0xLjkxem0tMi45Ny02Ljk2TDE3IDExLjQ1bC01IDQuODctNS00Ljg3IDEuMzYtMS4zMiAyLjY4IDIuNjRWNWgxLjkydjcuNzd6XCIvPjwvc3ZnPjwvYT4nLHpvb206JzxidXR0b24gZGF0YS1mYW5jeWJveC16b29tIGNsYXNzPVwiZmFuY3lib3gtYnV0dG9uIGZhbmN5Ym94LWJ1dHRvbi0tem9vbVwiIHRpdGxlPVwie3taT09NfX1cIj48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xOC43IDE3LjNsLTMtM2E1LjkgNS45IDAgMCAwLS42LTcuNiA1LjkgNS45IDAgMCAwLTguNCAwIDUuOSA1LjkgMCAwIDAgMCA4LjQgNS45IDUuOSAwIDAgMCA3LjcuN2wzIDNhMSAxIDAgMCAwIDEuMyAwYy40LS41LjQtMSAwLTEuNXpNOC4xIDEzLjhhNCA0IDAgMCAxIDAtNS43IDQgNCAwIDAgMSA1LjcgMCA0IDQgMCAwIDEgMCA1LjcgNCA0IDAgMCAxLTUuNyAwelwiLz48L3N2Zz48L2J1dHRvbj4nLGNsb3NlOic8YnV0dG9uIGRhdGEtZmFuY3lib3gtY2xvc2UgY2xhc3M9XCJmYW5jeWJveC1idXR0b24gZmFuY3lib3gtYnV0dG9uLS1jbG9zZVwiIHRpdGxlPVwie3tDTE9TRX19XCI+PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMTIgMTAuNkw2LjYgNS4yIDUuMiA2LjZsNS40IDUuNC01LjQgNS40IDEuNCAxLjQgNS40LTUuNCA1LjQgNS40IDEuNC0xLjQtNS40LTUuNCA1LjQtNS40LTEuNC0xLjQtNS40IDUuNHpcIi8+PC9zdmc+PC9idXR0b24+JyxhcnJvd0xlZnQ6JzxidXR0b24gZGF0YS1mYW5jeWJveC1wcmV2IGNsYXNzPVwiZmFuY3lib3gtYnV0dG9uIGZhbmN5Ym94LWJ1dHRvbi0tYXJyb3dfbGVmdFwiIHRpdGxlPVwie3tQUkVWfX1cIj48ZGl2PjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTExLjI4IDE1LjdsLTEuMzQgMS4zN0w1IDEybDQuOTQtNS4wNyAxLjM0IDEuMzgtMi42OCAyLjcySDE5djEuOTRIOC42elwiLz48L3N2Zz48L2Rpdj48L2J1dHRvbj4nLGFycm93UmlnaHQ6JzxidXR0b24gZGF0YS1mYW5jeWJveC1uZXh0IGNsYXNzPVwiZmFuY3lib3gtYnV0dG9uIGZhbmN5Ym94LWJ1dHRvbi0tYXJyb3dfcmlnaHRcIiB0aXRsZT1cInt7TkVYVH19XCI+PGRpdj48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xNS40IDEyLjk3bC0yLjY4IDIuNzIgMS4zNCAxLjM4TDE5IDEybC00Ljk0LTUuMDctMS4zNCAxLjM4IDIuNjggMi43Mkg1djEuOTR6XCIvPjwvc3ZnPjwvZGl2PjwvYnV0dG9uPicsc21hbGxCdG46JzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtZmFuY3lib3gtY2xvc2UgY2xhc3M9XCJmYW5jeWJveC1idXR0b24gZmFuY3lib3gtY2xvc2Utc21hbGxcIiB0aXRsZT1cInt7Q0xPU0V9fVwiPjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZlcnNpb249XCIxXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMTMgMTJsNS01LTEtMS01IDUtNS01LTEgMSA1IDUtNSA1IDEgMSA1LTUgNSA1IDEtMXpcIi8+PC9zdmc+PC9idXR0b24+J30scGFyZW50RWw6XCJib2R5XCIsaGlkZVNjcm9sbGJhcjohMCxhdXRvRm9jdXM6ITAsYmFja0ZvY3VzOiEwLHRyYXBGb2N1czohMCxmdWxsU2NyZWVuOnthdXRvU3RhcnQ6ITF9LHRvdWNoOnt2ZXJ0aWNhbDohMCxtb21lbnR1bTohMH0saGFzaDpudWxsLG1lZGlhOnt9LHNsaWRlU2hvdzp7YXV0b1N0YXJ0OiExLHNwZWVkOjNlM30sdGh1bWJzOnthdXRvU3RhcnQ6ITEsaGlkZU9uQ2xvc2U6ITAscGFyZW50RWw6XCIuZmFuY3lib3gtY29udGFpbmVyXCIsYXhpczpcInlcIn0sd2hlZWw6XCJhdXRvXCIsb25Jbml0Om4ubm9vcCxiZWZvcmVMb2FkOm4ubm9vcCxhZnRlckxvYWQ6bi5ub29wLGJlZm9yZVNob3c6bi5ub29wLGFmdGVyU2hvdzpuLm5vb3AsYmVmb3JlQ2xvc2U6bi5ub29wLGFmdGVyQ2xvc2U6bi5ub29wLG9uQWN0aXZhdGU6bi5ub29wLG9uRGVhY3RpdmF0ZTpuLm5vb3AsY2xpY2tDb250ZW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJpbWFnZVwiPT09dC50eXBlJiZcInpvb21cIn0sY2xpY2tTbGlkZTpcImNsb3NlXCIsY2xpY2tPdXRzaWRlOlwiY2xvc2VcIixkYmxjbGlja0NvbnRlbnQ6ITEsZGJsY2xpY2tTbGlkZTohMSxkYmxjbGlja091dHNpZGU6ITEsbW9iaWxlOntwcmV2ZW50Q2FwdGlvbk92ZXJsYXA6ITEsaWRsZVRpbWU6ITEsY2xpY2tDb250ZW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJpbWFnZVwiPT09dC50eXBlJiZcInRvZ2dsZUNvbnRyb2xzXCJ9LGNsaWNrU2xpZGU6ZnVuY3Rpb24odCxlKXtyZXR1cm5cImltYWdlXCI9PT10LnR5cGU/XCJ0b2dnbGVDb250cm9sc1wiOlwiY2xvc2VcIn0sZGJsY2xpY2tDb250ZW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJpbWFnZVwiPT09dC50eXBlJiZcInpvb21cIn0sZGJsY2xpY2tTbGlkZTpmdW5jdGlvbih0LGUpe3JldHVyblwiaW1hZ2VcIj09PXQudHlwZSYmXCJ6b29tXCJ9fSxsYW5nOlwiZW5cIixpMThuOntlbjp7Q0xPU0U6XCJDbG9zZVwiLE5FWFQ6XCJOZXh0XCIsUFJFVjpcIlByZXZpb3VzXCIsRVJST1I6XCJUaGUgcmVxdWVzdGVkIGNvbnRlbnQgY2Fubm90IGJlIGxvYWRlZC4gPGJyLz4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIixQTEFZX1NUQVJUOlwiU3RhcnQgc2xpZGVzaG93XCIsUExBWV9TVE9QOlwiUGF1c2Ugc2xpZGVzaG93XCIsRlVMTF9TQ1JFRU46XCJGdWxsIHNjcmVlblwiLFRIVU1CUzpcIlRodW1ibmFpbHNcIixET1dOTE9BRDpcIkRvd25sb2FkXCIsU0hBUkU6XCJTaGFyZVwiLFpPT006XCJab29tXCJ9LGRlOntDTE9TRTpcIlNjaGxpZSZzemxpZztlblwiLE5FWFQ6XCJXZWl0ZXJcIixQUkVWOlwiWnVyJnV1bWw7Y2tcIixFUlJPUjpcIkRpZSBhbmdlZm9yZGVydGVuIERhdGVuIGtvbm50ZW4gbmljaHQgZ2VsYWRlbiB3ZXJkZW4uIDxici8+IEJpdHRlIHZlcnN1Y2hlbiBTaWUgZXMgc3AmYXVtbDt0ZXIgbm9jaG1hbC5cIixQTEFZX1NUQVJUOlwiRGlhc2NoYXUgc3RhcnRlblwiLFBMQVlfU1RPUDpcIkRpYXNjaGF1IGJlZW5kZW5cIixGVUxMX1NDUkVFTjpcIlZvbGxiaWxkXCIsVEhVTUJTOlwiVm9yc2NoYXViaWxkZXJcIixET1dOTE9BRDpcIkhlcnVudGVybGFkZW5cIixTSEFSRTpcIlRlaWxlblwiLFpPT006XCJWZXJnciZvdW1sOyZzemxpZztlcm5cIn19fSxzPW4odCkscj1uKGUpLGM9MCxsPWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Lmhhc093blByb3BlcnR5JiZ0IGluc3RhbmNlb2Ygbn0sZD1mdW5jdGlvbigpe3JldHVybiB0LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8dC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHQubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx0Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGZ1bmN0aW9uKGUpe3JldHVybiB0LnNldFRpbWVvdXQoZSwxZTMvNjApfX0oKSx1PWZ1bmN0aW9uKCl7cmV0dXJuIHQuY2FuY2VsQW5pbWF0aW9uRnJhbWV8fHQud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fHQubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fHQub0NhbmNlbEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbihlKXt0LmNsZWFyVGltZW91dChlKX19KCksZj1mdW5jdGlvbigpe3ZhciB0LG49ZS5jcmVhdGVFbGVtZW50KFwiZmFrZWVsZW1lbnRcIiksbz17dHJhbnNpdGlvbjpcInRyYW5zaXRpb25lbmRcIixPVHJhbnNpdGlvbjpcIm9UcmFuc2l0aW9uRW5kXCIsTW96VHJhbnNpdGlvbjpcInRyYW5zaXRpb25lbmRcIixXZWJraXRUcmFuc2l0aW9uOlwid2Via2l0VHJhbnNpdGlvbkVuZFwifTtmb3IodCBpbiBvKWlmKHZvaWQgMCE9PW4uc3R5bGVbdF0pcmV0dXJuIG9bdF07cmV0dXJuXCJ0cmFuc2l0aW9uZW5kXCJ9KCkscD1mdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5sZW5ndGgmJnRbMF0ub2Zmc2V0SGVpZ2h0fSxoPWZ1bmN0aW9uKHQsZSl7dmFyIG89bi5leHRlbmQoITAse30sdCxlKTtyZXR1cm4gbi5lYWNoKGUsZnVuY3Rpb24odCxlKXtuLmlzQXJyYXkoZSkmJihvW3RdPWUpfSksb30sZz1mdW5jdGlvbih0KXt2YXIgbyxpO3JldHVybiEoIXR8fHQub3duZXJEb2N1bWVudCE9PWUpJiYobihcIi5mYW5jeWJveC1jb250YWluZXJcIikuY3NzKFwicG9pbnRlci1ldmVudHNcIixcIm5vbmVcIiksbz17eDp0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQrdC5vZmZzZXRXaWR0aC8yLHk6dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ArdC5vZmZzZXRIZWlnaHQvMn0saT1lLmVsZW1lbnRGcm9tUG9pbnQoby54LG8ueSk9PT10LG4oXCIuZmFuY3lib3gtY29udGFpbmVyXCIpLmNzcyhcInBvaW50ZXItZXZlbnRzXCIsXCJcIiksaSl9LGI9ZnVuY3Rpb24odCxlLG8pe3ZhciBpPXRoaXM7aS5vcHRzPWgoe2luZGV4Om99LG4uZmFuY3lib3guZGVmYXVsdHMpLG4uaXNQbGFpbk9iamVjdChlKSYmKGkub3B0cz1oKGkub3B0cyxlKSksbi5mYW5jeWJveC5pc01vYmlsZSYmKGkub3B0cz1oKGkub3B0cyxpLm9wdHMubW9iaWxlKSksaS5pZD1pLm9wdHMuaWR8fCsrYyxpLmN1cnJJbmRleD1wYXJzZUludChpLm9wdHMuaW5kZXgsMTApfHwwLGkucHJldkluZGV4PW51bGwsaS5wcmV2UG9zPW51bGwsaS5jdXJyUG9zPTAsaS5maXJzdFJ1bj0hMCxpLmdyb3VwPVtdLGkuc2xpZGVzPXt9LGkuYWRkQ29udGVudCh0KSxpLmdyb3VwLmxlbmd0aCYmaS5pbml0KCl9O24uZXh0ZW5kKGIucHJvdG90eXBlLHtpbml0OmZ1bmN0aW9uKCl7dmFyIG8saSxhPXRoaXMscz1hLmdyb3VwW2EuY3VyckluZGV4XSxyPXMub3B0cztyLmNsb3NlRXhpc3RpbmcmJm4uZmFuY3lib3guY2xvc2UoITApLG4oXCJib2R5XCIpLmFkZENsYXNzKFwiZmFuY3lib3gtYWN0aXZlXCIpLCFuLmZhbmN5Ym94LmdldEluc3RhbmNlKCkmJiExIT09ci5oaWRlU2Nyb2xsYmFyJiYhbi5mYW5jeWJveC5pc01vYmlsZSYmZS5ib2R5LnNjcm9sbEhlaWdodD50LmlubmVySGVpZ2h0JiYobihcImhlYWRcIikuYXBwZW5kKCc8c3R5bGUgaWQ9XCJmYW5jeWJveC1zdHlsZS1ub3Njcm9sbFwiIHR5cGU9XCJ0ZXh0L2Nzc1wiPi5jb21wZW5zYXRlLWZvci1zY3JvbGxiYXJ7bWFyZ2luLXJpZ2h0OicrKHQuaW5uZXJXaWR0aC1lLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkrXCJweDt9PC9zdHlsZT5cIiksbihcImJvZHlcIikuYWRkQ2xhc3MoXCJjb21wZW5zYXRlLWZvci1zY3JvbGxiYXJcIikpLGk9XCJcIixuLmVhY2goci5idXR0b25zLGZ1bmN0aW9uKHQsZSl7aSs9ci5idG5UcGxbZV18fFwiXCJ9KSxvPW4oYS50cmFuc2xhdGUoYSxyLmJhc2VUcGwucmVwbGFjZShcInt7YnV0dG9uc319XCIsaSkucmVwbGFjZShcInt7YXJyb3dzfX1cIixyLmJ0blRwbC5hcnJvd0xlZnQrci5idG5UcGwuYXJyb3dSaWdodCkpKS5hdHRyKFwiaWRcIixcImZhbmN5Ym94LWNvbnRhaW5lci1cIithLmlkKS5hZGRDbGFzcyhyLmJhc2VDbGFzcykuZGF0YShcIkZhbmN5Qm94XCIsYSkuYXBwZW5kVG8oci5wYXJlbnRFbCksYS4kcmVmcz17Y29udGFpbmVyOm99LFtcImJnXCIsXCJpbm5lclwiLFwiaW5mb2JhclwiLFwidG9vbGJhclwiLFwic3RhZ2VcIixcImNhcHRpb25cIixcIm5hdmlnYXRpb25cIl0uZm9yRWFjaChmdW5jdGlvbih0KXthLiRyZWZzW3RdPW8uZmluZChcIi5mYW5jeWJveC1cIit0KX0pLGEudHJpZ2dlcihcIm9uSW5pdFwiKSxhLmFjdGl2YXRlKCksYS5qdW1wVG8oYS5jdXJySW5kZXgpfSx0cmFuc2xhdGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10Lm9wdHMuaTE4blt0Lm9wdHMubGFuZ118fHQub3B0cy5pMThuLmVuO3JldHVybiBlLnJlcGxhY2UoL1xce1xceyhcXHcrKVxcfVxcfS9nLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PW5bZV0/dDpuW2VdfSl9LGFkZENvbnRlbnQ6ZnVuY3Rpb24odCl7dmFyIGUsbz10aGlzLGk9bi5tYWtlQXJyYXkodCk7bi5lYWNoKGksZnVuY3Rpb24odCxlKXt2YXIgaSxhLHMscixjLGw9e30sZD17fTtuLmlzUGxhaW5PYmplY3QoZSk/KGw9ZSxkPWUub3B0c3x8ZSk6XCJvYmplY3RcIj09PW4udHlwZShlKSYmbihlKS5sZW5ndGg/KGk9bihlKSxkPWkuZGF0YSgpfHx7fSxkPW4uZXh0ZW5kKCEwLHt9LGQsZC5vcHRpb25zKSxkLiRvcmlnPWksbC5zcmM9by5vcHRzLnNyY3x8ZC5zcmN8fGkuYXR0cihcImhyZWZcIiksbC50eXBlfHxsLnNyY3x8KGwudHlwZT1cImlubGluZVwiLGwuc3JjPWUpKTpsPXt0eXBlOlwiaHRtbFwiLHNyYzplK1wiXCJ9LGwub3B0cz1uLmV4dGVuZCghMCx7fSxvLm9wdHMsZCksbi5pc0FycmF5KGQuYnV0dG9ucykmJihsLm9wdHMuYnV0dG9ucz1kLmJ1dHRvbnMpLG4uZmFuY3lib3guaXNNb2JpbGUmJmwub3B0cy5tb2JpbGUmJihsLm9wdHM9aChsLm9wdHMsbC5vcHRzLm1vYmlsZSkpLGE9bC50eXBlfHxsLm9wdHMudHlwZSxyPWwuc3JjfHxcIlwiLCFhJiZyJiYoKHM9ci5tYXRjaCgvXFwuKG1wNHxtb3Z8b2d2fHdlYm0pKChcXD98IykuKik/JC9pKSk/KGE9XCJ2aWRlb1wiLGwub3B0cy52aWRlby5mb3JtYXR8fChsLm9wdHMudmlkZW8uZm9ybWF0PVwidmlkZW8vXCIrKFwib2d2XCI9PT1zWzFdP1wib2dnXCI6c1sxXSkpKTpyLm1hdGNoKC8oXmRhdGE6aW1hZ2VcXC9bYS16MC05K1xcLz1dKiwpfChcXC4oanAoZXxnfGVnKXxnaWZ8cG5nfGJtcHx3ZWJwfHN2Z3xpY28pKChcXD98IykuKik/JCkvaSk/YT1cImltYWdlXCI6ci5tYXRjaCgvXFwuKHBkZikoKFxcP3wjKS4qKT8kL2kpPyhhPVwiaWZyYW1lXCIsbD1uLmV4dGVuZCghMCxsLHtjb250ZW50VHlwZTpcInBkZlwiLG9wdHM6e2lmcmFtZTp7cHJlbG9hZDohMX19fSkpOlwiI1wiPT09ci5jaGFyQXQoMCkmJihhPVwiaW5saW5lXCIpKSxhP2wudHlwZT1hOm8udHJpZ2dlcihcIm9iamVjdE5lZWRzVHlwZVwiLGwpLGwuY29udGVudFR5cGV8fChsLmNvbnRlbnRUeXBlPW4uaW5BcnJheShsLnR5cGUsW1wiaHRtbFwiLFwiaW5saW5lXCIsXCJhamF4XCJdKT4tMT9cImh0bWxcIjpsLnR5cGUpLGwuaW5kZXg9by5ncm91cC5sZW5ndGgsXCJhdXRvXCI9PWwub3B0cy5zbWFsbEJ0biYmKGwub3B0cy5zbWFsbEJ0bj1uLmluQXJyYXkobC50eXBlLFtcImh0bWxcIixcImlubGluZVwiLFwiYWpheFwiXSk+LTEpLFwiYXV0b1wiPT09bC5vcHRzLnRvb2xiYXImJihsLm9wdHMudG9vbGJhcj0hbC5vcHRzLnNtYWxsQnRuKSxsLiR0aHVtYj1sLm9wdHMuJHRodW1ifHxudWxsLGwub3B0cy4kdHJpZ2dlciYmbC5pbmRleD09PW8ub3B0cy5pbmRleCYmKGwuJHRodW1iPWwub3B0cy4kdHJpZ2dlci5maW5kKFwiaW1nOmZpcnN0XCIpLGwuJHRodW1iLmxlbmd0aCYmKGwub3B0cy4kb3JpZz1sLm9wdHMuJHRyaWdnZXIpKSxsLiR0aHVtYiYmbC4kdGh1bWIubGVuZ3RofHwhbC5vcHRzLiRvcmlnfHwobC4kdGh1bWI9bC5vcHRzLiRvcmlnLmZpbmQoXCJpbWc6Zmlyc3RcIikpLGwuJHRodW1iJiYhbC4kdGh1bWIubGVuZ3RoJiYobC4kdGh1bWI9bnVsbCksbC50aHVtYj1sLm9wdHMudGh1bWJ8fChsLiR0aHVtYj9sLiR0aHVtYlswXS5zcmM6bnVsbCksXCJmdW5jdGlvblwiPT09bi50eXBlKGwub3B0cy5jYXB0aW9uKSYmKGwub3B0cy5jYXB0aW9uPWwub3B0cy5jYXB0aW9uLmFwcGx5KGUsW28sbF0pKSxcImZ1bmN0aW9uXCI9PT1uLnR5cGUoby5vcHRzLmNhcHRpb24pJiYobC5vcHRzLmNhcHRpb249by5vcHRzLmNhcHRpb24uYXBwbHkoZSxbbyxsXSkpLGwub3B0cy5jYXB0aW9uIGluc3RhbmNlb2Ygbnx8KGwub3B0cy5jYXB0aW9uPXZvaWQgMD09PWwub3B0cy5jYXB0aW9uP1wiXCI6bC5vcHRzLmNhcHRpb24rXCJcIiksXCJhamF4XCI9PT1sLnR5cGUmJihjPXIuc3BsaXQoL1xccysvLDIpLGMubGVuZ3RoPjEmJihsLnNyYz1jLnNoaWZ0KCksbC5vcHRzLmZpbHRlcj1jLnNoaWZ0KCkpKSxsLm9wdHMubW9kYWwmJihsLm9wdHM9bi5leHRlbmQoITAsbC5vcHRzLHt0cmFwRm9jdXM6ITAsaW5mb2JhcjowLHRvb2xiYXI6MCxzbWFsbEJ0bjowLGtleWJvYXJkOjAsc2xpZGVTaG93OjAsZnVsbFNjcmVlbjowLHRodW1iczowLHRvdWNoOjAsY2xpY2tDb250ZW50OiExLGNsaWNrU2xpZGU6ITEsY2xpY2tPdXRzaWRlOiExLGRibGNsaWNrQ29udGVudDohMSxkYmxjbGlja1NsaWRlOiExLGRibGNsaWNrT3V0c2lkZTohMX0pKSxvLmdyb3VwLnB1c2gobCl9KSxPYmplY3Qua2V5cyhvLnNsaWRlcykubGVuZ3RoJiYoby51cGRhdGVDb250cm9scygpLChlPW8uVGh1bWJzKSYmZS5pc0FjdGl2ZSYmKGUuY3JlYXRlKCksZS5mb2N1cygpKSl9LGFkZEV2ZW50czpmdW5jdGlvbigpe3ZhciBlPXRoaXM7ZS5yZW1vdmVFdmVudHMoKSxlLiRyZWZzLmNvbnRhaW5lci5vbihcImNsaWNrLmZiLWNsb3NlXCIsXCJbZGF0YS1mYW5jeWJveC1jbG9zZV1cIixmdW5jdGlvbih0KXt0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSxlLmNsb3NlKHQpfSkub24oXCJ0b3VjaHN0YXJ0LmZiLXByZXYgY2xpY2suZmItcHJldlwiLFwiW2RhdGEtZmFuY3lib3gtcHJldl1cIixmdW5jdGlvbih0KXt0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSxlLnByZXZpb3VzKCl9KS5vbihcInRvdWNoc3RhcnQuZmItbmV4dCBjbGljay5mYi1uZXh0XCIsXCJbZGF0YS1mYW5jeWJveC1uZXh0XVwiLGZ1bmN0aW9uKHQpe3Quc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpLGUubmV4dCgpfSkub24oXCJjbGljay5mYlwiLFwiW2RhdGEtZmFuY3lib3gtem9vbV1cIixmdW5jdGlvbih0KXtlW2UuaXNTY2FsZWREb3duKCk/XCJzY2FsZVRvQWN0dWFsXCI6XCJzY2FsZVRvRml0XCJdKCl9KSxzLm9uKFwib3JpZW50YXRpb25jaGFuZ2UuZmIgcmVzaXplLmZiXCIsZnVuY3Rpb24odCl7dCYmdC5vcmlnaW5hbEV2ZW50JiZcInJlc2l6ZVwiPT09dC5vcmlnaW5hbEV2ZW50LnR5cGU/KGUucmVxdWVzdElkJiZ1KGUucmVxdWVzdElkKSxlLnJlcXVlc3RJZD1kKGZ1bmN0aW9uKCl7ZS51cGRhdGUodCl9KSk6KGUuY3VycmVudCYmXCJpZnJhbWVcIj09PWUuY3VycmVudC50eXBlJiZlLiRyZWZzLnN0YWdlLmhpZGUoKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS4kcmVmcy5zdGFnZS5zaG93KCksZS51cGRhdGUodCl9LG4uZmFuY3lib3guaXNNb2JpbGU/NjAwOjI1MCkpfSksci5vbihcImtleWRvd24uZmJcIixmdW5jdGlvbih0KXt2YXIgbz1uLmZhbmN5Ym94P24uZmFuY3lib3guZ2V0SW5zdGFuY2UoKTpudWxsLGk9by5jdXJyZW50LGE9dC5rZXlDb2RlfHx0LndoaWNoO2lmKDk9PWEpcmV0dXJuIHZvaWQoaS5vcHRzLnRyYXBGb2N1cyYmZS5mb2N1cyh0KSk7aWYoISghaS5vcHRzLmtleWJvYXJkfHx0LmN0cmxLZXl8fHQuYWx0S2V5fHx0LnNoaWZ0S2V5fHxuKHQudGFyZ2V0KS5pcyhcImlucHV0LHRleHRhcmVhLHZpZGVvLGF1ZGlvLHNlbGVjdFwiKSkpcmV0dXJuIDg9PT1hfHwyNz09PWE/KHQucHJldmVudERlZmF1bHQoKSx2b2lkIGUuY2xvc2UodCkpOjM3PT09YXx8Mzg9PT1hPyh0LnByZXZlbnREZWZhdWx0KCksdm9pZCBlLnByZXZpb3VzKCkpOjM5PT09YXx8NDA9PT1hPyh0LnByZXZlbnREZWZhdWx0KCksdm9pZCBlLm5leHQoKSk6dm9pZCBlLnRyaWdnZXIoXCJhZnRlcktleWRvd25cIix0LGEpfSksZS5ncm91cFtlLmN1cnJJbmRleF0ub3B0cy5pZGxlVGltZSYmKGUuaWRsZVNlY29uZHNDb3VudGVyPTAsci5vbihcIm1vdXNlbW92ZS5mYi1pZGxlIG1vdXNlbGVhdmUuZmItaWRsZSBtb3VzZWRvd24uZmItaWRsZSB0b3VjaHN0YXJ0LmZiLWlkbGUgdG91Y2htb3ZlLmZiLWlkbGUgc2Nyb2xsLmZiLWlkbGUga2V5ZG93bi5mYi1pZGxlXCIsZnVuY3Rpb24odCl7ZS5pZGxlU2Vjb25kc0NvdW50ZXI9MCxlLmlzSWRsZSYmZS5zaG93Q29udHJvbHMoKSxlLmlzSWRsZT0hMX0pLGUuaWRsZUludGVydmFsPXQuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXsrK2UuaWRsZVNlY29uZHNDb3VudGVyPj1lLmdyb3VwW2UuY3VyckluZGV4XS5vcHRzLmlkbGVUaW1lJiYhZS5pc0RyYWdnaW5nJiYoZS5pc0lkbGU9ITAsZS5pZGxlU2Vjb25kc0NvdW50ZXI9MCxlLmhpZGVDb250cm9scygpKX0sMWUzKSl9LHJlbW92ZUV2ZW50czpmdW5jdGlvbigpe3ZhciBlPXRoaXM7cy5vZmYoXCJvcmllbnRhdGlvbmNoYW5nZS5mYiByZXNpemUuZmJcIiksci5vZmYoXCJrZXlkb3duLmZiIC5mYi1pZGxlXCIpLHRoaXMuJHJlZnMuY29udGFpbmVyLm9mZihcIi5mYi1jbG9zZSAuZmItcHJldiAuZmItbmV4dFwiKSxlLmlkbGVJbnRlcnZhbCYmKHQuY2xlYXJJbnRlcnZhbChlLmlkbGVJbnRlcnZhbCksZS5pZGxlSW50ZXJ2YWw9bnVsbCl9LHByZXZpb3VzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmp1bXBUbyh0aGlzLmN1cnJQb3MtMSx0KX0sbmV4dDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5qdW1wVG8odGhpcy5jdXJyUG9zKzEsdCl9LGp1bXBUbzpmdW5jdGlvbih0LGUpe3ZhciBvLGksYSxzLHIsYyxsLGQsdSxmPXRoaXMsaD1mLmdyb3VwLmxlbmd0aDtpZighKGYuaXNEcmFnZ2luZ3x8Zi5pc0Nsb3Npbmd8fGYuaXNBbmltYXRpbmcmJmYuZmlyc3RSdW4pKXtpZih0PXBhcnNlSW50KHQsMTApLCEoYT1mLmN1cnJlbnQ/Zi5jdXJyZW50Lm9wdHMubG9vcDpmLm9wdHMubG9vcCkmJih0PDB8fHQ+PWgpKXJldHVybiExO2lmKG89Zi5maXJzdFJ1bj0hT2JqZWN0LmtleXMoZi5zbGlkZXMpLmxlbmd0aCxyPWYuY3VycmVudCxmLnByZXZJbmRleD1mLmN1cnJJbmRleCxmLnByZXZQb3M9Zi5jdXJyUG9zLHM9Zi5jcmVhdGVTbGlkZSh0KSxoPjEmJigoYXx8cy5pbmRleDxoLTEpJiZmLmNyZWF0ZVNsaWRlKHQrMSksKGF8fHMuaW5kZXg+MCkmJmYuY3JlYXRlU2xpZGUodC0xKSksZi5jdXJyZW50PXMsZi5jdXJySW5kZXg9cy5pbmRleCxmLmN1cnJQb3M9cy5wb3MsZi50cmlnZ2VyKFwiYmVmb3JlU2hvd1wiLG8pLGYudXBkYXRlQ29udHJvbHMoKSxzLmZvcmNlZER1cmF0aW9uPXZvaWQgMCxuLmlzTnVtZXJpYyhlKT9zLmZvcmNlZER1cmF0aW9uPWU6ZT1zLm9wdHNbbz9cImFuaW1hdGlvbkR1cmF0aW9uXCI6XCJ0cmFuc2l0aW9uRHVyYXRpb25cIl0sZT1wYXJzZUludChlLDEwKSxpPWYuaXNNb3ZlZChzKSxzLiRzbGlkZS5hZGRDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1jdXJyZW50XCIpLG8pcmV0dXJuIHMub3B0cy5hbmltYXRpb25FZmZlY3QmJmUmJmYuJHJlZnMuY29udGFpbmVyLmNzcyhcInRyYW5zaXRpb24tZHVyYXRpb25cIixlK1wibXNcIiksZi4kcmVmcy5jb250YWluZXIuYWRkQ2xhc3MoXCJmYW5jeWJveC1pcy1vcGVuXCIpLnRyaWdnZXIoXCJmb2N1c1wiKSxmLmxvYWRTbGlkZShzKSx2b2lkIGYucHJlbG9hZChcImltYWdlXCIpO2M9bi5mYW5jeWJveC5nZXRUcmFuc2xhdGUoci4kc2xpZGUpLGw9bi5mYW5jeWJveC5nZXRUcmFuc2xhdGUoZi4kcmVmcy5zdGFnZSksbi5lYWNoKGYuc2xpZGVzLGZ1bmN0aW9uKHQsZSl7bi5mYW5jeWJveC5zdG9wKGUuJHNsaWRlLCEwKX0pLHIucG9zIT09cy5wb3MmJihyLmlzQ29tcGxldGU9ITEpLHIuJHNsaWRlLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtc2xpZGUtLWNvbXBsZXRlIGZhbmN5Ym94LXNsaWRlLS1jdXJyZW50XCIpLGk/KHU9Yy5sZWZ0LShyLnBvcypjLndpZHRoK3IucG9zKnIub3B0cy5ndXR0ZXIpLG4uZWFjaChmLnNsaWRlcyxmdW5jdGlvbih0LG8pe28uJHNsaWRlLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtYW5pbWF0ZWRcIikucmVtb3ZlQ2xhc3MoZnVuY3Rpb24odCxlKXtyZXR1cm4oZS5tYXRjaCgvKF58XFxzKWZhbmN5Ym94LWZ4LVxcUysvZyl8fFtdKS5qb2luKFwiIFwiKX0pO3ZhciBpPW8ucG9zKmMud2lkdGgrby5wb3Mqby5vcHRzLmd1dHRlcjtuLmZhbmN5Ym94LnNldFRyYW5zbGF0ZShvLiRzbGlkZSx7dG9wOjAsbGVmdDppLWwubGVmdCt1fSksby5wb3MhPT1zLnBvcyYmby4kc2xpZGUuYWRkQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tXCIrKG8ucG9zPnMucG9zP1wibmV4dFwiOlwicHJldmlvdXNcIikpLHAoby4kc2xpZGUpLG4uZmFuY3lib3guYW5pbWF0ZShvLiRzbGlkZSx7dG9wOjAsbGVmdDooby5wb3Mtcy5wb3MpKmMud2lkdGgrKG8ucG9zLXMucG9zKSpvLm9wdHMuZ3V0dGVyfSxlLGZ1bmN0aW9uKCl7by4kc2xpZGUuY3NzKHt0cmFuc2Zvcm06XCJcIixvcGFjaXR5OlwiXCJ9KS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1uZXh0IGZhbmN5Ym94LXNsaWRlLS1wcmV2aW91c1wiKSxvLnBvcz09PWYuY3VyclBvcyYmZi5jb21wbGV0ZSgpfSl9KSk6ZSYmcy5vcHRzLnRyYW5zaXRpb25FZmZlY3QmJihkPVwiZmFuY3lib3gtYW5pbWF0ZWQgZmFuY3lib3gtZngtXCIrcy5vcHRzLnRyYW5zaXRpb25FZmZlY3Qsci4kc2xpZGUuYWRkQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tXCIrKHIucG9zPnMucG9zP1wibmV4dFwiOlwicHJldmlvdXNcIikpLG4uZmFuY3lib3guYW5pbWF0ZShyLiRzbGlkZSxkLGUsZnVuY3Rpb24oKXtyLiRzbGlkZS5yZW1vdmVDbGFzcyhkKS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1uZXh0IGZhbmN5Ym94LXNsaWRlLS1wcmV2aW91c1wiKX0sITEpKSxzLmlzTG9hZGVkP2YucmV2ZWFsQ29udGVudChzKTpmLmxvYWRTbGlkZShzKSxmLnByZWxvYWQoXCJpbWFnZVwiKX19LGNyZWF0ZVNsaWRlOmZ1bmN0aW9uKHQpe3ZhciBlLG8saT10aGlzO3JldHVybiBvPXQlaS5ncm91cC5sZW5ndGgsbz1vPDA/aS5ncm91cC5sZW5ndGgrbzpvLCFpLnNsaWRlc1t0XSYmaS5ncm91cFtvXSYmKGU9bignPGRpdiBjbGFzcz1cImZhbmN5Ym94LXNsaWRlXCI+PC9kaXY+JykuYXBwZW5kVG8oaS4kcmVmcy5zdGFnZSksaS5zbGlkZXNbdF09bi5leHRlbmQoITAse30saS5ncm91cFtvXSx7cG9zOnQsJHNsaWRlOmUsaXNMb2FkZWQ6ITF9KSxpLnVwZGF0ZVNsaWRlKGkuc2xpZGVzW3RdKSksaS5zbGlkZXNbdF19LHNjYWxlVG9BY3R1YWw6ZnVuY3Rpb24odCxlLG8pe3ZhciBpLGEscyxyLGMsbD10aGlzLGQ9bC5jdXJyZW50LHU9ZC4kY29udGVudCxmPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKGQuJHNsaWRlKS53aWR0aCxwPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKGQuJHNsaWRlKS5oZWlnaHQsaD1kLndpZHRoLGc9ZC5oZWlnaHQ7bC5pc0FuaW1hdGluZ3x8bC5pc01vdmVkKCl8fCF1fHxcImltYWdlXCIhPWQudHlwZXx8IWQuaXNMb2FkZWR8fGQuaGFzRXJyb3J8fChsLmlzQW5pbWF0aW5nPSEwLG4uZmFuY3lib3guc3RvcCh1KSx0PXZvaWQgMD09PXQ/LjUqZjp0LGU9dm9pZCAwPT09ZT8uNSpwOmUsaT1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZSh1KSxpLnRvcC09bi5mYW5jeWJveC5nZXRUcmFuc2xhdGUoZC4kc2xpZGUpLnRvcCxpLmxlZnQtPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKGQuJHNsaWRlKS5sZWZ0LHI9aC9pLndpZHRoLGM9Zy9pLmhlaWdodCxhPS41KmYtLjUqaCxzPS41KnAtLjUqZyxoPmYmJihhPWkubGVmdCpyLSh0KnItdCksYT4wJiYoYT0wKSxhPGYtaCYmKGE9Zi1oKSksZz5wJiYocz1pLnRvcCpjLShlKmMtZSkscz4wJiYocz0wKSxzPHAtZyYmKHM9cC1nKSksbC51cGRhdGVDdXJzb3IoaCxnKSxuLmZhbmN5Ym94LmFuaW1hdGUodSx7dG9wOnMsbGVmdDphLHNjYWxlWDpyLHNjYWxlWTpjfSxvfHwzNjYsZnVuY3Rpb24oKXtsLmlzQW5pbWF0aW5nPSExfSksbC5TbGlkZVNob3cmJmwuU2xpZGVTaG93LmlzQWN0aXZlJiZsLlNsaWRlU2hvdy5zdG9wKCkpfSxzY2FsZVRvRml0OmZ1bmN0aW9uKHQpe3ZhciBlLG89dGhpcyxpPW8uY3VycmVudCxhPWkuJGNvbnRlbnQ7by5pc0FuaW1hdGluZ3x8by5pc01vdmVkKCl8fCFhfHxcImltYWdlXCIhPWkudHlwZXx8IWkuaXNMb2FkZWR8fGkuaGFzRXJyb3J8fChvLmlzQW5pbWF0aW5nPSEwLG4uZmFuY3lib3guc3RvcChhKSxlPW8uZ2V0Rml0UG9zKGkpLG8udXBkYXRlQ3Vyc29yKGUud2lkdGgsZS5oZWlnaHQpLG4uZmFuY3lib3guYW5pbWF0ZShhLHt0b3A6ZS50b3AsbGVmdDplLmxlZnQsc2NhbGVYOmUud2lkdGgvYS53aWR0aCgpLHNjYWxlWTplLmhlaWdodC9hLmhlaWdodCgpfSx0fHwzNjYsZnVuY3Rpb24oKXtvLmlzQW5pbWF0aW5nPSExfSkpfSxnZXRGaXRQb3M6ZnVuY3Rpb24odCl7dmFyIGUsbyxpLGEscz10aGlzLHI9dC4kY29udGVudCxjPXQuJHNsaWRlLGw9dC53aWR0aHx8dC5vcHRzLndpZHRoLGQ9dC5oZWlnaHR8fHQub3B0cy5oZWlnaHQsdT17fTtyZXR1cm4hISh0LmlzTG9hZGVkJiZyJiZyLmxlbmd0aCkmJihlPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKHMuJHJlZnMuc3RhZ2UpLndpZHRoLG89bi5mYW5jeWJveC5nZXRUcmFuc2xhdGUocy4kcmVmcy5zdGFnZSkuaGVpZ2h0LGUtPXBhcnNlRmxvYXQoYy5jc3MoXCJwYWRkaW5nTGVmdFwiKSkrcGFyc2VGbG9hdChjLmNzcyhcInBhZGRpbmdSaWdodFwiKSkrcGFyc2VGbG9hdChyLmNzcyhcIm1hcmdpbkxlZnRcIikpK3BhcnNlRmxvYXQoci5jc3MoXCJtYXJnaW5SaWdodFwiKSksby09cGFyc2VGbG9hdChjLmNzcyhcInBhZGRpbmdUb3BcIikpK3BhcnNlRmxvYXQoYy5jc3MoXCJwYWRkaW5nQm90dG9tXCIpKStwYXJzZUZsb2F0KHIuY3NzKFwibWFyZ2luVG9wXCIpKStwYXJzZUZsb2F0KHIuY3NzKFwibWFyZ2luQm90dG9tXCIpKSxsJiZkfHwobD1lLGQ9byksaT1NYXRoLm1pbigxLGUvbCxvL2QpLGwqPWksZCo9aSxsPmUtLjUmJihsPWUpLGQ+by0uNSYmKGQ9byksXCJpbWFnZVwiPT09dC50eXBlPyh1LnRvcD1NYXRoLmZsb29yKC41KihvLWQpKStwYXJzZUZsb2F0KGMuY3NzKFwicGFkZGluZ1RvcFwiKSksdS5sZWZ0PU1hdGguZmxvb3IoLjUqKGUtbCkpK3BhcnNlRmxvYXQoYy5jc3MoXCJwYWRkaW5nTGVmdFwiKSkpOlwidmlkZW9cIj09PXQuY29udGVudFR5cGUmJihhPXQub3B0cy53aWR0aCYmdC5vcHRzLmhlaWdodD9sL2Q6dC5vcHRzLnJhdGlvfHwxNi85LGQ+bC9hP2Q9bC9hOmw+ZCphJiYobD1kKmEpKSx1LndpZHRoPWwsdS5oZWlnaHQ9ZCx1KX0sdXBkYXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7bi5lYWNoKGUuc2xpZGVzLGZ1bmN0aW9uKG4sbyl7ZS51cGRhdGVTbGlkZShvLHQpfSl9LHVwZGF0ZVNsaWRlOmZ1bmN0aW9uKHQsZSl7dmFyIG89dGhpcyxpPXQmJnQuJGNvbnRlbnQsYT10LndpZHRofHx0Lm9wdHMud2lkdGgscz10LmhlaWdodHx8dC5vcHRzLmhlaWdodCxyPXQuJHNsaWRlO28uYWRqdXN0Q2FwdGlvbih0KSxpJiYoYXx8c3x8XCJ2aWRlb1wiPT09dC5jb250ZW50VHlwZSkmJiF0Lmhhc0Vycm9yJiYobi5mYW5jeWJveC5zdG9wKGkpLG4uZmFuY3lib3guc2V0VHJhbnNsYXRlKGksby5nZXRGaXRQb3ModCkpLHQucG9zPT09by5jdXJyUG9zJiYoby5pc0FuaW1hdGluZz0hMSxvLnVwZGF0ZUN1cnNvcigpKSksby5hZGp1c3RMYXlvdXQodCksci5sZW5ndGgmJihyLnRyaWdnZXIoXCJyZWZyZXNoXCIpLHQucG9zPT09by5jdXJyUG9zJiZvLiRyZWZzLnRvb2xiYXIuYWRkKG8uJHJlZnMubmF2aWdhdGlvbi5maW5kKFwiLmZhbmN5Ym94LWJ1dHRvbi0tYXJyb3dfcmlnaHRcIikpLnRvZ2dsZUNsYXNzKFwiY29tcGVuc2F0ZS1mb3Itc2Nyb2xsYmFyXCIsci5nZXQoMCkuc2Nyb2xsSGVpZ2h0PnIuZ2V0KDApLmNsaWVudEhlaWdodCkpLG8udHJpZ2dlcihcIm9uVXBkYXRlXCIsdCxlKX0sY2VudGVyU2xpZGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxvPWUuY3VycmVudCxpPW8uJHNsaWRlOyFlLmlzQ2xvc2luZyYmbyYmKGkuc2libGluZ3MoKS5jc3Moe3RyYW5zZm9ybTpcIlwiLG9wYWNpdHk6XCJcIn0pLGkucGFyZW50KCkuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1wcmV2aW91cyBmYW5jeWJveC1zbGlkZS0tbmV4dFwiKSxuLmZhbmN5Ym94LmFuaW1hdGUoaSx7dG9wOjAsbGVmdDowLG9wYWNpdHk6MX0sdm9pZCAwPT09dD8wOnQsZnVuY3Rpb24oKXtpLmNzcyh7dHJhbnNmb3JtOlwiXCIsb3BhY2l0eTpcIlwifSksby5pc0NvbXBsZXRlfHxlLmNvbXBsZXRlKCl9LCExKSl9LGlzTW92ZWQ6ZnVuY3Rpb24odCl7dmFyIGUsbyxpPXR8fHRoaXMuY3VycmVudDtyZXR1cm4hIWkmJihvPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKHRoaXMuJHJlZnMuc3RhZ2UpLGU9bi5mYW5jeWJveC5nZXRUcmFuc2xhdGUoaS4kc2xpZGUpLCFpLiRzbGlkZS5oYXNDbGFzcyhcImZhbmN5Ym94LWFuaW1hdGVkXCIpJiYoTWF0aC5hYnMoZS50b3Atby50b3ApPi41fHxNYXRoLmFicyhlLmxlZnQtby5sZWZ0KT4uNSkpfSx1cGRhdGVDdXJzb3I6ZnVuY3Rpb24odCxlKXt2YXIgbyxpLGE9dGhpcyxzPWEuY3VycmVudCxyPWEuJHJlZnMuY29udGFpbmVyO3MmJiFhLmlzQ2xvc2luZyYmYS5HdWVzdHVyZXMmJihyLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtaXMtem9vbWFibGUgZmFuY3lib3gtY2FuLXpvb21JbiBmYW5jeWJveC1jYW4tem9vbU91dCBmYW5jeWJveC1jYW4tc3dpcGUgZmFuY3lib3gtY2FuLXBhblwiKSxvPWEuY2FuUGFuKHQsZSksaT0hIW98fGEuaXNab29tYWJsZSgpLHIudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1pcy16b29tYWJsZVwiLGkpLG4oXCJbZGF0YS1mYW5jeWJveC16b29tXVwiKS5wcm9wKFwiZGlzYWJsZWRcIiwhaSksbz9yLmFkZENsYXNzKFwiZmFuY3lib3gtY2FuLXBhblwiKTppJiYoXCJ6b29tXCI9PT1zLm9wdHMuY2xpY2tDb250ZW50fHxuLmlzRnVuY3Rpb24ocy5vcHRzLmNsaWNrQ29udGVudCkmJlwiem9vbVwiPT1zLm9wdHMuY2xpY2tDb250ZW50KHMpKT9yLmFkZENsYXNzKFwiZmFuY3lib3gtY2FuLXpvb21JblwiKTpzLm9wdHMudG91Y2gmJihzLm9wdHMudG91Y2gudmVydGljYWx8fGEuZ3JvdXAubGVuZ3RoPjEpJiZcInZpZGVvXCIhPT1zLmNvbnRlbnRUeXBlJiZyLmFkZENsYXNzKFwiZmFuY3lib3gtY2FuLXN3aXBlXCIpKX0saXNab29tYWJsZTpmdW5jdGlvbigpe3ZhciB0LGU9dGhpcyxuPWUuY3VycmVudDtpZihuJiYhZS5pc0Nsb3NpbmcmJlwiaW1hZ2VcIj09PW4udHlwZSYmIW4uaGFzRXJyb3Ipe2lmKCFuLmlzTG9hZGVkKXJldHVybiEwO2lmKCh0PWUuZ2V0Rml0UG9zKG4pKSYmKG4ud2lkdGg+dC53aWR0aHx8bi5oZWlnaHQ+dC5oZWlnaHQpKXJldHVybiEwfXJldHVybiExfSxpc1NjYWxlZERvd246ZnVuY3Rpb24odCxlKXt2YXIgbz10aGlzLGk9ITEsYT1vLmN1cnJlbnQscz1hLiRjb250ZW50O3JldHVybiB2b2lkIDAhPT10JiZ2b2lkIDAhPT1lP2k9dDxhLndpZHRoJiZlPGEuaGVpZ2h0OnMmJihpPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKHMpLGk9aS53aWR0aDxhLndpZHRoJiZpLmhlaWdodDxhLmhlaWdodCksaX0sY2FuUGFuOmZ1bmN0aW9uKHQsZSl7dmFyIG89dGhpcyxpPW8uY3VycmVudCxhPW51bGwscz0hMTtyZXR1cm5cImltYWdlXCI9PT1pLnR5cGUmJihpLmlzQ29tcGxldGV8fHQmJmUpJiYhaS5oYXNFcnJvciYmKHM9by5nZXRGaXRQb3MoaSksdm9pZCAwIT09dCYmdm9pZCAwIT09ZT9hPXt3aWR0aDp0LGhlaWdodDplfTppLmlzQ29tcGxldGUmJihhPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKGkuJGNvbnRlbnQpKSxhJiZzJiYocz1NYXRoLmFicyhhLndpZHRoLXMud2lkdGgpPjEuNXx8TWF0aC5hYnMoYS5oZWlnaHQtcy5oZWlnaHQpPjEuNSkpLHN9LGxvYWRTbGlkZTpmdW5jdGlvbih0KXt2YXIgZSxvLGksYT10aGlzO2lmKCF0LmlzTG9hZGluZyYmIXQuaXNMb2FkZWQpe2lmKHQuaXNMb2FkaW5nPSEwLCExPT09YS50cmlnZ2VyKFwiYmVmb3JlTG9hZFwiLHQpKXJldHVybiB0LmlzTG9hZGluZz0hMSwhMTtzd2l0Y2goZT10LnR5cGUsbz10LiRzbGlkZSxvLm9mZihcInJlZnJlc2hcIikudHJpZ2dlcihcIm9uUmVzZXRcIikuYWRkQ2xhc3ModC5vcHRzLnNsaWRlQ2xhc3MpLGUpe2Nhc2VcImltYWdlXCI6YS5zZXRJbWFnZSh0KTticmVhaztjYXNlXCJpZnJhbWVcIjphLnNldElmcmFtZSh0KTticmVhaztjYXNlXCJodG1sXCI6YS5zZXRDb250ZW50KHQsdC5zcmN8fHQuY29udGVudCk7YnJlYWs7Y2FzZVwidmlkZW9cIjphLnNldENvbnRlbnQodCx0Lm9wdHMudmlkZW8udHBsLnJlcGxhY2UoL1xce1xce3NyY1xcfVxcfS9naSx0LnNyYykucmVwbGFjZShcInt7Zm9ybWF0fX1cIix0Lm9wdHMudmlkZW9Gb3JtYXR8fHQub3B0cy52aWRlby5mb3JtYXR8fFwiXCIpLnJlcGxhY2UoXCJ7e3Bvc3Rlcn19XCIsdC50aHVtYnx8XCJcIikpO2JyZWFrO2Nhc2VcImlubGluZVwiOm4odC5zcmMpLmxlbmd0aD9hLnNldENvbnRlbnQodCxuKHQuc3JjKSk6YS5zZXRFcnJvcih0KTticmVhaztjYXNlXCJhamF4XCI6YS5zaG93TG9hZGluZyh0KSxpPW4uYWpheChuLmV4dGVuZCh7fSx0Lm9wdHMuYWpheC5zZXR0aW5ncyx7dXJsOnQuc3JjLHN1Y2Nlc3M6ZnVuY3Rpb24oZSxuKXtcInN1Y2Nlc3NcIj09PW4mJmEuc2V0Q29udGVudCh0LGUpfSxlcnJvcjpmdW5jdGlvbihlLG4pe2UmJlwiYWJvcnRcIiE9PW4mJmEuc2V0RXJyb3IodCl9fSkpLG8ub25lKFwib25SZXNldFwiLGZ1bmN0aW9uKCl7aS5hYm9ydCgpfSk7YnJlYWs7ZGVmYXVsdDphLnNldEVycm9yKHQpfXJldHVybiEwfX0sc2V0SW1hZ2U6ZnVuY3Rpb24odCl7dmFyIG8saT10aGlzO3NldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgZT10LiRpbWFnZTtpLmlzQ2xvc2luZ3x8IXQuaXNMb2FkaW5nfHxlJiZlLmxlbmd0aCYmZVswXS5jb21wbGV0ZXx8dC5oYXNFcnJvcnx8aS5zaG93TG9hZGluZyh0KX0sNTApLGkuY2hlY2tTcmNzZXQodCksdC4kY29udGVudD1uKCc8ZGl2IGNsYXNzPVwiZmFuY3lib3gtY29udGVudFwiPjwvZGl2PicpLmFkZENsYXNzKFwiZmFuY3lib3gtaXMtaGlkZGVuXCIpLmFwcGVuZFRvKHQuJHNsaWRlLmFkZENsYXNzKFwiZmFuY3lib3gtc2xpZGUtLWltYWdlXCIpKSwhMSE9PXQub3B0cy5wcmVsb2FkJiZ0Lm9wdHMud2lkdGgmJnQub3B0cy5oZWlnaHQmJnQudGh1bWImJih0LndpZHRoPXQub3B0cy53aWR0aCx0LmhlaWdodD10Lm9wdHMuaGVpZ2h0LG89ZS5jcmVhdGVFbGVtZW50KFwiaW1nXCIpLG8ub25lcnJvcj1mdW5jdGlvbigpe24odGhpcykucmVtb3ZlKCksdC4kZ2hvc3Q9bnVsbH0sby5vbmxvYWQ9ZnVuY3Rpb24oKXtpLmFmdGVyTG9hZCh0KX0sdC4kZ2hvc3Q9bihvKS5hZGRDbGFzcyhcImZhbmN5Ym94LWltYWdlXCIpLmFwcGVuZFRvKHQuJGNvbnRlbnQpLmF0dHIoXCJzcmNcIix0LnRodW1iKSksaS5zZXRCaWdJbWFnZSh0KX0sY2hlY2tTcmNzZXQ6ZnVuY3Rpb24oZSl7dmFyIG4sbyxpLGEscz1lLm9wdHMuc3Jjc2V0fHxlLm9wdHMuaW1hZ2Uuc3Jjc2V0O2lmKHMpe2k9dC5kZXZpY2VQaXhlbFJhdGlvfHwxLGE9dC5pbm5lcldpZHRoKmksbz1zLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24odCl7dmFyIGU9e307cmV0dXJuIHQudHJpbSgpLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbih0LG4pe3ZhciBvPXBhcnNlSW50KHQuc3Vic3RyaW5nKDAsdC5sZW5ndGgtMSksMTApO2lmKDA9PT1uKXJldHVybiBlLnVybD10O28mJihlLnZhbHVlPW8sZS5wb3N0Zml4PXRbdC5sZW5ndGgtMV0pfSksZX0pLG8uc29ydChmdW5jdGlvbih0LGUpe3JldHVybiB0LnZhbHVlLWUudmFsdWV9KTtmb3IodmFyIHI9MDtyPG8ubGVuZ3RoO3IrKyl7dmFyIGM9b1tyXTtpZihcIndcIj09PWMucG9zdGZpeCYmYy52YWx1ZT49YXx8XCJ4XCI9PT1jLnBvc3RmaXgmJmMudmFsdWU+PWkpe249YzticmVha319IW4mJm8ubGVuZ3RoJiYobj1vW28ubGVuZ3RoLTFdKSxuJiYoZS5zcmM9bi51cmwsZS53aWR0aCYmZS5oZWlnaHQmJlwid1wiPT1uLnBvc3RmaXgmJihlLmhlaWdodD1lLndpZHRoL2UuaGVpZ2h0Km4udmFsdWUsZS53aWR0aD1uLnZhbHVlKSxlLm9wdHMuc3Jjc2V0PXMpfX0sc2V0QmlnSW1hZ2U6ZnVuY3Rpb24odCl7dmFyIG89dGhpcyxpPWUuY3JlYXRlRWxlbWVudChcImltZ1wiKSxhPW4oaSk7dC4kaW1hZ2U9YS5vbmUoXCJlcnJvclwiLGZ1bmN0aW9uKCl7by5zZXRFcnJvcih0KX0pLm9uZShcImxvYWRcIixmdW5jdGlvbigpe3ZhciBlO3QuJGdob3N0fHwoby5yZXNvbHZlSW1hZ2VTbGlkZVNpemUodCx0aGlzLm5hdHVyYWxXaWR0aCx0aGlzLm5hdHVyYWxIZWlnaHQpLG8uYWZ0ZXJMb2FkKHQpKSxvLmlzQ2xvc2luZ3x8KHQub3B0cy5zcmNzZXQmJihlPXQub3B0cy5zaXplcyxlJiZcImF1dG9cIiE9PWV8fChlPSh0LndpZHRoL3QuaGVpZ2h0PjEmJnMud2lkdGgoKS9zLmhlaWdodCgpPjE/XCIxMDBcIjpNYXRoLnJvdW5kKHQud2lkdGgvdC5oZWlnaHQqMTAwKSkrXCJ2d1wiKSxhLmF0dHIoXCJzaXplc1wiLGUpLmF0dHIoXCJzcmNzZXRcIix0Lm9wdHMuc3Jjc2V0KSksdC4kZ2hvc3QmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXt0LiRnaG9zdCYmIW8uaXNDbG9zaW5nJiZ0LiRnaG9zdC5oaWRlKCl9LE1hdGgubWluKDMwMCxNYXRoLm1heCgxZTMsdC5oZWlnaHQvMTYwMCkpKSxvLmhpZGVMb2FkaW5nKHQpKX0pLmFkZENsYXNzKFwiZmFuY3lib3gtaW1hZ2VcIikuYXR0cihcInNyY1wiLHQuc3JjKS5hcHBlbmRUbyh0LiRjb250ZW50KSwoaS5jb21wbGV0ZXx8XCJjb21wbGV0ZVwiPT1pLnJlYWR5U3RhdGUpJiZhLm5hdHVyYWxXaWR0aCYmYS5uYXR1cmFsSGVpZ2h0P2EudHJpZ2dlcihcImxvYWRcIik6aS5lcnJvciYmYS50cmlnZ2VyKFwiZXJyb3JcIil9LHJlc29sdmVJbWFnZVNsaWRlU2l6ZTpmdW5jdGlvbih0LGUsbil7dmFyIG89cGFyc2VJbnQodC5vcHRzLndpZHRoLDEwKSxpPXBhcnNlSW50KHQub3B0cy5oZWlnaHQsMTApO3Qud2lkdGg9ZSx0LmhlaWdodD1uLG8+MCYmKHQud2lkdGg9byx0LmhlaWdodD1NYXRoLmZsb29yKG8qbi9lKSksaT4wJiYodC53aWR0aD1NYXRoLmZsb29yKGkqZS9uKSx0LmhlaWdodD1pKX0sc2V0SWZyYW1lOmZ1bmN0aW9uKHQpe3ZhciBlLG89dGhpcyxpPXQub3B0cy5pZnJhbWUsYT10LiRzbGlkZTt0LiRjb250ZW50PW4oJzxkaXYgY2xhc3M9XCJmYW5jeWJveC1jb250ZW50JysoaS5wcmVsb2FkP1wiIGZhbmN5Ym94LWlzLWhpZGRlblwiOlwiXCIpKydcIj48L2Rpdj4nKS5jc3MoaS5jc3MpLmFwcGVuZFRvKGEpLGEuYWRkQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tXCIrdC5jb250ZW50VHlwZSksdC4kaWZyYW1lPWU9bihpLnRwbC5yZXBsYWNlKC9cXHtybmRcXH0vZywobmV3IERhdGUpLmdldFRpbWUoKSkpLmF0dHIoaS5hdHRyKS5hcHBlbmRUbyh0LiRjb250ZW50KSxpLnByZWxvYWQ/KG8uc2hvd0xvYWRpbmcodCksZS5vbihcImxvYWQuZmIgZXJyb3IuZmJcIixmdW5jdGlvbihlKXt0aGlzLmlzUmVhZHk9MSx0LiRzbGlkZS50cmlnZ2VyKFwicmVmcmVzaFwiKSxvLmFmdGVyTG9hZCh0KX0pLGEub24oXCJyZWZyZXNoLmZiXCIsZnVuY3Rpb24oKXt2YXIgbixvLHM9dC4kY29udGVudCxyPWkuY3NzLndpZHRoLGM9aS5jc3MuaGVpZ2h0O2lmKDE9PT1lWzBdLmlzUmVhZHkpe3RyeXtuPWUuY29udGVudHMoKSxvPW4uZmluZChcImJvZHlcIil9Y2F0Y2godCl7fW8mJm8ubGVuZ3RoJiZvLmNoaWxkcmVuKCkubGVuZ3RoJiYoYS5jc3MoXCJvdmVyZmxvd1wiLFwidmlzaWJsZVwiKSxzLmNzcyh7d2lkdGg6XCIxMDAlXCIsXCJtYXgtd2lkdGhcIjpcIjEwMCVcIixoZWlnaHQ6XCI5OTk5cHhcIn0pLHZvaWQgMD09PXImJihyPU1hdGguY2VpbChNYXRoLm1heChvWzBdLmNsaWVudFdpZHRoLG8ub3V0ZXJXaWR0aCghMCkpKSkscy5jc3MoXCJ3aWR0aFwiLHJ8fFwiXCIpLmNzcyhcIm1heC13aWR0aFwiLFwiXCIpLHZvaWQgMD09PWMmJihjPU1hdGguY2VpbChNYXRoLm1heChvWzBdLmNsaWVudEhlaWdodCxvLm91dGVySGVpZ2h0KCEwKSkpKSxzLmNzcyhcImhlaWdodFwiLGN8fFwiXCIpLGEuY3NzKFwib3ZlcmZsb3dcIixcImF1dG9cIikpLHMucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1pcy1oaWRkZW5cIil9fSkpOm8uYWZ0ZXJMb2FkKHQpLGUuYXR0cihcInNyY1wiLHQuc3JjKSxhLm9uZShcIm9uUmVzZXRcIixmdW5jdGlvbigpe3RyeXtuKHRoaXMpLmZpbmQoXCJpZnJhbWVcIikuaGlkZSgpLnVuYmluZCgpLmF0dHIoXCJzcmNcIixcIi8vYWJvdXQ6YmxhbmtcIil9Y2F0Y2godCl7fW4odGhpcykub2ZmKFwicmVmcmVzaC5mYlwiKS5lbXB0eSgpLHQuaXNMb2FkZWQ9ITEsdC5pc1JldmVhbGVkPSExfSl9LHNldENvbnRlbnQ6ZnVuY3Rpb24odCxlKXt2YXIgbz10aGlzO28uaXNDbG9zaW5nfHwoby5oaWRlTG9hZGluZyh0KSx0LiRjb250ZW50JiZuLmZhbmN5Ym94LnN0b3AodC4kY29udGVudCksdC4kc2xpZGUuZW1wdHkoKSxsKGUpJiZlLnBhcmVudCgpLmxlbmd0aD8oKGUuaGFzQ2xhc3MoXCJmYW5jeWJveC1jb250ZW50XCIpfHxlLnBhcmVudCgpLmhhc0NsYXNzKFwiZmFuY3lib3gtY29udGVudFwiKSkmJmUucGFyZW50cyhcIi5mYW5jeWJveC1zbGlkZVwiKS50cmlnZ2VyKFwib25SZXNldFwiKSx0LiRwbGFjZWhvbGRlcj1uKFwiPGRpdj5cIikuaGlkZSgpLmluc2VydEFmdGVyKGUpLGUuY3NzKFwiZGlzcGxheVwiLFwiaW5saW5lLWJsb2NrXCIpKTp0Lmhhc0Vycm9yfHwoXCJzdHJpbmdcIj09PW4udHlwZShlKSYmKGU9bihcIjxkaXY+XCIpLmFwcGVuZChuLnRyaW0oZSkpLmNvbnRlbnRzKCkpLHQub3B0cy5maWx0ZXImJihlPW4oXCI8ZGl2PlwiKS5odG1sKGUpLmZpbmQodC5vcHRzLmZpbHRlcikpKSx0LiRzbGlkZS5vbmUoXCJvblJlc2V0XCIsZnVuY3Rpb24oKXtuKHRoaXMpLmZpbmQoXCJ2aWRlbyxhdWRpb1wiKS50cmlnZ2VyKFwicGF1c2VcIiksdC4kcGxhY2Vob2xkZXImJih0LiRwbGFjZWhvbGRlci5hZnRlcihlLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtY29udGVudFwiKS5oaWRlKCkpLnJlbW92ZSgpLHQuJHBsYWNlaG9sZGVyPW51bGwpLHQuJHNtYWxsQnRuJiYodC4kc21hbGxCdG4ucmVtb3ZlKCksdC4kc21hbGxCdG49bnVsbCksdC5oYXNFcnJvcnx8KG4odGhpcykuZW1wdHkoKSx0LmlzTG9hZGVkPSExLHQuaXNSZXZlYWxlZD0hMSl9KSxuKGUpLmFwcGVuZFRvKHQuJHNsaWRlKSxuKGUpLmlzKFwidmlkZW8sYXVkaW9cIikmJihuKGUpLmFkZENsYXNzKFwiZmFuY3lib3gtdmlkZW9cIiksbihlKS53cmFwKFwiPGRpdj48L2Rpdj5cIiksdC5jb250ZW50VHlwZT1cInZpZGVvXCIsdC5vcHRzLndpZHRoPXQub3B0cy53aWR0aHx8bihlKS5hdHRyKFwid2lkdGhcIiksdC5vcHRzLmhlaWdodD10Lm9wdHMuaGVpZ2h0fHxuKGUpLmF0dHIoXCJoZWlnaHRcIikpLHQuJGNvbnRlbnQ9dC4kc2xpZGUuY2hpbGRyZW4oKS5maWx0ZXIoXCJkaXYsZm9ybSxtYWluLHZpZGVvLGF1ZGlvLGFydGljbGUsLmZhbmN5Ym94LWNvbnRlbnRcIikuZmlyc3QoKSx0LiRjb250ZW50LnNpYmxpbmdzKCkuaGlkZSgpLHQuJGNvbnRlbnQubGVuZ3RofHwodC4kY29udGVudD10LiRzbGlkZS53cmFwSW5uZXIoXCI8ZGl2PjwvZGl2PlwiKS5jaGlsZHJlbigpLmZpcnN0KCkpLHQuJGNvbnRlbnQuYWRkQ2xhc3MoXCJmYW5jeWJveC1jb250ZW50XCIpLHQuJHNsaWRlLmFkZENsYXNzKFwiZmFuY3lib3gtc2xpZGUtLVwiK3QuY29udGVudFR5cGUpLG8uYWZ0ZXJMb2FkKHQpKX0sc2V0RXJyb3I6ZnVuY3Rpb24odCl7dC5oYXNFcnJvcj0hMCx0LiRzbGlkZS50cmlnZ2VyKFwib25SZXNldFwiKS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1cIit0LmNvbnRlbnRUeXBlKS5hZGRDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1lcnJvclwiKSx0LmNvbnRlbnRUeXBlPVwiaHRtbFwiLHRoaXMuc2V0Q29udGVudCh0LHRoaXMudHJhbnNsYXRlKHQsdC5vcHRzLmVycm9yVHBsKSksdC5wb3M9PT10aGlzLmN1cnJQb3MmJih0aGlzLmlzQW5pbWF0aW5nPSExKX0sc2hvd0xvYWRpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dGhpczsodD10fHxlLmN1cnJlbnQpJiYhdC4kc3Bpbm5lciYmKHQuJHNwaW5uZXI9bihlLnRyYW5zbGF0ZShlLGUub3B0cy5zcGlubmVyVHBsKSkuYXBwZW5kVG8odC4kc2xpZGUpLmhpZGUoKS5mYWRlSW4oXCJmYXN0XCIpKX0saGlkZUxvYWRpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dGhpczsodD10fHxlLmN1cnJlbnQpJiZ0LiRzcGlubmVyJiYodC4kc3Bpbm5lci5zdG9wKCkucmVtb3ZlKCksZGVsZXRlIHQuJHNwaW5uZXIpfSxhZnRlckxvYWQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztlLmlzQ2xvc2luZ3x8KHQuaXNMb2FkaW5nPSExLHQuaXNMb2FkZWQ9ITAsZS50cmlnZ2VyKFwiYWZ0ZXJMb2FkXCIsdCksZS5oaWRlTG9hZGluZyh0KSwhdC5vcHRzLnNtYWxsQnRufHx0LiRzbWFsbEJ0biYmdC4kc21hbGxCdG4ubGVuZ3RofHwodC4kc21hbGxCdG49bihlLnRyYW5zbGF0ZSh0LHQub3B0cy5idG5UcGwuc21hbGxCdG4pKS5hcHBlbmRUbyh0LiRjb250ZW50KSksdC5vcHRzLnByb3RlY3QmJnQuJGNvbnRlbnQmJiF0Lmhhc0Vycm9yJiYodC4kY29udGVudC5vbihcImNvbnRleHRtZW51LmZiXCIsZnVuY3Rpb24odCl7cmV0dXJuIDI9PXQuYnV0dG9uJiZ0LnByZXZlbnREZWZhdWx0KCksITB9KSxcImltYWdlXCI9PT10LnR5cGUmJm4oJzxkaXYgY2xhc3M9XCJmYW5jeWJveC1zcGFjZWJhbGxcIj48L2Rpdj4nKS5hcHBlbmRUbyh0LiRjb250ZW50KSksZS5hZGp1c3RDYXB0aW9uKHQpLGUuYWRqdXN0TGF5b3V0KHQpLHQucG9zPT09ZS5jdXJyUG9zJiZlLnVwZGF0ZUN1cnNvcigpLGUucmV2ZWFsQ29udGVudCh0KSl9LGFkanVzdENhcHRpb246ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzLG89dHx8bi5jdXJyZW50LGk9by5vcHRzLmNhcHRpb24sYT1vLm9wdHMucHJldmVudENhcHRpb25PdmVybGFwLHM9bi4kcmVmcy5jYXB0aW9uLHI9ITE7cy50b2dnbGVDbGFzcyhcImZhbmN5Ym94LWNhcHRpb24tLXNlcGFyYXRlXCIsYSksYSYmaSYmaS5sZW5ndGgmJihvLnBvcyE9PW4uY3VyclBvcz8oZT1zLmNsb25lKCkuYXBwZW5kVG8ocy5wYXJlbnQoKSksZS5jaGlsZHJlbigpLmVxKDApLmVtcHR5KCkuaHRtbChpKSxyPWUub3V0ZXJIZWlnaHQoITApLGUuZW1wdHkoKS5yZW1vdmUoKSk6bi4kY2FwdGlvbiYmKHI9bi4kY2FwdGlvbi5vdXRlckhlaWdodCghMCkpLG8uJHNsaWRlLmNzcyhcInBhZGRpbmctYm90dG9tXCIscnx8XCJcIikpfSxhZGp1c3RMYXlvdXQ6ZnVuY3Rpb24odCl7dmFyIGUsbixvLGksYT10aGlzLHM9dHx8YS5jdXJyZW50O3MuaXNMb2FkZWQmJiEwIT09cy5vcHRzLmRpc2FibGVMYXlvdXRGaXgmJihzLiRjb250ZW50LmNzcyhcIm1hcmdpbi1ib3R0b21cIixcIlwiKSxzLiRjb250ZW50Lm91dGVySGVpZ2h0KCk+cy4kc2xpZGUuaGVpZ2h0KCkrLjUmJihvPXMuJHNsaWRlWzBdLnN0eWxlW1wicGFkZGluZy1ib3R0b21cIl0saT1zLiRzbGlkZS5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiKSxwYXJzZUZsb2F0KGkpPjAmJihlPXMuJHNsaWRlWzBdLnNjcm9sbEhlaWdodCxzLiRzbGlkZS5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiLDApLE1hdGguYWJzKGUtcy4kc2xpZGVbMF0uc2Nyb2xsSGVpZ2h0KTwxJiYobj1pKSxzLiRzbGlkZS5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiLG8pKSkscy4kY29udGVudC5jc3MoXCJtYXJnaW4tYm90dG9tXCIsbikpfSxyZXZlYWxDb250ZW50OmZ1bmN0aW9uKHQpe3ZhciBlLG8saSxhLHM9dGhpcyxyPXQuJHNsaWRlLGM9ITEsbD0hMSxkPXMuaXNNb3ZlZCh0KSx1PXQuaXNSZXZlYWxlZDtyZXR1cm4gdC5pc1JldmVhbGVkPSEwLGU9dC5vcHRzW3MuZmlyc3RSdW4/XCJhbmltYXRpb25FZmZlY3RcIjpcInRyYW5zaXRpb25FZmZlY3RcIl0saT10Lm9wdHNbcy5maXJzdFJ1bj9cImFuaW1hdGlvbkR1cmF0aW9uXCI6XCJ0cmFuc2l0aW9uRHVyYXRpb25cIl0saT1wYXJzZUludCh2b2lkIDA9PT10LmZvcmNlZER1cmF0aW9uP2k6dC5mb3JjZWREdXJhdGlvbiwxMCksIWQmJnQucG9zPT09cy5jdXJyUG9zJiZpfHwoZT0hMSksXCJ6b29tXCI9PT1lJiYodC5wb3M9PT1zLmN1cnJQb3MmJmkmJlwiaW1hZ2VcIj09PXQudHlwZSYmIXQuaGFzRXJyb3ImJihsPXMuZ2V0VGh1bWJQb3ModCkpP2M9cy5nZXRGaXRQb3ModCk6ZT1cImZhZGVcIiksXCJ6b29tXCI9PT1lPyhzLmlzQW5pbWF0aW5nPSEwLGMuc2NhbGVYPWMud2lkdGgvbC53aWR0aCxjLnNjYWxlWT1jLmhlaWdodC9sLmhlaWdodCxhPXQub3B0cy56b29tT3BhY2l0eSxcImF1dG9cIj09YSYmKGE9TWF0aC5hYnModC53aWR0aC90LmhlaWdodC1sLndpZHRoL2wuaGVpZ2h0KT4uMSksYSYmKGwub3BhY2l0eT0uMSxjLm9wYWNpdHk9MSksbi5mYW5jeWJveC5zZXRUcmFuc2xhdGUodC4kY29udGVudC5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWlzLWhpZGRlblwiKSxsKSxwKHQuJGNvbnRlbnQpLHZvaWQgbi5mYW5jeWJveC5hbmltYXRlKHQuJGNvbnRlbnQsYyxpLGZ1bmN0aW9uKCl7cy5pc0FuaW1hdGluZz0hMSxzLmNvbXBsZXRlKCl9KSk6KHMudXBkYXRlU2xpZGUodCksZT8obi5mYW5jeWJveC5zdG9wKHIpLG89XCJmYW5jeWJveC1zbGlkZS0tXCIrKHQucG9zPj1zLnByZXZQb3M/XCJuZXh0XCI6XCJwcmV2aW91c1wiKStcIiBmYW5jeWJveC1hbmltYXRlZCBmYW5jeWJveC1meC1cIitlLHIuYWRkQ2xhc3MobykucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tY3VycmVudFwiKSx0LiRjb250ZW50LnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtaXMtaGlkZGVuXCIpLHAociksXCJpbWFnZVwiIT09dC50eXBlJiZ0LiRjb250ZW50LmhpZGUoKS5zaG93KDApLHZvaWQgbi5mYW5jeWJveC5hbmltYXRlKHIsXCJmYW5jeWJveC1zbGlkZS0tY3VycmVudFwiLGksZnVuY3Rpb24oKXtyLnJlbW92ZUNsYXNzKG8pLmNzcyh7dHJhbnNmb3JtOlwiXCIsb3BhY2l0eTpcIlwifSksdC5wb3M9PT1zLmN1cnJQb3MmJnMuY29tcGxldGUoKX0sITApKToodC4kY29udGVudC5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWlzLWhpZGRlblwiKSx1fHwhZHx8XCJpbWFnZVwiIT09dC50eXBlfHx0Lmhhc0Vycm9yfHx0LiRjb250ZW50LmhpZGUoKS5mYWRlSW4oXCJmYXN0XCIpLHZvaWQodC5wb3M9PT1zLmN1cnJQb3MmJnMuY29tcGxldGUoKSkpKX0sZ2V0VGh1bWJQb3M6ZnVuY3Rpb24odCl7dmFyIGUsbyxpLGEscyxyPSExLGM9dC4kdGh1bWI7cmV0dXJuISghY3x8IWcoY1swXSkpJiYoZT1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShjKSxvPXBhcnNlRmxvYXQoYy5jc3MoXCJib3JkZXItdG9wLXdpZHRoXCIpfHwwKSxpPXBhcnNlRmxvYXQoYy5jc3MoXCJib3JkZXItcmlnaHQtd2lkdGhcIil8fDApLGE9cGFyc2VGbG9hdChjLmNzcyhcImJvcmRlci1ib3R0b20td2lkdGhcIil8fDApLHM9cGFyc2VGbG9hdChjLmNzcyhcImJvcmRlci1sZWZ0LXdpZHRoXCIpfHwwKSxyPXt0b3A6ZS50b3ArbyxsZWZ0OmUubGVmdCtzLHdpZHRoOmUud2lkdGgtaS1zLGhlaWdodDplLmhlaWdodC1vLWEsc2NhbGVYOjEsc2NhbGVZOjF9LGUud2lkdGg+MCYmZS5oZWlnaHQ+MCYmcil9LGNvbXBsZXRlOmZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzLG89ZS5jdXJyZW50LGk9e307IWUuaXNNb3ZlZCgpJiZvLmlzTG9hZGVkJiYoby5pc0NvbXBsZXRlfHwoby5pc0NvbXBsZXRlPSEwLG8uJHNsaWRlLnNpYmxpbmdzKCkudHJpZ2dlcihcIm9uUmVzZXRcIiksZS5wcmVsb2FkKFwiaW5saW5lXCIpLHAoby4kc2xpZGUpLG8uJHNsaWRlLmFkZENsYXNzKFwiZmFuY3lib3gtc2xpZGUtLWNvbXBsZXRlXCIpLG4uZWFjaChlLnNsaWRlcyxmdW5jdGlvbih0LG8pe28ucG9zPj1lLmN1cnJQb3MtMSYmby5wb3M8PWUuY3VyclBvcysxP2lbby5wb3NdPW86byYmKG4uZmFuY3lib3guc3RvcChvLiRzbGlkZSksby4kc2xpZGUub2ZmKCkucmVtb3ZlKCkpfSksZS5zbGlkZXM9aSksZS5pc0FuaW1hdGluZz0hMSxlLnVwZGF0ZUN1cnNvcigpLGUudHJpZ2dlcihcImFmdGVyU2hvd1wiKSxvLm9wdHMudmlkZW8uYXV0b1N0YXJ0JiZvLiRzbGlkZS5maW5kKFwidmlkZW8sYXVkaW9cIikuZmlsdGVyKFwiOnZpc2libGU6Zmlyc3RcIikudHJpZ2dlcihcInBsYXlcIikub25lKFwiZW5kZWRcIixmdW5jdGlvbigpe0RvY3VtZW50LmV4aXRGdWxsc2NyZWVuP0RvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk6dGhpcy53ZWJraXRFeGl0RnVsbHNjcmVlbiYmdGhpcy53ZWJraXRFeGl0RnVsbHNjcmVlbigpLGUubmV4dCgpfSksby5vcHRzLmF1dG9Gb2N1cyYmXCJodG1sXCI9PT1vLmNvbnRlbnRUeXBlJiYodD1vLiRjb250ZW50LmZpbmQoXCJpbnB1dFthdXRvZm9jdXNdOmVuYWJsZWQ6dmlzaWJsZTpmaXJzdFwiKSx0Lmxlbmd0aD90LnRyaWdnZXIoXCJmb2N1c1wiKTplLmZvY3VzKG51bGwsITApKSxvLiRzbGlkZS5zY3JvbGxUb3AoMCkuc2Nyb2xsTGVmdCgwKSl9LHByZWxvYWQ6ZnVuY3Rpb24odCl7dmFyIGUsbixvPXRoaXM7by5ncm91cC5sZW5ndGg8Mnx8KG49by5zbGlkZXNbby5jdXJyUG9zKzFdLGU9by5zbGlkZXNbby5jdXJyUG9zLTFdLGUmJmUudHlwZT09PXQmJm8ubG9hZFNsaWRlKGUpLG4mJm4udHlwZT09PXQmJm8ubG9hZFNsaWRlKG4pKX0sZm9jdXM6ZnVuY3Rpb24odCxvKXt2YXIgaSxhLHM9dGhpcyxyPVtcImFbaHJlZl1cIixcImFyZWFbaHJlZl1cIiwnaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbdHlwZT1cImhpZGRlblwiXSk6bm90KFthcmlhLWhpZGRlbl0pJyxcInNlbGVjdDpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pXCIsXCJ0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pXCIsXCJidXR0b246bm90KFtkaXNhYmxlZF0pOm5vdChbYXJpYS1oaWRkZW5dKVwiLFwiaWZyYW1lXCIsXCJvYmplY3RcIixcImVtYmVkXCIsXCJ2aWRlb1wiLFwiYXVkaW9cIixcIltjb250ZW50ZWRpdGFibGVdXCIsJ1t0YWJpbmRleF06bm90KFt0YWJpbmRleF49XCItXCJdKSddLmpvaW4oXCIsXCIpO3MuaXNDbG9zaW5nfHwoaT0hdCYmcy5jdXJyZW50JiZzLmN1cnJlbnQuaXNDb21wbGV0ZT9zLmN1cnJlbnQuJHNsaWRlLmZpbmQoXCIqOnZpc2libGVcIisobz9cIjpub3QoLmZhbmN5Ym94LWNsb3NlLXNtYWxsKVwiOlwiXCIpKTpzLiRyZWZzLmNvbnRhaW5lci5maW5kKFwiKjp2aXNpYmxlXCIpLGk9aS5maWx0ZXIocikuZmlsdGVyKGZ1bmN0aW9uKCl7cmV0dXJuXCJoaWRkZW5cIiE9PW4odGhpcykuY3NzKFwidmlzaWJpbGl0eVwiKSYmIW4odGhpcykuaGFzQ2xhc3MoXCJkaXNhYmxlZFwiKX0pLGkubGVuZ3RoPyhhPWkuaW5kZXgoZS5hY3RpdmVFbGVtZW50KSx0JiZ0LnNoaWZ0S2V5PyhhPDB8fDA9PWEpJiYodC5wcmV2ZW50RGVmYXVsdCgpLGkuZXEoaS5sZW5ndGgtMSkudHJpZ2dlcihcImZvY3VzXCIpKTooYTwwfHxhPT1pLmxlbmd0aC0xKSYmKHQmJnQucHJldmVudERlZmF1bHQoKSxpLmVxKDApLnRyaWdnZXIoXCJmb2N1c1wiKSkpOnMuJHJlZnMuY29udGFpbmVyLnRyaWdnZXIoXCJmb2N1c1wiKSl9LGFjdGl2YXRlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztuKFwiLmZhbmN5Ym94LWNvbnRhaW5lclwiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9bih0aGlzKS5kYXRhKFwiRmFuY3lCb3hcIik7ZSYmZS5pZCE9PXQuaWQmJiFlLmlzQ2xvc2luZyYmKGUudHJpZ2dlcihcIm9uRGVhY3RpdmF0ZVwiKSxlLnJlbW92ZUV2ZW50cygpLGUuaXNWaXNpYmxlPSExKX0pLHQuaXNWaXNpYmxlPSEwLCh0LmN1cnJlbnR8fHQuaXNJZGxlKSYmKHQudXBkYXRlKCksdC51cGRhdGVDb250cm9scygpKSx0LnRyaWdnZXIoXCJvbkFjdGl2YXRlXCIpLHQuYWRkRXZlbnRzKCl9LGNsb3NlOmZ1bmN0aW9uKHQsZSl7dmFyIG8saSxhLHMscixjLGwsdT10aGlzLGY9dS5jdXJyZW50LGg9ZnVuY3Rpb24oKXt1LmNsZWFuVXAodCl9O3JldHVybiF1LmlzQ2xvc2luZyYmKHUuaXNDbG9zaW5nPSEwLCExPT09dS50cmlnZ2VyKFwiYmVmb3JlQ2xvc2VcIix0KT8odS5pc0Nsb3Npbmc9ITEsZChmdW5jdGlvbigpe3UudXBkYXRlKCl9KSwhMSk6KHUucmVtb3ZlRXZlbnRzKCksYT1mLiRjb250ZW50LG89Zi5vcHRzLmFuaW1hdGlvbkVmZmVjdCxpPW4uaXNOdW1lcmljKGUpP2U6bz9mLm9wdHMuYW5pbWF0aW9uRHVyYXRpb246MCxmLiRzbGlkZS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1jb21wbGV0ZSBmYW5jeWJveC1zbGlkZS0tbmV4dCBmYW5jeWJveC1zbGlkZS0tcHJldmlvdXMgZmFuY3lib3gtYW5pbWF0ZWRcIiksITAhPT10P24uZmFuY3lib3guc3RvcChmLiRzbGlkZSk6bz0hMSxmLiRzbGlkZS5zaWJsaW5ncygpLnRyaWdnZXIoXCJvblJlc2V0XCIpLnJlbW92ZSgpLGkmJnUuJHJlZnMuY29udGFpbmVyLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtaXMtb3BlblwiKS5hZGRDbGFzcyhcImZhbmN5Ym94LWlzLWNsb3NpbmdcIikuY3NzKFwidHJhbnNpdGlvbi1kdXJhdGlvblwiLGkrXCJtc1wiKSx1LmhpZGVMb2FkaW5nKGYpLHUuaGlkZUNvbnRyb2xzKCEwKSx1LnVwZGF0ZUN1cnNvcigpLFwiem9vbVwiIT09b3x8YSYmaSYmXCJpbWFnZVwiPT09Zi50eXBlJiYhdS5pc01vdmVkKCkmJiFmLmhhc0Vycm9yJiYobD11LmdldFRodW1iUG9zKGYpKXx8KG89XCJmYWRlXCIpLFwiem9vbVwiPT09bz8obi5mYW5jeWJveC5zdG9wKGEpLHM9bi5mYW5jeWJveC5nZXRUcmFuc2xhdGUoYSksYz17dG9wOnMudG9wLGxlZnQ6cy5sZWZ0LHNjYWxlWDpzLndpZHRoL2wud2lkdGgsc2NhbGVZOnMuaGVpZ2h0L2wuaGVpZ2h0LHdpZHRoOmwud2lkdGgsaGVpZ2h0OmwuaGVpZ2h0fSxyPWYub3B0cy56b29tT3BhY2l0eSxcblwiYXV0b1wiPT1yJiYocj1NYXRoLmFicyhmLndpZHRoL2YuaGVpZ2h0LWwud2lkdGgvbC5oZWlnaHQpPi4xKSxyJiYobC5vcGFjaXR5PTApLG4uZmFuY3lib3guc2V0VHJhbnNsYXRlKGEsYykscChhKSxuLmZhbmN5Ym94LmFuaW1hdGUoYSxsLGksaCksITApOihvJiZpP24uZmFuY3lib3guYW5pbWF0ZShmLiRzbGlkZS5hZGRDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1wcmV2aW91c1wiKS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1jdXJyZW50XCIpLFwiZmFuY3lib3gtYW5pbWF0ZWQgZmFuY3lib3gtZngtXCIrbyxpLGgpOiEwPT09dD9zZXRUaW1lb3V0KGgsaSk6aCgpLCEwKSkpfSxjbGVhblVwOmZ1bmN0aW9uKGUpe3ZhciBvLGksYSxzPXRoaXMscj1zLmN1cnJlbnQub3B0cy4kb3JpZztzLmN1cnJlbnQuJHNsaWRlLnRyaWdnZXIoXCJvblJlc2V0XCIpLHMuJHJlZnMuY29udGFpbmVyLmVtcHR5KCkucmVtb3ZlKCkscy50cmlnZ2VyKFwiYWZ0ZXJDbG9zZVwiLGUpLHMuY3VycmVudC5vcHRzLmJhY2tGb2N1cyYmKHImJnIubGVuZ3RoJiZyLmlzKFwiOnZpc2libGVcIil8fChyPXMuJHRyaWdnZXIpLHImJnIubGVuZ3RoJiYoaT10LnNjcm9sbFgsYT10LnNjcm9sbFksci50cmlnZ2VyKFwiZm9jdXNcIiksbihcImh0bWwsIGJvZHlcIikuc2Nyb2xsVG9wKGEpLnNjcm9sbExlZnQoaSkpKSxzLmN1cnJlbnQ9bnVsbCxvPW4uZmFuY3lib3guZ2V0SW5zdGFuY2UoKSxvP28uYWN0aXZhdGUoKToobihcImJvZHlcIikucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1hY3RpdmUgY29tcGVuc2F0ZS1mb3Itc2Nyb2xsYmFyXCIpLG4oXCIjZmFuY3lib3gtc3R5bGUtbm9zY3JvbGxcIikucmVtb3ZlKCkpfSx0cmlnZ2VyOmZ1bmN0aW9uKHQsZSl7dmFyIG8saT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksYT10aGlzLHM9ZSYmZS5vcHRzP2U6YS5jdXJyZW50O2lmKHM/aS51bnNoaWZ0KHMpOnM9YSxpLnVuc2hpZnQoYSksbi5pc0Z1bmN0aW9uKHMub3B0c1t0XSkmJihvPXMub3B0c1t0XS5hcHBseShzLGkpKSwhMT09PW8pcmV0dXJuIG87XCJhZnRlckNsb3NlXCIhPT10JiZhLiRyZWZzP2EuJHJlZnMuY29udGFpbmVyLnRyaWdnZXIodCtcIi5mYlwiLGkpOnIudHJpZ2dlcih0K1wiLmZiXCIsaSl9LHVwZGF0ZUNvbnRyb2xzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxvPXQuY3VycmVudCxpPW8uaW5kZXgsYT10LiRyZWZzLmNvbnRhaW5lcixzPXQuJHJlZnMuY2FwdGlvbixyPW8ub3B0cy5jYXB0aW9uO28uJHNsaWRlLnRyaWdnZXIoXCJyZWZyZXNoXCIpLHImJnIubGVuZ3RoPyh0LiRjYXB0aW9uPXMscy5jaGlsZHJlbigpLmVxKDApLmh0bWwocikpOnQuJGNhcHRpb249bnVsbCx0Lmhhc0hpZGRlbkNvbnRyb2xzfHx0LmlzSWRsZXx8dC5zaG93Q29udHJvbHMoKSxhLmZpbmQoXCJbZGF0YS1mYW5jeWJveC1jb3VudF1cIikuaHRtbCh0Lmdyb3VwLmxlbmd0aCksYS5maW5kKFwiW2RhdGEtZmFuY3lib3gtaW5kZXhdXCIpLmh0bWwoaSsxKSxhLmZpbmQoXCJbZGF0YS1mYW5jeWJveC1wcmV2XVwiKS5wcm9wKFwiZGlzYWJsZWRcIiwhby5vcHRzLmxvb3AmJmk8PTApLGEuZmluZChcIltkYXRhLWZhbmN5Ym94LW5leHRdXCIpLnByb3AoXCJkaXNhYmxlZFwiLCFvLm9wdHMubG9vcCYmaT49dC5ncm91cC5sZW5ndGgtMSksXCJpbWFnZVwiPT09by50eXBlP2EuZmluZChcIltkYXRhLWZhbmN5Ym94LXpvb21dXCIpLnNob3coKS5lbmQoKS5maW5kKFwiW2RhdGEtZmFuY3lib3gtZG93bmxvYWRdXCIpLmF0dHIoXCJocmVmXCIsby5vcHRzLmltYWdlLnNyY3x8by5zcmMpLnNob3coKTpvLm9wdHMudG9vbGJhciYmYS5maW5kKFwiW2RhdGEtZmFuY3lib3gtZG93bmxvYWRdLFtkYXRhLWZhbmN5Ym94LXpvb21dXCIpLmhpZGUoKSxuKGUuYWN0aXZlRWxlbWVudCkuaXMoXCI6aGlkZGVuLFtkaXNhYmxlZF1cIikmJnQuJHJlZnMuY29udGFpbmVyLnRyaWdnZXIoXCJmb2N1c1wiKX0saGlkZUNvbnRyb2xzOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1bXCJpbmZvYmFyXCIsXCJ0b29sYmFyXCIsXCJuYXZcIl07IXQmJmUuY3VycmVudC5vcHRzLnByZXZlbnRDYXB0aW9uT3ZlcmxhcHx8bi5wdXNoKFwiY2FwdGlvblwiKSx0aGlzLiRyZWZzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhuLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImZhbmN5Ym94LXNob3ctXCIrdH0pLmpvaW4oXCIgXCIpKSx0aGlzLmhhc0hpZGRlbkNvbnRyb2xzPSEwfSxzaG93Q29udHJvbHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC5jdXJyZW50P3QuY3VycmVudC5vcHRzOnQub3B0cyxuPXQuJHJlZnMuY29udGFpbmVyO3QuaGFzSGlkZGVuQ29udHJvbHM9ITEsdC5pZGxlU2Vjb25kc0NvdW50ZXI9MCxuLnRvZ2dsZUNsYXNzKFwiZmFuY3lib3gtc2hvdy10b29sYmFyXCIsISghZS50b29sYmFyfHwhZS5idXR0b25zKSkudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1zaG93LWluZm9iYXJcIiwhIShlLmluZm9iYXImJnQuZ3JvdXAubGVuZ3RoPjEpKS50b2dnbGVDbGFzcyhcImZhbmN5Ym94LXNob3ctY2FwdGlvblwiLCEhdC4kY2FwdGlvbikudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1zaG93LW5hdlwiLCEhKGUuYXJyb3dzJiZ0Lmdyb3VwLmxlbmd0aD4xKSkudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1pcy1tb2RhbFwiLCEhZS5tb2RhbCl9LHRvZ2dsZUNvbnRyb2xzOmZ1bmN0aW9uKCl7dGhpcy5oYXNIaWRkZW5Db250cm9scz90aGlzLnNob3dDb250cm9scygpOnRoaXMuaGlkZUNvbnRyb2xzKCl9fSksbi5mYW5jeWJveD17dmVyc2lvbjpcIjMuNS43XCIsZGVmYXVsdHM6YSxnZXRJbnN0YW5jZTpmdW5jdGlvbih0KXt2YXIgZT1uKCcuZmFuY3lib3gtY29udGFpbmVyOm5vdChcIi5mYW5jeWJveC1pcy1jbG9zaW5nXCIpOmxhc3QnKS5kYXRhKFwiRmFuY3lCb3hcIiksbz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBiJiYoXCJzdHJpbmdcIj09PW4udHlwZSh0KT9lW3RdLmFwcGx5KGUsbyk6XCJmdW5jdGlvblwiPT09bi50eXBlKHQpJiZ0LmFwcGx5KGUsbyksZSl9LG9wZW46ZnVuY3Rpb24odCxlLG4pe3JldHVybiBuZXcgYih0LGUsbil9LGNsb3NlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0SW5zdGFuY2UoKTtlJiYoZS5jbG9zZSgpLCEwPT09dCYmdGhpcy5jbG9zZSh0KSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLmNsb3NlKCEwKSxyLmFkZChcImJvZHlcIikub2ZmKFwiY2xpY2suZmItc3RhcnRcIixcIioqXCIpfSxpc01vYmlsZTovQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksdXNlM2Q6ZnVuY3Rpb24oKXt2YXIgbj1lLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIHQuZ2V0Q29tcHV0ZWRTdHlsZSYmdC5nZXRDb21wdXRlZFN0eWxlKG4pJiZ0LmdldENvbXB1dGVkU3R5bGUobikuZ2V0UHJvcGVydHlWYWx1ZShcInRyYW5zZm9ybVwiKSYmIShlLmRvY3VtZW50TW9kZSYmZS5kb2N1bWVudE1vZGU8MTEpfSgpLGdldFRyYW5zbGF0ZTpmdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4hKCF0fHwhdC5sZW5ndGgpJiYoZT10WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHt0b3A6ZS50b3B8fDAsbGVmdDplLmxlZnR8fDAsd2lkdGg6ZS53aWR0aCxoZWlnaHQ6ZS5oZWlnaHQsb3BhY2l0eTpwYXJzZUZsb2F0KHQuY3NzKFwib3BhY2l0eVwiKSl9KX0sc2V0VHJhbnNsYXRlOmZ1bmN0aW9uKHQsZSl7dmFyIG49XCJcIixvPXt9O2lmKHQmJmUpcmV0dXJuIHZvaWQgMD09PWUubGVmdCYmdm9pZCAwPT09ZS50b3B8fChuPSh2b2lkIDA9PT1lLmxlZnQ/dC5wb3NpdGlvbigpLmxlZnQ6ZS5sZWZ0KStcInB4LCBcIisodm9pZCAwPT09ZS50b3A/dC5wb3NpdGlvbigpLnRvcDplLnRvcCkrXCJweFwiLG49dGhpcy51c2UzZD9cInRyYW5zbGF0ZTNkKFwiK24rXCIsIDBweClcIjpcInRyYW5zbGF0ZShcIituK1wiKVwiKSx2b2lkIDAhPT1lLnNjYWxlWCYmdm9pZCAwIT09ZS5zY2FsZVk/bis9XCIgc2NhbGUoXCIrZS5zY2FsZVgrXCIsIFwiK2Uuc2NhbGVZK1wiKVwiOnZvaWQgMCE9PWUuc2NhbGVYJiYobis9XCIgc2NhbGVYKFwiK2Uuc2NhbGVYK1wiKVwiKSxuLmxlbmd0aCYmKG8udHJhbnNmb3JtPW4pLHZvaWQgMCE9PWUub3BhY2l0eSYmKG8ub3BhY2l0eT1lLm9wYWNpdHkpLHZvaWQgMCE9PWUud2lkdGgmJihvLndpZHRoPWUud2lkdGgpLHZvaWQgMCE9PWUuaGVpZ2h0JiYoby5oZWlnaHQ9ZS5oZWlnaHQpLHQuY3NzKG8pfSxhbmltYXRlOmZ1bmN0aW9uKHQsZSxvLGksYSl7dmFyIHMscj10aGlzO24uaXNGdW5jdGlvbihvKSYmKGk9byxvPW51bGwpLHIuc3RvcCh0KSxzPXIuZ2V0VHJhbnNsYXRlKHQpLHQub24oZixmdW5jdGlvbihjKXsoIWN8fCFjLm9yaWdpbmFsRXZlbnR8fHQuaXMoYy5vcmlnaW5hbEV2ZW50LnRhcmdldCkmJlwiei1pbmRleFwiIT1jLm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lKSYmKHIuc3RvcCh0KSxuLmlzTnVtZXJpYyhvKSYmdC5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsXCJcIiksbi5pc1BsYWluT2JqZWN0KGUpP3ZvaWQgMCE9PWUuc2NhbGVYJiZ2b2lkIDAhPT1lLnNjYWxlWSYmci5zZXRUcmFuc2xhdGUodCx7dG9wOmUudG9wLGxlZnQ6ZS5sZWZ0LHdpZHRoOnMud2lkdGgqZS5zY2FsZVgsaGVpZ2h0OnMuaGVpZ2h0KmUuc2NhbGVZLHNjYWxlWDoxLHNjYWxlWToxfSk6ITAhPT1hJiZ0LnJlbW92ZUNsYXNzKGUpLG4uaXNGdW5jdGlvbihpKSYmaShjKSl9KSxuLmlzTnVtZXJpYyhvKSYmdC5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsbytcIm1zXCIpLG4uaXNQbGFpbk9iamVjdChlKT8odm9pZCAwIT09ZS5zY2FsZVgmJnZvaWQgMCE9PWUuc2NhbGVZJiYoZGVsZXRlIGUud2lkdGgsZGVsZXRlIGUuaGVpZ2h0LHQucGFyZW50KCkuaGFzQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0taW1hZ2VcIikmJnQucGFyZW50KCkuYWRkQ2xhc3MoXCJmYW5jeWJveC1pcy1zY2FsaW5nXCIpKSxuLmZhbmN5Ym94LnNldFRyYW5zbGF0ZSh0LGUpKTp0LmFkZENsYXNzKGUpLHQuZGF0YShcInRpbWVyXCIsc2V0VGltZW91dChmdW5jdGlvbigpe3QudHJpZ2dlcihmKX0sbyszMykpfSxzdG9wOmZ1bmN0aW9uKHQsZSl7dCYmdC5sZW5ndGgmJihjbGVhclRpbWVvdXQodC5kYXRhKFwidGltZXJcIikpLGUmJnQudHJpZ2dlcihmKSx0Lm9mZihmKS5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsXCJcIiksdC5wYXJlbnQoKS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWlzLXNjYWxpbmdcIikpfX0sbi5mbi5mYW5jeWJveD1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gdD10fHx7fSxlPXQuc2VsZWN0b3J8fCExLGU/bihcImJvZHlcIikub2ZmKFwiY2xpY2suZmItc3RhcnRcIixlKS5vbihcImNsaWNrLmZiLXN0YXJ0XCIsZSx7b3B0aW9uczp0fSxpKTp0aGlzLm9mZihcImNsaWNrLmZiLXN0YXJ0XCIpLm9uKFwiY2xpY2suZmItc3RhcnRcIix7aXRlbXM6dGhpcyxvcHRpb25zOnR9LGkpLHRoaXN9LHIub24oXCJjbGljay5mYi1zdGFydFwiLFwiW2RhdGEtZmFuY3lib3hdXCIsaSksci5vbihcImNsaWNrLmZiLXN0YXJ0XCIsXCJbZGF0YS1mYW5jeWJveC10cmlnZ2VyXVwiLGZ1bmN0aW9uKHQpe24oJ1tkYXRhLWZhbmN5Ym94PVwiJytuKHRoaXMpLmF0dHIoXCJkYXRhLWZhbmN5Ym94LXRyaWdnZXJcIikrJ1wiXScpLmVxKG4odGhpcykuYXR0cihcImRhdGEtZmFuY3lib3gtaW5kZXhcIil8fDApLnRyaWdnZXIoXCJjbGljay5mYi1zdGFydFwiLHskdHJpZ2dlcjpuKHRoaXMpfSl9KSxmdW5jdGlvbigpe3ZhciB0PW51bGw7ci5vbihcIm1vdXNlZG93biBtb3VzZXVwIGZvY3VzIGJsdXJcIixcIi5mYW5jeWJveC1idXR0b25cIixmdW5jdGlvbihlKXtzd2l0Y2goZS50eXBlKXtjYXNlXCJtb3VzZWRvd25cIjp0PW4odGhpcyk7YnJlYWs7Y2FzZVwibW91c2V1cFwiOnQ9bnVsbDticmVhaztjYXNlXCJmb2N1c2luXCI6bihcIi5mYW5jeWJveC1idXR0b25cIikucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1mb2N1c1wiKSxuKHRoaXMpLmlzKHQpfHxuKHRoaXMpLmlzKFwiW2Rpc2FibGVkXVwiKXx8bih0aGlzKS5hZGRDbGFzcyhcImZhbmN5Ym94LWZvY3VzXCIpO2JyZWFrO2Nhc2VcImZvY3Vzb3V0XCI6bihcIi5mYW5jeWJveC1idXR0b25cIikucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1mb2N1c1wiKX19KX0oKX19KHdpbmRvdyxkb2N1bWVudCxqUXVlcnkpLGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO3ZhciBlPXt5b3V0dWJlOnttYXRjaGVyOi8oeW91dHViZVxcLmNvbXx5b3V0dVxcLmJlfHlvdXR1YmVcXC1ub2Nvb2tpZVxcLmNvbSlcXC8od2F0Y2hcXD8oLiomKT92PXx2XFwvfHVcXC98ZW1iZWRcXC8/KT8odmlkZW9zZXJpZXNcXD9saXN0PSguKil8W1xcdy1dezExfXxcXD9saXN0VHlwZT0oLiopJmxpc3Q9KC4qKSkoLiopL2kscGFyYW1zOnthdXRvcGxheToxLGF1dG9oaWRlOjEsZnM6MSxyZWw6MCxoZDoxLHdtb2RlOlwidHJhbnNwYXJlbnRcIixlbmFibGVqc2FwaToxLGh0bWw1OjF9LHBhcmFtUGxhY2U6OCx0eXBlOlwiaWZyYW1lXCIsdXJsOlwiaHR0cHM6Ly93d3cueW91dHViZS1ub2Nvb2tpZS5jb20vZW1iZWQvJDRcIix0aHVtYjpcImh0dHBzOi8vaW1nLnlvdXR1YmUuY29tL3ZpLyQ0L2hxZGVmYXVsdC5qcGdcIn0sdmltZW86e21hdGNoZXI6L14uK3ZpbWVvLmNvbVxcLyguKlxcLyk/KFtcXGRdKykoLiopPy8scGFyYW1zOnthdXRvcGxheToxLGhkOjEsc2hvd190aXRsZToxLHNob3dfYnlsaW5lOjEsc2hvd19wb3J0cmFpdDowLGZ1bGxzY3JlZW46MX0scGFyYW1QbGFjZTozLHR5cGU6XCJpZnJhbWVcIix1cmw6XCIvL3BsYXllci52aW1lby5jb20vdmlkZW8vJDJcIn0saW5zdGFncmFtOnttYXRjaGVyOi8oaW5zdGFnclxcLmFtfGluc3RhZ3JhbVxcLmNvbSlcXC9wXFwvKFthLXpBLVowLTlfXFwtXSspXFwvPy9pLHR5cGU6XCJpbWFnZVwiLHVybDpcIi8vJDEvcC8kMi9tZWRpYS8/c2l6ZT1sXCJ9LGdtYXBfcGxhY2U6e21hdGNoZXI6LyhtYXBzXFwuKT9nb29nbGVcXC4oW2Etel17MiwzfShcXC5bYS16XXsyfSk/KVxcLygoKG1hcHNcXC8ocGxhY2VcXC8oLiopXFwvKT9cXEAoLiopLChcXGQrLj9cXGQrPyl6KSl8KFxcP2xsPSkpKC4qKT8vaSx0eXBlOlwiaWZyYW1lXCIsdXJsOmZ1bmN0aW9uKHQpe3JldHVyblwiLy9tYXBzLmdvb2dsZS5cIit0WzJdK1wiLz9sbD1cIisodFs5XT90WzldK1wiJno9XCIrTWF0aC5mbG9vcih0WzEwXSkrKHRbMTJdP3RbMTJdLnJlcGxhY2UoL15cXC8vLFwiJlwiKTpcIlwiKTp0WzEyXStcIlwiKS5yZXBsYWNlKC9cXD8vLFwiJlwiKStcIiZvdXRwdXQ9XCIrKHRbMTJdJiZ0WzEyXS5pbmRleE9mKFwibGF5ZXI9Y1wiKT4wP1wic3ZlbWJlZFwiOlwiZW1iZWRcIil9fSxnbWFwX3NlYXJjaDp7bWF0Y2hlcjovKG1hcHNcXC4pP2dvb2dsZVxcLihbYS16XXsyLDN9KFxcLlthLXpdezJ9KT8pXFwvKG1hcHNcXC9zZWFyY2hcXC8pKC4qKS9pLHR5cGU6XCJpZnJhbWVcIix1cmw6ZnVuY3Rpb24odCl7cmV0dXJuXCIvL21hcHMuZ29vZ2xlLlwiK3RbMl0rXCIvbWFwcz9xPVwiK3RbNV0ucmVwbGFjZShcInF1ZXJ5PVwiLFwicT1cIikucmVwbGFjZShcImFwaT0xXCIsXCJcIikrXCImb3V0cHV0PWVtYmVkXCJ9fX0sbj1mdW5jdGlvbihlLG4sbyl7aWYoZSlyZXR1cm4gbz1vfHxcIlwiLFwib2JqZWN0XCI9PT10LnR5cGUobykmJihvPXQucGFyYW0obywhMCkpLHQuZWFjaChuLGZ1bmN0aW9uKHQsbil7ZT1lLnJlcGxhY2UoXCIkXCIrdCxufHxcIlwiKX0pLG8ubGVuZ3RoJiYoZSs9KGUuaW5kZXhPZihcIj9cIik+MD9cIiZcIjpcIj9cIikrbyksZX07dChkb2N1bWVudCkub24oXCJvYmplY3ROZWVkc1R5cGUuZmJcIixmdW5jdGlvbihvLGksYSl7dmFyIHMscixjLGwsZCx1LGYscD1hLnNyY3x8XCJcIixoPSExO3M9dC5leHRlbmQoITAse30sZSxhLm9wdHMubWVkaWEpLHQuZWFjaChzLGZ1bmN0aW9uKGUsbyl7aWYoYz1wLm1hdGNoKG8ubWF0Y2hlcikpe2lmKGg9by50eXBlLGY9ZSx1PXt9LG8ucGFyYW1QbGFjZSYmY1tvLnBhcmFtUGxhY2VdKXtkPWNbby5wYXJhbVBsYWNlXSxcIj9cIj09ZFswXSYmKGQ9ZC5zdWJzdHJpbmcoMSkpLGQ9ZC5zcGxpdChcIiZcIik7Zm9yKHZhciBpPTA7aTxkLmxlbmd0aDsrK2kpe3ZhciBzPWRbaV0uc3BsaXQoXCI9XCIsMik7Mj09cy5sZW5ndGgmJih1W3NbMF1dPWRlY29kZVVSSUNvbXBvbmVudChzWzFdLnJlcGxhY2UoL1xcKy9nLFwiIFwiKSkpfX1yZXR1cm4gbD10LmV4dGVuZCghMCx7fSxvLnBhcmFtcyxhLm9wdHNbZV0sdSkscD1cImZ1bmN0aW9uXCI9PT10LnR5cGUoby51cmwpP28udXJsLmNhbGwodGhpcyxjLGwsYSk6bihvLnVybCxjLGwpLHI9XCJmdW5jdGlvblwiPT09dC50eXBlKG8udGh1bWIpP28udGh1bWIuY2FsbCh0aGlzLGMsbCxhKTpuKG8udGh1bWIsYyksXCJ5b3V0dWJlXCI9PT1lP3A9cC5yZXBsYWNlKC8mdD0oKFxcZCspbSk/KFxcZCspcy8sZnVuY3Rpb24odCxlLG4sbyl7cmV0dXJuXCImc3RhcnQ9XCIrKChuPzYwKnBhcnNlSW50KG4sMTApOjApK3BhcnNlSW50KG8sMTApKX0pOlwidmltZW9cIj09PWUmJihwPXAucmVwbGFjZShcIiYlMjNcIixcIiNcIikpLCExfX0pLGg/KGEub3B0cy50aHVtYnx8YS5vcHRzLiR0aHVtYiYmYS5vcHRzLiR0aHVtYi5sZW5ndGh8fChhLm9wdHMudGh1bWI9ciksXCJpZnJhbWVcIj09PWgmJihhLm9wdHM9dC5leHRlbmQoITAsYS5vcHRzLHtpZnJhbWU6e3ByZWxvYWQ6ITEsYXR0cjp7c2Nyb2xsaW5nOlwibm9cIn19fSkpLHQuZXh0ZW5kKGEse3R5cGU6aCxzcmM6cCxvcmlnU3JjOmEuc3JjLGNvbnRlbnRTb3VyY2U6Zixjb250ZW50VHlwZTpcImltYWdlXCI9PT1oP1wiaW1hZ2VcIjpcImdtYXBfcGxhY2VcIj09Znx8XCJnbWFwX3NlYXJjaFwiPT1mP1wibWFwXCI6XCJ2aWRlb1wifSkpOnAmJihhLnR5cGU9YS5vcHRzLmRlZmF1bHRUeXBlKX0pO3ZhciBvPXt5b3V0dWJlOntzcmM6XCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9pZnJhbWVfYXBpXCIsY2xhc3M6XCJZVFwiLGxvYWRpbmc6ITEsbG9hZGVkOiExfSx2aW1lbzp7c3JjOlwiaHR0cHM6Ly9wbGF5ZXIudmltZW8uY29tL2FwaS9wbGF5ZXIuanNcIixjbGFzczpcIlZpbWVvXCIsbG9hZGluZzohMSxsb2FkZWQ6ITF9LGxvYWQ6ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzO2lmKHRoaXNbdF0ubG9hZGVkKXJldHVybiB2b2lkIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtuLmRvbmUodCl9KTt0aGlzW3RdLmxvYWRpbmd8fCh0aGlzW3RdLmxvYWRpbmc9ITAsZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpLGUudHlwZT1cInRleHQvamF2YXNjcmlwdFwiLGUuc3JjPXRoaXNbdF0uc3JjLFwieW91dHViZVwiPT09dD93aW5kb3cub25Zb3VUdWJlSWZyYW1lQVBJUmVhZHk9ZnVuY3Rpb24oKXtuW3RdLmxvYWRlZD0hMCxuLmRvbmUodCl9OmUub25sb2FkPWZ1bmN0aW9uKCl7blt0XS5sb2FkZWQ9ITAsbi5kb25lKHQpfSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGUpKX0sZG9uZTpmdW5jdGlvbihlKXt2YXIgbixvLGk7XCJ5b3V0dWJlXCI9PT1lJiZkZWxldGUgd2luZG93Lm9uWW91VHViZUlmcmFtZUFQSVJlYWR5LChuPXQuZmFuY3lib3guZ2V0SW5zdGFuY2UoKSkmJihvPW4uY3VycmVudC4kY29udGVudC5maW5kKFwiaWZyYW1lXCIpLFwieW91dHViZVwiPT09ZSYmdm9pZCAwIT09WVQmJllUP2k9bmV3IFlULlBsYXllcihvLmF0dHIoXCJpZFwiKSx7ZXZlbnRzOntvblN0YXRlQ2hhbmdlOmZ1bmN0aW9uKHQpezA9PXQuZGF0YSYmbi5uZXh0KCl9fX0pOlwidmltZW9cIj09PWUmJnZvaWQgMCE9PVZpbWVvJiZWaW1lbyYmKGk9bmV3IFZpbWVvLlBsYXllcihvKSxpLm9uKFwiZW5kZWRcIixmdW5jdGlvbigpe24ubmV4dCgpfSkpKX19O3QoZG9jdW1lbnQpLm9uKHtcImFmdGVyU2hvdy5mYlwiOmZ1bmN0aW9uKHQsZSxuKXtlLmdyb3VwLmxlbmd0aD4xJiYoXCJ5b3V0dWJlXCI9PT1uLmNvbnRlbnRTb3VyY2V8fFwidmltZW9cIj09PW4uY29udGVudFNvdXJjZSkmJm8ubG9hZChuLmNvbnRlbnRTb3VyY2UpfX0pfShqUXVlcnkpLGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgbz1mdW5jdGlvbigpe3JldHVybiB0LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8dC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHQubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx0Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGZ1bmN0aW9uKGUpe3JldHVybiB0LnNldFRpbWVvdXQoZSwxZTMvNjApfX0oKSxpPWZ1bmN0aW9uKCl7cmV0dXJuIHQuY2FuY2VsQW5pbWF0aW9uRnJhbWV8fHQud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fHQubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fHQub0NhbmNlbEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbihlKXt0LmNsZWFyVGltZW91dChlKX19KCksYT1mdW5jdGlvbihlKXt2YXIgbj1bXTtlPWUub3JpZ2luYWxFdmVudHx8ZXx8dC5lLGU9ZS50b3VjaGVzJiZlLnRvdWNoZXMubGVuZ3RoP2UudG91Y2hlczplLmNoYW5nZWRUb3VjaGVzJiZlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aD9lLmNoYW5nZWRUb3VjaGVzOltlXTtmb3IodmFyIG8gaW4gZSllW29dLnBhZ2VYP24ucHVzaCh7eDplW29dLnBhZ2VYLHk6ZVtvXS5wYWdlWX0pOmVbb10uY2xpZW50WCYmbi5wdXNoKHt4OmVbb10uY2xpZW50WCx5OmVbb10uY2xpZW50WX0pO3JldHVybiBufSxzPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gZSYmdD9cInhcIj09PW4/dC54LWUueDpcInlcIj09PW4/dC55LWUueTpNYXRoLnNxcnQoTWF0aC5wb3codC54LWUueCwyKStNYXRoLnBvdyh0LnktZS55LDIpKTowfSxyPWZ1bmN0aW9uKHQpe2lmKHQuaXMoJ2EsYXJlYSxidXR0b24sW3JvbGU9XCJidXR0b25cIl0saW5wdXQsbGFiZWwsc2VsZWN0LHN1bW1hcnksdGV4dGFyZWEsdmlkZW8sYXVkaW8saWZyYW1lJyl8fG4uaXNGdW5jdGlvbih0LmdldCgwKS5vbmNsaWNrKXx8dC5kYXRhKFwic2VsZWN0YWJsZVwiKSlyZXR1cm4hMDtmb3IodmFyIGU9MCxvPXRbMF0uYXR0cmlidXRlcyxpPW8ubGVuZ3RoO2U8aTtlKyspaWYoXCJkYXRhLWZhbmN5Ym94LVwiPT09b1tlXS5ub2RlTmFtZS5zdWJzdHIoMCwxNCkpcmV0dXJuITA7cmV0dXJuITF9LGM9ZnVuY3Rpb24oZSl7dmFyIG49dC5nZXRDb21wdXRlZFN0eWxlKGUpW1wib3ZlcmZsb3cteVwiXSxvPXQuZ2V0Q29tcHV0ZWRTdHlsZShlKVtcIm92ZXJmbG93LXhcIl0saT0oXCJzY3JvbGxcIj09PW58fFwiYXV0b1wiPT09bikmJmUuc2Nyb2xsSGVpZ2h0PmUuY2xpZW50SGVpZ2h0LGE9KFwic2Nyb2xsXCI9PT1vfHxcImF1dG9cIj09PW8pJiZlLnNjcm9sbFdpZHRoPmUuY2xpZW50V2lkdGg7cmV0dXJuIGl8fGF9LGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSExOzspe2lmKGU9Yyh0LmdldCgwKSkpYnJlYWs7aWYodD10LnBhcmVudCgpLCF0Lmxlbmd0aHx8dC5oYXNDbGFzcyhcImZhbmN5Ym94LXN0YWdlXCIpfHx0LmlzKFwiYm9keVwiKSlicmVha31yZXR1cm4gZX0sZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2UuaW5zdGFuY2U9dCxlLiRiZz10LiRyZWZzLmJnLGUuJHN0YWdlPXQuJHJlZnMuc3RhZ2UsZS4kY29udGFpbmVyPXQuJHJlZnMuY29udGFpbmVyLGUuZGVzdHJveSgpLGUuJGNvbnRhaW5lci5vbihcInRvdWNoc3RhcnQuZmIudG91Y2ggbW91c2Vkb3duLmZiLnRvdWNoXCIsbi5wcm94eShlLFwib250b3VjaHN0YXJ0XCIpKX07ZC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dC4kY29udGFpbmVyLm9mZihcIi5mYi50b3VjaFwiKSxuKGUpLm9mZihcIi5mYi50b3VjaFwiKSx0LnJlcXVlc3RJZCYmKGkodC5yZXF1ZXN0SWQpLHQucmVxdWVzdElkPW51bGwpLHQudGFwcGVkJiYoY2xlYXJUaW1lb3V0KHQudGFwcGVkKSx0LnRhcHBlZD1udWxsKX0sZC5wcm90b3R5cGUub250b3VjaHN0YXJ0PWZ1bmN0aW9uKG8pe3ZhciBpPXRoaXMsYz1uKG8udGFyZ2V0KSxkPWkuaW5zdGFuY2UsdT1kLmN1cnJlbnQsZj11LiRzbGlkZSxwPXUuJGNvbnRlbnQsaD1cInRvdWNoc3RhcnRcIj09by50eXBlO2lmKGgmJmkuJGNvbnRhaW5lci5vZmYoXCJtb3VzZWRvd24uZmIudG91Y2hcIiksKCFvLm9yaWdpbmFsRXZlbnR8fDIhPW8ub3JpZ2luYWxFdmVudC5idXR0b24pJiZmLmxlbmd0aCYmYy5sZW5ndGgmJiFyKGMpJiYhcihjLnBhcmVudCgpKSYmKGMuaXMoXCJpbWdcIil8fCEoby5vcmlnaW5hbEV2ZW50LmNsaWVudFg+Y1swXS5jbGllbnRXaWR0aCtjLm9mZnNldCgpLmxlZnQpKSl7aWYoIXV8fGQuaXNBbmltYXRpbmd8fHUuJHNsaWRlLmhhc0NsYXNzKFwiZmFuY3lib3gtYW5pbWF0ZWRcIikpcmV0dXJuIG8uc3RvcFByb3BhZ2F0aW9uKCksdm9pZCBvLnByZXZlbnREZWZhdWx0KCk7aS5yZWFsUG9pbnRzPWkuc3RhcnRQb2ludHM9YShvKSxpLnN0YXJ0UG9pbnRzLmxlbmd0aCYmKHUudG91Y2gmJm8uc3RvcFByb3BhZ2F0aW9uKCksaS5zdGFydEV2ZW50PW8saS5jYW5UYXA9ITAsaS4kdGFyZ2V0PWMsaS4kY29udGVudD1wLGkub3B0cz11Lm9wdHMudG91Y2gsaS5pc1Bhbm5pbmc9ITEsaS5pc1N3aXBpbmc9ITEsaS5pc1pvb21pbmc9ITEsaS5pc1Njcm9sbGluZz0hMSxpLmNhblBhbj1kLmNhblBhbigpLGkuc3RhcnRUaW1lPShuZXcgRGF0ZSkuZ2V0VGltZSgpLGkuZGlzdGFuY2VYPWkuZGlzdGFuY2VZPWkuZGlzdGFuY2U9MCxpLmNhbnZhc1dpZHRoPU1hdGgucm91bmQoZlswXS5jbGllbnRXaWR0aCksaS5jYW52YXNIZWlnaHQ9TWF0aC5yb3VuZChmWzBdLmNsaWVudEhlaWdodCksaS5jb250ZW50TGFzdFBvcz1udWxsLGkuY29udGVudFN0YXJ0UG9zPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKGkuJGNvbnRlbnQpfHx7dG9wOjAsbGVmdDowfSxpLnNsaWRlclN0YXJ0UG9zPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKGYpLGkuc3RhZ2VQb3M9bi5mYW5jeWJveC5nZXRUcmFuc2xhdGUoZC4kcmVmcy5zdGFnZSksaS5zbGlkZXJTdGFydFBvcy50b3AtPWkuc3RhZ2VQb3MudG9wLGkuc2xpZGVyU3RhcnRQb3MubGVmdC09aS5zdGFnZVBvcy5sZWZ0LGkuY29udGVudFN0YXJ0UG9zLnRvcC09aS5zdGFnZVBvcy50b3AsaS5jb250ZW50U3RhcnRQb3MubGVmdC09aS5zdGFnZVBvcy5sZWZ0LG4oZSkub2ZmKFwiLmZiLnRvdWNoXCIpLm9uKGg/XCJ0b3VjaGVuZC5mYi50b3VjaCB0b3VjaGNhbmNlbC5mYi50b3VjaFwiOlwibW91c2V1cC5mYi50b3VjaCBtb3VzZWxlYXZlLmZiLnRvdWNoXCIsbi5wcm94eShpLFwib250b3VjaGVuZFwiKSkub24oaD9cInRvdWNobW92ZS5mYi50b3VjaFwiOlwibW91c2Vtb3ZlLmZiLnRvdWNoXCIsbi5wcm94eShpLFwib250b3VjaG1vdmVcIikpLG4uZmFuY3lib3guaXNNb2JpbGUmJmUuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLGkub25zY3JvbGwsITApLCgoaS5vcHRzfHxpLmNhblBhbikmJihjLmlzKGkuJHN0YWdlKXx8aS4kc3RhZ2UuZmluZChjKS5sZW5ndGgpfHwoYy5pcyhcIi5mYW5jeWJveC1pbWFnZVwiKSYmby5wcmV2ZW50RGVmYXVsdCgpLG4uZmFuY3lib3guaXNNb2JpbGUmJmMucGFyZW50cyhcIi5mYW5jeWJveC1jYXB0aW9uXCIpLmxlbmd0aCkpJiYoaS5pc1Njcm9sbGFibGU9bChjKXx8bChjLnBhcmVudCgpKSxuLmZhbmN5Ym94LmlzTW9iaWxlJiZpLmlzU2Nyb2xsYWJsZXx8by5wcmV2ZW50RGVmYXVsdCgpLCgxPT09aS5zdGFydFBvaW50cy5sZW5ndGh8fHUuaGFzRXJyb3IpJiYoaS5jYW5QYW4/KG4uZmFuY3lib3guc3RvcChpLiRjb250ZW50KSxpLmlzUGFubmluZz0hMCk6aS5pc1N3aXBpbmc9ITAsaS4kY29udGFpbmVyLmFkZENsYXNzKFwiZmFuY3lib3gtaXMtZ3JhYmJpbmdcIikpLDI9PT1pLnN0YXJ0UG9pbnRzLmxlbmd0aCYmXCJpbWFnZVwiPT09dS50eXBlJiYodS5pc0xvYWRlZHx8dS4kZ2hvc3QpJiYoaS5jYW5UYXA9ITEsaS5pc1N3aXBpbmc9ITEsaS5pc1Bhbm5pbmc9ITEsaS5pc1pvb21pbmc9ITAsbi5mYW5jeWJveC5zdG9wKGkuJGNvbnRlbnQpLGkuY2VudGVyUG9pbnRTdGFydFg9LjUqKGkuc3RhcnRQb2ludHNbMF0ueCtpLnN0YXJ0UG9pbnRzWzFdLngpLW4odCkuc2Nyb2xsTGVmdCgpLGkuY2VudGVyUG9pbnRTdGFydFk9LjUqKGkuc3RhcnRQb2ludHNbMF0ueStpLnN0YXJ0UG9pbnRzWzFdLnkpLW4odCkuc2Nyb2xsVG9wKCksaS5wZXJjZW50YWdlT2ZJbWFnZUF0UGluY2hQb2ludFg9KGkuY2VudGVyUG9pbnRTdGFydFgtaS5jb250ZW50U3RhcnRQb3MubGVmdCkvaS5jb250ZW50U3RhcnRQb3Mud2lkdGgsaS5wZXJjZW50YWdlT2ZJbWFnZUF0UGluY2hQb2ludFk9KGkuY2VudGVyUG9pbnRTdGFydFktaS5jb250ZW50U3RhcnRQb3MudG9wKS9pLmNvbnRlbnRTdGFydFBvcy5oZWlnaHQsaS5zdGFydERpc3RhbmNlQmV0d2VlbkZpbmdlcnM9cyhpLnN0YXJ0UG9pbnRzWzBdLGkuc3RhcnRQb2ludHNbMV0pKSkpfX0sZC5wcm90b3R5cGUub25zY3JvbGw9ZnVuY3Rpb24odCl7dmFyIG49dGhpcztuLmlzU2Nyb2xsaW5nPSEwLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLG4ub25zY3JvbGwsITApfSxkLnByb3RvdHlwZS5vbnRvdWNobW92ZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiB2b2lkIDAhPT10Lm9yaWdpbmFsRXZlbnQuYnV0dG9ucyYmMD09PXQub3JpZ2luYWxFdmVudC5idXR0b25zP3ZvaWQgZS5vbnRvdWNoZW5kKHQpOmUuaXNTY3JvbGxpbmc/dm9pZChlLmNhblRhcD0hMSk6KGUubmV3UG9pbnRzPWEodCksdm9pZCgoZS5vcHRzfHxlLmNhblBhbikmJmUubmV3UG9pbnRzLmxlbmd0aCYmZS5uZXdQb2ludHMubGVuZ3RoJiYoZS5pc1N3aXBpbmcmJiEwPT09ZS5pc1N3aXBpbmd8fHQucHJldmVudERlZmF1bHQoKSxlLmRpc3RhbmNlWD1zKGUubmV3UG9pbnRzWzBdLGUuc3RhcnRQb2ludHNbMF0sXCJ4XCIpLGUuZGlzdGFuY2VZPXMoZS5uZXdQb2ludHNbMF0sZS5zdGFydFBvaW50c1swXSxcInlcIiksZS5kaXN0YW5jZT1zKGUubmV3UG9pbnRzWzBdLGUuc3RhcnRQb2ludHNbMF0pLGUuZGlzdGFuY2U+MCYmKGUuaXNTd2lwaW5nP2Uub25Td2lwZSh0KTplLmlzUGFubmluZz9lLm9uUGFuKCk6ZS5pc1pvb21pbmcmJmUub25ab29tKCkpKSkpfSxkLnByb3RvdHlwZS5vblN3aXBlPWZ1bmN0aW9uKGUpe3ZhciBhLHM9dGhpcyxyPXMuaW5zdGFuY2UsYz1zLmlzU3dpcGluZyxsPXMuc2xpZGVyU3RhcnRQb3MubGVmdHx8MDtpZighMCE9PWMpXCJ4XCI9PWMmJihzLmRpc3RhbmNlWD4wJiYocy5pbnN0YW5jZS5ncm91cC5sZW5ndGg8Mnx8MD09PXMuaW5zdGFuY2UuY3VycmVudC5pbmRleCYmIXMuaW5zdGFuY2UuY3VycmVudC5vcHRzLmxvb3ApP2wrPU1hdGgucG93KHMuZGlzdGFuY2VYLC44KTpzLmRpc3RhbmNlWDwwJiYocy5pbnN0YW5jZS5ncm91cC5sZW5ndGg8Mnx8cy5pbnN0YW5jZS5jdXJyZW50LmluZGV4PT09cy5pbnN0YW5jZS5ncm91cC5sZW5ndGgtMSYmIXMuaW5zdGFuY2UuY3VycmVudC5vcHRzLmxvb3ApP2wtPU1hdGgucG93KC1zLmRpc3RhbmNlWCwuOCk6bCs9cy5kaXN0YW5jZVgpLHMuc2xpZGVyTGFzdFBvcz17dG9wOlwieFwiPT1jPzA6cy5zbGlkZXJTdGFydFBvcy50b3Arcy5kaXN0YW5jZVksbGVmdDpsfSxzLnJlcXVlc3RJZCYmKGkocy5yZXF1ZXN0SWQpLHMucmVxdWVzdElkPW51bGwpLHMucmVxdWVzdElkPW8oZnVuY3Rpb24oKXtzLnNsaWRlckxhc3RQb3MmJihuLmVhY2gocy5pbnN0YW5jZS5zbGlkZXMsZnVuY3Rpb24odCxlKXt2YXIgbz1lLnBvcy1zLmluc3RhbmNlLmN1cnJQb3M7bi5mYW5jeWJveC5zZXRUcmFuc2xhdGUoZS4kc2xpZGUse3RvcDpzLnNsaWRlckxhc3RQb3MudG9wLGxlZnQ6cy5zbGlkZXJMYXN0UG9zLmxlZnQrbypzLmNhbnZhc1dpZHRoK28qZS5vcHRzLmd1dHRlcn0pfSkscy4kY29udGFpbmVyLmFkZENsYXNzKFwiZmFuY3lib3gtaXMtc2xpZGluZ1wiKSl9KTtlbHNlIGlmKE1hdGguYWJzKHMuZGlzdGFuY2UpPjEwKXtpZihzLmNhblRhcD0hMSxyLmdyb3VwLmxlbmd0aDwyJiZzLm9wdHMudmVydGljYWw/cy5pc1N3aXBpbmc9XCJ5XCI6ci5pc0RyYWdnaW5nfHwhMT09PXMub3B0cy52ZXJ0aWNhbHx8XCJhdXRvXCI9PT1zLm9wdHMudmVydGljYWwmJm4odCkud2lkdGgoKT44MDA/cy5pc1N3aXBpbmc9XCJ4XCI6KGE9TWF0aC5hYnMoMTgwKk1hdGguYXRhbjIocy5kaXN0YW5jZVkscy5kaXN0YW5jZVgpL01hdGguUEkpLHMuaXNTd2lwaW5nPWE+NDUmJmE8MTM1P1wieVwiOlwieFwiKSxcInlcIj09PXMuaXNTd2lwaW5nJiZuLmZhbmN5Ym94LmlzTW9iaWxlJiZzLmlzU2Nyb2xsYWJsZSlyZXR1cm4gdm9pZChzLmlzU2Nyb2xsaW5nPSEwKTtyLmlzRHJhZ2dpbmc9cy5pc1N3aXBpbmcscy5zdGFydFBvaW50cz1zLm5ld1BvaW50cyxuLmVhY2goci5zbGlkZXMsZnVuY3Rpb24odCxlKXt2YXIgbyxpO24uZmFuY3lib3guc3RvcChlLiRzbGlkZSksbz1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShlLiRzbGlkZSksaT1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShyLiRyZWZzLnN0YWdlKSxlLiRzbGlkZS5jc3Moe3RyYW5zZm9ybTpcIlwiLG9wYWNpdHk6XCJcIixcInRyYW5zaXRpb24tZHVyYXRpb25cIjpcIlwifSkucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1hbmltYXRlZFwiKS5yZW1vdmVDbGFzcyhmdW5jdGlvbih0LGUpe3JldHVybihlLm1hdGNoKC8oXnxcXHMpZmFuY3lib3gtZngtXFxTKy9nKXx8W10pLmpvaW4oXCIgXCIpfSksZS5wb3M9PT1yLmN1cnJlbnQucG9zJiYocy5zbGlkZXJTdGFydFBvcy50b3A9by50b3AtaS50b3Ascy5zbGlkZXJTdGFydFBvcy5sZWZ0PW8ubGVmdC1pLmxlZnQpLG4uZmFuY3lib3guc2V0VHJhbnNsYXRlKGUuJHNsaWRlLHt0b3A6by50b3AtaS50b3AsbGVmdDpvLmxlZnQtaS5sZWZ0fSl9KSxyLlNsaWRlU2hvdyYmci5TbGlkZVNob3cuaXNBY3RpdmUmJnIuU2xpZGVTaG93LnN0b3AoKX19LGQucHJvdG90eXBlLm9uUGFuPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZihzKHQubmV3UG9pbnRzWzBdLHQucmVhbFBvaW50c1swXSk8KG4uZmFuY3lib3guaXNNb2JpbGU/MTA6NSkpcmV0dXJuIHZvaWQodC5zdGFydFBvaW50cz10Lm5ld1BvaW50cyk7dC5jYW5UYXA9ITEsdC5jb250ZW50TGFzdFBvcz10LmxpbWl0TW92ZW1lbnQoKSx0LnJlcXVlc3RJZCYmaSh0LnJlcXVlc3RJZCksdC5yZXF1ZXN0SWQ9byhmdW5jdGlvbigpe24uZmFuY3lib3guc2V0VHJhbnNsYXRlKHQuJGNvbnRlbnQsdC5jb250ZW50TGFzdFBvcyl9KX0sZC5wcm90b3R5cGUubGltaXRNb3ZlbWVudD1mdW5jdGlvbigpe3ZhciB0LGUsbixvLGksYSxzPXRoaXMscj1zLmNhbnZhc1dpZHRoLGM9cy5jYW52YXNIZWlnaHQsbD1zLmRpc3RhbmNlWCxkPXMuZGlzdGFuY2VZLHU9cy5jb250ZW50U3RhcnRQb3MsZj11LmxlZnQscD11LnRvcCxoPXUud2lkdGgsZz11LmhlaWdodDtyZXR1cm4gaT1oPnI/ZitsOmYsYT1wK2QsdD1NYXRoLm1heCgwLC41KnItLjUqaCksZT1NYXRoLm1heCgwLC41KmMtLjUqZyksbj1NYXRoLm1pbihyLWgsLjUqci0uNSpoKSxvPU1hdGgubWluKGMtZywuNSpjLS41KmcpLGw+MCYmaT50JiYoaT10LTErTWF0aC5wb3coLXQrZitsLC44KXx8MCksbDwwJiZpPG4mJihpPW4rMS1NYXRoLnBvdyhuLWYtbCwuOCl8fDApLGQ+MCYmYT5lJiYoYT1lLTErTWF0aC5wb3coLWUrcCtkLC44KXx8MCksZDwwJiZhPG8mJihhPW8rMS1NYXRoLnBvdyhvLXAtZCwuOCl8fDApLHt0b3A6YSxsZWZ0Oml9fSxkLnByb3RvdHlwZS5saW1pdFBvc2l0aW9uPWZ1bmN0aW9uKHQsZSxuLG8pe3ZhciBpPXRoaXMsYT1pLmNhbnZhc1dpZHRoLHM9aS5jYW52YXNIZWlnaHQ7cmV0dXJuIG4+YT8odD10PjA/MDp0LHQ9dDxhLW4/YS1uOnQpOnQ9TWF0aC5tYXgoMCxhLzItbi8yKSxvPnM/KGU9ZT4wPzA6ZSxlPWU8cy1vP3MtbzplKTplPU1hdGgubWF4KDAscy8yLW8vMikse3RvcDplLGxlZnQ6dH19LGQucHJvdG90eXBlLm9uWm9vbT1mdW5jdGlvbigpe3ZhciBlPXRoaXMsYT1lLmNvbnRlbnRTdGFydFBvcyxyPWEud2lkdGgsYz1hLmhlaWdodCxsPWEubGVmdCxkPWEudG9wLHU9cyhlLm5ld1BvaW50c1swXSxlLm5ld1BvaW50c1sxXSksZj11L2Uuc3RhcnREaXN0YW5jZUJldHdlZW5GaW5nZXJzLHA9TWF0aC5mbG9vcihyKmYpLGg9TWF0aC5mbG9vcihjKmYpLGc9KHItcCkqZS5wZXJjZW50YWdlT2ZJbWFnZUF0UGluY2hQb2ludFgsYj0oYy1oKSplLnBlcmNlbnRhZ2VPZkltYWdlQXRQaW5jaFBvaW50WSxtPShlLm5ld1BvaW50c1swXS54K2UubmV3UG9pbnRzWzFdLngpLzItbih0KS5zY3JvbGxMZWZ0KCksdj0oZS5uZXdQb2ludHNbMF0ueStlLm5ld1BvaW50c1sxXS55KS8yLW4odCkuc2Nyb2xsVG9wKCkseT1tLWUuY2VudGVyUG9pbnRTdGFydFgseD12LWUuY2VudGVyUG9pbnRTdGFydFksdz1sKyhnK3kpLCQ9ZCsoYit4KSxTPXt0b3A6JCxsZWZ0Oncsc2NhbGVYOmYsc2NhbGVZOmZ9O2UuY2FuVGFwPSExLGUubmV3V2lkdGg9cCxlLm5ld0hlaWdodD1oLGUuY29udGVudExhc3RQb3M9UyxlLnJlcXVlc3RJZCYmaShlLnJlcXVlc3RJZCksZS5yZXF1ZXN0SWQ9byhmdW5jdGlvbigpe24uZmFuY3lib3guc2V0VHJhbnNsYXRlKGUuJGNvbnRlbnQsZS5jb250ZW50TGFzdFBvcyl9KX0sZC5wcm90b3R5cGUub250b3VjaGVuZD1mdW5jdGlvbih0KXt2YXIgbz10aGlzLHM9by5pc1N3aXBpbmcscj1vLmlzUGFubmluZyxjPW8uaXNab29taW5nLGw9by5pc1Njcm9sbGluZztpZihvLmVuZFBvaW50cz1hKHQpLG8uZE1zPU1hdGgubWF4KChuZXcgRGF0ZSkuZ2V0VGltZSgpLW8uc3RhcnRUaW1lLDEpLG8uJGNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWlzLWdyYWJiaW5nXCIpLG4oZSkub2ZmKFwiLmZiLnRvdWNoXCIpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLG8ub25zY3JvbGwsITApLG8ucmVxdWVzdElkJiYoaShvLnJlcXVlc3RJZCksby5yZXF1ZXN0SWQ9bnVsbCksby5pc1N3aXBpbmc9ITEsby5pc1Bhbm5pbmc9ITEsby5pc1pvb21pbmc9ITEsby5pc1Njcm9sbGluZz0hMSxvLmluc3RhbmNlLmlzRHJhZ2dpbmc9ITEsby5jYW5UYXApcmV0dXJuIG8ub25UYXAodCk7by5zcGVlZD0xMDAsby52ZWxvY2l0eVg9by5kaXN0YW5jZVgvby5kTXMqLjUsby52ZWxvY2l0eVk9by5kaXN0YW5jZVkvby5kTXMqLjUscj9vLmVuZFBhbm5pbmcoKTpjP28uZW5kWm9vbWluZygpOm8uZW5kU3dpcGluZyhzLGwpfSxkLnByb3RvdHlwZS5lbmRTd2lwaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIG89dGhpcyxpPSExLGE9by5pbnN0YW5jZS5ncm91cC5sZW5ndGgscz1NYXRoLmFicyhvLmRpc3RhbmNlWCkscj1cInhcIj09dCYmYT4xJiYoby5kTXM+MTMwJiZzPjEwfHxzPjUwKTtvLnNsaWRlckxhc3RQb3M9bnVsbCxcInlcIj09dCYmIWUmJk1hdGguYWJzKG8uZGlzdGFuY2VZKT41MD8obi5mYW5jeWJveC5hbmltYXRlKG8uaW5zdGFuY2UuY3VycmVudC4kc2xpZGUse3RvcDpvLnNsaWRlclN0YXJ0UG9zLnRvcCtvLmRpc3RhbmNlWSsxNTAqby52ZWxvY2l0eVksb3BhY2l0eTowfSwyMDApLGk9by5pbnN0YW5jZS5jbG9zZSghMCwyNTApKTpyJiZvLmRpc3RhbmNlWD4wP2k9by5pbnN0YW5jZS5wcmV2aW91cygzMDApOnImJm8uZGlzdGFuY2VYPDAmJihpPW8uaW5zdGFuY2UubmV4dCgzMDApKSwhMSE9PWl8fFwieFwiIT10JiZcInlcIiE9dHx8by5pbnN0YW5jZS5jZW50ZXJTbGlkZSgyMDApLG8uJGNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWlzLXNsaWRpbmdcIil9LGQucHJvdG90eXBlLmVuZFBhbm5pbmc9ZnVuY3Rpb24oKXt2YXIgdCxlLG8saT10aGlzO2kuY29udGVudExhc3RQb3MmJighMT09PWkub3B0cy5tb21lbnR1bXx8aS5kTXM+MzUwPyh0PWkuY29udGVudExhc3RQb3MubGVmdCxlPWkuY29udGVudExhc3RQb3MudG9wKToodD1pLmNvbnRlbnRMYXN0UG9zLmxlZnQrNTAwKmkudmVsb2NpdHlYLGU9aS5jb250ZW50TGFzdFBvcy50b3ArNTAwKmkudmVsb2NpdHlZKSxvPWkubGltaXRQb3NpdGlvbih0LGUsaS5jb250ZW50U3RhcnRQb3Mud2lkdGgsaS5jb250ZW50U3RhcnRQb3MuaGVpZ2h0KSxvLndpZHRoPWkuY29udGVudFN0YXJ0UG9zLndpZHRoLG8uaGVpZ2h0PWkuY29udGVudFN0YXJ0UG9zLmhlaWdodCxuLmZhbmN5Ym94LmFuaW1hdGUoaS4kY29udGVudCxvLDM2NikpfSxkLnByb3RvdHlwZS5lbmRab29taW5nPWZ1bmN0aW9uKCl7dmFyIHQsZSxvLGksYT10aGlzLHM9YS5pbnN0YW5jZS5jdXJyZW50LHI9YS5uZXdXaWR0aCxjPWEubmV3SGVpZ2h0O2EuY29udGVudExhc3RQb3MmJih0PWEuY29udGVudExhc3RQb3MubGVmdCxlPWEuY29udGVudExhc3RQb3MudG9wLGk9e3RvcDplLGxlZnQ6dCx3aWR0aDpyLGhlaWdodDpjLHNjYWxlWDoxLHNjYWxlWToxfSxuLmZhbmN5Ym94LnNldFRyYW5zbGF0ZShhLiRjb250ZW50LGkpLHI8YS5jYW52YXNXaWR0aCYmYzxhLmNhbnZhc0hlaWdodD9hLmluc3RhbmNlLnNjYWxlVG9GaXQoMTUwKTpyPnMud2lkdGh8fGM+cy5oZWlnaHQ/YS5pbnN0YW5jZS5zY2FsZVRvQWN0dWFsKGEuY2VudGVyUG9pbnRTdGFydFgsYS5jZW50ZXJQb2ludFN0YXJ0WSwxNTApOihvPWEubGltaXRQb3NpdGlvbih0LGUscixjKSxuLmZhbmN5Ym94LmFuaW1hdGUoYS4kY29udGVudCxvLDE1MCkpKX0sZC5wcm90b3R5cGUub25UYXA9ZnVuY3Rpb24oZSl7dmFyIG8saT10aGlzLHM9bihlLnRhcmdldCkscj1pLmluc3RhbmNlLGM9ci5jdXJyZW50LGw9ZSYmYShlKXx8aS5zdGFydFBvaW50cyxkPWxbMF0/bFswXS54LW4odCkuc2Nyb2xsTGVmdCgpLWkuc3RhZ2VQb3MubGVmdDowLHU9bFswXT9sWzBdLnktbih0KS5zY3JvbGxUb3AoKS1pLnN0YWdlUG9zLnRvcDowLGY9ZnVuY3Rpb24odCl7dmFyIG89Yy5vcHRzW3RdO2lmKG4uaXNGdW5jdGlvbihvKSYmKG89by5hcHBseShyLFtjLGVdKSksbylzd2l0Y2gobyl7Y2FzZVwiY2xvc2VcIjpyLmNsb3NlKGkuc3RhcnRFdmVudCk7YnJlYWs7Y2FzZVwidG9nZ2xlQ29udHJvbHNcIjpyLnRvZ2dsZUNvbnRyb2xzKCk7YnJlYWs7Y2FzZVwibmV4dFwiOnIubmV4dCgpO2JyZWFrO2Nhc2VcIm5leHRPckNsb3NlXCI6ci5ncm91cC5sZW5ndGg+MT9yLm5leHQoKTpyLmNsb3NlKGkuc3RhcnRFdmVudCk7YnJlYWs7Y2FzZVwiem9vbVwiOlwiaW1hZ2VcIj09Yy50eXBlJiYoYy5pc0xvYWRlZHx8Yy4kZ2hvc3QpJiYoci5jYW5QYW4oKT9yLnNjYWxlVG9GaXQoKTpyLmlzU2NhbGVkRG93bigpP3Iuc2NhbGVUb0FjdHVhbChkLHUpOnIuZ3JvdXAubGVuZ3RoPDImJnIuY2xvc2UoaS5zdGFydEV2ZW50KSl9fTtpZigoIWUub3JpZ2luYWxFdmVudHx8MiE9ZS5vcmlnaW5hbEV2ZW50LmJ1dHRvbikmJihzLmlzKFwiaW1nXCIpfHwhKGQ+c1swXS5jbGllbnRXaWR0aCtzLm9mZnNldCgpLmxlZnQpKSl7aWYocy5pcyhcIi5mYW5jeWJveC1iZywuZmFuY3lib3gtaW5uZXIsLmZhbmN5Ym94LW91dGVyLC5mYW5jeWJveC1jb250YWluZXJcIikpbz1cIk91dHNpZGVcIjtlbHNlIGlmKHMuaXMoXCIuZmFuY3lib3gtc2xpZGVcIikpbz1cIlNsaWRlXCI7ZWxzZXtpZighci5jdXJyZW50LiRjb250ZW50fHwhci5jdXJyZW50LiRjb250ZW50LmZpbmQocykuYWRkQmFjaygpLmZpbHRlcihzKS5sZW5ndGgpcmV0dXJuO289XCJDb250ZW50XCJ9aWYoaS50YXBwZWQpe2lmKGNsZWFyVGltZW91dChpLnRhcHBlZCksaS50YXBwZWQ9bnVsbCxNYXRoLmFicyhkLWkudGFwWCk+NTB8fE1hdGguYWJzKHUtaS50YXBZKT41MClyZXR1cm4gdGhpcztmKFwiZGJsY2xpY2tcIitvKX1lbHNlIGkudGFwWD1kLGkudGFwWT11LGMub3B0c1tcImRibGNsaWNrXCIrb10mJmMub3B0c1tcImRibGNsaWNrXCIrb10hPT1jLm9wdHNbXCJjbGlja1wiK29dP2kudGFwcGVkPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtpLnRhcHBlZD1udWxsLHIuaXNBbmltYXRpbmd8fGYoXCJjbGlja1wiK28pfSw1MDApOmYoXCJjbGlja1wiK28pO3JldHVybiB0aGlzfX0sbihlKS5vbihcIm9uQWN0aXZhdGUuZmJcIixmdW5jdGlvbih0LGUpe2UmJiFlLkd1ZXN0dXJlcyYmKGUuR3Vlc3R1cmVzPW5ldyBkKGUpKX0pLm9uKFwiYmVmb3JlQ2xvc2UuZmJcIixmdW5jdGlvbih0LGUpe2UmJmUuR3Vlc3R1cmVzJiZlLkd1ZXN0dXJlcy5kZXN0cm95KCl9KX0od2luZG93LGRvY3VtZW50LGpRdWVyeSksZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjtlLmV4dGVuZCghMCxlLmZhbmN5Ym94LmRlZmF1bHRzLHtidG5UcGw6e3NsaWRlU2hvdzonPGJ1dHRvbiBkYXRhLWZhbmN5Ym94LXBsYXkgY2xhc3M9XCJmYW5jeWJveC1idXR0b24gZmFuY3lib3gtYnV0dG9uLS1wbGF5XCIgdGl0bGU9XCJ7e1BMQVlfU1RBUlR9fVwiPjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTYuNSA1LjR2MTMuMmwxMS02LjZ6XCIvPjwvc3ZnPjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTguMzMgNS43NWgyLjJ2MTIuNWgtMi4yVjUuNzV6bTUuMTUgMGgyLjJ2MTIuNWgtMi4yVjUuNzV6XCIvPjwvc3ZnPjwvYnV0dG9uPid9LHNsaWRlU2hvdzp7YXV0b1N0YXJ0OiExLHNwZWVkOjNlMyxwcm9ncmVzczohMH19KTt2YXIgbj1mdW5jdGlvbih0KXt0aGlzLmluc3RhbmNlPXQsdGhpcy5pbml0KCl9O2UuZXh0ZW5kKG4ucHJvdG90eXBlLHt0aW1lcjpudWxsLGlzQWN0aXZlOiExLCRidXR0b246bnVsbCxpbml0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxuPXQuaW5zdGFuY2Usbz1uLmdyb3VwW24uY3VyckluZGV4XS5vcHRzLnNsaWRlU2hvdzt0LiRidXR0b249bi4kcmVmcy50b29sYmFyLmZpbmQoXCJbZGF0YS1mYW5jeWJveC1wbGF5XVwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXt0LnRvZ2dsZSgpfSksbi5ncm91cC5sZW5ndGg8Mnx8IW8/dC4kYnV0dG9uLmhpZGUoKTpvLnByb2dyZXNzJiYodC4kcHJvZ3Jlc3M9ZSgnPGRpdiBjbGFzcz1cImZhbmN5Ym94LXByb2dyZXNzXCI+PC9kaXY+JykuYXBwZW5kVG8obi4kcmVmcy5pbm5lcikpfSxzZXQ6ZnVuY3Rpb24odCl7dmFyIG49dGhpcyxvPW4uaW5zdGFuY2UsaT1vLmN1cnJlbnQ7aSYmKCEwPT09dHx8aS5vcHRzLmxvb3B8fG8uY3VyckluZGV4PG8uZ3JvdXAubGVuZ3RoLTEpP24uaXNBY3RpdmUmJlwidmlkZW9cIiE9PWkuY29udGVudFR5cGUmJihuLiRwcm9ncmVzcyYmZS5mYW5jeWJveC5hbmltYXRlKG4uJHByb2dyZXNzLnNob3coKSx7c2NhbGVYOjF9LGkub3B0cy5zbGlkZVNob3cuc3BlZWQpLG4udGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe28uY3VycmVudC5vcHRzLmxvb3B8fG8uY3VycmVudC5pbmRleCE9by5ncm91cC5sZW5ndGgtMT9vLm5leHQoKTpvLmp1bXBUbygwKX0saS5vcHRzLnNsaWRlU2hvdy5zcGVlZCkpOihuLnN0b3AoKSxvLmlkbGVTZWNvbmRzQ291bnRlcj0wLG8uc2hvd0NvbnRyb2xzKCkpfSxjbGVhcjpmdW5jdGlvbigpe3ZhciB0PXRoaXM7Y2xlYXJUaW1lb3V0KHQudGltZXIpLHQudGltZXI9bnVsbCx0LiRwcm9ncmVzcyYmdC4kcHJvZ3Jlc3MucmVtb3ZlQXR0cihcInN0eWxlXCIpLmhpZGUoKX0sc3RhcnQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC5pbnN0YW5jZS5jdXJyZW50O2UmJih0LiRidXR0b24uYXR0cihcInRpdGxlXCIsKGUub3B0cy5pMThuW2Uub3B0cy5sYW5nXXx8ZS5vcHRzLmkxOG4uZW4pLlBMQVlfU1RPUCkucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1idXR0b24tLXBsYXlcIikuYWRkQ2xhc3MoXCJmYW5jeWJveC1idXR0b24tLXBhdXNlXCIpLHQuaXNBY3RpdmU9ITAsZS5pc0NvbXBsZXRlJiZ0LnNldCghMCksdC5pbnN0YW5jZS50cmlnZ2VyKFwib25TbGlkZVNob3dDaGFuZ2VcIiwhMCkpfSxzdG9wOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuaW5zdGFuY2UuY3VycmVudDt0LmNsZWFyKCksdC4kYnV0dG9uLmF0dHIoXCJ0aXRsZVwiLChlLm9wdHMuaTE4bltlLm9wdHMubGFuZ118fGUub3B0cy5pMThuLmVuKS5QTEFZX1NUQVJUKS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWJ1dHRvbi0tcGF1c2VcIikuYWRkQ2xhc3MoXCJmYW5jeWJveC1idXR0b24tLXBsYXlcIiksdC5pc0FjdGl2ZT0hMSx0Lmluc3RhbmNlLnRyaWdnZXIoXCJvblNsaWRlU2hvd0NoYW5nZVwiLCExKSx0LiRwcm9ncmVzcyYmdC4kcHJvZ3Jlc3MucmVtb3ZlQXR0cihcInN0eWxlXCIpLmhpZGUoKX0sdG9nZ2xlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0LmlzQWN0aXZlP3Quc3RvcCgpOnQuc3RhcnQoKX19KSxlKHQpLm9uKHtcIm9uSW5pdC5mYlwiOmZ1bmN0aW9uKHQsZSl7ZSYmIWUuU2xpZGVTaG93JiYoZS5TbGlkZVNob3c9bmV3IG4oZSkpfSxcImJlZm9yZVNob3cuZmJcIjpmdW5jdGlvbih0LGUsbixvKXt2YXIgaT1lJiZlLlNsaWRlU2hvdztvP2kmJm4ub3B0cy5zbGlkZVNob3cuYXV0b1N0YXJ0JiZpLnN0YXJ0KCk6aSYmaS5pc0FjdGl2ZSYmaS5jbGVhcigpfSxcImFmdGVyU2hvdy5mYlwiOmZ1bmN0aW9uKHQsZSxuKXt2YXIgbz1lJiZlLlNsaWRlU2hvdztvJiZvLmlzQWN0aXZlJiZvLnNldCgpfSxcImFmdGVyS2V5ZG93bi5mYlwiOmZ1bmN0aW9uKG4sbyxpLGEscyl7dmFyIHI9byYmby5TbGlkZVNob3c7IXJ8fCFpLm9wdHMuc2xpZGVTaG93fHw4MCE9PXMmJjMyIT09c3x8ZSh0LmFjdGl2ZUVsZW1lbnQpLmlzKFwiYnV0dG9uLGEsaW5wdXRcIil8fChhLnByZXZlbnREZWZhdWx0KCksci50b2dnbGUoKSl9LFwiYmVmb3JlQ2xvc2UuZmIgb25EZWFjdGl2YXRlLmZiXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj1lJiZlLlNsaWRlU2hvdztuJiZuLnN0b3AoKX19KSxlKHQpLm9uKFwidmlzaWJpbGl0eWNoYW5nZVwiLGZ1bmN0aW9uKCl7dmFyIG49ZS5mYW5jeWJveC5nZXRJbnN0YW5jZSgpLG89biYmbi5TbGlkZVNob3c7byYmby5pc0FjdGl2ZSYmKHQuaGlkZGVuP28uY2xlYXIoKTpvLnNldCgpKX0pfShkb2N1bWVudCxqUXVlcnkpLGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZnVuY3Rpb24oKXtmb3IodmFyIGU9W1tcInJlcXVlc3RGdWxsc2NyZWVuXCIsXCJleGl0RnVsbHNjcmVlblwiLFwiZnVsbHNjcmVlbkVsZW1lbnRcIixcImZ1bGxzY3JlZW5FbmFibGVkXCIsXCJmdWxsc2NyZWVuY2hhbmdlXCIsXCJmdWxsc2NyZWVuZXJyb3JcIl0sW1wid2Via2l0UmVxdWVzdEZ1bGxzY3JlZW5cIixcIndlYmtpdEV4aXRGdWxsc2NyZWVuXCIsXCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudFwiLFwid2Via2l0RnVsbHNjcmVlbkVuYWJsZWRcIixcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIixcIndlYmtpdGZ1bGxzY3JlZW5lcnJvclwiXSxbXCJ3ZWJraXRSZXF1ZXN0RnVsbFNjcmVlblwiLFwid2Via2l0Q2FuY2VsRnVsbFNjcmVlblwiLFwid2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50XCIsXCJ3ZWJraXRDYW5jZWxGdWxsU2NyZWVuXCIsXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsXCJ3ZWJraXRmdWxsc2NyZWVuZXJyb3JcIl0sW1wibW96UmVxdWVzdEZ1bGxTY3JlZW5cIixcIm1vekNhbmNlbEZ1bGxTY3JlZW5cIixcIm1vekZ1bGxTY3JlZW5FbGVtZW50XCIsXCJtb3pGdWxsU2NyZWVuRW5hYmxlZFwiLFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLFwibW96ZnVsbHNjcmVlbmVycm9yXCJdLFtcIm1zUmVxdWVzdEZ1bGxzY3JlZW5cIixcIm1zRXhpdEZ1bGxzY3JlZW5cIixcIm1zRnVsbHNjcmVlbkVsZW1lbnRcIixcIm1zRnVsbHNjcmVlbkVuYWJsZWRcIixcIk1TRnVsbHNjcmVlbkNoYW5nZVwiLFwiTVNGdWxsc2NyZWVuRXJyb3JcIl1dLG49e30sbz0wO288ZS5sZW5ndGg7bysrKXt2YXIgaT1lW29dO2lmKGkmJmlbMV1pbiB0KXtmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKyluW2VbMF1bYV1dPWlbYV07cmV0dXJuIG59fXJldHVybiExfSgpO2lmKG4pe3ZhciBvPXtyZXF1ZXN0OmZ1bmN0aW9uKGUpe2U9ZXx8dC5kb2N1bWVudEVsZW1lbnQsZVtuLnJlcXVlc3RGdWxsc2NyZWVuXShlLkFMTE9XX0tFWUJPQVJEX0lOUFVUKX0sZXhpdDpmdW5jdGlvbigpe3Rbbi5leGl0RnVsbHNjcmVlbl0oKX0sdG9nZ2xlOmZ1bmN0aW9uKGUpe2U9ZXx8dC5kb2N1bWVudEVsZW1lbnQsdGhpcy5pc0Z1bGxzY3JlZW4oKT90aGlzLmV4aXQoKTp0aGlzLnJlcXVlc3QoZSl9LGlzRnVsbHNjcmVlbjpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKHRbbi5mdWxsc2NyZWVuRWxlbWVudF0pfSxlbmFibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4odFtuLmZ1bGxzY3JlZW5FbmFibGVkXSl9fTtlLmV4dGVuZCghMCxlLmZhbmN5Ym94LmRlZmF1bHRzLHtidG5UcGw6e2Z1bGxTY3JlZW46JzxidXR0b24gZGF0YS1mYW5jeWJveC1mdWxsc2NyZWVuIGNsYXNzPVwiZmFuY3lib3gtYnV0dG9uIGZhbmN5Ym94LWJ1dHRvbi0tZnNlbnRlclwiIHRpdGxlPVwie3tGVUxMX1NDUkVFTn19XCI+PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNNyAxNEg1djVoNXYtMkg3di0zem0tMi00aDJWN2gzVjVINXY1em0xMiA3aC0zdjJoNXYtNWgtMnYzek0xNCA1djJoM3YzaDJWNWgtNXpcIi8+PC9zdmc+PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNNSAxNmgzdjNoMnYtNUg1em0zLThINXYyaDVWNUg4em02IDExaDJ2LTNoM3YtMmgtNXptMi0xMVY1aC0ydjVoNVY4elwiLz48L3N2Zz48L2J1dHRvbj4nfSxmdWxsU2NyZWVuOnthdXRvU3RhcnQ6ITF9fSksZSh0KS5vbihuLmZ1bGxzY3JlZW5jaGFuZ2UsZnVuY3Rpb24oKXt2YXIgdD1vLmlzRnVsbHNjcmVlbigpLG49ZS5mYW5jeWJveC5nZXRJbnN0YW5jZSgpO24mJihuLmN1cnJlbnQmJlwiaW1hZ2VcIj09PW4uY3VycmVudC50eXBlJiZuLmlzQW5pbWF0aW5nJiYobi5pc0FuaW1hdGluZz0hMSxuLnVwZGF0ZSghMCwhMCwwKSxuLmlzQ29tcGxldGV8fG4uY29tcGxldGUoKSksbi50cmlnZ2VyKFwib25GdWxsc2NyZWVuQ2hhbmdlXCIsdCksbi4kcmVmcy5jb250YWluZXIudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1pcy1mdWxsc2NyZWVuXCIsdCksbi4kcmVmcy50b29sYmFyLmZpbmQoXCJbZGF0YS1mYW5jeWJveC1mdWxsc2NyZWVuXVwiKS50b2dnbGVDbGFzcyhcImZhbmN5Ym94LWJ1dHRvbi0tZnNlbnRlclwiLCF0KS50b2dnbGVDbGFzcyhcImZhbmN5Ym94LWJ1dHRvbi0tZnNleGl0XCIsdCkpfSl9ZSh0KS5vbih7XCJvbkluaXQuZmJcIjpmdW5jdGlvbih0LGUpe3ZhciBpO2lmKCFuKXJldHVybiB2b2lkIGUuJHJlZnMudG9vbGJhci5maW5kKFwiW2RhdGEtZmFuY3lib3gtZnVsbHNjcmVlbl1cIikucmVtb3ZlKCk7ZSYmZS5ncm91cFtlLmN1cnJJbmRleF0ub3B0cy5mdWxsU2NyZWVuPyhpPWUuJHJlZnMuY29udGFpbmVyLGkub24oXCJjbGljay5mYi1mdWxsc2NyZWVuXCIsXCJbZGF0YS1mYW5jeWJveC1mdWxsc2NyZWVuXVwiLGZ1bmN0aW9uKHQpe3Quc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpLG8udG9nZ2xlKCl9KSxlLm9wdHMuZnVsbFNjcmVlbiYmITA9PT1lLm9wdHMuZnVsbFNjcmVlbi5hdXRvU3RhcnQmJm8ucmVxdWVzdCgpLGUuRnVsbFNjcmVlbj1vKTplJiZlLiRyZWZzLnRvb2xiYXIuZmluZChcIltkYXRhLWZhbmN5Ym94LWZ1bGxzY3JlZW5dXCIpLmhpZGUoKX0sXCJhZnRlcktleWRvd24uZmJcIjpmdW5jdGlvbih0LGUsbixvLGkpe2UmJmUuRnVsbFNjcmVlbiYmNzA9PT1pJiYoby5wcmV2ZW50RGVmYXVsdCgpLGUuRnVsbFNjcmVlbi50b2dnbGUoKSl9LFwiYmVmb3JlQ2xvc2UuZmJcIjpmdW5jdGlvbih0LGUpe2UmJmUuRnVsbFNjcmVlbiYmZS4kcmVmcy5jb250YWluZXIuaGFzQ2xhc3MoXCJmYW5jeWJveC1pcy1mdWxsc2NyZWVuXCIpJiZvLmV4aXQoKX19KX0oZG9jdW1lbnQsalF1ZXJ5KSxmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO3ZhciBuPVwiZmFuY3lib3gtdGh1bWJzXCI7ZS5mYW5jeWJveC5kZWZhdWx0cz1lLmV4dGVuZCghMCx7YnRuVHBsOnt0aHVtYnM6JzxidXR0b24gZGF0YS1mYW5jeWJveC10aHVtYnMgY2xhc3M9XCJmYW5jeWJveC1idXR0b24gZmFuY3lib3gtYnV0dG9uLS10aHVtYnNcIiB0aXRsZT1cInt7VEhVTUJTfX1cIj48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xNC41OSAxNC41OWgzLjc2djMuNzZoLTMuNzZ2LTMuNzZ6bS00LjQ3IDBoMy43NnYzLjc2aC0zLjc2di0zLjc2em0tNC40NyAwaDMuNzZ2My43Nkg1LjY1di0zLjc2em04Ljk0LTQuNDdoMy43NnYzLjc2aC0zLjc2di0zLjc2em0tNC40NyAwaDMuNzZ2My43NmgtMy43NnYtMy43NnptLTQuNDcgMGgzLjc2djMuNzZINS42NXYtMy43NnptOC45NC00LjQ3aDMuNzZ2My43NmgtMy43NlY1LjY1em0tNC40NyAwaDMuNzZ2My43NmgtMy43NlY1LjY1em0tNC40NyAwaDMuNzZ2My43Nkg1LjY1VjUuNjV6XCIvPjwvc3ZnPjwvYnV0dG9uPid9LHRodW1iczp7YXV0b1N0YXJ0OiExLGhpZGVPbkNsb3NlOiEwLHBhcmVudEVsOlwiLmZhbmN5Ym94LWNvbnRhaW5lclwiLGF4aXM6XCJ5XCJ9fSxlLmZhbmN5Ym94LmRlZmF1bHRzKTt2YXIgbz1mdW5jdGlvbih0KXt0aGlzLmluaXQodCl9O2UuZXh0ZW5kKG8ucHJvdG90eXBlLHskYnV0dG9uOm51bGwsJGdyaWQ6bnVsbCwkbGlzdDpudWxsLGlzVmlzaWJsZTohMSxpc0FjdGl2ZTohMSxpbml0OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj10Lmdyb3VwLG89MDtlLmluc3RhbmNlPXQsZS5vcHRzPW5bdC5jdXJySW5kZXhdLm9wdHMudGh1bWJzLHQuVGh1bWJzPWUsZS4kYnV0dG9uPXQuJHJlZnMudG9vbGJhci5maW5kKFwiW2RhdGEtZmFuY3lib3gtdGh1bWJzXVwiKTtmb3IodmFyIGk9MCxhPW4ubGVuZ3RoO2k8YSYmKG5baV0udGh1bWImJm8rKywhKG8+MSkpO2krKyk7bz4xJiZlLm9wdHM/KGUuJGJ1dHRvbi5yZW1vdmVBdHRyKFwic3R5bGVcIikub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7ZS50b2dnbGUoKX0pLGUuaXNBY3RpdmU9ITApOmUuJGJ1dHRvbi5oaWRlKCl9LGNyZWF0ZTpmdW5jdGlvbigpe3ZhciB0LG89dGhpcyxpPW8uaW5zdGFuY2UsYT1vLm9wdHMucGFyZW50RWwscz1bXTtvLiRncmlkfHwoby4kZ3JpZD1lKCc8ZGl2IGNsYXNzPVwiJytuK1wiIFwiK24rXCItXCIrby5vcHRzLmF4aXMrJ1wiPjwvZGl2PicpLmFwcGVuZFRvKGkuJHJlZnMuY29udGFpbmVyLmZpbmQoYSkuYWRkQmFjaygpLmZpbHRlcihhKSksby4kZ3JpZC5vbihcImNsaWNrXCIsXCJhXCIsZnVuY3Rpb24oKXtpLmp1bXBUbyhlKHRoaXMpLmF0dHIoXCJkYXRhLWluZGV4XCIpKX0pKSxvLiRsaXN0fHwoby4kbGlzdD1lKCc8ZGl2IGNsYXNzPVwiJytuKydfX2xpc3RcIj4nKS5hcHBlbmRUbyhvLiRncmlkKSksZS5lYWNoKGkuZ3JvdXAsZnVuY3Rpb24oZSxuKXt0PW4udGh1bWIsdHx8XCJpbWFnZVwiIT09bi50eXBlfHwodD1uLnNyYykscy5wdXNoKCc8YSBocmVmPVwiamF2YXNjcmlwdDo7XCIgdGFiaW5kZXg9XCIwXCIgZGF0YS1pbmRleD1cIicrZSsnXCInKyh0JiZ0Lmxlbmd0aD8nIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTp1cmwoJyt0KycpXCInOidjbGFzcz1cImZhbmN5Ym94LXRodW1icy1taXNzaW5nXCInKStcIj48L2E+XCIpfSksby4kbGlzdFswXS5pbm5lckhUTUw9cy5qb2luKFwiXCIpLFwieFwiPT09by5vcHRzLmF4aXMmJm8uJGxpc3Qud2lkdGgocGFyc2VJbnQoby4kZ3JpZC5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpLDEwKStpLmdyb3VwLmxlbmd0aCpvLiRsaXN0LmNoaWxkcmVuKCkuZXEoMCkub3V0ZXJXaWR0aCghMCkpfSxmb2N1czpmdW5jdGlvbih0KXt2YXIgZSxuLG89dGhpcyxpPW8uJGxpc3QsYT1vLiRncmlkO28uaW5zdGFuY2UuY3VycmVudCYmKGU9aS5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtdGh1bWJzLWFjdGl2ZVwiKS5maWx0ZXIoJ1tkYXRhLWluZGV4PVwiJytvLmluc3RhbmNlLmN1cnJlbnQuaW5kZXgrJ1wiXScpLmFkZENsYXNzKFwiZmFuY3lib3gtdGh1bWJzLWFjdGl2ZVwiKSxuPWUucG9zaXRpb24oKSxcInlcIj09PW8ub3B0cy5heGlzJiYobi50b3A8MHx8bi50b3A+aS5oZWlnaHQoKS1lLm91dGVySGVpZ2h0KCkpP2kuc3RvcCgpLmFuaW1hdGUoe3Njcm9sbFRvcDppLnNjcm9sbFRvcCgpK24udG9wfSx0KTpcInhcIj09PW8ub3B0cy5heGlzJiYobi5sZWZ0PGEuc2Nyb2xsTGVmdCgpfHxuLmxlZnQ+YS5zY3JvbGxMZWZ0KCkrKGEud2lkdGgoKS1lLm91dGVyV2lkdGgoKSkpJiZpLnBhcmVudCgpLnN0b3AoKS5hbmltYXRlKHtzY3JvbGxMZWZ0Om4ubGVmdH0sdCkpfSx1cGRhdGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3QuaW5zdGFuY2UuJHJlZnMuY29udGFpbmVyLnRvZ2dsZUNsYXNzKFwiZmFuY3lib3gtc2hvdy10aHVtYnNcIix0aGlzLmlzVmlzaWJsZSksdC5pc1Zpc2libGU/KHQuJGdyaWR8fHQuY3JlYXRlKCksdC5pbnN0YW5jZS50cmlnZ2VyKFwib25UaHVtYnNTaG93XCIpLHQuZm9jdXMoMCkpOnQuJGdyaWQmJnQuaW5zdGFuY2UudHJpZ2dlcihcIm9uVGh1bWJzSGlkZVwiKSx0Lmluc3RhbmNlLnVwZGF0ZSgpfSxoaWRlOmZ1bmN0aW9uKCl7dGhpcy5pc1Zpc2libGU9ITEsdGhpcy51cGRhdGUoKX0sc2hvdzpmdW5jdGlvbigpe3RoaXMuaXNWaXNpYmxlPSEwLHRoaXMudXBkYXRlKCl9LHRvZ2dsZTpmdW5jdGlvbigpe3RoaXMuaXNWaXNpYmxlPSF0aGlzLmlzVmlzaWJsZSx0aGlzLnVwZGF0ZSgpfX0pLGUodCkub24oe1wib25Jbml0LmZiXCI6ZnVuY3Rpb24odCxlKXt2YXIgbjtlJiYhZS5UaHVtYnMmJihuPW5ldyBvKGUpLG4uaXNBY3RpdmUmJiEwPT09bi5vcHRzLmF1dG9TdGFydCYmbi5zaG93KCkpfSxcImJlZm9yZVNob3cuZmJcIjpmdW5jdGlvbih0LGUsbixvKXt2YXIgaT1lJiZlLlRodW1icztpJiZpLmlzVmlzaWJsZSYmaS5mb2N1cyhvPzA6MjUwKX0sXCJhZnRlcktleWRvd24uZmJcIjpmdW5jdGlvbih0LGUsbixvLGkpe3ZhciBhPWUmJmUuVGh1bWJzO2EmJmEuaXNBY3RpdmUmJjcxPT09aSYmKG8ucHJldmVudERlZmF1bHQoKSxhLnRvZ2dsZSgpKX0sXCJiZWZvcmVDbG9zZS5mYlwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZSYmZS5UaHVtYnM7biYmbi5pc1Zpc2libGUmJiExIT09bi5vcHRzLmhpZGVPbkNsb3NlJiZuLiRncmlkLmhpZGUoKX19KX0oZG9jdW1lbnQsalF1ZXJ5KSxmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4odCl7dmFyIGU9e1wiJlwiOlwiJmFtcDtcIixcIjxcIjpcIiZsdDtcIixcIj5cIjpcIiZndDtcIiwnXCInOlwiJnF1b3Q7XCIsXCInXCI6XCImIzM5O1wiLFwiL1wiOlwiJiN4MkY7XCIsXCJgXCI6XCImI3g2MDtcIixcIj1cIjpcIiYjeDNEO1wifTtyZXR1cm4gU3RyaW5nKHQpLnJlcGxhY2UoL1smPD5cIidgPVxcL10vZyxmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0pfWUuZXh0ZW5kKCEwLGUuZmFuY3lib3guZGVmYXVsdHMse2J0blRwbDp7c2hhcmU6JzxidXR0b24gZGF0YS1mYW5jeWJveC1zaGFyZSBjbGFzcz1cImZhbmN5Ym94LWJ1dHRvbiBmYW5jeWJveC1idXR0b24tLXNoYXJlXCIgdGl0bGU9XCJ7e1NIQVJFfX1cIj48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0yLjU1IDE5YzEuNC04LjQgOS4xLTkuOCAxMS45LTkuOFY1bDcgNy03IDYuM3YtMy41Yy0yLjggMC0xMC41IDIuMS0xMS45IDQuMnpcIi8+PC9zdmc+PC9idXR0b24+J30sc2hhcmU6e3VybDpmdW5jdGlvbih0LGUpe3JldHVybiF0LmN1cnJlbnRIYXNoJiZcImlubGluZVwiIT09ZS50eXBlJiZcImh0bWxcIiE9PWUudHlwZSYmKGUub3JpZ1NyY3x8ZS5zcmMpfHx3aW5kb3cubG9jYXRpb259LFxudHBsOic8ZGl2IGNsYXNzPVwiZmFuY3lib3gtc2hhcmVcIj48aDE+e3tTSEFSRX19PC9oMT48cD48YSBjbGFzcz1cImZhbmN5Ym94LXNoYXJlX19idXR0b24gZmFuY3lib3gtc2hhcmVfX2J1dHRvbi0tZmJcIiBocmVmPVwiaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3NoYXJlci9zaGFyZXIucGhwP3U9e3t1cmx9fVwiPjxzdmcgdmlld0JveD1cIjAgMCA1MTIgNTEyXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJtMjg3IDQ1NnYtMjk5YzAtMjEgNi0zNSAzNS0zNWgzOHYtNjNjLTctMS0yOS0zLTU1LTMtNTQgMC05MSAzMy05MSA5NHYzMDZtMTQzLTI1NGgtMjA1djcyaDE5NlwiIC8+PC9zdmc+PHNwYW4+RmFjZWJvb2s8L3NwYW4+PC9hPjxhIGNsYXNzPVwiZmFuY3lib3gtc2hhcmVfX2J1dHRvbiBmYW5jeWJveC1zaGFyZV9fYnV0dG9uLS10d1wiIGhyZWY9XCJodHRwczovL3R3aXR0ZXIuY29tL2ludGVudC90d2VldD91cmw9e3t1cmx9fSZ0ZXh0PXt7ZGVzY3J9fVwiPjxzdmcgdmlld0JveD1cIjAgMCA1MTIgNTEyXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJtNDU2IDEzM2MtMTQgNy0zMSAxMS00NyAxMyAxNy0xMCAzMC0yNyAzNy00Ni0xNSAxMC0zNCAxNi01MiAyMC02MS02Mi0xNTctNy0xNDEgNzUtNjgtMy0xMjktMzUtMTY5LTg1LTIyIDM3LTExIDg2IDI2IDEwOS0xMyAwLTI2LTQtMzctOSAwIDM5IDI4IDcyIDY1IDgwLTEyIDMtMjUgNC0zNyAyIDEwIDMzIDQxIDU3IDc3IDU3LTQyIDMwLTc3IDM4LTEyMiAzNCAxNzAgMTExIDM3OC0zMiAzNTktMjA4IDE2LTExIDMwLTI1IDQxLTQyelwiIC8+PC9zdmc+PHNwYW4+VHdpdHRlcjwvc3Bhbj48L2E+PGEgY2xhc3M9XCJmYW5jeWJveC1zaGFyZV9fYnV0dG9uIGZhbmN5Ym94LXNoYXJlX19idXR0b24tLXB0XCIgaHJlZj1cImh0dHBzOi8vd3d3LnBpbnRlcmVzdC5jb20vcGluL2NyZWF0ZS9idXR0b24vP3VybD17e3VybH19JmRlc2NyaXB0aW9uPXt7ZGVzY3J9fSZtZWRpYT17e21lZGlhfX1cIj48c3ZnIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwibTI2NSA1NmMtMTA5IDAtMTY0IDc4LTE2NCAxNDQgMCAzOSAxNSA3NCA0NyA4NyA1IDIgMTAgMCAxMi01bDQtMTljMi02IDEtOC0zLTEzLTktMTEtMTUtMjUtMTUtNDUgMC01OCA0My0xMTAgMTEzLTExMCA2MiAwIDk2IDM4IDk2IDg4IDAgNjctMzAgMTIyLTczIDEyMi0yNCAwLTQyLTE5LTM2LTQ0IDYtMjkgMjAtNjAgMjAtODEgMC0xOS0xMC0zNS0zMS0zNS0yNSAwLTQ0IDI2LTQ0IDYwIDAgMjEgNyAzNiA3IDM2bC0zMCAxMjVjLTggMzctMSA4MyAwIDg3IDAgMyA0IDQgNSAyIDItMyAzMi0zOSA0Mi03NWwxNi02NGM4IDE2IDMxIDI5IDU2IDI5IDc0IDAgMTI0LTY3IDEyNC0xNTcgMC02OS01OC0xMzItMTQ2LTEzMnpcIiBmaWxsPVwiI2ZmZlwiLz48L3N2Zz48c3Bhbj5QaW50ZXJlc3Q8L3NwYW4+PC9hPjwvcD48cD48aW5wdXQgY2xhc3M9XCJmYW5jeWJveC1zaGFyZV9faW5wdXRcIiB0eXBlPVwidGV4dFwiIHZhbHVlPVwie3t1cmxfcmF3fX1cIiBvbmNsaWNrPVwic2VsZWN0KClcIiAvPjwvcD48L2Rpdj4nfX0pLGUodCkub24oXCJjbGlja1wiLFwiW2RhdGEtZmFuY3lib3gtc2hhcmVdXCIsZnVuY3Rpb24oKXt2YXIgdCxvLGk9ZS5mYW5jeWJveC5nZXRJbnN0YW5jZSgpLGE9aS5jdXJyZW50fHxudWxsO2EmJihcImZ1bmN0aW9uXCI9PT1lLnR5cGUoYS5vcHRzLnNoYXJlLnVybCkmJih0PWEub3B0cy5zaGFyZS51cmwuYXBwbHkoYSxbaSxhXSkpLG89YS5vcHRzLnNoYXJlLnRwbC5yZXBsYWNlKC9cXHtcXHttZWRpYVxcfVxcfS9nLFwiaW1hZ2VcIj09PWEudHlwZT9lbmNvZGVVUklDb21wb25lbnQoYS5zcmMpOlwiXCIpLnJlcGxhY2UoL1xce1xce3VybFxcfVxcfS9nLGVuY29kZVVSSUNvbXBvbmVudCh0KSkucmVwbGFjZSgvXFx7XFx7dXJsX3Jhd1xcfVxcfS9nLG4odCkpLnJlcGxhY2UoL1xce1xce2Rlc2NyXFx9XFx9L2csaS4kY2FwdGlvbj9lbmNvZGVVUklDb21wb25lbnQoaS4kY2FwdGlvbi50ZXh0KCkpOlwiXCIpLGUuZmFuY3lib3gub3Blbih7c3JjOmkudHJhbnNsYXRlKGksbyksdHlwZTpcImh0bWxcIixvcHRzOnt0b3VjaDohMSxhbmltYXRpb25FZmZlY3Q6ITEsYWZ0ZXJMb2FkOmZ1bmN0aW9uKHQsZSl7aS4kcmVmcy5jb250YWluZXIub25lKFwiYmVmb3JlQ2xvc2UuZmJcIixmdW5jdGlvbigpe3QuY2xvc2UobnVsbCwwKX0pLGUuJGNvbnRlbnQuZmluZChcIi5mYW5jeWJveC1zaGFyZV9fYnV0dG9uXCIpLmNsaWNrKGZ1bmN0aW9uKCl7cmV0dXJuIHdpbmRvdy5vcGVuKHRoaXMuaHJlZixcIlNoYXJlXCIsXCJ3aWR0aD01NTAsIGhlaWdodD00NTBcIiksITF9KX0sbW9iaWxlOnthdXRvRm9jdXM6ITF9fX0pKX0pfShkb2N1bWVudCxqUXVlcnkpLGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKCl7dmFyIGU9dC5sb2NhdGlvbi5oYXNoLnN1YnN0cigxKSxuPWUuc3BsaXQoXCItXCIpLG89bi5sZW5ndGg+MSYmL15cXCs/XFxkKyQvLnRlc3QobltuLmxlbmd0aC0xXSk/cGFyc2VJbnQobi5wb3AoLTEpLDEwKXx8MToxLGk9bi5qb2luKFwiLVwiKTtyZXR1cm57aGFzaDplLGluZGV4Om88MT8xOm8sZ2FsbGVyeTppfX1mdW5jdGlvbiBpKHQpe1wiXCIhPT10LmdhbGxlcnkmJm4oXCJbZGF0YS1mYW5jeWJveD0nXCIrbi5lc2NhcGVTZWxlY3Rvcih0LmdhbGxlcnkpK1wiJ11cIikuZXEodC5pbmRleC0xKS5mb2N1cygpLnRyaWdnZXIoXCJjbGljay5mYi1zdGFydFwiKX1mdW5jdGlvbiBhKHQpe3ZhciBlLG47cmV0dXJuISF0JiYoZT10LmN1cnJlbnQ/dC5jdXJyZW50Lm9wdHM6dC5vcHRzLFwiXCIhPT0obj1lLmhhc2h8fChlLiRvcmlnP2UuJG9yaWcuZGF0YShcImZhbmN5Ym94XCIpfHxlLiRvcmlnLmRhdGEoXCJmYW5jeWJveC10cmlnZ2VyXCIpOlwiXCIpKSYmbil9bi5lc2NhcGVTZWxlY3Rvcnx8KG4uZXNjYXBlU2VsZWN0b3I9ZnVuY3Rpb24odCl7cmV0dXJuKHQrXCJcIikucmVwbGFjZSgvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXHg4MC1cXHVGRkZGXFx3LV0vZyxmdW5jdGlvbih0LGUpe3JldHVybiBlP1wiXFwwXCI9PT10P1wi77+9XCI6dC5zbGljZSgwLC0xKStcIlxcXFxcIit0LmNoYXJDb2RlQXQodC5sZW5ndGgtMSkudG9TdHJpbmcoMTYpK1wiIFwiOlwiXFxcXFwiK3R9KX0pLG4oZnVuY3Rpb24oKXshMSE9PW4uZmFuY3lib3guZGVmYXVsdHMuaGFzaCYmKG4oZSkub24oe1wib25Jbml0LmZiXCI6ZnVuY3Rpb24odCxlKXt2YXIgbixpOyExIT09ZS5ncm91cFtlLmN1cnJJbmRleF0ub3B0cy5oYXNoJiYobj1vKCksKGk9YShlKSkmJm4uZ2FsbGVyeSYmaT09bi5nYWxsZXJ5JiYoZS5jdXJySW5kZXg9bi5pbmRleC0xKSl9LFwiYmVmb3JlU2hvdy5mYlwiOmZ1bmN0aW9uKG4sbyxpLHMpe3ZhciByO2kmJiExIT09aS5vcHRzLmhhc2gmJihyPWEobykpJiYoby5jdXJyZW50SGFzaD1yKyhvLmdyb3VwLmxlbmd0aD4xP1wiLVwiKyhpLmluZGV4KzEpOlwiXCIpLHQubG9jYXRpb24uaGFzaCE9PVwiI1wiK28uY3VycmVudEhhc2gmJihzJiYhby5vcmlnSGFzaCYmKG8ub3JpZ0hhc2g9dC5sb2NhdGlvbi5oYXNoKSxvLmhhc2hUaW1lciYmY2xlYXJUaW1lb3V0KG8uaGFzaFRpbWVyKSxvLmhhc2hUaW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XCJyZXBsYWNlU3RhdGVcImluIHQuaGlzdG9yeT8odC5oaXN0b3J5W3M/XCJwdXNoU3RhdGVcIjpcInJlcGxhY2VTdGF0ZVwiXSh7fSxlLnRpdGxlLHQubG9jYXRpb24ucGF0aG5hbWUrdC5sb2NhdGlvbi5zZWFyY2grXCIjXCIrby5jdXJyZW50SGFzaCkscyYmKG8uaGFzQ3JlYXRlZEhpc3Rvcnk9ITApKTp0LmxvY2F0aW9uLmhhc2g9by5jdXJyZW50SGFzaCxvLmhhc2hUaW1lcj1udWxsfSwzMDApKSl9LFwiYmVmb3JlQ2xvc2UuZmJcIjpmdW5jdGlvbihuLG8saSl7aSYmITEhPT1pLm9wdHMuaGFzaCYmKGNsZWFyVGltZW91dChvLmhhc2hUaW1lciksby5jdXJyZW50SGFzaCYmby5oYXNDcmVhdGVkSGlzdG9yeT90Lmhpc3RvcnkuYmFjaygpOm8uY3VycmVudEhhc2gmJihcInJlcGxhY2VTdGF0ZVwiaW4gdC5oaXN0b3J5P3QuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sZS50aXRsZSx0LmxvY2F0aW9uLnBhdGhuYW1lK3QubG9jYXRpb24uc2VhcmNoKyhvLm9yaWdIYXNofHxcIlwiKSk6dC5sb2NhdGlvbi5oYXNoPW8ub3JpZ0hhc2gpLG8uY3VycmVudEhhc2g9bnVsbCl9fSksbih0KS5vbihcImhhc2hjaGFuZ2UuZmJcIixmdW5jdGlvbigpe3ZhciB0PW8oKSxlPW51bGw7bi5lYWNoKG4oXCIuZmFuY3lib3gtY29udGFpbmVyXCIpLmdldCgpLnJldmVyc2UoKSxmdW5jdGlvbih0LG8pe3ZhciBpPW4obykuZGF0YShcIkZhbmN5Qm94XCIpO2lmKGkmJmkuY3VycmVudEhhc2gpcmV0dXJuIGU9aSwhMX0pLGU/ZS5jdXJyZW50SGFzaD09PXQuZ2FsbGVyeStcIi1cIit0LmluZGV4fHwxPT09dC5pbmRleCYmZS5jdXJyZW50SGFzaD09dC5nYWxsZXJ5fHwoZS5jdXJyZW50SGFzaD1udWxsLGUuY2xvc2UoKSk6XCJcIiE9PXQuZ2FsbGVyeSYmaSh0KX0pLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtuLmZhbmN5Ym94LmdldEluc3RhbmNlKCl8fGkobygpKX0sNTApKX0pfSh3aW5kb3csZG9jdW1lbnQsalF1ZXJ5KSxmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO3ZhciBuPShuZXcgRGF0ZSkuZ2V0VGltZSgpO2UodCkub24oe1wib25Jbml0LmZiXCI6ZnVuY3Rpb24odCxlLG8pe2UuJHJlZnMuc3RhZ2Uub24oXCJtb3VzZXdoZWVsIERPTU1vdXNlU2Nyb2xsIHdoZWVsIE1vek1vdXNlUGl4ZWxTY3JvbGxcIixmdW5jdGlvbih0KXt2YXIgbz1lLmN1cnJlbnQsaT0obmV3IERhdGUpLmdldFRpbWUoKTtlLmdyb3VwLmxlbmd0aDwyfHwhMT09PW8ub3B0cy53aGVlbHx8XCJhdXRvXCI9PT1vLm9wdHMud2hlZWwmJlwiaW1hZ2VcIiE9PW8udHlwZXx8KHQucHJldmVudERlZmF1bHQoKSx0LnN0b3BQcm9wYWdhdGlvbigpLG8uJHNsaWRlLmhhc0NsYXNzKFwiZmFuY3lib3gtYW5pbWF0ZWRcIil8fCh0PXQub3JpZ2luYWxFdmVudHx8dCxpLW48MjUwfHwobj1pLGVbKC10LmRlbHRhWXx8LXQuZGVsdGFYfHx0LndoZWVsRGVsdGF8fC10LmRldGFpbCk8MD9cIm5leHRcIjpcInByZXZpb3VzXCJdKCkpKSl9KX19KX0oZG9jdW1lbnQsalF1ZXJ5KTsiLCIvKlxuICogSW50ZXJuYXRpb25hbCBUZWxlcGhvbmUgSW5wdXQgdjE4LjIuMVxuICogaHR0cHM6Ly9naXRodWIuY29tL2phY2tvY25yL2ludGwtdGVsLWlucHV0LmdpdFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuIWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEsYixjKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBkKGEsYil7aWYoIShhIGluc3RhbmNlb2YgYikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBlKGEsYil7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWJbY107ZC5lbnVtZXJhYmxlPWQuZW51bWVyYWJsZXx8ITEsZC5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZCYmKGQud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGQua2V5LGQpfX1mdW5jdGlvbiBmKGEsYixjKXtyZXR1cm4gYiYmZShhLnByb3RvdHlwZSxiKSxjJiZlKGEsYyksYX1mb3IodmFyIGc9W1tcIkFmZ2hhbmlzdGFuICjigKvYp9mB2LrYp9mG2LPYqtin2YbigKzigI4pXCIsXCJhZlwiLFwiOTNcIl0sW1wiQWxiYW5pYSAoU2hxaXDDq3JpKVwiLFwiYWxcIixcIjM1NVwiXSxbXCJBbGdlcmlhICjigKvYp9mE2KzYstin2KbYseKArOKAjilcIixcImR6XCIsXCIyMTNcIl0sW1wiQW1lcmljYW4gU2Ftb2FcIixcImFzXCIsXCIxXCIsNSxbXCI2ODRcIl1dLFtcIkFuZG9ycmFcIixcImFkXCIsXCIzNzZcIl0sW1wiQW5nb2xhXCIsXCJhb1wiLFwiMjQ0XCJdLFtcIkFuZ3VpbGxhXCIsXCJhaVwiLFwiMVwiLDYsW1wiMjY0XCJdXSxbXCJBbnRpZ3VhIGFuZCBCYXJidWRhXCIsXCJhZ1wiLFwiMVwiLDcsW1wiMjY4XCJdXSxbXCJBcmdlbnRpbmFcIixcImFyXCIsXCI1NFwiXSxbXCJBcm1lbmlhICjVgNWh1bXVodW91b/VodW2KVwiLFwiYW1cIixcIjM3NFwiXSxbXCJBcnViYVwiLFwiYXdcIixcIjI5N1wiXSxbXCJBdXN0cmFsaWFcIixcImF1XCIsXCI2MVwiLDBdLFtcIkF1c3RyaWEgKMOWc3RlcnJlaWNoKVwiLFwiYXRcIixcIjQzXCJdLFtcIkF6ZXJiYWlqYW4gKEF6yZlyYmF5Y2FuKVwiLFwiYXpcIixcIjk5NFwiXSxbXCJCYWhhbWFzXCIsXCJic1wiLFwiMVwiLDgsW1wiMjQyXCJdXSxbXCJCYWhyYWluICjigKvYp9mE2KjYrdix2YrZhuKArOKAjilcIixcImJoXCIsXCI5NzNcIl0sW1wiQmFuZ2xhZGVzaCAo4Kas4Ka+4KaC4Kay4Ka+4Kam4KeH4Ka2KVwiLFwiYmRcIixcIjg4MFwiXSxbXCJCYXJiYWRvc1wiLFwiYmJcIixcIjFcIiw5LFtcIjI0NlwiXV0sW1wiQmVsYXJ1cyAo0JHQtdC70LDRgNGD0YHRjClcIixcImJ5XCIsXCIzNzVcIl0sW1wiQmVsZ2l1bSAoQmVsZ2nDqylcIixcImJlXCIsXCIzMlwiXSxbXCJCZWxpemVcIixcImJ6XCIsXCI1MDFcIl0sW1wiQmVuaW4gKELDqW5pbilcIixcImJqXCIsXCIyMjlcIl0sW1wiQmVybXVkYVwiLFwiYm1cIixcIjFcIiwxMCxbXCI0NDFcIl1dLFtcIkJodXRhbiAo4L2g4L2W4L6y4L204L2CKVwiLFwiYnRcIixcIjk3NVwiXSxbXCJCb2xpdmlhXCIsXCJib1wiLFwiNTkxXCJdLFtcIkJvc25pYSBhbmQgSGVyemVnb3ZpbmEgKNCR0L7RgdC90LAg0Lgg0KXQtdGA0YbQtdCz0L7QstC40L3QsClcIixcImJhXCIsXCIzODdcIl0sW1wiQm90c3dhbmFcIixcImJ3XCIsXCIyNjdcIl0sW1wiQnJhemlsIChCcmFzaWwpXCIsXCJiclwiLFwiNTVcIl0sW1wiQnJpdGlzaCBJbmRpYW4gT2NlYW4gVGVycml0b3J5XCIsXCJpb1wiLFwiMjQ2XCJdLFtcIkJyaXRpc2ggVmlyZ2luIElzbGFuZHNcIixcInZnXCIsXCIxXCIsMTEsW1wiMjg0XCJdXSxbXCJCcnVuZWlcIixcImJuXCIsXCI2NzNcIl0sW1wiQnVsZ2FyaWEgKNCR0YrQu9Cz0LDRgNC40Y8pXCIsXCJiZ1wiLFwiMzU5XCJdLFtcIkJ1cmtpbmEgRmFzb1wiLFwiYmZcIixcIjIyNlwiXSxbXCJCdXJ1bmRpIChVYnVydW5kaSlcIixcImJpXCIsXCIyNTdcIl0sW1wiQ2FtYm9kaWEgKOGegOGemOGfkuGeluGeu+Geh+GetilcIixcImtoXCIsXCI4NTVcIl0sW1wiQ2FtZXJvb24gKENhbWVyb3VuKVwiLFwiY21cIixcIjIzN1wiXSxbXCJDYW5hZGFcIixcImNhXCIsXCIxXCIsMSxbXCIyMDRcIixcIjIyNlwiLFwiMjM2XCIsXCIyNDlcIixcIjI1MFwiLFwiMjg5XCIsXCIzMDZcIixcIjM0M1wiLFwiMzY1XCIsXCIzODdcIixcIjQwM1wiLFwiNDE2XCIsXCI0MThcIixcIjQzMVwiLFwiNDM3XCIsXCI0MzhcIixcIjQ1MFwiLFwiNTA2XCIsXCI1MTRcIixcIjUxOVwiLFwiNTQ4XCIsXCI1NzlcIixcIjU4MVwiLFwiNTg3XCIsXCI2MDRcIixcIjYxM1wiLFwiNjM5XCIsXCI2NDdcIixcIjY3MlwiLFwiNzA1XCIsXCI3MDlcIixcIjc0MlwiLFwiNzc4XCIsXCI3ODBcIixcIjc4MlwiLFwiODA3XCIsXCI4MTlcIixcIjgyNVwiLFwiODY3XCIsXCI4NzNcIixcIjkwMlwiLFwiOTA1XCJdXSxbXCJDYXBlIFZlcmRlIChLYWJ1IFZlcmRpKVwiLFwiY3ZcIixcIjIzOFwiXSxbXCJDYXJpYmJlYW4gTmV0aGVybGFuZHNcIixcImJxXCIsXCI1OTlcIiwxLFtcIjNcIixcIjRcIixcIjdcIl1dLFtcIkNheW1hbiBJc2xhbmRzXCIsXCJreVwiLFwiMVwiLDEyLFtcIjM0NVwiXV0sW1wiQ2VudHJhbCBBZnJpY2FuIFJlcHVibGljIChSw6lwdWJsaXF1ZSBjZW50cmFmcmljYWluZSlcIixcImNmXCIsXCIyMzZcIl0sW1wiQ2hhZCAoVGNoYWQpXCIsXCJ0ZFwiLFwiMjM1XCJdLFtcIkNoaWxlXCIsXCJjbFwiLFwiNTZcIl0sW1wiQ2hpbmEgKOS4reWbvSlcIixcImNuXCIsXCI4NlwiXSxbXCJDaHJpc3RtYXMgSXNsYW5kXCIsXCJjeFwiLFwiNjFcIiwyXSxbXCJDb2NvcyAoS2VlbGluZykgSXNsYW5kc1wiLFwiY2NcIixcIjYxXCIsMV0sW1wiQ29sb21iaWFcIixcImNvXCIsXCI1N1wiXSxbXCJDb21vcm9zICjigKvYrNiy2LEg2KfZhNmC2YXYseKArOKAjilcIixcImttXCIsXCIyNjlcIl0sW1wiQ29uZ28gKERSQykgKEphbWh1cmkgeWEgS2lkZW1va3Jhc2lhIHlhIEtvbmdvKVwiLFwiY2RcIixcIjI0M1wiXSxbXCJDb25nbyAoUmVwdWJsaWMpIChDb25nby1CcmF6emF2aWxsZSlcIixcImNnXCIsXCIyNDJcIl0sW1wiQ29vayBJc2xhbmRzXCIsXCJja1wiLFwiNjgyXCJdLFtcIkNvc3RhIFJpY2FcIixcImNyXCIsXCI1MDZcIl0sW1wiQ8O0dGUgZOKAmUl2b2lyZVwiLFwiY2lcIixcIjIyNVwiXSxbXCJDcm9hdGlhIChIcnZhdHNrYSlcIixcImhyXCIsXCIzODVcIl0sW1wiQ3ViYVwiLFwiY3VcIixcIjUzXCJdLFtcIkN1cmHDp2FvXCIsXCJjd1wiLFwiNTk5XCIsMF0sW1wiQ3lwcnVzICjOms+Nz4DPgc6/z4IpXCIsXCJjeVwiLFwiMzU3XCJdLFtcIkN6ZWNoIFJlcHVibGljICjEjGVza8OhIHJlcHVibGlrYSlcIixcImN6XCIsXCI0MjBcIl0sW1wiRGVubWFyayAoRGFubWFyaylcIixcImRrXCIsXCI0NVwiXSxbXCJEamlib3V0aVwiLFwiZGpcIixcIjI1M1wiXSxbXCJEb21pbmljYVwiLFwiZG1cIixcIjFcIiwxMyxbXCI3NjdcIl1dLFtcIkRvbWluaWNhbiBSZXB1YmxpYyAoUmVww7pibGljYSBEb21pbmljYW5hKVwiLFwiZG9cIixcIjFcIiwyLFtcIjgwOVwiLFwiODI5XCIsXCI4NDlcIl1dLFtcIkVjdWFkb3JcIixcImVjXCIsXCI1OTNcIl0sW1wiRWd5cHQgKOKAq9mF2LXYseKArOKAjilcIixcImVnXCIsXCIyMFwiXSxbXCJFbCBTYWx2YWRvclwiLFwic3ZcIixcIjUwM1wiXSxbXCJFcXVhdG9yaWFsIEd1aW5lYSAoR3VpbmVhIEVjdWF0b3JpYWwpXCIsXCJncVwiLFwiMjQwXCJdLFtcIkVyaXRyZWFcIixcImVyXCIsXCIyOTFcIl0sW1wiRXN0b25pYSAoRWVzdGkpXCIsXCJlZVwiLFwiMzcyXCJdLFtcIkV0aGlvcGlhXCIsXCJldFwiLFwiMjUxXCJdLFtcIkZhbGtsYW5kIElzbGFuZHMgKElzbGFzIE1hbHZpbmFzKVwiLFwiZmtcIixcIjUwMFwiXSxbXCJGYXJvZSBJc2xhbmRzIChGw7hyb3lhcilcIixcImZvXCIsXCIyOThcIl0sW1wiRmlqaVwiLFwiZmpcIixcIjY3OVwiXSxbXCJGaW5sYW5kIChTdW9taSlcIixcImZpXCIsXCIzNThcIiwwXSxbXCJGcmFuY2VcIixcImZyXCIsXCIzM1wiXSxbXCJGcmVuY2ggR3VpYW5hIChHdXlhbmUgZnJhbsOnYWlzZSlcIixcImdmXCIsXCI1OTRcIl0sW1wiRnJlbmNoIFBvbHluZXNpYSAoUG9seW7DqXNpZSBmcmFuw6dhaXNlKVwiLFwicGZcIixcIjY4OVwiXSxbXCJHYWJvblwiLFwiZ2FcIixcIjI0MVwiXSxbXCJHYW1iaWFcIixcImdtXCIsXCIyMjBcIl0sW1wiR2VvcmdpYSAo4YOh4YOQ4YOl4YOQ4YOg4YOX4YOV4YOU4YOa4YOdKVwiLFwiZ2VcIixcIjk5NVwiXSxbXCJHZXJtYW55IChEZXV0c2NobGFuZClcIixcImRlXCIsXCI0OVwiXSxbXCJHaGFuYSAoR2FhbmEpXCIsXCJnaFwiLFwiMjMzXCJdLFtcIkdpYnJhbHRhclwiLFwiZ2lcIixcIjM1MFwiXSxbXCJHcmVlY2UgKM6VzrvOu86szrTOsSlcIixcImdyXCIsXCIzMFwiXSxbXCJHcmVlbmxhbmQgKEthbGFhbGxpdCBOdW5hYXQpXCIsXCJnbFwiLFwiMjk5XCJdLFtcIkdyZW5hZGFcIixcImdkXCIsXCIxXCIsMTQsW1wiNDczXCJdXSxbXCJHdWFkZWxvdXBlXCIsXCJncFwiLFwiNTkwXCIsMF0sW1wiR3VhbVwiLFwiZ3VcIixcIjFcIiwxNSxbXCI2NzFcIl1dLFtcIkd1YXRlbWFsYVwiLFwiZ3RcIixcIjUwMlwiXSxbXCJHdWVybnNleVwiLFwiZ2dcIixcIjQ0XCIsMSxbXCIxNDgxXCIsXCI3NzgxXCIsXCI3ODM5XCIsXCI3OTExXCJdXSxbXCJHdWluZWEgKEd1aW7DqWUpXCIsXCJnblwiLFwiMjI0XCJdLFtcIkd1aW5lYS1CaXNzYXUgKEd1aW7DqSBCaXNzYXUpXCIsXCJnd1wiLFwiMjQ1XCJdLFtcIkd1eWFuYVwiLFwiZ3lcIixcIjU5MlwiXSxbXCJIYWl0aVwiLFwiaHRcIixcIjUwOVwiXSxbXCJIb25kdXJhc1wiLFwiaG5cIixcIjUwNFwiXSxbXCJIb25nIEtvbmcgKOmmmea4rylcIixcImhrXCIsXCI4NTJcIl0sW1wiSHVuZ2FyeSAoTWFneWFyb3JzesOhZylcIixcImh1XCIsXCIzNlwiXSxbXCJJY2VsYW5kICjDjXNsYW5kKVwiLFwiaXNcIixcIjM1NFwiXSxbXCJJbmRpYSAo4KSt4KS+4KSw4KSkKVwiLFwiaW5cIixcIjkxXCJdLFtcIkluZG9uZXNpYVwiLFwiaWRcIixcIjYyXCJdLFtcIklyYW4gKOKAq9in24zYsdin2YbigKzigI4pXCIsXCJpclwiLFwiOThcIl0sW1wiSXJhcSAo4oCr2KfZhNi52LHYp9mC4oCs4oCOKVwiLFwiaXFcIixcIjk2NFwiXSxbXCJJcmVsYW5kXCIsXCJpZVwiLFwiMzUzXCJdLFtcIklzbGUgb2YgTWFuXCIsXCJpbVwiLFwiNDRcIiwyLFtcIjE2MjRcIixcIjc0NTc2XCIsXCI3NTI0XCIsXCI3OTI0XCIsXCI3NjI0XCJdXSxbXCJJc3JhZWwgKOKAq9eZ16nXqNeQ15zigKzigI4pXCIsXCJpbFwiLFwiOTcyXCJdLFtcIkl0YWx5IChJdGFsaWEpXCIsXCJpdFwiLFwiMzlcIiwwXSxbXCJKYW1haWNhXCIsXCJqbVwiLFwiMVwiLDQsW1wiODc2XCIsXCI2NThcIl1dLFtcIkphcGFuICjml6XmnKwpXCIsXCJqcFwiLFwiODFcIl0sW1wiSmVyc2V5XCIsXCJqZVwiLFwiNDRcIiwzLFtcIjE1MzRcIixcIjc1MDlcIixcIjc3MDBcIixcIjc3OTdcIixcIjc4MjlcIixcIjc5MzdcIl1dLFtcIkpvcmRhbiAo4oCr2KfZhNij2LHYr9mG4oCs4oCOKVwiLFwiam9cIixcIjk2MlwiXSxbXCJLYXpha2hzdGFuICjQmtCw0LfQsNGF0YHRgtCw0L0pXCIsXCJrelwiLFwiN1wiLDEsW1wiMzNcIixcIjdcIl1dLFtcIktlbnlhXCIsXCJrZVwiLFwiMjU0XCJdLFtcIktpcmliYXRpXCIsXCJraVwiLFwiNjg2XCJdLFtcIktvc292b1wiLFwieGtcIixcIjM4M1wiXSxbXCJLdXdhaXQgKOKAq9in2YTZg9mI2YrYquKArOKAjilcIixcImt3XCIsXCI5NjVcIl0sW1wiS3lyZ3l6c3RhbiAo0JrRi9GA0LPRi9C30YHRgtCw0L0pXCIsXCJrZ1wiLFwiOTk2XCJdLFtcIkxhb3MgKOC6peC6suC6pylcIixcImxhXCIsXCI4NTZcIl0sW1wiTGF0dmlhIChMYXR2aWphKVwiLFwibHZcIixcIjM3MVwiXSxbXCJMZWJhbm9uICjigKvZhNio2YbYp9mG4oCs4oCOKVwiLFwibGJcIixcIjk2MVwiXSxbXCJMZXNvdGhvXCIsXCJsc1wiLFwiMjY2XCJdLFtcIkxpYmVyaWFcIixcImxyXCIsXCIyMzFcIl0sW1wiTGlieWEgKOKAq9mE2YrYqNmK2KfigKzigI4pXCIsXCJseVwiLFwiMjE4XCJdLFtcIkxpZWNodGVuc3RlaW5cIixcImxpXCIsXCI0MjNcIl0sW1wiTGl0aHVhbmlhIChMaWV0dXZhKVwiLFwibHRcIixcIjM3MFwiXSxbXCJMdXhlbWJvdXJnXCIsXCJsdVwiLFwiMzUyXCJdLFtcIk1hY2F1ICjmvrPploApXCIsXCJtb1wiLFwiODUzXCJdLFtcIk1hY2Vkb25pYSAoRllST00pICjQnNCw0LrQtdC00L7QvdC40ZjQsClcIixcIm1rXCIsXCIzODlcIl0sW1wiTWFkYWdhc2NhciAoTWFkYWdhc2lrYXJhKVwiLFwibWdcIixcIjI2MVwiXSxbXCJNYWxhd2lcIixcIm13XCIsXCIyNjVcIl0sW1wiTWFsYXlzaWFcIixcIm15XCIsXCI2MFwiXSxbXCJNYWxkaXZlc1wiLFwibXZcIixcIjk2MFwiXSxbXCJNYWxpXCIsXCJtbFwiLFwiMjIzXCJdLFtcIk1hbHRhXCIsXCJtdFwiLFwiMzU2XCJdLFtcIk1hcnNoYWxsIElzbGFuZHNcIixcIm1oXCIsXCI2OTJcIl0sW1wiTWFydGluaXF1ZVwiLFwibXFcIixcIjU5NlwiXSxbXCJNYXVyaXRhbmlhICjigKvZhdmI2LHZitiq2KfZhtmK2KfigKzigI4pXCIsXCJtclwiLFwiMjIyXCJdLFtcIk1hdXJpdGl1cyAoTW9yaXMpXCIsXCJtdVwiLFwiMjMwXCJdLFtcIk1heW90dGVcIixcInl0XCIsXCIyNjJcIiwxLFtcIjI2OVwiLFwiNjM5XCJdXSxbXCJNZXhpY28gKE3DqXhpY28pXCIsXCJteFwiLFwiNTJcIl0sW1wiTWljcm9uZXNpYVwiLFwiZm1cIixcIjY5MVwiXSxbXCJNb2xkb3ZhIChSZXB1YmxpY2EgTW9sZG92YSlcIixcIm1kXCIsXCIzNzNcIl0sW1wiTW9uYWNvXCIsXCJtY1wiLFwiMzc3XCJdLFtcIk1vbmdvbGlhICjQnNC+0L3Qs9C+0LspXCIsXCJtblwiLFwiOTc2XCJdLFtcIk1vbnRlbmVncm8gKENybmEgR29yYSlcIixcIm1lXCIsXCIzODJcIl0sW1wiTW9udHNlcnJhdFwiLFwibXNcIixcIjFcIiwxNixbXCI2NjRcIl1dLFtcIk1vcm9jY28gKOKAq9in2YTZhdi62LHYqOKArOKAjilcIixcIm1hXCIsXCIyMTJcIiwwXSxbXCJNb3phbWJpcXVlIChNb8OnYW1iaXF1ZSlcIixcIm16XCIsXCIyNThcIl0sW1wiTXlhbm1hciAoQnVybWEpICjhgJnhgLzhgJThgLrhgJnhgKwpXCIsXCJtbVwiLFwiOTVcIl0sW1wiTmFtaWJpYSAoTmFtaWJpw6spXCIsXCJuYVwiLFwiMjY0XCJdLFtcIk5hdXJ1XCIsXCJuclwiLFwiNjc0XCJdLFtcIk5lcGFsICjgpKjgpYfgpKrgpL7gpLIpXCIsXCJucFwiLFwiOTc3XCJdLFtcIk5ldGhlcmxhbmRzIChOZWRlcmxhbmQpXCIsXCJubFwiLFwiMzFcIl0sW1wiTmV3IENhbGVkb25pYSAoTm91dmVsbGUtQ2Fsw6lkb25pZSlcIixcIm5jXCIsXCI2ODdcIl0sW1wiTmV3IFplYWxhbmRcIixcIm56XCIsXCI2NFwiXSxbXCJOaWNhcmFndWFcIixcIm5pXCIsXCI1MDVcIl0sW1wiTmlnZXIgKE5pamFyKVwiLFwibmVcIixcIjIyN1wiXSxbXCJOaWdlcmlhXCIsXCJuZ1wiLFwiMjM0XCJdLFtcIk5pdWVcIixcIm51XCIsXCI2ODNcIl0sW1wiTm9yZm9sayBJc2xhbmRcIixcIm5mXCIsXCI2NzJcIl0sW1wiTm9ydGggS29yZWEgKOyhsOyEoCDrr7zso7zso7zsnZgg7J2466+8IOqzte2ZlOq1rSlcIixcImtwXCIsXCI4NTBcIl0sW1wiTm9ydGhlcm4gTWFyaWFuYSBJc2xhbmRzXCIsXCJtcFwiLFwiMVwiLDE3LFtcIjY3MFwiXV0sW1wiTm9yd2F5IChOb3JnZSlcIixcIm5vXCIsXCI0N1wiLDBdLFtcIk9tYW4gKOKAq9i52Y/Zhdin2YbigKzigI4pXCIsXCJvbVwiLFwiOTY4XCJdLFtcIlBha2lzdGFuICjigKvZvtin2qnYs9iq2KfZhuKArOKAjilcIixcInBrXCIsXCI5MlwiXSxbXCJQYWxhdVwiLFwicHdcIixcIjY4MFwiXSxbXCJQYWxlc3RpbmUgKOKAq9mB2YTYs9i32YrZhuKArOKAjilcIixcInBzXCIsXCI5NzBcIl0sW1wiUGFuYW1hIChQYW5hbcOhKVwiLFwicGFcIixcIjUwN1wiXSxbXCJQYXB1YSBOZXcgR3VpbmVhXCIsXCJwZ1wiLFwiNjc1XCJdLFtcIlBhcmFndWF5XCIsXCJweVwiLFwiNTk1XCJdLFtcIlBlcnUgKFBlcsO6KVwiLFwicGVcIixcIjUxXCJdLFtcIlBoaWxpcHBpbmVzXCIsXCJwaFwiLFwiNjNcIl0sW1wiUG9sYW5kIChQb2xza2EpXCIsXCJwbFwiLFwiNDhcIl0sW1wiUG9ydHVnYWxcIixcInB0XCIsXCIzNTFcIl0sW1wiUHVlcnRvIFJpY29cIixcInByXCIsXCIxXCIsMyxbXCI3ODdcIixcIjkzOVwiXV0sW1wiUWF0YXIgKOKAq9mC2LfYseKArOKAjilcIixcInFhXCIsXCI5NzRcIl0sW1wiUsOpdW5pb24gKExhIFLDqXVuaW9uKVwiLFwicmVcIixcIjI2MlwiLDBdLFtcIlJvbWFuaWEgKFJvbcOibmlhKVwiLFwicm9cIixcIjQwXCJdLFtcIlJ1c3NpYSAo0KDQvtGB0YHQuNGPKVwiLFwicnVcIixcIjdcIiwwXSxbXCJSd2FuZGFcIixcInJ3XCIsXCIyNTBcIl0sW1wiU2FpbnQgQmFydGjDqWxlbXlcIixcImJsXCIsXCI1OTBcIiwxXSxbXCJTYWludCBIZWxlbmFcIixcInNoXCIsXCIyOTBcIl0sW1wiU2FpbnQgS2l0dHMgYW5kIE5ldmlzXCIsXCJrblwiLFwiMVwiLDE4LFtcIjg2OVwiXV0sW1wiU2FpbnQgTHVjaWFcIixcImxjXCIsXCIxXCIsMTksW1wiNzU4XCJdXSxbXCJTYWludCBNYXJ0aW4gKFNhaW50LU1hcnRpbiAocGFydGllIGZyYW7Dp2Fpc2UpKVwiLFwibWZcIixcIjU5MFwiLDJdLFtcIlNhaW50IFBpZXJyZSBhbmQgTWlxdWVsb24gKFNhaW50LVBpZXJyZS1ldC1NaXF1ZWxvbilcIixcInBtXCIsXCI1MDhcIl0sW1wiU2FpbnQgVmluY2VudCBhbmQgdGhlIEdyZW5hZGluZXNcIixcInZjXCIsXCIxXCIsMjAsW1wiNzg0XCJdXSxbXCJTYW1vYVwiLFwid3NcIixcIjY4NVwiXSxbXCJTYW4gTWFyaW5vXCIsXCJzbVwiLFwiMzc4XCJdLFtcIlPDo28gVG9tw6kgYW5kIFByw61uY2lwZSAoU8OjbyBUb23DqSBlIFByw61uY2lwZSlcIixcInN0XCIsXCIyMzlcIl0sW1wiU2F1ZGkgQXJhYmlhICjigKvYp9mE2YXZhdmE2YPYqSDYp9mE2LnYsdio2YrYqSDYp9mE2LPYudmI2K/Zitip4oCs4oCOKVwiLFwic2FcIixcIjk2NlwiXSxbXCJTZW5lZ2FsIChTw6luw6lnYWwpXCIsXCJzblwiLFwiMjIxXCJdLFtcIlNlcmJpYSAo0KHRgNCx0LjRmNCwKVwiLFwicnNcIixcIjM4MVwiXSxbXCJTZXljaGVsbGVzXCIsXCJzY1wiLFwiMjQ4XCJdLFtcIlNpZXJyYSBMZW9uZVwiLFwic2xcIixcIjIzMlwiXSxbXCJTaW5nYXBvcmVcIixcInNnXCIsXCI2NVwiXSxbXCJTaW50IE1hYXJ0ZW5cIixcInN4XCIsXCIxXCIsMjEsW1wiNzIxXCJdXSxbXCJTbG92YWtpYSAoU2xvdmVuc2tvKVwiLFwic2tcIixcIjQyMVwiXSxbXCJTbG92ZW5pYSAoU2xvdmVuaWphKVwiLFwic2lcIixcIjM4NlwiXSxbXCJTb2xvbW9uIElzbGFuZHNcIixcInNiXCIsXCI2NzdcIl0sW1wiU29tYWxpYSAoU29vbWFhbGl5YSlcIixcInNvXCIsXCIyNTJcIl0sW1wiU291dGggQWZyaWNhXCIsXCJ6YVwiLFwiMjdcIl0sW1wiU291dGggS29yZWEgKOuMgO2VnOuvvOq1rSlcIixcImtyXCIsXCI4MlwiXSxbXCJTb3V0aCBTdWRhbiAo4oCr2KzZhtmI2Kgg2KfZhNiz2YjYr9in2YbigKzigI4pXCIsXCJzc1wiLFwiMjExXCJdLFtcIlNwYWluIChFc3Bhw7FhKVwiLFwiZXNcIixcIjM0XCJdLFtcIlNyaSBMYW5rYSAo4LeB4LeK4oCN4La74LeTIOC2veC2guC2muC3j+C3gClcIixcImxrXCIsXCI5NFwiXSxbXCJTdWRhbiAo4oCr2KfZhNiz2YjYr9in2YbigKzigI4pXCIsXCJzZFwiLFwiMjQ5XCJdLFtcIlN1cmluYW1lXCIsXCJzclwiLFwiNTk3XCJdLFtcIlN2YWxiYXJkIGFuZCBKYW4gTWF5ZW5cIixcInNqXCIsXCI0N1wiLDEsW1wiNzlcIl1dLFtcIlN3YXppbGFuZFwiLFwic3pcIixcIjI2OFwiXSxbXCJTd2VkZW4gKFN2ZXJpZ2UpXCIsXCJzZVwiLFwiNDZcIl0sW1wiU3dpdHplcmxhbmQgKFNjaHdlaXopXCIsXCJjaFwiLFwiNDFcIl0sW1wiU3lyaWEgKOKAq9iz2YjYsdmK2KfigKzigI4pXCIsXCJzeVwiLFwiOTYzXCJdLFtcIlRhaXdhbiAo5Y+w54GjKVwiLFwidHdcIixcIjg4NlwiXSxbXCJUYWppa2lzdGFuXCIsXCJ0alwiLFwiOTkyXCJdLFtcIlRhbnphbmlhXCIsXCJ0elwiLFwiMjU1XCJdLFtcIlRoYWlsYW5kICjguYTguJfguKIpXCIsXCJ0aFwiLFwiNjZcIl0sW1wiVGltb3ItTGVzdGVcIixcInRsXCIsXCI2NzBcIl0sW1wiVG9nb1wiLFwidGdcIixcIjIyOFwiXSxbXCJUb2tlbGF1XCIsXCJ0a1wiLFwiNjkwXCJdLFtcIlRvbmdhXCIsXCJ0b1wiLFwiNjc2XCJdLFtcIlRyaW5pZGFkIGFuZCBUb2JhZ29cIixcInR0XCIsXCIxXCIsMjIsW1wiODY4XCJdXSxbXCJUdW5pc2lhICjigKvYqtmI2YbYs+KArOKAjilcIixcInRuXCIsXCIyMTZcIl0sW1wiVHVya2V5IChUw7xya2l5ZSlcIixcInRyXCIsXCI5MFwiXSxbXCJUdXJrbWVuaXN0YW5cIixcInRtXCIsXCI5OTNcIl0sW1wiVHVya3MgYW5kIENhaWNvcyBJc2xhbmRzXCIsXCJ0Y1wiLFwiMVwiLDIzLFtcIjY0OVwiXV0sW1wiVHV2YWx1XCIsXCJ0dlwiLFwiNjg4XCJdLFtcIlUuUy4gVmlyZ2luIElzbGFuZHNcIixcInZpXCIsXCIxXCIsMjQsW1wiMzQwXCJdXSxbXCJVZ2FuZGFcIixcInVnXCIsXCIyNTZcIl0sW1wiVWtyYWluZSAo0KPQutGA0LDRl9C90LApXCIsXCJ1YVwiLFwiMzgwXCJdLFtcIlVuaXRlZCBBcmFiIEVtaXJhdGVzICjigKvYp9mE2KXZhdin2LHYp9iqINin2YTYudix2KjZitipINin2YTZhdiq2K3Yr9ip4oCs4oCOKVwiLFwiYWVcIixcIjk3MVwiXSxbXCJVbml0ZWQgS2luZ2RvbVwiLFwiZ2JcIixcIjQ0XCIsMF0sW1wiVW5pdGVkIFN0YXRlc1wiLFwidXNcIixcIjFcIiwwXSxbXCJVcnVndWF5XCIsXCJ1eVwiLFwiNTk4XCJdLFtcIlV6YmVraXN0YW4gKE/Ku3piZWtpc3RvbilcIixcInV6XCIsXCI5OThcIl0sW1wiVmFudWF0dVwiLFwidnVcIixcIjY3OFwiXSxbXCJWYXRpY2FuIENpdHkgKENpdHTDoCBkZWwgVmF0aWNhbm8pXCIsXCJ2YVwiLFwiMzlcIiwxLFtcIjA2Njk4XCJdXSxbXCJWZW5lenVlbGFcIixcInZlXCIsXCI1OFwiXSxbXCJWaWV0bmFtIChWaeG7h3QgTmFtKVwiLFwidm5cIixcIjg0XCJdLFtcIldhbGxpcyBhbmQgRnV0dW5hIChXYWxsaXMtZXQtRnV0dW5hKVwiLFwid2ZcIixcIjY4MVwiXSxbXCJXZXN0ZXJuIFNhaGFyYSAo4oCr2KfZhNi12K3Ysdin2KEg2KfZhNi62LHYqNmK2KnigKzigI4pXCIsXCJlaFwiLFwiMjEyXCIsMSxbXCI1Mjg4XCIsXCI1Mjg5XCJdXSxbXCJZZW1lbiAo4oCr2KfZhNmK2YXZhuKArOKAjilcIixcInllXCIsXCI5NjdcIl0sW1wiWmFtYmlhXCIsXCJ6bVwiLFwiMjYwXCJdLFtcIlppbWJhYndlXCIsXCJ6d1wiLFwiMjYzXCJdLFtcIsOFbGFuZCBJc2xhbmRzXCIsXCJheFwiLFwiMzU4XCIsMSxbXCIxOFwiXV1dLGg9MDtoPGcubGVuZ3RoO2grKyl7dmFyIGk9Z1toXTtnW2hdPXtuYW1lOmlbMF0saXNvMjppWzFdLGRpYWxDb2RlOmlbMl0scHJpb3JpdHk6aVszXXx8MCxhcmVhQ29kZXM6aVs0XXx8bnVsbH19YS5pbnRsVGVsSW5wdXRHbG9iYWxzPXtnZXRJbnN0YW5jZTpmdW5jdGlvbihiKXt2YXIgYz1iLmdldEF0dHJpYnV0ZShcImRhdGEtaW50bC10ZWwtaW5wdXQtaWRcIik7cmV0dXJuIGEuaW50bFRlbElucHV0R2xvYmFscy5pbnN0YW5jZXNbY119LGluc3RhbmNlczp7fX07dmFyIGo9MCxrPXthbGxvd0Ryb3Bkb3duOiEwLGF1dG9IaWRlRGlhbENvZGU6ITAsYXV0b1BsYWNlaG9sZGVyOlwicG9saXRlXCIsY3VzdG9tQ29udGFpbmVyOlwiXCIsY3VzdG9tUGxhY2Vob2xkZXI6bnVsbCxkcm9wZG93bkNvbnRhaW5lcjpudWxsLGV4Y2x1ZGVDb3VudHJpZXM6W10sZm9ybWF0T25EaXNwbGF5OiEwLGdlb0lwTG9va3VwOm51bGwsaGlkZGVuSW5wdXQ6XCJcIixpbml0aWFsQ291bnRyeTpcIlwiLGxvY2FsaXplZENvdW50cmllczpudWxsLG5hdGlvbmFsTW9kZTohMCxvbmx5Q291bnRyaWVzOltdLHBsYWNlaG9sZGVyTnVtYmVyVHlwZTpcIk1PQklMRVwiLHByZWZlcnJlZENvdW50cmllczpbXCJ1c1wiLFwiZ2JcIl0sc2VwYXJhdGVEaWFsQ29kZTohMSx1dGlsc1NjcmlwdDpcIlwifSxsPVtcIjgwMFwiLFwiODIyXCIsXCI4MzNcIixcIjg0NFwiLFwiODU1XCIsXCI4NjZcIixcIjg3N1wiLFwiODgwXCIsXCI4ODFcIixcIjg4MlwiLFwiODgzXCIsXCI4ODRcIixcIjg4NVwiLFwiODg2XCIsXCI4ODdcIixcIjg4OFwiLFwiODg5XCJdO2EuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbigpe2EuaW50bFRlbElucHV0R2xvYmFscy53aW5kb3dMb2FkZWQ9ITB9KTt2YXIgbT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1PYmplY3Qua2V5cyhhKSxkPTA7ZDxjLmxlbmd0aDtkKyspYihjW2RdLGFbY1tkXV0pfSxuPWZ1bmN0aW9uKGIpe20oYS5pbnRsVGVsSW5wdXRHbG9iYWxzLmluc3RhbmNlcyxmdW5jdGlvbihjKXthLmludGxUZWxJbnB1dEdsb2JhbHMuaW5zdGFuY2VzW2NdW2JdKCl9KX0sbz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoYSxiKXt2YXIgYz10aGlzO2QodGhpcyxlKSx0aGlzLmlkPWorKyx0aGlzLmE9YSx0aGlzLmI9bnVsbCx0aGlzLmM9bnVsbDt2YXIgZj1ifHx7fTt0aGlzLmQ9e30sbShrLGZ1bmN0aW9uKGEsYil7Yy5kW2FdPWYuaGFzT3duUHJvcGVydHkoYSk/ZlthXTpifSksdGhpcy5lPUJvb2xlYW4oYS5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKSl9cmV0dXJuIGYoZSxbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2lmKHRoaXMuZC5uYXRpb25hbE1vZGUmJih0aGlzLmQuYXV0b0hpZGVEaWFsQ29kZT0hMSksdGhpcy5kLnNlcGFyYXRlRGlhbENvZGUmJih0aGlzLmQuYXV0b0hpZGVEaWFsQ29kZT10aGlzLmQubmF0aW9uYWxNb2RlPSExKSx0aGlzLmc9L0FuZHJvaWQuK01vYmlsZXx3ZWJPU3xpUGhvbmV8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLHRoaXMuZyYmKGIuYm9keS5jbGFzc0xpc3QuYWRkKFwiaXRpLW1vYmlsZVwiKSx0aGlzLmQuZHJvcGRvd25Db250YWluZXJ8fCh0aGlzLmQuZHJvcGRvd25Db250YWluZXI9Yi5ib2R5KSksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2Upe3ZhciBjPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGIsYyl7YS5oPWIsYS5pPWN9KSxkPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGIsYyl7YS5pMD1iLGEuaTE9Y30pO3RoaXMucHJvbWlzZT1Qcm9taXNlLmFsbChbYyxkXSl9ZWxzZSB0aGlzLmg9dGhpcy5pPWZ1bmN0aW9uKCl7fSx0aGlzLmkwPXRoaXMuaTE9ZnVuY3Rpb24oKXt9O3RoaXMucz17fSx0aGlzLl9iKCksdGhpcy5fZigpLHRoaXMuX2goKSx0aGlzLl9pKCksdGhpcy5faTMoKX19LHtrZXk6XCJfYlwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fZCgpLHRoaXMuX2QyKCksdGhpcy5fZSgpLHRoaXMuZC5sb2NhbGl6ZWRDb3VudHJpZXMmJnRoaXMuX2QwKCksKHRoaXMuZC5vbmx5Q291bnRyaWVzLmxlbmd0aHx8dGhpcy5kLmxvY2FsaXplZENvdW50cmllcykmJnRoaXMucC5zb3J0KHRoaXMuX2QxKX19LHtrZXk6XCJfY1wiLHZhbHVlOmZ1bmN0aW9uKGEsYixkKXtiLmxlbmd0aD50aGlzLmRpYWxDb2RlTWF4TGVuJiYodGhpcy5kaWFsQ29kZU1heExlbj1iLmxlbmd0aCksdGhpcy5xLmhhc093blByb3BlcnR5KGIpfHwodGhpcy5xW2JdPVtdKTtmb3IodmFyIGU9MDtlPHRoaXMucVtiXS5sZW5ndGg7ZSsrKWlmKHRoaXMucVtiXVtlXT09PWEpcmV0dXJuO3ZhciBmPWQhPT1jP2Q6dGhpcy5xW2JdLmxlbmd0aDt0aGlzLnFbYl1bZl09YX19LHtrZXk6XCJfZFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5kLm9ubHlDb3VudHJpZXMubGVuZ3RoKXt2YXIgYT10aGlzLmQub25seUNvdW50cmllcy5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEudG9Mb3dlckNhc2UoKX0pO3RoaXMucD1nLmZpbHRlcihmdW5jdGlvbihiKXtyZXR1cm4gYS5pbmRleE9mKGIuaXNvMik+LTF9KX1lbHNlIGlmKHRoaXMuZC5leGNsdWRlQ291bnRyaWVzLmxlbmd0aCl7dmFyIGI9dGhpcy5kLmV4Y2x1ZGVDb3VudHJpZXMubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhLnRvTG93ZXJDYXNlKCl9KTt0aGlzLnA9Zy5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuLTE9PT1iLmluZGV4T2YoYS5pc28yKX0pfWVsc2UgdGhpcy5wPWd9fSx7a2V5OlwiX2QwXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMucC5sZW5ndGg7YSsrKXt2YXIgYj10aGlzLnBbYV0uaXNvMi50b0xvd2VyQ2FzZSgpO3RoaXMuZC5sb2NhbGl6ZWRDb3VudHJpZXMuaGFzT3duUHJvcGVydHkoYikmJih0aGlzLnBbYV0ubmFtZT10aGlzLmQubG9jYWxpemVkQ291bnRyaWVzW2JdKX19fSx7a2V5OlwiX2QxXCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKX19LHtrZXk6XCJfZDJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZGlhbENvZGVNYXhMZW49MCx0aGlzLnE9e307Zm9yKHZhciBhPTA7YTx0aGlzLnAubGVuZ3RoO2ErKyl7dmFyIGI9dGhpcy5wW2FdO3RoaXMuX2MoYi5pc28yLGIuZGlhbENvZGUsYi5wcmlvcml0eSl9Zm9yKHZhciBjPTA7Yzx0aGlzLnAubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5wW2NdO2lmKGQuYXJlYUNvZGVzKWZvcih2YXIgZT10aGlzLnFbZC5kaWFsQ29kZV1bMF0sZj0wO2Y8ZC5hcmVhQ29kZXMubGVuZ3RoO2YrKyl7Zm9yKHZhciBnPWQuYXJlYUNvZGVzW2ZdLGg9MTtoPGcubGVuZ3RoO2grKyl7dmFyIGk9ZC5kaWFsQ29kZStnLnN1YnN0cigwLGgpO3RoaXMuX2MoZSxpKSx0aGlzLl9jKGQuaXNvMixpKX10aGlzLl9jKGQuaXNvMixkLmRpYWxDb2RlK2cpfX19fSx7a2V5OlwiX2VcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJlZmVycmVkQ291bnRyaWVzPVtdO2Zvcih2YXIgYT0wO2E8dGhpcy5kLnByZWZlcnJlZENvdW50cmllcy5sZW5ndGg7YSsrKXt2YXIgYj10aGlzLmQucHJlZmVycmVkQ291bnRyaWVzW2FdLnRvTG93ZXJDYXNlKCksYz10aGlzLl95KGIsITEsITApO2MmJnRoaXMucHJlZmVycmVkQ291bnRyaWVzLnB1c2goYyl9fX0se2tleTpcIl9lMlwiLHZhbHVlOmZ1bmN0aW9uKGEsYyxkKXt2YXIgZT1iLmNyZWF0ZUVsZW1lbnQoYSk7cmV0dXJuIGMmJm0oYyxmdW5jdGlvbihhLGIpe3JldHVybiBlLnNldEF0dHJpYnV0ZShhLGIpfSksZCYmZC5hcHBlbmRDaGlsZChlKSxlfX0se2tleTpcIl9mXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmEuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlXCIsXCJvZmZcIik7dmFyIGE9XCJpdGlcIjt0aGlzLmQuYWxsb3dEcm9wZG93biYmKGErPVwiIGl0aS0tYWxsb3ctZHJvcGRvd25cIiksdGhpcy5kLnNlcGFyYXRlRGlhbENvZGUmJihhKz1cIiBpdGktLXNlcGFyYXRlLWRpYWwtY29kZVwiKSx0aGlzLmQuY3VzdG9tQ29udGFpbmVyJiYoYSs9XCIgXCIsYSs9dGhpcy5kLmN1c3RvbUNvbnRhaW5lcik7dmFyIGI9dGhpcy5fZTIoXCJkaXZcIix7XCJjbGFzc1wiOmF9KTtpZih0aGlzLmEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYix0aGlzLmEpLHRoaXMuaz10aGlzLl9lMihcImRpdlwiLHtcImNsYXNzXCI6XCJpdGlfX2ZsYWctY29udGFpbmVyXCJ9LGIpLGIuYXBwZW5kQ2hpbGQodGhpcy5hKSx0aGlzLnNlbGVjdGVkRmxhZz10aGlzLl9lMihcImRpdlwiLHtcImNsYXNzXCI6XCJpdGlfX3NlbGVjdGVkLWZsYWdcIixyb2xlOlwiY29tYm9ib3hcIixcImFyaWEtb3duc1wiOlwiY291bnRyeS1saXN0Ym94XCJ9LHRoaXMuayksdGhpcy5sPXRoaXMuX2UyKFwiZGl2XCIse1wiY2xhc3NcIjpcIml0aV9fZmxhZ1wifSx0aGlzLnNlbGVjdGVkRmxhZyksdGhpcy5kLnNlcGFyYXRlRGlhbENvZGUmJih0aGlzLnQ9dGhpcy5fZTIoXCJkaXZcIix7XCJjbGFzc1wiOlwiaXRpX19zZWxlY3RlZC1kaWFsLWNvZGVcIn0sdGhpcy5zZWxlY3RlZEZsYWcpKSx0aGlzLmQuYWxsb3dEcm9wZG93biYmKHRoaXMuc2VsZWN0ZWRGbGFnLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsXCIwXCIpLHRoaXMudT10aGlzLl9lMihcImRpdlwiLHtcImNsYXNzXCI6XCJpdGlfX2Fycm93XCJ9LHRoaXMuc2VsZWN0ZWRGbGFnKSx0aGlzLm09dGhpcy5fZTIoXCJ1bFwiLHtcImNsYXNzXCI6XCJpdGlfX2NvdW50cnktbGlzdCBpdGlfX2hpZGVcIixpZDpcImNvdW50cnktbGlzdGJveFwiLFwiYXJpYS1leHBhbmRlZFwiOlwiZmFsc2VcIixyb2xlOlwibGlzdGJveFwifSksdGhpcy5wcmVmZXJyZWRDb3VudHJpZXMubGVuZ3RoJiYodGhpcy5fZyh0aGlzLnByZWZlcnJlZENvdW50cmllcyxcIml0aV9fcHJlZmVycmVkXCIpLHRoaXMuX2UyKFwibGlcIix7XCJjbGFzc1wiOlwiaXRpX19kaXZpZGVyXCIscm9sZTpcInNlcGFyYXRvclwiLFwiYXJpYS1kaXNhYmxlZFwiOlwidHJ1ZVwifSx0aGlzLm0pKSx0aGlzLl9nKHRoaXMucCxcIml0aV9fc3RhbmRhcmRcIiksdGhpcy5kLmRyb3Bkb3duQ29udGFpbmVyPyh0aGlzLmRyb3Bkb3duPXRoaXMuX2UyKFwiZGl2XCIse1wiY2xhc3NcIjpcIml0aSBpdGktLWNvbnRhaW5lclwifSksdGhpcy5kcm9wZG93bi5hcHBlbmRDaGlsZCh0aGlzLm0pKTp0aGlzLmsuYXBwZW5kQ2hpbGQodGhpcy5tKSksdGhpcy5kLmhpZGRlbklucHV0KXt2YXIgYz10aGlzLmQuaGlkZGVuSW5wdXQsZD10aGlzLmEuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtpZihkKXt2YXIgZT1kLmxhc3RJbmRleE9mKFwiW1wiKTstMSE9PWUmJihjPVwiXCIuY29uY2F0KGQuc3Vic3RyKDAsZSksXCJbXCIpLmNvbmNhdChjLFwiXVwiKSl9dGhpcy5oaWRkZW5JbnB1dD10aGlzLl9lMihcImlucHV0XCIse3R5cGU6XCJoaWRkZW5cIixuYW1lOmN9KSxiLmFwcGVuZENoaWxkKHRoaXMuaGlkZGVuSW5wdXQpfX19LHtrZXk6XCJfZ1wiLHZhbHVlOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVwiXCIsZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgZT1hW2RdO2MrPVwiPGxpIGNsYXNzPSdpdGlfX2NvdW50cnkgXCIuY29uY2F0KGIsXCInIHRhYkluZGV4PSctMScgaWQ9J2l0aS1pdGVtLVwiKS5jb25jYXQoZS5pc28yLFwiJyByb2xlPSdvcHRpb24nIGRhdGEtZGlhbC1jb2RlPSdcIikuY29uY2F0KGUuZGlhbENvZGUsXCInIGRhdGEtY291bnRyeS1jb2RlPSdcIikuY29uY2F0KGUuaXNvMixcIic+XCIpLGMrPVwiPGRpdiBjbGFzcz0naXRpX19mbGFnLWJveCc+PGRpdiBjbGFzcz0naXRpX19mbGFnIGl0aV9fXCIuY29uY2F0KGUuaXNvMixcIic+PC9kaXY+PC9kaXY+XCIpLGMrPVwiPHNwYW4gY2xhc3M9J2l0aV9fY291bnRyeS1uYW1lJz5cIi5jb25jYXQoZS5uYW1lLFwiPC9zcGFuPlwiKSxjKz1cIjxzcGFuIGNsYXNzPSdpdGlfX2RpYWwtY29kZSc+K1wiLmNvbmNhdChlLmRpYWxDb2RlLFwiPC9zcGFuPlwiKSxjKz1cIjwvbGk+XCJ9dGhpcy5tLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLGMpfX0se2tleTpcIl9oXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmEudmFsdWUsYj10aGlzLl81KGEpLGM9dGhpcy5fdyhhKSxkPXRoaXMuZCxlPWQuaW5pdGlhbENvdW50cnksZj1kLm5hdGlvbmFsTW9kZSxnPWQuYXV0b0hpZGVEaWFsQ29kZSxoPWQuc2VwYXJhdGVEaWFsQ29kZTtiJiYhYz90aGlzLl92KGEpOlwiYXV0b1wiIT09ZSYmKGU/dGhpcy5feihlLnRvTG93ZXJDYXNlKCkpOmImJmM/dGhpcy5feihcInVzXCIpOih0aGlzLmo9dGhpcy5wcmVmZXJyZWRDb3VudHJpZXMubGVuZ3RoP3RoaXMucHJlZmVycmVkQ291bnRyaWVzWzBdLmlzbzI6dGhpcy5wWzBdLmlzbzIsYXx8dGhpcy5feih0aGlzLmopKSxhfHxmfHxnfHxofHwodGhpcy5hLnZhbHVlPVwiK1wiLmNvbmNhdCh0aGlzLnMuZGlhbENvZGUpKSksYSYmdGhpcy5fdShhKX19LHtrZXk6XCJfaVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5faigpLHRoaXMuZC5hdXRvSGlkZURpYWxDb2RlJiZ0aGlzLl9sKCksdGhpcy5kLmFsbG93RHJvcGRvd24mJnRoaXMuX2kyKCksdGhpcy5oaWRkZW5JbnB1dCYmdGhpcy5faTAoKX19LHtrZXk6XCJfaTBcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXM7dGhpcy5fYTE0PWZ1bmN0aW9uKCl7YS5oaWRkZW5JbnB1dC52YWx1ZT1hLmdldE51bWJlcigpfSx0aGlzLmEuZm9ybSYmdGhpcy5hLmZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLHRoaXMuX2ExNCl9fSx7a2V5OlwiX2kxXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5hO2EmJlwiTEFCRUxcIiE9PWEudGFnTmFtZTspYT1hLnBhcmVudE5vZGU7cmV0dXJuIGF9fSx7a2V5OlwiX2kyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuX2E5PWZ1bmN0aW9uKGIpe2EubS5jbGFzc0xpc3QuY29udGFpbnMoXCJpdGlfX2hpZGVcIik/YS5hLmZvY3VzKCk6Yi5wcmV2ZW50RGVmYXVsdCgpfTt2YXIgYj10aGlzLl9pMSgpO2ImJmIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fYTkpLHRoaXMuX2ExMD1mdW5jdGlvbigpeyFhLm0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXRpX19oaWRlXCIpfHxhLmEuZGlzYWJsZWR8fGEuYS5yZWFkT25seXx8YS5fbigpfSx0aGlzLnNlbGVjdGVkRmxhZy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9hMTApLHRoaXMuX2ExMT1mdW5jdGlvbihiKXthLm0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXRpX19oaWRlXCIpJiYtMSE9PVtcIkFycm93VXBcIixcIkFycm93RG93blwiLFwiIFwiLFwiRW50ZXJcIl0uaW5kZXhPZihiLmtleSkmJihiLnByZXZlbnREZWZhdWx0KCksYi5zdG9wUHJvcGFnYXRpb24oKSxhLl9uKCkpLFwiVGFiXCI9PT1iLmtleSYmYS5fMigpfSx0aGlzLmsuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLl9hMTEpfX0se2tleTpcIl9pM1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGI9dGhpczt0aGlzLmQudXRpbHNTY3JpcHQmJiFhLmludGxUZWxJbnB1dFV0aWxzP2EuaW50bFRlbElucHV0R2xvYmFscy53aW5kb3dMb2FkZWQ/YS5pbnRsVGVsSW5wdXRHbG9iYWxzLmxvYWRVdGlscyh0aGlzLmQudXRpbHNTY3JpcHQpOmEuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbigpe2EuaW50bFRlbElucHV0R2xvYmFscy5sb2FkVXRpbHMoYi5kLnV0aWxzU2NyaXB0KX0pOnRoaXMuaTAoKSxcImF1dG9cIj09PXRoaXMuZC5pbml0aWFsQ291bnRyeT90aGlzLl9pNCgpOnRoaXMuaCgpfX0se2tleTpcIl9pNFwiLHZhbHVlOmZ1bmN0aW9uKCl7YS5pbnRsVGVsSW5wdXRHbG9iYWxzLmF1dG9Db3VudHJ5P3RoaXMuaGFuZGxlQXV0b0NvdW50cnkoKTphLmludGxUZWxJbnB1dEdsb2JhbHMuc3RhcnRlZExvYWRpbmdBdXRvQ291bnRyeXx8KGEuaW50bFRlbElucHV0R2xvYmFscy5zdGFydGVkTG9hZGluZ0F1dG9Db3VudHJ5PSEwLFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuZC5nZW9JcExvb2t1cCYmdGhpcy5kLmdlb0lwTG9va3VwKGZ1bmN0aW9uKGIpe2EuaW50bFRlbElucHV0R2xvYmFscy5hdXRvQ291bnRyeT1iLnRvTG93ZXJDYXNlKCksc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBuKFwiaGFuZGxlQXV0b0NvdW50cnlcIil9KX0sZnVuY3Rpb24oKXtyZXR1cm4gbihcInJlamVjdEF1dG9Db3VudHJ5UHJvbWlzZVwiKX0pKX19LHtrZXk6XCJfalwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLl9hMTI9ZnVuY3Rpb24oKXthLl92KGEuYS52YWx1ZSkmJmEuXzgoKX0sdGhpcy5hLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLHRoaXMuX2ExMiksdGhpcy5fYTEzPWZ1bmN0aW9uKCl7c2V0VGltZW91dChhLl9hMTIpfSx0aGlzLmEuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLHRoaXMuX2ExMyksdGhpcy5hLmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLHRoaXMuX2ExMyl9fSx7a2V5OlwiX2oyXCIsdmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hLmdldEF0dHJpYnV0ZShcIm1heGxlbmd0aFwiKTtyZXR1cm4gYiYmYS5sZW5ndGg+Yj9hLnN1YnN0cigwLGIpOmF9fSx7a2V5OlwiX2xcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXM7dGhpcy5fYTg9ZnVuY3Rpb24oKXthLl9sMigpfSx0aGlzLmEuZm9ybSYmdGhpcy5hLmZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLHRoaXMuX2E4KSx0aGlzLmEuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIix0aGlzLl9hOCl9fSx7a2V5OlwiX2wyXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZihcIitcIj09PXRoaXMuYS52YWx1ZS5jaGFyQXQoMCkpe3ZhciBhPXRoaXMuX20odGhpcy5hLnZhbHVlKTthJiZ0aGlzLnMuZGlhbENvZGUhPT1hfHwodGhpcy5hLnZhbHVlPVwiXCIpfX19LHtrZXk6XCJfbVwiLHZhbHVlOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UoL1xcRC9nLFwiXCIpfX0se2tleTpcIl9tMlwiLHZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBjPWIuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtjLmluaXRFdmVudChhLCEwLCEwKSx0aGlzLmEuZGlzcGF0Y2hFdmVudChjKX19LHtrZXk6XCJfblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5tLmNsYXNzTGlzdC5yZW1vdmUoXCJpdGlfX2hpZGVcIiksdGhpcy5tLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIixcInRydWVcIiksdGhpcy5fbygpLHRoaXMuYiYmKHRoaXMuX3godGhpcy5iLCExKSx0aGlzLl8zKHRoaXMuYiwhMCkpLHRoaXMuX3AoKSx0aGlzLnUuY2xhc3NMaXN0LmFkZChcIml0aV9fYXJyb3ctLXVwXCIpLHRoaXMuX20yKFwib3Blbjpjb3VudHJ5ZHJvcGRvd25cIil9fSx7a2V5OlwiX24yXCIsdmFsdWU6ZnVuY3Rpb24oYSxiLGMpe2MmJiFhLmNsYXNzTGlzdC5jb250YWlucyhiKT9hLmNsYXNzTGlzdC5hZGQoYik6IWMmJmEuY2xhc3NMaXN0LmNvbnRhaW5zKGIpJiZhLmNsYXNzTGlzdC5yZW1vdmUoYil9fSx7a2V5OlwiX29cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBjPXRoaXM7aWYodGhpcy5kLmRyb3Bkb3duQ29udGFpbmVyJiZ0aGlzLmQuZHJvcGRvd25Db250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kcm9wZG93biksIXRoaXMuZyl7dmFyIGQ9dGhpcy5hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGU9YS5wYWdlWU9mZnNldHx8Yi5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLGY9ZC50b3ArZSxnPXRoaXMubS5vZmZzZXRIZWlnaHQsaD1mK3RoaXMuYS5vZmZzZXRIZWlnaHQrZzxlK2EuaW5uZXJIZWlnaHQsaT1mLWc+ZTtpZih0aGlzLl9uMih0aGlzLm0sXCJpdGlfX2NvdW50cnktbGlzdC0tZHJvcHVwXCIsIWgmJmkpLHRoaXMuZC5kcm9wZG93bkNvbnRhaW5lcil7dmFyIGo9IWgmJmk/MDp0aGlzLmEub2Zmc2V0SGVpZ2h0O3RoaXMuZHJvcGRvd24uc3R5bGUudG9wPVwiXCIuY29uY2F0KGYraixcInB4XCIpLHRoaXMuZHJvcGRvd24uc3R5bGUubGVmdD1cIlwiLmNvbmNhdChkLmxlZnQrYi5ib2R5LnNjcm9sbExlZnQsXCJweFwiKSx0aGlzLl9hND1mdW5jdGlvbigpe3JldHVybiBjLl8yKCl9LGEuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMuX2E0KX19fX0se2tleTpcIl9vMlwiLHZhbHVlOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hO2ImJmIhPT10aGlzLm0mJiFiLmNsYXNzTGlzdC5jb250YWlucyhcIml0aV9fY291bnRyeVwiKTspYj1iLnBhcmVudE5vZGU7cmV0dXJuIGI9PT10aGlzLm0/bnVsbDpifX0se2tleTpcIl9wXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuX2EwPWZ1bmN0aW9uKGIpe3ZhciBjPWEuX28yKGIudGFyZ2V0KTtjJiZhLl94KGMsITEpfSx0aGlzLm0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLHRoaXMuX2EwKSx0aGlzLl9hMT1mdW5jdGlvbihiKXt2YXIgYz1hLl9vMihiLnRhcmdldCk7YyYmYS5fMShjKX0sdGhpcy5tLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2ExKTt2YXIgYz0hMDt0aGlzLl9hMj1mdW5jdGlvbigpe2N8fGEuXzIoKSxjPSExfSxiLmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9hMik7dmFyIGQ9XCJcIixlPW51bGw7dGhpcy5fYTM9ZnVuY3Rpb24oYil7Yi5wcmV2ZW50RGVmYXVsdCgpLFwiQXJyb3dVcFwiPT09Yi5rZXl8fFwiQXJyb3dEb3duXCI9PT1iLmtleT9hLl9xKGIua2V5KTpcIkVudGVyXCI9PT1iLmtleT9hLl9yKCk6XCJFc2NhcGVcIj09PWIua2V5P2EuXzIoKTovXlthLXpBLVrDgC3DvyBdJC8udGVzdChiLmtleSkmJihlJiZjbGVhclRpbWVvdXQoZSksZCs9Yi5rZXkudG9Mb3dlckNhc2UoKSxhLl9zKGQpLGU9c2V0VGltZW91dChmdW5jdGlvbigpe2Q9XCJcIn0sMWUzKSl9LGIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLl9hMyl9fSx7a2V5OlwiX3FcIix2YWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1cIkFycm93VXBcIj09PWE/dGhpcy5jLnByZXZpb3VzRWxlbWVudFNpYmxpbmc6dGhpcy5jLm5leHRFbGVtZW50U2libGluZztiJiYoYi5jbGFzc0xpc3QuY29udGFpbnMoXCJpdGlfX2RpdmlkZXJcIikmJihiPVwiQXJyb3dVcFwiPT09YT9iLnByZXZpb3VzRWxlbWVudFNpYmxpbmc6Yi5uZXh0RWxlbWVudFNpYmxpbmcpLHRoaXMuX3goYiwhMCkpfX0se2tleTpcIl9yXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmMmJnRoaXMuXzEodGhpcy5jKX19LHtrZXk6XCJfc1wiLHZhbHVlOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5wLmxlbmd0aDtiKyspaWYodGhpcy5fdCh0aGlzLnBbYl0ubmFtZSxhKSl7dmFyIGM9dGhpcy5tLnF1ZXJ5U2VsZWN0b3IoXCIjaXRpLWl0ZW0tXCIuY29uY2F0KHRoaXMucFtiXS5pc28yKSk7dGhpcy5feChjLCExKSx0aGlzLl8zKGMsITApO2JyZWFrfX19LHtrZXk6XCJfdFwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuc3Vic3RyKDAsYi5sZW5ndGgpLnRvTG93ZXJDYXNlKCk9PT1ifX0se2tleTpcIl91XCIsdmFsdWU6ZnVuY3Rpb24oYil7dmFyIGM9YjtpZih0aGlzLmQuZm9ybWF0T25EaXNwbGF5JiZhLmludGxUZWxJbnB1dFV0aWxzJiZ0aGlzLnMpe3ZhciBkPSF0aGlzLmQuc2VwYXJhdGVEaWFsQ29kZSYmKHRoaXMuZC5uYXRpb25hbE1vZGV8fFwiK1wiIT09Yy5jaGFyQXQoMCkpLGU9aW50bFRlbElucHV0VXRpbHMubnVtYmVyRm9ybWF0LGY9ZS5OQVRJT05BTCxnPWUuSU5URVJOQVRJT05BTCxoPWQ/ZjpnO2M9aW50bFRlbElucHV0VXRpbHMuZm9ybWF0TnVtYmVyKGMsdGhpcy5zLmlzbzIsaCl9Yz10aGlzLl83KGMpLHRoaXMuYS52YWx1ZT1jfX0se2tleTpcIl92XCIsdmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9YSxjPXRoaXMucy5kaWFsQ29kZSxkPVwiMVwiPT09YztiJiZ0aGlzLmQubmF0aW9uYWxNb2RlJiZkJiZcIitcIiE9PWIuY2hhckF0KDApJiYoXCIxXCIhPT1iLmNoYXJBdCgwKSYmKGI9XCIxXCIuY29uY2F0KGIpKSxiPVwiK1wiLmNvbmNhdChiKSksdGhpcy5kLnNlcGFyYXRlRGlhbENvZGUmJmMmJlwiK1wiIT09Yi5jaGFyQXQoMCkmJihiPVwiK1wiLmNvbmNhdChjKS5jb25jYXQoYikpO3ZhciBlPXRoaXMuXzUoYiksZj10aGlzLl9tKGIpLGc9bnVsbDtpZihlKXt2YXIgaD10aGlzLnFbdGhpcy5fbShlKV0saT0tMSE9PWguaW5kZXhPZih0aGlzLnMuaXNvMikmJmYubGVuZ3RoPD1lLmxlbmd0aC0xO2lmKCEoXCIxXCI9PT1jJiZ0aGlzLl93KGYpKSYmIWkpZm9yKHZhciBqPTA7ajxoLmxlbmd0aDtqKyspaWYoaFtqXSl7Zz1oW2pdO2JyZWFrfX1lbHNlXCIrXCI9PT1iLmNoYXJBdCgwKSYmZi5sZW5ndGg/Zz1cIlwiOmImJlwiK1wiIT09Ynx8KGc9dGhpcy5qKTtyZXR1cm4gbnVsbCE9PWcmJnRoaXMuX3ooZyl9fSx7a2V5OlwiX3dcIix2YWx1ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLl9tKGEpO2lmKFwiMVwiPT09Yi5jaGFyQXQoMCkpe3ZhciBjPWIuc3Vic3RyKDEsMyk7cmV0dXJuLTEhPT1sLmluZGV4T2YoYyl9cmV0dXJuITF9fSx7a2V5OlwiX3hcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuYztjJiZjLmNsYXNzTGlzdC5yZW1vdmUoXCJpdGlfX2hpZ2hsaWdodFwiKSx0aGlzLmM9YSx0aGlzLmMuY2xhc3NMaXN0LmFkZChcIml0aV9faGlnaGxpZ2h0XCIpLGImJnRoaXMuYy5mb2N1cygpfX0se2tleTpcIl95XCIsdmFsdWU6ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1iP2c6dGhpcy5wLGU9MDtlPGQubGVuZ3RoO2UrKylpZihkW2VdLmlzbzI9PT1hKXJldHVybiBkW2VdO2lmKGMpcmV0dXJuIG51bGw7dGhyb3cgbmV3IEVycm9yKFwiTm8gY291bnRyeSBkYXRhIGZvciAnXCIuY29uY2F0KGEsXCInXCIpKX19LHtrZXk6XCJfelwiLHZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMucy5pc28yP3RoaXMuczp7fTt0aGlzLnM9YT90aGlzLl95KGEsITEsITEpOnt9LHRoaXMucy5pc28yJiYodGhpcy5qPXRoaXMucy5pc28yKSx0aGlzLmwuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixcIml0aV9fZmxhZyBpdGlfX1wiLmNvbmNhdChhKSk7dmFyIGM9YT9cIlwiLmNvbmNhdCh0aGlzLnMubmFtZSxcIjogK1wiKS5jb25jYXQodGhpcy5zLmRpYWxDb2RlKTpcIlVua25vd25cIjtpZih0aGlzLnNlbGVjdGVkRmxhZy5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLGMpLHRoaXMuZC5zZXBhcmF0ZURpYWxDb2RlKXt2YXIgZD10aGlzLnMuZGlhbENvZGU/XCIrXCIuY29uY2F0KHRoaXMucy5kaWFsQ29kZSk6XCJcIjt0aGlzLnQuaW5uZXJIVE1MPWQ7dmFyIGU9dGhpcy5zZWxlY3RlZEZsYWcub2Zmc2V0V2lkdGh8fHRoaXMuX2dldEhpZGRlblNlbGVjdGVkRmxhZ1dpZHRoKCk7dGhpcy5hLnN0eWxlLnBhZGRpbmdMZWZ0PVwiXCIuY29uY2F0KGUrNixcInB4XCIpfWlmKHRoaXMuXzAoKSx0aGlzLmQuYWxsb3dEcm9wZG93bil7dmFyIGY9dGhpcy5iO2lmKGYmJihmLmNsYXNzTGlzdC5yZW1vdmUoXCJpdGlfX2FjdGl2ZVwiKSxmLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIixcImZhbHNlXCIpKSxhKXt2YXIgZz10aGlzLm0ucXVlcnlTZWxlY3RvcihcIiNpdGktaXRlbS1cIi5jb25jYXQoYSkpO2cuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLFwidHJ1ZVwiKSxnLmNsYXNzTGlzdC5hZGQoXCJpdGlfX2FjdGl2ZVwiKSx0aGlzLmI9Zyx0aGlzLm0uc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsZy5nZXRBdHRyaWJ1dGUoXCJpZFwiKSl9fXJldHVybiBiLmlzbzIhPT1hfX0se2tleTpcIl9nZXRIaWRkZW5TZWxlY3RlZEZsYWdXaWR0aFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5hLnBhcmVudE5vZGUuY2xvbmVOb2RlKCk7YS5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCIsYi5ib2R5LmFwcGVuZENoaWxkKGEpO3ZhciBjPXRoaXMuc2VsZWN0ZWRGbGFnLmNsb25lTm9kZSghMCk7YS5hcHBlbmRDaGlsZChjKTt2YXIgZD1jLm9mZnNldFdpZHRoO3JldHVybiBhLnJlbW92ZSgpLGR9fSx7a2V5OlwiXzBcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBiPVwiYWdncmVzc2l2ZVwiPT09dGhpcy5kLmF1dG9QbGFjZWhvbGRlcnx8IXRoaXMuZSYmXCJwb2xpdGVcIj09PXRoaXMuZC5hdXRvUGxhY2Vob2xkZXI7aWYoYS5pbnRsVGVsSW5wdXRVdGlscyYmYil7dmFyIGM9aW50bFRlbElucHV0VXRpbHMubnVtYmVyVHlwZVt0aGlzLmQucGxhY2Vob2xkZXJOdW1iZXJUeXBlXSxkPXRoaXMucy5pc28yP2ludGxUZWxJbnB1dFV0aWxzLmdldEV4YW1wbGVOdW1iZXIodGhpcy5zLmlzbzIsdGhpcy5kLm5hdGlvbmFsTW9kZSxjKTpcIlwiO2Q9dGhpcy5fNyhkKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLmQuY3VzdG9tUGxhY2Vob2xkZXImJihkPXRoaXMuZC5jdXN0b21QbGFjZWhvbGRlcihkLHRoaXMucykpLHRoaXMuYS5zZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiLGQpfX19LHtrZXk6XCJfMVwiLHZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX3ooYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvdW50cnktY29kZVwiKSk7dGhpcy5fMigpLHRoaXMuXzQoYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRpYWwtY29kZVwiKSwhMCksdGhpcy5hLmZvY3VzKCk7dmFyIGM9dGhpcy5hLnZhbHVlLmxlbmd0aDt0aGlzLmEuc2V0U2VsZWN0aW9uUmFuZ2UoYyxjKSxiJiZ0aGlzLl84KCl9fSx7a2V5OlwiXzJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMubS5jbGFzc0xpc3QuYWRkKFwiaXRpX19oaWRlXCIpLHRoaXMubS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsXCJmYWxzZVwiKSx0aGlzLnUuY2xhc3NMaXN0LnJlbW92ZShcIml0aV9fYXJyb3ctLXVwXCIpLGIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLl9hMyksYi5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fYTIpLHRoaXMubS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsdGhpcy5fYTApLHRoaXMubS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9hMSksdGhpcy5kLmRyb3Bkb3duQ29udGFpbmVyJiYodGhpcy5nfHxhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLl9hNCksdGhpcy5kcm9wZG93bi5wYXJlbnROb2RlJiZ0aGlzLmRyb3Bkb3duLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kcm9wZG93bikpLHRoaXMuX20yKFwiY2xvc2U6Y291bnRyeWRyb3Bkb3duXCIpfX0se2tleTpcIl8zXCIsdmFsdWU6ZnVuY3Rpb24oYyxkKXt2YXIgZT10aGlzLm0sZj1hLnBhZ2VZT2Zmc2V0fHxiLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsZz1lLm9mZnNldEhlaWdodCxoPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wK2YsaT1oK2csaj1jLm9mZnNldEhlaWdodCxrPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wK2YsbD1rK2osbT1rLWgrZS5zY3JvbGxUb3Asbj1nLzItai8yO2lmKGs8aClkJiYobS09biksZS5zY3JvbGxUb3A9bTtlbHNlIGlmKGw+aSl7ZCYmKG0rPW4pO3ZhciBvPWctajtlLnNjcm9sbFRvcD1tLW99fX0se2tleTpcIl80XCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPXRoaXMuYS52YWx1ZSxlPVwiK1wiLmNvbmNhdChhKTtpZihcIitcIj09PWQuY2hhckF0KDApKXt2YXIgZj10aGlzLl81KGQpO2M9Zj9kLnJlcGxhY2UoZixlKTplfWVsc2V7aWYodGhpcy5kLm5hdGlvbmFsTW9kZXx8dGhpcy5kLnNlcGFyYXRlRGlhbENvZGUpcmV0dXJuO2lmKGQpYz1lK2Q7ZWxzZXtpZighYiYmdGhpcy5kLmF1dG9IaWRlRGlhbENvZGUpcmV0dXJuO2M9ZX19dGhpcy5hLnZhbHVlPWN9fSx7a2V5OlwiXzVcIix2YWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1cIlwiO2lmKFwiK1wiPT09YS5jaGFyQXQoMCkpZm9yKHZhciBjPVwiXCIsZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgZT1hLmNoYXJBdChkKTtpZighaXNOYU4ocGFyc2VJbnQoZSwxMCkpJiYoYys9ZSx0aGlzLnFbY10mJihiPWEuc3Vic3RyKDAsZCsxKSksYy5sZW5ndGg9PT10aGlzLmRpYWxDb2RlTWF4TGVuKSlicmVha31yZXR1cm4gYn19LHtrZXk6XCJfNlwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5hLnZhbHVlLnRyaW0oKSxiPXRoaXMucy5kaWFsQ29kZSxjPXRoaXMuX20oYSk7cmV0dXJuKHRoaXMuZC5zZXBhcmF0ZURpYWxDb2RlJiZcIitcIiE9PWEuY2hhckF0KDApJiZiJiZjP1wiK1wiLmNvbmNhdChiKTpcIlwiKSthfX0se2tleTpcIl83XCIsdmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9YTtpZih0aGlzLmQuc2VwYXJhdGVEaWFsQ29kZSl7dmFyIGM9dGhpcy5fNShiKTtpZihjKXtjPVwiK1wiLmNvbmNhdCh0aGlzLnMuZGlhbENvZGUpO3ZhciBkPVwiIFwiPT09YltjLmxlbmd0aF18fFwiLVwiPT09YltjLmxlbmd0aF0/Yy5sZW5ndGgrMTpjLmxlbmd0aDtiPWIuc3Vic3RyKGQpfX1yZXR1cm4gdGhpcy5fajIoYil9fSx7a2V5OlwiXzhcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX20yKFwiY291bnRyeWNoYW5nZVwiKX19LHtrZXk6XCJoYW5kbGVBdXRvQ291bnRyeVwiLHZhbHVlOmZ1bmN0aW9uKCl7XCJhdXRvXCI9PT10aGlzLmQuaW5pdGlhbENvdW50cnkmJih0aGlzLmo9YS5pbnRsVGVsSW5wdXRHbG9iYWxzLmF1dG9Db3VudHJ5LHRoaXMuYS52YWx1ZXx8dGhpcy5zZXRDb3VudHJ5KHRoaXMuaiksdGhpcy5oKCkpfX0se2tleTpcImhhbmRsZVV0aWxzXCIsdmFsdWU6ZnVuY3Rpb24oKXthLmludGxUZWxJbnB1dFV0aWxzJiYodGhpcy5hLnZhbHVlJiZ0aGlzLl91KHRoaXMuYS52YWx1ZSksdGhpcy5fMCgpKSx0aGlzLmkwKCl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5hLmZvcm07aWYodGhpcy5kLmFsbG93RHJvcGRvd24pe3RoaXMuXzIoKSx0aGlzLnNlbGVjdGVkRmxhZy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9hMTApLHRoaXMuay5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuX2ExMSk7dmFyIGM9dGhpcy5faTEoKTtjJiZjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2E5KX10aGlzLmhpZGRlbklucHV0JiZiJiZiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIix0aGlzLl9hMTQpLHRoaXMuZC5hdXRvSGlkZURpYWxDb2RlJiYoYiYmYi5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VibWl0XCIsdGhpcy5fYTgpLHRoaXMuYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLHRoaXMuX2E4KSksdGhpcy5hLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLHRoaXMuX2ExMiksdGhpcy5hLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjdXRcIix0aGlzLl9hMTMpLHRoaXMuYS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFzdGVcIix0aGlzLl9hMTMpLHRoaXMuYS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWludGwtdGVsLWlucHV0LWlkXCIpO3ZhciBkPXRoaXMuYS5wYXJlbnROb2RlO2QucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5hLGQpLGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSxkZWxldGUgYS5pbnRsVGVsSW5wdXRHbG9iYWxzLmluc3RhbmNlc1t0aGlzLmlkXX19LHtrZXk6XCJnZXRFeHRlbnNpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBhLmludGxUZWxJbnB1dFV0aWxzP2ludGxUZWxJbnB1dFV0aWxzLmdldEV4dGVuc2lvbih0aGlzLl82KCksdGhpcy5zLmlzbzIpOlwiXCJ9fSx7a2V5OlwiZ2V0TnVtYmVyXCIsdmFsdWU6ZnVuY3Rpb24oYil7aWYoYS5pbnRsVGVsSW5wdXRVdGlscyl7dmFyIGM9dGhpcy5zLmlzbzI7cmV0dXJuIGludGxUZWxJbnB1dFV0aWxzLmZvcm1hdE51bWJlcih0aGlzLl82KCksYyxiKX1yZXR1cm5cIlwifX0se2tleTpcImdldE51bWJlclR5cGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBhLmludGxUZWxJbnB1dFV0aWxzP2ludGxUZWxJbnB1dFV0aWxzLmdldE51bWJlclR5cGUodGhpcy5fNigpLHRoaXMucy5pc28yKTotOTl9fSx7a2V5OlwiZ2V0U2VsZWN0ZWRDb3VudHJ5RGF0YVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc319LHtrZXk6XCJnZXRWYWxpZGF0aW9uRXJyb3JcIix2YWx1ZTpmdW5jdGlvbigpe2lmKGEuaW50bFRlbElucHV0VXRpbHMpe3ZhciBiPXRoaXMucy5pc28yO3JldHVybiBpbnRsVGVsSW5wdXRVdGlscy5nZXRWYWxpZGF0aW9uRXJyb3IodGhpcy5fNigpLGIpfXJldHVybi05OX19LHtrZXk6XCJpc1ZhbGlkTnVtYmVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLl82KCkudHJpbSgpLGM9dGhpcy5kLm5hdGlvbmFsTW9kZT90aGlzLnMuaXNvMjpcIlwiO3JldHVybiBhLmludGxUZWxJbnB1dFV0aWxzP2ludGxUZWxJbnB1dFV0aWxzLmlzVmFsaWROdW1iZXIoYixjKTpudWxsfX0se2tleTpcInNldENvdW50cnlcIix2YWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1hLnRvTG93ZXJDYXNlKCk7dGhpcy5sLmNsYXNzTGlzdC5jb250YWlucyhcIml0aV9fXCIuY29uY2F0KGIpKXx8KHRoaXMuX3ooYiksdGhpcy5fNCh0aGlzLnMuZGlhbENvZGUsITEpLHRoaXMuXzgoKSl9fSx7a2V5Olwic2V0TnVtYmVyXCIsdmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fdihhKTt0aGlzLl91KGEpLGImJnRoaXMuXzgoKX19LHtrZXk6XCJzZXRQbGFjZWhvbGRlck51bWJlclR5cGVcIix2YWx1ZTpmdW5jdGlvbihhKXt0aGlzLmQucGxhY2Vob2xkZXJOdW1iZXJUeXBlPWEsdGhpcy5fMCgpfX1dKSxlfSgpXG47YS5pbnRsVGVsSW5wdXRHbG9iYWxzLmdldENvdW50cnlEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIGd9O3ZhciBwPWZ1bmN0aW9uKGEsYyxkKXt2YXIgZT1iLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7ZS5vbmxvYWQ9ZnVuY3Rpb24oKXtuKFwiaGFuZGxlVXRpbHNcIiksYyYmYygpfSxlLm9uZXJyb3I9ZnVuY3Rpb24oKXtuKFwicmVqZWN0VXRpbHNTY3JpcHRQcm9taXNlXCIpLGQmJmQoKX0sZS5jbGFzc05hbWU9XCJpdGktbG9hZC11dGlsc1wiLGUuYXN5bmM9ITAsZS5zcmM9YSxiLmJvZHkuYXBwZW5kQ2hpbGQoZSl9O3JldHVybiBhLmludGxUZWxJbnB1dEdsb2JhbHMubG9hZFV0aWxzPWZ1bmN0aW9uKGIpe2lmKCFhLmludGxUZWxJbnB1dFV0aWxzJiYhYS5pbnRsVGVsSW5wdXRHbG9iYWxzLnN0YXJ0ZWRMb2FkaW5nVXRpbHNTY3JpcHQpe2lmKGEuaW50bFRlbElucHV0R2xvYmFscy5zdGFydGVkTG9hZGluZ1V0aWxzU2NyaXB0PSEwLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlKXJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihhLGMpe3JldHVybiBwKGIsYSxjKX0pO3AoYil9cmV0dXJuIG51bGx9LGEuaW50bFRlbElucHV0R2xvYmFscy5kZWZhdWx0cz1rLGEuaW50bFRlbElucHV0R2xvYmFscy52ZXJzaW9uPVwiMTYuMC4wXCIsZnVuY3Rpb24oYixjKXt2YXIgZD1uZXcgbyhiLGMpO3JldHVybiBkLl9pbml0KCksYi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWludGwtdGVsLWlucHV0LWlkXCIsZC5pZCksYS5pbnRsVGVsSW5wdXRHbG9iYWxzLmluc3RhbmNlc1tkLmlkXT1kLGR9fSgpfSh3aW5kb3csZG9jdW1lbnQpO1wib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWI6d2luZG93LmludGxUZWxJbnB1dD1ifSgpOyIsIi8qIVxuICBab29tIDEuNy4yMVxuICBsaWNlbnNlOiBNSVRcbiAgaHR0cDovL3d3dy5qYWNrbG1vb3JlLmNvbS96b29tXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICB1cmw6IGZhbHNlLFxuICAgIGNhbGxiYWNrOiBmYWxzZSxcbiAgICB0YXJnZXQ6IGZhbHNlLFxuICAgIGR1cmF0aW9uOiAxMjAsXG4gICAgb246ICdtb3VzZW92ZXInLCAvLyBvdGhlciBvcHRpb25zOiBncmFiLCBjbGljaywgdG9nZ2xlXG4gICAgdG91Y2g6IHRydWUsIC8vIGVuYWJsZXMgYSB0b3VjaCBmYWxsYmFja1xuICAgIG9uWm9vbUluOiBmYWxzZSxcbiAgICBvblpvb21PdXQ6IGZhbHNlLFxuICAgIG1hZ25pZnk6IDFcbiAgfTtcblxuICAvLyBDb3JlIFpvb20gTG9naWMsIGluZGVwZW5kZW50IG9mIGV2ZW50IGxpc3RlbmVycy5cbiAgJC56b29tID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBpbWcsIG1hZ25pZnkpIHtcbiAgICB2YXIgdGFyZ2V0SGVpZ2h0LFxuICAgICAgdGFyZ2V0V2lkdGgsXG4gICAgICBzb3VyY2VIZWlnaHQsXG4gICAgICBzb3VyY2VXaWR0aCxcbiAgICAgIHhSYXRpbyxcbiAgICAgIHlSYXRpbyxcbiAgICAgIG9mZnNldCxcbiAgICAgICR0YXJnZXQgPSAkKHRhcmdldCksXG4gICAgICBwb3NpdGlvbiA9ICR0YXJnZXQuY3NzKCdwb3NpdGlvbicpLFxuICAgICAgJHNvdXJjZSA9ICQoc291cmNlKTtcblxuICAgIC8vIFRoZSBwYXJlbnQgZWxlbWVudCBuZWVkcyBwb3NpdGlvbmluZyBzbyB0aGF0IHRoZSB6b29tZWQgZWxlbWVudCBjYW4gYmUgY29ycmVjdGx5IHBvc2l0aW9uZWQgd2l0aGluLlxuICAgIHRhcmdldC5zdHlsZS5wb3NpdGlvbiA9IC8oYWJzb2x1dGV8Zml4ZWQpLy50ZXN0KHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogJ3JlbGF0aXZlJztcbiAgICB0YXJnZXQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBpbWcuc3R5bGUud2lkdGggPSBpbWcuc3R5bGUuaGVpZ2h0ID0gJyc7XG5cbiAgICAkKGltZylcbiAgICAgIC5hZGRDbGFzcygnem9vbUltZycpXG4gICAgICAuY3NzKHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgd2lkdGg6IGltZy53aWR0aCAqIG1hZ25pZnksXG4gICAgICAgIGhlaWdodDogaW1nLmhlaWdodCAqIG1hZ25pZnksXG4gICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICBtYXhXaWR0aDogJ25vbmUnLFxuICAgICAgICBtYXhIZWlnaHQ6ICdub25lJ1xuICAgICAgfSlcbiAgICAgIC5hcHBlbmRUbyh0YXJnZXQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGFyZ2V0V2lkdGggPSAkdGFyZ2V0Lm91dGVyV2lkdGgoKTtcbiAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gJHRhcmdldC5vdXRlckhlaWdodCgpO1xuXG4gICAgICAgIGlmIChzb3VyY2UgPT09IHRhcmdldCkge1xuICAgICAgICAgIHNvdXJjZVdpZHRoID0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgc291cmNlSGVpZ2h0ID0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvdXJjZVdpZHRoID0gJHNvdXJjZS5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgc291cmNlSGVpZ2h0ID0gJHNvdXJjZS5vdXRlckhlaWdodCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgeFJhdGlvID0gKGltZy53aWR0aCAtIHRhcmdldFdpZHRoKSAvIHNvdXJjZVdpZHRoO1xuICAgICAgICB5UmF0aW8gPSAoaW1nLmhlaWdodCAtIHRhcmdldEhlaWdodCkgLyBzb3VyY2VIZWlnaHQ7XG5cbiAgICAgICAgb2Zmc2V0ID0gJHNvdXJjZS5vZmZzZXQoKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbGVmdCA9IChlLnBhZ2VYIC0gb2Zmc2V0LmxlZnQpLFxuICAgICAgICAgIHRvcCA9IChlLnBhZ2VZIC0gb2Zmc2V0LnRvcCk7XG5cbiAgICAgICAgdG9wID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCBzb3VyY2VIZWlnaHQpLCAwKTtcbiAgICAgICAgbGVmdCA9IE1hdGgubWF4KE1hdGgubWluKGxlZnQsIHNvdXJjZVdpZHRoKSwgMCk7XG5cbiAgICAgICAgaW1nLnN0eWxlLmxlZnQgPSAobGVmdCAqIC14UmF0aW8pICsgJ3B4JztcbiAgICAgICAgaW1nLnN0eWxlLnRvcCA9ICh0b3AgKiAteVJhdGlvKSArICdweCc7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAkLmZuLnpvb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyXG4gICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KSxcbiAgICAgICAgLy90YXJnZXQgd2lsbCBkaXNwbGF5IHRoZSB6b29tZWQgaW1hZ2VcbiAgICAgICAgdGFyZ2V0ID0gc2V0dGluZ3MudGFyZ2V0ICYmICQoc2V0dGluZ3MudGFyZ2V0KVswXSB8fCB0aGlzLFxuICAgICAgICAvL3NvdXJjZSB3aWxsIHByb3ZpZGUgem9vbSBsb2NhdGlvbiBpbmZvICh0aHVtYm5haWwpXG4gICAgICAgIHNvdXJjZSA9IHRoaXMsXG4gICAgICAgICRzb3VyY2UgPSAkKHNvdXJjZSksXG4gICAgICAgIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpLFxuICAgICAgICAkaW1nID0gJChpbWcpLFxuICAgICAgICBtb3VzZW1vdmUgPSAnbW91c2Vtb3ZlLnpvb20nLFxuICAgICAgICBjbGlja2VkID0gZmFsc2UsXG4gICAgICAgIHRvdWNoZWQgPSBmYWxzZTtcblxuICAgICAgLy8gSWYgYSB1cmwgd2Fzbid0IHNwZWNpZmllZCwgbG9vayBmb3IgYW4gaW1hZ2UgZWxlbWVudC5cbiAgICAgIGlmICghc2V0dGluZ3MudXJsKSB7XG4gICAgICAgIHZhciBzcmNFbGVtZW50ID0gc291cmNlLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgICAgICBpZiAoc3JjRWxlbWVudCkge1xuICAgICAgICAgIHNldHRpbmdzLnVybCA9IHNyY0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpIHx8IHNyY0VsZW1lbnQuY3VycmVudFNyYyB8fCBzcmNFbGVtZW50LnNyYztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNldHRpbmdzLnVybCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkc291cmNlLm9uZSgnem9vbS5kZXN0cm95JywgZnVuY3Rpb24gKHBvc2l0aW9uLCBvdmVyZmxvdykge1xuICAgICAgICAkc291cmNlLm9mZihcIi56b29tXCIpO1xuICAgICAgICB0YXJnZXQuc3R5bGUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIGltZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICAkaW1nLnJlbW92ZSgpO1xuICAgICAgfS5iaW5kKHRoaXMsIHRhcmdldC5zdHlsZS5wb3NpdGlvbiwgdGFyZ2V0LnN0eWxlLm92ZXJmbG93KSk7XG5cbiAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB6b29tID0gJC56b29tKHRhcmdldCwgc291cmNlLCBpbWcsIHNldHRpbmdzLm1hZ25pZnkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0KGUpIHtcbiAgICAgICAgICB6b29tLmluaXQoKTtcbiAgICAgICAgICB6b29tLm1vdmUoZSk7XG5cbiAgICAgICAgICAvLyBTa2lwIHRoZSBmYWRlLWluIGZvciBJRTggYW5kIGxvd2VyIHNpbmNlIGl0IGNob2tlcyBvbiBmYWRpbmctaW5cbiAgICAgICAgICAvLyBhbmQgY2hhbmdpbmcgcG9zaXRpb24gYmFzZWQgb24gbW91c2Vtb3ZlbWVudCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICRpbWcuc3RvcCgpXG4gICAgICAgICAgICAuZmFkZVRvKCQuc3VwcG9ydC5vcGFjaXR5ID8gc2V0dGluZ3MuZHVyYXRpb24gOiAwLCAxLCAkLmlzRnVuY3Rpb24oc2V0dGluZ3Mub25ab29tSW4pID8gc2V0dGluZ3Mub25ab29tSW4uY2FsbChpbWcpIDogZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAkaW1nLnN0b3AoKVxuICAgICAgICAgICAgLmZhZGVUbyhzZXR0aW5ncy5kdXJhdGlvbiwgMCwgJC5pc0Z1bmN0aW9uKHNldHRpbmdzLm9uWm9vbU91dCkgPyBzZXR0aW5ncy5vblpvb21PdXQuY2FsbChpbWcpIDogZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW91c2UgZXZlbnRzXG4gICAgICAgIGlmIChzZXR0aW5ncy5vbiA9PT0gJ2dyYWInKSB7XG4gICAgICAgICAgJHNvdXJjZVxuICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24uem9vbScsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uZSgnbW91c2V1cC56b29tJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3AoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZihtb3VzZW1vdmUsIHpvb20ubW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgIHN0YXJ0KGUpO1xuXG4gICAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5vbihtb3VzZW1vdmUsIHpvb20ubW92ZSk7XG5cbiAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mub24gPT09ICdjbGljaycpIHtcbiAgICAgICAgICAkc291cmNlLm9uKCdjbGljay56b29tJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmIChjbGlja2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gYnViYmxlIHRoZSBldmVudCB1cCB0byB0aGUgZG9jdW1lbnQgdG8gdHJpZ2dlciB0aGUgdW5iaW5kLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGlja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFydChlKTtcbiAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5vbihtb3VzZW1vdmUsIHpvb20ubW92ZSk7XG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkub25lKCdjbGljay56b29tJyxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjbGlja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZihtb3VzZW1vdmUsIHpvb20ubW92ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9uID09PSAndG9nZ2xlJykge1xuICAgICAgICAgICRzb3VyY2Uub24oJ2NsaWNrLnpvb20nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGNsaWNrZWQpIHtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2xpY2tlZCA9ICFjbGlja2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mub24gPT09ICdtb3VzZW92ZXInKSB7XG4gICAgICAgICAgem9vbS5pbml0KCk7IC8vIFByZWVtcHRpdmVseSBjYWxsIGluaXQgYmVjYXVzZSBJRTcgd2lsbCBmaXJlIHRoZSBtb3VzZW1vdmUgaGFuZGxlciBiZWZvcmUgdGhlIGhvdmVyIGhhbmRsZXIuXG5cbiAgICAgICAgICAkc291cmNlXG4gICAgICAgICAgICAub24oJ21vdXNlZW50ZXIuem9vbScsIHN0YXJ0KVxuICAgICAgICAgICAgLm9uKCdtb3VzZWxlYXZlLnpvb20nLCBzdG9wKVxuICAgICAgICAgICAgLm9uKG1vdXNlbW92ZSwgem9vbS5tb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvdWNoIGZhbGxiYWNrXG4gICAgICAgIGlmIChzZXR0aW5ncy50b3VjaCkge1xuICAgICAgICAgICRzb3VyY2VcbiAgICAgICAgICAgIC5vbigndG91Y2hzdGFydC56b29tJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBpZiAodG91Y2hlZCkge1xuICAgICAgICAgICAgICAgIHRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG91Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhcnQoZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0gfHwgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbigndG91Y2htb3ZlLnpvb20nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIHpvb20ubW92ZShlLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXSB8fCBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbigndG91Y2hlbmQuem9vbScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgaWYgKHRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgICB0b3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24oc2V0dGluZ3MuY2FsbGJhY2spKSB7XG4gICAgICAgICAgc2V0dGluZ3MuY2FsbGJhY2suY2FsbChpbWcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpbWcuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xuICAgICAgaW1nLmFsdCA9ICcnO1xuICAgICAgaW1nLnNyYyA9IHNldHRpbmdzLnVybDtcbiAgICB9KTtcbiAgfTtcblxuICAkLmZuLnpvb20uZGVmYXVsdHMgPSBkZWZhdWx0cztcbn0od2luZG93LmpRdWVyeSkpOyIsIi8qIVxuKiBjb3VudHJ5LXJlZ2lvbi1zZWxlY3RvclxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogMS4wLjBcbiogQGF1dGhvciBCZW4gS2VlblxuKiBAcmVwbyBodHRwczovL2dpdGh1Yi5jb20vYmVua2Vlbi9jb3VudHJ5LXJlZ2lvbi1zZWxlY3RvclxuKiBAbGljZW5jZSBNSVRcbiovXG5cbiFmdW5jdGlvbiAoYSwgbikgeyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKFtdLCBuKTsgZWxzZSBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cykgdHJ5IHsgbW9kdWxlLmV4cG9ydHMgPSBuKHJlcXVpcmUoKSkgfSBjYXRjaCAoYSkgeyBtb2R1bGUuZXhwb3J0cyA9IG4oKSB9IGVsc2UgYS5jcnMgPSBuKCkgfSh0aGlzLCBmdW5jdGlvbiAoKSB7IFwidXNlIHN0cmljdFwiOyB2YXIgbSA9ICEwLCBoID0gITAsIE0gPSBbXSwgbCA9IFtbXCJBZmdoYW5pc3RhblwiLCBcIkFGXCIsIFwiQmFkYWtoc2hhbn5CRFN8QmFkZ2hpc35CREd8QmFnaGxhbn5CR0x8QmFsa2h+QkFMfEJhbXlhbn5CQU18RGF5a3VuZGl+REFZfEZhcmFofkZSQXxGYXJ5YWJ+RllCfEdoYXpuaX5HSEF8R2hvcn5HSE98SGVsbWFuZH5IRUx8SGVyYXR+SEVSfEpvd3pqYW5+Sk9XfEthYnVsfktBQnxLYW5kYWhhcn5LQU58S2FwaXNhfktBUHxLaG9zdH5LSE98S3VuYXJ+S05SfEt1bmR1en5LRFp8TGFnaG1hbn5MQUd8TG9nYXJ+TE9XfE1haWRhbiBXYXJkYWt+V0FSfE5hbmdhcmhhcn5OQU58TmltcnV6fk5JTXxOdXJpc3Rhbn5OVVJ8UGFrdGlhflBJQXxQYWt0aWthflBLQXxQYW5qc2hpcn5QQU58UGFyd2FuflBBUnxTYW1hbmdhbn5TQU18U2FyLWUgUG9sflNBUnxUYWtoYXJ+VEFLfFVyb3pnYW5+T1JVfFphYnVsflpBQlwiXSwgW1wiw4VsYW5kIElzbGFuZHNcIiwgXCJBWFwiLCBcIkJyw6RuZMO2fkJSfEVja2Vyw7Z+RUN8Rmluc3Ryw7ZtfkZOfEbDtmdsw7Z+Rkd8R2V0YX5HVHxIYW1tYXJsYW5kfkhNfEpvbWFsYX5KTXxLdW1saW5nZX5LTXxLw7ZrYXJ+S0t8TGVtbGFuZH5MRXxMdW1wYXJsYW5kfkxVfE1hcmllaGFtbn5NSHxTYWx0dmlrflNWfFNvdHR1bmdhflNUfFN1bmR+U0R8VsOlcmTDtn5WUlwiXSwgW1wiQWxiYW5pYVwiLCBcIkFMXCIsIFwiQmVyYXR+MDF8RGliw6tyfjA5fER1cnLDq3N+MDJ8RWxiYXNhbn4wM3xGaWVyfjA0fEdqaXJva2FzdMOrcn4wNXxLb3LDp8OrfjA2fEt1a8Orc34wN3xMZXpow6t+MDh8U2hrb2TDq3J+MTB8VGlyYW5hfjExfFZsb3LDq34xMlwiXSwgW1wiQWxnZXJpYVwiLCBcIkRaXCIsIFwiQWRyYXJ+MDF8QcOvbiBEZWZsYX40NHxBw69uIFTDqW1vdWNoZW50fjQ2fEFsZ2llcnN+MTZ8QW5uYWJhfjIzfEJhdG5hfjA1fELDqWNoYXJ+MDh8QsOpamHDr2F+MDZ8Qmlza3JhfjA3fEJsaWRhfjA5fEJvcmRqIEJvdSBBcnLDqXJpZGp+MzR8Qm91w69yYX4xMHxCb3VtZXJkw6hzfjM1fENobGVmfjAyfENvbnN0YW50aW5lfjI1fERqZWxmYX4xN3xFbCBCYXlhZGh+MzJ8RWwgT3VlZH4zOXxFbCBUYXJmfjM2fEdoYXJkYcOvYX40N3xHdWVsbWF+MjR8SWxsaXppfjMzfEppamVsfjE4fEtoZW5jaGVsYX40MHxMYWdob3VhdH4wM3xNYXNjYXJhfjI5fE3DqWTDqWF+MjZ8TWlsYX40M3xNb3N0YWdhbmVtfjI3fE1zaWxhfjI4fE5hw6JtYX40NXxPcmFufjMxfE91YXJnbGF+MzB8T3VtIGVsIEJvdWFnaGl+MDR8UmVsaXphbmV+NDh8U2HDr2RhfjIwfFPDqXRpZn4xOXxTaWRpIEJlbCBBYmLDqHN+MjJ8U2tpa2RhfjIxfFNvdWsgQWhyYXN+NDF8VGFtYW5naGFzc2V0fjExfFTDqWJlc3NhfjEyfFRpYXJldH4xNHxUaW5kb3VmfjM3fFRpcGF6YX40MnxUaXNzZW1zaWx0fjM4fFRpemkgT3V6b3V+MTV8VGxlbWNlbn4xM1wiXSwgW1wiQW1lcmljYW4gU2Ftb2FcIiwgXCJBU1wiLCBcIlR1dHVpbGF+MDF8QXVudSd1fjAyfFRhJ8WrfjAzfE9mdeKAkU9sb3NlZ2F+MDR8Um9zZSBBdG9sbH4yMXxTd2FpbnMgSXNsYW5kfjIyXCJdLCBbXCJBbmRvcnJhXCIsIFwiQURcIiwgXCJBbmRvcnJhIGxhIFZlbGxhfjA3fENhbmlsbG9+MDJ8RW5jYW1wfjAzfEVzY2FsZGVzLUVuZ29yZGFueX4wOHxMYSBNYXNzYW5hfjA0fE9yZGlub34wNXxTYW50IEp1bGnDoCBkZSBMw7JyaWF+MDZcIl0sIFtcIkFuZ29sYVwiLCBcIkFPXCIsIFwiQmVuZ29+QkdPfEJlbmd1ZWxhfkJHVXxCacOpfkJJRXxDYWJpbmRhfkNBQnxDdWFuZG8gQ3ViYW5nb35DQ1V8Q3VhbnphIE5vcnRlfkNOT3xDdWFuemEgU3VsfkNVU3xDdW5lbmV+Q05OfEh1YW1ib35IVUF8SHXDrWxhfkhVSXxMdWFuZGF+TFVBfEx1bmRhIE5vcnRlfkxOT3xMdW5kYSBTdWx+TFNVfE1hbGFuamV+TUFMfE1veGljb35NT1h8TmFtaWJlfk5BTXxVw61nZX5VSUd8WmFpcmV+WkFJXCJdLCBbXCJBbmd1aWxsYVwiLCBcIkFJXCIsIFwiQW5ndWlsbGF+MDF8QW5ndWlsbGl0YSBJc2xhbmR+MDJ8Qmxvd2luZyBSb2NrfjAzfENvdmUgQ2F5fjA0fENyb2N1cyBDYXl+MDV8RGVhZG1hbidzIENheX4wNnxEb2cgSXNsYW5kfjA3fEVhc3QgQ2F5fjA4fExpdHRsZSBJc2xhbmR+MDl8TGl0dGxlIFNjcnViIElzbGFuZH4xMHxNaWQgQ2F5fjExfE5vcnRoIENheX4xMnxQcmlja2x5IFBlYXIgQ2F5c34xM3xSYWJiaXQgSXNsYW5kfjE0fFNhbmR5IElzbGFuZC9TYW5kIElzbGFuZH4xNXxTY2lsbHkgQ2F5fjE2fFNjcnViIElzbGFuZH4xN3xTZWFsIElzbGFuZH4xOHxTb21icmVyby9IYXQgSXNsYW5kfjE5fFNvdXRoIENheX4yMHxTb3V0aCBXYWdlciBJc2xhbmR+MjF8V2VzdCBDYXl+MjJcIl0sIFtcIkFudGFyY3RpY2FcIiwgXCJBUVwiLCBcIkFudGFyY3RpY2F+QVFcIl0sIFtcIkFudGlndWEgYW5kIEJhcmJ1ZGFcIiwgXCJBR1wiLCBcIkFudGlndWEgSXNsYW5kfjAxfEJhcmJ1ZGEgSXNsYW5kfjAyfEJpcmQgSXNsYW5kfjA0fEJpc2hvcCBJc2xhbmR+MDV8Qmxha2UgSXNsYW5kfjA2fENydW1wIElzbGFuZH4wOXxEdWxjaW5hIElzbGFuZH4xMHxFeGNoYW5nZSBJc2xhbmR+MTF8Rml2ZSBJc2xhbmRzfjEyfEdyZWF0IEJpcmQgSXNsYW5kfjEzfEdyZWVuIElzbGFuZH4xNHxHdWlhbmEgSXNsYW5kfjE1fEhhd2VzIElzbGFuZH4xN3xIZWxscyBHYXRlIElzbGFuZH4xNnxIZW5yeSBJc2xhbmR+MTh8Sm9obnNvbiBJc2xhbmR+MTl8S2lkIElzbGFuZH4yMHxMb2JzdGVyIElzbGFuZH4yMnxNYWlkZW4gSXNsYW5kfjI0fE1vb3IgSXNsYW5kfjI1fE5hbm55IElzbGFuZH4yNnxQZWxpY2FuIElzbGFuZH4yN3xQcmlja2x5IFBlYXIgSXNsYW5kfjI4fFJhYmJpdCBJc2xhbmR+Mjl8UmVkIEhlYWQgSXNsYW5kfjMxfFJlZG9uZGEgSXNsYW5kfjAzfFNhbmR5IElzbGFuZH4zMnxTbWl0aCBJc2xhbmR+MzN8VGhlIFNpc3RlcnN+MzR8VmVybm9uIElzbGFuZH4zNXxXaWNrZWQgV2lsbCBJc2xhbmR+MzZ8WW9yayBJc2xhbmR+MzdcIl0sIFtcIkFyZ2VudGluYVwiLCBcIkFSXCIsIFwiQnVlbm9zIEFpcmVzfkJ8Q2FwaXRhbCBGZWRlcmFsfkN8Q2F0YW1hcmNhfkt8Q2hhY29+SHxDaHVidXR+VXxDw7NyZG9iYX5YfENvcnJpZW50ZXN+V3xFbnRyZSBSw61vc35FfEZvcm1vc2F+UHxKdWp1eX5ZfExhIFBhbXBhfkx8TGEgUmlvamF+RnxNZW5kb3phfk18TWlzaW9uZXN+TnxOZXVxdcOpbn5RfFLDrW8gTmVncm9+UnxTYWx0YX5BfFNhbiBKdWFufkp8U2FuIEx1aXN+RHxTYW50YSBDcnV6flp8U2FudGEgRmV+U3xTYW50aWFnbyBkZWwgRXN0ZXJvfkd8VGllcnJhIGRlbCBGdWVnb35WfFR1Y3Vtw6FuflRcIl0sIFtcIkFybWVuaWFcIiwgXCJBTVwiLCBcIkFyYWdhdHNvdG5+QUd8QXJhcmF0fkFSfEFybWF2aXJ+QVZ8R2VnaGFya3VuaWt+R1J8S290YXlrfktUfExvcml+TE98U2hpcmFrflNIfFN5dW5pa35TVXxUYXZ1c2h+VFZ8VmF5b3RzIER6b3J+VkR8WWVyZXZhbn5FUlwiXSwgW1wiQXJ1YmFcIiwgXCJBV1wiLCBcIkFydWJhfkFXXCJdLCBbXCJBdXN0cmFsaWFcIiwgXCJBVVwiLCBcIkF1c3RyYWxpYW4gQ2FwaXRhbCBUZXJyaXRvcnl+QUNUfE5ldyBTb3V0aCBXYWxlc35OU1d8Tm9ydGhlcm4gVGVycml0b3J5fk5UfFF1ZWVuc2xhbmR+UUxEfFNvdXRoIEF1c3RyYWxpYX5TQXxUYXNtYW5pYX5UQVN8VmljdG9yaWF+VklDfFdlc3Rlcm4gQXVzdHJhbGlhfldBXCJdLCBbXCJBdXN0cmlhXCIsIFwiQVRcIiwgXCJCdXJnZW5sYW5kfjF8S8Okcm50ZW5+MnxOaWVkZXLDtnN0ZXJyZWljaH4zfE9iZXLDtnN0ZXJyZWljaH40fFNhbHpidXJnfjV8U3RlaWVybWFya342fFRpcm9sfjd8Vm9yYXJsYmVyZ344fFdpZW5+OVwiXSwgW1wiQXplcmJhaWphblwiLCBcIkFaXCIsIFwiQWLFn2Vyb25+QUJTfEHEn2NhYsmZZGl+QUdDfEHEn2RhbX5BR018QcSfZGHFn35BR1N8QcSfc3RhZmF+QUdBfEHEn3N1fkFHVXxBc3RhcmF+QVNUfEJhYsmZa35CQUJ8QmFsYWvJmW5+QkFMfELJmXJkyZl+QkFSfEJleWzJmXFhbn5CRVl8QmlsyZlzdXZhcn5CSUx8Q8mZYnJhecSxbH5DQUJ8Q8mZbGlsYWJhZH5DQUx8Q3VsZmF+Q1VMfERhxZ9ryZlzyZlufkRBU3xGw7x6dWxpfkZVWnxHyZlkyZliyZl5fkdBRHxHb3JhbmJveX5HT1J8R8O2ecOnYXl+R09ZfEfDtnlnw7ZsfkdZR3xIYWPEsXFhYnVsfkhBQ3zEsG1pxZ9saX5JTUl8xLBzbWF5xLFsbMSxfklTTXxLyZlsYsmZY8mZcn5LQUx8S8edbmfHnXJsaX5LQU58S8O8cmTJmW1pcn5LVVJ8TGHDp8Sxbn5MQUN8TMmZbmvJmXJhbn5MQU58TGVyaWt+TEVSfE1hc2FsbMSxfk1BU3xOZWZ0w6dhbGF+TkVGfE/En3V6fk9HVXxPcmR1YmFkfk9SRHxRyZliyZlsyZl+UUFCfFFheH5RQVh8UWF6YXh+UUFafFFvYnVzdGFuflFPQnxRdWJhflFCQXxRdWJhZGxpflFCSXxRdXNhcn5RVVN8U2FhdGzEsX5TQVR8U2FiaXJhYmFkflNBQnzFnmFicmFuflNCTnxTyZlkyZlyyZlrflNBRHzFnmFoYnV6flNBSHzFnsmZa2l+U0FLfFNhbHlhbn5TQUx8xZ5hbWF4xLF+U01JfMWeyZlta2lyflNLUnxTYW11eH5TTVh8xZ7JmXJ1cn5TQVJ8U2l5yZl6yZluflNJWXzFnnXFn2F+U1VTfFTJmXJ0yZlyflRBUnxUb3Z1en5UT1Z8VWNhcn5VQ0F8WGHDp21hen5YQUN8WMSxesSxflhJWnxYb2NhbMSxflhDSXxYb2NhdsmZbmR+WFZEfFlhcmTEsW1sxLF+WUFSfFlldmxheH5ZRVZ8WsmZbmdpbGFuflpBTnxaYXFhdGFsYX5aQVF8WsmZcmRhYn5aQVJcIl0sIFtcIkJhaGFtYXNcIiwgXCJCU1wiLCBcIkFja2xpbnMgSXNsYW5kfjAxfEJlcnJ5IElzbGFuZHN+MjJ8QmltaW5pfjAyfEJsYWNrIFBvaW50fjIzfENhdCBJc2xhbmR+MDN8Q2VudHJhbCBBYmFjb34yNHxDcm9va2VkIElzbGFuZCBhbmQgTG9uZyBDYXl+Mjh8RWFzdCBHcmFuZCBCYWhhbWF+Mjl8RXh1bWF+MDR8RnJlZXBvcnR+MDV8RnJlc2ggQ3JlZWt+MDZ8R292ZXJub3IncyBIYXJib3VyfjA3fEdyZWVuIFR1cnRsZSBDYXl+MDh8SGFyYm91ciBJc2xhbmR+MDl8SGlnaCBSb2NrfjEwfEluYWd1YX4xMXxLZW1wcyBCYXl+MTJ8TG9uZyBJc2xhbmR+MTN8TWFyc2ggSGFyYm91cn4xNHxNYXlhZ3VhbmF+MTV8TW9vcmXigJlzIElzbGFuZH40MHxOZXcgUHJvdmlkZW5jZX4xNnxOaWNob2xsc3Rvd24gYW5kIEJlcnJ5IElzbGFuZHN+MTd8Tm9ydGggQWJhY29+NDJ8Tm9ydGggQW5kcm9zfjQxfE5vcnRoIEVsZXV0aGVyYX4zM3xSYWdnZWQgSXNsYW5kfjE4fFJvY2sgU291bmR+MTl8U2FuIFNhbHZhZG9yIGFuZCBSdW0gQ2F5fjIwfFNhbmR5IFBvaW50fjIxfFNvdXRoIEFiYWNvfjM1fFNvdXRoIEFuZHJvc34zNnxTb3V0aCBFbGV1dGhlcmF+Mzd8V2VzdCBHcmFuZCBCYWhhbWF+MzlcIl0sIFtcIkJhaHJhaW5cIiwgXCJCSFwiLCBcIkFsIEphbsWrYsSreWFofjE0fEFsIE1hbsSBbWFofjEzfEFsIE114bipYXJyYXF+MTV8QWwgV3VzxaPDoX4xNnxBc2ggU2hhbcSBbMSreWFofjE3XCJdLCBbXCJCYW5nbGFkZXNoXCIsIFwiQkRcIiwgXCJCYXJpc2FsfkF8Q2hpdHRhZ29uZ35CfERoYWthfkN8S2h1bG5hfkR8TXltZW5zaW5naH5NfFJhanNoYWhpfkV8UmFuZ3B1cn5GfFN5bGhldH5HXCJdLCBbXCJCYXJiYWRvc1wiLCBcIkJCXCIsIFwiQ2hyaXN0IENodXJjaH4wMXxTYWludCBBbmRyZXd+MDJ8U2FpbnQgR2VvcmdlfjAzfFNhaW50IEphbWVzfjA0fFNhaW50IEpvaG5+MDV8U2FpbnQgSm9zZXBofjA2fFNhaW50IEx1Y3l+MDd8U2FpbnQgTWljaGFlbH4wOHxTYWludCBQZXRlcn4wOXxTYWludCBQaGlsaXB+MTB8U2FpbnQgVGhvbWFzfjExXCJdLCBbXCJCZWxhcnVzXCIsIFwiQllcIiwgXCJCcmVzdCB2b2JsYXN0fkJSfEdvcm9kIE1pbnNrfkhPfEhvbWllbCB2b2JsYXN0fkhPfEhyb2RuYSB2b2JsYXN0fkhSfE1haGlseW93IHZvYmxhc3R+TUF8TWluc2sgdm9ibGFzdH5NSXxWaXRzZWJzayB2b2JsYXN0flZJXCJdLCBbXCJCZWxnaXVtXCIsIFwiQkVcIiwgXCJCcnV4ZWxsZXMtQ2FwaXRhbGV+QlJVfFLDqWdpb24gRmxhbWFuZGV+VkxHfFLDqWdpb24gV2FsbG9uacOrfldBTFwiXSwgW1wiQmVsaXplXCIsIFwiQlpcIiwgXCJCZWxpemUgRGlzdHJpY3R+Qlp8Q2F5byBEaXN0cmljdH5DWXxDb3JvemFsIERpc3RyaWN0fkNaTHxPcmFuZ2UgV2FsayBEaXN0cmljdH5PV3xTdGFubiBDcmVlayBEaXN0cmljdH5TQ3xUb2xlZG8gRGlzdHJpY3R+VE9MXCJdLCBbXCJCZW5pblwiLCBcIkJKXCIsIFwiQWxpYm9yaX5BTHxBdGFrb3JhfkFLfEF0bGFudGlxdWV+QVF8Qm9yZ291fkJPfENvbGxpbmVzIERlcGFydG1lbnR+Q098RG9uZ2F+RE98S291ZmZvfktPfExpdHRvcmFsIERlcGFydG1lbnR+TEl8TW9ubyBEZXBhcnRtZW50fk1PfE91w6ltw6l+T1V8UGxhdGVhdX5QTHxab3V+Wk9cIl0sIFtcIkJlcm11ZGFcIiwgXCJCTVwiLCBcIkNpdHkgb2YgSGFtaWx0b25+MDN8RGV2b25zaGlyZSBQYXJpc2h+MDF8SGFtaWx0b24gUGFyaXNofjAyfFBhZ2V0IFBhcmlzaH4wNHxQZW1icm9rZSBQYXJpc2h+MDV8U2FuZHlzIFBhcmlzaH4wOHxTbWl0aCdzIFBhcmlzaH4wOXxTb3V0aGFtcHRvbiBQYXJpc2h+MTB8U3QuIEdlb3JnZSdzIFBhcmlzaH4wN3xUb3duIG9mIFN0LiBHZW9yZ2V+MDZ8V2Fyd2ljayBQYXJpc2h+MTFcIl0sIFtcIkJodXRhblwiLCBcIkJUXCIsIFwiQnVtdGhhbmd+MzN8Q2hodWtoYX4xMnxEYWdhbmF+MjJ8R2FzYX5HQXxIYWF+MTN8TGh1bnRzZX40NHxNb25nYXJ+NDJ8UGFyb34xMXxQZW1hZ2F0c2hlbH40M3xQdW5ha2hhfjIzfFNhbWRydXAgSm9uZ2toYXJ+NDV8U2FtdHNlfjE0fFNhcnBhbmd+MzF8VGhpbXBodX4xNXxUcmFzaGlnYW5nfjQxfFRyYXNoaXlhbmd0c2V+VFl8VHJvbmdzYX4zMnxUc2lyYW5nfjIxfFdhbmdkdWUgUGhvZHJhbmd+MjR8WmhlbWdhbmd+MzRcIl0sIFtcIkJvbGl2aWFcIiwgXCJCT1wiLCBcIkJlbml+QnxDaHVxdWlzYWNhfkh8Q29jaGFiYW1iYX5DfExhIFBhen5MfE9ydXJvfk98UGFuZG9+TnxQb3Rvc8OtflB8U2FudGEgQ3J1en5TfFRhcmlqYX5UXCJdLCBbXCJCb25haXJlLCBTaW50IEV1c3RhdGl1cyBhbmQgU2FiYVwiLCBcIkJRXCIsIFwiQm9uYWlyZX5CT3xTYWJhIElzYW5kflNBfFNpbnQgRXVzdGF0aXVzflNFXCJdLCBbXCJCb3NuaWEgYW5kIEhlcnplZ292aW5hXCIsIFwiQkFcIiwgXCJCcsSNa28gRGlzdHJpa3R+QlJDfEZlZGVyYWNpamEgQm9zbmUgaSBIZXJjZWdvdmluZX5CSUh8UmVwdWJsaWthIFNycHNrYX5TUlBcIl0sIFtcIkJvdHN3YW5hXCIsIFwiQldcIiwgXCJDZW50cmFsfkNFfEdoYW56aX5HSHxLZ2FsYWdhZGl+S0d8S2dhdGxlbmd+S0x8S3dlbmVuZ35LV3xOb3J0aCBXZXN0fk5XfE5vcnRoLUVhc3R+TkV8U291dGggRWFzdH5TRXxTb3V0aGVybn5TT1wiXSwgW1wiQm91dmV0IElzbGFuZFwiLCBcIkJWXCIsIFwiQm91dmV0IElzbGFuZH5CVlwiXSwgW1wiQnJhemlsXCIsIFwiQlJcIiwgXCJBY3JlfkFDfEFsYWdvYXN+QUx8QW1hcMOhfkFQfEFtYXpvbmFzfkFNfEJhaGlhfkJBfENlYXLDoX5DRXxEaXN0cml0byBGZWRlcmFsfkRGfEVzcMOtcml0byBTYW50b35FU3xHb2nDoXN+R098TWFyYW5ow6Nvfk1BfE1hdG8gR3Jvc3Nvfk1UfE1hdG8gR3Jvc3NvIGRvIFN1bH5NU3xNaW5hcyBHZXJhaXN+TUd8UGFyw6F+UEF8UGFyYcOtYmF+UEJ8UGFyYW7DoX5QUnxQZXJuYW1idWNvflBFfFBpYXXDrX5QSXxSaW8gZGUgSmFuZWlyb35SSnxSaW8gR3JhbmRlIGRvIE5vcnRlflJOfFJpbyBHcmFuZGUgZG8gU3VsflJTfFJvbmTDtG5pYX5ST3xSb3JhaW1hflJSfFNhbnRhIENhdGFyaW5hflNDfFPDo28gUGF1bG9+U1B8U2VyZ2lwZX5TRXxUb2NhbnRpbnN+VE9cIl0sIFtcIkJyaXRpc2ggSW5kaWFuIE9jZWFuIFRlcnJpdG9yeVwiLCBcIklPXCIsIFwiQnJpdGlzaCBJbmRpYW4gT2NlYW4gVGVycml0b3J5fklPXCJdLCBbXCJCcnVuZWkgRGFydXNzYWxhbVwiLCBcIkJOXCIsIFwiQmVsYWl0fkJFfEJydW5laSBNdWFyYX5CTXxUZW1idXJvbmd+VEV8VHV0b25nflRVXCJdLCBbXCJCdWxnYXJpYVwiLCBcIkJHXCIsIFwiQmxhZ29ldmdyYWR+MDF8QnVyZ2FzfjAyfERvYnJpY2h+MDh8R2Ficm92b34wN3xKYW1ib2x+Mjh8S2hhc2tvdm9+MjZ8S2p1c3RlbmRpbH4xMHxLdXJkemhhbGl+MDl8TG92ZWNofjExfE1vbnRhbmF+MTJ8UGF6YXJkemhpa34xM3xQZXJuaWt+MTR8UGxldmVufjE1fFBsb3ZkaXZ+MTZ8UmF6Z3JhZH4xN3xSdXNlfjE4fFNodW1lbn4yN3xTaWxpc3RyYX4xOXxTbGl2ZW5+MjB8U21vbGphbn4yMXxTb2ZpamF+MjN8U29maWphLUdyYWR+MjJ8U3RhcmEgWmFnb3JhfjI0fFR1cmdvdmlzaGhlfjI1fFZhcm5hfjAzfFZlbGlrbyBUdXJub3ZvfjA0fFZpZGlufjA1fFZyYWNhfjA2XCJdLCBbXCJCdXJraW5hIEZhc29cIiwgXCJCRlwiLCBcIkJhbMOpfkJBTHxCYW0vTGFrZSBCYW1+QkFNfEJhbndhIFByb3ZpbmNlfkJBTnxCYXrDqGdhfkJBWnxCb3Vnb3VyaWJhfkJHUnxCb3VsZ291IFByb3ZpbmNlfkJMR3xCb3Vsa2llbWTDqX5CTEt8Q29tb8OpL0tvbW9lfkNPTXxHYW56b3VyZ291IFByb3ZpbmNlfkdBTnxHbmFnbmF+R05BfEdvdXJtYSBQcm92aW5jZX5HT1V8SG91ZXR+SE9VfElvYmF+SU9CfEthZGlvZ29+S0FEfEvDqW7DqWRvdWdvdX5LRU58S29tb25kamFyaX5LTUR8S29tcGllbmdhfktNUHxLb3NzaSBQcm92aW5jZX5LT1N8S291bHDDqWxvZ29+S09QfEtvdXJpdGVuZ2F+S09UfEtvdXJ3w6lvZ29+S09XfEzDqXJhYmF+TEVSfExvcm91bX5MT1J8TW91aG91bn5NT1V8TmFtZW50ZW5nYX5OQU18TmFvdXJpL05haG91cml+TkFPfE5heWFsYX5OQVl8Tm91bWJpZWx+Tk9VfE91YnJpdGVuZ2F+T1VCfE91ZGFsYW5+T1VEfFBhc3NvcsOpflBBU3xQb25pflBPTnxTYW5ndWnDqX5TTkd8U2FubWF0ZW5nYX5TTVR8U8Opbm9+U0VOfFNpc3NpbGl+U0lTfFNvdW1+U09NfFNvdXJvdX5TT1J8VGFwb2F+VEFQfFR1aS9UdXl+VFVJfFlhZ2hhfllBR3xZYXRlbmdhfllBVHxaaXJvflpJUnxab25kb21hflpPTnxab3VuZHfDqW9nb35aT1VcIl0sIFtcIkJ1cnVuZGlcIiwgXCJCSVwiLCBcIkJ1YmFuemF+QkJ8QnVqdW1idXJhIE1haXJpZX5CTXxCdWp1bWJ1cmEgUnVyYWx+Qkx8QnVydXJpfkJSfENhbmt1em9+Q0F8Q2liaXRva2V+Q0l8R2l0ZWdhfkdJfEthcnV6aX5LUnxLYXlhbnphfktZfEtpcnVuZG9+S0l8TWFrYW1iYX5NQXxNdXJhbXZ5YX5NVXxNdXlpbmdhfk1ZfE13YXJvfk1XfE5nb3ppfk5HfFJ1dGFuYX5SVHxSdXlpZ2l+UllcIl0sIFtcIkNhbWJvZGlhXCIsIFwiS0hcIiwgXCJCYWF0IERhbWJhbmd+MnxCYW50ZWF5IE1lYW4gQ2hleX4xfEthbXBvbmcgQ2hhYW1+M3xLYW1wb25nIENoaG5hbmd+NHxLYW1wb25nIFNwdWV1fjV8S2FtcG9uZyBUaHVtfjZ8S2FtcG90fjd8S2FuZGFhbH44fEthb2ggS29uZ345fEtyYWNoZWh+MTB8S3JvbmcgS2FlYn4yM3xLcm9uZyBQYWlsaW5+MjR8S3JvbmcgUHJlYWggU2loYW5vdWt+MTh8TW9uZG9sIEtpcml+MTF8T3RkYXIgTWVhbiBDaGV5fjIyfFBobm9tIFBlbmh+MTJ8UG91c2FhdH4xNXxQcmVhaCBWaWhlYXJ+MTN8UHJleSBWZWFlbmd+MTR8Um90YW5haCBLaXJpfjE2fFNpZW0gUmVhYn4xN3xTdHVlbmcgVHJlbmd+MTl8U3ZhYXkgUmllbmd+MjB8VGFha2Fldn4yMXxUYm9uZyBLaG11bX4yNVwiXSwgW1wiQ2FtZXJvb25cIiwgXCJDTVwiLCBcIkFkYW1hb3VhfkFEfENlbnRyZX5DRXxFc3R+RVN8RXh0csOqbWUtTm9yZH5FTnxMaXR0b3JhbH5MVHxOb3Jkfk5PfE5vcmQtT3Vlc3R+Tld8T3Vlc3R+T1V8U3VkflNVfFN1ZC1PdWVzdH5TV1wiXSwgW1wiQ2FuYWRhXCIsIFwiQ0FcIiwgXCJBbGJlcnRhfkFCfEJyaXRpc2ggQ29sdW1iaWF+QkN8TWFuaXRvYmF+TUJ8TmV3IEJydW5zd2lja35OQnxOZXdmb3VuZGxhbmQgYW5kIExhYnJhZG9yfk5MfE5vcnRod2VzdCBUZXJyaXRvcmllc35OVHxOb3ZhIFNjb3RpYX5OU3xOdW5hdnV0fk5VfE9udGFyaW9+T058UHJpbmNlIEVkd2FyZCBJc2xhbmR+UEV8UXVlYmVjflFDfFNhc2thdGNoZXdhbn5TS3xZdWtvbn5ZVFwiXSwgW1wiQ2FwZSBWZXJkZVwiLCBcIkNWXCIsIFwiQm9hIFZpc3RhfkJWfEJyYXZhfkJSfENhbGhldGEgZGUgU8OjbyBNaWd1ZWx+Q1N8TWFpb35NQXxNb3N0ZWlyb3N+TU98UGHDumx+UEF8UG9ydG8gTm92b35QTnxQcmFpYX5QUnxSaWJlaXJhIEJyYXZhflJCfFJpYmVpcmEgR3JhbmRlflJHfFNhbH5TTHxTYW50YSBDYXRhcmluYX5DQXxTYW50YSBDcnV6fkNSfFPDo28gRG9taW5nb3N+U0R8U8OjbyBGaWxpcGV+U0Z8U8OjbyBOaWNvbGF1flNOfFPDo28gVmljZW50ZX5TVnxUYXJyYWZhbH5UQXxUYXJyYWZhbCBkZSBTw6NvIE5pY29sYXV+VFNcIl0sIFtcIkNheW1hbiBJc2xhbmRzXCIsIFwiS1lcIiwgXCJDcmVla3xFYXN0ZXJufE1pZGxhbmR8U291dGggVG93bnxTcG90IEJheXxTdGFrZSBCYXl8V2VzdCBFbmR8V2VzdGVyblwiXSwgW1wiQ2VudHJhbCBBZnJpY2FuIFJlcHVibGljXCIsIFwiQ0ZcIiwgXCJCYW1pbmd1aS1CYW5nb3Jhbn5CQnxCYW5ndWl+QkdGfEJhc3NlLUtvdHRvfkJLfEhhdXRlLUtvdHRvfkhLfEhhdXQtTWJvbW91fkhNfEvDqW1vfktHfExvYmF5ZX5MQnxNYW1iw6lyw6ktS2Fkw6nDr35IU3xNYm9tb3V+TUJ8TmFuYS1HcmViaXppfjEwfE5hbmEtTWFtYsOpcsOpfk5NfE9tYmVsbGEtTSdQb2tvfk1QfE91YWthflVLfE91aGFtfkFDfE91aGFtIFDDqW5kw6l+T1B8U2FuZ2hhLU1iYcOpcsOpflNFfFZha2FnYX5WS1wiXSwgW1wiQ2hhZFwiLCBcIlREXCIsIFwiQmFociBlbCBHaGF6YWx+Qkd8QmF0aGF+QkF8Qm9ya291fkJPfENoYXJpLUJhZ3Vpcm1pfkNCfEVubmVkaS1Fc3R+RUV8RW5uZWRpLU91ZXN0fkVPfEd1w6lyYX5HUnxIYWRqZXIgTGFtaXN+SEx8S2FuZW1+S0F8TGFjfkxDfExvZ29uZSBPY2NpZGVudGFsfkxPfExvZ29uZSBPcmllbnRhbH5MUnxNb25kb3Vsfk1BfE1heW8tS8OpYmJpLUVzdH5NRXxNb3llbi1DaGFyaX5NQ3xPdWFkZGFpfk9EfFNhbGFtYXR+U0F8U2lsYX5TSXxUYW5kamlsw6l+VEF8VGliZXN0aX5USXxWaWxsZSBkZSBOZGphbWVuYX5ORHxXYWRpIEZpcmF+V0ZcIl0sIFtcIkNoaWxlXCIsIFwiQ0xcIiwgXCJBaXPDqW4gZGVsIEdlbmVyYWwgQ2FybG9zIEliw6HDsWV6IGRlbCBDYW1wb35BSXxBbnRvZmFnYXN0YX5BTnxBcmF1Y2Fuw61hfkFSfEFyaWNhIHkgUGFyaW5hY290YX5BUHxBdGFjYW1hfkFUfELDrW8tQsOtb35CSXxDb3F1aW1ib35DT3xMaWJlcnRhZG9yIEdlbmVyYWwgQmVybmFyZG8gTydIaWdnaW5zfkxJfExvcyBMYWdvc35MTHxMb3MgUsOtb3N+TFJ8TWFnYWxsYW5lcyB5IEFudGFydGljYSBDaGlsZW5hfk1BfE1hcmdhLU1hcmdhfnxNYXVsZX5NTHxSZWdpw7NuIE1ldHJvcG9saXRhbmEgZGUgU2FudGlhZ29+Uk18VGFyYXBhY8OhflRBfFZhbHBhcmHDrXNvflZTXCJdLCBbXCJDaGluYVwiLCBcIkNOXCIsIFwiQW5odWl+MzR8QmVpamluZ34xMXxDaG9uZ3Fpbmd+NTB8RnVqaWFufjM1fEdhbnN1fjYyfEd1YW5nZG9uZ340NHxHdWFuZ3hpfjQ1fEd1aXpob3V+NTJ8SGFpbmFufjQ2fEhlYmVpfjEzfEhlaWxvbmdqaWFuZ34yM3xIZW5hbn40MXxIb25nIEtvbmd+OTF8SHViZWl+NDJ8SHVuYW5+NDN8SW5uZXIgTW9uZ29saWF+MTV8SmlhbmdzdX4zMnxKaWFuZ3hpfjM2fEppbGlufjIyfExpYW9uaW5nfjIxfE1hY2F1fjkyfE5pbmd4aWF+NjR8UWluZ2hhaX42M3xTaGFhbnhpfjYxfFNoYW5kb25nfjM3fFNoYW5naGFpfjMxfFNoYW54aX4xNHxTaWNodWFufjUxfFRpYW5qaW5+MTJ8VGliZXR+NTR8WGluamlhbmd+NjV8WXVubmFufjUzfFpoZWppYW5nfjMzXCJdLCBbXCJDaHJpc3RtYXMgSXNsYW5kXCIsIFwiQ1hcIiwgXCJDaHJpc3RtYXMgSXNsYW5kfkNYXCJdLCBbXCJDb2NvcyAoS2VlbGluZykgSXNsYW5kc1wiLCBcIkNDXCIsIFwiRGlyZWN0aW9uIElzbGFuZH5ESXxIb21lIElzbGFuZH5ITXxIb3JzYnVyZ2ggSXNsYW5kfkhSfE5vcnRoIEtlZWxpbmcgSXNsYW5kfk5LfFNvdXRoIElzbGFuZH5TSXxXZXN0IElzbGFuZH5XSVwiXSwgW1wiQ29sb21iaWFcIiwgXCJDT1wiLCBcIkFtYXpvbmFzfkFNQXxBbnRpb3F1aWF+QU5UfEFyYXVjYX5BUkF8QXJjaGlwacOpbGFnbyBkZSBTYW4gQW5kcsOpc35TQVB8QXRsw6FudGljb35BVEx8Qm9nb3TDoSBELkMufkRDfEJvbMOtdmFyfkJPTHxCb3lhY8OhfkJPWXxDYWxkYXN+Q0FMfENhcXVldMOhfkNBUXxDYXNhbmFyZX5DQVN8Q2F1Y2F+Q0FVfENlc2FyfkNFU3xDaG9jw7N+Q0hPfEPDs3Jkb2JhfkNPUnxDdW5kaW5hbWFyY2F+Q1VOfEd1YWluw61hfkdVQXxHdWF2aWFyZX5HVVZ8SHVpbGF+SFVJfExhIEd1YWppcmF+TEFHfE1hZ2RhbGVuYX5NQUd8TWV0YX5NRVR8TmFyacOxb35OQVJ8Tm9ydGUgZGUgU2FudGFuZGVyfk5TQXxQdXR1bWF5b35QVVR8UXVpbmTDrW9+UVVJfFJpc2FyYWxkYX5SSVN8U2FudGFuZGVyflNBTnxTdWNyZX5TVUN8VG9saW1hflRPTHxWYWxsZSBkZWwgQ2F1Y2F+VkFDfFZhdXDDqXN+VkFVfFZpY2hhZGF+VklEXCJdLCBbXCJDb21vcm9zXCIsIFwiS01cIiwgXCJBbmRqYXrDrmRqYX5HfEFuZGpvdcOibn5BfE1vw7tow65sw65+TVwiXSwgW1wiQ29uZ28sIFJlcHVibGljIG9mIHRoZSAoQnJhenphdmlsbGUpXCIsIFwiQ0dcIiwgXCJCb3VlbnphfjExfEJyYXp6YXZpbGxlfkJaVnxDdXZldHRlfjh8Q3V2ZXR0ZS1PdWVzdH4xNXxLb3VpbG91fjV8TMOpa291bW91fjJ8TGlrb3VhbGF+N3xOaWFyaX45fFBsYXRlYXV4fjE0fFBvaW50ZS1Ob2lyZX4xNnxQb29sfjEyfFNhbmdoYX4xM1wiXSwgW1wiQ29uZ28sIHRoZSBEZW1vY3JhdGljIFJlcHVibGljIG9mIHRoZSAoS2luc2hhc2EpXCIsIFwiQ0RcIiwgXCJCYW5kdW5kdX5CTnxCYXMtQ29uZ29+QkN8w4lxdWF0ZXVyfkVRfEthc2HDry1PY2NpZGVudGFsfktFfEthc2HDry1PcmllbnRhbH5LV3xLYXRhbmdhfktBfEtpbnNoYXNhfktOfE1hbmllbWF+TUF8Tm9yZC1LaXZ1fk5LfE9yaWVudGFsZX5PUnxTdWQtS2l2dX5TS1wiXSwgW1wiQ29vayBJc2xhbmRzXCIsIFwiQ0tcIiwgXCJBaXR1dGFraXxBdGl1fEF2YXJ1YXxNYW5nYWlhfE1hbmloaWtpfE1hJ3VrZXxNaXRpYXJvfE5hc3NhdXxQYWxtZXJzdG9ufFBlbnJoeW58UHVrYXB1a2F8UmFrYWhhbmdhXCJdLCBbXCJDb3N0YSBSaWNhXCIsIFwiQ1JcIiwgXCJBbGFqdWVsYX4yfENhcnRhZ29+M3xHdWFuYWNhc3RlfjV8SGVyZWRpYX40fExpbcOzbn43fFB1bnRhcmVuYXN+NnxTYW4gSm9zw6l+MVwiXSwgW1wiQ8O0dGUgZCdJdm9pcmUsIFJlcHVibGljIG9mXCIsIFwiQ0lcIiwgXCJBZ27DqWJ5fjE2fEJhZmluZ34xN3xCYXMtU2Fzc2FuZHJhfjA5fERlbmd1w6lsw6l+MTB8RGl4LUh1aXQgTW9udGFnbmVzfjA2fEZyb21hZ2VyfjE4fEhhdXQtU2Fzc2FuZHJhfjAyfExhY3N+MDd8TGFndW5lc34wMXxNYXJhaG91w6l+MTJ8TW95ZW4tQ2F2YWxseX4xOXxNb3llbi1Db21vw6l+MDV8Tid6aS1Db21vw6l+MTF8U2F2YW5lc34wM3xTdWQtQmFuZGFtYX4xNXxTdWQtQ29tb8OpfjEzfFZhbGzDqWUgZHUgQmFuZGFtYX4wNHxXb3JvZG91Z291fjE0fFphbnphbn4wOFwiXSwgW1wiQ3JvYXRpYVwiLCBcIkhSXCIsIFwiQmplbG92YXJza28tQmlsb2dvcnNrYSDFvXVwYW5pamF+MDd8QnJvZHNrby1Qb3NhdnNrYSDFvXVwYW5pamF+MTJ8RHVicm92YcSNa28tTmVyZXR2YW5za2Egxb11cGFuaWphfjE5fEdyYWQgWmFncmVifjIxfElzdGFyc2thIMW9dXBhbmlqYX4xOHxLYXJsb3ZhxI1rYSDFvXVwYW5pamF+MDR8S29wcml2bmnEjWtvLUtyaXpldmHEjWthIMW9dXBhbmlqYX4wNnxLcmFwaW5za28tWmFnb3Jza2Egxb11cGFuaWphfjAyfExpxI1rby1TZW5qc2thIMW9dXBhbmlqYX4wOXxNZcSRaW11cnNrYSDFvXVwYW5pamF+MjB8T3NqZcSNa28tQmFyYW5qc2thIMW9dXBhbmlqYX4xNHxQb8W+ZcWha28tU2xhdm9uc2thIMW9dXBhbmlqYX4xMXxQcmltb3Jza28tR29yYW5za2Egxb11cGFuaWphfjA4fFNpc2HEjWtvLU1vc2xhdmHEjWthIMW9dXBhbmlqYX4wM3xTcGxpdHNrby1EYWxtYXRpbnNrYSDFvXVwYW5pamF+MTd8U2liZW5za28tS25pbnNrYSDFvXVwYW5pamF+MTV8VmFyYcW+ZGluc2thIMW9dXBhbmlqYX4wNXxWaXJvdml0acSNa28tUG9kcmF2c2thIMW9dXBhbmlqYX4xMHxWdWtvdmFyc2tvLVNyaWplbXNrYSDFvXVwYW5pamF+MTZ8WmFkYXJza2Egxb11cGFuaWphfjEzfFphZ3JlYmFja2EgWnVwYW5pamF+MDFcIl0sIFtcIkN1YmFcIiwgXCJDVVwiLCBcIkFydGVtaXNhfjE1fENhbWFnw7xleX4wOXxDaWVnbyBkZSDDgXZpbGF+MDh8Q2llbmZ1ZWdvc34wNnxHcmFubWF+MTJ8R3VhbnTDoW5hbW9+MTR8SG9sZ3XDrW5+MTF8SXNsYSBkZSBsYSBKdXZlbnR1ZH45OXxMYSBIYWJhbmF+MDN8TGFzIFR1bmFzfjEwfE1hdGFuemFzfjA0fE1heWFiZXF1ZX4xNnxQaW5hciBkZWwgUsOtb34wMXxTYW5jdGkgU3DDrXJpdHVzfjA3fFNhbnRpYWdvIGRlIEN1YmF+MTN8VmlsbGEgQ2xhcmF+MDVcIl0sIFtcIkN1cmHDp2FvXCIsIFwiQ1dcIiwgXCJDdXJhw6dhb35DV1wiXSwgW1wiQ3lwcnVzXCIsIFwiQ1lcIiwgXCJBbW1vY2hvc3Rvc34wNHxLZXJ5bmVpYX4wNXxMYXJuYWthfjAzfExlZmtvc2lhfjAxfExlbWVzb3N+MDJ8UGFmb3N+MDVcIl0sIFtcIkN6ZWNoIFJlcHVibGljXCIsIFwiQ1pcIiwgXCJIbGF2bsOtIG3Em3N0byBQcmFoYX5QUnxKaWhvxI1lc2vDvSBrcmFqfkpDfEppaG9tb3JhdnNrw70ga3Jhan5KTXxLYXJsb3ZhcnNrw70ga3Jhan5LQXxLcsOhbG92w6locmFkZWNrw70ga3Jhan5LUnxMaWJlcmVja8O9IGtyYWp+TEl8TW9yYXZza29zbGV6c2vDvSBrcmFqfk1PfE9sb21vdWNrw70ga3Jhan5PTHxQYXJkdWJpY2vDvSBrcmFqflBBfFBsemXFiHNrw70ga3Jhan5QTHxTdMWZZWRvxI1lc2vDvSBrcmFqflNUfMOac3RlY2vDvSBrcmFqflVTfFZ5c2/EjWluYX5WWXxabMOtbnNrw70ga3Jhan5aTFwiXSwgW1wiRGVubWFya1wiLCBcIkRLXCIsIFwiSG92ZWRzdGFkZW5+ODR8S3VqYWxsZXF+R0wtS1V8TWlkdGp5bGxhbmR+ODJ8Tm9yZGVyw7hlcm5lfkZPLTAxfE5vcmRqeWxsYW5kfjgxfMOYc3RlcsO4fkZPLTA2fFFhYXN1aXRzdXB+R0wtUUF8UWVxcWF0YX5HTC1RRXxTYW5kw7h+Rk8tMDJ8U2VybWVyc29vcX5HTC1TTXxTasOmbGxhbmR+ODV8U3Ryw7htw7h+Rk8tMDN8U3VkZXLDuH5GTy0wNHxTeWRkYW5tYXJrfjgzfFbDpWfDuH5GTy0wNVwiXSwgW1wiRGppYm91dGlcIiwgXCJESlwiLCBcIkFsaSBTYWJpZWh+QVN8QXJ0YX5BUnxEaWtoaWx+REl8T2JvY2t+T0J8VGFkam91cmFoflRBXCJdLCBbXCJEb21pbmljYVwiLCBcIkRNXCIsIFwiU2FpbnQgQW5kcmV3IFBhcmlzaH4wMnxTYWludCBEYXZpZCBQYXJpc2h+MDN8U2FpbnQgR2VvcmdlIFBhcmlzaH4wNHxTYWludCBKb2huIFBhcmlzaH4wNXxTYWludCBKb3NlcGggUGFyaXNofjA2fFNhaW50IEx1a2UgUGFyaXNofjA3fFNhaW50IE1hcmsgUGFyaXNofjA4fFNhaW50IFBhdHJpY2sgUGFyaXNofjA5fFNhaW50IFBhdWwgUGFyaXNofjEwfFNhaW50IFBldGVyIFBhcmlzaH4xMVwiXSwgW1wiRG9taW5pY2FuIFJlcHVibGljXCIsIFwiRE9cIiwgXCJDaWJhbyBDZW50cmFsfjAyfERlbCBWYWxsZX4zN3xEaXN0cml0byBOYWNpb25hbH4wMXxFbnJpcXVpbGxvfjM4fE5vcmNlbnRyYWx+MDR8Tm9yZGVzdGV+MzR8Tm9yb2VzdGV+MzR8Tm9ydGV+MzV8VmFsZGVzaWF+NDJcIl0sIFtcIkVjdWFkb3JcIiwgXCJFQ1wiLCBcIkF6dWF5fkF8Qm9sw612YXJ+QnxDYcOxYXJ+RnxDYXJjaGl+Q3xDaGltYm9yYXpvfkh8Q290b3BheGl+WHxFbCBPcm9+T3xFc21lcmFsZGFzfkV8R2Fsw6FwYWdvc35XfEd1YXlhc35HfEltYmFidXJhfkl8TG9qYX5MfExvcyBSw61vc35SfE1hbmFiw61+TXxNb3JvbmEtU2FudGlhZ29+U3xOYXBvfk58T3JlbGxhbmF+RHxQYXN0YXphfll8UGljaGluY2hhflB8U2FudGEgRWxlbmF+U0V8U2FudG8gRG9taW5nbyBkZSBsb3MgVHPDoWNoaWxhc35TRHxTdWN1bWLDrW9zflV8VHVuZ3VyYWh1YX5UfFphbW9yYS1DaGluY2hpcGV+WlwiXSwgW1wiRWd5cHRcIiwgXCJFR1wiLCBcIkFsZXhhbmRyaWF+QUxYfEFzd2FufkFTTnxBc3lvdXR+QVNUfEJhbmkgU3VlaWZ+Qk5TfEJlaGVpcmF+Qkh8Q2Fpcm9+Q3xEYXFhaGxpYX5ES3xEdW1pYXR+RFR8RWwgQmFociBFbCBBaG1hcn5CQXxFbCBJc21haWxpYX5JU3xFbCBTdWV6flNVWnxFbCBXYWRpIEVsIEdlZGVlZH5XQUR8RmF5b3VtfkZZTXxHaGFyYmlhfkdIfEdpemF+U1VafEhlbHdhbn5IVXxLYWZyIEVsIFNoZWlraH5LRlN8THV4b3J+TFh8TWF0cm91aH5NVHxNZW5pYX5NTnxNZW5vZmlhfk1ORnxOb3J0aCBTaW5haX5TSU58UG9ydCBTYWlkflBUU3xRYWx1YmlhfktCfFFlbmF+S058U2hhcnFpYX5TSFJ8U2l4dGggb2YgT2N0b2Jlcn5TVXxTb2hhZ35TSEd8U291dGggU2luYWl+SlNcIl0sIFtcIkVsIFNhbHZhZG9yXCIsIFwiU1ZcIiwgXCJBaHVhY2hhcMOhbn5BSHxDYWJhw7Fhc35DQXxDdXNjYXRsw6FufkNVfENoYWxhdGVuYW5nb35DSHxMYSBMaWJlcnRhZH5MSXxMYSBQYXp+UEF8TGEgVW5pw7NuflVOfE1vcmF6w6Fufk1PfFNhbiBNaWd1ZWx+U018U2FuIFNhbHZhZG9yflNTfFNhbnRhIEFuYX5TQXxTYW4gVmljZW50ZX5TVnxTb25zb25hdGV+U098VXN1bHV0w6FuflVTXCJdLCBbXCJFcXVhdG9yaWFsIEd1aW5lYVwiLCBcIkdRXCIsIFwiQW5ub2LDs25+QU58Qmlva28gTm9ydGV+Qk58Qmlva28gU3VyfkJTfENlbnRybyBTdXJ+Q1N8S2nDqS1OdGVtfktOfExpdG9yYWx+TEl8V2VsZS1OemFzfldOXCJdLCBbXCJFcml0cmVhXCIsIFwiRVJcIiwgXCJBbnNlYmF+QU58RGVidWJ+RFV8RGVidWItS2VpaC1CYWhyaX5ES3xHYXNoLUJhcmthfkdCfE1hZWtlbH5NQXxTZW1pZW4tS2VpaC1CYWhyaX5TS1wiXSwgW1wiRXN0b25pYVwiLCBcIkVFXCIsIFwiSGFyanVtYWEgKFRhbGxpbm4pfjM3fEhpaXVtYWEgKEthcmRsYSl+Mzl8SWRhLVZpcnVtYWEgKEpvaHZpKX40NHxKw6RydmFtYWEgKFBhaWRlKX40MXxKw7VnZXZhbWFhIChKb2dldmEpfjQ5fEzDpMOkbmVtYWF+NTd8TMOkw6RuZS1WaXJ1bWFhIChSYWt2ZXJlKX41OXxQw6RybnVtYWEgKFBhcm51KX42N3xQw7VsdmFtYWEgKFBvbHZhKX42NXxSYXBsYW1hYSAoUmFwbGEpfjcwfFNhYXJlbWFhIChLdWVzc2FhcmUpfjc0fFRhcnR1bWFhIChUYXJ0dSl+Nzh8VmFsZ2FtYWEgKFZhbGdhKX44MnxWaWxqYW5kaW1hYSAoVmlsamFuZGkpfjg0fFbDtXJ1bWFhIChWb3J1KX44NlwiXSwgW1wiRXRoaW9waWFcIiwgXCJFVFwiLCBcIkFkZGlzIEFiYWJhfkFBfEFmYXJ+QUZ8QW1oYXJhfkFNfEJlbnNoYW5ndWwtR3VtYXp+QkV8RGlyZSBEYXdhfkREfEdhbWJlbGF+R0F8SGFyYXJpfkhBfE9yb21pYX5PUnxTb21hbGl+U098U291dGhlcm4gTmF0aW9ucyBOYXRpb25hbGl0aWVzIGFuZCBQZW9wbGUncyBSZWdpb25+U058VGlncmF5flRJXCJdLCBbXCJGYWxrbGFuZCBJc2xhbmRzIChJc2xhcyBNYWx2aW5hcylcIiwgXCJGS1wiLCBcIkZhbGtsYW5kIElzbGFuZHMgKElzbGFzIE1hbHZpbmFzKVwiXSwgW1wiRmFyb2UgSXNsYW5kc1wiLCBcIkZPXCIsIFwiQm9yZG95fEV5c3R1cm95fE15a2luZXN8U2FuZG95fFNrdXZveXxTdHJleW1veXxTdWR1cm95fFR2b3JveXJpfFZhZ2FyXCJdLCBbXCJGaWppXCIsIFwiRkpcIiwgXCJCYX4wMXxCdWF+MDF8Q2FrYXVkcm92ZX4wM3xLYWRhdnV+MDR8TGF1fjA1fExvbWFpdml0aX4wNnxNYWN1YXRhfjA3fE5hZHJvZ2EgYW5kIE5hdm9zYX4wOHxOYWl0YXNpcml+MDl8TmFtb3NpfjEwfFJhfjAxMXxSZXdhfjEyfFJvdHVtYX5SfFNlcnVhfjEyfFRhaWxldnV+MTRcIl0sIFtcIkZpbmxhbmRcIiwgXCJGSVwiLCBcIkFodmVuYW5tYWFuIGzDpMOkbml+QUx8RXRlbMOkLVN1b21lbiBsw6TDpG5pfkVTfEl0w6QtU3VvbWVuIGzDpMOkbml+SVN8TMOkbnNpLVN1b21lbiBsw6TDpG5pfkxTfExhcGluIGzDpMOkbml+TEx8T3VsdW4gbMOkw6RuaX5PTFwiXSwgW1wiRnJhbmNlXCIsIFwiRlJcIiwgXCJBdXZlcmduZS1SaMO0bmUtQWxwZXN+QVJBfEJvdXJnb2duZS1GcmFuY2hlLUNvbXTDqX5CRkN8QnJldGFnbmV+QlJFfENlbnRyZS1WYWwgZGUgTG9pcmV+Q1ZMfENvcnNlfkNPUnxHcmFuZCBFc3R+R0VTfEhhdXRzLWRlLUZyYW5jZX5IREZ8w45sZS1kZS1GcmFuY2V+SURGfE5vcm1hbmRpZX5OT1J8Tm91dmVsbGUtQXF1aXRhaW5lfk5BUXxPY2NpdGFuaWV+T0NDfFBheXMgZGUgbGEgTG9pcmV+UERMfFByb3ZlbmNlLUFscGVzLUNvdGUgZCdBenVyflBBQ3xDbGlwcGVydG9ufkNQfEd1YWRlbG91cGV+R1B8R3V5YW5lfkdGfE1hcnRpbmlxdWV+TVF8TWF5b3R0ZX5ZVHxOb3ZlbGxlLUNhbMOpZG9uaWV+TkN8UG9seW7DqXNpZX5QRnxTYWludC1QaWVycmUtZXQtTWlxdWVsb25+UE18U2FpbnQgQmFydGjDqWxlbXl+Qkx8U2FpbnQgTWFydGlufk1GfFLDqXVuaW9uflJFfFRlcnJlcyBBdXN0cmFsZXMgRnJhbsOnYWlzZXN+VEZ8V2FsbGlzLWV0LUZ1dHVuYX5XRlwiXSwgW1wiRnJlbmNoIEd1aWFuYVwiLCBcIkdGXCIsIFwiRnJlbmNoIEd1aWFuYVwiXSwgW1wiRnJlbmNoIFBvbHluZXNpYVwiLCBcIlBGXCIsIFwiQXJjaGlwZWwgZGVzIE1hcnF1aXNlc3xBcmNoaXBlbCBkZXMgVHVhbW90dXxBcmNoaXBlbCBkZXMgVHVidWFpfElsZXMgZHUgVmVudHxJbGVzIFNvdXMtbGUtVmVudFwiXSwgW1wiRnJlbmNoIFNvdXRoZXJuIGFuZCBBbnRhcmN0aWMgTGFuZHNcIiwgXCJURlwiLCBcIkFkZWxpZSBMYW5kfElsZSBDcm96ZXR8SWxlcyBLZXJndWVsZW58SWxlcyBTYWludC1QYXVsIGV0IEFtc3RlcmRhbVwiXSwgW1wiR2Fib25cIiwgXCJHQVwiLCBcIkVzdHVhaXJlfjF8SGF1dC1PZ29vdcOpfjJ8TW95ZW4tT2dvb3XDqX4zfE5nb3VuacOpfjR8TnlhbmdhfjV8T2dvb3XDqS1JdmluZG9+NnxPZ29vdcOpLUxvbG9+N3xPZ29vdcOpLU1hcml0aW1lfjh8V29sZXUtTnRlbX45XCJdLCBbXCJHYW1iaWEsIFRoZVwiLCBcIkdNXCIsIFwiQmFuanVsfkJ8Q2VudHJhbCBSaXZlcn5NfExvd2VyIFJpdmVyfkx8Tm9ydGggQmFua35OfFVwcGVyIFJpdmVyflV8V2VzdGVybn5XXCJdLCBbXCJHZW9yZ2lhXCIsIFwiR0VcIiwgXCJBYmtoYXppYSAoU29raHVtaSl+QUJ8QWphcmlhIChCYXQndW1pKX5BSnxHdXJpYX5HVXxJbWVyZXRpfklNfEsnYWtoZXRpfktBfEt2ZW1vIEthcnRsaX5LS3xNdHNoa2hldGEtTXRpYW5ldGl+TU18UmFjaCdhLUxleGhrdW1pLUt2ZW1vU3ZhbmV0aX5STHxTYW1lZ3JlbG8tWmVtbyBTdmFuZXRpflNafFNhbXRza2hlLUphdmFraGV0aX5TSnxTaGlkYSBLYXJ0bGl+U0t8VGJpbGlzaX5UQlwiXSwgW1wiR2VybWFueVwiLCBcIkRFXCIsIFwiQmFkZW4tV8O8cnR0ZW1iZXJnfkJXfEJheWVybn5CWXxCZXJsaW5+QkV8QnJhbmRlbmJ1cmd+QkJ8QnJlbWVufkhCfEhhbWJ1cmd+SEh8SGVzc2VufkhFfE1lY2tsZW5idXJnLVZvcnBvbW1lcm5+TVZ8TmllZGVyc2FjaHNlbn5OSXxOb3JkcmhlaW4tV2VzdGZhbGVufk5XfFJoZWlubGFuZC1QZmFsen5SUHxTYWFybGFuZH5TTHxTYWNoc2VuflNOfFNhY2hzZW4tQW5oYWx0flNUfFNjaGxlc3dpZy1Ib2xzdGVpbn5TSHxUaMO8cmluZ2VuflRIXCJdLCBbXCJHaGFuYVwiLCBcIkdIXCIsIFwiQXNoYW50aX5BSHxCcm9uZy1BaGFmb35CQXxDZW50cmFsfkNQfEVhc3Rlcm5+RVB8R3JlYXRlciBBY2NyYX5BQXxOb3J0aGVybn5OUHxVcHBlciBFYXN0flVFfFVwcGVyIFdlc3R+VVd8Vm9sdGF+VFZ8V2VzdGVybn5XUFwiXSwgW1wiR2licmFsdGFyXCIsIFwiR0lcIiwgXCJHaWJyYWx0YXJcIl0sIFtcIkdyZWVjZVwiLCBcIkdSXCIsIFwiQW5hdG9saWvDrSBNYWtlZG9uw61hIGthaSBUaHLDoWtpfkF8QXR0aWvhuK9+SXxEeXRpa8OtIEVsbMOhZGF+R3xEeXRpa8OtIE1ha2Vkb27DrWF+Q3xJb27DrWEgTsOtc2lhfkZ8S2VudHJpa8OtIE1ha2Vkb27DrWF+QnxLcsOtdMOtfk18Tm90w61vIEFpZ2HDrW9+THxQZWxvcG9ubsOtc29zfkp8U3RlcmXDoSBFbGzDoWRhfkh8VGhlc3NhbMOtYX5FfFZvcmXDrW8gQWlnYcOtb35LfMONcGVpcm9zfkR8w4FnaW9uIMOTcm9zfjY5XCJdLCBbXCJHcmVlbmxhbmRcIiwgXCJHTFwiLCBcIktvbW11bmUgS3VqYWxsZXF+S1V8S29tbXVuZXFhcmZpayBTZXJtZXJzb29xflNNfFFhYXN1aXRzdXAgS29tbXVuaWF+UUF8UWVxcWF0YSBLb21tdW5pYX5RRVwiXSwgW1wiR3JlbmFkYVwiLCBcIkdEXCIsIFwiU2FpbnQgQW5kcmV3fjAxfFNhaW50IERhdmlkfjAyfFNhaW50IEdlb3JnZX4wM3xTYWludCBKb2hufjA0fFNhaW50IE1hcmt+MDV8U2FpbnQgUGF0cmlja34wNnxTb3V0aGVybiBHcmVuYWRpbmUgSXNsYW5kc34xMFwiXSwgW1wiR3VhZGVsb3VwZVwiLCBcIkdQXCIsIFwiR3VhZGVsb3VwZVwiXSwgW1wiR3VhbVwiLCBcIkdVXCIsIFwiR3VhbVwiXSwgW1wiR3VhdGVtYWxhXCIsIFwiR1RcIiwgXCJBbHRhIFZlcmFwYXp+QVZ8QmFqYSBWZXJhcGF6fkJWfENoaW1hbHRlbmFuZ29+Q018Q2hpcXVpbXVsYX5DUXxFbCBQcm9ncmVzb35QUnxFc2N1aW50bGF+RVN8R3VhdGVtYWxhfkdVfEh1ZWh1ZXRlbmFuZ29+SFV8SXphYmFsfklafEphbGFwYX5KQXxKdXRpYXBhfkpVfFBldMOpbn5QRXxRdWV0emFsdGVuYW5nb35RWnxRdWljaMOpflFDfFJldGFsaHVsZXV+UmV8U2FjYXRlcMOpcXVlen5TQXxTYW4gTWFyY29zflNNfFNhbnRhIFJvc2F+U1J8U29sb2zDoX5TT3xTdWNoaXRlcMOpcXVlen5TVXxUb3RvbmljYXDDoW5+VE98WmFjYXBhflpBXCJdLCBbXCJHdWVybnNleVwiLCBcIkdHXCIsIFwiQ2FzdGVsfEZvcmVzdHxTdC4gQW5kcmV3fFN0LiBNYXJ0aW58U3QuIFBldGVyIFBvcnR8U3QuIFBpZXJyZSBkdSBCb2lzfFN0LiBTYW1wc29ufFN0LiBTYXZpb3VyfFRvcnRldmFsfFZhbGVcIl0sIFtcIkd1aW5lYVwiLCBcIkdOXCIsIFwiQm9rw6l+QnxDb25ha3J5fkN8RmFyYW5haH5GfEthbmthbn5LfEtpbmRpYX5EfExhYsOpfkx8TWFtb3V+TXxOesOpcsOpa29yw6l+TlwiXSwgW1wiR3VpbmVhLUJpc3NhdVwiLCBcIkdXXCIsIFwiQmFmYXTDoX5CQXxCaW9tYm9+Qk18Qmlzc2F1fkJTfEJvbGFtYS1CaWphZ29zfkJMfENhY2hldX5DQXxHYWLDun5HQXxPaW9+T0l8UXVpbmFyYX5RVXxUb21iYWxpflRPXCJdLCBbXCJHdXlhbmFcIiwgXCJHWVwiLCBcIkJhcmltYS1XYWluaX5CQXxDdXl1bmktTWF6YXJ1bml+Q1V8RGVtZXJhcmEtTWFoYWljYX5ERXxFYXN0IEJlcmJpY2UtQ29yZW50eW5lfkVCfEVzc2VxdWlibyBJc2xhbmRzLVdlc3QgRGVtZXJhcmF+RVN8TWFoYWljYS1CZXJiaWNlfk1BfFBvbWVyb29uLVN1cGVuYWFtflBNfFBvdGFyby1TaXBhcnVuaX5QVHxVcHBlciBEZW1lcmFyYS1CZXJiaWNlflVEfFVwcGVyIFRha3V0dS1VcHBlciBFc3NlcXVpYm9+VVRcIl0sIFtcIkhhaXRpXCIsIFwiSFRcIiwgXCJBcnRpYm9uaXRlfkFSfENlbnRyZX5DRXxHcmFuZCdBbnNlfkdBfE5pcHBlc35OSXxOb3Jkfk5EfE5vcmQtRXN0fk5FfE5vcmQtT3Vlc3R+Tk98T3Vlc3R+T1V8U3VkflNEfFN1ZC1Fc3R+U0VcIl0sIFtcIkhlYXJkIElzbGFuZCBhbmQgTWNEb25hbGQgSXNsYW5kc1wiLCBcIkhNXCIsIFwiSGVhcmQgSXNsYW5kIGFuZCBNY0RvbmFsZCBJc2xhbmRzXCJdLCBbXCJIb2x5IFNlZSAoVmF0aWNhbiBDaXR5KVwiLCBcIlZBXCIsIFwiSG9seSBTZWUgKFZhdGljYW4gQ2l0eSl+MDFcIl0sIFtcIkhvbmR1cmFzXCIsIFwiSE5cIiwgXCJBdGzDoW50aWRhfkFUfENob2x1dGVjYX5DSHxDb2zDs25+Q0x8Q29tYXlhZ3VhfkNNfENvcMOhbn5DUHxDb3J0w6lzfkNSfEVsIFBhcmHDrXNvfkVQfEZyYW5jaXNjbyBNb3JhemFufkZNfEdyYWNpYXMgYSBEaW9zfkdEfEludGlidWPDoX5JTnxJc2xhcyBkZSBsYSBCYWjDrWF+SUJ8TGEgUGF6fkxQfExlbXBpcmF+TEV8T2NvdGVwZXF1ZX5PQ3xPbGFuY2hvfk9MfFNhbnRhIELDoXJiYXJhflNCfFZhbGxlflZBfFlvcm9+WU9cIl0sIFtcIkhvbmcgS29uZ1wiLCBcIkhLXCIsIFwiSG9uZyBLb25nXCJdLCBbXCJIdW5nYXJ5XCIsIFwiSFVcIiwgXCJCw6Fjcy1LaXNrdW5+Qkt8QmFyYW55YX5CQXxCw6lrw6lzfkJFfELDqWvDqXNjc2FiYX5CQ3xCb3Jzb2QtQWJhdWotWmVtcGxlbn5CWnxCdWRhcGVzdH5CVXxDc29uZ3LDoWR+Q1N8RGVicmVjZW5+REV8RHVuYcO6anbDoXJvc35EVXxFZ2VyfkVHfMOJcmR+RVJ8RmVqw6lyfkZFfEd5xZFyfkdZfEd5xZFyLU1vc29uLVNvcHJvbn5HU3xIYWpkw7otQmloYXJ+SEJ8SGV2ZXN+SEV8SMOzZG1lesWRdsOhc8OhcmhlbHl+SFZ8SsOhc3otTmFneWt1bi1Tem9sbm9rfk58S2Fwb3N2w6FyfktWfEtlY3NrZW3DqXR+S018S29tw6Fyb20tRXN6dGVyZ29tfktFfE1pc2tvbGN+TUl8TmFneWthbml6c2F+Tkt8TsOzZ3LDoWR+Tk98TnnDrXJlZ3low6F6YX5OWXxQw6ljc35QU3xQZXN0flBFfFNhbGfDs3RhcmrDoW5+U1R8U29tb2d5flNPfFNvcHJvbn5TTnxTemFib2xjcy3DoS1CZXJlZ35TWnxTemVnZWR+U0R8U3rDqWtlc2ZlaMOpcnbDoXJ+U0Z8U3pla3N6w6FyZH5TU3xTem9sbm9rflNLfFN6b21iYXRoZWx5flNIfFRhdGFiw6FueWF+VEJ8VG9sbmF+VE98VmFzflZBfFZlc3pwcsOpbX5WRXxWZXN6cHLDqW0gKENpdHkpflZNfFphbGF+WkF8WmFsYWVnZXJzemVnflpFXCJdLCBbXCJJY2VsYW5kXCIsIFwiSVNcIiwgXCJBdXN0dXJsYW5kfjd8SMO2ZnXDsGJvcmdhcnN2w6bDsGkgdXRhbiBSZXlramF2w61rdXJ+MXxOb3LDsHVybGFuZCBleXN0cmF+NnxOb3LDsHVybGFuZCB2ZXN0cmF+NXxTdcOwdXJsYW5kfjh8U3XDsHVybmVzfjJ8VmVzdGZpcsOwaXJ+NHxWZXN0dXJsYW5kfjNcIl0sIFtcIkluZGlhXCIsIFwiSU5cIiwgXCJBbmRhbWFuIGFuZCBOaWNvYmFyIElzbGFuZHN+QU58QW5kaHJhIFByYWRlc2h+QVB8QXJ1bmFjaGFsIFByYWRlc2h+QVJ8QXNzYW1+QVN8QmloYXJ+QlJ8Q2hhbmRpZ2FyaH5DSHxDaGhhdHRpc2dhcmh+Q1R8RGFkcmEgYW5kIE5hZ2FyIEhhdmVsaX5ETnxEYW1hbiBhbmQgRGl1fkREfERlbGhpfkRMfEdvYX5HQXxHdWphcmF0fkdKfEhhcnlhbmF+SFJ8SGltYWNoYWwgUHJhZGVzaH5IUHxKYW1tdSBhbmQgS2FzaG1pcn5KS3xKaGFya2hhbmR+Skh8S2FybmF0YWthfktBfEtlcmFsYX5LTHxMYWtzaGFkd2VlcH5MRHxNYWRoeWEgUHJhZGVzaH5NUHxNYWhhcmFzaHRyYX5NSHxNYW5pcHVyfk1OfE1lZ2hhbGF5YX5NTHxNaXpvcmFtfk1afE5hZ2FsYW5kfk5MfE9kaXNoYX5PUnxQdWR1Y2hlcnJ5flBZfFB1bmphYn5QQnxSYWphc3RoYW5+Ukp8U2lra2ltfldLfFRhbWlsIE5hZHV+VE58VGVsYW5nYW5hflRHfFRyaXB1cmF+VFJ8VXR0YXJha2hhbmR+VVR8VXR0YXIgUHJhZGVzaH5VUHxXZXN0IEJlbmdhbH5XQlwiXSwgW1wiSW5kb25lc2lhXCIsIFwiSURcIiwgXCJBY2VofkFDfEJhbGl+QkF8QmFuZ2thIEJlbGl0dW5nfkJCfEJhbnRlbn5CVHxCZW5na3VsdX5CRXxHb3JvbnRhbG9+R098SmFrYXJ0YSBSYXlhfkpLfEphbWJpfkpBfEphd2EgQmFyYXR+SkJ8SmF3YSBUZW5nYWh+SlR8SmF3YSBUaW11cn5KSXxLYWxpbWFudGFuIEJhcmF0fktCfEthbGltYW50YW4gU2VsYXRhbn5LU3xLYWxpbWFudGFuIFRlbmdhaH5LVHxLYWxpbWFudGFuIFRpbXVyfktJfEthbGltYW50YW4gVXRhcmF+S1V8S2VwdWxhdWFuIFJpYXV+S1J8TGFtcHVuZ35MQXxNYWx1a3V+TUF8TWFsdWt1IFV0YXJhfk1VfE51c2EgVGVuZ2dhcmEgQmFyYXR+TkJ8TnVzYSBUZW5nZ2FyYSBUaW11cn5OVHxQYXB1YX5QQXxQYXB1YSBCYXJhdH5QQnxSaWF1flJJfFN1bGF3ZXNpIFNlbGF0YW5+U1J8U3VsYXdlc2kgVGVuZ2FoflNUfFN1bGF3ZXNpIFRlbmdnYXJhflNHfFN1bGF3ZXNpIFV0YXJhflNBfFN1bWF0ZXJhIEJhcmF0flNCfFN1bWF0ZXJhIFNlbGF0YW5+U1N8U3VtYXRlcmEgVXRhcmF+U1V8WW9neWFrYXJ0YX5ZT1wiXSwgW1wiSXJhbiwgSXNsYW1pYyBSZXB1YmxpYyBvZlwiLCBcIklSXCIsIFwiQWxib3J6fjMyfEFyZGFixKtsfjAzfMSAesyEYXJixIF5asSBbi1lIEdoYXJixKt+MDJ8xIB6zIRhcmLEgXlqxIFuLWUgU2hhcnHEq34wMXxCxatzaGVocn4wNnxDaGFoxIFyIE1h4bipxIFsIHZhIEJha2h0xKvEgXLEq34wOHxFxZ9mYWjEgW5+MDR8RsSBcnN+MTR8R8SrbMSBbn4xOXxHb2xlc3TEgW5+Mjd8SGFtYWTEgW5+MjR8SG9ybW96Z8SBbn4yM3zEqmzEgW1+MDV8S2VybcSBbn4xNXxLZXJtxIFuc2jEgWh+MTd8S2hvcsSBc8SBbi1lIEpvbsWrYsSrfjI5fEtob3LEgXPEgW4tZSBSYeG6lWF2xKt+MzB8S2hvcsSBc8SBbi1lIFNob23EgWzEq342MXxLaMWremVzdMSBbn4xMHxLb2hnxKtsxat5ZWggdmEgQm93eWVyIEHhuKltYWR+MTh8S29yZGVzdMSBbn4xNnxMb3Jlc3TEgW5+MjB8TWFya2F6aX4yMnxNxIF6YW5kYXLEgW5+MjF8UWF6dsSrbn4yOHxRb21+MjZ8U2VtbsSBbn4xMnxTxKtzdMSBbiB2YSBCYWzFq2NoZXN0xIFufjEzfFRlaHLEgW5+MDd8WWF6ZH4yNXxaYW5qxIFufjExXCJdLCBbXCJJcmFxXCIsIFwiSVFcIiwgXCJBbCBBbmLEgXJ+QU58QWwgQmHFn3JhaH5CQXxBbCBNdXRoYW5uw6F+TVV8QWwgUcSBZGlzxKt5YWh+UUF8QW4gTmFqYWZ+TkF8QXJixKtsfkFSfEFzIFN1bGF5bcSBbsSreWFoflNVfELEgWJpbH5CQnxCYWdoZMSBZH5CR3xEb2h1a35EQXxEaMSrIFHEgXJ+RFF8RGl5xIFsw6F+REl8S2FyYmFsxIEnfktBfEtpcmt1a35LSXxNYXlzxIFufk1BfE7Eq25hd8Ohfk5JfMWeYWzEgeG4qSBhZCBExKtuflNEfFfEgXNpxaN+V0FcIl0sIFtcIklyZWxhbmRcIiwgXCJJRVwiLCBcIkNhcmxvd35DV3xDYXZhbn5DTnxDbGFyZX5DRXxDb3JrfkNPfERvbmVnYWx+REx8RHVibGlufkR8R2Fsd2F5fkd8S2Vycnl+S1l8S2lsZGFyZX5LRXxLaWxrZW5ueX5LS3xMYW9pc35MU3xMZWl0cmltfkxNfExpbWVyaWNrfkxLfExvbmdmb3JkfkxEfExvdXRofkxIfE1heW9+TU98TWVhdGh+TUh8TW9uYWdoYW5+TU58T2ZmYWx5fk9ZfFJvc2NvbW1vbn5STnxTbGlnb35TT3xUaXBwZXJhcnl+VEF8V2F0ZXJmb3JkfldEfFdlc3RtZWF0aH5XSHxXZXhmb3JkfldYfFdpY2tsb3d+V1dcIl0sIFtcIklzbGUgb2YgTWFuXCIsIFwiSU1cIiwgXCJJc2xlIG9mIE1hblwiXSwgW1wiSXNyYWVsXCIsIFwiSUxcIiwgXCJIYURhcm9tfkR8SGFNZXJrYXp+TXxIYVRzYWZvbn5afEjMsWVmYX5IQXxUZWwtQXZpdn5UQXxZZXJ1c2hhbGF5aW1+Sk1cIl0sIFtcIkl0YWx5XCIsIFwiSVRcIiwgXCJBYnJ1enpvfjY1fEJhc2lsaWNhdGF+Nzd8Q2FsYWJyaWF+Nzh8Q2FtcGFuaWF+NzJ8RW1pbGlhLVJvbWFnbmF+NDV8RnJpdWxpLVZlbmV6aWEgR2l1bGlhfjM2fExhemlvfjYyfExpZ3VyaWF+NDJ8TG9tYmFyZGlhfjI1fE1hcmNoZX41N3xNb2xpc2V+Njd8UGllbW9udGV+MjF8UHVnbGlhfjc1fFNhcmRlZ25hfjg4fFNpY2lsaWF+ODJ8VG9zY2FuYX41MnxUcmVudGluby1BbHRvIEFkaWdlfjMyfFVtYnJpYX41NXxWYWxsZSBkJ0Fvc3RhfjIzfFZlbmV0b34zNFwiXSwgW1wiSmFtYWljYVwiLCBcIkpNXCIsIFwiQ2xhcmVuZG9ufjEzfEhhbm92ZXJ+MDl8S2luZ3N0b25+MDF8TWFuY2hlc3Rlcn4xMnxQb3J0bGFuZH4wNHxTYWludCBBbmRyZXd+MDJ8U2FpbnQgQW5ufjA2fFNhaW50IENhdGhlcmluZX4xNHxTYWludCBFbGl6YWJldGh+MTF8U2FpbnQgSmFtZXN+MDh8U2FpbnQgTWFyeX4wNXxTYWludCBUaG9tYXN+MDN8VHJlbGF3bnl+MDd8V2VzdG1vcmVsYW5kfjEwXCJdLCBbXCJKYXBhblwiLCBcIkpQXCIsIFwiQWljaGl+MjN8QWtpdGF+MDV8QW9tb3JpfjAyfENoaWJhfjEyfEVoaW1lfjM4fEZ1a3VpfjE4fEZ1a3Vva2F+NDB8RnVrdXNoaW1hfjA3fEdpZnV+MjF8R3VubWF+MTB8SGlyb3NoaW1hfjM0fEhva2thaWRvfjAxfEh5b2dvfjI4fEliYXJha2l+MDh8SXNoaWthd2F+MTd8SXdhdGV+MDN8S2FnYXdhfjM3fEthZ29zaGltYX40NnxLYW5hZ2F3YX4xNHxLb2NoaX4zOXxLdW1hbW90b340M3xLeW90b34yNnxNaWV+MjR8TWl5YWdpfjA0fE1peWF6YWtpfjQ1fE5hZ2Fub34yMHxOYWdhc2FraX40MnxOYXJhfjI5fE5paWdhdGF+MTV8T2l0YX40NHxPa2F5YW1hfjMzfE9raW5hd2F+NDd8T3Nha2F+Mjd8U2FnYX40MXxTYWl0YW1hfjExfFNoaWdhfjI1fFNoaW1hbmV+MzJ8U2hpenVva2F+MjJ8VG9jaGlnaX4wOXxUb2t1c2hpbWF+MzZ8VG9reW9+MTN8VG90dG9yaX4zMXxUb3lhbWF+MTZ8V2FrYXlhbWF+MzB8WWFtYWdhdGF+MDZ8WWFtYWd1Y2hpfjM1fFlhbWFuYXNoaX4xOVwiXSwgW1wiSmVyc2V5XCIsIFwiSkVcIiwgXCJKZXJzZXlcIl0sIFtcIkpvcmRhblwiLCBcIkpPXCIsIFwi4oCYQWpsxatufkFKfEFsICdBcWFiYWh+QVF8QWwgQmFsccSB4oCZfkJBfEFsIEthcmFrfktBfEFsIE1hZnJhcX5NQXxBbCDigJhBzIXFn2ltYWh+QU18QcWjIMWiYWbEq2xhaH5BVHxBeiBaYXJxxIHigJl+QVp8SXJiaWR+SVJ8SmFyYXNofkpBfE1h4oCYxIFufk1OfE3EgWRhYsSBfk1EXCJdLCBbXCJLYXpha2hzdGFuXCIsIFwiS1pcIiwgXCJBbG1hdHl+QUxBfEFxbW9sYX5BS018QXF0b2JlfkFLVHxBc3RhbmF+QVNUfEF0eXJhdX5BVFl8QmF0eXMgUWF6YXFzdGFuflpBUHxCYXlxb25neXJ8TWFuZ2doeXN0YXV+TUFOfE9uZ3R1c3RpayBRYXphcXN0YW5+WVVafFBhdmxvZGFyflBBVnxRYXJhZ2hhbmR5fktBUnxRb3N0YW5heX5LVVN8UXl6eWxvcmRhfktaWXxTaHlnaHlzIFFhemFxc3Rhbn5WT1N8U29sdHVzdGlrIFFhemFxc3Rhbn5TRVZ8WmhhbWJ5bH5aSEFcIl0sIFtcIktlbnlhXCIsIFwiS0VcIiwgXCJCYXJpbmdvfjAxfEJvbWV0fjAyfEJ1bmdvbWF+MDN8QnVzaWF+MDR8RWxleW8vTWFyYWt3ZXR+MDV8RW1idX4wNnxHYXJpc3NhfjA3fEhvbWEgQmF5fjA4fElzaW9sb34wOXxLYWppYWRvfjEwfEtha2FtZWdhfjExfEtlcmljaG9+MTJ8S2lhbWJ1fjEzfEtpbGlmaX4xNHxLaXJpbnlhZ2F+MTV8S2lzaWl+MTZ8S2lzdW11fjE3fEtpdHVpfjE4fEt3YWxlfjE5fExhaWtpcGlhfjIwfExhbXV+MjF8TWFjaGFrb3N+MjJ8TWFrdWVuaX4yM3xNYW5kZXJhfjI0fE1hcnNhYml0fjI1fE1lcnV+MjZ8TWlnb3JpfjI3fE1vbWJhc2F+Mjh8TXVyYW5nJ2F+Mjl8TmFpcm9iaSBDaXR5fjMwfE5ha3VydX4zMXxOYW5kaX4zMnxOYXJva34zM3xOeWFtaXJhfjM0fE55YW5kYXJ1YX4zNXxOeWVyaX4zNnxTYW1idXJ1fjM3fFNpYXlhfjM4fFRhaXRhL1RhdmV0YX4zOXxUYW5hIFJpdmVyfjQwfFRoYXJha2EtTml0aGl+NDF8VHJhbnMgTnpvaWF+NDJ8VHVya2FuYX40M3xVYXNpbiBHaXNodX40NHxWaWhpZ2F+NDV8V2FqaXJ+NDZ8V2VzdCBQb2tvdH40N1wiXSwgW1wiS2lyaWJhdGlcIiwgXCJLSVwiLCBcIkFiYWlhbmd8QWJlbWFtYXxBcmFudWthfEFyb3JhZXxCYW5hYmF8QmVydXxCdXRhcml0YXJpfENlbnRyYWwgR2lsYmVydHN8R2lsYmVydCBJc2xhbmRzfkd8S2FudG9ufEtpcml0aW1hdGl8S3VyaWF8TGluZSBJc2xhbmRzfkx8TWFpYW5hfE1ha2lufE1hcmFrZWl8TmlrdW5hdXxOb25vdXRpfE5vcnRoZXJuIEdpbGJlcnRzfE9ub3RvYXxQaG9lbml4IElzbGFuZHN+UHxTb3V0aGVybiBHaWxiZXJ0c3xUYWJpdGV1ZWF8VGFidWFlcmFufFRhbWFuYXxUYXJhd2F8VGVyYWluYVwiXSwgW1wiS29yZWEsIERlbW9jcmF0aWMgUGVvcGxlJ3MgUmVwdWJsaWMgb2ZcIiwgXCJLUFwiLCBcIkNoYWdhbmctZG8gKENoYWdhbmcgUHJvdmluY2UpfjA0fEhhbWd5b25nLWJ1a3RvIChOb3J0aCBIYW1neW9uZyBQcm92aW5jZSl+MDl8SGFtZ3lvbmctbmFtZG8gKFNvdXRoIEhhbWd5b25nIFByb3ZpbmNlKX4wOHxId2FuZ2hhZS1idWt0byAoTm9ydGggSHdhbmdoYWUgUHJvdmluY2UpfjA2fEh3YW5naGFlLW5hbWRvIChTb3V0aCBId2FuZ2hhZSBQcm92aW5jZSl+MDV8S2FuZ3dvbi1kbyAoS2FuZ3dvbiBQcm92aW5jZSl+MDd8TmFzxY9uIChOYWppbi1TxY9uYm9uZyl+MTN8UCd5b25nYW4tYnVrdG8gKE5vcnRoIFAneW9uZ2FuIFByb3ZpbmNlKX4wM3xQJ3lvbmdhbi1uYW1kbyAoU291dGggUCd5b25nYW4gUHJvdmluY2UpfjAyfFAneW9uZ3lhbmctc2kgKFAneW9uZ3lhbmcgQ2l0eSl+MDF8WWFuZ2dhbmctZG8gKFlhbmdnYW5nIFByb3ZpbmNlKX4xMFwiXSwgW1wiS29yZWEsIFJlcHVibGljIG9mXCIsIFwiS1JcIiwgXCJDaCd1bmdjaCdvbmdidWstZG9+NDN8Q2gndW5nY2gnb25nbmFtLWRvfjQ0fENoZWp1LWRvfjQ5fENob2xsYWJ1ay1kb340NXxDaG9sbGFuYW0tZG9+NDZ8SW5jaCdvbi1Ld2FuZ3lva2hpfjI4fEthbmctd29uLWRvfjQyfEt3YW5nanUtS3dhbmd5b2tzaGl+Mjh8S3lvbmdnaS1kb340MXxLeW9uZ3NhbmdidWstZG9+NDd8S3lvbmdzYW5nbmFtLWRvfjQ4fFB1c2FuLUt3YW5neW9rc2hpfjI2fFNlb3VsLVQndWtweW9sc2hpfjExfFNlam9uZ341MHxUYWVndS1Ld2FuZ3lva3NoaX4yN3xUYWVqb24tS3dhbmd5b2tzaGl+MzB8VWxzYW4tS3dhbmd5b2tzaGl+MzFcIl0sIFtcIkt1d2FpdFwiLCBcIktXXCIsIFwiQWwgQeG4qW1hZGl+QUh8QWwgRmFyd8SBbsSreWFofkZBfEFsIEphaHLEgeKAmX5KQXxBbCDigJjEgMWfaW1haH5LVXzhuKhhd2FsbMSrfkhBfE11YsSBcmFrIGFsIEthYmlyfk1VXCJdLCBbXCJLeXJneXpzdGFuXCIsIFwiS0dcIiwgXCJCYXRrZW4gT2JsYXN0eX5CfEJpc2hrZWsgU2hhYXJ5fkdCfENodXkgT2JsYXN0eSAoQmlzaGtlayl+Q3xKYWxhbC1BYmFkIE9ibGFzdHl+SnxOYXJ5biBPYmxhc3R5fk58T3NoIE9ibGFzdHl+T3xUYWxhcyBPYmxhc3R5flR8WXN5ay1Lb2wgT2JsYXN0eSAoS2FyYWtvbCl+WVwiXSwgW1wiTGFvc1wiLCBcIkxBXCIsIFwiQXR0YXB1fkFUfEJva8Oob35CS3xCb2xpa2hhbXhhaX5CTHxDaGFtcGFzYWt+Q0h8SG91YXBoYW5+SE98S2hhbW1vdWFufktIfExvdWFuZyBOYW10aGF+TE18TG91YW5ncGhhYmFuZ35MUHxPdWTDtG14YWl+T1V8UGjDtG5nc2FsaX5QSHxTYWxhdmFuflNMfFNhdmFubmFraMOpdH5TVnxWaWVudGlhbmV+Vkl8WGFpZ25hYm91bGl+WEF8WMOpa29uZ35YRXxYYWlzb21ib3VuflhTfFhpYW5na2hvdWFuZ35YSVwiXSwgW1wiTGF0dmlhXCIsIFwiTFZcIiwgXCJBZ2xvbmF+MDAxfEFpemtyYXVrbGV+MDAyfEFpenB1dGV+MDAzfEFrbsSrc3RlfjAwNHxBbG9qYX4wMDV8QWxzdW5nYX4wNnxBbMWra3NuZX4wMDd8QW1hdGF+MDA4fEFwZX4wMDl8QXVjZX4wMTB8xIBkYcW+aX4wMTF8QmFixKt0ZX4wMTJ8QmFsZG9uZX4wMTN8QmFsdGluYXZhfjAxNHxCYWx2aX4wMTV8QmF1c2thfjAxNnxCZXZlcsSrbmF+MDE3fEJyb2PEk25pfjAxOHxCdXJ0bmlla2l+MDE5fENhcm5pa2F2YX4wMjB8Q2VzdmFpbmV+MDIxfEPEk3Npc34wMjJ8Q2libGF+MDIzfERhZ2RhfjAyNHxEYXVnYXZwaWxzfjAyNXxEYXVnYXZwaWxzIChDaXR5KX5ER1Z8RG9iZWxlfjAyNnxEdW5kYWdhfjAyN3xEdXJiZX4wMjh8RW5ndXJlfjAyOXzEknJnxLxpfjAzMHxHYXJrYWxuZX4wMzF8R3JvYmnFhmF+MDMyfEd1bGJlbmV+MDMzfEllY2F2YX4wMzR8SWvFocS3aWxlfjAzNXxJbMWra3N0ZX4wMzZ8SW7EjXVrYWxuc34wMzd8SmF1bmplbGdhdmF+MDM4fEphdW5waWViYWxnYX4wMzl8SmF1bnBpbHN+MDQwfEplbGdhdmF+MDQxfEplbGdhdmEgKENpdHkpfkpFTHxKxJNrYWJwaWxzfjA0MnxKxJNrYWJwaWxzIChDaXR5KX5KS0J8SsWrcm1hbGEgKENpdHkpfkpVUnxLYW5kYXZhfjA0M3xLxIFyc2F2YX4wNDR8S29jxJNuaX4wNDV8S29rbmVzZX4wNDZ8S3LEgXNsYXZhfjA0N3xLcmltdWxkYX4wNDh8S3J1c3RwaWxzfjA0OXxLdWxkxKtnYX4wNTB8xLZlZ3Vtc34wNTF8xLZla2F2YX4wNTJ8TGllbHbEgXJkZX4wNTN8TGllcMSBamF+TFBYfExpbWJhxb5pfjA1NHxMxKtnYXRuZX4wNTV8TMSrdsSBbml+MDU2fEx1YsSBbmF+MDU3fEx1ZHphfjA1OHxNYWRvbmF+MDU5fE1henNhbGFjYX4wNjB8TcSBbHBpbHN+MDYxfE3EgXJ1cGV+MDYyfE3Ek3JzcmFnc34wNjN8TmF1a8WhxJNuaX4wNjR8TmVyZXRhfjA2NXxOxKtjYX4wNjZ8T2dyZX4wNjd8T2xhaW5lfjA2OHxPem9sbmlla2l+MDY5fFDEgXJnYXVqYX4wNzB8UMSBdmlsb3N0YX4wNzF8UMS8YXZpxYZhc34wNzJ8UHJlacS8aX4wNzN8UHJpZWt1bGV+MDc0fFByaWVrdcS8aX4wNzV8UmF1bmF+MDc2fFLEk3pla25lfjA3N3xSxJN6ZWtuZSAoQ2l0eSl+UkVafFJpZWJpxYZpfjA3OHxSxKtnYX5SSVh8Um9qYX4wNzl8Um9wYcW+aX4wODB8UnVjYXZhfjA4MXxSdWfEgWppfjA4MnxSdW5kxIFsZX4wODN8UsWramllbmF+MDg0fFNhbGF+MDg1fFNhbGFjZ3LEq3ZhfjA4NnxTYWxhc3BpbHN+MDg3fFNhbGR1c34wODh8U2F1bGtyYXN0aX4wODl8U8STamF+MDkwfFNpZ3VsZGF+MDkxfFNrcsSrdmVyaX4wOTJ8U2tydW5kYX4wOTN8U21pbHRlbmV+MDk0fFN0b3BpxYZpfjA5NXxTdHJlbsSNaX4wOTZ8VGFsc2l+MDk3fFTEk3J2ZXRlfjA5OHxUdWt1bXN+MDk5fFZhacWGb2RlfjEwMHxWYWxrYX4xMDF8VmFsbWllcmF+Vk1SfFZhcmFrxLzEgW5pfjEwMnxWxIFya2F2YX4xMDN8VmVjcGllYmFsZ2F+MTA0fFZlY3Vtbmlla2l+MTA1fFZlbnRzcGlsc34xMDZ8VmVudHNwaWxzIChDaXR5KX5WRU58Vmllc8SrdGV+MTA3fFZpxLxha2F+MTA4fFZpxLzEgW5pfjEwOXxaaWx1cGV+MTEwXCJdLCBbXCJMZWJhbm9uXCIsIFwiTEJcIiwgXCJBYWtrw6JyfkFLfEJhYWxiZWxrLUhlcm1lbH5CSHxCw6lxYWF+Qkl8QmV5cm91dGh+QkF8TGliYW4tTm9yZH5BU3xMaWJhbi1TdWR+SkF8TW9udC1MaWJhbn5KTHxOYWJhdMOuecOpfk5BXCJdLCBbXCJMZXNvdGhvXCIsIFwiTFNcIiwgXCJCZXJlYX5EfEJ1dGhhLUJ1dGhlfkJ8TGVyaWJlfkN8TWFmZXRlbmd+RXxNYXNlcnV+QXxNb2hhbGVzIEhvZWt+RnxNb2tob3Rsb25nfkp8UWFjaGEncyBOZWt+SHxRdXRoaW5nfkd8VGhhYmEtVHNla2F+S1wiXSwgW1wiTGliZXJpYVwiLCBcIkxSXCIsIFwiQm9taX5CTXxCb25nfkJHfEdiYXJwb2x1fkdQfEdyYW5kIEJhc3NhfkdCfEdyYW5kIENhcGUgTW91bnR+Q018R3JhbmQgR2VkZWh+R0d8R3JhbmQgS3J1fkdLfExvZmF+TE98TWFyZ2liaX5NR3xNYXJ5bGFuZH5NWXxNb250c2VycmFkb35NT3xOaW1iYX5OSXxSaXZlciBDZXNzflJJfFJpdmVyIEdlZWV+Ukd8U2lub2V+U0lcIl0sIFtcIkxpYnlhXCIsIFwiTFlcIiwgXCJBbCBCdcWjbsSBbn5CVXxBbCBKYWJhbCBhbCBBa2jhuJFhcn5KQXxBbCBKYWJhbCBhbCBHaGFyYsSrfkpHfEFsIEphZsSBcmFofkpBfEFsIEp1ZnJhaH5KVXxBbCBLdWZyYWh+Rkt8QWwgTWFyan5NSnxBbCBNYXJxdWFifk1CfEFsIFfEgeG4qcSBdH5XQXxBbiBOdXFhxaMgYWwgS2hhbXN+TlF8QXogWsSBd2l5YWh+WkF8QmFuZ2jEgXrEq35CQXxEYXJuYWh+RFJ8R2jEgXR+R0h8TWnFn3LEgXRhaH5NSXxNdXJ6dXF+TVF8TsSBbMWrdH5OTHxTYWJoxIF+U0J8U3VydH5TUnzFomFyxIFidWx1c35UQnxZYWZyYW5+V0R8V8SBZMSrIGFzaCBTaMSBxaNpyr5+V1NcIl0sIFtcIkxpZWNodGVuc3RlaW5cIiwgXCJMSVwiLCBcIkJhbHplcnN+MDF8RXNjaGVufjAyfEdhbXByaW5+MDN8TWF1cmVufjA0fFBsYW5rZW5+MDV8UnVnZ2VsbH4wNnxTY2hhYW5+MDd8U2NoZWxsZW5iZXJnfjA4fFRyaWVzZW5+MDl8VHJpZXNlbmJlcmd+MTB8VmFkdXp+MTFcIl0sIFtcIkxpdGh1YW5pYVwiLCBcIkxUXCIsIFwiQWx5dGF1c35BTHxLYXVub35LVXxLbGFpcMSXZG9zfktMfE1hcmlqYW1wb2zEl3N+TVJ8UGFuZXbEl8W+aW9+UE58xaBpYXVsacWzflNBfFRhdXJhZ8SXc35UQXxUZWzFoWnFs35URXxVdGVub3N+VVR8VmlsbmlhdXN+VkxcIl0sIFtcIkx1eGVtYm91cmdcIiwgXCJMVVwiLCBcIkNhcGVsbGVufkNBfENsZXZhdXh+Q0x8RGlla2lyY2h+REl8RWNodGVybmFjaH5FQ3xFc2NoLXN1ci1BbHpldHRlfkVTfEdyZXZlbm1hY2hlcn5HUnxMdXhlbWJvdXJnfkxVfE1lcnNjaH5NRXxSZWRhbmdlflJEfFJlbWljaH5STXxWaWFuZGVuflZEfFdpbHR6fldJXCJdLCBbXCJNYWNhb1wiLCBcIk1PXCIsIFwiTWFjYW9cIl0sIFtcIk1hY2Vkb25pYSwgUmVwdWJsaWMgb2ZcIiwgXCJNS1wiLCBcIkFyYcSNaW5vdm9+MDJ8QmVyb3ZvfjAzfEJpdG9sYX4wNHxCb2dkYW5jaX4wNXxCb2dvdmluamV+MDZ8Qm9zaWxvdm9+MDd8QnJ2ZW5pY2F+MDh8Q2VudGFyIMW9dXBhfjc4fMSMYcWha2F+MDh8xIxlxaFpbm92by1PYmxlxaFldm9+ODF8xIx1xI1lciBTYW5kZXZvfjgyfERlYmFyfjIxfERlYmFyY2F+MjJ8RGVsxI1ldm9+MjN8RGVtaXIgSGlzYXJ+MjV8RGVtaXIgS2FwaWphfjI0fERvcmFufjI2fERvbG5lbml+Mjd8R2V2Z2VsaWphfjE4fEdvc3RpdmFyfjE5fEdyYWRza29+MjB8SWxpbmRlbn4zNHxKZWd1bm92Y2V+MzV8S2FyYmluY2l+Mzd8S2F2YWRhcmNpfjM2fEtpxI1ldm9+NDB8S2/EjWFuaX40MnxLb27EjWV+NDF8S3JhdG92b340M3xLcml2YSBQYWxhbmthfjQ0fEtyaXZvZ2HFoXRhbml+NDV8S3J1xaFldm9+NDZ8S3VtYW5vdm9+NDd8TGlwa292b340OHxMb3pvdm9+NDl8TWFrZWRvbnNrYSBLYW1lbmljYX41MXxNYWtlZG9uc2tpIEJyb2R+NTJ8TWF2cm92byBpIFJvc3R1xaFhfjUwfE1vZ2lsYX41M3xOZWdvdGlub341NHxOb3ZhY2l+NTV8Tm92byBTZWxvfjU2fE9ocmlkfjU4fFBlaMSNZXZvfjYwfFBldHJvdmVjfjU5fFBsYXNuaWNhfjYxfFByaWxlcH42MnxQcm9iacWhdGlwfjYzfFJhZG92acWhfnxSYW5rb3ZjZX42NXxSZXNlbn42NnxSb3NvbWFufjY3fFNrb3BqZX44NXxTb3BpxaF0ZX43MHxTdGFybyBOYWdvcmnEjWFuZX43MXxTdHJ1Z2F+NzJ8U3RydW1pY2F+NzN8U3R1ZGVuacSNYW5pfjc0fFN2ZXRpIE5pa29sZX42OXzFoHRpcH44M3xUZWFyY2V+NzV8VGV0b3Zvfjc2fFZhbGFuZG92b34xMHxWYXNpbGV2b34xMXxWZWxlc34xM3xWZXbEjWFuaX4xMnxWaW5pY2F+MTR8VnJhcMSNacWhdGV+MTZ8WmVsZW5pa292b34zMnxacm5vdmNpfjMzfMW9ZWxpbm9+MzBcIl0sIFtcIk1hZGFnYXNjYXJcIiwgXCJNR1wiLCBcIkFudGFuYW5hcml2b35UfEFudHNpcmFuYW5hfkR8RmlhbmFyYW50c29hfkZ8TWFoYWphbmdhfk18VG9hbWFzaW5hfkF8VG9saWFyYX5VXCJdLCBbXCJNYWxhd2lcIiwgXCJNV1wiLCBcIkJhbGFrYX5CQXxCbGFudHlyZX5CTHxDaGlrd2F3YX5DS3xDaGlyYWR6dWx1fkNSfENoaXRpcGF+Q1R8RGVkemF+REV8RG93YX5ET3xLYXJvbmdhfktSfEthc3VuZ3V+S1N8TGlrb21hfkxLfExpbG9uZ3dlfkxJfE1hY2hpbmdhfk1IfE1hbmdvY2hpfk1HfE1jaGluaml+TUN8TXVsYW5qZX5NVXxNd2FuemF+TVd8TXppbWJhfk1afE5raGF0YSBCYXl+TkV8Tmtob3Rha290YX5OQnxOc2FuamV+TlN8TnRjaGV1fk5VfE50Y2hpc2l+Tkl8UGhhbG9tYmV+UEh8UnVtcGhpflJVfFNhbGltYX5TQXxUaHlvbG9+VEh8Wm9tYmF+Wk9cIl0sIFtcIk1hbGF5c2lhXCIsIFwiTVlcIiwgXCJKb2hvcn4wMXxLZWRhaH4wMnxLZWxhbnRhbn4wM3xNZWxha2F+MDR8TmVnZXJpIFNlbWJpbGFufjA1fFBhaGFuZ34wNnxQZXJha34wOHxQZXJsaXN+MDl8UHVsYXUgUGluYW5nfjA3fFNhYmFofjEyfFNhcmF3YWt+MTN8U2VsYW5nb3J+MTB8VGVyZW5nZ2FudX4xMXxXaWxheWFoIFBlcnNla3V0dWFuIChLdWFsYSBMdW1wdXIpfjE0fFdpbGF5YWggUGVyc2VrdXR1YW4gKExhYnVhbil+MTV8V2lsYXlhaCBQZXJzZWt1dHVhbiAoUHV0cmFqYXlhKX4xNlwiXSwgW1wiTWFsZGl2ZXNcIiwgXCJNVlwiLCBcIkFsaWZ1IEFsaWZ1fjAyfEFsaWZ1IERoYWFsdX4wMHxCYWF+MjB8RGhhYWx1fjE3fEZhYWZ1fjE0fEdhYWZ1IEFsaWZ1fjI3fEdhYWZ1IERoYWFsdX4yOHxHbmF2aXlhbml+Mjl8SGFhIEFsaWZ1fjA3fEhhYSBEaGFhbHV+MjN8S2FhZnV+Mjl8TGFhbXV+MDV8TGhhdml5YW5pfjAzfE1hbMOpfk1MRXxNZWVtdX4xMnxOb29udX4yNXxSYWF+MTN8U2VlbnV+MDF8U2hhdml5YW5pfjI0fFRoYWF+MDh8VmFhdnV+MDRcIl0sIFtcIk1hbGlcIiwgXCJNTFwiLCBcIkJhbWFrb35CS098R2Fvfjd8S2F5ZXN+MXxLaWRhbH44fEtvdWxpa29yb34yfE1vcHRpfjV8U2Vnb3V+NHxTaWthc3NvfjN8VG9tYm91Y3RvdX42XCJdLCBbXCJNYWx0YVwiLCBcIk1UXCIsIFwiQXR0YXJkfjAxfEJhbHphbn4wMnxCaXJndX4wM3xCaXJraXJrYXJhfjA0fEJpcsW8ZWJidcShYX4wNXxCb3JtbGF+MDZ8RGluZ2xpfjA3fEZndXJhfjA4fEZsb3JpYW5hfjA5fEZvbnRhbmF+MTB8R3VkYX4xMXxHxbxpcmF+MTJ8R8SnYWpuc2llbGVtfjEzfEfEp2FyYn4xNHxHxKdhcmfEp3VyfjE1fEfEp2Fzcml+MTZ8R8SnYXhhcX4xN3zEpmFtcnVufjE4fElrbGlufjE5fElzbGF+MjB8S2Fsa2FyYX4yMXxLZXLEi2VtfjIyfEtpcmtvcH4yM3xMaWphfjI0fEx1cWF+MjV8TWFyc2F+MjZ8TWFyc2Fza2FsYX4yN3xNYXJzYXhsb2trfjI4fE1kaW5hfjI5fE1lbGxpZcSnYX4zMHxNxKFhcnJ+MzF8TW9zdGF+MzJ8TXFhYmJhfjMzfE1zaWRhfjM0fE10YXJmYX4zNXxNdW54YXJ+MzZ8TmFkdXJ+Mzd8TmF4eGFyfjM4fFBhb2xhfjM5fFBlbWJyb2tlfjQwfFBpZXTDoH40MXxRYWxhfjQyfFFvcm1pfjQzfFFyZW5kaX40NHxSYWJhdCBHxKdhd2RleH40NXxSYWJhdCBNYWx0YX40NnxTYWZpfjQ3fFNhbiDEoGlsamFufjQ4fFNhbiDEoHdhbm5+NDl8U2FuIExhd3Jlbnp+NTB8U2FuIFBhd2wgaWwtQmHEp2FyfjUxfFNhbm5hdH41MnxTYW50YSBMdcSLaWphfjUzfFNhbnRhIFZlbmVyYX41NHxTacShxKFpZXdpfjU1fFNsaWVtYX41NnxTd2llcWl+NTd8VGFpIFhiaWV4fjU4fFRhcnppZW5+NTl8VmFsbGV0dGF+NjB8WGFnxKdyYX42MXxYZXdraWphfjYyfFhnxKdhanJhfjYzfMW7YWJiYXJ+NjR8xbtlYmJ1xKEgR8SnYXdkZX42NXzFu2ViYnXEoSBNYWx0YX42NnzFu2VqdHVufjY3fMW7dXJyaWVxfjY4XCJdLCBbXCJNYXJzaGFsbCBJc2xhbmRzXCIsIFwiTUhcIiwgXCJBaWxpbmdsYXBsYXB+QUxMfEFpbHVrfkFMS3xBcm5vfkFSTnxBdXJ+QVVSfEJpa2luaSBhbmQgS2lsaX5LSUx8RWJvbn5FQk98SmFiYXR+SkFCfEphbHVpdH5KQUx8S3dhamFsZWlufktXQXxMYWV+TEFFfExpYn5MSUJ8TGlraWVwfkxJS3xNYWp1cm9+TUFKfE1hbG9lbGFwfk1BTHxNZWppdH5NRUp8TmFtZHJpa35OTUt8TmFtdX5OTVV8Um9uZ2VsYXB+Uk9OfFVqYWV+VUpBfFV0cmlrflVUSXxXb3Rob35XVEh8V290amV+V1RKXCJdLCBbXCJNYXJ0aW5pcXVlXCIsIFwiTVFcIiwgXCJNYXJ0aW5pcXVlXCJdLCBbXCJNYXVyaXRhbmlhXCIsIFwiTVJcIiwgXCJBZHJhcn4wN3xBc3NhYmF+MDN8QnJha25hfjA1fERha2hsZXQgTm91YWRoaWJvdX4wOHxHb3Jnb2x+MDR8R3VpZGltYWthfjEwfEhvZGggRWNoIENoYXJndWl+MDF8SG9kaCBFbCBHaGFyYml+MDJ8SW5jaGlyaX4xMnxOb3Vha2Nob3R0IE5vcmR+MTR8Tm91YWtjaG90dCBPdWVzdH4xM3xOb3Vha2Nob3R0IFN1ZH4xNXxUYWdhbnR+MDl8VGlyaXMgWmVtbW91cn4xMXxUcmFyemF+MDZcIl0sIFtcIk1hdXJpdGl1c1wiLCBcIk1VXCIsIFwiQWdhbGVnYSBJc2xhbmRzfkFHfEJlYXUgQmFzc2luLVJvc2UgSGlsbH5CUnxCbGFjayBSaXZlcn5CTHxDYXJnYWRvcyBDYXJham9zIFNob2Fsc35DQ3xDdXJlcGlwZX5DVXxGbGFjcX5GTHxHcmFuZCBQb3J0fkdQfE1va2F+TU98UGFtcGxlbW91c3Nlc35QQXxQbGFpbmVzIFdpbGhlbXN+UFd8UG9ydCBMb3VpcyAoQ2l0eSl+UFV8UG9ydCBMb3Vpc35QTHxSaXZpZXJlIGR1IFJlbXBhcnR+UlJ8Um9kcmlndWVzIElzbGFuZH5ST3xTYXZhbm5lflNBfFZhY29hcy1QaG9lbml4fkNQXCJdLCBbXCJNYXlvdHRlXCIsIFwiWVRcIiwgXCJEemFvdWR6aX4wMXxQYW1hbmR6aX4wMnxNYW1vdWR6b3V+MDN8RGVtYmVuaX4wNHxCYW5kcsOpbMOpfjA1fEthbmktS8OpbGl+MDZ8Qm91w6luaX4wN3xDaGlyb25ndWl+MDh8U2FkYX4wOXxPdWFuZ2FuaX4xMHxDaGljb25pfjExfFRzaW5nb25pfjEyfE0nVHNhbmdhbW91aml+MTN8QWNvdWF+MTR8TXRzYW1ib3JvfjE1fEJhbmRyYWJvdWF+MTZ8S291bmdvdX4xN1wiXSwgW1wiTWV4aWNvXCIsIFwiTVhcIiwgXCJBZ3Vhc2NhbGllbnRlc35BR1V8QmFqYSBDYWxpZm9ybmlhfkJDTnxCYWphIENhbGlmb3JuaWEgU3VyfkJDU3xDYW1wZWNoZX5DQU18Q2l1ZGFkIGRlIE3DqXhpY29+RElGfENoaWFwYXN+Q0hQfENoaWh1YWh1YX5DSEh8Q29haHVpbGEgZGUgWmFyYWdvemF+Q09BfENvbGltYX5DT0x8RHVyYW5nb35EVVJ8RXN0YWRvIGRlIE3DqXhpY29+TUVYfEd1YW5hanVhdG9+R1VBfEd1ZXJyZXJvfkdST3xIaWRhbGdvfkhJRHxKYWxpc2NvfkpBTHxNaWNob2Fjw6FuIGRlIE9jYW1wb35NSUN8TW9yZWxvc35NT1J8TmF5YXJpdH5OQVl8TnVldm8gTGXDs25+TkxFfE9heGFjYX5PQVh8UHVlYmxhflBVRXxRdWVyw6l0YXJvIGRlIEFydGVhZ2F+UVVFfFF1aW50YW5hIFJvb35ST098U2FuIEx1aXMgUG90b3PDrX5TTFB8U2luYWxvYX5TSU58U29ub3JhflNPTnxUYWJhc2NvflRBQnxUYW1hdWxpcGFzflRBTXxUbGF4Y2FsYX5UTEF8VmVyYWNydXp+VkVSfFl1Y2F0w6FufllVQ3xaYWNhdGVjYXN+WkFDXCJdLCBbXCJNaWNyb25lc2lhLCBGZWRlcmF0ZWQgU3RhdGVzIG9mXCIsIFwiRk1cIiwgXCJDaHV1ayAoVHJ1ayl+VFJLfEtvc3JhZX5LU0F8UG9obnBlaX5QTkl8WWFwfllBUFwiXSwgW1wiTW9sZG92YVwiLCBcIk1EXCIsIFwiQWVuaWkgTm9pfkFOfEJhc2FyYWJlYXNjYX5CU3xCxINsyJtpfkJBfEJlbmRlcn5CRHxCcmljZW5pfkJSfENhaHVsfkNBfENhbnRlbWlyfkNUfEPEg2zEg3JhyJlpfkNMfEPEg3XImWVuaX5DU3xDaGnImWluxIN1fkNVfENpbWnImWxpYX5DTXxDcml1bGVuaX5DUnxEb25kdciZZW5pfkRPfERyb2NoaWF+RFJ8RHVixINzYXJpfkRVfEVkaW5lyJt+RUR8RsSDbGXImXRpfkZBfEZsb3JlyJl0aX5GTHxHxINnxIN1emlhfkdBfEdsb2Rlbml+R0x8SMOubmNlyJl0aX5ISXxJYWxvdmVuaX5JQXxMZW92YX5MRXxOaXNwb3Jlbml+Tkl8T2NuacibYX5PQ3xPcmhlaX5PUnxSZXppbmF+UkV8UsOuyJljYW5pflJJfFPDrm5nZXJlaX5TSXxTb3JvY2F+U098U3TDrm5nYSBOaXN0cnVsdWl+U058U3RyxIPImWVuaX5TVHzImG9sZMSDbmXImXRpflNEfMiYdGVmYW4gVm9kxIN+U1Z8VGFyYWNsaWF+VEF8VGVsZW5lyJl0aX5URXxVbmdoZW5pflVOXCJdLCBbXCJNb25hY29cIiwgXCJNQ1wiLCBcIkNvbGxlfkNMfENvbmRhbWluZX5DT3xGb250dmllaWxsZX5GT3xHYXJlfkdBfEphcmRpbiBFeG90aXF1ZX5KRXxMYXJ2b3R0b35MQXxNYWxib3VzcXVldH5NQXxNb25hY28tVmlsbGV+TU98TW9uZWdoZXR0aX5NR3xNb250ZS1DYXJsb35NQ3xNb3VsaW5zfk1VfFBvcnQtSGVyY3VsZX5QSHxTYWludC1Sb21hbn5TUnxTYWludGUtRMOpdm90ZX5TRHxTb3VyY2V+U098U3DDqWx1Z3Vlc35TUHxWYWxsb24gZGUgbGEgUm91c3NlflZSXCJdLCBbXCJNb25nb2xpYVwiLCBcIk1OXCIsIFwiQXJoYW5nYXl+MDczfEJheWFuLU9sZ2l5fjA3MXxCYXlhbmhvbmdvcn4wNjl8QnVsZ2FufjA2N3xEYXJoYW5+MDM3fERvcm5vZH4wNjF8RG9ybm9nb3ZpfjA2M3xEdW5kZ292aX4wNTl8RHphdmhhbn4wNjV8R292aS1BbHRheX4wNjV8R292aS1TdW1iZXJ+MDY0fEhvdmR+MDQzfEhvdnNnb2x+MDQxfE9tbm9nb3ZpfjA1M3xPdm9yaGFuZ2F5fjA1NXxTZWxlbmdlfjA0OXxTdWhiYWF0YXJ+MDUxfFRvdn4wNDd8VWxhYW5iYWF0YXJ+MXxVdnN+MDQ2XCJdLCBbXCJNb250ZW5lZ3JvXCIsIFwiTUVcIiwgXCJBbmRyaWpldmljYX4wMXxCYXJ+MDJ8QmVyYW5lfjAzfEJpamVsbyBQb2xqZX4wNHxCdWR2YX4wNXxDZXRpbmplfjA2fERhbmlsb3ZncmFkfjA3fEd1c2luamV+MjJ8SGVyY2VnIE5vdml+MDh8S29sYcWhaW5+MDl8S290b3J+MTB8TW9qa292YWN+MTF8TmlrxaFpxId+MTJ8UGV0bmljYX4yM3xQbGF2fjEzfFBsdcW+aW5lfjE0fFBsamV2bGphfjE1fFBvZGdvcmljYX4xNnxSb8W+YWplfjE3fMWgYXZuaWt+MTh8VGl2YXR+MTl8VWxjaW5qfjIwfMW9YWJsamFrfjIxXCJdLCBbXCJNb250c2VycmF0XCIsIFwiTVNcIiwgXCJTYWludCBBbnRob255fFNhaW50IEdlb3JnZXN8U2FpbnQgUGV0ZXInc1wiXSwgW1wiTW9yb2Njb1wiLCBcIk1BXCIsIFwiQ2hhb3VpYS1PdWFyZGlnaGF+MDl8RG91a2hhbGEtQWJkYX4xMHxGw6hzLUJvdWxlbWFuZX4wNXxHaGFyYi1DaHJhcmRhLUJlbmkgSHNzZW5+MDJ8R3JhbmQgQ2FzYWJsYW5jYX4wOHxHdWVsbWltLUVzIFNlbWFyYX4xNHxMYcOieW91bmUtQm91amRvdXItU2FraWEgZWwgSGFtcmF+MTV8TWFycmFrZWNoLVRlbnNpZnQtQWwgSGFvdXp+MTF8TWVrbsOocy1UYWZpbGFsZXR+MDZ8T3JpZW50YWx+MDR8T3VlZCBlZCBEYWhhYi1MYWdvdWlyYX4xNnxTb3Vzcy1NYXNzYS1EcsOiYX4xM3xUYWRsYS1BemlsYWx+MTJ8VGFuZ2VyLVTDqXRvdWFufjAxfFRhemEtQWwgSG9jZWltYS1UYW91bmF0ZX4wM1wiXSwgW1wiTW96YW1iaXF1ZVwiLCBcIk1aXCIsIFwiQ2FibyBEZWxnYWRvflB8R2F6YX5HfEluaGFtYmFuZX5JfE1hbmljYX5CfE1hcHV0b35MfE1hcHV0byAoQ2l0eSl+TVBNfE5hbXB1bGF+TnxOaWFzc2F+QXxTb2ZhbGF+U3xUZXRlflR8WmFtYmV6aWF+UVwiXSwgW1wiTXlhbm1hclwiLCBcIk1NXCIsIFwiQXlleWFyd2FkeX4wN3xCYWdvfjAyfENoaW5+MTR8S2FjaGlufjExfEtheWFofjEyfEtheWlufjEzfE1hZ3dheX4wM3xNYW5kYWxheX4wNHxNb25+MTV8TmF5IFB5aSBUYXd+MTh8UmFraGluZX4xNnxTYWdhaW5nfjAxfFNoYW5+MTd8VGFuaW50aGFyeWl+MDV8WWFuZ29ufjA2XCJdLCBbXCJOYW1pYmlhXCIsIFwiTkFcIiwgXCJFcm9uZ29+RVJ8SGFyZGFwfkhBfEthdmFuZ28gRWFzdH5LRXxLYXZhbmdvIFdlc3R+S1d8S2FyYXN+S0F8S2hvbWFzfktIfEt1bmVuZX5LVXxPaGFuZ3dlbmF+T1d8T21haGVrZX5PSHxPbXVzYXRpfk9TfE9zaGFuYX5PTnxPc2hpa290b35PVHxPdGpvem9uZGp1cGF+T0R8WmFtYmV6aX5DQVwiXSwgW1wiTmF1cnVcIiwgXCJOUlwiLCBcIkFpd29+MDF8QW5hYmFyfjAyfEFuZXRhbn4wM3xBbmliYXJlfjA0fEJhaXRpfjA1fEJvZX4wNnxCdWFkYX4wN3xEZW5pZ29tb2R1fjA4fEV3YX4wOXxJanV3fjEwfE1lbmVuZ34xMXxOaWJva34xMnxVYWJvZX4xM3xZYXJlbn4xNFwiXSwgW1wiTmVwYWxcIiwgXCJOUFwiLCBcIkJhZ21hdGl+QkF8Qmhlcml+Qkh8RGhhd2FsYWdpcml+REh8R2FuZGFraX5HQXxKYW5ha3B1cn5KQXxLYXJuYWxpfktBfEtvc2l+S098THVtYmluaX5MVXxNYWhha2FsaX5NQXxNZWNoaX5NRXxOYXJheWFuaX5OQXxSYXB0aX5SQXxTYWdhcm1hdGhhflNBfFNldGl+U0VcIl0sIFtcIk5ldGhlcmxhbmRzXCIsIFwiTkxcIiwgXCJEcmVudGhlfkRSfEZsZXZvbGFuZH5GTHxGcmllc2xhbmR+RlJ8R2VsZGVybGFuZH5HRXxHcm9uaW5nZW5+R1J8TGltYnVyZ35MSXxOb29yZC1CcmFiYW50fk5CfE5vb3JkLUhvbGxhbmR+Tkh8T3Zlcmlqc3NlbH5PVnxVdHJlY2h0flVUfFplZWxhbmR+WkV8WnVpZC1Ib2xsYW5kflpIXCJdLCBbXCJOZXcgQ2FsZWRvbmlhXCIsIFwiTkNcIiwgXCJJbGVzIExveWF1dGV8Tm9yZHxTdWRcIl0sIFtcIk5ldyBaZWFsYW5kXCIsIFwiTlpcIiwgXCJBdWNrbGFuZH5BVUt8QmF5IG9mIFBsZW50eX5CT1B8Q2FudGVyYnVyeX5DQU58R2lzYm9ybmV+R0lTfEhhd2tlJ3MgQmF5fkhLQnxNYXJsYm9yb3VnaH5NQkh8TWFuYXdhdHUtV2FuZ2FudWl+TVdUfE5vcnRobGFuZH5OVEx8TmVsc29ufk5TTnxPdGFnb35PVEF8U291dGhsYW5kflNUTHxUYXJhbmFraX5US0l8VGFzbWFuflRBU3xXYWlrYXRvfldLT3xXZWxsaW5ndG9ufldHTnxXZXN0IENvYXN0fldUQ3xDaGF0aGFtIElzbGFuZHMgVGVycml0b3J5fkNJVFwiXSwgW1wiTmljYXJhZ3VhXCIsIFwiTklcIiwgXCJCb2Fjb35CT3xDYXJhem9+Q0F8Q2hpbmFuZGVnYX5DSXxDaG9udGFsZXN+Q098RXN0ZWzDrX5FU3xHcmFuYWRhfkdSfEppbm90ZWdhfkpJfExlw7NufkxFfE1hZHJpen5NRHxNYW5hZ3Vhfk1OfE1hc2F5YX5NU3xNYXRhZ2FscGF+TVR8TnVldmEgU2Vnb3ZpYX5OU3xSw61vIFNhbiBKdWFuflNKfFJpdmFzflJJfEF0bMOhbnRpY28gTm9ydGV+QU58QXRsw6FudGljbyBTdXJ+QVNcIl0sIFtcIk5pZ2VyXCIsIFwiTkVcIiwgXCJBZ2FkZXp+MXxEaWZmYX4yfERvc3NvfjN8TWFyYWRpfjR8TmlhbWV5fjh8VGFob3VhfjV8VGlsbGFiw6lyaX42fFppbmRlcn43XCJdLCBbXCJOaWdlcmlhXCIsIFwiTkdcIiwgXCJBYmlhfkFCfEFidWphIEZlZGVyYWwgQ2FwaXRhbCBUZXJyaXRvcnl+RkN8QWRhbWF3YX5BRHxBa3dhIElib21+QUt8QW5hbWJyYX5BTnxCYXVjaGl+QkF8QmF5ZWxzYX5CWXxCZW51ZX5CRXxCb3Jub35CT3xDcm9zcyBSaXZlcn5DUnxEZWx0YX5ERXxFYm9ueWl+RUJ8RWRvfkVEfEVraXRpfkVLfEVudWd1fkVOfEdvbWJlfkdPfEltb35JTXxKaWdhd2F+Skl8S2FkdW5hfktEfEthbm9+S058S2F0c2luYX5LVHxLZWJiaX5LRXxLb2dpfktPfEt3YXJhfktXfExhZ29zfkxBfE5hc3NhcmF3YX5OQXxOaWdlcn5OSXxPZ3Vufk9HfE9uZG9+T058T3N1bn5PU3xPeW9+T1l8UGxhdGVhdX5QTHxSaXZlcnN+Ukl8U29rb3RvflNPfFRhcmFiYX5UQXxZb2JlfllPfFphbWZhcmF+WkFcIl0sIFtcIk5pdWVcIiwgXCJOVVwiLCBcIk5pdWVcIl0sIFtcIk5vcmZvbGsgSXNsYW5kXCIsIFwiTkZcIiwgXCJOb3Jmb2xrIElzbGFuZFwiXSwgW1wiTm9ydGhlcm4gTWFyaWFuYSBJc2xhbmRzXCIsIFwiTVBcIiwgXCJOb3J0aGVybiBJc2xhbmRzfFJvdGF8U2FpcGFufFRpbmlhblwiXSwgW1wiTm9yd2F5XCIsIFwiTk9cIiwgXCJBa2Vyc2h1c34wMnxBdXN0LUFnZGVyfjA5fEJ1c2tlcnVkfjA2fEZpbm5tYXJrfjIwfEhlZG1hcmt+MDR8SG9yZGFsYW5kfjEyfE3DuHJlIG9nIFJvbXNkYWx+MTV8Tm9yZGxhbmR+MTh8Tm9yZC1UcsO4bmRlbGFnfjE3fE9wcGxhbmR+MDV8T3Nsb34wM3xSb2dhbGFuZH4xMXxTb2duIG9nIEZqb3JkYW5lfjE0fFPDuHItVHLDuG5kZWxhZ34xNnxUZWxlbWFya34wOHxUcm9tc34xOXxWZXN0LUFnZGVyfjEwfFZlc3Rmb2xkfjA3fMOYc3Rmb2xkfjAxfEphbiBNYXllbn4yMnxTdmFsYmFyZH4yMVwiXSwgW1wiT21hblwiLCBcIk9NXCIsIFwiQWQgRGFraGlsaXlhaH5EQXxBbCBCdXJheW1pfkJVfEFsIFd1c3RhfldVfEF6IFphaGlyYWh+WkF8SmFudWIgYWwgQmF0aW5haH5CU3xKYW51YiBhc2ggU2hhcnFpeWFoflNTfE1hc3FhdH5NQXxNdXNhbmRhbX5NVXxTaGFtYWwgYWwgQmF0aW5haH5CSnxTaGFtYWwgYXNoIFNoYXJxaXlhaH5TSnxadWZhcn5aVVwiXSwgW1wiUGFraXN0YW5cIiwgXCJQS1wiLCBcIsSAesSBZCBLYXNobcSrcn5KS3xCYWzFjWNoaXN0xIFufkJBfEdpbGdpdC1CYWx0aXN0xIFufkdCfElzbMSBbcSBYsSBZH5JU3xLaGHEq2JhciBQYWtodMWrbmtod8SBc35LUHxQdW5qxIFiflBCfFNpbmRoflNEfEZlZGVyYWxseSBBZG1pbmlzdGVyZWQgVHJpYmFsIEFyZWFzflRBXCJdLCBbXCJQYWxhdVwiLCBcIlBXXCIsIFwiQWltZWxpaWt+MDAyfEFpcmFpfjAwNHxBbmdhdXJ+MDEwfEhhdG9ib2hlaX4wNTB8S2F5YW5nZWx+MTAwfEtvcm9yfjE1MHxNZWxla2Vva34yMTJ8TmdhcmFhcmR+MjE0fE5nYXJjaGVsb25nfjIxOHxOZ2FyZG1hdX4yMjJ8TmdhdHBhbmd+MjI0fE5nY2hlc2FyfjIyNnxOZ2VyZW1sZW5ndWl+MjI3fE5naXdhbH4yMjh8UGVsZWxpdX4zNTB8U29uc29yYWx+MzUwXCJdLCBbXCJQYWxlc3RpbmUsIFN0YXRlIG9mXCIsIFwiUFNcIiwgXCJBayBLaGFsxKtsfkhCTnxBbCBRdWRzfkpFTXxBcsSr4bipxIEgd2FsIEFnaHfEgXJ+SlJIfEJheXQgTGHhuKltfkJUSHxEYXlyIGFsIEJhbGHhuKl+REVCfEdoYXp6YWh+R1pBfEphbsSrbn5KRU58S2jEgW4gWcWrbmlzfktZU3xOxIFibHVzfk5CU3xRYWxxxKt5YWh+UVFBfFJhZmHhuKl+UkZIfFLEgW0gQWxsxIFoIHdhbCBCxKtyYWh+UkJIfFNhbGbEq3R+U0xUfFNoYW3EgWwgR2hhenphaH5OR1p8xaLFq2LEgXN+VEJTfMWixatsa2FybX5US01cIl0sIFtcIlBhbmFtYVwiLCBcIlBBXCIsIFwiQm9jYXMgZGVsIFRvcm9+MXxDaGlyaXF1w61+NHxDb2Nsw6l+MnxDb2zDs25+M3xEYXJpw6lufjV8RW1iZXLDoX5FTXxIZXJyZXJhfjZ8S3VuYSBZYWxhfktZfExvcyBTYW50b3N+N3xOZ8OkYmUtQnVnbMOpfk5CfFBhbmFtw6F+OHxQYW5hbcOhIE9lc3RlfjEwfFZlcmFndWFzfjlcIl0sIFtcIlBhcHVhIE5ldyBHdWluZWFcIiwgXCJQR1wiLCBcIkJvdWdhaW52aWxsZX5OU0J8Q2VudHJhbH5DUE18Q2hpbWJ1fkNQS3xFYXN0IE5ldyBCcml0YWlufkVCUnxFYXN0IFNlcGlrfkVTV3xFYXN0ZXJuIEhpZ2hsYW5kc35FSEd8RW5nYX5FUFd8R3VsZn5HUEt8SGVsYX5ITEF8Sml3YWthfkpXS3xNYWRhbmd+TU9NfE1hbnVzfk1STHxNaWxuZSBCYXl+TUJBfE1vcm9iZX5NUEx8UG9ydCBNb3Jlc2J5fk5DRHxOZXcgSXJlbGFuZH5OSUt8Tm9ydGhlcm5+TlBQfFNvdXRoZXJuIEhpZ2hsYW5kc35TSE18V2VzdCBOZXcgQnJpdGFpbn5XQkt8V2VzdCBTZXBpa35TQU58V2VzdGVybn5XUER8V2VzdGVybiBIaWdobGFuZHN+V0hNXCJdLCBbXCJQYXJhZ3VheVwiLCBcIlBZXCIsIFwiQWx0byBQYXJhZ3VheX4xNnxBbHRvIFBhcmFuYX4xMHxBbWFtYmF5fjEzfEFzdW5jaW9ufkFTVXxDYWFndWF6dX41fENhYXphcGF+NnxDYW5pbmRleXV+MTR8Q2VudHJhbH4xMXxDb25jZXBjaW9ufjF8Q29yZGlsbGVyYX4zfEd1YWlyYX40fEl0YXB1YX43fE1pc2lvbmVzfjh8TmVlbWJ1Y3V+MTJ8UGFyYWd1YXJpfjl8UHJlc2lkZW50ZSBIYXllc34xNXxTYW4gUGVkcm9+MlwiXSwgW1wiUGVydVwiLCBcIlBFXCIsIFwiQW1hem9uYXN+QU1BfEFuY2FzaH5BTkN8QXB1cmltYWN+QVBVfEFyZXF1aXBhfkFSRXxBeWFjdWNob35BWUF8Q2FqYW1hcmNhfkNBSnxDYWxsYW9+Q0FMfEN1c2NvfkNVU3xIdWFuY2F2ZWxpY2F+SFVWfEh1YW51Y29+SFVDfEljYX5JQ0F8SnVuaW5+SlVOfExhIExpYmVydGFkfkxBTHxMYW1iYXllcXVlfkxBTXxMaW1hfkxJTXxMb3JldG9+TE9SfE1hZHJlIGRlIERpb3N+TUREfE1vcXVlZ3Vhfk1PUXxNdW5pY2lwYWxpZGFkIE1ldHJvcG9saXRhbmEgZGUgTGltYX5MTUF8UGFzY29+UEFTfFBpdXJhflBJVXxQdW5vflBVTnxTYW4gTWFydGluflNBTXxUYWNuYX5UQUN8VHVtYmVzflRVTXxVY2F5YWxpflVDQVwiXSwgW1wiUGhpbGlwcGluZXNcIiwgXCJQSFwiLCBcIkFicmF+QUJSfEFndXNhbiBkZWwgTm9ydGV+QUdOfEFndXNhbiBkZWwgU3VyfkFHU3xBa2xhbn5BS0x8QWxiYXl+QUxCfEFudGlxdWV+QU5UfEFwYXlhb35BUEF8QXVyb3JhfkFVUnxCYXNpbGFufkJBU3xCYXRhYW5+QkFOfEJhdGFuZXN+QlROfEJhdGFuZ2FzfkJUR3xCZW5ndWV0fkJFTnxCaWxpcmFufkJJTHxCb2hvbH5CT0h8QnVraWRub25+QlVLfEJ1bGFjYW5+QlVMfENhZ2F5YW5+Q0FHfENhbWFyaW5lcyBOb3J0ZX5DQU58Q2FtYXJpbmVzIFN1cn5DQVN8Q2FtaWd1aW5+Q0FNfENhcGl6fkNBUHxDYXRhbmR1YW5lc35DQVR8Q2F2aXRlfkNBVnxDZWJ1fkNFQnxDb21wb3N0ZWxhfkNPTXxDb3RhYmF0b35OQ098RGF2YW8gZGVsIE5vcnRlfkRBVnxEYXZhbyBkZWwgU3VyfkRBU3xEYXZhbyBPY2NpZGVudGFsfkRWT3xEYXZhbyBPcmllbnRhbH5EQU98RGluYWdhdCBJc2xhbmRzfkRJTnxFYXN0ZXJuIFNhbWFyfkVBU3xHdWltYXJhc35HVUl8SWZ1Z2FvfklGVXxJbG9jb3MgTm9ydGV+SUxOfElsb2NvcyBTdXJ+SUxTfElsb2lsb35JTEl8SXNhYmVsYX5JU0F8S2FsaW5nYX5LQUx8TGEgVW5pb25+TFVOfExhZ3VuYX5MQUd8TGFuYW8gZGVsIE5vcnRlfkxBTnxMYW5hbyBkZWwgU3VyfkxBU3xMZXl0ZX5MRVl8TWFndWluZGFuYW9+TUFHfE1hc2JhdGV+TUFTfE1ldHJvIE1hbmlsYX4wMHxNaW5kb3JvIE9jY2lkZW50YWx+TURDfE1pbmRvcm8gT3JpZW50YWx+TURSfE1pc2FtaXMgT2NjaWRlbnRhbH5NU0N8TWlzYW1pcyBPcmllbnRhbH5NU1J8TW91bnRhaW4gUHJvdmluY2V+TU9VfE5lZ3JvcyBPY2NpZGVudGFsfk5FQ3xOZWdyb3MgT3JpZW50YWx+TkVSfE5vcnRoZXJuIFNhbWFyfk5TQXxOdWV2YSBFY2lqYX5OVUV8TnVldmEgVml6Y2F5YX5OVVZ8UGFsYXdhbn5QTFd8UGFtcGFuZ2F+UEFNfFBhbmdhc2luYW5+UEFOfFF1ZXpvbn5RVUV8UXVpcmlub35RVUl8Uml6YWx+UklafFJvbWJsb25+Uk9NfFNhbWFyfldTQXxTYXJhbmdhbml+U0FSfFNpcXVpam9yflNJR3xTb3Jzb2dvbn5TT1J8U291dGhlcm4gTGV5dGV+U0xFfFN1bHRhbiBLdWRhcmF0fkFVS3xTdWx1flNMVXxTdXJpZ2FvIGRlbCBOb3J0ZX5TVU58U3VyaWdhbyBkZWwgU3VyflNVUnxUYXJsYWN+VEFSfFRhd2ktVGF3aX5UQVd8WmFtYmFsZXN+Wk1CfFphbWJvYW5nYSBkZWwgTm9ydGV+WkFOfFphbWJvYW5nYSBkZWwgU3VyflpBU3xaYW1ib2FuZ2EgU2lidWdheX5aU0lcIl0sIFtcIlBpdGNhaXJuXCIsIFwiUE5cIiwgXCJQaXRjYWlybiBJc2xhbmRzXCJdLCBbXCJQb2xhbmRcIiwgXCJQTFwiLCBcIkRvbG5vxZtsxIVza2llfkRTfEt1amF3c2tvLXBvbW9yc2tpZX5LUHzFgcOzZHpraWV+TER8THViZWxza2llfkxVfEx1YnVza2llfkxCfE1hbG9wb2xza2llfk1BfE1hem93aWVja2llfk1afE9wb2xza2llfk9QfFBvZGthcnBhY2tpZX5QS3xQb2RsYXNraWV+UER8UG9tb3Jza2llflBNfMWabMSFc2tpZX5TTHzFmndpxJl0b2tyenlza2llflNLfFdhcm1pxYRza28tbWF6dXJza2llfldOfFdpZWxrb3BvbHNraWV+V1B8WmFjaG9kbmlvcG9tb3Jza2llflpQXCJdLCBbXCJQb3J0dWdhbFwiLCBcIlBUXCIsIFwiQWNvcmVzfjIwfEF2ZWlyb34wMXxCZWphfjAyfEJyYWdhfjAzfEJyYWdhbmNhfjA0fENhc3RlbG8gQnJhbmNvfjA1fENvaW1icmF+MDZ8RXZvcmF+MDd8RmFyb34wOHxHdWFyZGF+MDl8TGVpcmlhfjEwfExpc2JvYX4xMXxNYWRlaXJhfjMwfFBvcnRhbGVncmV+MTJ8UG9ydG9+MTN8U2FudGFyZW1+MTR8U2V0dWJhbH4xNXxWaWFuYSBkbyBDYXN0ZWxvfjE2fFZpbGEgUmVhbH4xN3xWaXNldX4xOFwiXSwgW1wiUHVlcnRvIFJpY29cIiwgXCJQUlwiLCBcIkFkanVudGFzfEFndWFkYXxBZ3VhZGlsbGF8QWd1YXMgQnVlbmFzfEFpYm9uaXRvfEFuYXNjb3xBcmVjaWJvfEFycm95b3xCYXJjZWxvbmV0YXxCYXJyYW5xdWl0YXN8QmF5YW1vbnxDYWJvIFJvam98Q2FndWFzfENhbXV5fENhbm92YW5hc3xDYXJvbGluYXxDYXR8Q2VpYmF8Q2lhbGVzfENpZHJhfENvYW1vfENvbWVyaW98Q29yb3phbHxDdWxlYnJhfERvcmFkb3xGYWphcmRvfEZsb3JpZGF8R3VhbmljYXxHdWF5YW1hfEd1YXlhbmlsbGF8R3VheW5hYm98R3VyYWJvfEhhdGlsbG98SG9ybWlndWVyb3N8SHVtYWNhb3xJc2FiZXxKdWFuYSBEaWF6fEp1bmNvc3xMYWphc3xMYXJlc3xMYXMgTWFyaWFzfExhcyBvaXphfEx1cXVpbGxvfE1hbmF0aXxNYXJpY2FvfE1hdW5hYm98TWF5YWd1ZXp8TW9jYXxNb3JvdmlzfE5hZ3VhYm98TmFyYW5qaXRvfE9yb2NvdmlzfFBhdGlsbGFzfFBlbnVlbGFzfFBvbmNlfFF1ZWJyYWRpbGxhc3xSaW5jb258UmlvIEdyYW5kZXxTYWJhbmEgbGluYXN8U2FuIEdlcm1hbnxTYW4gSnVhbnxTYW4gTG9yZW56b3xTYW4gU2ViYXN0aWFufFNhbnRhIElzYWJlbHxUb2EgQWx0YXxUb2EgQmFqYXxUcnVqaWxsbyBBbHRvfFV0dWFkb3xWZWdhIEFsdGF8VmVnYSB1ZXN8VmlsbGFsYmF8WWFidWNvYXxZYXVjb1wiXSwgW1wiUWF0YXJcIiwgXCJRQVwiLCBcIkFkIERhd+G4qWFofkRBfEFsIEtoYXdyIHdhIGFkaCBEaGFraMSrcmFofktIfEFsIFdha3JhaH5XQXxBciBSYXl5xIFuflJBfEFzaCBTaGFtxIFsfk1TfEF6zKcgWmHMp2DEgXlpbn5aQXxVbW0gxZ5hbMSBbH5VU1wiXSwgW1wiUsOpdW5pb25cIiwgXCJSRVwiLCBcIlLDqXVuaW9uXCJdLCBbXCJSb21hbmlhXCIsIFwiUk9cIiwgXCJBbGJhfkFCfEFyYWR+QVJ8QXJnZXN+QUd8QmFjYXV+QkN8Qmlob3J+Qkh8QmlzdHJpdGEtTmFzYXVkfkJOfEJvdG9zYW5pfkJUfEJyYWlsYX5CUnxCcmFzb3Z+QlZ8QnVjdXJlc3RpfkJ8QnV6YXV+Qlp8Q2FsYXJhc2l+Q0x8Q2FyYXMtU2V2ZXJpbn5DU3xDbHVqfkNKfENvbnN0YW50YX5DVHxDb3Zhc25hfkNWfERhbWJvdml0YX5EQnxEb2xqfkRKfEdhbGF0aX5HTHxHaXVyZ2l1fkdSfEdvcmp+R0p8SGFyZ2hpdGF+SFJ8SHVuZWRvYXJhfkhEfElhbG9taXRhfklMfElhc2l+SVN8TWFyYW11cmVzfk1NfE1laGVkaW50aX5NSHxNdXJlc35NU3xOZWFtdH5OVHxPbHR+T1R8UHJhaG92YX5QSHxTYWxhan5TSnxTYXR1IE1hcmV+U018U2liaXV+U0J8U3VjZWF2YX5TVnxUZWxlb3JtYW5+VFJ8VGltaXN+VE18VHVsY2VhflRMfFZhbGNlYX5WTHxWYXNsdWl+VlN8VnJhbmNlYX5WTlwiXSwgW1wiUnVzc2lhbiBGZWRlcmF0aW9uXCIsIFwiUlVcIiwgXCJSZXB1YmxpYyBvZiBBZHlnZWF+QUR8UmVwdWJsaWMgb2YgQWx0YWkgKEdvcm5vLUFsdGF5c2spfkFMfEFsdGFpIEtyYWl+QUxUfEFtdXIgT2JsYXN0fkFNVXxBcmtoYW5nZWxzayBPYmxhc3R+QVJLfEFzdHJha2hhbiBPYmxhc3R+QVNUfFJlcHVibGljIG9mIEJhc2hrb3J0b3N0YW5+QkF8QmVsZ29yb2QgT2JsYXN0fkJFTHxCcnlhbnNrIE9ibGFzdH5CUll8UmVwdWJsaWMgb2YgQnVyeWF0aWF+QlV8Q2hlY2hlbiBSZXB1YmxpY35DRXxDaGVseWFiaW5zayBPYmxhc3R+Q0hFfENodWtvdGthIEF1dG9ub21vdXMgT2tydWd+Q0hVfENodXZhc2ggUmVwdWJsaWN+Q1V8UmVwdWJsaWMgb2YgRGFnZXN0YW5+REF8UmVwdWJsaWMgb2YgSW5ndXNoZXRpYX5JTnxJcmt1dHNrIE9ibGFzdH5JUkt8SXZhbm92byBPYmxhc3R+SVZBfEpld2lzaCBBdXRvbm9tb3VzIE9ibGFzdH5KRVd8S2FiYXJkaW5vLUJhbGthciBSZXB1YmxpY35LQnxLYWxpbmluZ3JhZCBPYmxhc3R+S0xOfFJlcHVibGljIG9mIEthbG15a2lhfktMfEthbHVnYSBPYmxhc3R+S0xVfEthbWNoYXRrYSBLcmFpfktBTXxLYXJhY2hheS1DaGVya2VzcyBSZXB1YmxpY35LQ3xSZXB1YmxpYyBvZiBLYXJlbGlhfktSfEtoYWJhcm92c2sgS3JhaX5LSEF8UmVwdWJsaWMgb2YgS2hha2Fzc2lhfktLfEtoYW50eS1NYW5zaSBBdXRvbm9tb3VzIE9rcnVnIC0gWXVncmF+S0hNfEtlbWVyb3ZvIE9ibGFzdH5LRU18S2lyb3YgT2JsYXN0fktJUnxLb21pIFJlcHVibGljfktPfEtvc3Ryb21hIE9ibGFzdH5LT1N8S3Jhc25vZGFyIEtyYWl+S0RBfEtyYXNub3lhcnNrIEtyYWl+S1lBfEt1cmdhbiBPYmxhc3R+S0dOfEt1cnNrIE9ibGFzdH5LUlN8TGVuaW5ncmFkIE9ibGFzdH5MRU58TGlwZXRzayBPYmxhc3R+TElQfE1hZ2FkYW4gT2JsYXN0fk1BR3xNYXJpIEVsIFJlcHVibGljfk1FfFJlcHVibGljIG9mIE1vcmRvdmlhfk1PfE1vc2NvdyBPYmxhc3R+TU9TfE1vc2Nvd35NT1d8TXVybWFuc2sgT2JsYXN0fk1VfE5lbmV0cyBBdXRvbm9tb3VzIE9rcnVnfk5FTnxOaXpobnkgTm92Z29yb2QgT2JsYXN0fk5JWnxOb3Znb3JvZCBPYmxhc3R+TkdSfE5vdm9zaWJpcnNrIE9ibGFzdH5OVlN8T21zayBPYmxhc3R+T01TfE9yZW5idXJnIE9ibGFzdH5PUkV8T3J5b2wgT2JsYXN0fk9STHxQZW56YSBPYmxhc3R+UE5afFBlcm0gS3JhaX5QRVJ8UHJpbW9yc2t5IEtyYWl+UFJJfFBza292IE9ibGFzdH5QU0t8Um9zdG92IE9ibGFzdH5ST1N8UnlhemFuIE9ibGFzdH5SWUF8U2FpbnQgUGV0ZXJzYnVyZ35TUEV8U2FraGEgKFlha3V0aWEpIFJlcHVibGljflNBfFNha2hhbGluIE9ibGFzdH5TQUt8U2FtYXJhIE9ibGFzdH5TQU18U2FyYXRvdiBPYmxhc3R+U0FSfFJlcHVibGljIG9mIE5vcnRoIE9zc2V0aWEtQWxhbmlhfk5PQXxTbW9sZW5zayBPYmxhc3R+U01PfFN0YXZyb3BvbCBLcmFpflNUQXxTdmVyZGxvdnNrIE9ibGFzdH5TVkV8VGFtYm92IE9ibGFzdH5UQU18UmVwdWJsaWMgb2YgVGF0YXJzdGFuflRBfFRvbXNrIE9ibGFzdH5UT018VHV2YSBSZXB1YmxpY35UVXxUdWxhIE9ibGFzdH5UVUx8VHZlciBPYmxhc3R+VFZFfFR5dW1lbiBPYmxhc3R+VFlVfFVkbXVydCBSZXB1YmxpY35VRHxVbHlhbm92c2sgT2JsYXN0flVMWXxWbGFkaW1pciBPYmxhc3R+VkxBfFZvbGdvZ3JhZCBPYmxhc3R+VkdHfFZvbG9nZGEgT2JsYXN0flZMR3xWb3JvbmV6aCBPYmxhc3R+Vk9SfFlhbWFsby1OZW5ldHMgQXV0b25vbW91cyBPa3J1Z35ZQU58WWFyb3NsYXZsIE9ibGFzdH5ZQVJ8WmFiYXlrYWxza3kgS3JhaX5aQUJcIl0sIFtcIlJ3YW5kYVwiLCBcIlJXXCIsIFwiS2lnYWxpfjAxfEVhc3Rlcm5+MDJ8Tm9ydGhlcm5+MDN8V2VzdGVybn4wNHxTb3V0aGVybn4wNVwiXSwgW1wiU2FpbnQgQmFydGjDqWxlbXlcIiwgXCJCTFwiLCBcIkF1IFZlbnR+MDJ8U291cyBsZSBWZW50fjAxXCJdLCBbXCJTYWludCBIZWxlbmEsIEFzY2Vuc2lvbiBhbmQgVHJpc3RhbiBkYSBDdW5oYVwiLCBcIlNIXCIsIFwiQXNjZW5zaW9ufkFDfFNhaW50IEhlbGVuYX5ITHxUcmlzdGFuIGRhIEN1bmhhflRBXCJdLCBbXCJTYWludCBLaXR0cyBhbmQgTmV2aXNcIiwgXCJLTlwiLCBcIlNhaW50IEtpdHRzfkt8TmV2aXN+TlwiXSwgW1wiU2FpbnQgTHVjaWFcIiwgXCJMQ1wiLCBcIkFuc2UtbGEtUmF5ZX4wMXxDYW5hcmllc34xMnxDYXN0cmllc34wMnxDaG9pc2V1bH4wM3xEZW5uZXJ5fjA1fEdyb3MgSXNsZXR+MDZ8TGFib3JpZX4wN3xNaWNvdWR+MDh8U291ZnJpZXJlfjEwfFZpZXV4IEZvcnR+MTFcIl0sIFtcIlNhaW50IE1hcnRpblwiLCBcIk1GXCIsIFwiU2FpbnQgTWFydGluXCJdLCBbXCJTYWludCBQaWVycmUgYW5kIE1pcXVlbG9uXCIsIFwiUE1cIiwgXCJNaXF1ZWxvbnxTYWludCBQaWVycmVcIl0sIFtcIlNhaW50IFZpbmNlbnQgYW5kIHRoZSBHcmVuYWRpbmVzXCIsIFwiVkNcIiwgXCJDaGFybG90dGV+MDF8R3JlbmFkaW5lc34wNnxTYWludCBBbmRyZXd+MDJ8U2FpbnQgRGF2aWR+MDN8U2FpbnQgR2VvcmdlfjA0fFNhaW50IFBhdHJpY2t+MDVcIl0sIFtcIlNhbW9hXCIsIFwiV1NcIiwgXCJBJ2FuYX5BQXxBaWdhLWktbGUtVGFpfkFMfEF0dWF+QVR8RmEnYXNhbGVsZWFnYX5GQXxHYWdhJ2VtYXVnYX5HRXxHYWdhaWZvbWF1Z2F+R0l8UGFsYXVsaX5QQXxTYXR1cGEnaXRlYX5TQXxUdWFtYXNhZ2F+VFV8VmEnYS1vLUZvbm90aX5WRnxWYWlzaWdhbm9+VlNcIl0sIFtcIlNhbiBNYXJpbm9cIiwgXCJTTVwiLCBcIkFjcXVhdml2YX4wMXxCb3JnbyBNYWdnaW9yZX4wNnxDaGllc2FudW92YX4wMnxEb21hZ25hbm9+MDN8RmFldGFub34wNHxGaW9yZW50aW5vfjA1fE1vbnRlZ2lhcmRpbm9+MDh8U2FuIE1hcmlub34wN3xTZXJyYXZhbGxlfjA5XCJdLCBbXCJTYW8gVG9tZSBhbmQgUHJpbmNpcGVcIiwgXCJTVFwiLCBcIlByaW5jaXBlflB8U2FvIFRvbWV+U1wiXSwgW1wiU2F1ZGkgQXJhYmlhXCIsIFwiU0FcIiwgXCInQXNpcn4xNHxBbCBCYWhhaH4xMXxBbCBIdWR1ZCBhc2ggU2hhbWFsaXlhaH4wOHxBbCBKYXdmfjEyfEFsIE1hZGluYWggYWwgTXVuYXd3YXJhaH4wM3xBbCBRYXNpbX4wNXxBciBSaXlhZH4wMXxBc2ggU2hhcnFpeWFofjA0fEhhJ2lsfjA2fEphemFufjA5fE1ha2thaCBhbCBNdWthcnJhbWFofjAyfE5hanJhbn4xMHxUYWJ1a34wN1wiXSwgW1wiU2VuZWdhbFwiLCBcIlNOXCIsIFwiRGFrYXJ+REt8RGlvdXJiZWx+REJ8RmF0aWNrfkZLfEthZmZyaW5lfktBfEthb2xhY2t+S0x8S2Vkb3Vnb3V+S0V8S29sZGF+S0R8TG91Z2F+TEd8TWF0YW1+TVR8U2FpbnQtTG91aXN+U0x8U2VkaGlvdX5TRXxUYW1iYWNvdW5kYX5UQ3xUaGllc35USHxaaWd1aW5jaG9yflpHXCJdLCBbXCJTZXJiaWFcIiwgXCJSU1wiLCBcIkJlb2dyYWQgKEJlbGdyYWRlKX4wMHxCb3Jza2l+MTR8QnJhbmnEjWV2c2tpfjExfEphYmxhbmnEjWtpfjIzfEp1xb5ub2JhxI1raX4wNnxKdcW+bm9iYW5hdHNraX4wNHxLb2x1YmFyc2tpfjA5fEtvc292c2tpfjI1fEtvc292c2tvLU1pdHJvdmHEjWtpfjI4fEtvc292c2tvLVBvbW9yYXZza2l+Mjl8TWHEjXZhbnNraX4wOHxNb3JhdmnEjWtpfjE3fE5pxaFhdnNraX4yMHxQxI1pbmpza2l+MjR8UGXEh2tpfjI2fFBpcm90c2tpfjIyfFBvZHVuYXZza2l+MTB8UG9tb3JhdnNraX4xM3xQcml6cmVuc2tpfjI3fFJhc2luc2tpfjE5fFJhxaFraX4xOHxTZXZlcm5vYmHEjWtpfjAxfFNldmVybm9iYW5hdHNraX4wM3xTcmVkbmplYmFuYXRza2l+MDJ8U3JlbXNraX4wN3zFoHVtYWRpanNraX4xMnxUb3BsacSNa2l+MjF8WmFqZcSNYXJza2l+MTV8WmFwYWRub2JhxI1raX4wNXxabGF0aWJvcnNraX4xNlwiXSwgW1wiU2V5Y2hlbGxlc1wiLCBcIlNDXCIsIFwiQW5zZSBhdXggUGluc34wMXxBbnNlIEJvaWxlYXV+MDJ8QW5zZSBFdG9pbGV+MDN8QW5zZSBSb3lhbGV+MDV8QW51IENhcH4wNHxCYWllIExhemFyZX4wNnxCYWllIFNhaW50ZSBBbm5lfjA3fEJlYXUgVmFsbG9ufjA4fEJlbCBBaXJ+MDl8QmVsIE9tYnJlfjEwfENhc2NhZGV+MTF8R2xhY2lzfjEyfEdyYW5kJ0Fuc2UgTWFoZX4xM3xHcmFuZCdBbnNlIFByYXNsaW5+MTR8TGEgRGlndWV+MTV8TGEgUml2aWVyZSBBbmdsYWlzZX4xNnxMZXMgTWFtZWxsZXN+MjR8TW9udCBCdXh0b25+MTd8TW9udCBGbGV1cml+MTh8UGxhaXNhbmNlfjE5fFBvaW50ZSBMYSBSdWV+MjB8UG9ydCBHbGF1ZH4yMXxSb2NoZSBDYWltYW5+MjV8U2FpbnQgTG91aXN+MjJ8VGFrYW1ha2F+MjNcIl0sIFtcIlNpZXJyYSBMZW9uZVwiLCBcIlNMXCIsIFwiRWFzdGVybn5FfE5vcnRoZXJufk58U291dGhlcm5+U3xXZXN0ZXJufldcIl0sIFtcIlNpbmdhcG9yZVwiLCBcIlNHXCIsIFwiQ2VudHJhbCBTaW5nYXBvcmV+MDF8Tm9ydGggRWFzdH4wMnxOb3J0aCBXZXN0fjAzfFNvdXRoIEVhc3R+MDR8U291dGggV2VzdH4wNVwiXSwgW1wiU2ludCBNYWFydGVuIChEdXRjaCBwYXJ0KVwiLCBcIlNYXCIsIFwiU2ludCBNYWFydGVuXCJdLCBbXCJTbG92YWtpYVwiLCBcIlNLXCIsIFwiQmFuc2tvYnlzdHJpY2t5fkJDfEJyYXRpc2xhdnNreX5CTHxLb3NpY2t5fktJfE5pdHJpYW5za3l+Tkl8UHJlc292c2t5flBWfFRyZW5jaWFuc2t5flRDfFRybmF2c2t5flRBfFppbGluc2t5flpJXCJdLCBbXCJTbG92ZW5pYVwiLCBcIlNJXCIsIFwiQWpkb3ZzY2luYX4wMDF8QXBhY2V+MTk1fEJlbHRpbmNpfjAwMnxCZW5lZGlrdH4xNDh8QmlzdHJpY2Egb2IgU290bGl+MTQ5fEJsZWR+MDAzfEJsb2tlfjE1MHxCb2hpbmp+MDA0fEJvcm92bmljYX4wMDV8Qm92ZWN+MDA2fEJyYXNsb3ZjZX4xNTF8QnJkYX4wMDd8QnJlemljZX4wMDl8QnJlem92aWNhfjAwOHxDYW5rb3ZhfjE1MnxDZWxqZX4wMTF8Q2Vya2xqZSBuYSBHb3Jlbmpza2VtfjAxMnxDZXJrbmljYX4wMTN8Q2Vya25vfjAxNHxDZXJrdmVuamFrfjE1M3xDaXJrdWxhbmV+MTk2fENyZW5zb3ZjaX4wMTV8Q3JuYSBuYSBLb3Jvc2tlbX4wMTZ8Q3Jub21lbGp+MDE3fERlc3RybmlrfjAxOHxEaXZhY2F+MDE5fERvYmplfjE1NHxEb2JyZXBvbGplfjAyMHxEb2JybmF+MTU1fERvYnJvdmEtUG9saG92IEdyYWRlY34wMjF8RG9icm92bmlrfjE1NnxEb2wgcHJpIExqdWJsamFuaX4wMjJ8RG9sZW5qc2tlIFRvcGxpY2V+MTU3fERvbXphbGV+MDIzfERvcm5hdmF+MDI0fERyYXZvZ3JhZH4wMjV8RHVwbGVrfjAyNnxHb3JlbmphIFZhcy1Qb2xqYW5lfjAyN3xHb3Jpc25pY2F+MDI4fEdvcmplfjIwN3xHb3JuamEgUmFkZ29uYX4wMjl8R29ybmppIEdyYWR+MDMwfEdvcm5qaSBQZXRyb3ZjaX4wMzF8R3JhZH4xNTh8R3Jvc3VwbGplfjAzMnxIYWpkaW5hfjE1OXxIb2NlLVNsaXZuaWNhfjE2MHxIb2Rvc34xNjF8SG9yanVsfjE2MnxIcmFzdG5pa34wMzR8SHJwZWxqZS1Lb3ppbmF+MDM1fElkcmlqYX4wMzZ8SWd+MDM3fElsaXJza2EgQmlzdHJpY2F+MDM4fEl2YW5jbmEgR29yaWNhfjAzOXxJem9sYX4wNDBzfEplc2VuaWNlfjA0MXxKdXJzaW5jaX4wNDJ8S2FtbmlrfjA0M3xLYW5hbH4wNDR8S2lkcmljZXZvfjA0NXxLb2JhcmlkfjA0NnxLb2JpbGplfjA0N3xLb2NldmplfjA0OHxLb21lbn4wNDl8S29tZW5kYX4xNjR8S29wZXJ+MDUwfEtvZGFuamV2aWNhIG5hIEtya2l+MTk3fEtvc3RlbH4xNjV8S296amV+MDUxfEtyYW5qfjA1MnxLcmFuanNrYSBHb3JhfjA1M3xLcml6ZXZjaX4xNjZ8S3Jza29+MDU0fEt1bmdvdGF+MDU1fEt1em1hfjA1NnxMYXNrb34wNTd8TGVuYXJ0fjA1OHxMZW5kYXZhfjA1OXxMaXRpamF+MDY4fExqdWJsamFuYX4wNjF8TGp1Ym5vfjA2MnxManV0b21lcn4wNjN8TG9nLURyYWdvbWVyfjIwOHxMb2dhdGVjfjA2NHxMb3NrYSBEb2xpbmF+MDY1fExvc2tpIFBvdG9rfjA2NnxMb3ZyZW5jIG5hIFBvaG9yanV+MTY3fEx1a292aWNhfjA2OHxMdWNlfjA2N3xNYWpzcGVya34wNjl8TWFrb2xlfjE5OHxNYXJpYm9yfjA3MHxNYXJrb3ZjaX4xNjh8TWVkdm9kZX4wNzF8TWVuZ2VzfjA3MnxNZXRsaWthfjA3M3xNZXppY2F+MDc0fE1pa2xhdnogbmEgRHJhdnNrZW0gUG9sanV+MTY5fE1pcmVuLUtvc3RhbmpldmljYX4wNzV8TWlybmF+MjEyfE1pcm5hIFBlY34xNzB8TWlzbGluamF+MDc2fE1va3Jvbm9nLVRyZWJlbG5vfjE5OXxNb3JhdmNlfjA3N3xNb3JhdnNrZSBUb3BsaWNlfjA3OHxNb3ppcmplfjA3OXxNdXJza2EgU29ib3RhfjA4MHxOYWtsb34wODJ8TmF6YXJqZX4wODN8Tm92YSBHb3JpY2F+MDg0fE5vdm8gTWVzdG9+MDg1fE9kcmFuY2l+MDg2fE9ybW96fjA4N3xPc2lsbmljYX4wODh8UGVzbmljYX4wODl8UGlyYW5+MDkwfFBpdmthfjA5MXxQb2RjZXRydGVrfjA5MnxQb2RsZWhuaWt+MTcyfFBvZHZlbGthfjA5M3xQb2xqY2FuZX4yMDB8UG9zdG9qbmF+MDk0fFByZWJvbGR+MTc0fFByZWRkdm9yfjA5NXxQcmV2YWxqZX4xNzV8UHR1an4wOTZ8UmFjZS1GcmFtfjA5OHxSYWRlY2V+MDk5fFJhZGVuY2l+MTAwfFJhZGxqZSBvYiBEcmF2aX4xMDF8UmFkb3ZsamljYX4xMDJ8UmF2bmUgbmEgS29yb3NrZW1+MTAzfFJhemtyaXpqZX4xNzZ8UmVjaWNhIG9iIFNhdmluaml+MjA5fFJlbmNlLVZvZ3Jza29+MjAxfFJpYm5pY2F+MTA0fFJpYm5pY2EgbmEgUG9ib3JpdX4xNzd8Um9nYXNrYSBTbGF0aW5hfjEwNnxSb2dhc292Y2l+MTA1fFJvZ2F0ZWN+MTA3fFJ1c2V+MTA4fFNhbG92Y2l+MDMzfFNlbG5pY2Egb2IgRHJhdml+MTc4fFNlbWljfjEwOXxTZW1wZXRlci1WcnRvamJhfjE4M3xTZW5jdXJ+MTE3fFNlbnRpbGp+MTE4fFNlbnRqZXJuZWp+MTE5fFNlbnRqdXJ+MTIwfFNlbnRydXBlcnR+MjExfFNldm5pY2F+MTEwfFNlemFuYX4xMTF8U2tvY2phbn4xMjF8U2tvZmphIExva2F+MTIyfFNrb2ZsamljYX4xMjN8U2xvdmVuaiBHcmFkZWN+MTEyfFNsb3ZlbnNrYSBCaXN0cmljYX4xMTN8U2xvdmVuc2tlIEtvbmppY2V+MTE0fFNtYXJqZSBwcmkgZWxzYWh+MTI0fFNtYXJqZXNrZSBUb3BsaWNlfjIwNnxTbWFydG5vIG9iIFBha2l+MTI1fFNtYXJ0bm8gcHJpIExpdGlqaX4xOTR8U29kcmF6aWNhfjE3OXxTb2xjYXZhfjE4MHxTb3N0YW5qfjEyNnxTcmVkaXNjZSBvYiBEcmF2aX4yMDJ8U3RhcnNlfjExNXxTdG9yZX4xMjd8U3RyYXphfjIwM3xTdmV0YSBBbmF+MTgxfFN2ZXRhIFRyb2ppY2EgdiBTbG92ZW5za2loIEdvcmljYWh+MjA0fFN2ZXRhIEFuZHJheiB2IFNsb3ZlbnNraWggR29yaWNhaH4xODJ8U3ZldGkgSnVyaWp+MTE2fFN2ZXRpIEp1cmlqIHYgU2xvdmVuc2tpaCBHb3JpY2FofjIxMHxTdmV0aSBUb21hen4yMDV8VGFib3J+MTg0fFRpc2luYX4xMjh8VG9sbWlufjEyOHxUcmJvdmxqZX4xMjl8VHJlYm5qZX4xMzB8VHJub3Zza2EgVmFzfjE4NXxUcnppbn4xODZ8VHJ6aWN+MTMxfFR1cm5pc2NlfjEzMnxWZWxlbmplfjEzM3xWZWxpa2EgUG9sYW5hfjE4N3xWZWxpa2UgTGFzY2V+MTM0fFZlcnplan4xODh8VmlkZW1+MTM1fFZpcGF2YX4xMzZ8Vml0YW5qZX4xMzd8Vm9kaWNlfjEzOHxWb2puaWt+MTM5fFZyYW5za29+MTg5fFZyaG5pa2F+MTQwfFZ1emVuaWNhfjE0MXxaYWdvcmplIG9iIFNhdml+MTQyfFphdnJjfjE0M3xacmVjZX4xNDR8WmFsZWN+MTkwfFplbGV6bmlraX4xNDZ8WmV0YWxlfjE5MXxaaXJpfjE0N3xaaXJvdm5pY2F+MTkyfFp1emVtYmVya34xOTNcIl0sIFtcIlNvbG9tb24gSXNsYW5kc1wiLCBcIlNCXCIsIFwiQ2VudHJhbH5DRXxDaG9pc2V1bH5DSHxHdWFkYWxjYW5hbH5HVXxIb25pYXJhfkNUfElzYWJlbH5JU3xNYWtpcmEtVWxhd2F+TUt8TWFsYWl0YX5NTHxSZW5uZWxsIGFuZCBCZWxsb25hflJCfFRlbW90dX5URXxXZXN0ZXJufldFXCJdLCBbXCJTb21hbGlhXCIsIFwiU09cIiwgXCJBd2RhbH5BV3xCYWtvb2x+Qkt8QmFuYWFkaXJ+Qk58QmFyaX5CUnxCYXl+Qll8R2FsZ3VkdXVkfkdBfEdlZG9+R0V8SGlpcmFhbn5ISXxKdWJiYWRhIERoZXhlfkpEfEp1YmJhZGEgSG9vc2V+Skh8TXVkdWd+TVV8TnVnYWFsfk5VfFNhbmFhZ35TQXxTaGFiZWVsbGFoYSBEaGV4ZX5TRHxTaGFiZWVsbGFoYSBIb29zZX5TSHxTb29sflNPfFRvZ2RoZWVyflRPfFdvcW9veWkgR2FsYmVlZH5XT1wiXSwgW1wiU291dGggQWZyaWNhXCIsIFwiWkFcIiwgXCJFYXN0ZXJuIENhcGV+RUN8RnJlZSBTdGF0ZX5GU3xHYXV0ZW5nfkdUfEt3YVp1bHUtTmF0YWx+Tkx8TGltcG9wb35MUHxNcHVtYWxhbmdhfk1QfE5vcnRoZXJuIENhcGV+TkN8Tm9ydGggV2VzdH5OV3xXZXN0ZXJuIENhcGV+V0NcIl0sIFtcIlNvdXRoIEdlb3JnaWEgYW5kIFNvdXRoIFNhbmR3aWNoIElzbGFuZHNcIiwgXCJHU1wiLCBcIkJpcmQgSXNsYW5kfEJyaXN0b2wgSXNsYW5kfENsZXJrZSBSb2Nrc3xNb250YWd1IElzbGFuZHxTYXVuZGVycyBJc2xhbmR8U291dGggR2VvcmdpYXxTb3V0aGVybiBUaHVsZXxUcmF2ZXJzYXkgSXNsYW5kc1wiXSwgW1wiU291dGggU3VkYW5cIiwgXCJTU1wiLCBcIkNlbnRyYWwgRXF1YXRvcmlhfkNFfEVhc3Rlcm4gRXF1YXRvcmlhfkVFfEpvbmdsZWl+Skd8TGFrZXN+TEt8Tm9ydGhlcm4gQmFociBlbCBHaGF6YWx+Qk58VW5pdHl+VVl8VXBwZXIgTmlsZX5OVXxXYXJyYXB+V1J8V2VzdGVybiBCYWhyIGVsIEdoYXphbH5CV3xXZXN0ZXJuIEVxdWF0b3JpYX5FV1wiXSwgW1wiU3BhaW5cIiwgXCJFU1wiLCBcIkFsYmFjZXRlfkNNfEFsaWNhbnRlflZDfEFsbWVyw61hfkFOfEFyYWJhL8OBbGF2YX5WSXxBc3R1cmlhc35PfMOBdmlsYX5BVnxCYWRham96fkJBfEJhcmNlbG9uYX5CfEJpemthaWF+Qkl8QnVyZ29zfkJVfEPDoWNlcmVzfkNDfEPDoWRpen5DQXxDYW50YWJyaWF+U3xDYXN0ZWxsw7NufkNTfEN1ZXRhfkNVfENpdWRhZCBSZWFsfkNSfEPDs3Jkb2JhfkNPfEEgQ29ydcOxYX5DfEN1ZW5jYX5DVXxHaXB1emtvYX5TU3xHaXJvbmF+R0l8R3JhbmFkYX5HUnxHdWFkYWxhamFyYX5HVXxIdWVsdmF+SHxIdWVzY2F+SFV8SWxsZXMgQmFsZWFyc35QTXxKYcOpbn5KfExlw7NufkxFfExsZWlkYX5MfEx1Z29+TFV8TWFkcmlkfk18TcOhbGFnYX5NQXxNZWxpbGxhfk1MfE11cmNpYX5NVXxOYXZhcnJlfk5BfE91cmVuc2V+T1J8UGFsZW5jaWF+UHxMYXMgUGFsbWFzfkdDfFBvbnRldmVkcmF+UE98TGEgUmlvamF+TE98U2FsYW1hbmNhflNBfFNhbnRhIENydXogZGUgVGVuZXJpZmV+VEZ8U2Vnb3ZpYX5TR3xTZXZpbGxhflNFfFNvcmlhflNPfFRhcnJhZ29uYX5UfFRlcnVlbH5URXxUb2xlZG9+VE98VmFsZW5jaWF+VnxWYWxsYWRvbGlkflZBfFphbW9yYX5aQXxaYXJhZ296YX5aXCJdLCBbXCJTcmkgTGFua2FcIiwgXCJMS1wiLCBcIkJhc25haGlyYX4xfERha3VudX4zfE1hZGh5YW1hfjJ8TmFlZ2VuYWhpcmF+NXxTYWJhcmFnYW11d2F+OXxVdHVydX40fFV0dXJ1bWFlZGF+N3xWYXlhbWJhfjZ8VXZhfjhcIl0sIFtcIlN1ZGFuXCIsIFwiU0RcIiwgXCJBbCBCYWhyIGFsIEFobWFyflJTfEFsIEphemlyYWh+R1p8QWwgS2hhcnR1bX5LSHxBbCBRYWRhcmlmfkdEfEFuIE5pbCBhbCBBYnlhZH5OV3xBbiBOaWwgYWwgQXpyYXF+TkJ8QXNoIFNoYW1hbGl5YWh+Tk98R2hhcmIgRGFyZnVyfkRXfEdoYXJiIEt1cmR1ZmFufkdLfEphbnViIERhcmZ1cn5EU3xKYW51YiBLdXJkdWZhbn5LU3xLYXNzYWxhfktBfE5haHIgYW4gTmlsfk5SfFNoYW1hbCBEYXJmdXJ+RE58U2hhcnEgRGFyZnVyfkRFfFNoaWFtYWwgS3VyZHVmYW5+S058U2lubmFyflNJfFdhc2F0IERhcmZ1ciBaYWxpbmpheX5EQ1wiXSwgW1wiU3VyaW5hbWVcIiwgXCJTUlwiLCBcIkJyb2tvcG9uZG9+QlJ8Q29tbWV3aWpuZX5DTXxDb3JvbmllfkNSfE1hcm93aWpuZX5NQXxOaWNrZXJpZX5OSXxQYXJhflBSfFBhcmFtYXJpYm9+UE18U2FyYW1hY2NhflNBfFNpcGFsaXdpbml+U0l8V2FuaWNhfldBXCJdLCBbXCJTd2F6aWxhbmRcIiwgXCJTWlwiLCBcIkhob2hob35ISHxMdWJvbWJvfkxVfE1hbnppbml+TUF8U2hpc2Vsd2VuaX5TSFwiXSwgW1wiU3dlZGVuXCIsIFwiU0VcIiwgXCJCbGVraW5nZX5LfERhbGFybmFzfld8R290bGFuZHN+WHxHYXZsZWJvcmdzfkl8SGFsbGFuZHN+TnxKYW10bGFuZHN+WnxKb25rb3BpbmdzfkZ8S2FsbWFyfkh8S3Jvbm9iZXJnc35HfE5vcnJib3R0ZW5zfkJEfE9yZWJyb35UfE9zdGVyZ290bGFuZHN+RXxTa2FuZX5NfFNvZGVybWFubGFuZHN+RHxTdG9ja2hvbG1+QUJ8VmFybWxhbmRzflN8VmFzdGVyYm90dGVuc35BQ3xWYXN0ZXJub3JybGFuZHN+WXxWYXN0bWFubGFuZHN+VXxWYXN0cmEgR290YWxhbmRzfk9cIl0sIFtcIlN3aXR6ZXJsYW5kXCIsIFwiQ0hcIiwgXCJBYXJnYXV+QUd8QXBwZW56ZWxsIEF1c3NlcnJob2Rlbn5BUnxBcHBlbnplbGwgSW5uZXJob2Rlbn5BSXxCYXNlbC1MYW5kc2NoYWZ0fkJMfEJhc2VsLVN0YWR0fkJTfEJlcm5+QkV8RnJpYm91cmd+RlJ8R2Vuw6h2ZX5HRXxHbGFydXN+R0x8R3JhdWLDvG5kZW5+R1J8SnVyYX5KVXxMdXplcm5+TFV8TmV1Y2jDonRlbH5ORXxOaWR3YWxkZW5+Tld8T2J3YWxkZW5+T1d8U2Fua3QgR2FsbGVuflNHfFNjaGFmZmhhdXNlbn5TSHxTY2h3eXp+U1p8U29sb3RodXJuflNPfFRodXJnYXV+VEd8VGljaW5vflRJfFVyaX5VUnxWYWxhaXN+VlN8VmF1ZH5WRHxadWd+Wkd8WsO8cmljaH5aSFwiXSwgW1wiU3lyaWFuIEFyYWIgUmVwdWJsaWNcIiwgXCJTWVwiLCBcIkFsIEhhc2FrYWh+SEF8QWwgTGFkaGlxaXlhaH5MQXxBbCBRdW5heXRpcmFoflFVfEFyIFJhcXFhaH5SQXxBcyBTdXdheWRhJ35TVXxEYXInYX5EUnxEYXlyIGF6IFphd3J+RFl8RGltYXNocX5ESXxIYWxhYn5ITHxIYW1haH5ITXxIaW1zfkhJfElkbGlifklEfFJpZiBEaW1hc2hxflJEfFRhcnR1c35UQVwiXSwgW1wiVGFpd2FuXCIsIFwiVFdcIiwgXCJDaGFuZy1odWF+Q0hBfENoaWEtaX5DWVF8SHNpbi1jaHV+SFNRfEh1YS1saWVufkhVQXxLYW8taHNpdW5nfktISHxLZWVsdW5nfktFRXxLaW5tZW5+S0lOfExpZW5jaGlhbmd+TElFfE1pYW8tbGl+TUlBfE5hbi10J291fk5BTnxQJ2VuZy1odX5QRU58TmV3IFRhaXBlaX5OV1R8UCdpbmctY2h1bmd+UElGfFQnYWktY2h1bmd+VFhHfFQnYWktbmFuflROTnxUJ2FpLXBlaX5UUEV8VCdhaS10dW5nflRUVHxUJ2FvLXl1YW5+VEFPfFlpLWxhbn5JTEF8WXVuLWxpbn5ZVU5cIl0sIFtcIlRhamlraXN0YW5cIiwgXCJUSlwiLCBcIkR1c2hhbmJlfkRVfEvFrWhpc3RvbmkgQmFkYWtoc2hvbn5HQnxLaGF0bG9ufktUfFN1Z2hkflNVXCJdLCBbXCJUYW56YW5pYSwgVW5pdGVkIFJlcHVibGljIG9mXCIsIFwiVFpcIiwgXCJBcnVzaGF+MDF8Q29hc3R+MTl8RGFyIGVzIFNhbGFhbX4wMnxEb2RvbWF+MDN8SXJpbmdhfjA0fEthZ2VyYX4wNXxLaWdvbWF+MDh8S2lsaW1hbmphcm9+MDl8TGluZGl+MTJ8TWFueWFyYX4yNnxNYXJhfjEzfE1iZXlhfjE0fE1vcm9nb3JvfjE2fE10d2FyYX4xN3xNd2FuemF+MTh8UGVtYmEgTm9ydGh+MDZ8UGVtYmEgU291dGh+MTB8UnVrd2F+MjB8UnV2dW1hfjIxfFNoaW55YW5nYX4yMnxTaW5naWRhfjIzfFRhYm9yYX4yNHxUYW5nYX4yNXxaYW56aWJhciBOb3J0aH4wN3xaYW56aWJhciBDZW50cmFsL1NvdXRofjExfFphbnppYmFyIFVyYmFuL1dlc3R+MTVcIl0sIFtcIlRoYWlsYW5kXCIsIFwiVEhcIiwgXCJBbW5hdCBDaGFyb2VufjM3fEFuZyBUaG9uZ34xNXxCdWVuZyBLYW5+Mzh8QnVyaSBSYW1+MzF8Q2hhY2hvZW5nc2FvfjI0fENoYWkgTmF0fjE4fENoYWl5YXBodW1+MzZ8Q2hhbnRoYWJ1cml+MjJ8Q2hpYW5nIE1haX41MHxDaGlhbmcgUmFpfjU3fENob24gQnVyaX4yMHxDaHVtcGhvbn44NnxLYWxhc2lufjQ2fEthbXBoYWVuZyBQaGV0fjYyfEthbmNoYW5hYnVyaX43MXxLaG9uIEthZW5+NDB8S3JhYml+ODF8S3J1bmcgVGhlcCBNYWhhbmFraG9uIChCYW5na29rKX4xMHxMYW1wYW5nfjUyfExhbXBodW5+NTF8TG9laX40MnxMb3AgQnVyaX4xNnxNYWUgSG9uZyBTb25+NTh8TWFoYSBTYXJha2hhbX40NHxNdWtkYWhhbn40OXxOYWtob24gTmF5b2t+MjZ8TmFraG9uIFBoYXRob21+NzN8TmFraG9uIFBoYW5vbX40OHxOYWtob24gUmF0Y2hhc2ltYX4zMHxOYWtob24gU2F3YW5+NjB8TmFraG9uIFNpIFRoYW1tYXJhdH44MHxOYW5+NTV8TmFyYXRoaXdhdH45NnxOb25nIEJ1YSBMYW0gUGh1fjM5fE5vbmcgS2hhaX40M3xOb250aGFidXJpfjEyfFBhdGh1bSBUaGFuaX4xM3xQYXR0YW5pfjk0fFBoYW5nbmdhfjgyfFBoYXR0aGFsdW5nfjkzfFBoYXlhb341NnxQaGV0Y2hhYnVufjc2fFBoZXRjaGFidXJpfjc2fFBoaWNoaXR+NjZ8UGhpdHNhbnVsb2t+NjV8UGhyYSBOYWtob24gU2kgQXl1dHRoYXlhfjE0fFBocmFlfjU0fFBodWtldH44M3xQcmFjaGluIEJ1cml+MjV8UHJhY2h1YXAgS2hpcmkgS2hhbn43N3xSYW5vbmd+ODV8UmF0Y2hhYnVyaX43MHxSYXlvbmd+MjF8Um9pIEV0fjQ1fFNhIEthZW9+Mjd8U2Frb24gTmFraG9ufjQ3fFNhbXV0IFByYWthbn4xMXxTYW11dCBTYWtob25+NzR8U2FtdXQgU29uZ2tocmFtfjc1fFNhcmFidXJpfjE5fFNhdHVufjkxfFNpbmcgQnVyaX4xN3xTaSBTYSBrZXR+MzN8U29uZ2tobGF+OTB8U3VraG90aGFpfjY0fFN1cGhhbiBCdXJpfjcyfFN1cmF0IFRoYW5pfjg0fFN1cmlufjMyfFRha342M3xUcmFuZ345MnxUcmF0fjIzfFVib24gUmF0Y2hhdGhhbml+MzR8VWRvbiBUaGFuaX40MXxVdGhhaSBUaGFuaX42MXxVdHRhcmFkaXR+NTN8WWFsYX45NXxZYXNvdGhvbn4zNVwiXSwgW1wiVGltb3ItTGVzdGVcIiwgXCJUTFwiLCBcIkFpbGV1fkFMfEFpbmFyb35BTnxCYXVjYXV+QkF8Qm9ib25hcm9+Qk98Q292YSBMaW1hfkNPfERpbGl+REl8RXJtZXJhfkVSfExhdXRlbX5MQXxMaXF1aWNhfkxJfE1hbmF0dXRvfk1UfE1hbnVmYWhpfk1GfE9lY3Vzc2l+T0V8VmlxdWVxdWV+VklcIl0sIFtcIlRvZ29cIiwgXCJUR1wiLCBcIkNlbnRyZX5DfEthcmF+S3xNYXJpdGltZX5NfFBsYXRlYXV4flB8U2F2YW5uZXN+U1wiXSwgW1wiVG9rZWxhdVwiLCBcIlRLXCIsIFwiQXRhZnV8RmFrYW9mb3xOdWt1bm9udVwiXSwgW1wiVG9uZ2FcIiwgXCJUT1wiLCBcIidFdWF+MDF8SGEnYXBhaX4wMnxOaXVhc34wM3xUb25nYXRhcHV+MDR8VmF2YSd1fjA1XCJdLCBbXCJUcmluaWRhZCBhbmQgVG9iYWdvXCIsIFwiVFRcIiwgXCJBcmltYX5BUkl8Q2hhZ3VhbmFzfkNIQXxDb3V2YS1UYWJhcXVpdGUtVGFscGFyb35DVFR8RGllZm8gTWFydGlufkRNTnxNYXlhcm8tUmlvIENsYXJvfk1SQ3xQZW5hbC1EZWJlflBFRHxQb2ludCBGb3J0aW5+UFRGfFBvcnQtb2YtU3BhaW5+UE9TfFByaW5jZXMgVG93bn5QUlR8U2FuIEZlcm5hbmRvflNGT3xTYW4gSnVhbi1MYXZlbnRpbGxlflNKTHxTYW5ncmUgR3JhbmRlflNHRXxTaXBhcmlhflNJUHxUb2JhZ29+VE9CfFR1bmFwdW5hLVBpYXJjb35UVVBcIl0sIFtcIlR1bmlzaWFcIiwgXCJUTlwiLCBcIkFyaWFuYX4xMnxCZWphfjMxfEJlbiBBcm91c34xM3xCaXplcnRlfjIzfEdhYmVzfjgxfEdhZnNhfjcxfEplbmRvdWJhfjMyfEthaXJvdWFufjQxfEthc3NlcmluZX40MnxLZWJpbGl+NzN8S2VmfjMzfE1haGRpYX41M3xNZWRlbmluZX44MnxNb25hc3Rpcn41MnxOYWJldWx+MjF8U2ZheH42MXxTaWRpIEJvdXppZH40M3xTaWxpYW5hfjM0fFNvdXNzZX41MXxUYXRhb3VpbmV+ODN8VG96ZXVyfjcyfFR1bmlzfjExfFphZ2hvdWFufjIyXCJdLCBbXCJUdXJrZXlcIiwgXCJUUlwiLCBcIkFkYW5hfjAxfEFkaXlhbWFufjAyfEFmeW9ua2FyYWhpc2FyfjAzfEFncml+MDR8QWtzYXJheX42OHxBbWFzeWF+MDV8QW5rYXJhfjA2fEFudGFseWF+MDd8QXJkYWhhbn43NXxBcnR2aW5+MDh8QXlkaW5+MDl8QmFsaWtlc2lyfjEwfEJhcnRpbn43NHxCYXRtYW5+NzJ8QmF5YnVydH42OXxCaWxlY2lrfjExfEJpbmdvbH4xMnxCaXRsaXN+MTN8Qm9sdX4xNHxCdXJkdXJ+MTV8QnVyc2F+MTZ8Q2FuYWtrYWxlfjE3fENhbmtpcml+MTh8Q29ydW1+MTl8RGVuaXpsaX4yMHxEaXlhcmJha2lyfjIxfER1emNlfjgxfEVkaXJuZX4yMnxFbGF6aWd+MjN8RXJ6aW5jYW5+MjR8RXJ6dXJ1bX4yNXxFc2tpc2VoaXJ+MjZ8R2F6aWFudGVwfjI3fEdpcmVzdW5+Mjh8R3VtdXNoYW5lfjI5fEhha2thcml+MzB8SGF0YXl+MzF8SWdkaXJ+NzZ8SXNwYXJ0YX4zMnxJc3RhbmJ1bH4zNHxJem1pcn4zNXxLYWhyYW1hbm1hcmFzfjQ2fEthcmFidWt+Nzh8S2FyYW1hbn43MHxLYXJzfjM2fEthc3RhbW9udX4zN3xLYXlzZXJpfjM4fEtpbGlzfjc5fEtpcmlra2FsZX43MXxLaXJrbGFyZWxpfjM5fEtpcnNlaGlyfjQwfEtvY2FlbGl+NDF8S29ueWF+NDJ8S3V0YWh5YX40M3xNYWxhdHlhfjQ0fE1hbmlzYX40NXxNYXJkaW5+NDd8TWVyc2lufjMzfE11Z2xhfjQ4fE11c340OXxOZXZzZWhpcn41MHxOaWdkZX41MXxPcmR1fjUyfE9zbWFuaXllfjgwfFJpemV+NTN8U2FrYXJ5YX41NHxTYW1zdW5+NTV8U2FubGl1cmZhfjYzfFNpaXJ0fjU2fFNpbm9wfjU3fFNpcm5ha343M3xTaXZhc341OHxUZWtpcmRhZ341OXxUb2thdH42MHxUcmFiem9ufjYxfFR1bmNlbGl+NjJ8VXNha342NHxWYW5+NjV8WWFsb3Zhfjc3fFlvemdhdH42Nnxab25ndWxkYWt+NjdcIl0sIFtcIlR1cmttZW5pc3RhblwiLCBcIlRNXCIsIFwiQWhhbH5BfEFzZ2FiYXR+U3xCYWxrYW5+QnxEYXNob2d1en5EfExlYmFwfkx8TWFyeX5NXCJdLCBbXCJUdXJrcyBhbmQgQ2FpY29zIElzbGFuZHNcIiwgXCJUQ1wiLCBcIlR1cmtzIGFuZCBDYWljb3MgSXNsYW5kc1wiXSwgW1wiVHV2YWx1XCIsIFwiVFZcIiwgXCJGdW5hZnV0aX5GVU58TmFudW1hbmdhfk5NR3xOYW51bWVhfk5NQXxOaXV0YW9+TklUfE51aX5OVUl8TnVrdWZldGF1fk5LRnxOdWt1bGFlbGFlfk5LTHxWYWl0dXB1flZBVVwiXSwgW1wiVWdhbmRhXCIsIFwiVUdcIiwgXCJBYmltfjMxN3xBZGp1bWFuaX4zMDF8QW1vbGF0YXJ+MzE0fEFtdXJpYX4yMTZ8QW11cnV+MzE5fEFwYWN+MzAyfEFydWF+MzAzfEJ1ZGFrYX4yMTd8QnVkdWRhfjIyM3xCdWdpcml+MjAxfEJ1a2VkZWF+MjI0fEJ1a3dhfjIxOHxCdWxpaXNhfjQxOXxCdW5kaWJ1Z3lvfjQwMXxCdXNoZW55aX40MDJ8QnVzaWF+MjAyfEJ1dGFsZWphfjIxOXxEb2tvbG9+MzE4fEd1bHV+MzA0fEhvaW1hfjQwM3xJYmFuZGF+NDE2fElnYW5nYX4yMDN8SXNpbmdpcm9+NDE3fEppbmphfjIwNHxLYWFib25nfjMxNXxLYWJhbGV+NDA0fEthYmFyb2xlfjQwNXxLYWJlcmFtYWlkb34yMTN8S2FsYW5nYWxhfjEwMXxLYWxpcm9+MjIwfEthbXBhbGF+MTAyfEthbXVsaX4yMDV8S2Ftd2VuZ2V+NDEzfEthbnVuZ3V+NDE0fEthcGNob3J3YX4yMDZ8S2FzZXNlfjQwNnxLYXRha3dpfjIwN3xLYXl1bmdhfjExMnxLaWJhYWxlfjQwN3xLaWJvZ2F+MTAzfEtpcnVodXJhfjQxOHxLaXNvcm9+NDA4fEtpdGd1bX4zMDV8S29ib2tvfjMxNnxLb3RpZG9+MzA2fEt1bWl+MjA4fEt5ZW5qb2pvfjQxNXxMaXJhfjMwN3xMdXdlcm9+MTA0fEx5YW50b25kZX4xMTZ8TWFuYWZ3YX4yMjF8TWFyYWNoYX4zMjB8TWFzYWthfjEwNXxNYXNpbmRpfjQwOXxNYXl1Z2V+MjE0fE1iYWxlfjIwOXxNYmFyYXJhfjQxMHxNaXR5YW5hfjExNHxNb3JvdG9+MzA4fE1veW9+MzA5fE1waWdpfjEwNnxNdWJlbmRlfjEwN3xNdWtvbm9+MTA4fE5ha2FwaXJpcGlyaXR+MzExfE5ha2FzZWtlfjExNXxOYWthc29uZ29sYX4xMDl8TmFtdXR1bWJhfjIyMnxOZWJiaX4zMTB8TnR1bmdhbW9+NDExfE95YW1+MzIxfFBhZGVyfjMxMnxQYWxsaXNhfjIxMHxSYWthaX4xMTB8UnVrdW5naXJpfjQxMnxTZW1iYWJ1bGV+MTExfFNpcm9ua29+MjE1fFNvcm90aX4yMTF8VG9yb3JvfjIxMnxXYWtpc29+MTEzfFl1bWJlfjMxM1wiXSwgW1wiVWtyYWluZVwiLCBcIlVBXCIsIFwiQ2hlcmthc3l+NzF8Q2hlcm5paGl2fjc0fENoZXJuaXZ0c2l+Nzd8RG5pcHJvcGV0cm92c2t+MTJ8RG9uZXRza34xNHxJdmFuby1GcmFua2l2c2t+MjZ8S2hhcmtpdn42M3xLaGVyc29ufjY1fEtobWVsbnl0c2t5aX42OHxLaWV2fjMyfEtpcm92b2hyYWR+MzV8THVoYW5za34wOXxMdml2fjQ2fE15a29sYWl2fjQ4fE9kZXNzYX41MXxQb2x0YXZhfjUzfFJpdm5lfjU2fFN1bXl+NTl8VGVybm9waWx+NjF8Vmlubnl0c2lhfjA1fFZvbHlufjA3fFpha2FycGF0dGlhfjIxfFphcG9yaXpoaWF+MjN8Wmh5dG9teXJ+MTh8QXZ0b25vbW5hIFJlc3B1Ymxpa2EgS3J5bX40M3xLecOvdn4zMHxTZXZhc3RvcG9sfjQwXCJdLCBbXCJVbml0ZWQgQXJhYiBFbWlyYXRlc1wiLCBcIkFFXCIsIFwiQWJ1IERoYWJpfkFafEFqbWFufkFKfER1YmFpfkRVfEZ1amFpcmFofkZVfFJhcyBhbCBLaGFpbWFoflJLfFNoYXJqYWh+U0h8VW1tIEFsIFF1d2Fpbn5VUVwiXSwgW1wiVW5pdGVkIEtpbmdkb21cIiwgXCJHQlwiLCBcIkF2b25+QVZOfEJlZGZvcmRzaGlyZX5CREZ8QmVya3NoaXJlfkJSS3xCcmlzdG9sLCBDaXR5IG9mfkNPQnxCdWNraW5naGFtc2hpcmV+QktNfENhbWJyaWRnZXNoaXJlfkNBTXxDaGVzaGlyZX5DSFN8Q2xldmVsYW5kfkNMVnxDb3Jud2FsbH5DT058Q3VtYnJpYX5DTUF8RGVyYnlzaGlyZX5EQll8RGV2b25+REVWfERvcnNldH5ET1J8RHVyaGFtfkRVUnxFYXN0IFN1c3NleH5TWEV8RXNzZXh+RVNTfEdsb3VjZXN0ZXJzaGlyZX5HTFN8R3JlYXRlciBMb25kb25+TE5EfEdyZWF0ZXIgTWFuY2hlc3Rlcn5HVE18SGFtcHNoaXJlIChDb3VudHkgb2YgU291dGhhbXB0b24pfkhBTXxIZXJlZm9yZCBhbmQgV29yY2VzdGVyfkhXUnxIZXJlZm9yZHNoaXJlfkhFRnxIZXJ0Zm9yZHNoaXJlfkhSVHxJc2xlIG9mIFdpZ2h0fklPV3xLZW50fktFTnxMYW5jYXNoaXJlfkxBTnxMZWljZXN0ZXJzaGlyZX5MRUl8TGluY29sbnNoaXJlfkxJTnxMb25kb25+TEROfE1lcnNleXNpZGV+TVNZfE1pZGRsZXNleH5NRFh8Tm9yZm9sa35ORkt8Tm9ydGhhbXB0b25zaGlyZX5OVEh8Tm9ydGh1bWJlcmxhbmR+TkJMfE5vcnRoIEh1bWJlcnNpZGV+TkhNfE5vcnRoIFlvcmtzaGlyZX5OWUt8Tm90dGluZ2hhbXNoaXJlfk5UVHxPeGZvcmRzaGlyZX5PWEZ8UnV0bGFuZH5SVVR8U2hyb3BzaGlyZX5TQUx8U29tZXJzZXR+U09NfFNvdXRoIEh1bWJlcnNpZGV+U0hNfFNvdXRoIFlvcmtzaGlyZX5TWUt8U3RhZmZvcmRzaGlyZX5TVFN8U3VmZm9sa35TRkt8U3VycmV5flNSWXxUeW5lIGFuZCBXZWFyflRXUnxXYXJ3aWNrc2hpcmV+V0FSfFdlc3QgTWlkbGFuZHN+V01EfFdlc3QgU3Vzc2V4flNYV3xXZXN0IFlvcmtzaGlyZX5XWUt8V2lsdHNoaXJlfldJTHxXb3JjZXN0ZXJzaGlyZX5XT1J8QW50cmltfkFOVHxBcm1hZ2h+QVJNfEJlbGZhc3QsIENpdHkgb2Z+QkxGfERvd25+RE9XfEZlcm1hbmFnaH5GRVJ8TG9uZG9uZGVycnl+TERZfERlcnJ5LCBDaXR5IG9mfkRSWXxUeXJvbmV+VFlSfEFiZXJkZWVuLCBDaXR5IG9mfkFOfEFiZXJkZWVuc2hpcmV+QUJEfEFuZ3VzIChGb3JmYXJzaGlyZSl+QU5TfEFyZ3lsbH5BR0J8QXlyc2hpcmV+QVJHfEJhbmZmc2hpcmV+QkFOfEJlcndpY2tzaGlyZX5CRVd8QnV0ZX5CVVR8Q2FpdGhuZXNzfkNBSXxDbGFja21hbm5hbnNoaXJlfkNMS3xDcm9tYXJ0eXNoaXJlfkNPQ3xEdW1mcmllc3NoaXJlfkRGU3xEdW5iYXJ0b25zaGlyZSAoRHVtYmFydG9uKX5ETkJ8RHVuZGVlLCBDaXR5IG9mfkREfEVhc3QgTG90aGlhbiAoSGFkZGluZ3RvbnNoaXJlKX5FTE58RWRpbmJ1cmdoLCBDaXR5IG9mfkVCfEZpZmV+RklGfEdsYXNnb3csIENpdHkgb2Z+R0xBfEludmVybmVzcy1zaGlyZX5JTlZ8S2luY2FyZGluZXNoaXJlfktDRHxLaW5yb3NzLXNoaXJlfktSU3xLaXJrY3VkYnJpZ2h0c2hpcmV+S0tEfExhbmFya3NoaXJlfkxLU3xNaWRsb3RoaWFuIChDb3VudHkgb2YgRWRpbmJ1cmdoKX5NTE58TW9yYXkgKEVsZ2luc2hpcmUpfk1PUnxOYWlybnNoaXJlfk5BSXxPcmtuZXl+T0tJfFBlZWJsZXNzaGlyZX5QRUV8UGVydGhzaGlyZX5QRVJ8UmVuZnJld3NoaXJlflJGV3xSb3NzIGFuZCBDcm9tYXJ0eX5ST0N8Um9zcy1zaGlyZX5ST1N8Um94YnVyZ2hzaGlyZX5ST1h8U2Vsa2lya3NoaXJlflNFTHxTaGV0bGFuZCAoWmV0bGFuZCl+U0hJfFN0aXJsaW5nc2hpcmV+U1RJfFN1dGhlcmxhbmR+U1VUfFdlc3QgTG90aGlhbiAoTGlubGl0aGdvd3NoaXJlKX5XTE58V2lndG93bnNoaXJlfldJR3xDbHd5ZH5DV0R8RHlmZWR+REZEfEd3ZW50fkdOVHxHd3luZWRkfkdXTnxNaWQgR2xhbW9yZ2Fufk1HTXxQb3d5c35QT1d8U291dGggR2xhbW9yZ2FuflNHTXxXZXN0IEdsYW1vcmdhbn5XR01cIl0sIFtcIlVuaXRlZCBTdGF0ZXNcIiwgXCJVU1wiLCBcIkFsYWJhbWF+QUx8QWxhc2thfkFLfEFtZXJpY2FuIFNhbW9hfkFTfEFyaXpvbmF+QVp8QXJrYW5zYXN+QVJ8Q2FsaWZvcm5pYX5DQXxDb2xvcmFkb35DT3xDb25uZWN0aWN1dH5DVHxEZWxhd2FyZX5ERXxEaXN0cmljdCBvZiBDb2x1bWJpYX5EQ3xNaWNyb25lc2lhfkZNfEZsb3JpZGF+Rkx8R2VvcmdpYX5HQXxHdWFtfkdVfEhhd2FpaX5ISXxJZGFob35JRHxJbGxpbm9pc35JTHxJbmRpYW5hfklOfElvd2F+SUF8S2Fuc2FzfktTfEtlbnR1Y2t5fktZfExvdWlzaWFuYX5MQXxNYWluZX5NRXxNYXJzaGFsbCBJc2xhbmRzfk1IfE1hcnlsYW5kfk1EfE1hc3NhY2h1c2V0dHN+TUF8TWljaGlnYW5+TUl8TWlubmVzb3Rhfk1OfE1pc3Npc3NpcHBpfk1TfE1pc3NvdXJpfk1PfE1vbnRhbmF+TVR8TmVicmFza2F+TkV8TmV2YWRhfk5WfE5ldyBIYW1wc2hpcmV+Tkh8TmV3IEplcnNleX5OSnxOZXcgTWV4aWNvfk5NfE5ldyBZb3Jrfk5ZfE5vcnRoIENhcm9saW5hfk5DfE5vcnRoIERha290YX5ORHxOb3J0aGVybiBNYXJpYW5hIElzbGFuZHN+TVB8T2hpb35PSHxPa2xhaG9tYX5PS3xPcmVnb25+T1J8UGFsYXV+UFd8UGVubnN5bHZhbmlhflBBfFB1ZXJ0byBSaWNvflBSfFJob2RlIElzbGFuZH5SSXxTb3V0aCBDYXJvbGluYX5TQ3xTb3V0aCBEYWtvdGF+U0R8VGVubmVzc2VlflROfFRleGFzflRYfFV0YWh+VVR8VmVybW9udH5WVHxWaXJnaW4gSXNsYW5kc35WSXxWaXJnaW5pYX5WQXxXYXNoaW5ndG9ufldBfFdlc3QgVmlyZ2luaWF+V1Z8V2lzY29uc2lufldJfFd5b21pbmd+V1l8QXJtZWQgRm9yY2VzIEFtZXJpY2FzfkFBfEFybWVkIEZvcmNlcyBFdXJvcGUsIENhbmFkYSwgQWZyaWNhIGFuZCBNaWRkbGUgRWFzdH5BRXxBcm1lZCBGb3JjZXMgUGFjaWZpY35BUFwiXSwgW1wiVW5pdGVkIFN0YXRlcyBNaW5vciBPdXRseWluZyBJc2xhbmRzXCIsIFwiVU1cIiwgXCJCYWtlciBJc2xhbmR+ODF8SG93bGFuZCBJc2xhbmR+ODR8SmFydmlzIElzbGFuZH44NnxKb2huc3RvbiBBdG9sbH42N3xLaW5nbWFuIFJlZWZ+ODl8TWlkd2F5IElzbGFuZHN+NzF8TmF2YXNzYSBJc2xhbmR+NzZ8UGFsbXlyYSBBdG9sbH45NXxXYWtlIElzbGFuZH43OXxCYWpvIE51ZXZvIEJhbmt+Qk58U2VycmFuaWxsYSBCYW5rflNCXCJdLCBbXCJVcnVndWF5XCIsIFwiVVlcIiwgXCJBcnRpZ2FzfkFSfENhbmVsb25lc35DQXxDZXJybyBMYXJnb35DTHxDb2xvbmlhfkNPfER1cmF6bm9+RFV8RmxvcmVzfkZTfEZsb3JpZGF+RkR8TGF2YWxsZWphfkxBfE1hbGRvbmFkb35NQXxNb250ZXZpZGVvfk1PfFBheXNhbmTDun5QQXxSw61vIE5lZ3JvflJOfFJpdmVyYX5SVnxSb2NoYX5ST3xTYWx0b35TQXxTYW4gSm9zw6l+U0p8U29yaWFub35TT3xUYWN1YXJlbWLDs35UQXxUcmVpbnRhIHkgVHJlc35UVFwiXSwgW1wiVXpiZWtpc3RhblwiLCBcIlVaXCIsIFwiVG9zaGtlbnQgc2hhaHJpflRLfEFuZGlqb25+QU58QnV4b3JvfkJVfEZhcmfigJhvbmF+RkF8Sml6emF4fkpJfE5hbWFuZ2Fufk5HfE5hdm9peX5OV3xRYXNocWFkYXJ5byAoUWFyc2hpKX5RQXxTYW1hcnFhbmR+U0F8U2lyZGFyeW8gKEd1bGlzdG9uKX5TSXxTdXJ4b25kYXJ5byAoVGVybWl6KX5TVXxUb3Noa2VudCB3aWxveWF0aX5UT3xYb3Jhem0gKFVyZ2FuY2gpflhPfFFvcmFxYWxwb2figJhpc3RvbiBSZXNwdWJsaWthc2kgKE51a3VzKX5RUlwiXSwgW1wiVmFudWF0dVwiLCBcIlZVXCIsIFwiTWFsYW1wYX5NQVB8UMOpbmFtYX5QQU18U2FubWF+U0FNfFNow6lmYX5TRUV8VGFmw6lhflRBRXxUb3JiYX5UT0JcIl0sIFtcIlZlbmV6dWVsYSwgQm9saXZhcmlhbiBSZXB1YmxpYyBvZlwiLCBcIlZFXCIsIFwiRGVwZW5kZW5jaWFzIEZlZGVyYWxlc35XfERpc3RyaXRvIEZlZGVyYWx+QXxBbWF6b25hc35afEFuem/DoXRlZ3VpfkJ8QXB1cmV+Q3xBcmFndWF+RHxCYXJpbmFzfkV8Qm9sw612YXJ+RnxDYXJhYm9ib35HfENvamVkZXN+SHxEZWx0YSBBbWFjdXJvfll8RmFsY8Ozbn5JfEd1w6FyaWNvfkp8TGFyYX5LfE3DqXJpZGF+THxNaXJhbmRhfk18TW9uYWdhc35OfE51ZXZhIEVzcGFydGF+T3xQb3J0dWd1ZXNhflB8U3VjcmV+UnxUw6FjaGlyYX5TfFRydWppbGxvflR8VmFyZ2Fzflh8WWFyYWN1eX5VfFp1bGlhflZcIl0sIFtcIlZpZXRuYW1cIiwgXCJWTlwiLCBcIsSQ4buTbmcgTmFpfjM5fMSQ4buTbmcgVGjDoXB+NDV8R2lhIExhaX4zMHxIw6AgR2lhbmd+MDN8SMOgIE5hbX42M3xIw6AgVMOieX4xNXxIw6AgVMSpbmh+MjN8SOG6o2kgRMawxqFuZ342MXxI4bqtdSBHaWFuZ343M3xIw7JhIELDrG5ofjE0fEjGsG5nIFnDqm5+NjZ8S2jDoW5oIEjDsmF+MzR8S2nDqm4gR2lhbmd+NDd8S29uIFR1bX4yOHxMYWkgQ2jDonV+MDF8TMOibSDEkOG7k25nfjM1fEzhuqFuZyBTxqFufjA5fEzDoG8gQ2FpfjAyfExvbmcgQW5+NDF8TmFtIMSQ4buLbmh+Njd8Tmdo4buHIEFufjIyfE5pbmggQsOsbmh+MTh8TmluaCBUaHXhuq1ufjM2fFBow7ogVGjhu41+Njh8UGjDuiBZw6pufjMyfFF14bqjbmcgQsOsbmh+MjR8UXXhuqNuZyBOYW1+Mjd8UXXhuqNuZyBOZ8OjaX4yOXxRdeG6o25nIE5pbmh+MTN8UXXhuqNuZyBUcuG7i34yNXxTw7NjIFRyxINuZ341MnxTxqFuIExhfjA1fFTDonkgTmluaH4zN3xUaMOhaSBCw6xuaH4yMHxUaMOhaSBOZ3V5w6pufjY5fFRoYW5oIEjDs2F+MjF8VGjhu6thIFRoacOqbuKAk0h14bq/fjI2fFRp4buBbiBHaWFuZ340NnxUcsOgIFZpbmh+NTF8VHV5w6puIFF1YW5nfjA3fFbEqW5oIExvbmd+NDl8VsSpbmggUGjDumN+NzB8WcOqbiBCw6FpfjA2fEPhuqduIFRoxqF+Q1R8xJDDoCBO4bq1bmd+RE58SMOgIE7hu5lpfkhOfEjhuqNpIFBow7JuZ35IUHxI4buTIENow60gTWluaCAoU8OgaSBHw7JuKX5TR1wiXSwgW1wiVmlyZ2luIElzbGFuZHMsIEJyaXRpc2hcIiwgXCJWR1wiLCBcIkFuZWdhZGF+QU5HfEpvc3QgVmFuIER5a2V+SlZEfFRvcnRvbGF+VFRBfFZpcmdpbiBHb3JkYX5WR0RcIl0sIFtcIlZpcmdpbiBJc2xhbmRzLCBVLlMuXCIsIFwiVklcIiwgXCJTdC4gVGhvbWFzflNUSHxTdC4gSm9obn5TSk98U3QuIENyb2l4flNDUlwiXSwgW1wiV2FsbGlzIGFuZCBGdXR1bmFcIiwgXCJXRlwiLCBcIkFsb35BTE98U2lnYXZlflNJR3xXYWxsaXN+V0FMXCJdLCBbXCJXZXN0ZXJuIFNhaGFyYVwiLCBcIkVIXCIsIFwiRXMgU21hcmF+RVNNfEJvdWpkb3VyfkJPRHxMYcOieW91bmV+TEFBfEFvdXNzZXJkfkFPVXxPdWVkIGVkIERhaGFifk9VRFwiXSwgW1wiWWVtZW5cIiwgXCJZRVwiLCBcIkFiecSBbn5BQnwnQWRhbn5BRHxB4biRIOG4kMSBbGknfkRBfEFsIEJheeG4kcSBJ35CQXxBbCDhuKh1ZGF5ZGFofkhVfEFsIEphd2Z+SkF8QWwgTWFocmFofk1SfEFsIE1h4bipd8SrdH5NV3wnQW1yxIFufkFNfERoYW3EgXJ+REh84bioYeG4kXJhbWF3dH5IRHzhuKhhamphaH5ISnxJYmJ+SUJ8TGHhuKlpan5MQXxNYSdyaWJ+TUF8UmF5bWFoflJBfMWexIHigJhkYWh+U0R8xZ5hbuKAmMSBJ35TTnxTaGFid2FoflNIfFTEgeKAmGl6en5UQVwiXSwgW1wiWmFtYmlhXCIsIFwiWk1cIiwgXCJDZW50cmFsfjAyfENvcHBlcmJlbHR+MDh8RWFzdGVybn4wM3xMdWFwdWxhfjA0fEx1c2FrYX4wOXxOb3J0aGVybn4wNXxOb3J0aC1XZXN0ZXJufjA2fFNvdXRoZXJufjA3fFdlc3Rlcm5+MDFcIl0sIFtcIlppbWJhYndlXCIsIFwiWldcIiwgXCJCdWxhd2F5b35CVXxIYXJhcmV+SEF8TWFuaWNhbGFuZH5NQXxNYXNob25hbGFuZCBDZW50cmFsfk1DfE1hc2hvbmFsYW5kIEVhc3R+TUV8TWFzaG9uYWxhbmQgV2VzdH5NV3xNYXN2aW5nb35NVnxNYXRhYmVsZWxhbmQgTm9ydGh+TU58TWF0YWJlbGVsYW5kIFNvdXRofk1TfE1pZGxhbmRzfk1JXCJdXSwgYSA9IGZ1bmN0aW9uICgpIHsgJChcIi5jcnMtY291bnRyeVwiKS5lYWNoKG4pIH0sIG4gPSBmdW5jdGlvbiAoKSB7IHZhciBhID0gdGhpczsgaWYgKFwidHJ1ZVwiICE9PSBhLmdldEF0dHJpYnV0ZShcImRhdGEtY3JzLWxvYWRlZFwiKSkgeyBhLmxlbmd0aCA9IDA7IHZhciBuID0gJChhKS5hdHRyKFwiZGF0YS1kZWZhdWx0LW9wdGlvblwiKSwgaSA9IG4gfHwgXCJTZWxlY3QgY291bnRyeVwiLCBlID0gYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXNob3ctZGVmYXVsdC1vcHRpb25cIik7IG0gPSBudWxsID09PSBlIHx8IFwidHJ1ZVwiID09PSBlOyB2YXIgciA9ICQoYSkuYXR0cihcImRhdGEtZGVmYXVsdC12YWx1ZVwiKSwgbyA9ICQoYSkuYXR0cihcImRhdGEtdmFsdWVcIiksIGwgPSAwOyBtICYmICh0aGlzLm9wdGlvbnNbMF0gPSBuZXcgT3B0aW9uKGksIFwiXCIpKSwgayh7IHdoaXRlbGlzdDogYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdoaXRlbGlzdFwiKSwgYmxhY2tsaXN0OiBhLmdldEF0dHJpYnV0ZShcImRhdGEtYmxhY2tsaXN0XCIpLCBwcmVmZXJyZWQ6IGEuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcmVmZXJyZWRcIiksIHByZWZlcnJlZERlbGltOiBhLmdldEF0dHJpYnV0ZShcImRhdGEtcHJlZmVycmVkLWRlbGltXCIpIH0pOyBmb3IgKHZhciB0ID0gMDsgdCA8IE0ubGVuZ3RoOyB0KyspIHsgdmFyIHMgPSBcInNob3J0Y29kZVwiID09IG8gfHwgXCIyLWNoYXJcIiA9PT0gbyA/IE1bdF1bMV0gOiBNW3RdWzBdOyBNW3RdWzRdICYmIChzID0gXCJcIiksIGEub3B0aW9uc1thLmxlbmd0aF0gPSBuZXcgT3B0aW9uKE1bdF1bMF0sIHMpLCBudWxsICE9IHIgJiYgciA9PT0gcyAmJiAobCA9IHQsIG0gJiYgbCsrKSB9IHRoaXMuc2VsZWN0ZWRJbmRleCA9IGw7IHZhciB1ID0gJChhKS5hdHRyKFwiZGF0YS1yZWdpb24taWRcIik7IGlmICh1KSB7IHZhciBkID0gJChcIiNcIiArIHUpWzBdOyBpZiAoZCkgaWYgKEIoZCksICQodGhpcykub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKCkgeyBiKGEsIGQpIH0pLCByICYmIDAgPCBhLnNlbGVjdGVkSW5kZXgpIHsgYihhLCBkKTsgdmFyIGggPSAkKGQpLmF0dHIoXCJkYXRhLWRlZmF1bHQtdmFsdWVcIiksIFMgPSBcInNob3J0Y29kZVwiID09PSBkLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIik7IGlmIChudWxsICE9PSBoKSB7IHZhciBBID0gbSA/IGEuc2VsZWN0ZWRJbmRleCAtIDEgOiBhLnNlbGVjdGVkSW5kZXgsIGcgPSBNW0FdWzNdOyBjKGQsIGcsIGgsIFMpIH0gfSBlbHNlICExID09PSBtICYmIGIoYSwgZCk7IGVsc2UgY29uc29sZS5lcnJvcihcIlJlZ2lvbiBkcm9wZG93biBET00gbm9kZSB3aXRoIElEIFwiICsgdSArIFwiIG5vdCBmb3VuZC5cIik7IGEuc2V0QXR0cmlidXRlKFwiZGF0YS1jcnMtbG9hZGVkXCIsIFwidHJ1ZVwiKSB9IGVsc2UgY29uc29sZS5lcnJvcihcIk1pc3NpbmcgZGF0YS1yZWdpb24taWQgb24gY291bnRyeS1yZWdpb24tc2VsZWN0b3IgY291bnRyeSBmaWVsZC5cIikgfSB9LCBCID0gZnVuY3Rpb24gKGEpIHsgdmFyIG4gPSAkKGEpLmF0dHIoXCJkYXRhLWJsYW5rLW9wdGlvblwiKSwgaSA9IG4gfHwgXCItXCIsIGUgPSBhLmdldEF0dHJpYnV0ZShcImRhdGEtc2hvdy1kZWZhdWx0LW9wdGlvblwiKTsgaCA9IG51bGwgPT09IGUgfHwgXCJ0cnVlXCIgPT09IGUsIGEubGVuZ3RoID0gMCwgaCAmJiAoYS5vcHRpb25zWzBdID0gbmV3IE9wdGlvbihpLCBcIlwiKSwgYS5zZWxlY3RlZEluZGV4ID0gMCkgfSwgayA9IGZ1bmN0aW9uIChhKSB7IHZhciBuID0gbCwgaSA9IFtdLCBlID0gMDsgaWYgKGEud2hpdGVsaXN0KSB7IHZhciByID0gYS53aGl0ZWxpc3Quc3BsaXQoXCIsXCIpOyBmb3IgKGUgPSAwOyBlIDwgbC5sZW5ndGg7IGUrKyktMSAhPT0gci5pbmRleE9mKGxbZV1bMV0pICYmIGkucHVzaChsW2VdKTsgbiA9IGkgfSBlbHNlIGlmIChhLmJsYWNrbGlzdCkgeyB2YXIgbyA9IGEuYmxhY2tsaXN0LnNwbGl0KFwiLFwiKTsgZm9yIChlID0gMDsgZSA8IGwubGVuZ3RoOyBlKyspLTEgPT09IG8uaW5kZXhPZihsW2VdWzFdKSAmJiBpLnB1c2gobFtlXSk7IG4gPSBpIH0gYS5wcmVmZXJyZWQgJiYgKG4gPSBzKG4sIGEucHJlZmVycmVkLCBhLnByZWZlcnJlZERlbGltKSksIE0gPSBuLCB0KCkgfSwgdCA9IGZ1bmN0aW9uICgpIHsgZm9yICh2YXIgYSA9IDA7IGEgPCBNLmxlbmd0aDsgYSsrKSB7IGZvciAodmFyIG4gPSB7IGhhc1Nob3J0Y29kZXM6IC9+Ly50ZXN0KE1bYV1bMl0pLCByZWdpb25zOiBbXSB9LCBpID0gTVthXVsyXS5zcGxpdChcInxcIiksIGUgPSAwOyBlIDwgaS5sZW5ndGg7IGUrKykgeyB2YXIgciA9IGlbZV0uc3BsaXQoXCJ+XCIpOyBuLnJlZ2lvbnMucHVzaChbclswXSwgclsxXV0pIH0gTVthXVszXSA9IG4gfSB9LCBjID0gZnVuY3Rpb24gKGEsIG4sIGksIGUpIHsgZm9yICh2YXIgciA9IDA7IHIgPCBuLnJlZ2lvbnMubGVuZ3RoOyByKyspIHsgaWYgKChlICYmIG4uaGFzU2hvcnRjb2RlcyAmJiBuLnJlZ2lvbnNbcl1bMV0gPyBuLnJlZ2lvbnNbcl1bMV0gOiBuLnJlZ2lvbnNbcl1bMF0pID09PSBpKSB7IGEuc2VsZWN0ZWRJbmRleCA9IGggPyByICsgMSA6IHI7IGJyZWFrIH0gfSB9LCBiID0gZnVuY3Rpb24gKGEsIG4pIHsgdmFyIGkgPSBtID8gYS5zZWxlY3RlZEluZGV4IC0gMSA6IGEuc2VsZWN0ZWRJbmRleCwgZSA9ICQobikuYXR0cihcImRhdGEtZGVmYXVsdC1vcHRpb25cIiksIHIgPSBuLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiksIG8gPSBlIHx8IFwiU2VsZWN0IHJlZ2lvblwiOyBpZiAoXCJcIiA9PT0gYS52YWx1ZSkgQihuKTsgZWxzZSB7IG4ubGVuZ3RoID0gMCwgaCAmJiAobi5vcHRpb25zWzBdID0gbmV3IE9wdGlvbihvLCBcIlwiKSk7IHZhciBsID0gTVtpXVszXSwgdCA9IFwic2hvcnRjb2RlXCIgPT09IHIgJiYgbC5oYXNTaG9ydGNvZGVzLCBzID0gdCA/IDEgOiAwOyBsLnJlZ2lvbnMuc29ydChmdW5jdGlvbiAoYSwgbikgeyB2YXIgaSA9IGFbc10udG9Mb3dlckNhc2UoKSwgZSA9IG5bc10udG9Mb3dlckNhc2UoKTsgcmV0dXJuIGkgPCBlID8gLTEgOiBlIDwgaSA/IDEgOiAwIH0pOyBmb3IgKHZhciB1ID0gMDsgdSA8IGwucmVnaW9ucy5sZW5ndGg7IHUrKykgeyB2YXIgZCA9IHQgPyBsLnJlZ2lvbnNbdV1bMV0gOiBsLnJlZ2lvbnNbdV1bMF07IG4ub3B0aW9uc1tuLmxlbmd0aF0gPSBuZXcgT3B0aW9uKGwucmVnaW9uc1t1XVswXSwgZCkgfSBuLnNlbGVjdGVkSW5kZXggPSAwIH0gfSwgcyA9IGZ1bmN0aW9uIChhLCBuLCBpKSB7IHZhciBlID0gbi5zcGxpdChcIixcIikucmV2ZXJzZSgpLCByID0ge30sIG8gPSAhMSwgbCA9IGEuZmlsdGVyKGZ1bmN0aW9uIChhKSB7IHJldHVybiAtMSA9PT0gZS5pbmRleE9mKGFbMV0pIHx8IChyW2FbMV1dID0gYSwgIShvID0gITApKSB9KTsgbyAmJiBpICYmIGwudW5zaGlmdChbaSwgXCJcIiwgXCJcIiwge30sICEwXSk7IGZvciAodmFyIHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKykgeyB2YXIgcyA9IGVbdF07IGwudW5zaGlmdChyW3NdKSB9IHJldHVybiBsIH07IHJldHVybiAkKGEpLCB7IGluaXQ6IGEgfSB9KTsiLCJjb25zdCAkID0gcmVxdWlyZSgnanF1ZXJ5JylcbndpbmRvdy4kID0gJFxud2luZG93LmpRdWVyeSA9ICRcbnJlcXVpcmUoJy4vanF1ZXJ5LmNycy5taW4nKVxucmVxdWlyZSgnLi9qUXVlcnktem9vbScpXG53aW5kb3cucG9wcGVyID0gcmVxdWlyZSgnLi9wb3BwZXInKVxud2luZG93LnRpcHB5ID0gcmVxdWlyZSgnLi90aXBweScpXG53aW5kb3cuU3BsaWRlID0gcmVxdWlyZSgnLi9zcGxpZGUnKVxucmVxdWlyZSgnLi9zcGxpZGUtZ3JpZCcpXG53aW5kb3cuaW50bFRlbElucHV0ID0gcmVxdWlyZSgnLi9pbnRsVGVsSW5wdXQnKVxud2luZG93LlBhcnNsZXkgPSByZXF1aXJlKCcuL3BhcnNsZXkubWluJylcbndpbmRvdy56ZW5zY3JvbGwgPSByZXF1aXJlKCcuL3plbnNjcm9sbCcpXG53aW5kb3cuZmFuY3lib3ggPSByZXF1aXJlKCcuL2ZhbmN5Ym94Lm1pbicpXG5cblxuLyoqIC0tIEdsb2JhbHMgKi9cbi8qKiBDb25zdGFudHMgLyBWYXJpYWJsZXMgLyBVdGlscyAvIEFqYXggKi9cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9jb25zdGFudHMnKVxuY29uc3QgdmFyaWFibGVzID0gcmVxdWlyZSgnLi9tb2R1bGVzL3ZhcmlhYmxlcycpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vbW9kdWxlcy91dGlscycpXG5jb25zdCBhamF4ID0gcmVxdWlyZSgnLi9tb2R1bGVzL2FqYXgnKVxuT2JqZWN0LmFzc2lnbih3aW5kb3csIGNvbnN0YW50cywgdmFyaWFibGVzLCB1dGlscywgYWpheClcblxuXG4vKiogLS0gQXBwZW5kIEVsZW1lbnRzICovXG4vKiBQYWdlIFRpcHMgKi9cbndpbmRvdy5QYWdlVGlwID0gcmVxdWlyZSgnLi9tb2R1bGVzL2R5bmFtaWMvcGFnZVRpcCcpXG4vKiBCYWNrZHJvcCAqL1xud2luZG93LkJhY2tkcm9wID0gcmVxdWlyZSgnLi9tb2R1bGVzL2R5bmFtaWMvYmFja2Ryb3AnKVxuLyogUGFnZSBDb25mZXR0aSAqL1xud2luZG93LlBhZ2VDb25mZXR0aSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9keW5hbWljL3BhZ2UtY29uZmV0dGknKVxuLyogQXNrIE1vZGFsICovXG53aW5kb3cuQXNrTW9kYWwgPSByZXF1aXJlKCcuL21vZHVsZXMvZHluYW1pYy9hc2stbW9kYWwnKVxuLyogTG9hZGVyIFJvb3QgKi9cbndpbmRvdy5yb290TG9hZGVyID0gcmVxdWlyZSgnLi9tb2R1bGVzL2R5bmFtaWMvcm9vdC1sb2FkZXInKVxuXG5cbi8qKiAtLSBQYWdlIEVsZW1lbnRzICovXG4vKiogTG9naW5cbiAqL1xucmVxdWlyZSgnLi9tb2R1bGVzL2xvZ2luJylcblxuLyoqIEhlYWRlciAvIEZvb3RlclxuICogQHR5cGUgT2JqZWN0c1xuICovXG53aW5kb3cuaGVhZGVyID0gcmVxdWlyZSgnLi9tb2R1bGVzL2VsZW1lbnRzL2hlYWRlcicpXG53aW5kb3cuZm9vdGVyID0gcmVxdWlyZSgnLi9tb2R1bGVzL2VsZW1lbnRzL2Zvb3RlcicpXG5cbi8qKiBQYWdlIEVsZW1lbnRzXG4gKiBAdHlwZSBPYmplY3RcbiAqL1xud2luZG93LnBhZ2VFbHMgPSByZXF1aXJlKCcuL21vZHVsZXMvZWxlbWVudHMvcGFnZS1lbGVtZW50cycpXG53aW5kb3cucGFnZVJldmlld3MgPSByZXF1aXJlKCcuL21vZHVsZXMvZWxlbWVudHMvcGFnZS1yZXZpZXdzJylcbndpbmRvdy5oZXJvU3BsaWRlID0gcmVxdWlyZSgnLi9tb2R1bGVzL2VsZW1lbnRzL2hlcm8tc3BsaWRlJylcbndpbmRvdy5wYWdlQWxlcnRzID0gcmVxdWlyZSgnLi9tb2R1bGVzL2VsZW1lbnRzL3BhZ2UtYWxlcnRzJylcblxuLyoqIE1vZGFsc1xuICogQ3VycmVuY3kgLyBDYXJ0IC8gTWVudSAvIE1haWwgLyBRdWl6IC8gU2lnbiAvIE1lbnVcbiAqIEB0eXBlIE9iZWpjdHNcbiAqL1xud2luZG93LmN1cnJlbmN5TW9kYWwgPSByZXF1aXJlKCcuL21vZHVsZXMvbW9kYWxzL2N1cnJlbmN5LW1vZGFsJylcbndpbmRvdy5jYXJ0TW9kYWwgPSByZXF1aXJlKCcuL21vZHVsZXMvbW9kYWxzL2NhcnQtbW9kYWwnKVxud2luZG93LmJvb2tNb2RhbCA9IHJlcXVpcmUoJy4vbW9kdWxlcy9tb2RhbHMvYm9vay1tb2RhbCcpXG53aW5kb3cubWFpbE1vZGFsID0gcmVxdWlyZSgnLi9tb2R1bGVzL21vZGFscy9tYWlsLW1vZGFsJylcbndpbmRvdy5xdWl6TW9kYWwgPSByZXF1aXJlKCcuL21vZHVsZXMvbW9kYWxzL3F1aXotbW9kYWwnKVxud2luZG93LnNhbGVzTW9kYWwgPSByZXF1aXJlKCcuL21vZHVsZXMvbW9kYWxzL3NhbGVzLW1vZGFsJylcbmNvbnN0IFNpZ25Nb2RhbCA9IHJlcXVpcmUoJy4vbW9kdWxlcy9tb2RhbHMvc2lnbi1tb2RhbCcpXG5jb25zdCBNZW51ID0gcmVxdWlyZSgnLi9tb2R1bGVzL21vZGFscy9tZW51JylcblxuLyoqIFBHIEZpbHRlcnMvU2VsZWN0L01vZGFsXG4gKiBAdHlwZSBPYmplY3RzXG4gKi9cbndpbmRvdy5wZ1NlbGVjdCA9IHJlcXVpcmUoJy4vbW9kdWxlcy9lbGVtZW50cy9wZy1zZWxlY3QnKVxud2luZG93LnBnTW9kYWwgPSByZXF1aXJlKCcuL21vZHVsZXMvZWxlbWVudHMvcGctbW9kYWwnKVxuXG5cbi8qKiAtLSBQYWdlcyAqL1xuY29uc3RcbiAgLyogTG9hbiBBcHAgOiAvZmluYW5jaW5nICovXG4gIExvYW5BcHAgPSByZXF1aXJlKCcuL21vZHVsZXMvcGFnZXMvbG9hbi1hcHAnKSxcbiAgLyogSm9iIEFwcGx5IDogL2FwcGx5LWpvYiAqL1xuICBKb2JBcHAgPSByZXF1aXJlKCcuL21vZHVsZXMvcGFnZXMvam9iLWFwcCcpLFxuICAvKiBTZWxsIFdhdGNoIDogL3NlbGwtbXktd2F0Y2ggKi9cbiAgU2VsbFdhdGNoID0gcmVxdWlyZSgnLi9tb2R1bGVzL3BhZ2VzL3NlbGwtd2F0Y2gnKSxcbiAgLyogTG9vc2UgRGlhbW9uZHMgOiAvbG9vc2UtZGlhbW9uZHMgKi9cbiAgTG9vc2VEaWFtb25kcyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9sb29zZS1kaWFtb25kcycpLFxuICAvKiBIb21lcGFnZSA6IC9pbmRleCAqL1xuICBIb21lcGFnZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9ob21lcGFnZScpLFxuICBSZXN1bHRzUGFnZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9yZXN1bHRzJyksXG4gIFByb2R1Y3RQYWdlID0gcmVxdWlyZSgnLi9tb2R1bGVzL3BhZ2VzL3Byb2R1Y3QnKSxcbiAgLyogUHJvZHVjdCBQYWdlIDogL3Byb2R1Y3QtcGFnZSAqL1xuICBwcm9kdWN0UGFnZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9wcm9kdWN0JyksXG4gIC8qIE15IEJhZyA6IC9jYXJ0ICovXG4gIG15QmFnID0gcmVxdWlyZSgnLi9tb2R1bGVzL3BhZ2VzL215LWJhZycpLFxuICAvKiBBY2NvdW50IFByb2ZpbGUgOiAvYWNjb3VudCAqL1xuICBhY2NvdW50ID0gcmVxdWlyZSgnLi9tb2R1bGVzL3BhZ2VzL2FjY291bnQtcGFnZScpLFxuICAvKiBMb2NhdGlvbnMgOiAvbG9jYXRpb25zICovXG4gIGxvY2F0aW9uUGFnZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9sb2NhdGlvbi1wYWdlJyksXG4gIC8qIFNlbGwgUGFnZXMgOiAvc2VsbCAqL1xuICBzZWxsUGFnZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9zZWxsLXBhZ2UnKSxcbiAgLyogUGFzcyBSZXNldCA6IC9wYXNzLXJlc2V0ICovXG4gIHBhc3NSZXNldCA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9wYXNzLXJlc2V0JyksXG4gIC8qIEJsb2cgOiAvYmxvZyAqL1xuICBibG9nUGFnZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9ibG9nLXBhZ2UnKSxcbiAgLyogRm9ybSBQYWdlIDogL2Zvcm0gKi9cbiAgZm9ybVBhZ2UgPSByZXF1aXJlKCcuL21vZHVsZXMvcGFnZXMvZm9ybS1wYWdlJyksXG4gIC8qIFRhZyBQcmV2aWV3IDogL3RhZyAqL1xuICB0YWdQcmV2aWV3ID0gcmVxdWlyZSgnLi9tb2R1bGVzL3BhZ2VzL3RhZy1wcmV2aWV3JylcblxuXG4vKiogLS0gSW5pdGlhbGl6ZSBQYWdlIE9iamVjdHMgKi9cbmNvbnN0XG4gIHBhZ2VPYmplY3RzQXJyID0gW1xuICAgIGhlYWRlcixcbiAgICBjYXJ0TW9kYWwsXG4gICAgY3VycmVuY3lNb2RhbCxcbiAgICBwZ01vZGFsLFxuICAgIGZvb3RlcixcbiAgICBwYWdlRWxzLFxuICAgIG15QmFnLFxuICAgIGFjY291bnQsXG4gICAgbG9jYXRpb25QYWdlLFxuICAgIHBhZ2VBbGVydHMsXG4gICAgc2VsbFBhZ2UsXG4gICAgYm9va01vZGFsLFxuICAgIHBhc3NSZXNldCxcbiAgICBwYWdlUmV2aWV3cyxcbiAgICBibG9nUGFnZSxcbiAgICBoZXJvU3BsaWRlLFxuICAgIG1haWxNb2RhbCxcbiAgICBxdWl6TW9kYWwsXG4gICAgc2FsZXNNb2RhbCxcbiAgICBmb3JtUGFnZSxcbiAgICB0YWdQcmV2aWV3XG4gIF1cbmNvbnN0IGluaXRQYWdlT2JqZWN0cyA9ICgpID0+IHtcbiAgZm9yIChjb25zdCBvYmogb2YgcGFnZU9iamVjdHNBcnIpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBvYmouaW5pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9iai5pbml0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG9iaiwgJ05vIGluaXQgZnVuY3Rpb24nKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW5pdGlhbGl6aW5nICR7b2JqfTpgLCBlcnIpXG4gICAgfVxuICB9XG59XG5cblxuLyoqIC0tIEluaXQgUGFnZSBPYmplY3RzICovXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gIGluaXRQYWdlT2JqZWN0cygpXG4gIHdpbmRvdy5wYWdlVGlwID0gbmV3IFBhZ2VUaXAoKVxuICB3aW5kb3cuc2lnbk1vZGFsID0gbmV3IFNpZ25Nb2RhbCgpXG5cbiAgLy8gTG9hbiBBcHBcbiAgY29uc3QgbG9hbkNhc2VIb2xkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cImxvYW4tYXBwbHlcIl0nKVxuICBpZiAobG9hbkNhc2VIb2xkZXIpIHtcbiAgICB3aW5kb3cubG9hbkFwcCA9IG5ldyBMb2FuQXBwKGxvYW5DYXNlSG9sZGVyKVxuICB9XG5cbiAgLy8gSm9iIEFwcGx5XG4gIGNvbnN0IGpvYkNhc2VIb2xkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cImpvYi1hcHBseVwiXScpXG4gIGlmIChqb2JDYXNlSG9sZGVyKSB7XG4gICAgd2luZG93LmpvYkFwcCA9IG5ldyBKb2JBcHAoam9iQ2FzZUhvbGRlcilcbiAgfVxuXG4gIC8vIEZvcm0gUGFnZVxuICBjb25zdCBmb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZm9ybSNzZWxsX215X3dhdGNoJylcbiAgaWYgKGZvcm0pIHtcbiAgICB3aW5kb3cuc2VsbE15V2F0Y2ggPSBuZXcgU2VsbFdhdGNoKClcbiAgfVxuXG4gIC8vIExvb3NlIERpYW1vbmRzXG4gIGNvbnN0IGxvb3NlRGlhbW9uZHNNYWluID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxvb3NlX2RpYW1vbmRzJylcbiAgaWYgKGxvb3NlRGlhbW9uZHNNYWluKSB7XG4gICAgd2luZG93Lmxvb3NlID0gbmV3IExvb3NlRGlhbW9uZHMoKVxuICB9XG5cbiAgLy8gTWVudVxuICBjb25zdCBtZW51RWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZW51JylcbiAgaWYgKG1lbnVFbGVtKSB7XG4gICAgd2luZG93Lm1lbnUgPSBuZXcgTWVudSgnLm1lbnUnKVxuICB9XG5cbiAgLy8gSG9tZXBhZ2VcbiAgbmV3IEhvbWVwYWdlKClcblxuICAvLyBSZXN1bHRzXG4gIGNvbnN0IHJlc3VsdHNNYWluID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW5fcmVzdWx0cycpXG4gIGlmIChyZXN1bHRzTWFpbikge1xuICAgIG5ldyBSZXN1bHRzUGFnZSgpXG4gIH1cblxuICBjb25zdCBwcm9kdWN0TWFpbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluX3Byb2R1Y3QnKVxuICBpZiAocHJvZHVjdE1haW4pIHtcbiAgICBuZXcgUHJvZHVjdFBhZ2UoKVxuICB9XG59KSIsImZ1bmN0aW9uIGFwcGx5UmVkZWVtQ29kZSgpIHtcbiAgY29uc3QgdmFsdWUgPSAkKCcjcmVkZWVtX2lucHV0JykudmFsKCk7XG4gIGlmICh2YWx1ZSAhPSAnJykge1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvanNvbi9yZWRlZW0tcHJvbW8tY29kZScsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiB7IGNvZGU6IHZhbHVlIH0sXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgciA9ICQucGFyc2VKU09OKGRhdGEpO1xuICAgICAgICBpZiAoIXIuZXJyb3IpIHtcbiAgICAgICAgICAkKCcuY2hlY2tvdXQtcmVkZWVtJykuc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3dNZXNzYWdlKCdlcnJvcicsICdFcnJvcicsIHIubXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcHBseVJlZGVlbUNvZGVcbn0iLCJjb25zdCBjb25zdGFudHMgPSB7XG4gIElTX1ZJU0lCTEU6IFwiaXMtdmlzaWJsZVwiLFxuICBJU19BQ1RJVkU6IFwiaXMtYWN0aXZlXCIsXG4gIEJVVFRPTl9MT0FESU5HOiBcImJ1dHRvbl9sb2FkaW5nXCIsXG4gIElTX0hJRERFTjogJ2lzLWhpZGRlbicsXG4gIElTX0VYUEFOREVEOiAnaXMtZXhwYW5kZWQnLFxuICBJU19NSU5JTUlaRUQ6ICdpcy1taW5pbWl6ZWQnLFxuICBJU19DT1BJRUQ6ICdpcy1jb3BpZWQnLFxuICBJU19FUlJPUjogJ2lzLWVycm9yJyxcbiAgSVNfRU1QVFk6ICdpcy1lbXB0eScsXG4gIF9fVFJVRTogJy0tdHJ1ZScsXG4gIF9fRkFMU0U6ICctLWZhbHNlJyxcbiAgX19GQURFOiAnLS1mYWRlJyxcbiAgX19IQUxGOiAnLS1oYWxmJyxcbiAgX19TRUxFQ1RFRDogJy0tc2VsZWN0ZWQnLFxuICBfX0xPQURFRDogJy0tbG9hZGVkJyxcbiAgX19ISURERU46ICctLWhpZGRlbicsXG4gIF9fVklTSUJMRTogJy0tdmlzaWJsZScsXG4gIF9fVkFMSUQ6ICctLXZhbGlkJyxcbiAgX19JTlZBTElEOiAnLS1pbnZhbGlkJyxcbiAgX19QRU5ESU5HOiAnLS1wZW5kaW5nJyxcbiAgX19MT0NLRUQ6ICctLWxvY2tlZCcsXG4gIF9fQUNUSVZFOiAnLS1hY3RpdmUnLFxuICBfX0VYUEFOREVEOiAnLS1leHBhbmRlZCcsXG4gIHBhY2VPcHRpb25zOiB7XG4gICAgYWpheDogdHJ1ZSxcbiAgICBkb2N1bWVudDogdHJ1ZSxcbiAgICBlbGVtZW50czoge1xuICAgICAgc2VsZWN0b3JzOiBbJ21haW4nXVxuICAgIH1cbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnRzOyIsImNsYXNzIEFza01vZGFsIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSkge1xuICAgIHRoaXMuaGVhZGluZyA9IHNldHRpbmdzLmhlYWRpbmcgfHwgJ0FyZSBZb3UgU3VyZSBZb3UgV2FudCBUbyBFeGl0PydcbiAgICB0aGlzLnN1YmhlYWRpbmcgPSBzZXR0aW5ncy5zdWJoZWFkaW5nIHx8ICdZb3Ugd2lsbCBsb3NlIGFsbCB1bnNhdmVkIHByb2dyZXNzLidcbiAgICB0aGlzLmV4aXRUZXh0ID0gc2V0dGluZ3MuZXhpdFRleHQgfHwgJ0V4aXQnXG4gICAgdGhpcy5rZWVwVGV4dCA9IHNldHRpbmdzLmtlZXBUZXh0IHx8ICdLZWVwJ1xuICAgIHRoaXMuZXhpdENhbGxiYWNrID0gc2V0dGluZ3MuZXhpdENhbGxiYWNrXG4gICAgdGhpcy5rZWVwQ2FsbGJhY2sgPSB0aGlzLmRlc3Ryb3lcbiAgfVxuXG4gIGdldCByZW5kZXJIVE1MKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8ZGl2IGRhdGEtZXZ0PVwiY2xvc2VBc2tNb2RhbFwiPjwvZGl2PlxuICAgICAgPGRpdj5cbiAgICAgICAgPGg0PiR7dGhpcy5oZWFkaW5nfTwvaDQ+XG4gICAgICAgIDxwPiR7dGhpcy5zdWJoZWFkaW5nfTwvcD5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8YnV0dG9uPiR7dGhpcy5leGl0VGV4dH08L2J1dHRvbj5cbiAgICAgICAgICA8YnV0dG9uPiR7dGhpcy5rZWVwVGV4dH08L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgXG4gIH1cblxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgbW9kYWwgPSBjcmVhdGVFbGVtKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICdhc2stbW9kYWwnLFxuICAgICAgaW5uZXJIVE1MOiB0aGlzLnJlbmRlckhUTUxcbiAgICB9KVxuICAgIGNvbnN0IGJ1dHRvbnMgPSBbLi4ubW9kYWwucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJyldXG4gICAgY29uc3QgY2xvc2VFdnQgPSBbLi4ubW9kYWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZXZ0PVwiY2xvc2VBc2tNb2RhbFwiXScpXVxuICAgIGJ1dHRvbnNbMF0ub25jbGljayA9ICgpID0+IHsgdGhpcy5kZXN0cm95KCk7IHRoaXMuZXhpdENhbGxiYWNrKCkgfVxuICAgIGJ1dHRvbnNbMV0ub25jbGljayA9ICgpID0+IHsgdGhpcy5rZWVwQ2FsbGJhY2soKSB9XG4gICAgZm9yIChjb25zdCBldnQgb2YgY2xvc2VFdnQpIHtcbiAgICAgIGV2dC5vbmNsaWNrID0gKCkgPT4geyB0aGlzLmRlc3Ryb3koKSB9XG4gICAgfVxuICAgIHJldHVybiBtb2RhbFxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB1bmxvY2tTY3JvbGwoKVxuICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFzay1tb2RhbCcpXG4gICAgaWYgKG1vZGFsKSB7XG4gICAgICBtb2RhbC5yZW1vdmUoKVxuICAgIH1cbiAgfVxuXG4gIHNob3coKSB7XG4gICAgbG9ja1Njcm9sbCgpXG4gICAgY29uc3QgZWxlbSA9IHRoaXMuY3JlYXRlKClcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBc2tNb2RhbCIsImNsYXNzIEJhY2tkcm9wIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSkge1xuICAgIHRoaXMuZWwgPSBjcmVhdGVFbGVtKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICdwYWdlLWJhY2tkcm9wJyxcbiAgICB9KVxuICAgIHRoaXMuY2FsbGJhY2sgPSBzZXR0aW5ncy5jYWxsYmFjayB8fCBudWxsXG4gICAgdGhpcy56SW5kZXggPSBzZXR0aW5ncy56SW5kZXggfHwgdW5kZWZpbmVkXG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gc2V0dGluZ3MuYmFja2dyb3VuZCB8fCB1bmRlZmluZWRcbiAgICB0aGlzLmhhbGYgPSBzZXR0aW5ncy5oYWxmIHx8IGZhbHNlXG4gICAgdGhpcy5zaG93KClcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy5lbCkge1xuICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzaG93KCkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5lbClcbiAgICBpZiAodGhpcy56SW5kZXgpIHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuekluZGV4ID0gdGhpcy56SW5kZXhcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFsZikge1xuICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKF9fSEFMRilcbiAgICB9XG4gICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5lbC5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgfSwgMSk7XG4gIH1cblxuICBoaWRlKGlnbm9yZUNhbGxiYWNrID0gZmFsc2UpIHtcbiAgICB0aGlzLmVsLnN0eWxlLm9wYWNpdHkgPSAnMCdcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgdGhpcy5lbC5yZW1vdmUoKVxuICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMuZWwpKTtcblxuICAgIGlmICh0aGlzLmNhbGxiYWNrICYmICFpZ25vcmVDYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjaygpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2Ryb3AiLCJjbGFzcyBQYWdlQ29uZmV0dGkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVsID0gbnVsbFxuICAgIHRoaXMuY29udGFpbmVyRWwgPSBudWxsXG4gICAgdGhpcy5jb25mZXR0aUZyZXF1ZW5jeSA9IDNcbiAgICB0aGlzLmNvbmZldHRpSW50ZXJ2YWwgPSA1MFxuICAgIHRoaXMudGltZVRvRGVzdHJveSA9IDgwMDBcbiAgICB0aGlzLmNvbmZldHRpQ29sb3JzID0gWycjMDA5NWM2JywgJyMxYWI4ZWMnLCAnIzhjZGZmYScsICcjZDhmM2ZjJ11cbiAgICB0aGlzLmNvbmZldHRpQW5pbWF0aW9ucyA9IFsnc2xvdycsICdtZWRpdW0nLCAnZmFzdCddXG4gIH1cblxuICBjcmVhdGVIb2xkZXIoKSB7XG4gICAgdGhpcy5lbCA9IGNyZWF0ZUVsZW0oJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2NvbmZldHRpLWhvbGRlcidcbiAgICB9KVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5lbClcbiAgfVxuXG4gIHNldHVwKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lckVsID0gY3JlYXRlRWxlbSgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAnY29uZmV0dGktY29udGFpbmVyJ1xuICAgIH0pXG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZChjb250YWluZXJFbClcbiAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWxcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbmZldHRpSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBjb25mZXR0aUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIGNvbnN0IGNvbmZldHRpU2l6ZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMpICsgNyArICdweCdcbiAgICAgIGNvbnN0IGNvbmZldHRpQmFja2dyb3VuZCA9IHRoaXMuY29uZmV0dGlDb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5jb25mZXR0aUNvbG9ycy5sZW5ndGgpXVxuICAgICAgY29uc3QgY29uZmV0dGlMZWZ0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5lbC5vZmZzZXRXaWR0aCkgKyAncHgnXG4gICAgICBjb25zdCBjb25mZXR0aUFuaW1hdGlvbiA9IHRoaXMuY29uZmV0dGlBbmltYXRpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMuY29uZmV0dGlBbmltYXRpb25zLmxlbmd0aCldXG5cbiAgICAgIGNvbmZldHRpRWwuY2xhc3NMaXN0LmFkZCgnY29uZmV0dGknLCAnY29uZmV0dGktLWFuaW1hdGlvbi0nICsgY29uZmV0dGlBbmltYXRpb24pXG4gICAgICBjb25mZXR0aUVsLnN0eWxlLmxlZnQgPSBjb25mZXR0aUxlZnRcbiAgICAgIGNvbmZldHRpRWwuc3R5bGUud2lkdGggPSBjb25mZXR0aVNpemVcbiAgICAgIGNvbmZldHRpRWwuc3R5bGUuaGVpZ2h0ID0gY29uZmV0dGlTaXplXG4gICAgICBjb25mZXR0aUVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbmZldHRpQmFja2dyb3VuZFxuXG4gICAgICBjb25mZXR0aUVsLnJlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uZmV0dGlFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvbmZldHRpRWwpXG4gICAgICB9LCAzMDAwKVxuXG4gICAgICB0aGlzLmNvbnRhaW5lckVsLmFwcGVuZENoaWxkKGNvbmZldHRpRWwpXG4gICAgfSwgdGhpcy5jb25mZXR0aUludGVydmFsKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSAnMCdcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKVxuICAgICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUoZWwpKTtcbiAgICB9XG4gIH1cblxuICBwdXNoKGluZmluaXR5ID0gZmFsc2UpIHtcbiAgICB0aGlzLmNyZWF0ZUhvbGRlcigpXG4gICAgdGhpcy5zZXR1cCgpXG4gICAgdGhpcy5yZW5kZXIoKVxuICAgIGlmICghaW5maW5pdHkpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKVxuICAgICAgfSwgdGhpcy50aW1lVG9EZXN0cm95KTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlQ29uZmV0dGkiLCIvKipcbiAqIFBhZ2UgVGlwc1xuICovXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIGZ1bmN0aW9uIFBhZ2VUaXAoKSB7XG4gICAgdGhpcy50aXBFbGVtID0gbnVsbDtcbiAgICB0aGlzLmhhbmRsZUhvdmVyKCk7XG4gIH1cblxuICBQYWdlVGlwLnByb3RvdHlwZS5oYW5kbGVIb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRpcF0nKS5mb3JFYWNoKGVsZW0gPT4ge1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZSA9PiB7XG4gICAgICAgIHRoaXMuY3JlYXRlVGlwKGVsZW0pO1xuICAgICAgICB0aGlzLnRpcEVsZW0udGV4dENvbnRlbnQgPSBlbGVtLmRhdGFzZXQudGlwO1xuICAgICAgICB0aGlzLnNldFRpcFBvc2l0aW9uKGVsZW0pO1xuICAgICAgfSk7XG5cbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGUgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3lUaXAoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFBhZ2VUaXAucHJvdG90eXBlLmNyZWF0ZVRpcCA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIGlmICghdGhpcy50aXBFbGVtKSB7XG4gICAgICB0aGlzLnRpcEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMudGlwRWxlbS5jbGFzc0xpc3QuYWRkKCdwYWdlLXRpcCcpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQodGhpcy50aXBFbGVtKTtcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBjb25zdCBleHRyYUNsYXNzID0gdGFyZ2V0LmRhdGFzZXQudGlwQ2xhc3M7XG4gICAgICAgIGlmIChleHRyYUNsYXNzKSB7XG4gICAgICAgICAgdGhpcy50aXBFbGVtLmNsYXNzTGlzdC5hZGQoYC0tJHtleHRyYUNsYXNzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFBhZ2VUaXAucHJvdG90eXBlLnNldFRpcFBvc2l0aW9uID0gZnVuY3Rpb24oZWxlbSkge1xuICAgIGNvbnN0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHRpcFdpZHRoID0gdGhpcy50aXBFbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgIGNvbnN0IHRpcEhlaWdodCA9IHRoaXMudGlwRWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgY29uc3QgZWxlbUhlaWdodCA9IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IGVsZW1XaWR0aCA9IGVsZW0ub2Zmc2V0V2lkdGg7XG5cbiAgICBsZXQgdG9wUG9zaXRpb24gPSB0b3AgLSB0aXBIZWlnaHQgLSA4O1xuICAgIGxldCBsZWZ0UG9zaXRpb24gPSAobGVmdCArIChlbGVtV2lkdGggLyAyKSkgLSAodGlwV2lkdGggLyAyKTtcblxuICAgIGlmICh0b3BQb3NpdGlvbiA8IDEwMCkge1xuICAgICAgdG9wUG9zaXRpb24gPSB0b3AgKyBlbGVtSGVpZ2h0ICsgODtcbiAgICAgIHRoaXMudGlwRWxlbS5jbGFzc0xpc3QuYWRkKCctLXRvcCcpO1xuICAgIH1cblxuICAgIGlmIChsZWZ0UG9zaXRpb24gPCAwKSB7XG4gICAgICBsZWZ0UG9zaXRpb24gPSBsZWZ0O1xuICAgICAgdGhpcy50aXBFbGVtLmNsYXNzTGlzdC5hZGQoJy0tbGVmdCcpO1xuICAgIH1cblxuICAgIHRoaXMudGlwRWxlbS5zdHlsZS50b3AgPSBgJHt0b3BQb3NpdGlvbn1weGA7XG4gICAgdGhpcy50aXBFbGVtLnN0eWxlLmxlZnQgPSBgJHtsZWZ0UG9zaXRpb259cHhgO1xuICB9O1xuXG4gIFBhZ2VUaXAucHJvdG90eXBlLmRlc3Ryb3lUaXAgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy50aXBFbGVtKSB7XG4gICAgICB0aGlzLnRpcEVsZW0ucmVtb3ZlKCk7XG4gICAgICB0aGlzLnRpcEVsZW0gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvLyDQrdC60YHQv9C+0YDRgtC40YDRg9C10Lwg0LrQu9Cw0YHRgSBQYWdlVGlwXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gUGFnZVRpcDtcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuUGFnZVRpcCA9IFBhZ2VUaXA7XG4gIH1cbn0pKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBnbG9iYWwpOyIsImNvbnN0IHJvb3RMb2FkZXIgPSBuZXcgT2JqZWN0KHtcbiAgY2xhc3M6ICdyb290X2xvYWRlcicsXG4gIHJlbmRlckhUTUw6ICgpID0+IHsgcmV0dXJuIGA8ZGl2IGNsYXNzPSR7cm9vdExvYWRlci5jbGFzc30+PC9kaXY+YCB9LFxuICBpc0V4aXN0OiAoKSA9PiB7IHJldHVybiAkKGRvY3VtZW50KS5maW5kKGAuJHtyb290TG9hZGVyLmNsYXNzfWApLmxlbmd0aCA/IHRydWUgOiBmYWxzZSB9LFxuXG4gIHB1c2g6IGZ1bmN0aW9uIChub0xvY2sgPSBmYWxzZSkge1xuICAgIGlmICghbm9Mb2NrKSB7IGxvY2tTY3JvbGwoKSB9XG4gICAgaWYgKCF0aGlzLmlzRXhpc3QoKSkgeyAkYm9keS5hcHBlbmQocm9vdExvYWRlci5yZW5kZXJIVE1MKCkpIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiAobm9VbmxvY2sgPSBmYWxzZSkge1xuICAgIGlmICghbm9VbmxvY2spIHVubG9ja1Njcm9sbCgpO1xuICAgIGlmICh0aGlzLmlzRXhpc3QoKSkgeyAkKGRvY3VtZW50KS5maW5kKGAuJHtyb290TG9hZGVyLmNsYXNzfWApLnJlbW92ZSgpIH1cbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSByb290TG9hZGVyIiwiY29uc3QgZm9vdGVyID0gbmV3IE9iamVjdCh7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPCA5OTIpIHtcbiAgICAgICAgbGV0IGZvb3RlckhlYWRlciA9IEFycmF5LmZyb20oJChcIi5mb290ZXItY29sX19oZWFkZXJcIikpO1xuXG4gICAgICAgICQuZWFjaChmb290ZXJIZWFkZXIsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgbGV0IGNvbCA9ICQoZm9vdGVySGVhZGVyW2ldKS5jbG9zZXN0KFwiLmZvb3Rlci1jb2xcIiksXG4gICAgICAgICAgICBib2R5ID0gY29sLmZpbmQoXCIuZm9vdGVyLWNvbF9fYm9keVwiKTtcblxuICAgICAgICAgIGlmIChib2R5Lmxlbmd0aCAmJiBjb2wubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb290ZXJIZWFkZXJbaV0ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGJvZHkuaGVpZ2h0KCkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBzY3JIID0gYm9keS5maW5kKFwiLmZvb3Rlci1jb2xfX2JvZHktc2Nyb2xsXCIpWzBdXG4gICAgICAgICAgICAgICAgICAuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJvZHkuY3NzKHtcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogYCR7c2NySH1weGAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGggPSBib2R5LmNzcyhcImhlaWdodFwiKTtcbiAgICAgICAgICAgICAgICBib2R5LmNzcyhcImhlaWdodFwiLCBoKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGJvZHkuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjBweFwiLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkKHdpbmRvdykub24oXCJsb2FkIHJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhdHRhY2goKTtcbiAgICB9KTtcbiAgfSxcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZm9vdGVyIiwiY29uc3QgaGVhZGVyID0ge1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW5kZXJET00oKTtcbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB0aGlzLnNldERyb3Bkb3ducygpXG4gIH0sXG4gIHJlbmRlckRPTTogZnVuY3Rpb24gKCkge1xuICAgIC8vIExvZ2luIERyb3Bkb3duXG4gICAgdGhpcy5sb2dpbkJ0biA9ICQoJ1tkYXRhLWV2dD1cInRvZ2dsZUFjY291bnREcm9wZG93blwiXScpO1xuICAgIHRoaXMubG9naW5Ecm9wZG93biA9ICQoXCIubG9naW4tZHJvcGRvd25cIik7XG5cbiAgICAvLyBTZWFyY2hcbiAgICB0aGlzLnNlYXJjaEJ0biA9ICQoJ1tkYXRhLWV2dD1cInRvZ2dsZVNlYXJjaFwiXScpO1xuICAgIHRoaXMuc2VhcmNoQmxvY2sgPSAkKFwiLmhlYWRlci1zZWFyY2hcIik7XG5cbiAgICB0aGlzLmxvZ2luTGluayA9ICQoJy5sb2dpbi1uYXZfX2xpbmsnKVxuICB9LFxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sb2dpbkJ0bi5vbignbW91c2VvdmVyIG1vdXNlbGVhdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBsZXQgZGQgPSBoZWFkZXIubG9naW5Ecm9wZG93blxuICAgICAgaWYgKGRkLmxlbmd0aCkge1xuICAgICAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgICAgICAgIGRkLmNzcyh7IGRpc3BsYXk6ICdibG9jaycsIG9wYWNpdHk6IDEgfSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21vdXNlbGVhdmUnOlxuICAgICAgICAgICAgZGQuY3NzKHsgZGlzcGxheTogJ25vbmUnLCBvcGFjaXR5OiAwIH0pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5sb2dpbkxpbmsuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICB9KVxuXG4gICAgdGhpcy5zZWFyY2hCdG4uY2xpY2soKCkgPT4ge1xuICAgICAgbGV0IGVsID0gaGVhZGVyLnNlYXJjaEJsb2NrO1xuXG4gICAgICBmdW5jdGlvbiBoaWRlU2VhcmNoKCkge1xuICAgICAgICBlbC5yZW1vdmVDbGFzcyhJU19WSVNJQkxFKTtcbiAgICAgICAgdW5sb2NrU2Nyb2xsKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC5oYXNDbGFzcyhJU19WSVNJQkxFKSkge1xuICAgICAgICBoaWRlU2VhcmNoKClcbiAgICAgICAgaWYgKHdpbmRvdy5zZWFyY2hCYWNrZHJvcCkge1xuICAgICAgICAgIHdpbmRvdy5zZWFyY2hCYWNrZHJvcC5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2tTY3JvbGwoKTtcbiAgICAgICAgZWwuYWRkQ2xhc3MoSVNfVklTSUJMRSk7XG4gICAgICAgIGVsLmZpbmQoXCJpbnB1dFwiKS5mb2N1cygpO1xuXG4gICAgICAgIHdpbmRvdy5zZWFyY2hCYWNrZHJvcCA9IG5ldyBCYWNrZHJvcCh7XG4gICAgICAgICAgaGFsZjogdHJ1ZSxcbiAgICAgICAgICB6SW5kZXg6IChnZXRaSW5kZXgoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZGVyJykpIC0gMSksXG4gICAgICAgICAgY2FsbGJhY2s6IGhpZGVTZWFyY2hcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgc2V0RHJvcGRvd25zOiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGFyZ3MgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5oZWFkZXJfX3N1Yi1saW5rJykpXG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDAgJiYgYXJncykge1xuXG4gICAgICBjb25zdCBkZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5uYXYtZHJvcCcpXG4gICAgICBjb25zdCBjb250ID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5uYXYtZHJvcF9fY29udGVudCcpXVxuICAgICAgY29uc3Qgc3ViTGluayA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubmF2LWRyb3BfbW9yZScpXVxuICAgICAgY29uc3QgSVNfQUNUSVZFID0gJ2lzLWFjdGl2ZSdcblxuICAgICAgbGV0IGhpZGVEZWxheVRpbWUsIHNob3dEZWxheVRpbWVcblxuICAgICAgaWYgKGRkICYmIGNvbnQgJiYgc3ViTGluaykge1xuICAgICAgICBjb25zdCBwb3MgPSAoZWwpID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBlbC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgKGVsLm9mZnNldFdpZHRoIC8gMikgLSAoZGQub2Zmc2V0V2lkdGggLyAyKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZuID0ge1xuICAgICAgICAgIGluaXRpYWw6ICgpID0+IHtcbiAgICAgICAgICAgIGRkLnN0eWxlLnRvcCA9IGAke3BvcyhhcmdzWzBdKS50b3B9cHhgXG4gICAgICAgICAgICBkZC5zdHlsZS5sZWZ0ID0gYCR7cG9zKGFyZ3NbMF0pLmxlZnR9cHhgXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoaWRlOiAoKSA9PiB7XG4gICAgICAgICAgICBkZC5zdHlsZS5vcGFjaXR5ID0gMFxuICAgICAgICAgICAgZGQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgYXJncy5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNob3c6IChlbCkgPT4ge1xuICAgICAgICAgICAgYXJncy5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKSlcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoSVNfQUNUSVZFKVxuICAgICAgICAgICAgZGQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgIGRkLnN0eWxlLnRvcCA9IGAke3BvcyhlbCkudG9wfXB4YFxuICAgICAgICAgICAgZGQuc3R5bGUubGVmdCA9IGAke3BvcyhlbCkubGVmdH1weGBcbiAgICAgICAgICAgIGRkLnN0eWxlLm9wYWNpdHkgPSAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzd2l0Y2hDb250ZW50OiAoYXR0cikgPT4ge1xuICAgICAgICAgICAgY29udC5mb3JFYWNoKGVsID0+IGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZScpXG4gICAgICAgICAgICBjb250LmZpbHRlcihlbCA9PiBlbC5pZCA9PSBgZGRfJHthdHRyfWApLmZvckVhY2goZWwgPT4gZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaycpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBpbml0aWFsOiBzZXRJbml0aWFsLCBoaWRlOiBoaWRlLCBzaG93OiBzaG93LCBzd2l0Y2hDb250ZW50OiBzd2l0Y2hDb250ZW50IH0gPSBmblxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViTGluay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGVsID0gc3ViTGlua1tpXSxcbiAgICAgICAgICAgIGNvbnRlbnQgPSBlbC5xdWVyeVNlbGVjdG9yKCcubmF2LWRyb3BfX3N1YicpXG4gICAgICAgICAgZWwub25tb3VzZW92ZXIgPSAoKSA9PiB7IGNvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jaycgfVxuICAgICAgICAgIGVsLm9ubW91c2VsZWF2ZSA9ICgpID0+IHsgY29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRkLm9ubW91c2VvdmVyID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoaGlkZURlbGF5VGltZSkgd2luZG93LmNsZWFyVGltZW91dChoaWRlRGVsYXlUaW1lKVxuICAgICAgICB9XG5cbiAgICAgICAgZGQub25tb3VzZWxlYXZlID0gKGUpID0+IHtcbiAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHNob3dEZWxheVRpbWUpXG4gICAgICAgICAgaGlkZURlbGF5VGltZSA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGhpZGUoKVxuICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGFyZ3MuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICBlbC5vbm1vdXNlb3ZlciA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gZWwuZGF0YXNldC5kcm9wZG93blxuICAgICAgICAgICAgaWYgKGF0dHIpIHtcbiAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChoaWRlRGVsYXlUaW1lKVxuICAgICAgICAgICAgICBzaG93RGVsYXlUaW1lID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaENvbnRlbnQoYXR0cilcbiAgICAgICAgICAgICAgICBzaG93KGVsKVxuICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsLm9ubW91c2VsZWF2ZSA9IChlKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHNob3dEZWxheVRpbWUpXG4gICAgICAgICAgICBoaWRlRGVsYXlUaW1lID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBoaWRlKClcbiAgICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHdpbmRvdy5vbnNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHNob3dEZWxheVRpbWUpXG4gICAgICAgICAgaGlkZSgpOyBzZXRJbml0aWFsKClcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEluaXRpYWwoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhlYWRlciIsImNvbnN0IGhlcm9TcGxpZGUgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5pbml0U3BsaWRlKClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVyci5tZXNzYWdlKVxuICAgIH1cbiAgfSxcbiAgaW5pdFNwbGlkZTogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGhlcm9TcGxpZGUgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmhlcm9fc3BsaWRlJyldXG4gICAgaWYgKGhlcm9TcGxpZGUubGVuZ3RoICE9PSAwKSB7XG4gICAgICBoZXJvU3BsaWRlLmZvckVhY2goKHNsaWRlKSA9PiB7XG4gICAgICAgIGxldCBzbGlkZXIgPSBuZXcgU3BsaWRlKHNsaWRlLCB7XG4gICAgICAgICAgdHlwZTogXCJzbGlkZXJcIixcbiAgICAgICAgICBwZXJQYWdlOiA0LFxuICAgICAgICAgIHBlck1vdmU6IDIsXG4gICAgICAgICAgYXV0b3BsYXk6IDAsXG4gICAgICAgICAgZ2FwOiBcIjEycHhcIixcbiAgICAgICAgICBhcnJvd3M6IDEsXG4gICAgICAgICAgcGFnaW5hdGlvbjogMCxcbiAgICAgICAgICBzcGVlZDogNzUwLFxuICAgICAgICAgIGJyZWFrcG9pbnRzOiB7XG4gICAgICAgICAgICA5OTE6IHsgcGVyUGFnZTogMi41LCB9LFxuICAgICAgICAgICAgNzY3OiB7IHBlclBhZ2U6IDIsIHBlck1vdmU6IDEgfSxcbiAgICAgICAgICAgIDQ3ODogeyBwZXJQYWdlOiAxLjQsIHBlck1vdmU6IDEsIGdhcDogOCB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBzbGlkZXIubW91bnQoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoZXJvU3BsaWRlIiwiY29uc3QgcGFnZUFsZXJ0cyA9IHtcbiAgY2xhc3Nlczoge1xuICAgIGZ1bGxXaWR0aDogJ3BhZ2UtYWxlcnRfYmFja2Ryb3AnLFxuICAgIGVycm9yOiAncGFnZS1hbGVydF9lcnJvcicsXG4gICAgd2FybmluZzogJ3BhZ2UtYWxlcnRfd2FybmluZycsXG4gICAgaW5mbzogJ3BhZ2UtYWxlcnRfaW5mbycsXG4gICAgdmlzaWJsZTogJ2lzLXZpc2libGUnXG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhY2hlRE9NKClcbiAgICB0aGlzLmJpbmRFdmVudHMoKVxuICAgIC8vIHRoaXMuZnVsbFdpZHRoKClcbiAgfSxcbiAgY2FjaGVET006IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbnRhaW5lciA9ICQoJy5wYWdlLWFsZXJ0JylcbiAgICB0aGlzLnRpdGxlID0gJCgnLnBhZ2UtYWxlcnQtdGl0bGUnKVxuICAgIHRoaXMuc3VidGl0bGUgPSAkKCcucGFnZS1hbGVydC10ZXh0JylcbiAgICB0aGlzLmNsb3NlID0gJCgnW2RhdGEtZXZ0PVwiaGlkZVBhZ2VBbGVydFwiXScpXG4gIH0sXG4gIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsb3NlLmNsaWNrKHRoaXMuaGlkZUFsZXJ0LmJpbmQodGhpcykpXG4gICAgY2xlYXJUaW1lb3V0KGFsZXJ0VGltZXIpXG4gIH0sXG4gIGZ1bGxXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKHRoaXMuY2xhc3Nlcy5mdWxsV2lkdGgpXG4gIH0sXG4gIHNob3dBbGVydDogZnVuY3Rpb24gKGVycm9yVHlwZSA9IGZ1bmN0aW9uICgpIHsgcGFnZUFsZXJ0cy5yZXNldEFsZXJ0KCkgfSwgdGl0bGUsIHRleHQsIGhpZGVUaW1lID0gMjUwMCkge1xuICAgIGNsZWFyVGltZW91dChhbGVydFRpbWVyKVxuICAgIHRoaXMucmVzZXRBbGVydCgpO1xuXG4gICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLnZpc2libGUpLmFkZENsYXNzKGVycm9yVHlwZSlcbiAgICB0aGlzLmNoYW5nZU1zZyh0aXRsZSwgdGV4dClcbiAgICBhbGVydFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcGFnZUFsZXJ0cy5oaWRlQWxlcnQoKVxuICAgIH0sIGhpZGVUaW1lKVxuICB9LFxuICBoaWRlQWxlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLmNsYXNzZXMudmlzaWJsZSlcbiAgfSxcbiAgY2hhbmdlTXNnOiBmdW5jdGlvbiAodGl0bGUsIHRleHQpIHtcbiAgICB0aGlzLnRpdGxlLmh0bWwodGl0bGUpXG4gICAgdGhpcy5zdWJ0aXRsZS5odG1sKHRleHQpXG4gIH0sXG4gIHJlc2V0QWxlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgaSA9IHBhZ2VBbGVydHMuY2xhc3Nlc1xuICAgICAgcmV0dXJuIGAke2kud2FybmluZ30gJHtpLmluZm99ICR7aS5lcnJvcn1gXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhZ2VBbGVydHMiLCJjb25zdCBwYWdlRWxzID0gbmV3IE9iamVjdCh7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuYXR0YWNoRXZlbnQpLmZvckVhY2goKHRhcmdldCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0YXJnZXQoKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIGF0dGFjaEV2ZW50OiB7XG4gICAgZmlsdGVyRHJvcGRvd246ICgpID0+IHtcbiAgICAgIGxldCBkcm9wZG93bkVscyA9IEFycmF5LmZyb20oJCgnLmZpbHRlci1kcm9wZG93bicpKVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyb3Bkb3duRWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZHJvcGRvd25FbHNbaV07XG4gICAgICAgICQoZWwpLmhvdmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsZXQgdGhpc0N1cnJlbnQgPSAkKHRoaXMpLmZpbmQoJy5maWx0ZXItZHJvcGRvd25fX2N1cnJlbnQnKSxcbiAgICAgICAgICAgIGxpc3QgPSAkKHRoaXMpLmZpbmQoJy5maWx0ZXItZHJvcGRvd25fX2xpc3QnKSxcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lciA9IGxpc3QuZmluZCgnPiBkaXYnKSxcbiAgICAgICAgICAgIGJ1dHRvbnMgPSBBcnJheS5mcm9tKHNjcm9sbENvbnRhaW5lci5maW5kKCc+IGRpdicpKSxcbiAgICAgICAgICAgIG1haW4gPSAkKHRoaXMpLmZpbmQoJy5maWx0ZXItZHJvcGRvd25fX21haW4nKVxuXG4gICAgICAgICAgY29uc3Qgc2Nyb2xsSCA9IHNjcm9sbENvbnRhaW5lclswXS5zY3JvbGxIZWlnaHRcblxuICAgICAgICAgIGlmIChsaXN0LmhlaWdodCgpID09IDApIHtcbiAgICAgICAgICAgIGxpc3QuY3NzKHsgaGVpZ2h0OiBgJHtzY3JvbGxIfXB4YCB9KVxuICAgICAgICAgICAgbWFpbi5hZGRDbGFzcyhJU19BQ1RJVkUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3QuY3NzKHsgaGVpZ2h0OiAnMHB4JyB9KVxuICAgICAgICAgICAgbWFpbi5yZW1vdmVDbGFzcyhJU19BQ1RJVkUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJC5lYWNoKGJ1dHRvbnMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICBidXR0b25zW2ldLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBzaWJzID0gJChidXR0b25zW2ldKS5zaWJsaW5ncygpXG4gICAgICAgICAgICAgIHNpYnMucmVtb3ZlQ2xhc3MoSVNfQUNUSVZFKVxuICAgICAgICAgICAgICBidXR0b25zW2ldLmNsYXNzTGlzdC5hZGQoSVNfQUNUSVZFKVxuXG4gICAgICAgICAgICAgIGxldCB2YWwgPSAkKGJ1dHRvbnNbaV0pLmh0bWwoKVxuICAgICAgICAgICAgICB0aGlzQ3VycmVudC5odG1sKHZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgdHJhY2tpbmdEYXRlVXBkYXRlOiAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRlcyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10cmFjaz1cInVwZGF0ZWRfZGF0ZVwiXScpXVxuICAgICAgY29uc3Qgbm93RGF0ZSA9IG5ldyBEYXRlKClcblxuICAgICAgaWYgKGRhdGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBkYXkgPSBub3dEYXRlLmdldERhdGUoKVxuICAgICAgICBjb25zdCBtb250aCA9IG5vd0RhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHsgbW9udGg6ICdzaG9ydCcgfSlcbiAgICAgICAgY29uc3QgeWVhciA9IG5vd0RhdGUuZ2V0RnVsbFllYXIoKVxuICAgICAgICBsZXQgaG91cnMgPSBub3dEYXRlLmdldEhvdXJzKClcbiAgICAgICAgY29uc3QgbWludXRlcyA9IG5vd0RhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKVxuICAgICAgICBjb25zdCBhbXBtID0gaG91cnMgPj0gMTIgPyAnUE0nIDogJ0FNJ1xuICAgICAgICBob3VycyA9IGhvdXJzICUgMTIgfHwgMTJcblxuICAgICAgICBmb3IgKGNvbnN0IGRhdGUgb2YgZGF0ZXMpIHtcbiAgICAgICAgICBkYXRlLmlubmVySFRNTCA9IGAke2RheX0gJHttb250aH0sICR7eWVhcn0sICR7aG91cnN9OiR7bWludXRlc30gJHthbXBtfWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcGFnZUZpbHRlcnM6ICgpID0+IHtcbiAgICAgIGxldCBmaWx0ZXJSb3dzID0gQXJyYXkuZnJvbSgkKCcuZmlsdGVyLXJvdycpKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsID0gJChmaWx0ZXJSb3dzW2ldKSxcbiAgICAgICAgICBoZWFkZXIgPSBlbC5maW5kKCcuZmlsdGVyLXJvd19faGVhZGVyJyksXG4gICAgICAgICAgYm9keSA9IGVsLmZpbmQoJy5maWx0ZXItcm93X19ib2R5JyksXG4gICAgICAgICAgY29udGFpbmVyID0gZWwuZmluZCgnLmZpbHRlci1yb3dfX2NvbnRhaW5lcicpLFxuICAgICAgICAgIGljb24gPSBoZWFkZXIuZmluZCgnc3ZnJylcblxuICAgICAgICBoZWFkZXIuY2xpY2soKCkgPT4ge1xuICAgICAgICAgIGxldCBjdXJyZW50Qm9keUhlaWdodCA9IGJvZHkuaGVpZ2h0KClcbiAgICAgICAgICBpZiAoY3VycmVudEJvZHlIZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIGJvZHkuY3NzKHsgaGVpZ2h0OiBgJHtjdXJyZW50Qm9keUhlaWdodH1weGAgfSlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBib2R5LmNzcyh7IGhlaWdodDogMCB9KVxuICAgICAgICAgICAgICBjb250YWluZXIuY3NzKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtMjRweCknLCBvcGFjaXR5OiAwIH0pXG4gICAgICAgICAgICAgIGljb24uY3NzKHsgdHJhbnNmb3JtOiAncm90YXRlKDBkZWcpJyB9KVxuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGxIID0gY29udGFpbmVyWzBdLnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgYm9keS5jc3MoeyBoZWlnaHQ6IHNjcm9sbEggfSlcbiAgICAgICAgICAgIGNvbnRhaW5lci5jc3MoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDBweCknLCBvcGFjaXR5OiAxIH0pXG4gICAgICAgICAgICBpY29uLmNzcyh7IHRyYW5zZm9ybTogJ3JvdGF0ZSgxODBkZWcpJyB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGZhcUxpc3RzOiAoKSA9PiB7XG4gICAgICBjb25zdCBoZWFkQXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mYXEtaGVhZCcpXVxuICAgICAgbGV0IGxpQXJyID0gW11cbiAgICAgIGZvciAoY29uc3QgZmFxSGVhZCBvZiBoZWFkQXJyKSB7XG4gICAgICAgIGNvbnN0IGxpID0gZmFxSGVhZC5jbG9zZXN0KCdsaScpXG4gICAgICAgIGNvbnN0IGJvZHkgPSBmYXFIZWFkLm5leHRFbGVtZW50U2libGluZ1xuICAgICAgICBpZiAobGkgJiYgYm9keSkge1xuICAgICAgICAgIGxpQXJyLnB1c2gobGkpXG4gICAgICAgICAgbGkuc2hvdyA9ICgpID0+IHtcbiAgICAgICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoX19BQ1RJVkUpXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBib2R5LnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgYm9keS5zdHlsZS5oZWlnaHQgPSBgJHtzY3JvbGxIZWlnaHR9cHhgXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgYm9keS5zdHlsZS5oZWlnaHQgPSAnYXV0bydcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaS5oaWRlID0gKCkgPT4ge1xuICAgICAgICAgICAgbGkuY2xhc3NMaXN0LnJlbW92ZShfX0FDVElWRSlcbiAgICAgICAgICAgIGJvZHkuc3R5bGUuaGVpZ2h0ID0gMFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZhcUhlYWQub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGJvZHkpXG4gICAgICAgICAgICBpZiAoYm9keS5vZmZzZXRIZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgICAgbGkuaGlkZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsaS5zaG93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gbGV0dGVyc1xuICAgICAgICAgIGNvbnN0IGg2ID0gZmFxSGVhZC5xdWVyeVNlbGVjdG9yKCdoNicpXG4gICAgICAgICAgaWYgKGg2KSB7XG4gICAgICAgICAgICBjb25zdCBjYXBpdGFsaXplZCA9IGg2LnRleHRDb250ZW50LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvKFxcYikoXFx3KS9nLCAobWF0Y2gsIHAxLCBwMikgPT4gcDIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIGg2LnRleHRDb250ZW50ID0gY2FwaXRhbGl6ZWRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXZlYWwgZmlyc3RcbiAgICAgICAgICBpZiAobGlBcnJbMF0gPT09IGxpKSBsaS5zaG93KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbGlzdGluZ3M6ICgpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RpbmdzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5saXN0aW5nLXNldCcpXVxuICAgICAgZm9yIChjb25zdCBsaXN0aW5nIG9mIGxpc3RpbmdzKSB7XG4gICAgICAgIGNvbnN0IGJ1dHRvbkFycmF5ID0gWy4uLmxpc3RpbmcucXVlcnlTZWxlY3RvckFsbCgnLmxpc3RpbmctYnRuOm5vdCguLS1kaXNhYmxlZCknKV1cbiAgICAgICAgYnV0dG9uQXJyYXkuZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgYnRuLmNsYXNzTGlzdC5hZGQoSVNfQUNUSVZFKVxuICAgICAgICAgICAgYnV0dG9uQXJyYXkuZm9yRWFjaCgoYXJyQnRuKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChhcnJCdG4gIT0gYnRuKSBhcnJCdG4uY2xhc3NMaXN0LnJlbW92ZShJU19BQ1RJVkUpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVaZXJvU3ViaGVhZGluZzogKCkgPT4ge1xuICAgICAgY29uc3QgYXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5yZXN1bHRzX19zdWJoZWFkaW5nJyldXG4gICAgICBmb3IgKGNvbnN0IHN1YmhlYWRpbmcgb2YgYXJyKSB7XG4gICAgICAgIGlmIChzdWJoZWFkaW5nLmlubmVySFRNTC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgc3ViaGVhZGluZy5yZW1vdmUoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0VGVsSW5wdXQ6ICgpID0+IHtcbiAgICAgIGxldCB0ZWxJbnB1dEFyciA9IEFycmF5LmZyb20oJCgnW2RhdGEtaW5wdXQ9XCJ0ZWxcIl0nKSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVsSW5wdXRBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRpID0gaW50bFRlbElucHV0KHRlbElucHV0QXJyW2ldLCB7XG4gICAgICAgICAgaW5pdGlhbENvdW50cnk6IFwiYXV0b1wiLFxuICAgICAgICAgIHByZWZlcnJlZENvdW50cmllczogW1widXNcIiwgXCJnYlwiLCBcImJyXCIsIFwiY25cIiwgXCJlc1wiLCBcIml0XCJdLFxuICAgICAgICAgIGF1dG9QbGFjZWhvbGRlcjogXCJhZ2dyZXNzaXZlXCIsXG4gICAgICAgICAgdXNlRnVsbHNjcmVlblBvcHVwOiB0cnVlLFxuICAgICAgICAgIHV0aWxzU2NyaXB0OlxuICAgICAgICAgICAgXCIvYXNzZXRzL3B1YmxpYy0yMDIwL2pzL3BsdWdpbnMvcGhvbmUvdXRpbHMuanNcIixcbiAgICAgICAgICBnZW9JcExvb2t1cDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBmZXRjaChcImh0dHBzOi8vaXBpbmZvLmlvL2pzb25cIiwge1xuICAgICAgICAgICAgICBjYWNoZTogXCJyZWxvYWRcIixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkOiBcIiArIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC50aGVuKChpcGpzb24pID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpcGpzb24uY291bnRyeSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwidXNcIik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5pdEN1c3RvbVVwbG9hZHM6ICgpID0+IHtcbiAgICAgIHRoaXMuYXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWN1c3RvbS11cGxvYWRdJyldXG5cbiAgICAgIGNvbnN0IHJlbmRlck91dHB1dEZpbGUgPSAoZmlsZSwgaW1nU3JjID0gJycpID0+IHtcbiAgICAgICAgbGV0IGltZ0VsZW0gPSBpbWdTcmMgPyBgPGRpdiBjbGFzcz1cIi0tZmlsbGVkXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJHtpbWdTcmN9KVwiPjwvZGl2PmAgOiBgPGRpdj48L2Rpdj5gXG4gICAgICAgIHJldHVybiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjdXN0b20tdXBsb2FkX19maWxlXCI+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICR7aW1nRWxlbX1cbiAgICAgICAgICAgIDxzcGFuIGRhdGEtY3VzdG9tLW5hbWU+JHtmaWxlLm5hbWV9PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtZXZ0PVwiY3VzdG9tX3VwbG9hZF9yZW1vdmVcIiBjbGFzcz1cIi0tcmVtb3ZlXCI+PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICBgXG4gICAgICB9XG4gICAgICBjb25zdCBiaW5kQm94RXZlbnRzID0gKGJveCwgaW5wdXQpID0+IHtcbiAgICAgICAgYm94Lm9uZHJhZ292ZXIgPSAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgYm94LmNsYXNzTGlzdC5hZGQoX19BQ1RJVkUpXG4gICAgICAgIH1cbiAgICAgICAgYm94Lm9uZHJhZ2xlYXZlID0gKGUpID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IGJveC5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgICAgICB9XG4gICAgICAgIGJveC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgKGUpID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICBib3guY2xhc3NMaXN0LnJlbW92ZShfX0FDVElWRSlcbiAgICAgICAgICBjb25zdCBmaWxlcyA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzXG4gICAgICAgICAgY29uc3QgbmV3RGF0YVRyYW5zZmVyID0gbmV3IERhdGFUcmFuc2ZlcigpXG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgIG5ld0RhdGFUcmFuc2Zlci5pdGVtcy5hZGQoZmlsZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQuZmlsZXMgPSBuZXdEYXRhVHJhbnNmZXIuZmlsZXNcbiAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyAnYnViYmxlcyc6IHRydWUgfSkpXG4gICAgICAgIH0pXG4gICAgICAgIGJveC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgaW5wdXQuY2xpY2soKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgY29uc3Qgc2V0SW5kZXhlcyA9ICh1cGxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSBbLi4udXBsb2FkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jdXN0b20tdXBsb2FkX19maWxlJyldXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmaWxlc1tpXS5kYXRhc2V0LmN1c3RvbUluZGV4ID0gaVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9jZXNzRmlsZXMgPSAoZmlsZXMsIHVwbG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSB1cGxvYWQucXVlcnlTZWxlY3RvcignLmN1c3RvbS11cGxvYWRfX2ZpbGVzJylcbiAgICAgICAgY29uc3QgY3VycmVudEZpbGVzID0gWy4uLnVwbG9hZC5xdWVyeVNlbGVjdG9yQWxsKCcuY3VzdG9tLXVwbG9hZF9fZmlsZScpXVxuXG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBjdXJyZW50RmlsZXMpIHtcbiAgICAgICAgICBmaWxlLnJlbW92ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICBjb25zdCBmaWxlSXNJbWFnZSA9IGZpbGUudHlwZS5tYXRjaCgnaW1hZ2UuKicpXG4gICAgICAgICAgaWYgKGZpbGVJc0ltYWdlKSB7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICAgICAgICAgIG91dHB1dC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIHJlbmRlck91dHB1dEZpbGUoZmlsZSwgZS50YXJnZXQucmVzdWx0KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIHJlbmRlck91dHB1dEZpbGUoZmlsZSkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldEluZGV4ZXModXBsb2FkKVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHVwbG9hZCBvZiB0aGlzLmFycikge1xuICAgICAgICBjb25zdCBib3ggPSB1cGxvYWQucXVlcnlTZWxlY3RvcignLmN1c3RvbS11cGxvYWRfX2JveCcpXG4gICAgICAgIGNvbnN0IGlucHV0ID0gdXBsb2FkLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JylcblxuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgYmluZEJveEV2ZW50cyhib3gsIGlucHV0KVxuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlcyA9IGUudGFyZ2V0LmZpbGVzXG4gICAgICAgICAgcHJvY2Vzc0ZpbGVzKGZpbGVzLCB1cGxvYWQpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXRcbiAgICAgICAgaWYgKGUudGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWV2dD1cImN1c3RvbV91cGxvYWRfcmVtb3ZlXCJdJykpIHtcbiAgICAgICAgICBjb25zdCB1cGxvYWQgPSB0YXJnZXQuY2xvc2VzdCgnW2RhdGEtY3VzdG9tLXVwbG9hZF0nKVxuICAgICAgICAgIGlmICghdXBsb2FkKSB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEtY3VzdG9tLXVwbG9hZCBub3QgZm91bmQnKVxuICAgICAgICAgIGNvbnN0IGlucHV0ID0gdXBsb2FkLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJylcbiAgICAgICAgICBpZiAoIWlucHV0KSB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0W3R5cGU9XCJmaWxlXCJdIG5vdCBmb3VuZCcpXG4gICAgICAgICAgY29uc3QgbmFtZUVsID0gZS50YXJnZXQuY2xvc2VzdCgnLmN1c3RvbS11cGxvYWRfX2ZpbGUnKS5xdWVyeVNlbGVjdG9yKCcqW2RhdGEtY3VzdG9tLW5hbWVdJylcbiAgICAgICAgICBpZiAoIW5hbWVFbCkgdGhyb3cgbmV3IEVycm9yKCdkYXRhLWN1c3RvbS1uYW1lIG5vdCBmb3VuZCcpXG5cbiAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZUVsLmlubmVySFRNTFxuICAgICAgICAgIGNvbnN0IG5ld0RhdGFUcmFuc2ZlciA9IG5ldyBEYXRhVHJhbnNmZXIoKVxuICAgICAgICAgIGNvbnN0IHsgZmlsZXMgfSA9IGlucHV0XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZmlsZXNbaV0ubmFtZSAhPT0gbmFtZSkge1xuICAgICAgICAgICAgICBuZXdEYXRhVHJhbnNmZXIuaXRlbXMuYWRkKGZpbGVzW2ldKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXdEYXRhVHJhbnNmZXIuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0LmZpbGVzID0gbmV3RGF0YVRyYW5zZmVyLmZpbGVzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScsIHsgJ2J1YmJsZXMnOiB0cnVlIH0pKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgYXR0YWNoUGF5TW9kYWw6ICgpID0+IHtcbiAgICAgIGxldCBldnRPcGVuTGF0ZXIgPSAkKCdbZGF0YS1ldnQ9XCJwYXlNb2RhbExhdGVyXCJdJyksXG4gICAgICAgIGV2dE9wZW5DcnlwdG8gPSAkKCdbZGF0YS1ldnQ9XCJwYXlNb2RhbENyeXB0b1wiXScpLFxuICAgICAgICBldnRDbG9zZSA9ICQoJ1tkYXRhLWV2dD1cImNsb3NlUGF5TW9kYWxcIl0nKSxcbiAgICAgICAgY3J5cHRvID0gJCgnI3BheU1vZGFsQ3J5cHRvJyksXG4gICAgICAgIGxhdGVyID0gJCgnI3BheU1vZGFsTGF0ZXInKSxcbiAgICAgICAgbW9kYWwgPSAkKCcucGF5LW1vZGFsJylcblxuICAgICAgY29uc3Qgb3Blbk1vZGFsID0gKCkgPT4ge1xuICAgICAgICBsb2NrU2Nyb2xsKClcbiAgICAgICAgbW9kYWwuc2hvdygpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIG1vZGFsLmNzcyh7IG9wYWNpdHk6IDEgfSlcbiAgICAgICAgfSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNsb3NlTW9kYWwgPSAoKSA9PiB7XG4gICAgICAgIHVubG9ja1Njcm9sbCgpXG4gICAgICAgIG1vZGFsLmNzcyh7IG9wYWNpdHk6IDAgfSlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgbW9kYWwuaGlkZSgpXG4gICAgICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKG1vZGFsKSk7XG4gICAgICB9XG5cbiAgICAgIGV2dE9wZW5MYXRlci5hZGQoZXZ0T3BlbkNyeXB0bykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBvcGVuTW9kYWwoKVxuICAgICAgICBjcnlwdG8uYWRkKGxhdGVyKS5oaWRlKClcbiAgICAgICAgaWYgKCQodGhpcykuaXMoZXZ0T3BlbkNyeXB0bykpIHtcbiAgICAgICAgICBjcnlwdG8uc2hvdygpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQodGhpcykuaXMoZXZ0T3BlbkxhdGVyKSkge1xuICAgICAgICAgIGxhdGVyLnNob3coKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBldnRDbG9zZS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsb3NlTW9kYWwoKVxuICAgICAgfSlcbiAgICB9LFxuICAgIGF0dGFjaFRvZ2dsZUlucHV0czogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgYXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWlucHV0LXRvZ2dsZV0nKV1cbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgYXJyKSB7XG4gICAgICAgIGNvbnN0IGJ0biA9IGlucHV0LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcignYnV0dG9uJykgfHwgaW5wdXQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwic3VibWl0XCJdJylcbiAgICAgICAgaWYgKGJ0bikge1xuICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGJ0bi5kaXNhYmxlZCA9IGZhbHNlXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnRuLmRpc2FibGVkID0gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5SXNFbnRlciA9IGUua2V5ID09PSAnRW50ZXInXG4gICAgICAgICAgICBpZiAoa2V5SXNFbnRlcikge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgYnRuLmNsaWNrKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZVxuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSAnJ1xuICAgICAgICAgICAgaW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JykpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaW5pdFByb2R1Y3Rab29tOiAoKSA9PiB7XG4gICAgICBjb25zdCBpc0Rlc2t0b3AgPSB3aW5kb3cuaW5uZXJXaWR0aCA+IDk5MVxuICAgICAgd2luZG93LnJlbW92ZVNsaWRlciA9ICh0YXJnZXQpID0+IHtcbiAgICAgICAgdW5sb2NrU2Nyb2xsKClcbiAgICAgICAgY29uc3Qgc2xpZGVyID0gdGFyZ2V0LmNsb3Nlc3QoJy56b29tX3NsaWRlcicpOyBzbGlkZXIuY3NzKHsgb3BhY2l0eTogMCB9KVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgc2xpZGVyLmhpZGUoKSB9LCA0MDApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXREZXNrdG9wWm9vbSA9ICgpID0+IHtcbiAgICAgICAgWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcm9kdWN0LW1lZGlhLWltZycpXS5yZWR1Y2UoKGFjYywgZWwpID0+IHtcbiAgICAgICAgICBpZiAoZWwgJiYgZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghLyhwbGFjZWhvbGRlcnxzdG9yZXxwYXkpL2dpLnRlc3QoZWwuZ2V0QXR0cmlidXRlKCdzcmMnKSkpIHtcbiAgICAgICAgICAgICAgYWNjLnB1c2goJChlbCkucGFyZW50KCcucHJvZHVjdC1tZWRpYV9faW5uZXItd3JhcCcpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgIH0sIFtdKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgICQoZWwpLnpvb20oeyBtYWduaWZ5OiAxLjksIG9uOiAnY2xpY2snIH0pXG4gICAgICAgICAgJChlbCkub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7ICQoZG9jdW1lbnQpLnRyaWdnZXIoJ2NsaWNrJykgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2V0TW9iaWxlWm9vbSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2xpZGVycyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucHJvZHVjdC1zbGlkZXInKV0gLy8gR2V0IGFsbCBleGlzdGluZyBzbGlkZXJzXG5cbiAgICAgICAgc2xpZGVycy5mb3JFYWNoKChzbGlkZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgYnV0dG9uID0gJCgnPGJ1dHRvbi8+JywgeyBjbGFzczogYHByb2R1Y3RfX3pvb20tYnRuIHpvb21fYnRuJHtpbmRleH1gIH0pOyBidXR0b24uYXBwZW5kVG8oJChzbGlkZXIpKSAvLyBDcmVhdGUgJiBhcHBlbmQgem9vbSBidXR0b25cbiAgICAgICAgICBjb25zdCByZW5kZXJOZXdTbGlkZXIgPSAoc2xpZGVyLCBpbmRleCkgPT4geyAvLyBHZXQgSFRNTCBuZXcgem9vbSBzbGlkZXJcbiAgICAgICAgICAgIGxldCBtZWRpYUFyciA9IFsuLi5zbGlkZXIucXVlcnlTZWxlY3RvckFsbCgnaW1nJyldLnJlZHVjZSgoYWNjLCBpbWcpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc3JjID0gaW1nLmdldEF0dHJpYnV0ZSgnc3JjJylcbiAgICAgICAgICAgICAgaWYgKCFhY2MuaW5jbHVkZXMoc3JjKSAmJiAhLyhwbGFjZWhvbGRlcnxzdG9yZXxwYXkpL2dpLnRlc3Qoc3JjKSkgeyBhY2MucHVzaChzcmMpIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgICAgICAgfSwgW10pLnNvcnQoKVxuXG4gICAgICAgICAgICB0aGlzLnJlbmRlck1lZGlhID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gbWVkaWFBcnIucmVkdWNlKChhY2MsIHNyYykgPT4ge1xuICAgICAgICAgICAgICAgIGFjYyArPSBgPGRpdiBjbGFzcz1cInNwbGlkZV9fc2xpZGVcIj48aW1nIHNyYz1cIiR7c3JjfVwiPjwvZGl2PmBcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgICAgICAgIH0sICcnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInpvb21fc2xpZGVyIHpzbCR7aW5kZXh9XCI+XG4gICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInpvb21fc2xpZGVyX2xvZ29cIj48aW1nIHNyYz1cIiR7U3RyaW5nLnJhd2BcXHRoZW1lc1xcZGVmYXVsdFxcZnJvbnRlbmRcXG9jdC0yMDIzL2Fzc2V0cy9sb2dvLnN2Z2B9XCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInpvb21fc2xpZGVyLWNsb3NlXCIgb25jbGljaz1cInJlbW92ZVNsaWRlcigkKHRoaXMpKVwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ6b29tLXNsJHtpbmRleH0gc3BsaWRlXCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BsaWRlX190cmFja1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BsaWRlX19saXN0XCI+XG4gICAgICAgICAgICAgICAgICAgICR7dGhpcy5yZW5kZXJNZWRpYSgpfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwbGlkZV9fYXJyb3dzXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGxpZGVfX2Fycm93LS1wcmV2XCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGxpZGVfX2Fycm93LS1uZXh0XCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5gXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFwcGVuZE5ld1NsaWRlciA9IChodG1sKSA9PiB7ICRib2R5LmFwcGVuZChodG1sKSB9IC8vIEFwcGVuZCBab29tIFNsaWRlclxuICAgICAgICAgIGNvbnN0IGluaXROZXdTbGlkZXIgPSAoaW5kZXgpID0+IHsgLy8gU3BsaWRlIEluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImxvb3BcIixcbiAgICAgICAgICAgICAgcGVyUGFnZTogMSxcbiAgICAgICAgICAgICAgcGVyTW92ZTogMSxcbiAgICAgICAgICAgICAgYXV0b3BsYXk6IDAsXG4gICAgICAgICAgICAgIGdhcDogXCIxMnB4XCIsXG4gICAgICAgICAgICAgIGFycm93czogMSxcbiAgICAgICAgICAgICAgcGFnaW5hdGlvbjogMCxcbiAgICAgICAgICAgICAgc3BlZWQ6IDgwMCxcbiAgICAgICAgICAgICAgZHJhZzogZmFsc2UsXG4gICAgICAgICAgICAgIGRyYWdBbmdsZVRocmVzaG9sZDogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgem9vbVNsaWRlciA9IG5ldyBTcGxpZGUoYC56b29tLXNsJHtpbmRleH1gLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgIHpvb21TbGlkZXIubW91bnQoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbml0Wm9vbSA9IChpbmRleCkgPT4geyAvLyBJbml0aWFsaXplIGpRdWVyeSB6b29tIGZvciB0aGUgbmV3IHNsaWRlclxuICAgICAgICAgICAgbGV0IHNsaWRlcyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuem9vbV9zbGlkZXIuenNsJHtpbmRleH1gKS5xdWVyeVNlbGVjdG9yQWxsKCcuc3BsaWRlX19zbGlkZScpXVxuICAgICAgICAgICAgc2xpZGVzLmZvckVhY2goKHNsaWRlKSA9PiB7XG4gICAgICAgICAgICAgICQoc2xpZGUpLnpvb20oe1xuICAgICAgICAgICAgICAgIG1hZ25pZnk6IDEuNCxcbiAgICAgICAgICAgICAgICBvblpvb21JbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCcuc3BsaWRlJykuY3NzKCdib3JkZXItY29sb3InLCAnI2U2ZWFlYycpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblpvb21PdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnLnNwbGlkZScpLmNzcygnYm9yZGVyLWNvbG9yJywgJyMwMDk1YzYnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNob3dOZXdTbGlkZXIgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBsb2NhbFNsaWRlciA9ICQoYC56b29tX3NsaWRlci56c2wke2luZGV4fWApXG4gICAgICAgICAgICBpZiAobG9jYWxTbGlkZXIpIHsgbG9jYWxTbGlkZXIuc2hvdygpOyBsb2NrU2Nyb2xsKCk7IHNldFRpbWVvdXQoKCkgPT4geyBsb2NhbFNsaWRlci5jc3MoeyBvcGFjaXR5OiAxIH0pIH0sIDEpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9wZW5TbGlkZXIgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBzbGlkZXIgPSAkKGAuem9vbV9zbGlkZXIuenNsJHtpbmRleH1gKVxuICAgICAgICAgICAgaWYgKHNsaWRlcikgeyBzbGlkZXIuc2hvdygpOyBsb2NrU2Nyb2xsKCk7IHNldFRpbWVvdXQoKCkgPT4geyBzbGlkZXIuY3NzKHsgb3BhY2l0eTogMSB9KSB9LCAxKTsgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJ1dHRvbi5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNsaWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYC56b29tX3NsaWRlci56c2wke2luZGV4fWApXG4gICAgICAgICAgICBpZiAoIWxvY2FsU2xpZGVyKSB7XG4gICAgICAgICAgICAgIGFwcGVuZE5ld1NsaWRlcihyZW5kZXJOZXdTbGlkZXIoc2xpZGVyLCBpbmRleCkpXG4gICAgICAgICAgICAgIGluaXROZXdTbGlkZXIoaW5kZXgpXG4gICAgICAgICAgICAgIGluaXRab29tKGluZGV4KVxuICAgICAgICAgICAgICBzaG93TmV3U2xpZGVyKGluZGV4KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3BlblNsaWRlcihpbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXRab29tID0gKCkgPT4ge1xuICAgICAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluX3Byb2R1Y3Rfem9vbScpID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpc0Rlc2t0b3AgJiYgJCgnLm1haW5fcHJvZHVjdCcpLmxlbmd0aCkgeyBzZXREZXNrdG9wWm9vbSgpIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldE1vYmlsZVpvb20oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldFpvb20oKVxuICAgIH0sXG4gICAgaW5pdFRlc3RQcm9kdWN0Wm9vbTogKCkgPT4ge1xuICAgICAgbGV0IHpvb21PcGVuQ291bnQgPSAwXG5cbiAgICAgIGNvbnN0IHNldFpvb20gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgc3JjSXNWYWxpZCA9IChzcmMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhLyhwbGFjZWhvbGRlcnxzdG9yZXxwYXkpL2dpLnRlc3Qoc3JjKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlsdGVyTWVkaWEgPSAoYXJyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLnJlZHVjZSgoYWNjLCBtZWRpYSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIGltZyA9IG1lZGlhLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpLFxuICAgICAgICAgICAgICAgIHRodW1iQW5jZXN0b3IgPSBtZWRpYS5jbG9zZXN0KCcucHJvZHVjdC1zbGlkZXJfdGh1bWJuYWlscycpLFxuICAgICAgICAgICAgICAgIHpvb21BbmNlc3RvciA9IG1lZGlhLmNsb3Nlc3QoJy56b29tLW1vZGFsJylcblxuICAgICAgICAgICAgICBpZiAoaW1nICYmIGltZyAhPT0gbnVsbCAmJiB0aHVtYkFuY2VzdG9yID09IG51bGwgJiYgem9vbUFuY2VzdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSBpbWcuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICAgICAgICAgICAgICAgIGlmIChzcmNJc1ZhbGlkKHNyYykpIHsgYWNjLnB1c2gobWVkaWEpIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFNyY0FyciA9IChhcnIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKChhY2MsIG1lZGlhKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGltZyA9IG1lZGlhLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpXG4gICAgICAgICAgICAgIGlmIChpbWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1nLmhhc0F0dHJpYnV0ZSgnc3JjJykpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNyYyA9IGltZy5nZXRBdHRyaWJ1dGUoJ3NyYycpXG4gICAgICAgICAgICAgICAgICBpZiAoc3JjSXNWYWxpZChzcmMpICYmICFhY2MuaW5jbHVkZXMoc3JjKSkgeyBhY2MucHVzaChzcmMpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgICAgICAgfSwgW10pXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW5kZXJTbGlkZXNIVE1MID0gKHNyY0FycikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNyY0Fyci5yZWR1Y2UoKGFjYywgc3JjKSA9PiB7XG4gICAgICAgICAgICAgIGFjYyArPSBgPGRpdiBzdHlsZT1cImN1cnNvcjogem9vbS1pblwiIGNsYXNzPVwiem9vbS1tb2RhbF9fc2xpZGUgc3BsaWRlX19zbGlkZVwiPjxpbWcgbG9hZGluZz1cImVhZ2VyXCIgYWx0PVwiXCIgc3JjPVwiJHtzcmN9XCI+PC9kaXY+YFxuICAgICAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgICAgICB9LCAnJylcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbmRlclNwbGlkZUhUTUwgPSAoc2xpZGVzSFRNTCkgPT4ge1xuICAgICAgICAgICAgbGV0IHByb2R1Y3RUaXRsZSA9ICQoJy5wcm9kdWN0X19pdGVtLXRpdGxlJykuaHRtbCgpLFxuICAgICAgICAgICAgICBwcmljZSA9ICQoJy5wcm9kdWN0X19pdGVtLXByaWNlJykuZXEoLTEpLmh0bWwoKVxuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiem9vbS1tb2RhbCBzcGxpZGVcIj5cbiAgICAgICAgICAgIDxidXR0b24gZGF0YS1ldnQ9XCJjbG9zZVpvb21Nb2RhbFwiIGNsYXNzPVwiem9vbS1tb2RhbF9fY2xvc2UtYnRuXCI+PC9idXR0b24+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiem9vbS1tb2RhbF9faG9sZGVyXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGxpZGVfX2Fycm93c1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGxpZGVfX2Fycm93LS1wcmV2XCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwbGlkZV9fYXJyb3ctLW5leHRcIj48L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ6b29tLW1vZGFsX19oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIiR7U3RyaW5nLnJhd2BcXHRoZW1lc1xcZGVmYXVsdFxcZnJvbnRlbmRcXG9jdC0yMDIzL2Fzc2V0cy9sb2dvLnN2Z2B9XCIgbG9hZGluZz1cImxhenlcIiBhbHQ9XCJcIj5cbiAgICAgICAgICAgICAgICA8aW1nIHN0eWxlPVwiZGlzcGxheTogbm9uZVwiIHNyYz1cIiR7U3RyaW5nLnJhd2AuL2Fzc2V0cy9sb2dvLnN2Z2B9XCIgbG9hZGluZz1cImxhenlcIiBhbHQ9XCJcIj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ6b29tLW1vZGFsX19mb290ZXJcIj5cbiAgICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJ6b29tLW1vZGFsX19uYW1lXCI+JHtwcm9kdWN0VGl0bGV9PC9oMT5cbiAgICAgICAgICAgICAgICA8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgZGF0YS1ldnQ9XCJjbG9zZVpvb21Nb2RhbFwiIGNsYXNzPVwiem9vbS1tb2RhbF9fYnV5LWJ0blwiIG9uY2xpY2s9XCJhZGRUb0NhcnQoKVwiPkFkZCBUbyBDYXJ0PHNwYW4+JHtwcmljZX0gVVNEPC9zcGFuPjwvYT5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ6b29tLW1vZGFsX19zbGlkZXJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BsaWRlX190cmFja1wiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwbGlkZV9fbGlzdFwiPlxuICAgICAgICAgICAgICAgICAgICAke3NsaWRlc0hUTUx9XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICBgXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbml0Wm9vbVNsaWRlciA9IChpbmRleFRvR28gPSAwKSA9PiB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImxvb3BcIixcbiAgICAgICAgICAgICAgICBwZXJQYWdlOiAxLFxuICAgICAgICAgICAgICAgIHBlck1vdmU6IDEsXG4gICAgICAgICAgICAgICAgYXV0b3BsYXk6IDAsXG4gICAgICAgICAgICAgICAgZ2FwOiBcIjEycHhcIixcbiAgICAgICAgICAgICAgICBhcnJvd3M6IDEsXG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvbjogMCxcbiAgICAgICAgICAgICAgICBzcGVlZDogODAwLFxuICAgICAgICAgICAgICAgIGRyYWc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRyYWdBbmdsZVRocmVzaG9sZDogMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzbGlkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuem9vbS1tb2RhbCcpXG4gICAgICAgICAgICBpZiAoc2xpZGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHpvb21TbGlkZXIgPSBuZXcgU3BsaWRlKCcuem9vbS1tb2RhbCcsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgem9vbVNsaWRlci5tb3VudCgpXG4gICAgICAgICAgICAgIHpvb21TbGlkZXIuZ28oaW5kZXhUb0dvKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5pdFByZXNzWm9vbSA9IChzbGlkZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlcyA9IFsuLi5zbGlkZXIucXVlcnlTZWxlY3RvckFsbCgnLnNwbGlkZV9fc2xpZGUnKV0sXG4gICAgICAgICAgICAgIHpvb21WYWx1ZSA9IHdpbmRvdy5pbm5lcldpZHRoID4gNDc5ID8gMi4yIDogMS42XG4gICAgICAgICAgICBzbGlkZXMuZm9yRWFjaCgoc2xpZGUpID0+IHtcbiAgICAgICAgICAgICAgJChzbGlkZSkuem9vbSh7XG4gICAgICAgICAgICAgICAgbWFnbmlmeTogem9vbVZhbHVlLFxuICAgICAgICAgICAgICAgIG9uOiAnZ3JhYicsXG4gICAgICAgICAgICAgICAgb25ab29tSW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICQoJy56b29tLW1vZGFsIC5zcGxpZGVfX2Fycm93cycpLmNzcyh7IG9wYWNpdHk6IDAgfSlcbiAgICAgICAgICAgICAgICAgICQoJy56b29tLWhpbnQnKS5jc3MoeyBvcGFjaXR5OiAwIH0pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblpvb21PdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICQoJy56b29tLW1vZGFsIC5zcGxpZGVfX2Fycm93cycpLmNzcyh7IG9wYWNpdHk6IDEgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZWRpYUFyciA9IGZpbHRlck1lZGlhKFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucHJvZHVjdC1tZWRpYScpXSlcblxuICAgICAgICBtZWRpYUFyci5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgIGVsLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2NrU2Nyb2xsKClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgc2liU3JjQXJyID0gZ2V0U3JjQXJyKGZpbHRlck1lZGlhKFsuLi5lbC5wYXJlbnROb2RlLmNsb3Nlc3QoJ2RpdicpLnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcm9kdWN0LW1lZGlhJyldKSksXG4gICAgICAgICAgICAgICAgc3BsaWRlSFRNTCA9IHJlbmRlclNwbGlkZUhUTUwocmVuZGVyU2xpZGVzSFRNTChzaWJTcmNBcnIpKVxuXG4gICAgICAgICAgICAgICRib2R5LmFwcGVuZChzcGxpZGVIVE1MKVxuICAgICAgICAgICAgICBpbml0Wm9vbVNsaWRlcihzaWJTcmNBcnIuaW5kZXhPZihlbC5xdWVyeVNlbGVjdG9yKCdpbWcnKS5nZXRBdHRyaWJ1dGUoJ3NyYycpKSlcblxuICAgICAgICAgICAgICBsZXQgem9vbU1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnpvb20tbW9kYWwnKSxcbiAgICAgICAgICAgICAgICBob2xkZXIgPSB6b29tTW9kYWwucXVlcnlTZWxlY3RvcignLnpvb20tbW9kYWxfX2hvbGRlcicpXG4gICAgICAgICAgICAgIGluaXRQcmVzc1pvb20oem9vbU1vZGFsKVxuXG4gICAgICAgICAgICAgIGxldCB6b29tSGludCA9ICQoJzxcXGRpdj4nLCB7IGNsYXNzOiAnem9vbS1oaW50JyB9KVxuXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHpvb21Nb2RhbC5zdHlsZS5vcGFjaXR5ID0gMVxuICAgICAgICAgICAgICAgIGlmICh6b29tT3BlbkNvdW50IDw9IDEpIHsgJChob2xkZXIpLmFwcGVuZCh6b29tSGludCk7IHNldFRpbWVvdXQoKCkgPT4geyB6b29tSGludC5jc3MoeyBvcGFjaXR5OiAxIH0pIH0sIDUwMCkgfVxuICAgICAgICAgICAgICB9LCAxKTtcblxuICAgICAgICAgICAgICB6b29tTW9kYWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHpvb21IaW50LmNzcyh7IG9wYWNpdHk6IDAgfSk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB6b29tSGludC5yZW1vdmUoKVxuICAgICAgICAgICAgICAgIH0sIDQ1MClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgZG9jdW1lbnQub25rZXlkb3duID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnRcbiAgICAgICAgICAgICAgICBsZXQgaXNFc2MgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGlmICgna2V5JyBpbiBlKSB7XG4gICAgICAgICAgICAgICAgICBpc0VzYyA9IChlLmtleSA9PT0gXCJFc2NhcGVcIiB8fCBlLmtleSA9PT0gXCJFc2NcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlzRXNjID0gKGUua2V5Q29kZSA9PT0gMjcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNFc2MpIHtcbiAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgdW5sb2NrU2Nyb2xsKClcbiAgICAgICAgICAgICAgICAgIGxldCBtb2RhbCA9ICQoJy56b29tLW1vZGFsJylcbiAgICAgICAgICAgICAgICAgIGlmIChtb2RhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwuY3NzKHsgb3BhY2l0eTogMCB9KVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBtb2RhbC5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZShtb2RhbCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB6b29tT3BlbkNvdW50KytcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTIDogSW5pdCBQcm9kdWN0IFpvb20gRXJyb3InKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnW2RhdGEtZXZ0PVwiY2xvc2Vab29tTW9kYWxcIl0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdW5sb2NrU2Nyb2xsKClcbiAgICAgICAgICBsZXQgbW9kYWwgPSAkKCcuem9vbS1tb2RhbCcpXG4gICAgICAgICAgaWYgKG1vZGFsLmxlbmd0aCkge1xuICAgICAgICAgICAgbW9kYWwuY3NzKHsgb3BhY2l0eTogMCB9KVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIG1vZGFsLnJlbW92ZSgpXG4gICAgICAgICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZShtb2RhbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluX3Byb2R1Y3Rfem9vbScpICE9PSBudWxsKSB7IHNldFpvb20oKSB9XG4gICAgfSxcbiAgICBhdHRhY2hTdGlja3lTY3JvbGw6ICgpID0+IHtcbiAgICAgIGNvbnN0IGJhciA9ICQoJy5maWx0ZXItc2lkZWJhcicpLCBvdmVybGF5ID0gJCgnLmZpbHRlci1zaWRlYmFyX19vdmVybGF5JylcbiAgICAgIGlmIChiYXIubGVuZ3RoICYmIG92ZXJsYXkubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGVscyA9IGJhci5maW5kKCcuZmlsdGVyLXJvdycpXG4gICAgICAgICQuZWFjaChlbHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgZWxzW2ldLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgY29udCA9ICQodGhpcykuZmluZCgnLmZpbHRlci1yb3dfX2NvbnRhaW5lcicpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgbGV0IGN1cnJlbnRIZWlnaHQgPSBiYXIuaGVpZ2h0KClcbiAgICAgICAgICAgICAgbGV0IHNjcm9sbEhlaWdodCA9IGJhclswXS5zY3JvbGxIZWlnaHRcbiAgICAgICAgICAgICAgaWYgKChjdXJyZW50SGVpZ2h0IC0gc2Nyb2xsSGVpZ2h0KSA8PSAtNSkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXkuY3NzKHsgb3BhY2l0eTogMSB9KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG92ZXJsYXkuY3NzKHsgb3BhY2l0eTogMCB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZShjb250KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBiYXJbMF0uYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3AgKyB0aGlzLmNsaWVudEhlaWdodCA+PSB0aGlzLnNjcm9sbEhlaWdodCkge1xuICAgICAgICAgICAgb3ZlcmxheS5jc3MoeyBvcGFjaXR5OiAwIH0pXG4gICAgICAgICAgfSBlbHNlIHsgb3ZlcmxheS5jc3MoeyBvcGFjaXR5OiAxIH0pIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGF0dGFjaENoZWNrb3V0Q29weTogKCkgPT4ge1xuICAgICAgY29uc3QgYnRuQXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jcnlwdG8taG93LWJ0bicpLCAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY29weS1hZGRyZXNzLWJ0bicpXVxuICAgICAgaWYgKGJ0bkFyci5sZW5ndGgpIHtcbiAgICAgICAgYnRuQXJyLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgICAgIGJ0bi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICBsZXQgZGV0YWlscyA9IGJ0bi5jbG9zZXN0KCcuY2hlY2tvdXQtZm9ybV9fcmFkaW8tZGV0YWlscycpXG4gICAgICAgICAgICAgIGlmIChkZXRhaWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSBkZXRhaWxzLnF1ZXJ5U2VsZWN0b3IoJy5jb3B5LWFkZHJlc3MtYnRuX190eXBvJykuaW5uZXJIVE1MXG4gICAgICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29weUFkZHJlc3MoKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5jbGFzc0xpc3QuYWRkKElTX0NPUElFRClcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5jbGFzc0xpc3QucmVtb3ZlKElTX0NPUElFRClcbiAgICAgICAgICAgICAgICAgICAgfSwgMTMwMCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5jbGFzc0xpc3QucmVtb3ZlKElTX0NPUElFRCwgSVNfRVJST1IpXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMuY2xhc3NMaXN0LnJlbW92ZShJU19DT1BJRUQsIElTX0VSUk9SKVxuICAgICAgICAgICAgICAgICAgICB9LCAyMTAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29weUFkZHJlc3MoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgYWRqdXN0U3RpY2t5RWxzOiAoKSA9PiB7XG4gICAgICBjb25zdCBlbHNBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZpbHRlci1zaWRlYmFyLnRvLXN0aWNrJyksIC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdGlja3ktZmlsdGVycycpXVxuICAgICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhlYWRlcicpXG5cbiAgICAgIGlmIChlbHNBcnIubGVuZ3RoICYmIGhlYWRlcikge1xuICAgICAgICBmdW5jdGlvbiBhZGp1c3QoKSB7XG4gICAgICAgICAgbGV0IGhlYWRlckhlaWdodCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGhlYWRlcikuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0JykpXG4gICAgICAgICAgZWxzQXJyLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBsZXQgdG9wVmFsdWUgPSAkKHdpbmRvdykud2lkdGgoKSA+IDk5MSA/IGhlYWRlckhlaWdodCArIDI0IDogaGVhZGVySGVpZ2h0XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVsLnN0eWxlLCB7IHRvcDogYCR7dG9wVmFsdWV9cHhgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBbJ2xvYWQnLCAncmVzaXplJ10uZm9yRWFjaCgoZXZlbnQpID0+IHsgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsICgpID0+IHsgYWRqdXN0KCkgfSkgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGJpbmRDYXJkRmF2OiAoKSA9PiB7XG4gICAgICBjb25zdCBidXR0b25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhcmQtaXRlbS1mYXYnKVxuICAgICAgYnV0dG9ucy5mb3JFYWNoKGJ0biA9PiBidG4ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgaWYgKGJ0bi5jbGFzc0xpc3QuY29udGFpbnMoSVNfQUNUSVZFKSkge1xuICAgICAgICAgIGJ0bi5jbGFzc0xpc3QucmVtb3ZlKElTX0FDVElWRSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidG4uY2xhc3NMaXN0LmFkZChJU19BQ1RJVkUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBvYnNlcnZlU21hcnRQaWN0dXJlczogKCkgPT4ge1xuICAgICAgY29uc3QgYXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zbWFydC1waWN0dXJlJyldXG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIGFycikge1xuICAgICAgICBjb25zdCBpbWcgPSBlbC5xdWVyeVNlbGVjdG9yKCdpbWcnKVxuICAgICAgICBpZiAoIWltZykge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoX19MT0FERUQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGltZy5jb21wbGV0ZSB8fCBpbWcuc3JjLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChfX0xPQURFRClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoX19MT0FERUQpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBwYWdlRWxzIiwiY29uc3QgcGFnZVJldmlld3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2UtcmV2aWV3cy5zcGxpZGUnKSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5pbml0U3BsaWRlKClcbiAgICB9XG4gIH0sXG4gIGluaXRTcGxpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IG1haW4gPSBuZXcgU3BsaWRlKCcucGFnZS1yZXZpZXdzJywge1xuICAgICAgICB0eXBlOiBcInNsaWRlclwiLFxuICAgICAgICBwZXJQYWdlOiAzLjQsXG4gICAgICAgIHBlck1vdmU6IDEsXG4gICAgICAgIGF1dG9wbGF5OiAwLFxuICAgICAgICBwYXVzZU9uSG92ZXI6IDEsXG4gICAgICAgIHBhdXNlT25Gb2N1czogMSxcbiAgICAgICAgZ2FwOiAxMixcbiAgICAgICAgYXJyb3dzOiAxLFxuICAgICAgICBwYWdpbmF0aW9uOiAxLFxuICAgICAgICBzcGVlZDogNTAwLFxuICAgICAgICBicmVha3BvaW50czoge1xuICAgICAgICAgIDk5MToge1xuICAgICAgICAgICAgcGVyUGFnZTogMi4yXG4gICAgICAgICAgfSxcbiAgICAgICAgICA2MjA6IHtcbiAgICAgICAgICAgIHBlclBhZ2U6IDEuM1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIG1haW4ubW91bnQoKVxuICAgIH0gY2F0Y2gge1xuICAgICAgY29uc29sZS5sb2coJ1BhZ2UgUmV2aWV3IFNQTElERSBFUlInKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhZ2VSZXZpZXdzIiwiY29uc3QgcGdNb2RhbCA9IG5ldyBPYmplY3Qoe1xuICBpbml0aWFsaXplZDogdW5kZWZpbmVkLFxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW5kZXJET00oKTtcbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuaW5pdEZuKS5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHRhcmdldCgpO1xuICAgIH0pO1xuICAgIHRoaXMuaW50aWFsaXplZCA9IHRydWU7XG4gIH0sXG5cbiAgcmVuZGVyRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUm9vdFxuICAgIHRoaXMubW9kYWwgPSAkKFwiLnBnLW1vZGFsXCIpO1xuICAgIHRoaXMuY29udGFpbmVyID0gJChcIi5wZy1tb2RhbF9fY29udGFpbmVyXCIpO1xuICAgIHRoaXMuYmFja2Ryb3AgPSAkKFwiLnBnLW1vZGFsX19iYWNrZHJvcFwiKTtcbiAgICB0aGlzLmNsb3NlID0gJCgnW2RhdGEtZXZ0PVwiY2xvc2VQZ01vZGFsXCJdJyk7XG5cbiAgICAvLyBTZWN0aW9uc1xuICAgIHRoaXMuc2VjdGlvbiA9ICQoXCIucGctc2VjdGlvblwiKTtcbiAgICB0aGlzLnJvdyA9ICQoXCIucGctcm93XCIpO1xuICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyID0gJChcIi5wZy1tb2RhbF9fb3ZlcnNjcm9sbFwiKTtcbiAgICB0aGlzLnNlY3Rpb25CcmFjZWxldHMgPSB0aGlzLnNlY3Rpb24uZmlsdGVyKFwiI3BnQnJhY2VsZXRzXCIpO1xuICAgIHRoaXMuc2VjdGlvbkRpYW1vbmRzID0gdGhpcy5zZWN0aW9uLmZpbHRlcihcIiNwZ0RpYW1vbmRzXCIpO1xuICAgIHRoaXMuc2VjdGlvblJpbmdzID0gdGhpcy5zZWN0aW9uLmZpbHRlcihcIiNwZ1JpbmdzXCIpO1xuICAgIHRoaXMuc2VjdGlvbk5lY2tsYWNlcyA9IHRoaXMuc2VjdGlvbi5maWx0ZXIoXCIjcGdOZWNrbGFjZXNcIik7XG5cbiAgICAvLyBDb250cm9sc1xuICAgIHRoaXMuc3dpdGNoQnRuID0gJChcIi5wZy1zd2l0Y2gtYnRuXCIpO1xuXG4gICAgLy8gU2VsZWN0IFRhYnNcbiAgICB0aGlzLnNlbGVjdEFyciA9IEFycmF5LmZyb20oJChcIi5wZy1zZWxlY3RcIikpO1xuICAgIHRoaXMuc2VsZWN0QnRuID0gJChcIi5wZy1zZWxlY3QtYnRuXCIpO1xuICB9LFxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbG9zZS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBwZ01vZGFsLmZuLmNsb3NlTW9kYWwoKTtcbiAgICB9KTtcbiAgfSxcblxuICBmbjoge1xuICAgIG9wZW5Nb2RhbDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgbG9ja1Njcm9sbCgpO1xuICAgICAgcGdNb2RhbC5tb2RhbC5zaG93KCk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcGdNb2RhbC5iYWNrZHJvcC5jc3MoeyBvcGFjaXR5OiAxIH0pO1xuICAgICAgICBwZ01vZGFsLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImlzLWhpZGRlblwiKTtcbiAgICAgIH0sIDEpO1xuICAgICAgbGV0IGF0dCA9ICQodGFyZ2V0KS5hdHRyKFwiZGF0YS1wZy1vcGVuXCIpO1xuICAgICAgcGdNb2RhbC5zZWN0aW9uLmhpZGUoKTtcbiAgICAgIHN3aXRjaCAoYXR0KSB7XG4gICAgICAgIGNhc2UgXCJkaWFtb25kc1wiOlxuICAgICAgICAgIHBnTW9kYWwuc2VjdGlvbkRpYW1vbmRzLnNob3coKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJpbmdzXCI6XG4gICAgICAgICAgcGdNb2RhbC5zZWN0aW9uUmluZ3Muc2hvdygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYnJhY2VsZXRzXCI6XG4gICAgICAgICAgcGdNb2RhbC5zZWN0aW9uQnJhY2VsZXRzLnNob3coKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5lY2tsYWNlc1wiOlxuICAgICAgICAgIHBnTW9kYWwuc2VjdGlvbk5lY2tsYWNlcy5zaG93KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGdNb2RhbC5zZWN0aW9uWzBdLnNob3coKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHBnTW9kYWwuc2Nyb2xsQ29udGFpbmVyWzBdLnNjcm9sbFRvcCA9IDA7XG4gICAgICBwZ1NlbGVjdC5hdHRhY2hDb250cm9scyhwZ01vZGFsLnNlbGVjdEFyciwgcGdNb2RhbC5zZWxlY3RCdG4pO1xuICAgIH0sXG4gICAgY2xvc2VNb2RhbDogZnVuY3Rpb24gKCkge1xuICAgICAgdW5sb2NrU2Nyb2xsKCk7XG4gICAgICBwZ01vZGFsLmJhY2tkcm9wLmNzcyh7IG9wYWNpdHk6IDAgfSk7XG4gICAgICBwZ01vZGFsLmNvbnRhaW5lci5hZGRDbGFzcyhcImlzLWhpZGRlblwiKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBwZ01vZGFsLm1vZGFsLmhpZGUoKTtcbiAgICAgIH0sIDQ3NSk7XG4gICAgfSxcbiAgICBzZXRNb2JpbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICgkKHdpbmRvdykud2lkdGgoKSA8IDQ4MCkge1xuICAgICAgICBsZXQgYXJyID0gQXJyYXkuZnJvbShwZ01vZGFsLnNlY3Rpb24pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBuQXJyID0gQXJyYXkuZnJvbSgkKGFycltpXSkuZmluZChwZ01vZGFsLnJvdykpO1xuICAgICAgICAgICQuZWFjaChuQXJyLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICQobkFycltpXSkuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhdHRhY2hTZWN0aW9uQ29udHJvbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHBnTW9kYWwuc2VjdGlvbi5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGJ0bkFyciA9IFsuLi4kKHRoaXMpLmZpbmQocGdNb2RhbC5zd2l0Y2hCdG4pXTtcbiAgICAgICAgbGV0IHJvd0FyciA9IFsuLi4kKHRoaXMpLmZpbmQocGdNb2RhbC5yb3cpXTtcbiAgICAgICAgJC5lYWNoKGJ0bkFyciwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICBidG5BcnJbaV0ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICQuZWFjaChyb3dBcnIsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICQocm93QXJyW2ldKS5oaWRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICQuZWFjaChidG5BcnIsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICQoYnRuQXJyW2ldKS5yZW1vdmVDbGFzcyhcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICQocm93QXJyW2ldKS5zaG93KCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuXG4gIGluaXRGbjoge1xuICAgIHNldEluaXRpYWw6ICgpID0+IHtcbiAgICAgIHBnTW9kYWwuZm4uY2xvc2VNb2RhbCgpO1xuICAgICAgcGdNb2RhbC5mbi5zZXRNb2JpbGUoKTtcbiAgICAgIHBnTW9kYWwuZm4uYXR0YWNoU2VjdGlvbkNvbnRyb2xzKCk7XG4gICAgfSxcbiAgfSxcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gcGdNb2RhbCIsImNvbnN0IHBnU2VsZWN0ID0ge1xuICBpbml0YWxpemVkOiB1bmRlZmluZWQsXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbmRlckRPTSgpO1xuICAgIHRoaXMuaW5pdGFsaXplZCA9IHRydWU7XG4gIH0sXG4gIGdldEF0dHJET006IGZ1bmN0aW9uIChhdHQpIHtcbiAgICByZXR1cm4gJChgW2RhdGEtcGctc2V0PVwiJHthdHR9XCJdYCk7XG4gIH0sXG4gIHJlbmRlckRPTTogZnVuY3Rpb24gKCkge1xuICAgIC8vIFNoYXBlXG4gICAgdGhpcy5zaGFwZUltZyA9IHRoaXMuZ2V0QXR0ckRPTShcInNoYXBlSW1nXCIpO1xuICAgIHRoaXMuc2hhcGVUaXRsZSA9IHRoaXMuZ2V0QXR0ckRPTShcInNoYXBlVGl0bGVcIik7XG4gICAgdGhpcy5zaGFwZURlc2NyaXB0aW9uID0gdGhpcy5nZXRBdHRyRE9NKFwic2hhcGVEZXNjcmlwdGlvblwiKTtcblxuICAgIC8vIENvbG9yXG4gICAgdGhpcy5jb2xvckltZyA9IHRoaXMuZ2V0QXR0ckRPTShcImNvbG9ySW1nXCIpO1xuICAgIHRoaXMuY29sb3JUaXRsZSA9IHRoaXMuZ2V0QXR0ckRPTShcImNvbG9yVGl0bGVcIik7XG4gICAgdGhpcy5jb2xvckRlc2NyaXB0aW9uID0gdGhpcy5nZXRBdHRyRE9NKFwiY29sb3JEZXNjcmlwdGlvblwiKTtcblxuICAgIC8vIENsYXJpdHlcbiAgICB0aGlzLmNsYXJpdHlJbWcgPSB0aGlzLmdldEF0dHJET00oXCJjbGFyaXR5SW1nXCIpO1xuICAgIHRoaXMuY2xhcnR5VGl0bGUgPSB0aGlzLmdldEF0dHJET00oXCJjbGFyaXR5VGl0bGVcIik7XG4gICAgdGhpcy5jbGFyaXR5RGVzY3JpcHRpb24gPSB0aGlzLmdldEF0dHJET00oXCJjbGFyaXR5RGVzY3JpcHRpb25cIik7XG5cbiAgICAvLyBSaW5nIFNpemVcbiAgICB0aGlzLmN1cnJlbnRTaXplID0gdGhpcy5nZXRBdHRyRE9NKFwiY3VycmVudFNpemVcIik7XG4gICAgdGhpcy5jaXJjU2l6ZSA9IHRoaXMuZ2V0QXR0ckRPTShcImNpcmNTaXplXCIpO1xuICAgIHRoaXMuZFNpemUgPSB0aGlzLmdldEF0dHJET00oXCJkU2l6ZVwiKTtcbiAgICB0aGlzLmV1U2l6ZSA9IHRoaXMuZ2V0QXR0ckRPTShcImV1U2l6ZVwiKTtcbiAgICB0aGlzLnVrU2l6ZSA9IHRoaXMuZ2V0QXR0ckRPTShcInVrU2l6ZVwiKTtcbiAgfSxcbiAgYXR0YWNoQ29udHJvbHM6IGZ1bmN0aW9uIChzQXJyLCBzQnRuKSB7XG4gICAgaWYgKCF0aGlzLmluaXRhbGl6ZWQpIHtcbiAgICAgIHBnU2VsZWN0LmluaXQoKTtcbiAgICB9XG4gICAgbGV0IHNlbGVjdEFyciA9IHNBcnIsXG4gICAgICBzZWxlY3RCdG4gPSBzQnRuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdGhpc0F0dHIgPSBzZWxlY3RBcnJbaV0uZ2V0QXR0cmlidXRlKFwiZGF0YS1wZy1zZWxlY3RcIiksXG4gICAgICAgIGJ0bkFyciA9IEFycmF5LmZyb20oJChzZWxlY3RBcnJbaV0pLmZpbmQoc2VsZWN0QnRuKSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldFBnU2VsZWN0RXZlbnQoKSB7XG4gICAgICAgIGxldCBkYXRhU2V0O1xuICAgICAgICBzd2l0Y2ggKHRoaXNBdHRyKSB7XG4gICAgICAgICAgY2FzZSBcInNoYXBlXCI6XG4gICAgICAgICAgICBkYXRhU2V0ID0gcGdTZWxlY3Quc2hhcGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgICAgICAgIGRhdGFTZXQgPSBwZ1NlbGVjdC5jb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjbGFyaXR5XCI6XG4gICAgICAgICAgICBkYXRhU2V0ID0gcGdTZWxlY3QuY2xhcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyaW5nLXNpemVcIjpcbiAgICAgICAgICAgIGRhdGFTZXQgPSBwZ1NlbGVjdC5yaW5nU2l6ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFTZXQgfTtcbiAgICAgIH1cblxuICAgICAgJC5lYWNoKGJ0bkFyciwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgYnRuQXJyW2ldLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgc2V0UGdTZWxlY3RFdmVudCgpLmRhdGFTZXQuY2hhbmdlRGV0YWlscyhpKTtcbiAgICAgICAgICAkLmVhY2goYnRuQXJyLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgYnRuQXJyW2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgc2hhcGU6IHtcbiAgICBjaGFuZ2VEZXRhaWxzOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHBnU2VsZWN0LnNoYXBlSW1nLmF0dHIoXCJzcmNcIiwgcGdTZWxlY3QuZGF0YS5zaGFwZVtpbmRleF0udXJsKTtcbiAgICAgIHBnU2VsZWN0LnNoYXBlVGl0bGUuaHRtbChwZ1NlbGVjdC5kYXRhLnNoYXBlW2luZGV4XS50aXRsZSk7XG4gICAgICBwZ1NlbGVjdC5zaGFwZURlc2NyaXB0aW9uLmh0bWwocGdTZWxlY3QuZGF0YS5zaGFwZVtpbmRleF0uZGVzY3JpcHRpb24pO1xuICAgIH0sXG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgY2hhbmdlRGV0YWlsczogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBwZ1NlbGVjdC5jb2xvckltZy5hdHRyKFwic3JjXCIsIHBnU2VsZWN0LmRhdGEuY29sb3JbaW5kZXhdLnVybCk7XG4gICAgICBwZ1NlbGVjdC5jb2xvclRpdGxlLmh0bWwocGdTZWxlY3QuZGF0YS5jb2xvcltpbmRleF0udGl0bGUpO1xuICAgICAgcGdTZWxlY3QuY29sb3JEZXNjcmlwdGlvbi5odG1sKHBnU2VsZWN0LmRhdGEuY29sb3JbaW5kZXhdLmRlc2NyaXB0aW9uKTtcbiAgICB9LFxuICB9LFxuICBjbGFyaXR5OiB7XG4gICAgY2hhbmdlRGV0YWlsczogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBwZ1NlbGVjdC5jbGFyaXR5SW1nLmF0dHIoXCJzcmNcIiwgcGdTZWxlY3QuZGF0YS5jbGFyaXR5W2luZGV4XS51cmwpO1xuICAgICAgcGdTZWxlY3QuY2xhcnR5VGl0bGUuaHRtbChwZ1NlbGVjdC5kYXRhLmNsYXJpdHlbaW5kZXhdLnRpdGxlKTtcbiAgICAgIHBnU2VsZWN0LmNsYXJpdHlEZXNjcmlwdGlvbi5odG1sKFxuICAgICAgICBwZ1NlbGVjdC5kYXRhLmNsYXJpdHlbaW5kZXhdLmRlc2NyaXB0aW9uXG4gICAgICApO1xuICAgIH0sXG4gIH0sXG4gIHJpbmdTaXplOiB7XG4gICAgY2hhbmdlRGV0YWlsczogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBwZ1NlbGVjdC5jdXJyZW50U2l6ZS5odG1sKHBnU2VsZWN0LmRhdGEucmluZ1NpemVbaW5kZXhdLnVzKTtcbiAgICAgIHBnU2VsZWN0LmNpcmNTaXplLmh0bWwocGdTZWxlY3QuZGF0YS5yaW5nU2l6ZVtpbmRleF0uY2lyYyk7XG4gICAgICBwZ1NlbGVjdC5kU2l6ZS5odG1sKHBnU2VsZWN0LmRhdGEucmluZ1NpemVbaW5kZXhdLmRpYW1ldGVyKTtcbiAgICAgIHBnU2VsZWN0LmV1U2l6ZS5odG1sKHBnU2VsZWN0LmRhdGEucmluZ1NpemVbaW5kZXhdLmV1cm9wZSk7XG4gICAgICBwZ1NlbGVjdC51a1NpemUuaHRtbChwZ1NlbGVjdC5kYXRhLnJpbmdTaXplW2luZGV4XS51ayk7XG4gICAgfSxcbiAgfSxcbiAgZGF0YToge1xuICAgIHNoYXBlOiBbXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL1pCbWNHMGYvZG1nLXNoYXBlLXJvdW5kLnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJSb3VuZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICBcIkEgY2xhc3NpYyBhbmQgdGltZWxlc3Mgc2hhcGUsIHRoZSByb3VuZCBkaWFtb25kIGlzIGtub3duIGZvciBpdHMgYnJpbGxpYW50IHNwYXJrbGUgYW5kIHBlcmZlY3Qgc3ltbWV0cnkuXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9pLmliYi5jby9yZE5rWXlwL2RtZy1zaGFwZS1wcmluZXNzLnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJQcmluY2Vzc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICBcIkEgc3F1YXJlLXNoYXBlZCBkaWFtb25kIHdpdGggc2hhcnAgY29ybmVycyBhbmQgZXhjZXB0aW9uYWwgYnJpbGxpYW5jZSwga25vd24gZm9yIGl0cyBtb2Rlcm4gYW5kIGNsZWFuIGxpbmVzLlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vaS5pYmIuY28vMjcxYnNDWi9kbWctc2hhcGUtb3ZhbC5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiT3ZhbFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICBcIkEgbW9kaWZpZWQgYnJpbGxpYW50IGN1dCBkaWFtb25kIHdpdGggYW4gZWxvbmdhdGVkIHNoYXBlLCBrbm93biBmb3IgaXRzIGJyaWxsaWFuY2UgYW5kIGFiaWxpdHkgdG8gY3JlYXRlIHRoZSBpbGx1c2lvbiBvZiBsb25nZXIsIHNsZW5kZXIgZmluZ2Vycy5cIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL3F5UW5WMWYvZG1nLXNoYXBlLXBlYXIucG5nXCIsXG4gICAgICAgIHRpdGxlOiBcIlBlYXJcIixcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgXCJBbiBlbGVnYW50IGNvbWJpbmF0aW9uIG9mIGEgcm91bmQgYW5kIG1hcnF1aXNlIHNoYXBlLCBzb21ldGltZXMgY2FsbGVkIGEgdGVhcmRyb3AsIG9mZmVyaW5nIGEgdW5pcXVlIGFuZCBncmFjZWZ1bCBhcHBlYXJhbmNlLlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vaS5pYmIuY28vTlZkZ0p0di9kbWctc2hhcGUtZW1lcmFsZC5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiRW1lcmFsZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICBcIkEgcmVjdGFuZ3VsYXIgc2hhcGUgd2l0aCBzdGVwcGVkIGZhY2V0cywgaGlnaGxpZ2h0aW5nIHRoZSBkaWFtb25kcyBjbGFyaXR5IGFuZCBzaG93Y2FzaW5nIGEgdGltZWxlc3MgYW5kIHNvcGhpc3RpY2F0ZWQgbG9vay5cIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICBjb2xvcjogW1xuICAgICAge1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9pLmliYi5jby9NRG5ZbUdoL2RtZy1jb2xvci1uZWFyLnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJLIC0gTGFzdCBHcmFkZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICBcIlRoZSBjb2xvciBtYXkgYmUgdmlzaWJsZSB0byB0aGUgdW5haWRlZCBleWUuIERpYW1vbmRzIHdpdGggYSBLLWNvbG9yIGdyYWRlIGNhbiBiZSBhIHNtYXJ0IGNob2ljZSwgb2ZmZXJpbmcgZXhjZWxsZW50IHZhbHVlIGZvciBtb25leS5cIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL01EblltR2gvZG1nLWNvbG9yLW5lYXIucG5nXCIsXG4gICAgICAgIHRpdGxlOiBcIkogLSBMYXN0IEdyYWRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICdDb2xvciBpbiBkaWFtb25kcyBncmFkZWQgYXMgXCJuZWFyLWNvbG9ybGVzc1wiIG1heSBiZSBzbGlnaHRseSB2aXNpYmxlIHRvIHRoZSBuYWtlZCBleWUsIGVzcGVjaWFsbHkgaW4gZmFuY3kgc2hhcGVzIG9yIGRpYW1vbmRzIGxhcmdlciB0aGFuIDEgY2FyYXQuJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL0prSzRCM0MvZG1nLWNvbG9yLXNsaWdodC5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiSSAtIFNsaWdodGx5IERldGVjdGFibGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgXCJVcG9uIGNsb3NlIGV4YW1pbmF0aW9uLCB0aGUgY29sb3IgbWF5IGJlIGJhcmVseSBub3RpY2VhYmxlLCBidXQgaXQgc3RpbGwgcHJvdmlkZXMgZXhjZXB0aW9uYWwgdmFsdWUuXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9pLmliYi5jby9KMkpoUE00L2RtZy1jb2xvci1jbGVhci5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiSCAtIE5lYXIgQ29sb3JsZXNzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICdUaGUgXCJuZWFyLWNvbG9ybGVzc1wiIGdyYWRlIG9mIENBIGV4aGliaXRzIG5vdGljZWFibGUgY29sb3Igb25seSB3aGVuIGNvbXBhcmVkIHRvIG11Y2ggaGlnaGVyIGNvbG9yIGdyYWRlcywgb2ZmZXJpbmcgZXhjZWxsZW50IHZhbHVlLicsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9pLmliYi5jby9KMkpoUE00L2RtZy1jb2xvci1jbGVhci5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiRyAtIEFsbW9zdCBDb2xvcmxlc3NcIixcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgJ1RoaXMgZ3JhZGUgaXMgdGhlIGhpZ2hlc3QgbGV2ZWwgb2YgXCJuZWFyLWNvbG9ybGVzc1wiIGFuZCBtYXkgc2hvdyBzb21lIGNvbG9yIGluIGNvbXBhcmlzb24gdG8gdGhlIGV2ZW4gaGlnaGVyIFwiY29sb3JsZXNzXCIgZ3JhZGVzLCBidXQgaXQgb2ZmZXJzIGV4Y2VsbGVudCB2YWx1ZS4nLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vaS5pYmIuY28vSjJKaFBNNC9kbWctY29sb3ItY2xlYXIucG5nXCIsXG4gICAgICAgIHRpdGxlOiBcIkYgLSBDb2xvcmxlc3NcIixcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgJ1RoZSBcImNvbG9ybGVzc1wiIGdyYWRlIGlzIG1vc3QgdmFsdWVkIHdoZW4gcGxhY2VkIGluIHBsYXRpbnVtIG9yIHdoaXRlIGdvbGQsIHdpdGggYSBmYWludCBjb2xvciB0aGF0IGNhbiBiZSBpZGVudGlmaWVkIGJ5IGEgc2tpbGxlZCBnZW1vbG9naXN0LicsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9pLmliYi5jby9KMkpoUE00L2RtZy1jb2xvci1jbGVhci5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiRSAtIENvbG9ybGVzc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAnVGhpcyBncmFkZSwgYmVzdCBzaG93Y2FzZWQgaW4gcGxhdGludW0gb3Igd2hpdGUgZ29sZCwgaXMgc28gXCJjb2xvcmxlc3NcIiB0aGF0IGV2ZW4gdHJhaW5lZCBleWVzIHdvdWxkIHN0cnVnZ2xlIHRvIGRldGVjdCB0cmFjZXMgb2YgY29sb3IuJyxcbiAgICAgIH0sXG4gICAgXSxcbiAgICBjbGFyaXR5OiBbXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL0dwOHBLd0svY2xhcml0eS1pMy5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiSTEsIEkyLCBJMyAtIEluY2x1ZGVkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiRGlhbW9uZHMgaW4gdGhpcyBjbGFyaXR5IHJhbmdlIGhhdmUgaW5jbHVzaW9ucyB0aGF0IGFyZSBlYXNpbHkgdmlzaWJsZSB1bmRlciAxMHggbWFnbmlmaWNhdGlvbiBhbmQgbWF5IGFsc28gYmUgdmlzaWJsZSB0byB0aGUgbmFrZWQgZXllLiBUaGVzZSBkaWFtb25kcyBtYXkgaGF2ZSByZWR1Y2VkIGJyaWxsaWFuY2UgYW5kIHNwYXJrbGUgZHVlIHRvIHRoZWlyIGluY2x1c2lvbnMuXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9pLmliYi5jby9aSEJ2Sno5L2NsYXJpdHktc2kxLXNpMi5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiU0kxICYgU0kyIC0gU2xpZ2h0bHkgSW5jbHVkZWRcIixcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgXCJUaGVzZSBncmFkZXMgaGF2ZSBub3RpY2VhYmxlIGluY2x1c2lvbnMgdW5kZXIgMTB4IG1hZ25pZmljYXRpb24sIHNvbWUgb2Ygd2hpY2ggbWlnaHQgYmUgdmlzaWJsZSB0byB0aGUgbmFrZWQgZXllLiBTSSBkaWFtb25kcyBnZW5lcmFsbHkgb2ZmZXIgZ29vZCB2YWx1ZSBhcyB0aGV5IGhhdmUgaW5jbHVzaW9ucyB0aGF0IG1pZ2h0IG5vdCBzaWduaWZpY2FudGx5IGFmZmVjdCB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgZGlhbW9uZC5cIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvLzI3eEc3R0MvY2xhcml0eS12czEtdnMyLnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJWUzEgJiBWUzIgLSBWZXJ5IFNsaWdodGx5IEluY2x1ZGVkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiVGhlc2UgZ3JhZGVzIGhhdmUgbWlub3IgaW5jbHVzaW9ucyB0aGF0IGFyZSB2aXNpYmxlIHVuZGVyIDEweCBtYWduaWZpY2F0aW9uIGJ1dCBhcmUgY29uc2lkZXJlZCByZWxhdGl2ZWx5IHNtYWxsIGFuZCBub3QgZWFzaWx5IG5vdGljZWFibGUgdG8gdGhlIG5ha2VkIGV5ZS5cIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL2Q2MXduTDkvY2xhcml0eS12dnMxLXZ2czIucG5nXCIsXG4gICAgICAgIHRpdGxlOiBcIlZWUzEgJiBWVlMyIC0gVmVyeSwgVmVyeSBTbGlnaHRseSBJbmNsdWRlZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICBcIlRoZXNlIGdyYWRlcyBpbmRpY2F0ZSB0aGF0IGluY2x1c2lvbnMgYXJlIGV4dHJlbWVseSBkaWZmaWN1bHQgdG8gc2VlIGV2ZW4gdW5kZXIgMTB4IG1hZ25pZmljYXRpb24uIFZWUyBkaWFtb25kcyBtYXkgaGF2ZSBtaW5vciBpbmNsdXNpb25zIHRoYXQgYXJlIGJhcmVseSB2aXNpYmxlIHRvIGEgc2tpbGxlZCBncmFkZXIuXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9pLmliYi5jby9XS3Nxczk5L2NsYXJpdHktZmwtaWYucG5nXCIsXG4gICAgICAgIHRpdGxlOiBcIkZMICYgSUYgLSBGbGF3bGVzc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICBcIlRoZXNlIGFyZSB0aGUgaGlnaGVzdCBjbGFyaXR5IGdyYWRlcy4gRmxhd2xlc3MgZGlhbW9uZHMgaGF2ZSBubyB2aXNpYmxlIGluY2x1c2lvbnMgb3IgYmxlbWlzaGVzIHVuZGVyIDEweCBtYWduaWZpY2F0aW9uLCBldmVuIGJ5IGEgc2tpbGxlZCBncmFkZXIuIEludGVybmFsbHkgRmxhd2xlc3MgZGlhbW9uZHMgaGF2ZSBubyBpbnRlcm5hbCBpbmNsdXNpb25zIGJ1dCBtYXkgaGF2ZSBtaW5vciBzdXJmYWNlIGJsZW1pc2hlcy5cIixcbiAgICAgIH0sXG4gICAgXSxcbiAgICByaW5nU2l6ZTogW1xuICAgICAgeyB1czogNCwgZXVyb3BlOiBcIjQ3XCIsIHVrOiBcIkggMS8yXCIsIGRpYW1ldGVyOiBcIjE0LjlcIiwgY2lyYzogXCI0Ni44XCIgfSxcbiAgICAgIHsgdXM6IDQuNSwgZXVyb3BlOiBcIjQ4XCIsIHVrOiBcIkkgMS8yXCIsIGRpYW1ldGVyOiBcIjE1LjNcIiwgY2lyYzogXCI0OFwiIH0sXG4gICAgICB7IHVzOiA1LCBldXJvcGU6IFwiNDlcIiwgdWs6IFwiSiAxLzJcIiwgZGlhbWV0ZXI6IFwiMTUuN1wiLCBjaXJjOiBcIjQ5LjNcIiB9LFxuICAgICAgeyB1czogNS41LCBldXJvcGU6IFwiNTFcIiwgdWs6IFwiSyAxLzJcIiwgZGlhbWV0ZXI6IFwiMTYuMVwiLCBjaXJjOiBcIjUwLjZcIiB9LFxuICAgICAgeyB1czogNiwgZXVyb3BlOiBcIjUyXCIsIHVrOiBcIkwgMS8yXCIsIGRpYW1ldGVyOiBcIjE2LjVcIiwgY2lyYzogXCI1MS45XCIgfSxcbiAgICAgIHsgdXM6IDYuNSwgZXVyb3BlOiBcIjUzXCIsIHVrOiBcIk0gMS8yXCIsIGRpYW1ldGVyOiBcIjE2LjlcIiwgY2lyYzogXCI1My4xXCIgfSxcbiAgICAgIHsgdXM6IDcsIGV1cm9wZTogXCI1NFwiLCB1azogXCJOIDEvMlwiLCBkaWFtZXRlcjogXCIxNy4zXCIsIGNpcmM6IFwiNTQuNFwiIH0sXG4gICAgICB7IHVzOiA3LjUsIGV1cm9wZTogXCI1NVwiLCB1azogXCJPIDEvMlwiLCBkaWFtZXRlcjogXCIxNy43XCIsIGNpcmM6IFwiNTUuN1wiIH0sXG4gICAgICB7IHVzOiA4LCBldXJvcGU6IFwiNTdcIiwgdWs6IFwiUCAxLzJcIiwgZGlhbWV0ZXI6IFwiMTguMVwiLCBjaXJjOiBcIjU3LjBcIiB9LFxuICAgICAgeyB1czogOC41LCBldXJvcGU6IFwiNThcIiwgdWs6IFwiUSAxLzJcIiwgZGlhbWV0ZXI6IFwiMTguNVwiLCBjaXJjOiBcIjU4LjNcIiB9LFxuICAgICAgeyB1czogOSwgZXVyb3BlOiBcIjU5XCIsIHVrOiBcIlIgMS8yXCIsIGRpYW1ldGVyOiBcIjE5LjBcIiwgY2lyYzogXCI1OS41XCIgfSxcbiAgICAgIHsgdXM6IDkuNSwgZXVyb3BlOiBcIjYxXCIsIHVrOiBcIlMgMS8yXCIsIGRpYW1ldGVyOiBcIjE5LjRcIiwgY2lyYzogXCI2MC44XCIgfSxcbiAgICAgIHsgdXM6IDEwLCBldXJvcGU6IFwiNjJcIiwgdWs6IFwiVCAxLzJcIiwgZGlhbWV0ZXI6IFwiMTkuOFwiLCBjaXJjOiBcIjYyLjFcIiB9LFxuICAgICAgeyB1czogMTAuNSwgZXVyb3BlOiBcIjYzXCIsIHVrOiBcIlUgMS8yXCIsIGRpYW1ldGVyOiBcIjIwLjJcIiwgY2lyYzogXCI2My40XCIgfSxcbiAgICAgIHsgdXM6IDExLCBldXJvcGU6IFwiNjRcIiwgdWs6IFwiViAxLzJcIiwgZGlhbWV0ZXI6IFwiMjAuNlwiLCBjaXJjOiBcIjY0LjZcIiB9LFxuICAgICAgeyB1czogMTEuNSwgZXVyb3BlOiBcIjY2XCIsIHVrOiBcIlcgMS8yXCIsIGRpYW1ldGVyOiBcIjIxLjBcIiwgY2lyYzogXCI2NS45XCIgfSxcbiAgICAgIHsgdXM6IDEyLCBldXJvcGU6IFwiNjdcIiwgdWs6IFwiWCAxLzJcIiwgZGlhbWV0ZXI6IFwiMjEuNFwiLCBjaXJjOiBcIjY3LjJcIiB9LFxuICAgICAgeyB1czogMTIuNSwgZXVyb3BlOiBcIjY4XCIsIHVrOiBcIlogMS8yXCIsIGRpYW1ldGVyOiBcIjIxLjhcIiwgY2lyYzogXCI2OC41XCIgfSxcbiAgICBdLFxuICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBnU2VsZWN0IiwiZnVuY3Rpb24gaW5pdFZhbGlkYXRvcnMoKSB7XG4gICQoXCIubmVlZHMtdmFsaWRhdGlvblwiKS5wYXJzbGV5KHtcbiAgICBlcnJvckNsYXNzOiAnaXMtaW52YWxpZCB0ZXh0LWRhbmdlcicsXG4gICAgc3VjY2Vzc0NsYXNzOiAnaXMtdmFsaWQnLFxuICAgIGVycm9yc1dyYXBwZXI6ICc8ZGl2IGNsYXNzPVwiaW52YWxpZC1mZWVkYmFja1wiPjwvZGl2PicsXG4gICAgZXJyb3JUZW1wbGF0ZTogJzxzcGFuPjwvc3Bhbj4nLFxuICAgIHRyaWdnZXI6ICdjaGFuZ2UnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNldEJ0blN0YXRlcyhlbCkge1xuICBlbC5yZW1vdmVDbGFzcygnaXMtc3VjY2Vzc2Z1bCcpO1xuICBlbC5yZW1vdmVDbGFzcygnaXMtZmFpbGVkJyk7XG59XG5cbmZ1bmN0aW9uIHNob3dBbHRlcm5hdGl2ZUJ0blRleHQoZWwsIG1zZywgY3NzX2NsYXNzKSB7XG4gIHZhciBvcmlnaW5hbF9tc2cgPSAkKGVsKS5odG1sKCk7XG4gIHJlc2V0QnRuU3RhdGVzKCQoZWwpKTtcbiAgJChlbCkuYWRkQ2xhc3MoY3NzX2NsYXNzKS5odG1sKG1zZyk7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0QnRuU3RhdGVzKCQoZWwpKTtcbiAgICAkKGVsKS5odG1sKG9yaWdpbmFsX21zZyk7XG4gIH0sIDQwMDApO1xufVxuXG5mdW5jdGlvbiByZXNldFNpZ25NZXNzYWdlKCkge1xuICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zaWduLW1vZGFsX19tZXNzYWdlJylcbiAgaWYgKGVsKSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnaXMtc3VjY2Vzc2Z1bCcpXG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnaXMtZmFpbGVkJylcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgZWwuaW5uZXJIVE1MID0gJydcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG93U2lnbk1lc3NhZ2UobXNnLCBjc3NfY2xhc3MpIHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2lnbi1tb2RhbF9fbWVzc2FnZScpXG4gIGlmIChlbCkge1xuICAgIHZhciBvcmlnaW5hbF9tc2cgPSBlbC5pbm5lckhUTUxcbiAgICByZXNldFNpZ25NZXNzYWdlKClcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNzc19jbGFzcylcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgZWwuaW5uZXJIVE1MID0gbXNnXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXNldFNpZ25NZXNzYWdlKClcbiAgICAgIGVsLmlubmVySFRNTCA9IG9yaWdpbmFsX21zZ1xuICAgIH0sIDQwMDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbmZpcm1Mb2dpbk90cCgpIHtcbiAgdmFyIG90cCA9ICQoJyNvdHBfMScpLnZhbCgpICsgJCgnI290cF8yJykudmFsKCkgKyAkKCcjb3RwXzMnKS52YWwoKSArICQoJyNvdHBfNCcpLnZhbCgpO1xuICB2YXIgcGhvbmUgPSAkKCcjb3RwX3Bob25lJykudmFsKCk7XG4gIHZhciBjb3VudHJ5Q29kZSA9ICQoJyNvdHBfY291bnRyeScpLnZhbCgpO1xuICB2YXIgYnRuID0gJyNidG5fY29uZmlybV9vdHAnO1xuXG5cbiAgaWYgKG90cCAhPSAnJyAmJiBvdHAubGVuZ3RoID09IDQpIHtcbiAgICB3aW5kb3cuc2lnbk1vZGFsLnN0YXJ0TG9hZGluZygpO1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvY29uZmlybS1vdHAnLFxuICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgZGF0YTogeyBjb3VudHJ5X2NvZGU6IGNvdW50cnlDb2RlLCBwaG9uZV9udW1iZXI6IHBob25lLCBvdHBfY29kZTogb3RwIH0sXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgciA9ICQucGFyc2VKU09OKGRhdGEpO1xuICAgICAgICB2YXIgTXNnQ2xhc3MgPSAoci5lcnJvcikgPyAnaXMtZmFpbGVkJyA6ICdpcy1zdWNjZXNzZnVsJztcbiAgICAgICAgd2luZG93LnNpZ25Nb2RhbC5zdG9wTG9hZGluZygpO1xuICAgICAgICBzaG93U2lnbk1lc3NhZ2Uoci5tc2csIE1zZ0NsYXNzKTtcbiAgICAgICAgaWYgKCFyLmVycm9yKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc2hvd1NpZ25NZXNzYWdlKCdFbnRlciA0IGRpZ2l0cyBPVFAnLCAnaXMtZmFpbGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZW5kT3RwKCkge1xuICB2YXIgcGhvbmUgPSAkKCcjb3RwX3Bob25lJykudmFsKCk7XG4gIHZhciBjb3VudHJ5Q29kZSA9ICQoJyNvdHBfY291bnRyeScpLnZhbCgpO1xuICB2YXIgYnRuID0gJyNyZXNlbmQtb3RwLWJ0bic7XG4gIHdpbmRvdy5zaWduTW9kYWwuc3RhcnRMb2FkaW5nKCk7XG4gICQuYWpheCh7XG4gICAgdXJsOiAnL3Jlc2VuZC1vdHAnLFxuICAgIHR5cGU6ICdQT1NUJyxcbiAgICBkYXRhOiB7IGNvdW50cnlfY29kZTogY291bnRyeUNvZGUsIHBob25lX251bWJlcjogcGhvbmUgfSxcbiAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIHIgPSAkLnBhcnNlSlNPTihkYXRhKTtcbiAgICAgIHZhciBNc2dDbGFzcyA9IChyLmVycm9yKSA/ICdpcy1mYWlsZWQnIDogJ2lzLXN1Y2Nlc3NmdWwnO1xuICAgICAgd2luZG93LnNpZ25Nb2RhbC5zdG9wTG9hZGluZygpO1xuICAgICAgc2hvd1NpZ25NZXNzYWdlKHIubXNnLCBNc2dDbGFzcyk7XG4gICAgfVxuICB9KVxufVxuXG53aW5kb3cuaW5pdFZhbGlkYXRvcnMgPSBpbml0VmFsaWRhdG9yc1xud2luZG93LnJlc2V0QnRuU3RhdGVzID0gcmVzZXRCdG5TdGF0ZXNcbndpbmRvdy5zaG93QWx0ZXJuYXRpdmVCdG5UZXh0ID0gc2hvd0FsdGVybmF0aXZlQnRuVGV4dFxud2luZG93LnJlc2V0U2lnbk1lc3NhZ2UgPSByZXNldFNpZ25NZXNzYWdlXG53aW5kb3cuc2hvd1NpZ25NZXNzYWdlID0gc2hvd1NpZ25NZXNzYWdlXG53aW5kb3cuY29uZmlybUxvZ2luT3RwID0gY29uZmlybUxvZ2luT3RwXG53aW5kb3cucmVzZW5kT3RwID0gcmVzZW5kT3RwXG5cbndpbmRvdy5QYXJzbGV5Lm9uKCdmb3JtOnN1Ym1pdCcsIGZ1bmN0aW9uICgpIHtcbiAgLy9jb25zb2xlLmxvZyhcInN1Ym1pdCBmb3JtXCIpO1xuICB2YXIgZm9ybSA9ICQodGhpcy4kZWxlbWVudFswXSk7XG4gIHZhciB1cmwgPSBmb3JtLmF0dHIoJ2FjdGlvbicpO1xuICB2YXIgYnRuID0gZm9ybS5maW5kKFwiLmpzLWxvYWRpbmctYnRuXCIpO1xuICAkLmFqYXgoe1xuICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgIHVybDogdXJsLFxuICAgIGRhdGE6IGZvcm0uc2VyaWFsaXplKCksIC8vIHNlcmlhbGl6ZXMgdGhlIGZvcm0ncyBlbGVtZW50cy5cbiAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIHIgPSAkLnBhcnNlSlNPTihkYXRhKTtcbiAgICAgIGlmICghci5lcnJvcikge1xuICAgICAgICAvL3Nob3cgc3VjY2VzcyBzdGF0ZSBvbiBidXR0b24gYW5kIHJldHVybiBtZXNzYWdlIGluIHIubXNnXG4gICAgICAgIHNob3dTaWduTWVzc2FnZShyLm1zZywgJ2lzLXN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChyLmxpbmsgIT0gdW5kZWZpbmVkICYmIHIubGluayAhPSAnJykge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSByLmxpbms7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9zaG93IGZhaWxlZCBzdGF0ZSBvbiBidXR0b24gYW5kIHJldHVybiBtZXNzYWdlIGluIHIubXNnXG4gICAgICAgIHNob3dTaWduTWVzc2FnZShyLm1zZywgJ2lzLWZhaWxlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmYWxzZTtcbn0pO1xuXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICQoJyNidG5fY29uZmlybV9vdHAnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uZmlybUxvZ2luT3RwKCk7XG4gIH0pO1xuICAkKCcjcmVzZW5kLW90cC1idG4nKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgcmVzZW5kT3RwKCk7XG4gIH0pO1xuICAkKCcjZnJtX2xvZ2luX290cCcpLm9uKCdzdWJtaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBwaG9uZUZpZWxkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Bob25lX2lucHV0X0xvZ2luJyk7XG4gICAgdmFyIGl0aSA9IHdpbmRvdy5pbnRsVGVsSW5wdXRHbG9iYWxzLmdldEluc3RhbmNlKHBob25lRmllbGQpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgZnVsbFBob25lID0gaXRpLmdldE51bWJlcigpO1xuICAgIHZhciBjb3VudHJ5Q29kZSA9ICcrJyArIGl0aS5nZXRTZWxlY3RlZENvdW50cnlEYXRhKCkuZGlhbENvZGU7XG4gICAgdmFyIHBob25lID0gZnVsbFBob25lLnJlcGxhY2UoY291bnRyeUNvZGUsICcnKTtcbiAgICB2YXIgYnRuID0gJChlLnRhcmdldCkuZmluZChcIi5qcy1sb2FkaW5nLWJ0blwiKTtcbiAgICAkKCcjb3RwX3Bob25lJykudmFsKHBob25lKTtcbiAgICAkKCcjb3RwX2NvdW50cnknKS52YWwoY291bnRyeUNvZGUpO1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvc2VuZC1vdHAnLFxuICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgZGF0YTogeyBjb3VudHJ5X2NvZGU6IGNvdW50cnlDb2RlLCBwaG9uZV9udW1iZXI6IHBob25lIH0sXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgciA9ICQucGFyc2VKU09OKGRhdGEpO1xuICAgICAgICB2YXIgTXNnQ2xhc3MgPSAoci5lcnJvcikgPyAnaXMtZmFpbGVkJyA6ICdpcy1zdWNjZXNzZnVsJztcbiAgICAgICAgc2hvd1NpZ25NZXNzYWdlKHIubXNnLCBNc2dDbGFzcyk7XG4gICAgICAgIGlmICghci5lcnJvcikge1xuICAgICAgICAgICQoJy5zaWduLW1vZGFsX19waG9uZS1zcGFuJykuaHRtbChmdWxsUGhvbmUpO1xuICAgICAgICAgIHdpbmRvdy5zaWduTW9kYWwuc3dpdGNoKCdvdHAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pOyIsImNvbnN0IGJvb2tNb2RhbCA9IHtcbiAgc3RlcDogMSxcbiAgYXBwdERhdGE6IHt9LFxuXG4gIHJvb3Q6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ib29rLXNlbGwnKSxcbiAgYmFja2Ryb3A6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ib29rLXNlbGxfX2JhY2tkcm9wJyksXG4gIGNvbnRhaW5lcjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmJvb2stc2VsbF9fY29udGFpbmVyJyksXG5cbiAgZXZ0TmV4dFN0ZXA6ICQoJ1tkYXRhLWV2dD1cImJvb2tNb2RhbE5leHRcIl0nKSxcbiAgZXZ0QmFja1N0ZXA6ICQoJ1tkYXRhLWV2dD1cImJvb2tNb2RhbEJhY2tcIl0nKSxcbiAgZXZ0VG9nZ2xlOiAkKCdbZGF0YS1ldnQ9XCJ0b2dnbGVCb29rTW9kYWxcIl0nKSxcblxuICBzZWN0aW9uRGF0ZTogJCgnI2Jvb2tTZWN0aW9uRGF0ZScpLFxuICBzZWN0aW9uUGVyc29uYWw6ICQoJyNib29rU2VjdGlvblBlcnNvbmFsJyksXG4gIHNlY3Rpb25Db25maXJtOiAkKCcjYm9va1NlY3Rpb25Db25maXJtJyksXG5cbiAgaW5wdXROYW1lOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm9va0Z1bGxOYW1lJyksXG4gIGlucHV0RW1haWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib29rRW1haWwnKSxcbiAgaW5wdXRQaG9uZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Jvb2tQaG9uZScpLFxuICBpbnB1dEFycjogW3RoaXMuaW5wdXROYW1lLCB0aGlzLmlucHV0RW1haWwsIHRoaXMuaW5wdXRQaG9uZV0sXG5cbiAgY29uZmlybU5hbWU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib29rQ29uZmlybU5hbWUnKSxcbiAgY29uZmlybUVtYWlsOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm9va0NvbmZpcm1FbWFpbCcpLFxuICBjb25maXJtUGhvbmU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib29rQ29uZmlybVBob25lJyksXG4gIGNvbmZpcm1EYXRlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm9va0NvbmZpcm1EYXRlJyksXG4gIGNvbmZpcm1UaW1lOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm9va0NvbmZpcm1UaW1lJyksXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnJvb3QgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZGF0ZVRpbWUuaW5pdCgpXG4gICAgICB0aGlzLmF0dGFjaEV2ZW50cygpXG4gICAgfVxuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdW5sb2NrU2Nyb2xsKClcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWCgxMDAlKSdcbiAgICB0aGlzLmJhY2tkcm9wLnN0eWxlLm9wYWNpdHkgPSAwXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJvb3Quc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMuY29udGFpbmVyKSk7XG4gIH0sXG4gIG9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoISQoJy5ib29rLXNlbGxfX2RhdGUtYm94JykubGVuZ3RoKSB7IGJvb2tNb2RhbC5kYXRlVGltZS5hcHBlbmRCb3hlcyhib29rTW9kYWwuZGF0ZVRpbWUuZ2V0RGF0ZXModHJ1ZSkpIH1cbiAgICBsb2NrU2Nyb2xsKClcbiAgICB0aGlzLnJvb3Quc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKDAlKSdcbiAgICAgIHRoaXMuYmFja2Ryb3Auc3R5bGUub3BhY2l0eSA9IDFcbiAgICB9LCAxKTtcbiAgfSxcbiAgdG9nZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMucm9vdCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpICE9PSAnbm9uZScpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH1cbiAgfSxcbiAgYXR0YWNoRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ldnRUb2dnbGUuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgYm9va01vZGFsLnRvZ2dsZSgpXG4gICAgfSlcbiAgICB0aGlzLmV2dE5leHRTdGVwLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHN3aXRjaCAoYm9va01vZGFsLnN0ZXApIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChib29rTW9kYWwuYXBwdERhdGEuZGF0ZSkge1xuICAgICAgICAgICAgYm9va01vZGFsLnN0ZXAgPSAyXG4gICAgICAgICAgICBib29rTW9kYWwuc2VjdGlvbkRhdGUuaGlkZSgpXG4gICAgICAgICAgICBib29rTW9kYWwuc2VjdGlvblBlcnNvbmFsLnNob3coKVxuICAgICAgICAgICAgYm9va01vZGFsLm9ic2VydmVyKClcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpZiAoYm9va01vZGFsLmlucHV0TmFtZS52YWx1ZSAmJiBib29rTW9kYWwuaW5wdXRFbWFpbC52YWx1ZSAmJiBib29rTW9kYWwuaW5wdXRQaG9uZS52YWx1ZSkge1xuICAgICAgICAgICAgYm9va01vZGFsLnN0ZXAgPSAzXG4gICAgICAgICAgICBib29rTW9kYWwuc2VjdGlvblBlcnNvbmFsLmhpZGUoKVxuICAgICAgICAgICAgYm9va01vZGFsLnNlY3Rpb25Db25maXJtLnNob3coKVxuICAgICAgICAgICAgYm9va01vZGFsLmFwcHREYXRhLm5hbWUgPSBib29rTW9kYWwuaW5wdXROYW1lLnZhbHVlXG4gICAgICAgICAgICBib29rTW9kYWwuYXBwdERhdGEuZW1haWwgPSBib29rTW9kYWwuaW5wdXRFbWFpbC52YWx1ZVxuICAgICAgICAgICAgYm9va01vZGFsLmFwcHREYXRhLnBob25lID0gYm9va01vZGFsLmlucHV0UGhvbmUudmFsdWVcbiAgICAgICAgICAgIGJvb2tNb2RhbC5hcHB0RGF0YS51cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgICAgICAgIGJvb2tNb2RhbC5vYnNlcnZlcigpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgYm9va01vZGFsLmFwcHREYXRhLmRhdGVfZGF5ID0gJCgnI2Jvb2tDb25maXJtRGF0ZScpLnRleHQoKTtcbiAgICAgICAgICBib29rTW9kYWwuYXBwdERhdGEudGltZSA9ICQoJyNib29rQ29uZmlybVRpbWUnKS50ZXh0KCk7XG4gICAgICAgICAgLy9hbGVydChKU09OLnN0cmluZ2lmeShib29rTW9kYWwuYXBwdERhdGEpKSAvLyBjaGFuZ2UgbGF0ZXJcbiAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiAnL2pzb24vYm9vay1hcHBvaW50bWVudCcsXG4gICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICBkYXRhOiB7IGpzb246IEpTT04uc3RyaW5naWZ5KGJvb2tNb2RhbC5hcHB0RGF0YSkgfSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIGJvb2tNb2RhbC5jbG9zZSgpXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGJvb2tNb2RhbC5yZXNldCgpXG4gICAgICAgICAgICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKGJvb2tNb2RhbC5jb250YWluZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5ldnRCYWNrU3RlcC5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBzd2l0Y2ggKGJvb2tNb2RhbC5zdGVwKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBib29rTW9kYWwuY2xvc2UoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgLS1ib29rTW9kYWwuc3RlcFxuICAgICAgICAgIGJvb2tNb2RhbC5vYnNlcnZlcigpXG4gICAgICAgICAgYm9va01vZGFsLnNlY3Rpb25QZXJzb25hbC5oaWRlKClcbiAgICAgICAgICBib29rTW9kYWwuc2VjdGlvbkRhdGUuc2hvdygpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAtLWJvb2tNb2RhbC5zdGVwXG4gICAgICAgICAgYm9va01vZGFsLm9ic2VydmVyKClcbiAgICAgICAgICBib29rTW9kYWwuc2VjdGlvbkNvbmZpcm0uaGlkZSgpXG4gICAgICAgICAgYm9va01vZGFsLnNlY3Rpb25QZXJzb25hbC5zaG93KClcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KVxuICAgIGNvbnN0IGF0dGFjaElucHV0T2Jlc3J2ZXIgPSAoKSA9PiB7XG4gICAgICBsZXQgYXJyID0gW2Jvb2tNb2RhbC5pbnB1dE5hbWUsIGJvb2tNb2RhbC5pbnB1dEVtYWlsLCBib29rTW9kYWwuaW5wdXRQaG9uZV1cbiAgICAgIGFyci5mb3JFYWNoKChlbCkgPT4geyBlbC5vbmlucHV0ID0gKCkgPT4geyBib29rTW9kYWwub2JzZXJ2ZXIoKSB9IH0pXG4gICAgfVxuICAgIGF0dGFjaElucHV0T2Jlc3J2ZXIoKVxuICB9LFxuXG4gIGRhdGVUaW1lOiB7XG4gICAgaW50ZXJ2YWxzOiBbWzExLCAwbzAsIDBvMF0sIFsxMywgMzAsIDBvMF0sIFsxNSwgMzAsIDBvMF0sIFsxNiwgMG8wLCAwbzBdLCBbMTYsIDMwLCAwbzBdXSxcbiAgICBkYXlzUGVyVmlldzogMyxcbiAgICBob2xkZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib29rU2VsbERhdGVzJyksXG5cbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmF0dGFjaEV2ZW50cygpXG4gICAgICB0aGlzLmFwcGVuZEJveGVzKHRoaXMuZ2V0RGF0ZXModHJ1ZSkpXG4gICAgfSxcbiAgICByZW5kZXJIVE1MOiAoZGF0ZSkgPT4ge1xuICAgICAgY29uc3Qgd2Vla2RheSA9IGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHsgd2Vla2RheTogJ2xvbmcnIH0pLCBkYXkgPSBkYXRlLmdldERhdGUoKSwgbW9udGggPSBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7IG1vbnRoOiAnc2hvcnQnIH0pLCB0aW1lID0gZGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcoJ2VuLVVTJywgeyBob3VyOiAnbnVtZXJpYycsIGhvdXIxMjogdHJ1ZSwgbWludXRlOiAnbnVtZXJpYycgfSlcblxuICAgICAgbGV0IGlmUGFzdCA9IG5ldyBEYXRlKCkgPiBkYXRlID8gJyBkaXNhYmxlZCcgOiAnJ1xuICAgICAgbGV0IGRheVRpbWUgPSBkYXRlLmdldERheSgpID09IDYgPyAnQ2xvc2VkJyA6IGRhdGUuZ2V0RGF5KCkgPT0gMCA/ICdDbG9zZWQnIDogdGltZVxuICAgICAgbGV0IGlzV2Vla2VuZCA9IGRhdGUuZ2V0RGF5KCkgPT0gNiA/ICcgaXMtY2xvc2VkJyA6IGRhdGUuZ2V0RGF5KCkgPT0gMCA/ICcgaXMtY2xvc2VkJyA6ICcnXG5cbiAgICAgIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwiYm9vay1zZWxsX19kYXRlLWJveCR7aXNXZWVrZW5kfVwiIGRhdGEtdGltZT1cIiR7U3RyaW5nKGRhdGUpfVwiJHtpZlBhc3R9PlxuICAgICAgICA8c3Bhbj4ke3dlZWtkYXl9LCAke2RheX0ke2dldE9yZGluYWxUeHQoZGF5KX0gJHttb250aH08L3NwYW4+XG4gICAgICAgIDxzcGFuPiR7ZGF5VGltZX08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICAgIGBcbiAgICB9LFxuICAgIGFwcGVuZEJveGVzOiBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICBhcnIuZm9yRWFjaCgoZWwpID0+IHRoaXMuaG9sZGVyLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgZWwpKVxuICAgIH0sXG4gICAgZ2V0RGF0ZXM6IGZ1bmN0aW9uIChpc05leHQpIHtcbiAgICAgIGxldCBkYXlzQXJyID0gW10sIGluaXRpYWwgPSAwXG4gICAgICBsZXQgYXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5ib29rLXNlbGxfX2RhdGUtYm94JyldXG4gICAgICBsZXQgaW5pdGlhbERhdGVcblxuICAgICAgaWYgKGFyci5sZW5ndGggPT0gMCkge1xuICAgICAgICBpbml0aWFsRGF0ZSA9IG5ldyBEYXRlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc05leHQgPT0gdHJ1ZSkge1xuICAgICAgICAgIGluaXRpYWxEYXRlID0gbmV3IERhdGUoYXJyW2Fyci5sZW5ndGggLSAxXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGltZScpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluaXRpYWxEYXRlID0gbmV3IERhdGUoYXJyWzBdLmdldEF0dHJpYnV0ZSgnZGF0YS10aW1lJykpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgYXJyLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpO1xuICAgICAgICBpZiAoaXNOZXh0ID09IHRydWUpIHtcbiAgICAgICAgICBpbml0aWFsRGF0ZS5zZXREYXRlKGluaXRpYWxEYXRlLmdldERhdGUoKSArIDEpXG4gICAgICAgIH0gZWxzZSB7IGluaXRpYWxEYXRlLnNldERhdGUoaW5pdGlhbERhdGUuZ2V0RGF0ZSgpIC0gMSkgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaW5pdGlhbCAhPT0gdGhpcy5kYXlzUGVyVmlldykge1xuICAgICAgICBsZXQgZGF5RGF0ZSA9IG5ldyBEYXRlKGluaXRpYWxEYXRlKVxuICAgICAgICBpZiAoaXNOZXh0ID09IHRydWUpIHsgZGF5c0Fyci5wdXNoKG5ldyBEYXRlKGRheURhdGUuc2V0RGF0ZShpbml0aWFsRGF0ZS5nZXREYXRlKCkgKyBpbml0aWFsKSkpIH0gZWxzZSB7XG4gICAgICAgICAgZGF5c0Fyci5wdXNoKG5ldyBEYXRlKGRheURhdGUuc2V0RGF0ZShpbml0aWFsRGF0ZS5nZXREYXRlKCkgLSBpbml0aWFsKSkpXG4gICAgICAgIH1cbiAgICAgICAgKytpbml0aWFsXG4gICAgICB9XG5cbiAgICAgIGxldCBpbnRzID0gaXNOZXh0ID09IHRydWUgPyB0aGlzLmludGVydmFscyA6IHRoaXMuaW50ZXJ2YWxzLnNsaWNlKCkucmV2ZXJzZSgpXG5cbiAgICAgIGxldCBodG1sQXJyID0gZGF5c0Fyci5yZWR1Y2UoKGFjYywgZGF0ZSkgPT4ge1xuICAgICAgICBpbnRzLmZvckVhY2goKGludGVydmFsKSA9PiB7XG4gICAgICAgICAgbGV0IHRoaXNEYXRlID0gbmV3IERhdGUoZGF0ZSlcbiAgICAgICAgICB0aGlzRGF0ZS5zZXRIb3VycyguLi5pbnRlcnZhbClcbiAgICAgICAgICBhY2MucHVzaCh0aGlzLnJlbmRlckhUTUwodGhpc0RhdGUpKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gYWNjXG4gICAgICB9LCBbXSlcblxuICAgICAgaWYgKGlzTmV4dCA9PSB0cnVlKSB7IHJldHVybiBodG1sQXJyIH0gZWxzZSB7IHJldHVybiBodG1sQXJyLnJldmVyc2UoKSB9XG4gICAgfSxcbiAgICBhdHRhY2hFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICQoJ1tkYXRhLXN3aXRjaC10aW1lXScpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGF0dHIgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtc3dpdGNoLXRpbWUnKVxuICAgICAgICBzd2l0Y2ggKGF0dHIpIHtcbiAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgIGJvb2tNb2RhbC5kYXRlVGltZS5hcHBlbmRCb3hlcyhib29rTW9kYWwuZGF0ZVRpbWUuZ2V0RGF0ZXModHJ1ZSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwcmV2JzpcbiAgICAgICAgICAgIGlmIChbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJvb2stc2VsbF9fZGF0ZS1ib3gnKV1bMF0pXG4gICAgICAgICAgICAgIGJvb2tNb2RhbC5kYXRlVGltZS5hcHBlbmRCb3hlcyhib29rTW9kYWwuZGF0ZVRpbWUuZ2V0RGF0ZXMoZmFsc2UpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnLmJvb2stc2VsbF9fZGF0ZS1ib3gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcyhJU19BQ1RJVkUpLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoSVNfQUNUSVZFKVxuICAgICAgICAgIGJvb2tNb2RhbC5vYnNlcnZlcigpXG4gICAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIG9ic2VydmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0ZXApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgbGV0IGFjdGl2ZURhdGUgPSAkKCcuYm9vay1zZWxsX19kYXRlLWJveCcpLmZpbHRlcihgLiR7SVNfQUNUSVZFfWApXG4gICAgICAgIGlmIChhY3RpdmVEYXRlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYXBwdERhdGEuZGF0ZSA9IG5ldyBEYXRlKGFjdGl2ZURhdGUuYXR0cignZGF0YS10aW1lJykpXG4gICAgICAgICAgdGhpcy5ldnROZXh0U3RlcC5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmFwcHREYXRhLmRhdGVcbiAgICAgICAgICB0aGlzLmV2dE5leHRTdGVwLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXROYW1lLnZhbHVlICYmIHRoaXMuaW5wdXRFbWFpbC52YWx1ZSAmJiB0aGlzLmlucHV0UGhvbmUudmFsdWUgJiYgdGhpcy5hcHB0RGF0YS5kYXRlKSB7XG4gICAgICAgICAgdGhpcy5ldnROZXh0U3RlcC5hdHRyKCdkaXNhYmxlZCcsIGZhbHNlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZXZ0TmV4dFN0ZXAuYXR0cignZGlzYWJsZWQnLCB0cnVlKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB0aGlzLmNvbmZpcm1OYW1lLmlubmVySFRNTCA9IHRoaXMuYXBwdERhdGEubmFtZVxuICAgICAgICB0aGlzLmNvbmZpcm1FbWFpbC5pbm5lckhUTUwgPSB0aGlzLmFwcHREYXRhLmVtYWlsXG4gICAgICAgIHRoaXMuY29uZmlybVBob25lLmlubmVySFRNTCA9IHRoaXMuYXBwdERhdGEucGhvbmVcbiAgICAgICAgdGhpcy5jb25maXJtRGF0ZS5pbm5lckhUTUwgPSBgJHt0aGlzLmFwcHREYXRhLmRhdGUuZ2V0RGF0ZSgpfSR7Z2V0T3JkaW5hbFR4dCh0aGlzLmFwcHREYXRhLmRhdGUuZ2V0RGF0ZSgpKX0gJHt0aGlzLmFwcHREYXRhLmRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHsgbW9udGg6ICdsb25nJyB9KX1gXG4gICAgICAgIHRoaXMuY29uZmlybVRpbWUuaW5uZXJIVE1MID0gdGhpcy5hcHB0RGF0YS5kYXRlLnRvTG9jYWxlVGltZVN0cmluZygnZW4tVVMnLCB7IGhvdXI6ICdudW1lcmljJywgaG91cjEyOiB0cnVlLCBtaW51dGU6ICdudW1lcmljJyB9KVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgYm9va01vZGFsLnN0ZXAgPSAxXG4gICAgbGV0IGlucHV0QXJyID0gW3RoaXMuaW5wdXROYW1lLCB0aGlzLmlucHV0RW1haWwsIHRoaXMuaW5wdXRQaG9uZV1cbiAgICBpbnB1dEFyci5mb3JFYWNoKChlbCkgPT4geyBlbC52YWx1ZSA9ICcnIH0pXG4gICAgJCgnLmJvb2stc2VsbF9fZGF0ZS1ib3gnKS5yZW1vdmVDbGFzcyhJU19BQ1RJVkUpXG4gICAgYm9va01vZGFsLnNlY3Rpb25Db25maXJtLmhpZGUoKVxuICAgIGJvb2tNb2RhbC5zZWN0aW9uUGVyc29uYWwuaGlkZSgpXG4gICAgYm9va01vZGFsLnNlY3Rpb25EYXRlLnNob3coKVxuICAgIE9iamVjdC52YWx1ZXMoYm9va01vZGFsLmFwcHREYXRhKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZGVsZXRlIGVsXG4gICAgfSlcbiAgICAkKCcuYm9vay1zZWxsX19kYXRlLWJveCcpLnJlbW92ZSgpXG4gICAgYm9va01vZGFsLm9ic2VydmVyKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJvb2tNb2RhbCIsImNvbnN0IGNhcnRNb2RhbCA9IG5ldyBPYmplY3Qoe1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW5kZXJET00oKVxuICAgIHRoaXMuYmluZFRvZ2dsZSgpXG4gIH0sXG4gIHJlbmRlckRPTTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuXyA9ICQoXCIuY2FydC1tb2RhbFwiKTtcbiAgICB0aGlzLmJhY2tkcm9wID0gdGhpcy5fLmZpbmQoXCIuY2FydC1tb2RhbF9fYmFja2Ryb3BcIik7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLl8uZmluZChcIi5jYXJ0LW1vZGFsX19jb250YWluZXJcIik7XG4gICAgdGhpcy5ldnRUb2dnbGUgPSBnZXRFdnRET00oXCJ0b2dnbGVDYXJ0XCIpO1xuICB9LFxuICBiaW5kVG9nZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJ1tkYXRhLWV2dD1cInRvZ2dsZUNhcnRcIl0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZWwgPSAkKFwiLmNhcnQtbW9kYWxcIilcbiAgICAgIGlmIChlbC5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9ICQoXCIuY2FydC1tb2RhbF9fY29udGFpbmVyXCIpLFxuICAgICAgICAgIGJhY2tkcm9wID0gJChcIi5jYXJ0LW1vZGFsX19iYWNrZHJvcFwiKVxuICAgICAgICBpZiAoZWxlbURpc3BsYXllZChlbCkpIHtcbiAgICAgICAgICB1bmxvY2tTY3JvbGwoKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGJhY2tkcm9wWzBdLnN0eWxlLCB7IG9wYWNpdHk6IDAgfSk7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihjb250YWluZXJbMF0uc3R5bGUsIHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoMTAwJSlcIiB9KTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGVsLmhpZGUoKTtcbiAgICAgICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZShjb250YWluZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NrU2Nyb2xsKCk7XG4gICAgICAgICAgZWwuc2hvdygpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihiYWNrZHJvcFswXS5zdHlsZSwgeyBvcGFjaXR5OiAxIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjb250YWluZXJbMF0uc3R5bGUsIHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoMCUpXCIgfSk7XG4gICAgICAgICAgfSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICB0b2dnbGU6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgZWwgPSBjYXJ0TW9kYWwuXztcbiAgICBpZiAoZWwubGVuZ3RoKSB7XG4gICAgICBpZiAoZWxlbURpc3BsYXllZChlbCkpIHtcbiAgICAgICAgY2FydE1vZGFsLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJ0TW9kYWwub3BlbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgIGxvY2tTY3JvbGwoKTtcbiAgICB0aGlzLl8uc2hvdygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmJhY2tkcm9wWzBdLnN0eWxlLCB7IG9wYWNpdHk6IDEgfSk7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMuY29udGFpbmVyWzBdLnN0eWxlLCB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVYKDAlKVwiIH0pO1xuICAgIH0sIDEpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHVubG9ja1Njcm9sbCgpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5iYWNrZHJvcFswXS5zdHlsZSwgeyBvcGFjaXR5OiAwIH0pO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb250YWluZXJbMF0uc3R5bGUsIHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoMTAwJSlcIiB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuXy5oaWRlKCk7XG4gICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUoY2FydE1vZGFsLmNvbnRhaW5lcikpO1xuICB9LFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBjYXJ0TW9kYWwiLCJjb25zdCBjdXJyZW5jeU1vZGFsID0gbmV3IE9iamVjdCh7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbmRlckRPTSgpO1xuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICB9LFxuICByZW5kZXJET006IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl8gPSAkKFwiLmN1ci1tb2RhbFwiKTtcbiAgICB0aGlzLmJhY2tkcm9wID0gdGhpcy5fLmZpbmQoXCIuY3VyLW1vZGFsX19iYWNrZHJvcFwiKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuXy5maW5kKFwiLmN1ci1tb2RhbF9fY29udGFpbmVyXCIpO1xuICAgIHRoaXMuZXZ0VG9nZ2xlID0gZ2V0RXZ0RE9NKFwidG9nZ2xlQ3VycmVuY3lcIik7XG4gICAgdGhpcy5pbnB1dCA9IHRoaXMuXy5maW5kKFwiaW5wdXRcIik7XG4gIH0sXG4gIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3VycmVuY3lNb2RhbC5ldnRUb2dnbGUubGVuZ3RoKSB7XG4gICAgICAkLmVhY2goY3VycmVuY3lNb2RhbC5ldnRUb2dnbGUsIChpKSA9PiB7XG4gICAgICAgIGN1cnJlbmN5TW9kYWwuZXZ0VG9nZ2xlW2ldLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgY3VycmVuY3lNb2RhbC50b2dnbGUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW5jeU1vZGFsLmlucHV0Lmxlbmd0aCkge1xuICAgICAgY3VycmVuY3lNb2RhbC5pbnB1dC5vbihcImtleXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVuY3lNb2RhbC5pbnRyYVNlYXJjaCgkKHRoaXMpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgdG9nZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pbnB1dC52YWwoXCJcIikudHJpZ2dlcihcImtleXVwXCIpO1xuICAgIGxldCBtb2RhbCA9IGN1cnJlbmN5TW9kYWwuXztcbiAgICBpZiAobW9kYWwubGVuZ3RoKSB7XG4gICAgICBpZiAoZWxlbURpc3BsYXllZChtb2RhbCkpIHtcbiAgICAgICAgY3VycmVuY3lNb2RhbC5jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVuY3lNb2RhbC5vcGVuKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBvcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgbG9ja1Njcm9sbCgpO1xuICAgIHRoaXMuXy5zaG93KCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmJhY2tkcm9wLmNzcyh7IG9wYWNpdHk6IDEgfSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jc3MoeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWCgwJSlcIiB9KTtcbiAgICB9LCAxKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB1bmxvY2tTY3JvbGwoKTtcbiAgICB0aGlzLmJhY2tkcm9wLmNzcyh7IG9wYWNpdHk6IDAgfSk7XG4gICAgdGhpcy5jb250YWluZXIuY3NzKHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoMTAwJSlcIiB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuXy5oaWRlKCk7XG4gICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUoY3VycmVuY3lNb2RhbC5iYWNrZHJvcCkpO1xuICB9LFxuICBpbnRyYVNlYXJjaDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgbGV0IHZhbCA9IGlucHV0LnZhbCgpLnRvTG93ZXJDYXNlKCksXG4gICAgICBhcnIgPSBbLi4uJChcIi5jdXItaXRlbVwiKV07XG4gICAgJC5lYWNoKGFyciwgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBsZXQgdHh0ID0gJChhcnJbaW5kZXhdKS5maW5kKFwiLmN1ci1pdGVtX19uYW1lXCIpLnRleHQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKH50eHQuaW5kZXhPZih2YWwpKSB7XG4gICAgICAgICQoYXJyW2luZGV4XSkuc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJChhcnJbaW5kZXhdKS5oaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IGN1cnJlbmN5TW9kYWwiLCJjb25zdCBtYWlsTW9kYWwgPSBuZXcgT2JqZWN0KHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyRE9NKClcbiAgICBpZiAodGhpcy5tb2RhbC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpXG4gICAgfVxuICB9LFxuICByZW5kZXJET006IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1vZGFsID0gJCgnLm1haWwtbW9kYWwnKVxuICAgIHRoaXMuYmFja2Ryb3AgPSAkKCcubWFpbC1tb2RhbF9fYmFja2Ryb3AnKVxuICAgIHRoaXMuY29udGFpbmVyID0gJCgnLm1haWwtbW9kYWxfX2NvbnRhaW5lcicpXG4gICAgdGhpcy5ldnRDbG9zZSA9ICQoJ1tkYXRhLW1haWwtbW9kYWw9XCJjbG9zZVwiXScpXG4gIH0sXG4gIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmV2dENsb3NlLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHsgbWFpbE1vZGFsLmNsb3NlKCkgfSlcbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgIGxvY2tTY3JvbGwoKVxuICAgIHRoaXMubW9kYWwuc2hvdygpXG4gICAgdGhpcy5tb2RhbC5maW5kKCdpbnB1dCcpLmZvY3VzKClcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMubW9kYWwuYWRkQ2xhc3MoX19BQ1RJVkUpXG4gICAgfSwgNSk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdW5sb2NrU2Nyb2xsKClcbiAgICB0aGlzLm1vZGFsLnJlbW92ZUNsYXNzKF9fQUNUSVZFKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5tb2RhbC5oaWRlKClcbiAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmNvbnRhaW5lcikpO1xuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1haWxNb2RhbCIsImNsYXNzIE1lbnUge1xuICBjb25zdHJ1Y3Rvcihyb290U2VsZWN0b3IgPSAnLm1lbnUnKSB7XG4gICAgdGhpcy5fc3RhdGUgPSBmYWxzZVxuICAgIHRoaXMub3ZlclN0YXRlID0gZmFsc2VcbiAgICB0aGlzLnJvb3RFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdFNlbGVjdG9yKVxuXG4gICAgaWYgKCF0aGlzLnJvb3RFbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jb250ZW50TGlzdCA9IHRoaXMucm9vdEVsLnF1ZXJ5U2VsZWN0b3IoJy5tZW51X19jb250ZW50LWxpc3QnKVxuICAgIHRoaXMub3Zlckxpc3QgPSB0aGlzLnJvb3RFbC5xdWVyeVNlbGVjdG9yKCcubWVudV9fb3Zlci1saXN0JylcbiAgICB0aGlzLnN1Ykxpc3RBcnIgPSBbLi4udGhpcy5yb290RWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbWVudS1saXN0XScpXVxuICAgIHRoaXMuYWN0aXZlTGlzdE5hbWUgPSB0aGlzLnJvb3RFbC5xdWVyeVNlbGVjdG9yKCcjYWN0aXZlTGlzdE5hbWUnKVxuXG4gICAgdGhpcy5pbml0KClcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVcbiAgfVxuXG4gIHNldCBzdGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuX3N0YXRlID0gdmFsdWVcbiAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgIHRoaXMub3Blbih0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlKHRydWUpXG4gICAgfVxuICB9XG5cbiAgb3Blbihmcm9tU2V0dGVyID0gZmFsc2UpIHtcbiAgICBpZiAoIWZyb21TZXR0ZXIpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMucm9vdEVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsb2NrU2Nyb2xsKClcbiAgICAgIHRoaXMucm9vdEVsLmNsYXNzTGlzdC5hZGQoX19BQ1RJVkUpXG4gICAgICB3aW5kb3cubWVudUJhY2tkcm9wID0gbmV3IEJhY2tkcm9wKHtcbiAgICAgICAgaGFsZjogdHJ1ZSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHsgdGhpcy5jbG9zZSgpIH1cbiAgICAgIH0pXG4gICAgfSwgNSk7XG4gIH1cblxuICBjbG9zZShmcm9tU2V0dGVyID0gZmFsc2UpIHtcbiAgICBpZiAoIWZyb21TZXR0ZXIpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAod2luZG93Lm1lbnVCYWNrZHJvcCkge1xuICAgICAgd2luZG93Lm1lbnVCYWNrZHJvcC5oaWRlKHRydWUpXG4gICAgfVxuXG4gICAgdW5sb2NrU2Nyb2xsKClcbiAgICB0aGlzLnJvb3RFbC5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuXG4gICAgaWYgKHRoaXMub3ZlclN0YXRlKSB7XG4gICAgICB0aGlzLmNsb3NlT3Zlckxpc3QoKVxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jb250ZW50TGlzdC5zY3JvbGxUb3AgPSAwXG4gICAgICB0aGlzLnJvb3RFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUodGhpcy5yb290RWwpKTtcbiAgfVxuXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnN0YXRlID0gIXRoaXMuc3RhdGVcbiAgfVxuXG4gIG9wZW5PdmVyTGlzdCgpIHtcbiAgICBpZiAoIXRoaXMub3ZlclN0YXRlKSB7XG4gICAgICB0aGlzLm92ZXJTdGF0ZSA9IHRydWVcbiAgICAgIHRoaXMub3Zlckxpc3Quc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgIHRoaXMub3Zlckxpc3Quc2Nyb2xsVG9wID0gMFxuICAgICAgdGhpcy5yb290RWwuY2xhc3NMaXN0LmFkZCgnLS1vdmVyLWFjdGl2ZScpXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5jb250ZW50TGlzdC5jbGFzc0xpc3QuYWRkKF9fSElEREVOKVxuICAgICAgICB0aGlzLm92ZXJMaXN0LmNsYXNzTGlzdC5hZGQoX19WSVNJQkxFKVxuICAgICAgfSwgNSk7XG4gICAgfVxuICB9XG5cbiAgY2xvc2VPdmVyTGlzdCgpIHtcbiAgICBpZiAodGhpcy5vdmVyU3RhdGUpIHtcbiAgICAgIHRoaXMub3ZlclN0YXRlID0gZmFsc2VcbiAgICAgIHRoaXMuY29udGVudExpc3QuY2xhc3NMaXN0LnJlbW92ZShfX0hJRERFTilcbiAgICAgIHRoaXMub3Zlckxpc3QuY2xhc3NMaXN0LnJlbW92ZShfX1ZJU0lCTEUpXG4gICAgICB0aGlzLnJvb3RFbC5jbGFzc0xpc3QucmVtb3ZlKCctLW92ZXItYWN0aXZlJylcbiAgICAgIHRoaXMuY29udGVudExpc3Quc2Nyb2xsVG9wID0gMFxuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5vdmVyTGlzdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLm92ZXJMaXN0KSk7XG5cbiAgICAgIGlmICh0aGlzLmFjdGl2ZUxpc3ROYW1lKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlTGlzdE5hbWUuaW5uZXJIVE1MID0gdGhpcy5hY3RpdmVMaXN0TmFtZS5kYXRhc2V0LnRpdGxlIHx8ICdFeHBsb3JlIEljZWJveCdcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnb1RvTmF2TGlzdChuYW1lLCBpdGVtID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLnN1Ykxpc3RBcnIuZmluZChlbCA9PiBlbC5kYXRhc2V0Lm1lbnVMaXN0ID09PSBuYW1lKVxuICAgICAgaWYgKCFsaXN0KSB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEtbWVudS1saXN0IG5vdCBmb3VuZCcpXG5cbiAgICAgIHRoaXMuc3ViTGlzdEFyci5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBpZiAoZWwgIT09IGxpc3QpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlmICh0aGlzLmFjdGl2ZUxpc3ROYW1lICYmIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5hY3RpdmVMaXN0TmFtZS5pbm5lckhUTUwgPSBpdGVtLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NwYW4nKVswXS5pbm5lckhUTUxcbiAgICAgIH1cbiAgICAgIHRoaXMub3Blbk92ZXJMaXN0KClcbiAgICB9XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLnN0YXRlID0gZmFsc2VcbiAgICB0aGlzLm92ZXJTdGF0ZSA9IGZhbHNlXG4gICAgdGhpcy5jb250ZW50TGlzdC5zY3JvbFRvcCA9IDBcbiAgICB0aGlzLm92ZXJMaXN0LnNjcm9sbFRvcCA9IDBcbiAgfVxuXG4gIC8vIEV2ZW50c1xuICBiaW5kRXZlbnRzKCkge1xuICAgIGNvbnN0IGV2dE5hdkFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tZW51LW5hdl0nKV1cbiAgICBldnROYXZBcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaXRlbS5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmJiAhdGhpcy5vdmVyU3RhdGUpIHtcbiAgICAgICAgICBjb25zdCBsaXN0TmFtZSA9IGl0ZW0uZGF0YXNldC5tZW51TmF2XG4gICAgICAgICAgdGhpcy5nb1RvTmF2TGlzdChsaXN0TmFtZSwgaXRlbSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBldnRUb2dnbGVNZW51QXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWV2dD1cInRvZ2dsZU1lbnVcIl0nKV1cbiAgICBldnRUb2dnbGVNZW51QXJyLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgdGhpcy5vcGVuKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5yZXNldCgpXG4gICAgdGhpcy5iaW5kRXZlbnRzKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lbnUiLCJjb25zdCBxdWl6TW9kYWwgPSB7XG4gIGN1cnJlbnRTdGVwOiB1bmRlZmluZWQsXG4gIGlzRmluaXNoZWQ6IHVuZGVmaW5lZCxcbiAgcG9sbExlbmd0aDogdW5kZWZpbmVkLFxuICBtYXhTdGVwOiB1bmRlZmluZWQsXG4gIGlzSW5pdGlhbGl6ZWQ6IHVuZGVmaW5lZCxcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyRE9NKClcbiAgICB0aGlzLnNldEluaXRpYWwoKVxuICAgIHRoaXMuYmluZEV2ZW50cygpXG4gIH0sXG4gIHJlbmRlckRPTTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubW9kYWwgPSAkKCcucXVpei1tb2RhbCcpXG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm1vZGFsLmZpbmQoJy5xdWl6LWNvbnRhaW5lcicpXG4gICAgdGhpcy5iYWNrZHJvcCA9IHRoaXMubW9kYWwuZmluZCgnLnF1aXotbW9kYWxfX2JhY2tkcm9wJylcbiAgICB0aGlzLmhlaWdodENvbnRhaW5lciA9IHRoaXMubW9kYWwuZmluZCgnLnF1aXotY29udGFpbmVyLWhlaWdodCcpXG4gICAgdGhpcy5wb2xsID0gdGhpcy5tb2RhbC5maW5kKCcucXVpei1wb2xsJylcbiAgICB0aGlzLnBvbGxBcnIgPSBbLi4udGhpcy5wb2xsXVxuICAgIHRoaXMuYW5zd2VycyA9IHRoaXMubW9kYWwuZmluZCgnLnF1aXotYW5zd2VyJylcbiAgICB0aGlzLmZ1bGxTdGVwVGV4dCA9IHRoaXMubW9kYWwuZmluZCgnLnF1aXotc3RlcC10ZXh0JylcbiAgICB0aGlzLmN1cnJlbnRTdGVwVGV4dCA9IHRoaXMubW9kYWwuZmluZCgnLnF1aXotY3VycmVudC1zdGVwJylcbiAgICB0aGlzLm1heFN0ZXBUZXh0ID0gdGhpcy5tb2RhbC5maW5kKCcucXVpei1tYXgtc3RlcCcpXG4gICAgdGhpcy5iYXIgPSB0aGlzLm1vZGFsLmZpbmQoJy5xdWl6LWJhcicpXG4gICAgdGhpcy5ldnRHb05leHQgPSAkKCdbZGF0YS1ldnQ9XCJxdWl6R29OZXh0XCJdJylcbiAgICB0aGlzLmV2dE9wZW4gPSAkKCdbZGF0YS1ldnQ9XCJvcGVuUXVpek1vZGFsXCJdJylcbiAgICB0aGlzLmNsb3NlQnRuID0gJCgnW2RhdGEtZXZ0PVwiY2xvc2VRdWl6TW9kYWxcIl0nKVxuICB9LFxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ldnRHb05leHQuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgcXVpek1vZGFsLmdvTmV4dFN0ZXAoKVxuICAgIH0pXG4gICAgdGhpcy5jbG9zZUJ0bi5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBxdWl6TW9kYWwuY2xvc2UoKVxuICAgIH0pXG4gICAgdGhpcy5ldnRPcGVuLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHF1aXpNb2RhbC5vcGVuKClcbiAgICB9KVxuICB9LFxuICBzZXRJbml0aWFsOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IDEsIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlLCB0aGlzLnBvbGxMZW5ndGggPSB0aGlzLnBvbGxBcnIubGVuZ3RoLCB0aGlzLm1heFN0ZXAgPSB0aGlzLnBvbGxMZW5ndGhcbiAgICBpZiAodGhpcy5wb2xsTGVuZ3RoICE9PSAwICYmIHRoaXMucG9sbExlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaXNJbml0aWFsaXplZCAhPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZVxuICAgICAgcXVpek1vZGFsLmN1cnJlbnRTdGVwVGV4dC5odG1sKHF1aXpNb2RhbC5jdXJyZW50U3RlcClcbiAgICAgIHF1aXpNb2RhbC5tYXhTdGVwVGV4dC5odG1sKHF1aXpNb2RhbC5tYXhTdGVwKVxuICAgICAgdGhpcy5tb2RhbC5maW5kKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpOyB0aGlzLmV2dEdvTmV4dC5odG1sKCdOZXh0JylcbiAgICAgIC8vIE9iamVjdC5hc3NpZ24odGhpcy5oZWlnaHRDb250YWluZXJbMF0uc3R5bGUsIHsgaGVpZ2h0OiBgJHt0aGlzLmdldE9iamVjdFNjcm9sbEhlaWdodCh0aGlzLnBvbGxBcnJbMF0pfWAgfSlcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5iYXJbMF0uc3R5bGUsIHsgd2lkdGg6IGAkeygxMDAgLyB0aGlzLnBvbGxMZW5ndGgpfSVgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgLy8gdXRpbHNcbiAgZ2V0T2JqZWN0U2Nyb2xsSGVpZ2h0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIGpRdWVyeSkge1xuICAgICAgcmV0dXJuIGAke29ialswXS5zY3JvbGxIZWlnaHR9cHhgXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJHtvYmouc2Nyb2xsSGVpZ2h0fXB4YFxuICAgIH1cbiAgfSxcbiAgbm9FbXB0eUFuc3dlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcGFyZW50ID0gJChxdWl6TW9kYWwucG9sbEFyclsocXVpek1vZGFsLmN1cnJlbnRTdGVwIC0gMSldKSxcbiAgICAgIGNoZWNrZWRSYWRpbyA9IHBhcmVudC5maW5kKCdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCcpLFxuICAgICAgYW5zd2VycyA9IHBhcmVudC5maW5kKHF1aXpNb2RhbC5hbnN3ZXJzKVxuICAgIGlmIChjaGVja2VkUmFkaW8ubGVuZ3RoID09IDApIHtcbiAgICAgIGFuc3dlcnMuY3NzKHsgb3BhY2l0eTogJzAuMycgfSk7IHNldFRpbWVvdXQoKCkgPT4geyBhbnN3ZXJzLmNzcyh7IG9wYWNpdHk6IDEgfSkgfSwgMzc1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0sXG4gIGdvTmV4dFN0ZXAoKSB7XG4gICAgaWYgKHF1aXpNb2RhbC5jdXJyZW50U3RlcCAhPT0gcXVpek1vZGFsLm1heFN0ZXApIHtcbiAgICAgIGlmIChxdWl6TW9kYWwubm9FbXB0eUFuc3dlcnMoKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHF1aXpNb2RhbC5wb2xsQXJyWyhxdWl6TW9kYWwuY3VycmVudFN0ZXAgLSAxKV0uc3R5bGUsIHsgb3BhY2l0eTogMCB9KVxuICAgICAgICBPYmplY3QuYXNzaWduKHF1aXpNb2RhbC5iYXJbMF0uc3R5bGUsIHsgd2lkdGg6IGAkeygxMDAgLyBxdWl6TW9kYWwucG9sbExlbmd0aCkgKiAocXVpek1vZGFsLmN1cnJlbnRTdGVwICsgMSl9JWAgfSlcbiAgICAgICAgJC5lYWNoKHF1aXpNb2RhbC5wb2xsQXJyLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLnBvbGxBcnJbaV0uc3R5bGUsIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgtJHsocXVpek1vZGFsLmN1cnJlbnRTdGVwICogMTAwKX0lKWAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgT2JqZWN0LmFzc2lnbihxdWl6TW9kYWwuaGVpZ2h0Q29udGFpbmVyWzBdLnN0eWxlLCB7IGhlaWdodDogYCR7cXVpek1vZGFsLnBvbGxBcnJbcXVpek1vZGFsLmN1cnJlbnRTdGVwXS5zY3JvbGxIZWlnaHR9cHhgIH0pXG4gICAgICAgICsrcXVpek1vZGFsLmN1cnJlbnRTdGVwXG4gICAgICAgIHF1aXpNb2RhbC5jdXJyZW50U3RlcFRleHQuaHRtbChxdWl6TW9kYWwuY3VycmVudFN0ZXApXG4gICAgICAgIGlmIChxdWl6TW9kYWwuY3VycmVudFN0ZXAgPT0gcXVpek1vZGFsLm1heFN0ZXApIHtcbiAgICAgICAgICBxdWl6TW9kYWwuZXZ0R29OZXh0Lmh0bWwoJ1Nob3cgUmVzdWx0cycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHF1aXpNb2RhbC5ub0VtcHR5QW5zd2VycygpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLmhlaWdodENvbnRhaW5lclswXS5zdHlsZSwgeyBoZWlnaHQ6ICcwcHgnIH0pXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLmJhclswXS5zdHlsZSwgeyB3aWR0aDogJzUlJyB9KVxuICAgICAgICAkLmVhY2gocXVpek1vZGFsLnBvbGxBcnIsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWl6TW9kYWwucG9sbEFycltpXS5zdHlsZSwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKC0keyhxdWl6TW9kYWwuY3VycmVudFN0ZXAgKiAxMDApfSUpYCB9KVxuICAgICAgICB9KVxuICAgICAgICBPYmplY3QuYXNzaWduKHF1aXpNb2RhbC5wb2xsQXJyWyhxdWl6TW9kYWwuY3VycmVudFN0ZXAgLSAxKV0uc3R5bGUsIHsgb3BhY2l0eTogMCB9KVxuICAgICAgICBxdWl6TW9kYWwuZXZ0R29OZXh0LnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSlcbiAgICAgICAgcXVpek1vZGFsLmZ1bGxTdGVwVGV4dC50ZXh0KCdGSU5ESU5HIFdBVENIRVMnKVxuICAgICAgICAkKCcucXVpei1jbG9zZS1idG4nKS5yZW1vdmUoKVxuICAgICAgICBxdWl6TW9kYWwuaXNGaW5pc2hlZCA9IHRydWVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcXVpek1vZGFsLmJhci5hbmltYXRlKHsgd2lkdGg6ICcxMDAlJyB9LCAzMDAwLCBmdW5jdGlvbiAoKSB7IHF1aXpNb2RhbC5jbG9zZSgpIH0pXG4gICAgICAgIH0sIDYwMCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBvcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgbG9ja1Njcm9sbCgpXG4gICAgcXVpek1vZGFsLm1vZGFsLnNob3coKVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5oZWlnaHRDb250YWluZXJbMF0uc3R5bGUsIHsgaGVpZ2h0OiBgJHt0aGlzLmdldE9iamVjdFNjcm9sbEhlaWdodCh0aGlzLnBvbGxBcnJbcXVpek1vZGFsLmN1cnJlbnRTdGVwIC0gMV0pfWAgfSlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLmJhY2tkcm9wWzBdLnN0eWxlLCB7IG9wYWNpdHk6IDEgfSlcbiAgICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLmNvbnRhaW5lclswXS5zdHlsZSwgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDBweCknLCBvcGFjaXR5OiAxIH0pXG4gICAgfSwgMSk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdW5sb2NrU2Nyb2xsKClcbiAgICBsZXQgdGltZVRvSGlkZSA9IChwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHF1aXpNb2RhbC5iYWNrZHJvcFswXSkudHJhbnNpdGlvbkR1cmF0aW9uKSAqIDEwMDApXG4gICAgT2JqZWN0LmFzc2lnbihxdWl6TW9kYWwuYmFja2Ryb3BbMF0uc3R5bGUsIHsgb3BhY2l0eTogMCB9KVxuICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLmNvbnRhaW5lclswXS5zdHlsZSwgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDMycHgpJywgb3BhY2l0eTogMCB9KVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcXVpek1vZGFsLm1vZGFsLmhpZGUoKVxuICAgIH0sIHRpbWVUb0hpZGUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVpek1vZGFsIiwiY29uc3Qgc2FsZXNNb2RhbCA9IHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyRE9NKClcbiAgICBpZiAodGhpcy5tb2RhbC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpXG4gICAgfVxuICB9LFxuICByZW5kZXJET006IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1vZGFsID0gJCgnLnNhbGUtaGlzdG9yeS1tb2RhbCcpXG4gICAgdGhpcy5jb250YWluZXIgPSAkKCcuc2FsZS1oaXN0b3J5X19jb250YWluZXInKVxuICAgIHRoaXMuZXZ0Q2xvc2UgPSAkKCdbZGF0YS1ldnQ9XCJjbG9zZVNhbGVzTW9kYWxcIl0nKVxuICB9LFxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ldnRDbG9zZS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBzYWxlc01vZGFsLmNsb3NlKClcbiAgICB9KVxuICB9LFxuICBvcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgc2FsZXNNb2RhbC5jbG9zZSgpXG4gICAgICB9XG4gICAgfSwgeyBvbmNlOiB0cnVlIH0pXG4gICAgbG9ja1Njcm9sbCgpXG4gICAgdGhpcy5tb2RhbC5zaG93KClcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMubW9kYWwuY3NzKHsgJ2JhY2tncm91bmQtY29sb3InOiBcInJnYmEoMTMsIDE2LCAyNiwgLjcpXCIgfSlcbiAgICAgIHRoaXMuY29udGFpbmVyLmNzcyh7ICd0cmFuc2Zvcm0nOiAndHJhbnNsYXRlWCgwJSknIH0pXG4gICAgfSwgMSk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdW5sb2NrU2Nyb2xsKClcbiAgICB0aGlzLm1vZGFsLmNzcyh7ICdiYWNrZ3JvdW5kLWNvbG9yJzogXCJyZ2JhKDEzLCAxNiwgMjYsIDApXCIgfSlcbiAgICB0aGlzLmNvbnRhaW5lci5jc3MoeyAndHJhbnNmb3JtJzogJ3RyYW5zbGF0ZVgoMTAwJSknIH0pXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLm1vZGFsLmhpZGUoKVxuICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMubW9kYWwpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhbGVzTW9kYWwiLCJjbGFzcyBTaWduTW9kYWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJvb3RFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zaWduLW1vZGFsJylcbiAgICBpZiAoIXRoaXMucm9vdEVsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdObyBlbGVtZW50IHdpdGggY2xhc3MgLnNpZ24tbW9kYWwgZm91bmQuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLmFkanVzdEVsID0gdGhpcy5yb290RWwucXVlcnlTZWxlY3RvcignLnNpZ24tbW9kYWxfX2FkanVzdCcpXG4gICAgdGhpcy5iYWNrZHJvcCA9IHRoaXMucm9vdEVsLnF1ZXJ5U2VsZWN0b3IoJy5zaWduLW1vZGFsX19iYWNrZHJvcCcpXG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLnJvb3RFbC5xdWVyeVNlbGVjdG9yKCcuc2lnbi1tb2RhbF9fY29udGFpbmVyJylcbiAgICB0aGlzLmZvcm1zQXJyID0gWy4uLnRoaXMucm9vdEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2Zvcm0nKV1cbiAgICB0aGlzLmV2dE9wZW5BcnIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1ldnQ9XCJvcGVuU2lnbk1vZGFsXCJdJylcbiAgICB0aGlzLmV2dENsb3NlQXJyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZXZ0PVwiY2xvc2VTaWduTW9kYWxcIl0nKVxuICAgIHRoaXMuZXZ0SnNUb2dnbGVTaWduID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmpzLXRvZ2dsZS1zaWduJylcbiAgICB0aGlzLmNvbnRlbnRBcnIgPSBbLi4udGhpcy5yb290RWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2lnbi1jb250ZW50XScpXVxuICAgIHRoaXMuZXZ0U3dpdGNoQ29udGVudEFyciA9IHRoaXMucm9vdEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNpZ24tc3dpdGNoXScpXG4gICAgdGhpcy5ldnRUb2dnbGVQYXNzd29yZCA9IFsuLi50aGlzLnJvb3RFbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1ldnQ9XCJ0b2dnbGVQYXNzd29yZFwiXScpXVxuICAgIHRoaXMubG9hZGVyID0gdGhpcy5yb290RWwucXVlcnlTZWxlY3RvcignLnNpZ24tbW9kYWxfX2xvYWRlcicpXG4gICAgdGhpcy5qc1N1Ym1pdEFyciA9IFsuLi50aGlzLnJvb3RFbC5xdWVyeVNlbGVjdG9yQWxsKCcuanMtc3VibWl0JyldXG4gICAgdGhpcy5vdHBBcnIgPSBbLi4udGhpcy5yb290RWwucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQuLS1vdHAnKV1cbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlXG4gICAgdGhpcy5vcGVuZWQgPSB0cnVlXG4gICAgdGhpcy5hY3RpdmVDb250ZW50ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5pbml0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXR0ZXJzXG4gICAqL1xuICBnZXQgZ2V0QWN0aXZlQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50QXJyLmZpbmQoZSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKS5kaXNwbGF5ICE9PSAnbm9uZScpXG4gIH1cblxuICAvKipcbiAgICogVXRpbHNcbiAgICovXG4gIGxvY2tNb2RhbCgpIHtcbiAgICB0aGlzLnJvb3RFbC5jbGFzc0xpc3QuYWRkKF9fTE9DS0VEKVxuICAgIHRoaXMubG9ja2VkID0gdHJ1ZVxuICB9XG4gIHVubG9ja01vZGFsKCkge1xuICAgIHRoaXMucm9vdEVsLmNsYXNzTGlzdC5yZW1vdmUoX19MT0NLRUQpXG4gICAgdGhpcy5sb2NrZWQgPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZHNcbiAgICovXG4gIHN3aXRjaChjb250ZW50VHlwZSkge1xuICAgIGxldCBzZWN0aW9uID0gdGhpcy5jb250ZW50QXJyLmZpbmQoZSA9PiBlLmRhdGFzZXQuc2lnbkNvbnRlbnQgPT09IGNvbnRlbnRUeXBlKSB8fCB0aGlzLmNvbnRlbnRBcnJbMF1cbiAgICBsZXQgYWN0aXZlU2VjdGlvbiA9IHRoaXMuY29udGVudEFyci5maW5kKChlbCkgPT4ge1xuICAgICAgbGV0IGRpc3BsYXlQcm9wZXJ0eSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5kaXNwbGF5XG4gICAgICByZXR1cm4gZGlzcGxheVByb3BlcnR5ICE9PSAnbm9uZSdcbiAgICB9KVxuICAgIGlmICghc2VjdGlvbikgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB0byBmaW5kIHNlY3Rpb24gd2l0aCBkYXRhLXNpZ24tY29udGVudD0ke2NvbnRlbnRUeXBlfWApXG4gICAgaWYgKGFjdGl2ZVNlY3Rpb24gPT0gc2VjdGlvbikgcmV0dXJuXG4gICAgaWYgKGNvbnRlbnRUeXBlID09ICdvdHAnKSB7XG4gICAgICB0aGlzLm90cEFyci5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBlbC52YWx1ZSA9ICcnXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuYWN0aXZlQ29udGVudCA9IHNlY3Rpb25cbiAgICB0aGlzLmxvY2tNb2RhbCgpXG4gICAgY29uc3QgY3VycmVudEhlaWdodCA9IHRoaXMuYWRqdXN0RWwub2Zmc2V0SGVpZ2h0XG4gICAgdGhpcy5hZGp1c3RFbC5zdHlsZS5vcGFjaXR5ID0gMFxuICAgIHRoaXMuYWRqdXN0RWwuc3R5bGUuaGVpZ2h0ID0gYCR7Y3VycmVudEhlaWdodH1weGBcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY29udGVudEFyci5mb3JFYWNoKGUgPT4gZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnKVxuICAgICAgc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgICBjb25zdCBuZXdIZWlnaHQgPSBzZWN0aW9uLnNjcm9sbEhlaWdodFxuICAgICAgdGhpcy5hZGp1c3RFbC5zdHlsZS5oZWlnaHQgPSBgJHtuZXdIZWlnaHR9cHhgXG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkanVzdEVsLnN0eWxlLm9wYWNpdHkgPSAnMSdcbiAgICAgICAgdGhpcy51bmxvY2tNb2RhbCgpXG4gICAgICB9LCA1KVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRqdXN0RWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nXG4gICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmFkanVzdEVsKSk7XG4gICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUodGhpcy5hZGp1c3RFbCkpO1xuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH1cbiAgfVxuICBvcGVuKCkge1xuICAgIGlmICghdGhpcy5vcGVuZWQpIHtcbiAgICAgIGlmICh3aW5kb3cubWVudSkge1xuICAgICAgICBpZiAod2luZG93Lm1lbnUuc3RhdGUpIHtcbiAgICAgICAgICB3aW5kb3cubWVudS5zdGF0ZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmNvbnRlbnRBcnIuZmluZChlID0+IGUuZGF0YXNldC5zaWduQ29udGVudCA9PSAnc21zJykgfHwgdGhpcy5jb250ZW50QXJyWzBdXG4gICAgICB0aGlzLm9wZW5lZCA9IHRydWVcbiAgICAgIHRoaXMucm9vdEVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICB0aGlzLmFkanVzdEVsLnN0eWxlLmhlaWdodCA9ICdhdXRvJ1xuICAgICAgdGhpcy5jb250ZW50QXJyLmZvckVhY2goZSA9PiBlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZScpXG4gICAgICBjb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbiAgICAgIC8vIGNvbnRlbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKS5mb2N1cygpXG4gICAgICBsb2NrU2Nyb2xsKClcbiAgICAgIGNvbnN0IHNob3cgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuYmFja2Ryb3Auc3R5bGUub3BhY2l0eSA9IDFcbiAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShJU19ISURERU4pXG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KHNob3csIDEpXG4gICAgfVxuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgdGhpcy5vcGVuZWQgPSBmYWxzZVxuICAgICAgdGhpcy5iYWNrZHJvcC5zdHlsZS5vcGFjaXR5ID0gMFxuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChJU19ISURERU4pXG4gICAgICB1bmxvY2tTY3JvbGwoKVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMucm9vdEVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMuYmFja2Ryb3ApKVxuICAgIH1cbiAgfVxuICBzdGFydExvYWRpbmcoKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyICYmICF0aGlzLmxvY2tlZCkge1xuICAgICAgdGhpcy51bmxvY2tNb2RhbCgpXG4gICAgICB0aGlzLmxvYWRlci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5sb2FkZXIuc3R5bGUub3BhY2l0eSA9ICcxJyB9LCAxMClcbiAgICB9XG4gIH1cbiAgc3RvcExvYWRpbmcoKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICB0aGlzLmxvYWRlci5zdHlsZS5vcGFjaXR5ID0gJzAnXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5sb2FkZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlXG4gICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmxvYWRlcikpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJpbmQgRXZlbnRzXG4gICAqL1xuICBiaW5kVG9nZ2xlVmlzaWJsaXR5KCkge1xuICAgIC8vIE9wZW5cbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuZXZ0T3BlbkFycikge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdGhpcy50b2dnbGUoKVxuICAgICAgfSlcbiAgICB9XG4gICAgLy8gQ2xvc2VcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuZXZ0Q2xvc2VBcnIpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfSlcbiAgICB9XG4gICAgLy8gVG9nZ2xlXG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmV2dEpzVG9nZ2xlU2lnbikge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdGhpcy50b2dnbGUoKVxuICAgICAgICBjb25zdCBjb250ZW50TmFtZSA9IGVsLmRhdGFzZXQuc2lnblN3aXRjaFxuICAgICAgICBpZiAoY29udGVudE5hbWUpIHtcbiAgICAgICAgICB0aGlzLnN3aXRjaChjb250ZW50TmFtZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZFN3aXRjaENvbnRlbnQoKSB7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmV2dFN3aXRjaENvbnRlbnRBcnIpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGNvbnN0IGNvbnRlbnROYW1lID0gZWwuZGF0YXNldC5zaWduU3dpdGNoXG4gICAgICAgIHRoaXMuc3dpdGNoKGNvbnRlbnROYW1lKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZE9UUElucHV0KCkge1xuICAgIGNvbnN0IGlucHV0cyA9IHRoaXMub3RwQXJyXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0Jyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YS5zcGxpdChcIlwiKTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCwgaW5kZXgpID0+IChpbnB1dC52YWx1ZSA9IHZhbHVlW2luZGV4XSkpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgZS50YXJnZXQudmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8uL2csICcnKVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXFxEL2cpKSB7XG4gICAgICAgICAgZS50YXJnZXQudmFsdWUgPSAnJ1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV4dElucHV0ID0gZS50YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nXG4gICAgICAgICAgY29uc3QgdmFsdWVJc0RpZ2l0ID0gdmFsdWUubWF0Y2goL1xcZC9nKVxuICAgICAgICAgIGlmIChuZXh0SW5wdXQgJiYgdmFsdWVJc0RpZ2l0KSB7XG4gICAgICAgICAgICBuZXh0SW5wdXQuZm9jdXMoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5rZXkgPT09ICdCYWNrc3BhY2UnKSB7XG4gICAgICAgICAgZS50YXJnZXQudmFsdWUgPSAnJ1xuICAgICAgICAgIGNvbnN0IHByZXZJbnB1dCA9IGUudGFyZ2V0LnByZXZpb3VzRWxlbWVudFNpYmxpbmdcbiAgICAgICAgICBpZiAocHJldklucHV0KSB7XG4gICAgICAgICAgICBwcmV2SW5wdXQuZm9jdXMoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXkgPT09ICdBcnJvd0xlZnQnKSB7XG4gICAgICAgICAgY29uc3QgcHJldklucHV0ID0gZS50YXJnZXQucHJldmlvdXNFbGVtZW50U2libGluZ1xuICAgICAgICAgIGlmIChwcmV2SW5wdXQpIHtcbiAgICAgICAgICAgIHByZXZJbnB1dC5mb2N1cygpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSAnQXJyb3dSaWdodCcpIHtcbiAgICAgICAgICBjb25zdCBuZXh0SW5wdXQgPSBlLnRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgICAgICBpZiAobmV4dElucHV0KSB7XG4gICAgICAgICAgICBuZXh0SW5wdXQuZm9jdXMoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZFRvZ2dsZVBhc3N3b3JkKCkge1xuICAgIGZvciAoY29uc3QgYnRuIG9mIHRoaXMuZXZ0VG9nZ2xlUGFzc3dvcmQpIHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBjb25zdCBpbnB1dCA9IGJ0bi5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JylcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IGlucHV0LmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAncGFzc3dvcmQnID8gJ3RleHQnIDogJ3Bhc3N3b3JkJ1xuICAgICAgICAgIGNvbnN0IHN2Z1Nob3cgPSBidG4ucXVlcnlTZWxlY3RvcignLnN2Z19wYXNzX3Nob3cnKVxuICAgICAgICAgIGNvbnN0IHN2Z0hpZGUgPSBidG4ucXVlcnlTZWxlY3RvcignLnN2Z19wYXNzX2hpZGUnKVxuXG4gICAgICAgICAgaW5wdXQudHlwZSA9IHR5cGVcbiAgICAgICAgICBpZiAoc3ZnU2hvdyAmJiBzdmdIaWRlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgIHN2Z1Nob3cuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgICBzdmdIaWRlLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJ1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3ZnU2hvdy5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSdcbiAgICAgICAgICAgICAgc3ZnSGlkZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBiaW5kU3VibWl0KCkge1xuICAgIHRoaXMuZm9ybXNBcnIuZm9yRWFjaCgoZm9ybSkgPT4ge1xuICAgICAgJChmb3JtKS5vbignc3VibWl0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoJCh0aGlzKS5wYXJzbGV5KCkuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgdGhpcy5zdGFydExvYWRpbmcoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZVxuICAgKi9cbiAgaW5pdGlhbFNldHVwKCkge1xuICAgIHRoaXMucm9vdEVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICB0aGlzLmNsb3NlKClcbiAgICB0aGlzLnN3aXRjaCgncGhvbmVfcmVnaXN0ZXInKVxuICB9XG4gIGluaXQoKSB7XG4gICAgaWYgKHRoaXMucm9vdEVsKSB7XG4gICAgICB0aGlzLmJpbmRUb2dnbGVWaXNpYmxpdHkoKVxuICAgICAgdGhpcy5iaW5kU3dpdGNoQ29udGVudCgpXG4gICAgICB0aGlzLmJpbmRPVFBJbnB1dCgpXG4gICAgICB0aGlzLmJpbmRUb2dnbGVQYXNzd29yZCgpXG4gICAgICB0aGlzLmJpbmRTdWJtaXQoKVxuICAgICAgdGhpcy5pbml0aWFsU2V0dXAoKVxuICAgICAgaW5pdFZhbGlkYXRvcnMoKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25Nb2RhbCIsImNvbnN0IGFjY291bnQgPSBuZXcgT2JqZWN0KHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5hdHRhY2hFdmVudHMpLmZvckVhY2goKGZuKSA9PiB7XG4gICAgICBpZiAoZm4gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJykgZm4oKTtcbiAgICB9KVxuICB9LFxuICBhdHRhY2hFdmVudHM6IHtcbiAgICBlZGl0QWRkcmVzczogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZXZ0RWRpdEFkZHJlc3MgPSBBcnJheS5mcm9tKCQoJ1tkYXRhLWVkaXQ9XCJhZGRyZXNzXCJdJykpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2dEVkaXRBZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZXZ0RWRpdEFkZHJlc3NbaV07XG5cbiAgICAgICAgJChlbCkuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxldCBkZXRhaWxzID0gJCh0aGlzKS5jbG9zZXN0KCcucHJvZmlsZS1jYXJkJykuZmluZCgnLnByb2ZpbGUtY2FyZF9fZGV0YWlscycpLFxuICAgICAgICAgICAgZm9ybSA9IGRldGFpbHMuZmlsdGVyKCcuZm9ybScpXG4gICAgICAgICAgaWYgKGVsZW1EaXNwbGF5ZWQoZm9ybSkpIHtcbiAgICAgICAgICAgIGRldGFpbHMuaGlkZSgpLm5vdChmb3JtKS5zaG93KClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGV0YWlscy5zaG93KCkubm90KGZvcm0pLmhpZGUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgfVxuICAgIH0sXG4gICAgdG9nZ2xlSW52b2ljZUhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgaW52b2ljZUFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcub3JkZXJfX2ludm9pY2UnKV1cbiAgICAgIGZvciAoY29uc3QgaW52b2ljZSBvZiBpbnZvaWNlQXJyKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGludm9pY2UucXVlcnlTZWxlY3RvcignLm9yZGVyX19pbnZvaWNlLWhlYWRlcicpXG4gICAgICAgIGNvbnN0IGJvZHkgPSBpbnZvaWNlLnF1ZXJ5U2VsZWN0b3IoJy5vcmRlcl9faW52b2ljZS1ib2R5JylcblxuICAgICAgICBoZWFkZXIub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB0b0Nsb3NlID0gaW52b2ljZS5jbGFzc0xpc3QuY29udGFpbnMoX19BQ1RJVkUpXG4gICAgICAgICAgaWYgKHRvQ2xvc2UpIHtcbiAgICAgICAgICAgIGludm9pY2UuY2xhc3NMaXN0LnJlbW92ZShfX0FDVElWRSlcbiAgICAgICAgICAgIGJvZHkuc3R5bGUuaGVpZ2h0ID0gYDgwcHhgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludm9pY2UuY2xhc3NMaXN0LmFkZChfX0FDVElWRSlcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgICAgICAgICBib2R5LnN0eWxlLmhlaWdodCA9IGAke3Njcm9sbEhlaWdodH1weGBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gYWNjb3VudCIsImNvbnN0IGJsb2dQYWdlID0ge1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLmluaXRGbikuZm9yRWFjaCgoZm4pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdHJ5IHsgZm4oKSB9XG4gICAgICAgIGNhdGNoIHsgY29uc29sZS5sb2coJ2Jsb2cgSlMgRVJSJykgfVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIGluaXRGbjoge1xuICAgIGF0dGFjaENvbW1lbnRTdWJtaXQ6ICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbW1lbnRBcmVhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtYXJ0aWNsZT1cImNvbW1lbnRBcmVhXCJdJylcbiAgICAgIGNvbnN0IGNvbW1lbnRTdWJtaXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hcnRpY2xlPVwiY29tbWVudFN1Ym1pdFwiXScpXG4gICAgICBjb25zdCBob2xkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXJ0aWNsZV9fY29tbWVudHMtd3JhcCcpXG5cbiAgICAgIGlmIChjb21tZW50QXJlYSAhPT0gbnVsbCAmJiBjb21tZW50U3VibWl0ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN1Ym1pdCA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgdmFsID0gY29tbWVudEFyZWEudmFsdWVcbiAgICAgICAgICBpZiAodmFsLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgdXNlciA9ICdHdWV0cycsXG4gICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tdXMnLCB7IHllYXI6IFwibnVtZXJpY1wiLCBtb250aDogXCJzaG9ydFwiLCBkYXk6IFwibnVtZXJpY1wiIH0pLFxuICAgICAgICAgICAgICBodG1sID0gYFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYXJ0aWNsZS1jb21tZW50XCI+PHNwYW4+JHt1c2VyfTwvc3Bhbj48c3Bhbj4ke3ZhbH08L3NwYW4+PHNwYW4+JHtkYXRlfTwvc3Bhbj48L2Rpdj5cbiAgICAgICAgICAgICAgYFxuXG4gICAgICAgICAgICBob2xkZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGh0bWwpXG4gICAgICAgICAgICBjb21tZW50QXJlYS52YWx1ZSA9ICcnXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29tbWVudFN1Ym1pdC5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgIHN1Ym1pdCgpXG4gICAgICAgIH1cblxuICAgICAgICBjb21tZW50QXJlYS5vbmtleWRvd24gPSAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzRW50ZXIgPSBlLmtleSA9PT0gJ0VudGVyJyB8fCBlLmtleUNvZGUgPT09IDEzXG4gICAgICAgICAgaWYgKGlzRW50ZXIpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgc3VibWl0KClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZVByb2dyZXNzQmFyOiAoKSA9PiB7XG4gICAgICBjb25zdCByZWFkQ29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hcnRpY2xlX19yZWFkLWNvbnRlbnQnKVxuICAgICAgaWYgKCFyZWFkQ29udGVudCkgcmV0dXJuXG4gICAgICBsZXQgeSA9IDBcbiAgICAgIGxldCBmdWxsSGVpZ2h0ID0gKHJlYWRDb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSArIDEyMCkgLSAod2luZG93LmlubmVySGVpZ2h0ICogMC43KVxuICAgICAgY29uc3QgY2FsY3VsYXRlUGVyY2VudGFnZSA9IChudW1iZXIsIHRvdGFsKSA9PiB7XG4gICAgICAgIHJldHVybiAobnVtYmVyIC8gdG90YWwpICogMTAwXG4gICAgICB9XG4gICAgICBjb25zdCBzZXRFbGVtZW50V2lkdGhQZXJjZW50ID0gKGVsLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gYCR7cGVyY2VudH0lYFxuICAgICAgfVxuXG4gICAgICBjb25zdFxuICAgICAgICBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgICBiYXIuY2xhc3NOYW1lID0gJ2Jsb2ctcHJvZ3Jlc3MnXG4gICAgICBiYXIuYXBwZW5kQ2hpbGQocHJvZ3Jlc3MpXG5cbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYmFyKVxuXG4gICAgICB3aW5kb3cub25zY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgIHkgPSB3aW5kb3cuc2Nyb2xsWVxuICAgICAgICBsZXQgZiA9IGNhbGN1bGF0ZVBlcmNlbnRhZ2UoeSwgZnVsbEhlaWdodClcbiAgICAgICAgc2V0RWxlbWVudFdpZHRoUGVyY2VudChwcm9ncmVzcywgZilcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFJlYWRpbmdUaW1lOiAoKSA9PiB7XG4gICAgICBjb25zdFxuICAgICAgICByZWFkQ29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hcnRpY2xlX19yZWFkLWNvbnRlbnQnKSxcbiAgICAgICAgdGltZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJlYWQtdGltZScpXG4gICAgICBpZiAoIXJlYWRDb250ZW50IHx8ICF0aW1lRWwpIHJldHVyblxuXG4gICAgICBjb25zdFxuICAgICAgICB3b3Jkc1Blck1pbnV0ZSA9IDIwMCxcbiAgICAgICAgdGV4dENvbnRlbnQgPSByZWFkQ29udGVudC50ZXh0Q29udGVudCxcbiAgICAgICAgd29yZENvdW50ID0gdGV4dENvbnRlbnQuc3BsaXQoL1xccy9nKS5sZW5ndGgsXG4gICAgICAgIHJlYWRpbmdUaW1lID0gTWF0aC5jZWlsKHdvcmRDb3VudCAvIHdvcmRzUGVyTWludXRlKVxuXG5cbiAgICAgIHRpbWVFbC50ZXh0Q29udGVudCA9IGAke3JlYWRpbmdUaW1lfSBtaW4gcmVhZGluZ2BcbiAgICB9LFxuICAgIGF0dGFjaFNjcm9sbDogKCkgPT4ge1xuICAgICAgcmV0dXJuXG4gICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXJ0aWNsZS10b3AtY292ZXIgaW1nJylcbiAgICAgIGlmIChpbWcgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IG1heCA9IGltZy5vZmZzZXRIZWlnaHQgKyAxMDBcbiAgICAgICAgd2luZG93Lm9uc2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgIGxldCB5ID0gd2luZG93LnNjcm9sbFlcbiAgICAgICAgICBpZiAobWF4ID4geSkge1xuICAgICAgICAgICAgbGV0IGYgPSAxIC0gKHkgKiAxMDAgLyBtYXggKiAwLjAxKVxuICAgICAgICAgICAgaW1nLnN0eWxlLm1hcmdpblRvcCA9IGAtJHt5ICogMC4wOH1weGBcbiAgICAgICAgICAgIGltZy5zdHlsZS5vcGFjaXR5ID0gZlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJsb2dQYWdlIiwiY29uc3QgZm9ybVBhZ2UgPSBuZXcgT2JqZWN0KHtcbiAgdXBsb2FkZWRJbWFnZXM6IFtdLFxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluX2Zvcm1wYWdlJykpIHtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpXG4gICAgICAvLyB0aGlzLmltZ1VwbG9hZCgpXG4gICAgICB0aGlzLmF0dGFjaEltYWdlc1VwbG9hZGVyKClcbiAgICAgIHRoaXMuYXR0YWNoV2F0Y2hlc1VwbG9hZCgpXG4gICAgfVxuICB9LFxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgJCgnLmZvcm1wYWdlX191cGxvYWQtYnRuJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCQoJyNpbWFnZV91cGxvYWQnKS5sZW5ndGgpIHsgJCgnI2ltYWdlX3VwbG9hZCcpLnRyaWdnZXIoJ2NsaWNrJykgfVxuICAgIH0pXG4gICAgLy8gJCgnI2Zvcm1wYWdlX2Zvcm0nKS5vbignc3VibWl0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAvLyAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAvLyAgIGZvcm1QYWdlLnN1Ym1pdEFqYXgoKTtcbiAgICAvLyB9KTtcbiAgfSxcbiAgc3VibWl0QWpheDogZnVuY3Rpb24gKCkgeyB9LFxuICBhdHRhY2hJbWFnZXNVcGxvYWRlcjogKCkgPT4ge1xuICAgIGNvbnN0IHVwbG9hZExhYmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2Zvcm1wYWdlX2ltZy11cGxvYWRlcicpLFxuICAgICAgdXBsb2FkSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaW1hZ2VfdXBsb2FkJyksXG4gICAgICBpbWFnZXNXcmFwID0gJCgnLmZvcm1wYWdlX19pbWFnZXMtdGh1bWJuYWlscycpXG5cbiAgICAvLyBTZXR0aW5nIGRyYWcmZHJvcCBldmVudFxuICAgIGlmICh1cGxvYWRMYWJlbCAhPT0gbnVsbCkge1xuICAgICAgdXBsb2FkTGFiZWwub25kcmFnb3ZlciA9IChldnQpID0+IHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdXBsb2FkTGFiZWwuY2xhc3NMaXN0LmFkZChJU19BQ1RJVkUpXG4gICAgICB9XG4gICAgICB1cGxvYWRMYWJlbC5vbmRyYWdsZWF2ZSA9IChldnQpID0+IHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdXBsb2FkTGFiZWwuY2xhc3NMaXN0LnJlbW92ZShJU19BQ1RJVkUpXG4gICAgICB9XG4gICAgICB1cGxvYWRMYWJlbC5vbmRyb3AgPSAoZXZ0KSA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHVwbG9hZExhYmVsLmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKVxuICAgICAgICAkKCcjaW1hZ2VfdXBsb2FkJykucHJvcCgnZmlsZXMnLCBldnQuZGF0YVRyYW5zZmVyLmZpbGVzKTtcbiAgICAgICAgY29uc3QgZmlsZXMgPSBbXSwgaXRlbXMgPSBbLi4uZXZ0LmRhdGFUcmFuc2Zlci5pdGVtc11cbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtLmtpbmQgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgZmlsZXMucHVzaChpdGVtLmdldEFzRmlsZSgpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICQoJy5mb3JtcGFnZV9faW1hZ2VzLXRodW1ibmFpbHMnKS5lbXB0eSgpXG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0ZpbGVzKFsuLi5maWxlc10pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyBtYW51YWwgZmlsZXMgdXBsb2FkXG4gICAgaWYgKHVwbG9hZElucHV0ICE9PSBudWxsKSB7XG4gICAgICB1cGxvYWRJbnB1dC5vbmNoYW5nZSA9IChldnQpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSBbLi4uZXZ0LnRhcmdldC5maWxlc11cbiAgICAgICAgJCgnLmZvcm1wYWdlX19pbWFnZXMtdGh1bWJuYWlscycpLmVtcHR5KClcbiAgICAgICAgcHJvY2Vzc0ZpbGVzKGZpbGVzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NGaWxlcyhmaWxlcykge1xuICAgICAgaWYgKGZpbGVzLmxlbmd0aCkge1xuICAgICAgICBmaWxlcy5mb3JFYWNoKChmaWxlLCBpKSA9PiB7XG4gICAgICAgICAgaWYgKCFmaWxlLnR5cGUubWF0Y2goJ2ltYWdlLionKSkgeyByZXR1cm4gfVxuXG4gICAgICAgICAgbGV0IGdldEluZGV4ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICQoJy5mb3JtcGFnZV9fdXBsb2FkJykubGVuZ3RoICsgMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBsZXQgaHRtbCA9XG4gICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtcGFnZV9fdXBsb2FkXCIgZGF0YS1pbWctaWQ9XCIke2dldEluZGV4KCl9XCI+XG4gICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtcGFnZV9faW5wdXQtYm94ZXNcIj5cbiAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHZhbHVlPVwiMVwiIG5hbWU9XCJ2aXNpYmxlX2ltYWdlXyR7aX1cIiBpZD1cImltYWdlXyR7aSArIDF9XCIgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD5cbiAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJpbWFnZV8ke2dldEluZGV4KCl9XCI+PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgPGRpdiBkYXRhLW5hbWU9XCIke2ZpbGUubmFtZX1cIiBzdHlsZT1cImJhY2tncm91bmQtaW1hZ2U6IHVybCgke2UudGFyZ2V0LnJlc3VsdH0pXCIgY2xhc3M9XCJmb3JtcGFnZV9fdXBsb2FkLWJnXCI+XG4gICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgYFxuICAgICAgICAgICAgaW1hZ2VzV3JhcC5hcHBlbmQoaHRtbClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIGNoZWNrYm94IHRvZ2dsZSBvbiBhcHBlbmRlZCBpbWFnZXNcbiAgICAkYm9keS5vbignY2xpY2snLCBcIi5mb3JtcGFnZV9fdXBsb2FkLWJnXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvY2tTY3JvbGwoKVxuICAgICAgbGV0IGh0bWwgPVxuICAgICAgICBgXG4gICAgICA8ZGl2IGNsYXNzPVwiZm9ybXBhZ2Utem9vbVwiPlxuICAgICAgICA8ZGl2IGRhdGEtZXZ0PVwiY2xvc2VGb3JtcGFnZVpvb21cIj48L2Rpdj5cbiAgICAgICAgPGRpdiBkYXRhLWJsb2NrPVwiZm9ybXBhZ2Vab29tXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIGBcbiAgICAgICRib2R5LmFwcGVuZChodG1sKVxuICAgICAgJCgnW2RhdGEtYmxvY2s9XCJmb3JtcGFnZVpvb21cIl0nKS5hdHRyKCdzdHlsZScsICQodGhpcykuYXR0cignc3R5bGUnKSlcbiAgICB9KTtcbiAgICAkYm9keS5vbignY2xpY2snLCAnW2RhdGEtZXZ0PVwiY2xvc2VGb3JtcGFnZVpvb21cIl0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxvY2tTY3JvbGwoKVxuICAgICAgJCgnLmZvcm1wYWdlLXpvb20nKS5yZW1vdmUoKVxuICAgIH0pXG4gIH0sXG4gIGF0dGFjaFdhdGNoZXNVcGxvYWQ6ICgpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjd2F0Y2hlc191cGxvYWRfbGFiZWwnKSxcbiAgICAgIGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3dhdGNoZXNfdXBsb2FkJylcblxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIH0sIGZhbHNlKVxuXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoX19BQ1RJVkUpXG4gICAgfSlcblxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsICgpID0+IHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgIH0pXG5cbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpXG4gICAgICBpbnB1dC5maWxlcyA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzXG4gICAgfSlcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JtUGFnZSIsImNsYXNzIEhvbWVwYWdlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbml0KClcbiAgfVxuXG4gIC8vIFNwbGlkZXNcbiAgaW5pdENhdGVnb3JpZXNTcGxpZGUoKSB7XG4gICAgY29uc3QgY2F0ZWdvcmllc0VsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaG9tZS1jYXRlZ29yaWVzLXNwbGlkZScpXG4gICAgaWYgKGNhdGVnb3JpZXNFbGVtKSB7XG4gICAgICBsZXQgc2xpZGVyID0gbmV3IFNwbGlkZShjYXRlZ29yaWVzRWxlbSwge1xuICAgICAgICB0eXBlOiBcImxvb3BcIixcbiAgICAgICAgcGVyUGFnZTogNyxcbiAgICAgICAgcGVyTW92ZTogMixcbiAgICAgICAgYXV0b3BsYXk6IDAsXG4gICAgICAgIGdhcDogXCI4cHhcIixcbiAgICAgICAgYXJyb3dzOiAxLFxuICAgICAgICBwYWdpbmF0aW9uOiAwLFxuICAgICAgICBzcGVlZDogNzUwLFxuICAgICAgICBicmVha3BvaW50czoge1xuICAgICAgICAgIDE2ODA6IHsgcGVyUGFnZTogNiwgfSxcbiAgICAgICAgICAxMTIwOiB7IHBlclBhZ2U6IDUsIH0sXG4gICAgICAgICAgNzY3OiB7IHBlclBhZ2U6IDMsIHBlck1vdmU6IDIgfSxcbiAgICAgICAgICA2MDA6IHsgcGVyUGFnZTogMiwgZ2FwOiA2IH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHNsaWRlci5tb3VudCgpXG4gICAgfVxuICB9XG5cbiAgaW5pdFNwbGlkZSgpIHtcbiAgICBjb25zdCBzcGxpZGVBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmhvbWUtc3BsaWRlJyldXG4gICAgaWYgKHNwbGlkZUFyci5sZW5ndGgpIHtcbiAgICAgIHNwbGlkZUFyci5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICAgIGxldCBzbGlkZXIgPSBuZXcgU3BsaWRlKGVsZW0sIHtcbiAgICAgICAgICB0eXBlOiBcImxvb3BcIixcbiAgICAgICAgICBwZXJQYWdlOiA1LFxuICAgICAgICAgIHBlck1vdmU6IDEsXG4gICAgICAgICAgYXV0b3BsYXk6IDAsXG4gICAgICAgICAgZ2FwOiBcIjhweFwiLFxuICAgICAgICAgIGFycm93czogMSxcbiAgICAgICAgICBwYWdpbmF0aW9uOiAwLFxuICAgICAgICAgIHNwZWVkOiA3NTAsXG4gICAgICAgICAgYnJlYWtwb2ludHM6IHtcbiAgICAgICAgICAgIDE5ODA6IHtcbiAgICAgICAgICAgICAgcGVyUGFnZTogNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDE2ODA6IHtcbiAgICAgICAgICAgICAgcGVyUGFnZTogNFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDk5MToge1xuICAgICAgICAgICAgICBwZXJQYWdlOiA0LFxuICAgICAgICAgICAgICBwZXJNb3ZlOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDc2Nzoge1xuICAgICAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICAgICAgcm93czogMixcbiAgICAgICAgICAgICAgICBjb2xzOiAzLFxuICAgICAgICAgICAgICAgIGdhcDogeyByb3c6IFwiMjRweFwiLCBjb2w6IFwiOHB4XCIgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNDc4OiB7XG4gICAgICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgICAgICByb3dzOiAyLFxuICAgICAgICAgICAgICAgIGNvbHM6IDJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgc2xpZGVyLm1vdW50KHdpbmRvdy5zcGxpZGUuRXh0ZW5zaW9ucyk7XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5pbml0Q2F0ZWdvcmllc1NwbGlkZSgpXG4gICAgdGhpcy5pbml0U3BsaWRlKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhvbWVwYWdlIiwiY2xhc3MgSm9iQXBwIHtcbiAgY29uc3RydWN0b3IoaG9sZGVyLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgdGhpcy5ob2xkZXIgPSBob2xkZXJcbiAgICB0aGlzLmZpbGVzSG9sZGVyID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignI2pvYl9maWxlc191cGxvYWQnKVxuICAgIHRoaXMuc2VjdGlvbnMgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbG9hbi1zZWN0aW9uXScpXVxuICAgIHRoaXMuY29udGVudCA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWNhc2VfX2NvbnRlbnQnKVxuICAgIHRoaXMuc2Nyb2xsZXIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1zY3JvbGxlcicpXG4gICAgdGhpcy5mb290ZXIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1jYXNlX19mb290ZXInKVxuICAgIHRoaXMuYnRuR3JvdXAgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1jYXNlX19idG4tZ3JvdXAnKVxuICAgIHRoaXMuZXZ0R28gPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbG9hbi1ldnQ9XCJnb1wiXScpXVxuICAgIHRoaXMuZXZ0VG9nZ2xlID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWxvYW4tZXZ0PVwidG9nZ2xlXCJdJyldXG4gICAgdGhpcy5ldnRTdWJtaXQgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbG9hbi1ldnQ9XCJzdWJtaXRcIl0nKV1cbiAgICB0aGlzLmV2dEJhY2sgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbG9hbi1ldnQ9XCJiYWNrXCJdJyldXG4gICAgdGhpcy5iYXIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1iYXInKVxuICAgIHRoaXMuYmFyX3Byb2dyZXNzID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tYmFyX19wcm9ncmVzcycpXG4gICAgdGhpcy5mbG93ID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tZmxvdycpXG4gICAgdGhpcy5maW5pc2ggPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1maW5pc2gnKVxuICAgIHRoaXMubWF4U3RlcHMgPSB1bmRlZmluZWRcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gdW5kZWZpbmVkXG4gICAgdGhpcy5zdGVwc0xlZnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLmVuZFJlYWNoZWQgPSB1bmRlZmluZWRcbiAgICB0aGlzLmF0U3RhcnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZVxuICAgIHRoaXMuZGF0YSA9IHt9XG4gICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgIHNjcm9sbFNwZWVkOiBzZXR0aW5ncy5zY3JvbGxTcGVlZCB8fCA2MDAsXG4gICAgICBlYXNpbmc6IHNldHRpbmdzLmVhc2luZyB8fCAnY3ViaWMtYmV6aWVyKC4zOSwgLjU3NSwgLjU2NSwgMSknLFxuICAgIH1cbiAgICBpZiAodGhpcy5ob2xkZXIpIHtcbiAgICAgIHRoaXMuaW5pdCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxzXG4gICAqL1xuICBnZXQgZ2V0TGVmdFN0ZXBzKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzIC0gdGhpcy5jdXJyZW50U3RlcFxuICB9XG4gIGdldCBnZXRBY3RpdmVTZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlY3Rpb25zW3RoaXMuY3VycmVudFN0ZXBdXG4gIH1cbiAgZ2V0IGdldEFjdGl2ZUlucHV0KCkge1xuICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLmdldEFjdGl2ZVNlY3Rpb25cbiAgICBpZiAoc2VjdGlvbiAmJiBzZWN0aW9uLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnIHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuICBnZXQgZ2V0TG9hZGVySFRNTCgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIHZlcnNpb249XCIxLjFcIiBpZD1cImxvYWRlci0xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCIgd2lkdGg9XCI0MHB4XCIgaGVpZ2h0PVwiNDBweFwiIHZpZXdCb3g9XCIwIDAgNDAgNDBcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgNDAgNDBcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIG9wYWNpdHk9XCIwLjJcIiBmaWxsPVwiIzAwMFwiIGQ9XCJNMjAuMjAxLDUuMTY5Yy04LjI1NCwwLTE0Ljk0Niw2LjY5Mi0xNC45NDYsMTQuOTQ2YzAsOC4yNTUsNi42OTIsMTQuOTQ2LDE0Ljk0NiwxNC45NDYgczE0Ljk0Ni02LjY5MSwxNC45NDYtMTQuOTQ2QzM1LjE0NiwxMS44NjEsMjguNDU1LDUuMTY5LDIwLjIwMSw1LjE2OXogTTIwLjIwMSwzMS43NDljLTYuNDI1LDAtMTEuNjM0LTUuMjA4LTExLjYzNC0xMS42MzQgYzAtNi40MjUsNS4yMDktMTEuNjM0LDExLjYzNC0xMS42MzRjNi40MjUsMCwxMS42MzMsNS4yMDksMTEuNjMzLDExLjYzNEMzMS44MzQsMjYuNTQxLDI2LjYyNiwzMS43NDksMjAuMjAxLDMxLjc0OXpcIj48L3BhdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIiMwMDBcIiBkPVwiTTI2LjAxMywxMC4wNDdsMS42NTQtMi44NjZjLTIuMTk4LTEuMjcyLTQuNzQzLTIuMDEyLTcuNDY2LTIuMDEyaDB2My4zMTJoMEMyMi4zMiw4LjQ4MSwyNC4zMDEsOS4wNTcsMjYuMDEzLDEwLjA0N3pcIj48L3BhdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlVHlwZT1cInhtbFwiIGF0dHJpYnV0ZU5hbWU9XCJ0cmFuc2Zvcm1cIiB0eXBlPVwicm90YXRlXCIgZnJvbT1cIjAgMjAgMjBcIiB0bz1cIjM2MCAyMCAyMFwiIGR1cj1cIjAuNXNcIiByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIj48L2FuaW1hdGVUcmFuc2Zvcm0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgYFxuICB9XG4gIGNyZWF0ZUVsZW0odGFnTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBpZCwgaW5uZXJIVE1MLCBzdHlsZSwgYXR0cmlidXRlcywgdG9BcHBlbmQgfSA9IG9wdGlvbnNcbiAgICBjb25zdCBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKVxuICAgIGlmIChjbGFzc05hbWUpIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIGlmIChpZCkgZWxlbS5pZCA9IGlkO1xuICAgIGlmIChpbm5lckhUTUwpIGVsZW0uaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5zdHlsZSkgeyBlbGVtLnN0eWxlW2tleV0gPSBvcHRpb25zLnN0eWxlW2tleV0gfVxuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5hdHRyaWJ1dGVzKSB7IGVsZW0uc2V0QXR0cmlidXRlKGtleSwgb3B0aW9ucy5hdHRyaWJ1dGVzW2tleV0pIH1cbiAgICB9XG4gICAgaWYgKHRvQXBwZW5kKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRvQXJyYXkodG9BcHBlbmQpKSB7IGVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQpIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1cbiAgfVxuICB0b0FycmF5KHRhcmdldCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQgOiBbdGFyZ2V0XVxuICB9XG4gIGxvYWRpbmdPbih0aW1lVG9SZW1vdmUpIHtcbiAgICBpZiAodGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tY2FzZS1sb2FkZXInKSkgcmV0dXJuXG4gICAgY29uc3QgbG9hZGVyID0gY3JlYXRlRWxlbSgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAnbG9hbi1jYXNlLWxvYWRlcicsXG4gICAgICBpbm5lckhUTUw6IHRoaXMuZ2V0TG9hZGVySFRNTFxuICAgIH0pXG4gICAgdGhpcy5ob2xkZXIuYXBwZW5kQ2hpbGQobG9hZGVyKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmFkZChfX0xPQ0tFRClcbiAgICAgIGlmICh0aW1lVG9SZW1vdmUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnJlbW92ZShfX0xPQ0tFRClcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGxvYWRlci5yZW1vdmUoKVxuICAgICAgICAgIH0sIDM1MCk7XG4gICAgICAgIH0sIHRpbWVUb1JlbW92ZSk7XG4gICAgICB9XG4gICAgfSwgMSk7XG4gIH1cbiAgbG9hZGluZ09mZigpIHtcbiAgICB0aGlzLmhvbGRlci5jbGFzc0xpc3QucmVtb3ZlKF9fTE9DS0VEKVxuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWNhc2UtbG9hZGVyJylcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbG9hZGVyLnJlbW92ZSgpXG4gICAgICB9LCAzNTApO1xuICAgIH1cbiAgfVxuICBzaG93SW5wdXRFcnJvcihpbnB1dCwgdGV4dCkge1xuICAgIGNvbnN0IGVyciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWlucHV0LWVycm9yJykgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubG9hbi1pbnB1dC1lcnJvcicpIDogY3JlYXRlRWxlbSgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAnbG9hbi1pbnB1dC1lcnJvcicsXG4gICAgICBpbm5lckhUTUw6IHRleHRcbiAgICB9KVxuICAgIGlmIChpbnB1dCkge1xuICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZChfX0lOVkFMSUQpXG4gICAgfVxuICAgIHRoaXMuZm9vdGVyLnByZXBlbmQoZXJyKVxuICB9XG4gIGNsZWFyRXJyb3JzKCkge1xuICAgIGNvbnN0IGFjdGl2ZVNlY3Rpb24gPSB0aGlzLmdldEFjdGl2ZVNlY3Rpb25cbiAgICBjb25zdCBpbnB1dHMgPSBbLi4uYWN0aXZlU2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpLCAuLi5hY3RpdmVTZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCcpXVxuICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoX19JTlZBTElEKSlcbiAgICBjb25zdCBlcnIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1pbnB1dC1lcnJvcicpXG4gICAgaWYgKGVycikgZXJyLnJlbW92ZSgpXG4gIH1cbiAgb2JzZXJ2ZUJhcigpIHtcbiAgICBjb25zdCBwcmV2U2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zLnNsaWNlKDAsIHRoaXMuY3VycmVudFN0ZXApLmxlbmd0aFxuICAgIGNvbnN0IHByb2dyZXNzID0gKHByZXZTZWN0aW9ucyArIDEpIC8gdGhpcy5zdGVwcyAqIDEwMFxuICAgIHRoaXMuYmFyX3Byb2dyZXNzLnN0eWxlLndpZHRoID0gYCR7cHJvZ3Jlc3N9JWBcbiAgfVxuICBjbGVhckFsbEZpZWxkcygpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6bm90KFt0eXBlPVwiY2hlY2tib3hcIl0pJyldXG4gICAgY29uc3Qgc2VsZWN0cyA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKV1cbiAgICBjb25zdCBjaGVja2JveGVzID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpXVxuICAgIGNvbnN0IGZ1bGxBcnIgPSBbLi4uaW5wdXRzLCAuLi5zZWxlY3RzLCAuLi5jaGVja2JveGVzXVxuXG4gICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gaW5wdXQudmFsdWUgPSAnJylcbiAgICBzZWxlY3RzLmZvckVhY2goc2VsZWN0ID0+IHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gMClcbiAgICBjaGVja2JveGVzLmZvckVhY2goKGNoZWNrYm94KSA9PiB7IGNoZWNrYm94LmNoZWNrZWQgPSBmYWxzZSB9KVxuICAgIGZ1bGxBcnIuZm9yRWFjaChlbGVtID0+IGVsZW0uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWluXG4gICAqL1xuICBzYXZlKCkge1xuICAgICQoJyNqb2JfYXBwbGljYXRpb25fZm9ybScpLnN1Ym1pdCgpO1xuICB9XG4gIGZpbmlzaE1lc3NhZ2UoKSB7XG4gICAgdGhpcy5sb2FkaW5nT24oMTAwMClcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZmxvdy5zdHlsZS5vcGFjaXR5ID0gMFxuICAgICAgbGV0IGN1cnJlbnRIZWlnaHQgPSB0aGlzLmhvbGRlci5vZmZzZXRIZWlnaHRcbiAgICAgIHRoaXMuaG9sZGVyLnN0eWxlLmhlaWdodCA9IGAke2N1cnJlbnRIZWlnaHR9cHhgXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5maW5pc2guc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgbGV0IHNjcm9sbEggPSB0aGlzLmZpbmlzaC5zY3JvbGxIZWlnaHRcbiAgICAgICAgdGhpcy5ob2xkZXIuc3R5bGUuaGVpZ2h0ID0gYCR7c2Nyb2xsSH1weGBcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5maW5pc2guc3R5bGUub3BhY2l0eSA9IDFcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgICAgICBjb25zdCBjb25mZXR0aSA9IG5ldyBQYWdlQ29uZmV0dGkoKVxuICAgICAgICAgIGNvbmZldHRpLnB1c2goZmFsc2UpXG4gICAgICAgIH0sIDEwKTtcbiAgICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMuZmxvdykgKyAxMClcbiAgICB9LCA4MDApO1xuICB9XG4gIHNsaWRlKHNlY3Rpb24pIHtcbiAgICBzZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbiAgICBjb25zdCBoZWlnaHQgPSBzZWN0aW9uLnNjcm9sbEhlaWdodFxuICAgIGNvbnN0IHB4VG9UcmFuc2Zvcm0gPSB0aGlzLnNlY3Rpb25zLnNsaWNlKDAsIHRoaXMuY3VycmVudFN0ZXApLnJlZHVjZSgoYWNjLCBlbCkgPT4gYWNjICsgZWwuc2Nyb2xsSGVpZ2h0LCAwKVxuICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgXG4gICAgdGhpcy5zY3JvbGxlci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgtJHtweFRvVHJhbnNmb3JtfXB4KWBcbiAgICB0aGlzLnNlY3Rpb25zLmZvckVhY2goZSA9PiBlLmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKSlcbiAgICBzZWN0aW9uLmNsYXNzTGlzdC5hZGQoSVNfQUNUSVZFKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zbGlkaW5nID0gZmFsc2VcbiAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLnNjcm9sbGVyKSk7XG4gIH1cbiAgZ28odG9TdGVwKSB7XG4gICAgaWYgKHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5jb250YWlucyhfX0xPQ0tFRCkpIHJldHVyblxuICAgIGNvbnN0IGlucHV0cyA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpLCAuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKV1cbiAgICBjb25zdCBzdGVwID0gdG9TdGVwIHx8IHRoaXMuY3VycmVudFN0ZXAgfHwgMFxuICAgIGNvbnN0IG5leHRTdGVwID0gc3RlcCArIDFcbiAgICBjb25zdCBuZXh0U2VjdGlvbiA9IHRoaXMuc2VjdGlvbnNbbmV4dFN0ZXBdXG5cbiAgICBpZiAoIXRoaXMuc2VjdGlvbnNbbmV4dFN0ZXAgKyAxXSkge1xuICAgICAgdGhpcy5ldnRHby5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgICAgYnRuLmlubmVySFRNTCA9ICdTdWJtaXQnXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChuZXh0U2VjdGlvbikge1xuICAgICAgdGhpcy5zbGlkaW5nID0gdHJ1ZVxuICAgICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gaW5wdXQuYmx1cigpKVxuICAgICAgdGhpcy5sb2FkaW5nT24oKVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSBuZXh0U3RlcFxuICAgICAgICB0aGlzLnNsaWRlKG5leHRTZWN0aW9uKVxuICAgICAgICB0aGlzLmxvYWRpbmdPZmYoKVxuICAgICAgICB0aGlzLm9ic2VydmVCYXIoKVxuICAgICAgfSwgNjAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zYXZlKClcbiAgICAgIHRoaXMuZmluaXNoTWVzc2FnZSgpXG4gICAgfVxuICB9XG4gIGJhY2sodG9TdGVwKSB7XG4gICAgaWYgKHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5jb250YWlucyhfX0xPQ0tFRCkpIHJldHVyblxuICAgIHRoaXMuY2xlYXJFcnJvcnMoKVxuICAgIGNvbnN0IHN0ZXAgPSB0b1N0ZXAgfHwgdGhpcy5jdXJyZW50U3RlcCB8fCAwXG4gICAgY29uc3QgcHJldlN0ZXAgPSBzdGVwIC0gMVxuICAgIGNvbnN0IHByZXZTZWN0aW9uID0gdGhpcy5zZWN0aW9uc1twcmV2U3RlcF1cbiAgICBpZiAocHJldlNlY3Rpb24pIHtcbiAgICAgIHRoaXMuZXZ0R28uZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICAgIGJ0bi5pbm5lckhUTUwgPSAnTmV4dCdcbiAgICAgIH0pXG4gICAgICB0aGlzLmN1cnJlbnRTdGVwID0gcHJldlN0ZXBcbiAgICAgIHRoaXMuc2xpZGUocHJldlNlY3Rpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9nZ2xlKClcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGUoc2VjdGlvbikge1xuICAgIGNvbnN0IHJlcXVpcmVkVGV4dElucHV0cyA9IFsuLi5zZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJ0ZXh0XCJdW3JlcXVpcmVkXTpub3QoLi0tZGlzYWJsZWQnKSwgLi4uc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiZW1haWxcIl1bcmVxdWlyZWRdJyldXG4gICAgY29uc3QgZW1wdHlJbnB1dHMgPSByZXF1aXJlZFRleHRJbnB1dHMuZmlsdGVyKGlucHV0ID0+ICFpbnB1dC52YWx1ZSlcbiAgICBjb25zdCBudW1iZXJJbnB1dHMgPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W2RhdGEtdmFsaWRhdGU9XCJudW1iZXJcIl0nKVxuICAgIGNvbnN0IHNlbGVjdElucHV0cyA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0W3JlcXVpcmVkXScpXG4gICAgY29uc3QgZW1haWxJbnB1dHMgPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W2RhdGEtdmFsaWRhdGU9XCJlbWFpbFwiXScpXG4gICAgY29uc3QgemlwSW5wdXRzID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtkYXRhLXZhbGlkYXRlPVwiemlwX2NvZGVcIl0nKVxuICAgIGNvbnN0IGZpbGVJbnB1dHMgPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3JlcXVpcmVkXVt0eXBlPVwiZmlsZVwiXScpXG4gICAgY29uc3Qgc2VjdGlvbklEID0gc2VjdGlvbi5kYXRhc2V0LmxvYW5TZWN0aW9uXG5cbiAgICBpZiAocmVxdWlyZWRUZXh0SW5wdXRzLnNvbWUoaW5wdXQgPT4gaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKF9fSU5WQUxJRCkpKSByZXR1cm4gZmFsc2VcblxuICAgIGlmIChzZWxlY3RJbnB1dHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdCBvZiBzZWxlY3RJbnB1dHMpIHtcbiAgICAgICAgaWYgKCFzZWxlY3QudmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnNob3dJbnB1dEVycm9yKHNlbGVjdCwgJ1BsZWFzZSBzZWxlY3QgYW4gb3B0aW9uJylcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnVtYmVySW5wdXRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBudW1iZXJJbnB1dHNbMF0udmFsdWVcbiAgICAgIGNvbnN0IHJlZ2V4ID0gL15cXCtcXGR7MX1cXHNcXChcXGR7M31cXClcXHNcXGR7M31cXC1cXGR7NH0kL1xuICAgICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICB0aGlzLnNob3dJbnB1dEVycm9yKG51bWJlcklucHV0c1swXSwgJ1BsZWFzZSBlbnRlciBhIHZhbGlkIHBob25lIG51bWJlcicpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW1haWxJbnB1dHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGVtYWlsSW5wdXRzWzBdLnZhbHVlXG4gICAgICBjb25zdCByZWdleCA9IC9eW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtekEtWjAtOS1dKyg/OlxcLlthLXpBLVowLTktXSspKiQvXG4gICAgICBpZiAoIXJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc2hvd0lucHV0RXJyb3IoZW1haWxJbnB1dHNbMF0sICdQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCcpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoemlwSW5wdXRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB6aXBJbnB1dHNbMF0udmFsdWVcbiAgICAgIGNvbnN0IHJlZ2V4ID0gL15cXGR7NX0kL1xuICAgICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICB0aGlzLnNob3dJbnB1dEVycm9yKHppcElucHV0c1swXSwgJ1BsZWFzZSBlbnRlciBhIHZhbGlkIHppcCBjb2RlJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbXB0eUlucHV0cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc2hvd0lucHV0RXJyb3IoZW1wdHlJbnB1dHNbMF0sICdUaGlzIGZpZWxkIGlzIHJlcXVpcmVkJylcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoZmlsZUlucHV0cy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgZmlsZUlucHV0cykge1xuICAgICAgICBpZiAoIWlucHV0LmZpbGVzWzBdKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coaW5wdXQuZmlsZXMpXG4gICAgICAgICAgdGhpcy5zaG93SW5wdXRFcnJvcihudWxsLCAnUGxlYXNlIHVwbG9hZCBhIGZpbGUnKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xlYXJFcnJvcnMoKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgYWRqdXN0QWN0aXZlU2VjdGlvbkhlaWdodCgpIHtcbiAgICBjb25zdCBhY3RpdmVTZWN0aW9uID0gdGhpcy5nZXRBY3RpdmVTZWN0aW9uXG4gICAgaWYgKGFjdGl2ZVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGFjdGl2ZVNlY3Rpb24uc2Nyb2xsSGVpZ2h0XG4gICAgICB0aGlzLmNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YFxuICAgIH1cbiAgfVxuICB0b2dnbGUoKSB7XG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKVxuICAgIGNvbnN0IGhlYWRlck5hdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5oZWFkZXJfX3N1Yi1uYXYnKVxuICAgIGNvbnN0IHdlbGNvbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc3VicGFnZV9fd2VsY29tZScpXG4gICAgY29uc3QgZm9vdGVyTWFpbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb290ZXJfX3dyYXBwZXIgPiAud3JhcHBlcicpXG4gICAgY29uc3QgbG9hbldlbGNvbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubG9hbi13ZWxjb21lJylcbiAgICBjb25zdCBoZWFkaW5nID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxvYW4tY2FzZV9faGVhZGluZycpXG4gICAgY29uc3QgYmFja0dyb3VwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxvYW4tY2FzZV9fYmFjay1ncm91cCcpXG4gICAgY29uc3QgQ0FTRV9DTEFTUyA9ICdsb2FuX2Nhc2UnXG4gICAgY29uc3QgZWxlbWVudHMgPSBbaGVhZGVyTmF2LCB3ZWxjb21lLCBmb290ZXJNYWluLCBsb2FuV2VsY29tZV1cblxuICAgIGNvbnN0IGhpZGVFbGVtZW50ID0gKGVsKSA9PiB7XG4gICAgICBjb25zdCBjdXJIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHRcbiAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGAke2N1ckhlaWdodH1weGBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9ICcwcHgnXG4gICAgICB9LCAxKTtcbiAgICB9XG4gICAgY29uc3Qgc2hvd0VsZW1lbnQgPSAoZWwpID0+IHtcbiAgICAgIGNvbnN0IGN1ckhlaWdodCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKVxuICAgICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gZWwuc2Nyb2xsSGVpZ2h0XG4gICAgICBlbC5zdHlsZS5oZWlnaHQgPSBgJHtjdXJIZWlnaHR9YFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLm92ZXJmbG93ID0gJ3Zpc2libGUnXG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGAke3Njcm9sbEhlaWdodH1weGBcbiAgICAgIH0sIDEpXG4gICAgfVxuXG4gICAgY29uc3QgaGlkZUxvYW4gPSAoKSA9PiB7XG4gICAgICBib2R5LmNsYXNzTGlzdC5yZW1vdmUoQ0FTRV9DTEFTUylcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBpZiAoZWxlbWVudCkgc2hvd0VsZW1lbnQoZWxlbWVudClcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGxlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICB0aGlzLmNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gYDBweGBcblxuICAgICAgaWYgKGJhY2tHcm91cCkge1xuICAgICAgICBiYWNrR3JvdXAuc3R5bGUuaGVpZ2h0ID0gYDBweGBcbiAgICAgIH1cblxuICAgICAgaWYgKGhlYWRpbmcpIHtcbiAgICAgICAgaGVhZGluZy5pbm5lckhUTUwgPSAnV2VsY29tZSBUbyB0aGUgSWNlYm94IE1heCBBcHByb3ZhbCBGaW5hbmNpbmcgRm9ybSdcbiAgICAgICAgaGVhZGluZy5jbGFzc0xpc3QucmVtb3ZlKCctLWJpZycpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2xlYXJFcnJvcnMoKVxuICAgICAgdGhpcy5iYWNrKDEpXG4gICAgICB0aGlzLmNsZWFyQWxsRmllbGRzKClcbiAgICB9XG4gICAgY29uc3Qgc2hvd0xvYW4gPSAoKSA9PiB7XG4gICAgICBib2R5LmNsYXNzTGlzdC5hZGQoJ2xvYW5fY2FzZScpXG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIGhpZGVFbGVtZW50KGVsZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2Nyb2xsZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xuICAgICAgdGhpcy5jb250ZW50LnN0eWxlLmhlaWdodCA9IGAke3RoaXMuc2VjdGlvbnNbMF0uc2Nyb2xsSGVpZ2h0fXB4YFxuXG4gICAgICBpZiAoYmFja0dyb3VwKSB7XG4gICAgICAgIGJhY2tHcm91cC5zdHlsZS5oZWlnaHQgPSBgJHtiYWNrR3JvdXAuc2Nyb2xsSGVpZ2h0fXB4YFxuICAgICAgfVxuXG4gICAgICBpZiAoaGVhZGluZykge1xuICAgICAgICBoZWFkaW5nLmlubmVySFRNTCA9ICdKb2IgQXBwbGljYXRpb24nXG4gICAgICAgIGhlYWRpbmcuY2xhc3NMaXN0LmFkZCgnLS1iaWcnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChib2R5LmNsYXNzTGlzdC5jb250YWlucyhDQVNFX0NMQVNTKSkge1xuICAgICAgY29uc3QgYXNrTW9kYWwgPSBuZXcgQXNrTW9kYWwoe1xuICAgICAgICBoZWFkaW5nOiAnQXJlIFlvdSBTdXJlIFlvdSBXYW50IFRvIEV4aXQgRmluYW5jaW5nIEFwcD8nLFxuICAgICAgICBzdWJoZWFkaW5nOiAnWW91IHdpbGwgbG9zZSBhbGwgdGhlIHByb2dyZXNzLiBLZWVwIGZpbGxpbmcgb3V0IHRoZSBmb3JtIGFuZCBnZXQgYXBwcm92ZWQgYXMgc29vbiBhcyBwb3NzaWJsZSEnLFxuICAgICAgICBleGl0VGV4dDogJ0V4aXQnLFxuICAgICAgICBrZWVwVGV4dDogJ0tlZXAgRmlsbGluZycsXG4gICAgICAgIGV4aXRDYWxsYmFjazogaGlkZUxvYW4sXG4gICAgICB9KVxuICAgICAgYXNrTW9kYWwuc2hvdygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3dMb2FuKClcbiAgICB9XG4gIH1cbiAgdGFiUHJlc3MoKSB7XG4gICAgaWYgKCF0aGlzLnNsaWRpbmcpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUlucHV0ID0gdGhpcy5nZXRBY3RpdmVJbnB1dFxuICAgICAgaWYgKCFhY3RpdmVJbnB1dCkge1xuICAgICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5nZXRBY3RpdmVTZWN0aW9uXG4gICAgICAgIGNvbnN0IGlucHV0QXJyYXkgPSBbLi4uc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dDpub3QoLi0tZGlzYWJsZWQpLCBzZWxlY3Q6bm90KC4tLWRpc2FibGVkKScpXVxuICAgICAgICBpZiAoaW5wdXRBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgaW5wdXRUb0ZvY3VzXG4gICAgICAgICAgY29uc3QgaW52YWxpZElucHV0cyA9IGlucHV0QXJyYXkuZmlsdGVyKGlucHV0ID0+IGlucHV0LmNsYXNzTGlzdC5jb250YWlucygnLS1pbnZhbGlkJykpXG4gICAgICAgICAgaWYgKGludmFsaWRJbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpbnB1dFRvRm9jdXMgPSBpbnZhbGlkSW5wdXRzWzBdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5SW5wdXRzID0gaW5wdXRBcnJheS5maWx0ZXIoaW5wdXQgPT4gIWlucHV0LnZhbHVlICYmIGlucHV0LnZhbHVlICE9PSAwKVxuICAgICAgICAgICAgaWYgKGVtcHR5SW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpbnB1dFRvRm9jdXMgPSBlbXB0eUlucHV0c1swXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5wdXRUb0ZvY3VzID0gaW5wdXRBcnJheVswXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dFRvRm9jdXMuZm9jdXMoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhY3RpdmVJbnB1dFdyYXAgPSBhY3RpdmVJbnB1dC5wYXJlbnROb2RlLmNsb3Nlc3QoJy5sb2FuLWlucHV0LXdyYXAnKVxuICAgICAgICBjb25zdCBuZXh0SW5wdXRXcmFwID0gYWN0aXZlSW5wdXRXcmFwLm5leHRFbGVtZW50U2libGluZ1xuICAgICAgICBpZiAobmV4dElucHV0V3JhcCkge1xuICAgICAgICAgIGNvbnN0IG5leHRJbnB1dCA9IG5leHRJbnB1dFdyYXAucXVlcnlTZWxlY3RvcignaW5wdXQsIHNlbGVjdCcpXG4gICAgICAgICAgaWYgKG5leHRJbnB1dCkge1xuICAgICAgICAgICAgbmV4dElucHV0LmZvY3VzKClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RJbnB1dFdyYXAgPSB0aGlzLmdldEFjdGl2ZVNlY3Rpb24ucXVlcnlTZWxlY3RvcignLmxvYW4taW5wdXQtd3JhcCcpXG4gICAgICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IGZpcnN0SW5wdXRXcmFwLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LCBzZWxlY3QnKVxuICAgICAgICAgIGlmIChmaXJzdElucHV0KSB7XG4gICAgICAgICAgICBmaXJzdElucHV0LmZvY3VzKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQmluZCBFdmVudHNcbiAgICovXG4gIGJpbmRTdGVwRXZ0KCkge1xuICAgIHRoaXMuZXZ0R28uZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuZ2V0QWN0aXZlU2VjdGlvblxuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZShzZWN0aW9uKSkgdGhpcy5nbygpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5ldnRCYWNrLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmJhY2soKVxuICAgICAgfSlcbiAgICB9KVxuICAgIHRoaXMuZXZ0U3VibWl0LmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHRoaXMuZXZ0R29bMF0uY2xpY2soKVxuICAgICAgfSlcbiAgICB9KVxuICAgIHRoaXMuZXZ0VG9nZ2xlLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgdGhpcy50b2dnbGUoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gIH1cbiAgYmluZElucHV0RXZlbnRzKCkge1xuICAgIGNvbnN0IGlucHV0cyA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpXVxuICAgIGNvbnN0IHNlbGVjdHMgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0JyldXG4gICAgY29uc3Qgbm9XZWJzaXRlQ2hlY2tib3ggPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcjbG9hbl9lbXBsb3llcl93ZWJzaXRlJylcbiAgICBjb25zdCBpbnB1dFdlYnNpdGVFbXBsb3llciA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJyNsb2FuX2VtcGxveWVyX3dlYnNpdGUnKVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICBjb25zdCBpc1RhYiA9IGUua2V5ID09PSAnVGFiJ1xuICAgICAgaWYgKGlzVGFiKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnbG9hbl9jYXNlJykpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICB0aGlzLnRhYlByZXNzKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyRXJyb3JzKClcbiAgICAgICAgY29uc3QgcGFyZW50ID0gaW5wdXQucGFyZW50Tm9kZS5jbG9zZXN0KCcubG9hbi1pbnB1dC13cmFwJylcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5jbGFzc0xpc3QuYWRkKCctLWZvY3VzZWQnKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gaW5wdXQucGFyZW50Tm9kZS5jbG9zZXN0KCcubG9hbi1pbnB1dC13cmFwJylcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKCctLWZvY3VzZWQnKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYXJFcnJvcnMoKVxuICAgICAgICBjb25zdCBpc0VudGVyID0gZS5rZXkgPT09ICdFbnRlcidcbiAgICAgICAgY29uc3QgaXNUYWIgPSBlLmtleSA9PT0gJ1RhYidcbiAgICAgICAgaWYgKGlzRW50ZXIpIHtcbiAgICAgICAgICB0aGlzLmV2dEdvWzBdLmNsaWNrKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICAgIHNlbGVjdHMuZm9yRWFjaCgoc2VsZWN0KSA9PiB7XG4gICAgICBzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyRXJyb3JzKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuICBiaW5kU1NOSW5wdXQoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbZGF0YS1mb3JtYXQ9XCJzc25cIl0nKVxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZS50YXJnZXQudmFsdWVcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gJydcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoYXIgPSB2YWx1ZS5jaGFyQXQoaSlcbiAgICAgICAgICBpZiAoY2hhci5tYXRjaCgvXlswLTldJC8pICYmIG5ld1ZhbHVlLmxlbmd0aCA8IDkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlICs9IGNoYXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZS50YXJnZXQudmFsdWUgPSBuZXdWYWx1ZVxuICAgICAgfSlcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhbXjAtOV0pL2csICcnKVxuICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUuc2xpY2UoMCwgMykgKyAn4oCUJyArIG5ld1ZhbHVlLnNsaWNlKDMsIDUpICsgJ+KAlCcgKyBuZXdWYWx1ZS5zbGljZSg1KVxuICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gbmV3VmFsdWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKGUpID0+IHtcbiAgICAgICAgZS50YXJnZXQudmFsdWUgPSBlLnRhcmdldC52YWx1ZS5yZXBsYWNlKC8oW14wLTldKS9nLCAnJylcbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGJpbmROdW1iZXJJbnB1dCgpIHtcbiAgICBjb25zdCBpbnB1dHMgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtkYXRhLXZhbGlkYXRlPVwibnVtYmVyXCJdJylcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgbGV0IGtleUNvZGU7XG4gICAgICBmdW5jdGlvbiBtYXNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LmtleUNvZGUgJiYgKGtleUNvZGUgPSBldmVudC5rZXlDb2RlKTtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGlmIChwb3MgPCAzKSBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGxldCBtYXRyaXggPSBcIisxIChfX18pIF9fXy1fX19fXCIsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgZGVmID0gbWF0cml4LnJlcGxhY2UoL1xcRC9nLCBcIlwiKSxcbiAgICAgICAgICB2YWwgPSB0aGlzLnZhbHVlLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSxcbiAgICAgICAgICBuZXdWYWx1ZSA9IG1hdHJpeC5yZXBsYWNlKC9bX1xcZF0vZywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBpIDwgdmFsLmxlbmd0aCA/IHZhbC5jaGFyQXQoaSsrKSB8fCBkZWYuY2hhckF0KGkpIDogYTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgaSA9IG5ld1ZhbHVlLmluZGV4T2YoXCJfXCIpO1xuICAgICAgICBpZiAoaSAhPSAtMSkge1xuICAgICAgICAgIGkgPCA1ICYmIChpID0gMyk7XG4gICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVnID0gbWF0cml4LnN1YnN0cigwLCB0aGlzLnZhbHVlLmxlbmd0aCkucmVwbGFjZSgvXysvZyxcbiAgICAgICAgICBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXGR7MSxcIiArIGEubGVuZ3RoICsgXCJ9XCI7XG4gICAgICAgICAgfSkucmVwbGFjZSgvWysoKV0vZywgXCJcXFxcJCZcIik7XG4gICAgICAgIHJlZyA9IG5ldyBSZWdFeHAoXCJeXCIgKyByZWcgKyBcIiRcIik7XG4gICAgICAgIGlmICghcmVnLnRlc3QodGhpcy52YWx1ZSkgfHwgdGhpcy52YWx1ZS5sZW5ndGggPCA1IHx8IGtleUNvZGUgPiA0NyAmJiBrZXlDb2RlIDwgNTgpIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJibHVyXCIgJiYgdGhpcy52YWx1ZS5sZW5ndGggPCA1KSB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgIH1cblxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIG1hc2ssIGZhbHNlKTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBtYXNrLCBmYWxzZSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBtYXNrLCBmYWxzZSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBtYXNrLCBmYWxzZSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGlmIChpbnB1dC52YWx1ZS5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoNCwgNClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShpbnB1dC52YWx1ZS5sZW5ndGgsIGlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZFJlc3VtZVVwbG9hZCgpIHtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNqb2JfcmVzdW1lJylcbiAgICBjb25zdCBib3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1sb2FuPVwiZmlsZXNfdXBsb2FkXCJdJylcbiAgICBjb25zdCBob2xkZXIgPSB0aGlzLmZpbGVzSG9sZGVyXG4gICAgLy8gaWYgKCFpbnB1dCB8fCAhYm94IHx8ICFob2xkZXIpIHRocm93IG5ldyBFcnJvcignSlMgOiBCaW5kIElEIFVwbG9hZCA6IElucHV0IG9yIEJveCBvciBIb2xkZXIgbm90IGZvdW5kJylcblxuICAgIGlmIChpbnB1dCAmJiBib3ggJiYgaG9sZGVyKSB7XG5cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3NGaWxlcyhmaWxlcykge1xuICAgICAgICBjb25zdCBhbGxvd2VkRXh0ZW5zaW9ucyA9IFsncGRmJywgJ2RvY3gnLCAnZG9jJ11cbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGZpbGUubmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbmFtZS5zcGxpdCgnLicpLnBvcCgpXG4gICAgICAgICAgaWYgKGFsbG93ZWRFeHRlbnNpb25zLmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGZpbGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJveC5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyRXJyb3JzKClcbiAgICAgICAgaW5wdXQuY2xpY2soKVxuICAgICAgfVxuICAgICAgaW5wdXQub25jaGFuZ2UgPSAoZSkgPT4ge1xuICAgICAgICBwcm9jZXNzRmlsZXMoZS50YXJnZXQuZmlsZXMpXG4gICAgICB9XG4gICAgICBib3gub25kcmFnb3ZlciA9IChlKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYXJFcnJvcnMoKVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgYm94LmNsYXNzTGlzdC5hZGQoSVNfQUNUSVZFKVxuICAgICAgfVxuICAgICAgYm94Lm9uZHJhZ2xlYXZlID0gKGUpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckVycm9ycygpXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBib3guY2xhc3NMaXN0LnJlbW92ZShJU19BQ1RJVkUpXG4gICAgICB9XG4gICAgICBib3gub25kcm9wID0gKGUpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckVycm9ycygpXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBib3guY2xhc3NMaXN0LnJlbW92ZShJU19BQ1RJVkUpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJpbmREdWFsU2VsZWN0KCkge1xuICAgIGNvbnN0IGR1YWxBcnIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1sb2FuLWV2dD1cImR1YWxfc2VsZWN0XCJdJylcbiAgICBmb3IgKGNvbnN0IGR1YWwgb2YgZHVhbEFycikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkdWFsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Om5vdChbdHlwZT1cImNoZWNrYm94XCJdKScpXG4gICAgICBjb25zdCBjaGVja2JveCA9IGR1YWwucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJylcbiAgICAgIGlmIChpbnB1dCAmJiBjaGVja2JveCkge1xuICAgICAgICBjaGVja2JveC5vbmNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICBsZXQgaXNDaGVja2VkID0gY2hlY2tib3guY2hlY2tlZFxuICAgICAgICAgIGlmIChpc0NoZWNrZWQpIHtcbiAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJy0tZGlzYWJsZWQnKVxuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpXG4gICAgICAgICAgICBpZiAoaW5wdXQudHlwZSAhPT0gJ3JhbmdlJykge1xuICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKVxuICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSgnLS1kaXNhYmxlZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmFuZ2VPdXRwdXRBcnIgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnLmN1c3RvbS1yYW5nZV9fb3V0cHV0JyldXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiByYW5nZU91dHB1dEFycikge1xuICAgICAgY29uc3QgcGFyZW50ID0gaW5wdXQuY2xvc2VzdCgnW2RhdGEtbG9hbi1ldnQ9XCJkdWFsX3NlbGVjdFwiXScpXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlSW5wdXQgPSBwYXJlbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cInJhbmdlXCJdJylcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgICBjb25zdCBtYXhWYWx1ZSA9IHJhbmdlSW5wdXQubWF4XG4gICAgICAgICAgY29uc3QgbWluVmFsdWUgPSByYW5nZUlucHV0Lm1pblxuXG4gICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS50YXJnZXQudmFsdWUgPSBlLnRhcmdldC52YWx1ZS5yZXBsYWNlKC9bXjAtOV0vZywgJycpXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS50YXJnZXQudmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihlLnRhcmdldC52YWx1ZSwgbWF4VmFsdWUpLCBtaW5WYWx1ZSlcbiAgICAgICAgICAgIHJhbmdlSW5wdXQudmFsdWUgPSBlLnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgcmFuZ2VJbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnKSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJpbmRGb3JtYXR0aW5nKCkge1xuICAgIGNvbnN0IGN1cnJlbmN5QXJyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZm9ybWF0PVwiY3VycmVuY3lcIl0nKVxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgY3VycmVuY3lBcnIpIHtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGlucHV0LnZhbHVlXG4gICAgICAgIGlmICh2YWwubGVuZ3RoKSB7XG4gICAgICAgICAgaW5wdXQudmFsdWUgPSBmb3JtYXRBc0N1cnJlbmN5KHZhbClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbFxuICAgKi9cbiAgc2V0SW5pdGlhbFZhcigpIHtcbiAgICB0aGlzLnN0ZXBzID0gdGhpcy5zZWN0aW9ucy5sZW5ndGhcbiAgICBpZiAoIXRoaXMuc3RlcHMpIHRocm93IG5ldyBFcnJvcignTm8gTG9hbiBTZWN0aW9ucyBGb3VuZCcpXG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IDBcbiAgICB0aGlzLnN0ZXBzTGVmdCA9IHRoaXMuc3RlcHNcbiAgICB0aGlzLmVuZFJlYWNoZWQgPSBmYWxzZVxuICAgIHRoaXMuYXRUaGVTdGFydCA9IHRydWVcbiAgfVxuICBzZXRJbml0aWFsTGF5b3V0KCkge1xuICAgIGNvbnN0IGZpcnN0U2VjdGlvbiA9IHRoaXMuc2VjdGlvbnNbMF1cbiAgICBjb25zdCBoZWlnaHQgPSBmaXJzdFNlY3Rpb24uc2Nyb2xsSGVpZ2h0XG4gICAgdGhpcy5jb250ZW50LnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGBcbiAgICB0aGlzLmNvbnRlbnQuc3R5bGUudHJhbnNpdGlvbiA9IGBhbGwgJHt0aGlzLnNldHRpbmdzLnNjcm9sbFNwZWVkfW1zICR7dGhpcy5zZXR0aW5ncy5lYXNpbmd9YFxuICAgIHRoaXMuc2Nyb2xsZXIuc3R5bGUudHJhbnNpdGlvbiA9IGBhbGwgJHt0aGlzLnNldHRpbmdzLnNjcm9sbFNwZWVkfW1zICR7dGhpcy5zZXR0aW5ncy5lYXNpbmd9YFxuICAgIC8vIHRoaXMuc2VjdGlvbnMuZm9yRWFjaChzZWN0aW9uID0+IHNlY3Rpb24uc3R5bGUuZGlzcGxheSA9ICdmbGV4JylcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuc2V0SW5pdGlhbExheW91dCgpXG4gICAgdGhpcy5zZXRJbml0aWFsVmFyKClcbiAgICB0aGlzLmJpbmRTdGVwRXZ0KClcbiAgICB0aGlzLmJpbmRJbnB1dEV2ZW50cygpXG4gICAgdGhpcy5iaW5kTnVtYmVySW5wdXQoKVxuICAgIHRoaXMuYmluZFNTTklucHV0KClcbiAgICB0aGlzLmJpbmRSZXN1bWVVcGxvYWQoKVxuICAgIHRoaXMuYmluZER1YWxTZWxlY3QoKVxuICAgIHRoaXMuYmluZEZvcm1hdHRpbmcoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSm9iQXBwIiwiY2xhc3MgTG9hbkFwcCB7XG4gIGNvbnN0cnVjdG9yKGhvbGRlciwgc2V0dGluZ3MgPSB7fSkge1xuICAgIHRoaXMuaG9sZGVyID0gaG9sZGVyXG4gICAgdGhpcy5maWxlc0hvbGRlciA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJyNsb2FuX2ZpbGVzX3VwbG9hZCcpXG4gICAgdGhpcy5zZWN0aW9ucyA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1sb2FuLXNlY3Rpb25dJyldXG4gICAgdGhpcy5jb250ZW50ID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tY2FzZV9fY29udGVudCcpXG4gICAgdGhpcy5zY3JvbGxlciA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLXNjcm9sbGVyJylcbiAgICB0aGlzLmZvb3RlciA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWNhc2VfX2Zvb3RlcicpXG4gICAgdGhpcy5idG5Hcm91cCA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWNhc2VfX2J0bi1ncm91cCcpXG4gICAgdGhpcy5ldnRHbyA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1sb2FuLWV2dD1cImdvXCJdJyldXG4gICAgdGhpcy5ldnRUb2dnbGUgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbG9hbi1ldnQ9XCJ0b2dnbGVcIl0nKV1cbiAgICB0aGlzLmV2dFN1Ym1pdCA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1sb2FuLWV2dD1cInN1Ym1pdFwiXScpXVxuICAgIHRoaXMuZXZ0QmFjayA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1sb2FuLWV2dD1cImJhY2tcIl0nKV1cbiAgICB0aGlzLmJhciA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWJhcicpXG4gICAgdGhpcy5iYXJfcHJvZ3Jlc3MgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1iYXJfX3Byb2dyZXNzJylcbiAgICB0aGlzLmZsb3cgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1mbG93JylcbiAgICB0aGlzLmZpbmlzaCA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWZpbmlzaCcpXG4gICAgdGhpcy5tYXhTdGVwcyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuY3VycmVudFN0ZXAgPSB1bmRlZmluZWRcbiAgICB0aGlzLnN0ZXBzTGVmdCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuZW5kUmVhY2hlZCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuYXRTdGFydCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlXG4gICAgdGhpcy5kYXRhID0ge31cbiAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgc2Nyb2xsU3BlZWQ6IHNldHRpbmdzLnNjcm9sbFNwZWVkIHx8IDYwMCxcbiAgICAgIGVhc2luZzogc2V0dGluZ3MuZWFzaW5nIHx8ICdjdWJpYy1iZXppZXIoLjM5LCAuNTc1LCAuNTY1LCAxKScsXG4gICAgfVxuICAgIGlmICh0aGlzLmhvbGRlcikge1xuICAgICAgdGhpcy5pbml0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXRpbHNcbiAgICovXG4gIGdldCBnZXRMZWZ0U3RlcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHMgLSB0aGlzLmN1cnJlbnRTdGVwXG4gIH1cbiAgZ2V0IGdldEFjdGl2ZVNlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VjdGlvbnNbdGhpcy5jdXJyZW50U3RlcF1cbiAgfVxuICBnZXQgZ2V0QWN0aXZlSW5wdXQoKSB7XG4gICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuZ2V0QWN0aXZlU2VjdGlvblxuICAgIGlmIChzZWN0aW9uICYmIHNlY3Rpb24uY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50LnRhZ05hbWUgPT09ICdJTlBVVCcgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICB9XG4gIGdldCBnZXRMb2FkZXJIVE1MKCkge1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgdmVyc2lvbj1cIjEuMVwiIGlkPVwibG9hZGVyLTFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB3aWR0aD1cIjQwcHhcIiBoZWlnaHQ9XCI0MHB4XCIgdmlld0JveD1cIjAgMCA0MCA0MFwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDAgMCA0MCA0MFwiIHhtbDpzcGFjZT1cInByZXNlcnZlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggb3BhY2l0eT1cIjAuMlwiIGZpbGw9XCIjMDAwXCIgZD1cIk0yMC4yMDEsNS4xNjljLTguMjU0LDAtMTQuOTQ2LDYuNjkyLTE0Ljk0NiwxNC45NDZjMCw4LjI1NSw2LjY5MiwxNC45NDYsMTQuOTQ2LDE0Ljk0NiBzMTQuOTQ2LTYuNjkxLDE0Ljk0Ni0xNC45NDZDMzUuMTQ2LDExLjg2MSwyOC40NTUsNS4xNjksMjAuMjAxLDUuMTY5eiBNMjAuMjAxLDMxLjc0OWMtNi40MjUsMC0xMS42MzQtNS4yMDgtMTEuNjM0LTExLjYzNCBjMC02LjQyNSw1LjIwOS0xMS42MzQsMTEuNjM0LTExLjYzNGM2LjQyNSwwLDExLjYzMyw1LjIwOSwxMS42MzMsMTEuNjM0QzMxLjgzNCwyNi41NDEsMjYuNjI2LDMxLjc0OSwyMC4yMDEsMzEuNzQ5elwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwiIzAwMFwiIGQ9XCJNMjYuMDEzLDEwLjA0N2wxLjY1NC0yLjg2NmMtMi4xOTgtMS4yNzItNC43NDMtMi4wMTItNy40NjYtMi4wMTJoMHYzLjMxMmgwQzIyLjMyLDguNDgxLDI0LjMwMSw5LjA1NywyNi4wMTMsMTAuMDQ3elwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVUeXBlPVwieG1sXCIgYXR0cmlidXRlTmFtZT1cInRyYW5zZm9ybVwiIHR5cGU9XCJyb3RhdGVcIiBmcm9tPVwiMCAyMCAyMFwiIHRvPVwiMzYwIDIwIDIwXCIgZHVyPVwiMC41c1wiIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiPjwvYW5pbWF0ZVRyYW5zZm9ybT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICBgXG4gIH1cbiAgY3JlYXRlRWxlbSh0YWdOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIGlkLCBpbm5lckhUTUwsIHN0eWxlLCBhdHRyaWJ1dGVzLCB0b0FwcGVuZCB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpXG4gICAgaWYgKGNsYXNzTmFtZSkgZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgaWYgKGlkKSBlbGVtLmlkID0gaWQ7XG4gICAgaWYgKGlubmVySFRNTCkgZWxlbS5pbm5lckhUTUwgPSBpbm5lckhUTUw7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zLnN0eWxlKSB7IGVsZW0uc3R5bGVba2V5XSA9IG9wdGlvbnMuc3R5bGVba2V5XSB9XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zLmF0dHJpYnV0ZXMpIHsgZWxlbS5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSkgfVxuICAgIH1cbiAgICBpZiAodG9BcHBlbmQpIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdG9BcnJheSh0b0FwcGVuZCkpIHsgZWxlbS5hcHBlbmRDaGlsZChjaGlsZCkgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbVxuICB9XG4gIHRvQXJyYXkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldCA6IFt0YXJnZXRdXG4gIH1cbiAgbG9hZGluZ09uKHRpbWVUb1JlbW92ZSkge1xuICAgIGlmICh0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1jYXNlLWxvYWRlcicpKSByZXR1cm5cbiAgICBjb25zdCBsb2FkZXIgPSBjcmVhdGVFbGVtKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICdsb2FuLWNhc2UtbG9hZGVyJyxcbiAgICAgIGlubmVySFRNTDogdGhpcy5nZXRMb2FkZXJIVE1MXG4gICAgfSlcbiAgICB0aGlzLmhvbGRlci5hcHBlbmRDaGlsZChsb2FkZXIpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmhvbGRlci5jbGFzc0xpc3QuYWRkKF9fTE9DS0VEKVxuICAgICAgaWYgKHRpbWVUb1JlbW92ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmhvbGRlci5jbGFzc0xpc3QucmVtb3ZlKF9fTE9DS0VEKVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgbG9hZGVyLnJlbW92ZSgpXG4gICAgICAgICAgfSwgMzUwKTtcbiAgICAgICAgfSwgdGltZVRvUmVtb3ZlKTtcbiAgICAgIH1cbiAgICB9LCAxKTtcbiAgfVxuICBsb2FkaW5nT2ZmKCkge1xuICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5yZW1vdmUoX19MT0NLRUQpXG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tY2FzZS1sb2FkZXInKVxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsb2FkZXIucmVtb3ZlKClcbiAgICAgIH0sIDM1MCk7XG4gICAgfVxuICB9XG4gIHNob3dJbnB1dEVycm9yKGlucHV0LCB0ZXh0KSB7XG4gICAgY29uc3QgZXJyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxvYW4taW5wdXQtZXJyb3InKSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWlucHV0LWVycm9yJykgOiBjcmVhdGVFbGVtKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICdsb2FuLWlucHV0LWVycm9yJyxcbiAgICAgIGlubmVySFRNTDogdGV4dFxuICAgIH0pXG4gICAgaW5wdXQuY2xhc3NMaXN0LmFkZChfX0lOVkFMSUQpXG4gICAgdGhpcy5mb290ZXIucHJlcGVuZChlcnIpXG4gIH1cbiAgY2xlYXJFcnJvcnMoKSB7XG4gICAgY29uc3QgYWN0aXZlU2VjdGlvbiA9IHRoaXMuZ2V0QWN0aXZlU2VjdGlvblxuICAgIGNvbnN0IGlucHV0cyA9IFsuLi5hY3RpdmVTZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JyksIC4uLmFjdGl2ZVNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0JyldXG4gICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gaW5wdXQuY2xhc3NMaXN0LnJlbW92ZShfX0lOVkFMSUQpKVxuICAgIGNvbnN0IGVyciA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWlucHV0LWVycm9yJylcbiAgICBpZiAoZXJyKSBlcnIucmVtb3ZlKClcbiAgfVxuICBvYnNlcnZlQmFyKCkge1xuICAgIGNvbnN0IHByZXZTZWN0aW9ucyA9IHRoaXMuc2VjdGlvbnMuc2xpY2UoMCwgdGhpcy5jdXJyZW50U3RlcCkubGVuZ3RoXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSAocHJldlNlY3Rpb25zICsgMSkgLyB0aGlzLnN0ZXBzICogMTAwXG4gICAgdGhpcy5iYXJfcHJvZ3Jlc3Muc3R5bGUud2lkdGggPSBgJHtwcm9ncmVzc30lYFxuICB9XG4gIGNsZWFyQWxsRmllbGRzKCkge1xuICAgIGNvbnN0IGlucHV0cyA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dDpub3QoW3R5cGU9XCJjaGVja2JveFwiXSknKV1cbiAgICBjb25zdCBzZWxlY3RzID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCcpXVxuICAgIGNvbnN0IGNoZWNrYm94ZXMgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJyldXG4gICAgY29uc3QgZnVsbEFyciA9IFsuLi5pbnB1dHMsIC4uLnNlbGVjdHMsIC4uLmNoZWNrYm94ZXNdXG5cbiAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBpbnB1dC52YWx1ZSA9ICcnKVxuICAgIHNlbGVjdHMuZm9yRWFjaChzZWxlY3QgPT4gc2VsZWN0LnNlbGVjdGVkSW5kZXggPSAwKVxuICAgIGNoZWNrYm94ZXMuZm9yRWFjaCgoY2hlY2tib3gpID0+IHsgY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlIH0pXG4gICAgZnVsbEFyci5mb3JFYWNoKGVsZW0gPT4gZWxlbS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpKVxuICB9XG5cbiAgLyoqXG4gICAqIE1haW5cbiAgICovXG4gIHNhdmUoKSB7XG4gICAgJCgnI2xvYW5fZm9ybScpLnN1Ym1pdCgpO1xuICB9XG4gIGZpbmlzaE1lc3NhZ2UoKSB7XG4gICAgdGhpcy5sb2FkaW5nT24oMTAwMClcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZmxvdy5zdHlsZS5vcGFjaXR5ID0gMFxuICAgICAgbGV0IGN1cnJlbnRIZWlnaHQgPSB0aGlzLmhvbGRlci5vZmZzZXRIZWlnaHRcbiAgICAgIHRoaXMuaG9sZGVyLnN0eWxlLmhlaWdodCA9IGAke2N1cnJlbnRIZWlnaHR9cHhgXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5maW5pc2guc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgbGV0IHNjcm9sbEggPSB0aGlzLmZpbmlzaC5zY3JvbGxIZWlnaHRcbiAgICAgICAgdGhpcy5ob2xkZXIuc3R5bGUuaGVpZ2h0ID0gYCR7c2Nyb2xsSH1weGBcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5maW5pc2guc3R5bGUub3BhY2l0eSA9IDFcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgICAgICBjb25zdCBjb25mZXR0aSA9IG5ldyBQYWdlQ29uZmV0dGkoKVxuICAgICAgICAgIGNvbmZldHRpLnB1c2goZmFsc2UpXG4gICAgICAgIH0sIDEwKTtcbiAgICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMuZmxvdykgKyAxMClcbiAgICB9LCA4MDApO1xuICB9XG4gIHNsaWRlKHNlY3Rpb24pIHtcbiAgICBzZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbiAgICBjb25zdCBoZWlnaHQgPSBzZWN0aW9uLnNjcm9sbEhlaWdodFxuICAgIGNvbnN0IHB4VG9UcmFuc2Zvcm0gPSB0aGlzLnNlY3Rpb25zLnNsaWNlKDAsIHRoaXMuY3VycmVudFN0ZXApLnJlZHVjZSgoYWNjLCBlbCkgPT4gYWNjICsgZWwuc2Nyb2xsSGVpZ2h0LCAwKVxuICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgXG4gICAgdGhpcy5zY3JvbGxlci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgtJHtweFRvVHJhbnNmb3JtfXB4KWBcbiAgICB0aGlzLnNlY3Rpb25zLmZvckVhY2goZSA9PiBlLmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKSlcbiAgICBzZWN0aW9uLmNsYXNzTGlzdC5hZGQoSVNfQUNUSVZFKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zbGlkaW5nID0gZmFsc2VcbiAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLnNjcm9sbGVyKSk7XG4gIH1cbiAgZ28odG9TdGVwKSB7XG4gICAgaWYgKHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5jb250YWlucyhfX0xPQ0tFRCkpIHJldHVyblxuICAgIGNvbnN0IGlucHV0cyA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpLCAuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKV1cbiAgICBjb25zdCBzdGVwID0gdG9TdGVwIHx8IHRoaXMuY3VycmVudFN0ZXAgfHwgMFxuICAgIGNvbnN0IG5leHRTdGVwID0gc3RlcCArIDFcbiAgICBjb25zdCBuZXh0U2VjdGlvbiA9IHRoaXMuc2VjdGlvbnNbbmV4dFN0ZXBdXG5cbiAgICBpZiAoIXRoaXMuc2VjdGlvbnNbbmV4dFN0ZXAgKyAxXSkge1xuICAgICAgdGhpcy5ldnRHby5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgICAgYnRuLmlubmVySFRNTCA9ICdTdWJtaXQnXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChuZXh0U2VjdGlvbikge1xuICAgICAgdGhpcy5zbGlkaW5nID0gdHJ1ZVxuICAgICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gaW5wdXQuYmx1cigpKVxuICAgICAgdGhpcy5sb2FkaW5nT24oKVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSBuZXh0U3RlcFxuICAgICAgICB0aGlzLnNsaWRlKG5leHRTZWN0aW9uKVxuICAgICAgICB0aGlzLmxvYWRpbmdPZmYoKVxuICAgICAgICB0aGlzLm9ic2VydmVCYXIoKVxuICAgICAgfSwgNjAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zYXZlKClcbiAgICAgIHRoaXMuZmluaXNoTWVzc2FnZSgpXG4gICAgfVxuICB9XG4gIGJhY2sodG9TdGVwKSB7XG4gICAgaWYgKHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5jb250YWlucyhfX0xPQ0tFRCkpIHJldHVyblxuICAgIHRoaXMuY2xlYXJFcnJvcnMoKVxuICAgIGNvbnN0IHN0ZXAgPSB0b1N0ZXAgfHwgdGhpcy5jdXJyZW50U3RlcCB8fCAwXG4gICAgY29uc3QgcHJldlN0ZXAgPSBzdGVwIC0gMVxuICAgIGNvbnN0IHByZXZTZWN0aW9uID0gdGhpcy5zZWN0aW9uc1twcmV2U3RlcF1cbiAgICBpZiAocHJldlNlY3Rpb24pIHtcbiAgICAgIHRoaXMuZXZ0R28uZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICAgIGJ0bi5pbm5lckhUTUwgPSAnTmV4dCdcbiAgICAgIH0pXG4gICAgICB0aGlzLmN1cnJlbnRTdGVwID0gcHJldlN0ZXBcbiAgICAgIHRoaXMuc2xpZGUocHJldlNlY3Rpb24pXG4gICAgfVxuICB9XG4gIHZhbGlkYXRlKHNlY3Rpb24pIHtcbiAgICBjb25zdCByZXF1aXJlZFRleHRJbnB1dHMgPSBbLi4uc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwidGV4dFwiXVtyZXF1aXJlZF06bm90KC4tLWRpc2FibGVkJyksIC4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cImVtYWlsXCJdW3JlcXVpcmVkXScpXVxuICAgIGNvbnN0IGVtcHR5SW5wdXRzID0gcmVxdWlyZWRUZXh0SW5wdXRzLmZpbHRlcihpbnB1dCA9PiAhaW5wdXQudmFsdWUpXG4gICAgY29uc3QgbnVtYmVySW5wdXRzID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtkYXRhLXZhbGlkYXRlPVwibnVtYmVyXCJdJylcbiAgICBjb25zdCBzZWxlY3RJbnB1dHMgPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdFtyZXF1aXJlZF0nKVxuICAgIGNvbnN0IGVtYWlsSW5wdXRzID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtkYXRhLXZhbGlkYXRlPVwiZW1haWxcIl0nKVxuICAgIGNvbnN0IHppcElucHV0cyA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbZGF0YS12YWxpZGF0ZT1cInppcF9jb2RlXCJdJylcbiAgICBjb25zdCBzZWN0aW9uSUQgPSBzZWN0aW9uLmRhdGFzZXQubG9hblNlY3Rpb25cblxuICAgIGlmIChyZXF1aXJlZFRleHRJbnB1dHMuc29tZShpbnB1dCA9PiBpbnB1dC5jbGFzc0xpc3QuY29udGFpbnMoX19JTlZBTElEKSkpIHJldHVybiBmYWxzZVxuICAgIGlmIChudW1iZXJJbnB1dHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG51bWJlcklucHV0c1swXS52YWx1ZVxuICAgICAgY29uc3QgcmVnZXggPSAvXlxcK1xcZHsxfVxcc1xcKFxcZHszfVxcKVxcc1xcZHszfVxcLVxcZHs0fSQvXG4gICAgICBpZiAoIXJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc2hvd0lucHV0RXJyb3IobnVtYmVySW5wdXRzWzBdLCAnUGxlYXNlIGVudGVyIGEgdmFsaWQgcGhvbmUgbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbWFpbElucHV0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZW1haWxJbnB1dHNbMF0udmFsdWVcbiAgICAgIGNvbnN0IHJlZ2V4ID0gL15bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05LV0rKD86XFwuW2EtekEtWjAtOS1dKykqJC9cbiAgICAgIGlmICghcmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5zaG93SW5wdXRFcnJvcihlbWFpbElucHV0c1swXSwgJ1BsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh6aXBJbnB1dHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHppcElucHV0c1swXS52YWx1ZVxuICAgICAgY29uc3QgcmVnZXggPSAvXlxcZHs1fSQvXG4gICAgICBpZiAoIXJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc2hvd0lucHV0RXJyb3IoemlwSW5wdXRzWzBdLCAnUGxlYXNlIGVudGVyIGEgdmFsaWQgemlwIGNvZGUnKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVtcHR5SW5wdXRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5zaG93SW5wdXRFcnJvcihlbXB0eUlucHV0c1swXSwgJ1RoaXMgZmllbGQgaXMgcmVxdWlyZWQnKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChzZWxlY3RJbnB1dHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdCBvZiBzZWxlY3RJbnB1dHMpIHtcbiAgICAgICAgaWYgKCFzZWxlY3QudmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnNob3dJbnB1dEVycm9yKHNlbGVjdCwgJ1BsZWFzZSBzZWxlY3QgYW4gb3B0aW9uJylcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGFkanVzdEFjdGl2ZVNlY3Rpb25IZWlnaHQoKSB7XG4gICAgY29uc3QgYWN0aXZlU2VjdGlvbiA9IHRoaXMuZ2V0QWN0aXZlU2VjdGlvblxuICAgIGlmIChhY3RpdmVTZWN0aW9uKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBhY3RpdmVTZWN0aW9uLnNjcm9sbEhlaWdodFxuICAgICAgdGhpcy5jb250ZW50LnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGBcbiAgICB9XG4gIH1cbiAgdG9nZ2xlKCkge1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JylcbiAgICBjb25zdCBoZWFkZXJOYXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaGVhZGVyX19zdWItbmF2JylcbiAgICBjb25zdCB3ZWxjb21lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnN1YnBhZ2VfX3dlbGNvbWUnKVxuICAgIGNvbnN0IGZvb3Rlck1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9vdGVyX193cmFwcGVyID4gLndyYXBwZXInKVxuICAgIGNvbnN0IGxvYW5XZWxjb21lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxvYW4td2VsY29tZScpXG4gICAgY29uc3QgaGVhZGluZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWNhc2VfX2hlYWRpbmcnKVxuICAgIGNvbnN0IGJhY2tHcm91cCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWNhc2VfX2JhY2stZ3JvdXAnKVxuICAgIGNvbnN0IENBU0VfQ0xBU1MgPSAnbG9hbl9jYXNlJ1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW2hlYWRlck5hdiwgd2VsY29tZSwgZm9vdGVyTWFpbiwgbG9hbldlbGNvbWVdXG5cbiAgICBjb25zdCBoaWRlRWxlbWVudCA9IChlbCkgPT4ge1xuICAgICAgY29uc3QgY3VySGVpZ2h0ID0gZWwuc2Nyb2xsSGVpZ2h0XG4gICAgICBlbC5zdHlsZS5oZWlnaHQgPSBgJHtjdXJIZWlnaHR9cHhgXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnMHB4J1xuICAgICAgfSwgMSk7XG4gICAgfVxuICAgIGNvbnN0IHNob3dFbGVtZW50ID0gKGVsKSA9PiB7XG4gICAgICBjb25zdCBjdXJIZWlnaHQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0JylcbiAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IGVsLnNjcm9sbEhlaWdodFxuICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gYCR7Y3VySGVpZ2h0fWBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlbC5zdHlsZS5vdmVyZmxvdyA9ICd2aXNpYmxlJ1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBgJHtzY3JvbGxIZWlnaHR9cHhgXG4gICAgICB9LCAxKVxuICAgIH1cblxuICAgIGNvbnN0IGhpZGVMb2FuID0gKCkgPT4ge1xuICAgICAgYm9keS5jbGFzc0xpc3QucmVtb3ZlKENBU0VfQ0xBU1MpXG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHNob3dFbGVtZW50KGVsZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2Nyb2xsZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgdGhpcy5jb250ZW50LnN0eWxlLmhlaWdodCA9IGAwcHhgXG5cbiAgICAgIGlmIChiYWNrR3JvdXApIHtcbiAgICAgICAgYmFja0dyb3VwLnN0eWxlLmhlaWdodCA9IGAwcHhgXG4gICAgICB9XG5cbiAgICAgIGlmIChoZWFkaW5nKSB7XG4gICAgICAgIGhlYWRpbmcuaW5uZXJIVE1MID0gJ1dlbGNvbWUgVG8gdGhlIEljZWJveCBNYXggQXBwcm92YWwgRmluYW5jaW5nIEZvcm0nXG4gICAgICAgIGhlYWRpbmcuY2xhc3NMaXN0LnJlbW92ZSgnLS1iaWcnKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNsZWFyRXJyb3JzKClcbiAgICAgIHRoaXMuYmFjaygxKVxuICAgICAgdGhpcy5jbGVhckFsbEZpZWxkcygpXG4gICAgfVxuICAgIGNvbnN0IHNob3dMb2FuID0gKCkgPT4ge1xuICAgICAgYm9keS5jbGFzc0xpc3QuYWRkKCdsb2FuX2Nhc2UnKVxuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChlbGVtZW50KSBoaWRlRWxlbWVudChlbGVtZW50KVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbGVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLnNlY3Rpb25zWzBdLnNjcm9sbEhlaWdodH1weGBcblxuICAgICAgaWYgKGJhY2tHcm91cCkge1xuICAgICAgICBiYWNrR3JvdXAuc3R5bGUuaGVpZ2h0ID0gYCR7YmFja0dyb3VwLnNjcm9sbEhlaWdodH1weGBcbiAgICAgIH1cblxuICAgICAgaWYgKGhlYWRpbmcpIHtcbiAgICAgICAgaGVhZGluZy5pbm5lckhUTUwgPSAnRmluYW5jaW5nIEFwcGxpY2F0aW9uJ1xuICAgICAgICBoZWFkaW5nLmNsYXNzTGlzdC5hZGQoJy0tYmlnJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm9keS5jbGFzc0xpc3QuY29udGFpbnMoQ0FTRV9DTEFTUykpIHtcbiAgICAgIGNvbnN0IGFza01vZGFsID0gbmV3IEFza01vZGFsKHtcbiAgICAgICAgaGVhZGluZzogJ0FyZSBZb3UgU3VyZSBZb3UgV2FudCBUbyBFeGl0IEZpbmFuY2luZyBBcHA/JyxcbiAgICAgICAgc3ViaGVhZGluZzogJ1lvdSB3aWxsIGxvc2UgYWxsIHRoZSBwcm9ncmVzcy4gS2VlcCBmaWxsaW5nIG91dCB0aGUgZm9ybSBhbmQgZ2V0IGFwcHJvdmVkIGFzIHNvb24gYXMgcG9zc2libGUhJyxcbiAgICAgICAgZXhpdFRleHQ6ICdFeGl0JyxcbiAgICAgICAga2VlcFRleHQ6ICdLZWVwIEZpbGxpbmcnLFxuICAgICAgICBleGl0Q2FsbGJhY2s6IGhpZGVMb2FuLFxuICAgICAgfSlcbiAgICAgIGFza01vZGFsLnNob3coKVxuICAgIH0gZWxzZSB7XG4gICAgICBzaG93TG9hbigpXG4gICAgfVxuICB9XG4gIHRhYlByZXNzKCkge1xuICAgIGlmICghdGhpcy5zbGlkaW5nKSB7XG4gICAgICBjb25zdCBhY3RpdmVJbnB1dCA9IHRoaXMuZ2V0QWN0aXZlSW5wdXRcbiAgICAgIGlmICghYWN0aXZlSW5wdXQpIHtcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuZ2V0QWN0aXZlU2VjdGlvblxuICAgICAgICBjb25zdCBpbnB1dEFycmF5ID0gWy4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6bm90KC4tLWRpc2FibGVkKSwgc2VsZWN0Om5vdCguLS1kaXNhYmxlZCknKV1cbiAgICAgICAgaWYgKGlucHV0QXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGlucHV0VG9Gb2N1c1xuICAgICAgICAgIGNvbnN0IGludmFsaWRJbnB1dHMgPSBpbnB1dEFycmF5LmZpbHRlcihpbnB1dCA9PiBpbnB1dC5jbGFzc0xpc3QuY29udGFpbnMoJy0taW52YWxpZCcpKVxuICAgICAgICAgIGlmIChpbnZhbGlkSW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaW5wdXRUb0ZvY3VzID0gaW52YWxpZElucHV0c1swXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbXB0eUlucHV0cyA9IGlucHV0QXJyYXkuZmlsdGVyKGlucHV0ID0+ICFpbnB1dC52YWx1ZSAmJiBpbnB1dC52YWx1ZSAhPT0gMClcbiAgICAgICAgICAgIGlmIChlbXB0eUlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaW5wdXRUb0ZvY3VzID0gZW1wdHlJbnB1dHNbMF1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0VG9Gb2N1cyA9IGlucHV0QXJyYXlbMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXRUb0ZvY3VzLmZvY3VzKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWN0aXZlSW5wdXRXcmFwID0gYWN0aXZlSW5wdXQucGFyZW50Tm9kZS5jbG9zZXN0KCcubG9hbi1pbnB1dC13cmFwJylcbiAgICAgICAgY29uc3QgbmV4dElucHV0V3JhcCA9IGFjdGl2ZUlucHV0V3JhcC5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgICAgaWYgKG5leHRJbnB1dFdyYXApIHtcbiAgICAgICAgICBjb25zdCBuZXh0SW5wdXQgPSBuZXh0SW5wdXRXcmFwLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LCBzZWxlY3QnKVxuICAgICAgICAgIGlmIChuZXh0SW5wdXQpIHtcbiAgICAgICAgICAgIG5leHRJbnB1dC5mb2N1cygpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGZpcnN0SW5wdXRXcmFwID0gdGhpcy5nZXRBY3RpdmVTZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWlucHV0LXdyYXAnKVxuICAgICAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBmaXJzdElucHV0V3JhcC5xdWVyeVNlbGVjdG9yKCdpbnB1dCwgc2VsZWN0JylcbiAgICAgICAgICBpZiAoZmlyc3RJbnB1dCkge1xuICAgICAgICAgICAgZmlyc3RJbnB1dC5mb2N1cygpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJpbmQgRXZlbnRzXG4gICAqL1xuICBiaW5kU3RlcEV2dCgpIHtcbiAgICB0aGlzLmV2dEdvLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLmdldEFjdGl2ZVNlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGUoc2VjdGlvbikpIHRoaXMuZ28oKVxuICAgICAgfSlcbiAgICB9KVxuICAgIHRoaXMuZXZ0QmFjay5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgdGhpcy5iYWNrKClcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLmV2dFN1Ym1pdC5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0aGlzLmV2dEdvWzBdLmNsaWNrKClcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLmV2dFRvZ2dsZS5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIHRoaXMudG9nZ2xlKClcbiAgICAgIH0pXG4gICAgfSlcblxuICB9XG4gIGJpbmRJbnB1dEV2ZW50cygpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKV1cbiAgICBjb25zdCBzZWxlY3RzID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCcpXVxuICAgIGNvbnN0IG5vV2Vic2l0ZUNoZWNrYm94ID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignI2xvYW5fZW1wbG95ZXJfd2Vic2l0ZScpXG4gICAgY29uc3QgaW5wdXRXZWJzaXRlRW1wbG95ZXIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcjbG9hbl9lbXBsb3llcl93ZWJzaXRlJylcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgY29uc3QgaXNUYWIgPSBlLmtleSA9PT0gJ1RhYidcbiAgICAgIGlmIChpc1RhYikge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ2xvYW5fY2FzZScpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgdGhpcy50YWJQcmVzcygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckVycm9ycygpXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGlucHV0LnBhcmVudE5vZGUuY2xvc2VzdCgnLmxvYW4taW5wdXQtd3JhcCcpXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQuY2xhc3NMaXN0LmFkZCgnLS1mb2N1c2VkJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGlucHV0LnBhcmVudE5vZGUuY2xvc2VzdCgnLmxvYW4taW5wdXQtd3JhcCcpXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQuY2xhc3NMaXN0LnJlbW92ZSgnLS1mb2N1c2VkJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyRXJyb3JzKClcbiAgICAgICAgY29uc3QgaXNFbnRlciA9IGUua2V5ID09PSAnRW50ZXInXG4gICAgICAgIGNvbnN0IGlzVGFiID0gZS5rZXkgPT09ICdUYWInXG4gICAgICAgIGlmIChpc0VudGVyKSB7XG4gICAgICAgICAgdGhpcy5ldnRHb1swXS5jbGljaygpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICBzZWxlY3RzLmZvckVhY2goKHNlbGVjdCkgPT4ge1xuICAgICAgc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckVycm9ycygpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbiAgYmluZFNTTklucHV0KCkge1xuICAgIGNvbnN0IGlucHV0cyA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W2RhdGEtZm9ybWF0PVwic3NuXCJdJylcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9ICcnXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGFyID0gdmFsdWUuY2hhckF0KGkpXG4gICAgICAgICAgaWYgKGNoYXIubWF0Y2goL15bMC05XSQvKSAmJiBuZXdWYWx1ZS5sZW5ndGggPCA5KSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSArPSBjaGFyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGUudGFyZ2V0LnZhbHVlID0gbmV3VmFsdWVcbiAgICAgIH0pXG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlLnRhcmdldC52YWx1ZVxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8oW14wLTldKS9nLCAnJylcbiAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnNsaWNlKDAsIDMpICsgJ+KAlCcgKyBuZXdWYWx1ZS5zbGljZSgzLCA1KSArICfigJQnICsgbmV3VmFsdWUuc2xpY2UoNSlcbiAgICAgICAgICBlLnRhcmdldC52YWx1ZSA9IG5ld1ZhbHVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIChlKSA9PiB7XG4gICAgICAgIGUudGFyZ2V0LnZhbHVlID0gZS50YXJnZXQudmFsdWUucmVwbGFjZSgvKFteMC05XSkvZywgJycpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBiaW5kTnVtYmVySW5wdXQoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbZGF0YS12YWxpZGF0ZT1cIm51bWJlclwiXScpXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgIGxldCBrZXlDb2RlO1xuICAgICAgZnVuY3Rpb24gbWFzayhldmVudCkge1xuICAgICAgICBldmVudC5rZXlDb2RlICYmIChrZXlDb2RlID0gZXZlbnQua2V5Q29kZSk7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBpZiAocG9zIDwgMykgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICBsZXQgbWF0cml4ID0gXCIrMSAoX19fKSBfX18tX19fX1wiLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGRlZiA9IG1hdHJpeC5yZXBsYWNlKC9cXEQvZywgXCJcIiksXG4gICAgICAgICAgdmFsID0gdGhpcy52YWx1ZS5yZXBsYWNlKC9cXEQvZywgXCJcIiksXG4gICAgICAgICAgbmV3VmFsdWUgPSBtYXRyaXgucmVwbGFjZSgvW19cXGRdL2csIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gaSA8IHZhbC5sZW5ndGggPyB2YWwuY2hhckF0KGkrKykgfHwgZGVmLmNoYXJBdChpKSA6IGE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGkgPSBuZXdWYWx1ZS5pbmRleE9mKFwiX1wiKTtcbiAgICAgICAgaWYgKGkgIT0gLTEpIHtcbiAgICAgICAgICBpIDwgNSAmJiAoaSA9IDMpO1xuICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlZyA9IG1hdHJpeC5zdWJzdHIoMCwgdGhpcy52YWx1ZS5sZW5ndGgpLnJlcGxhY2UoL18rL2csXG4gICAgICAgICAgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxkezEsXCIgKyBhLmxlbmd0aCArIFwifVwiO1xuICAgICAgICAgIH0pLnJlcGxhY2UoL1srKCldL2csIFwiXFxcXCQmXCIpO1xuICAgICAgICByZWcgPSBuZXcgUmVnRXhwKFwiXlwiICsgcmVnICsgXCIkXCIpO1xuICAgICAgICBpZiAoIXJlZy50ZXN0KHRoaXMudmFsdWUpIHx8IHRoaXMudmFsdWUubGVuZ3RoIDwgNSB8fCBrZXlDb2RlID4gNDcgJiYga2V5Q29kZSA8IDU4KSB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGlmIChldmVudC50eXBlID09IFwiYmx1clwiICYmIHRoaXMudmFsdWUubGVuZ3RoIDwgNSkgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBtYXNrLCBmYWxzZSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgbWFzaywgZmFsc2UpO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgbWFzaywgZmFsc2UpO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgbWFzaywgZmFsc2UpO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICBpZiAoaW5wdXQudmFsdWUubGVuZ3RoIDwgNCkge1xuICAgICAgICAgIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKDQsIDQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoaW5wdXQudmFsdWUubGVuZ3RoLCBpbnB1dC52YWx1ZS5sZW5ndGgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGJpbmRJRFVwbG9hZCgpIHtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNsb2FuX2lkJylcbiAgICBjb25zdCBib3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1sb2FuPVwiZmlsZXNfdXBsb2FkXCJdJylcbiAgICBjb25zdCBob2xkZXIgPSB0aGlzLmZpbGVzSG9sZGVyXG4gICAgLy8gaWYgKCFpbnB1dCB8fCAhYm94IHx8ICFob2xkZXIpIHRocm93IG5ldyBFcnJvcignSlMgOiBCaW5kIElEIFVwbG9hZCA6IElucHV0IG9yIEJveCBvciBIb2xkZXIgbm90IGZvdW5kJylcblxuICAgIGlmIChpbnB1dCAmJiBib3ggJiYgaG9sZGVyKSB7XG4gICAgICBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoZmlsZXMpIHtcbiAgICAgICAgaWYgKCFmaWxlcykgdGhyb3cgbmV3IEVycm9yKCdObyBmaWxlcyBzZWxlY3RlZCcpXG4gICAgICAgIGZpbGVzID0gWy4uLmZpbGVzXVxuICAgICAgICBpZiAoIWZpbGVzLmxlbmd0aCkgcmV0dXJuXG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgIGlmICghZmlsZS50eXBlLm1hdGNoKCdpbWFnZS4qJykpIGNvbnRpbnVlXG4gICAgICAgICAgY29uc3QgaW1hZ2VzID0gaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZycpXG4gICAgICAgICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgICAgICAgIGltYWdlLnJlbW92ZSgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICAgICAgICBhcHBlbmRJbWFnZShlLnRhcmdldC5yZXN1bHQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXBwZW5kSW1hZ2UoaW1nVVJMKSB7XG4gICAgICAgIGNvbnN0IGltZyA9IGNyZWF0ZUVsZW0oJ2ltZycsIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiBgdXJsKCR7aW1nVVJMfSlgXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICAgaG9sZGVyLmFwcGVuZChpbWcpXG4gICAgICB9XG5cbiAgICAgIGJveC5vbmNsaWNrID0gKCkgPT4geyBpbnB1dC5jbGljaygpIH1cbiAgICAgIGlucHV0Lm9uY2hhbmdlID0gKGUpID0+IHtcbiAgICAgICAgcHJvY2Vzc0ZpbGVzKGUudGFyZ2V0LmZpbGVzKVxuICAgICAgICAvLyBpbnB1dC52YWx1ZSA9ICcnXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRqdXN0QWN0aXZlU2VjdGlvbkhlaWdodCgpXG4gICAgICAgIH0sIDEwKTtcbiAgICAgIH1cbiAgICAgIGJveC5vbmRyYWdvdmVyID0gKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGJveC5jbGFzc0xpc3QuYWRkKElTX0FDVElWRSlcbiAgICAgIH1cbiAgICAgIGJveC5vbmRyYWdsZWF2ZSA9IChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBib3guY2xhc3NMaXN0LnJlbW92ZShJU19BQ1RJVkUpXG4gICAgICB9XG4gICAgICBib3gub25kcm9wID0gKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGJveC5jbGFzc0xpc3QucmVtb3ZlKElTX0FDVElWRSlcbiAgICAgICAgcHJvY2Vzc0ZpbGVzKGUuZGF0YVRyYW5zZmVyLmZpbGVzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBiaW5kRHVhbFNlbGVjdCgpIHtcbiAgICBjb25zdCBkdWFsQXJyID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbG9hbi1ldnQ9XCJkdWFsX3NlbGVjdFwiXScpXG4gICAgZm9yIChjb25zdCBkdWFsIG9mIGR1YWxBcnIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZHVhbC5xdWVyeVNlbGVjdG9yKCdpbnB1dDpub3QoW3R5cGU9XCJjaGVja2JveFwiXSknKVxuICAgICAgY29uc3QgY2hlY2tib3ggPSBkdWFsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpXG4gICAgICBpZiAoaW5wdXQgJiYgY2hlY2tib3gpIHtcbiAgICAgICAgY2hlY2tib3gub25jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgbGV0IGlzQ2hlY2tlZCA9IGNoZWNrYm94LmNoZWNrZWRcbiAgICAgICAgICBpZiAoaXNDaGVja2VkKSB7XG4gICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCctLWRpc2FibGVkJylcbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKVxuICAgICAgICAgICAgaWYgKGlucHV0LnR5cGUgIT09ICdyYW5nZScpIHtcbiAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoJy0tZGlzYWJsZWQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJhbmdlT3V0cHV0QXJyID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jdXN0b20tcmFuZ2VfX291dHB1dCcpXVxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgcmFuZ2VPdXRwdXRBcnIpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGlucHV0LmNsb3Nlc3QoJ1tkYXRhLWxvYW4tZXZ0PVwiZHVhbF9zZWxlY3RcIl0nKVxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBjb25zdCByYW5nZUlucHV0ID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJyYW5nZVwiXScpXG4gICAgICAgIGlmIChyYW5nZUlucHV0KSB7XG4gICAgICAgICAgY29uc3QgbWF4VmFsdWUgPSByYW5nZUlucHV0Lm1heFxuICAgICAgICAgIGNvbnN0IG1pblZhbHVlID0gcmFuZ2VJbnB1dC5taW5cblxuICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gZS50YXJnZXQudmFsdWUucmVwbGFjZSgvW14wLTldL2csICcnKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGUpID0+IHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4oZS50YXJnZXQudmFsdWUsIG1heFZhbHVlKSwgbWluVmFsdWUpXG4gICAgICAgICAgICByYW5nZUlucHV0LnZhbHVlID0gZS50YXJnZXQudmFsdWVcbiAgICAgICAgICAgIHJhbmdlSW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JykpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBiaW5kRm9ybWF0dGluZygpIHtcbiAgICBjb25zdCBjdXJyZW5jeUFyciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZvcm1hdD1cImN1cnJlbmN5XCJdJylcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGN1cnJlbmN5QXJyKSB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBpbnB1dC52YWx1ZVxuICAgICAgICBpZiAodmFsLmxlbmd0aCkge1xuICAgICAgICAgIGlucHV0LnZhbHVlID0gZm9ybWF0QXNDdXJyZW5jeSh2YWwpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxcbiAgICovXG4gIHNldEluaXRpYWxWYXIoKSB7XG4gICAgdGhpcy5zdGVwcyA9IHRoaXMuc2VjdGlvbnMubGVuZ3RoXG4gICAgaWYgKCF0aGlzLnN0ZXBzKSB0aHJvdyBuZXcgRXJyb3IoJ05vIExvYW4gU2VjdGlvbnMgRm91bmQnKVxuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAwXG4gICAgdGhpcy5zdGVwc0xlZnQgPSB0aGlzLnN0ZXBzXG4gICAgdGhpcy5lbmRSZWFjaGVkID0gZmFsc2VcbiAgICB0aGlzLmF0VGhlU3RhcnQgPSB0cnVlXG4gIH1cbiAgc2V0SW5pdGlhbExheW91dCgpIHtcbiAgICBjb25zdCBmaXJzdFNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zWzBdXG4gICAgY29uc3QgaGVpZ2h0ID0gZmlyc3RTZWN0aW9uLnNjcm9sbEhlaWdodFxuICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgXG4gICAgdGhpcy5jb250ZW50LnN0eWxlLnRyYW5zaXRpb24gPSBgYWxsICR7dGhpcy5zZXR0aW5ncy5zY3JvbGxTcGVlZH1tcyAke3RoaXMuc2V0dGluZ3MuZWFzaW5nfWBcbiAgICB0aGlzLnNjcm9sbGVyLnN0eWxlLnRyYW5zaXRpb24gPSBgYWxsICR7dGhpcy5zZXR0aW5ncy5zY3JvbGxTcGVlZH1tcyAke3RoaXMuc2V0dGluZ3MuZWFzaW5nfWBcbiAgICAvLyB0aGlzLnNlY3Rpb25zLmZvckVhY2goc2VjdGlvbiA9PiBzZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSAnZmxleCcpXG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnNldEluaXRpYWxMYXlvdXQoKVxuICAgIHRoaXMuc2V0SW5pdGlhbFZhcigpXG4gICAgdGhpcy5iaW5kU3RlcEV2dCgpXG4gICAgdGhpcy5iaW5kSW5wdXRFdmVudHMoKVxuICAgIHRoaXMuYmluZE51bWJlcklucHV0KClcbiAgICB0aGlzLmJpbmRTU05JbnB1dCgpXG4gICAgdGhpcy5iaW5kSURVcGxvYWQoKVxuICAgIHRoaXMuYmluZER1YWxTZWxlY3QoKVxuICAgIHRoaXMuYmluZEZvcm1hdHRpbmcoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTG9hbkFwcCIsImNvbnN0IGxvY2F0aW9uUGFnZSA9IG5ldyBPYmplY3Qoe1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLmF0dGFjaEV2ZW50cykuZm9yRWFjaCgoZm4pID0+IHtcbiAgICAgIGlmIChmbiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nKSBmbigpO1xuICAgIH0pXG4gIH0sXG4gIGF0dGFjaEV2ZW50czoge1xuICAgIHRvZ2dsZVN0b3Jlc1Zpc2liaWxpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBoZWFkQXJyID0gWy4uLiQoJy5zdG9yZS1yb3dfX2hlYWQnKV1cbiAgICAgICQuZWFjaChoZWFkQXJyLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAkKGhlYWRBcnJbaV0pLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsZXQgcm93cyA9ICQoJy5zdG9yZS1yb3cnKSxcbiAgICAgICAgICAgIHRoaXNSb3cgPSAkKHRoaXMpLmNsb3Nlc3Qocm93cylcbiAgICAgICAgICBpZiAoZWxlbURpc3BsYXllZCh0aGlzUm93LmZpbmQoJy5zdG9yZS1yb3dfX2JvZHknKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3dzLmZpbmQoJy5zdG9yZS1yb3dfX2JvZHknKS5zaG93KClcbiAgICAgICAgICAgIHJvd3Mubm90KHRoaXNSb3cpLmZpbmQoJy5zdG9yZS1yb3dfX2JvZHknKS5oaWRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBsb2NhdGlvblBhZ2UiLCJjbGFzcyBMb29zZURpYW1vbmRzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tYWluID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxvb3NlX2RpYW1vbmRzJylcbiAgICB0aGlzLnJlc3VsdHNDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubG9vc2VfX3Jlc3VsdHMnKVxuICAgIHRoaXMudmlld0J0bkFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubG9vc2VfX3ZpZXctYnRuJyldXG4gICAgdGhpcy5sb29zZVNlbGVjdEFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubG9vc2Utc2VsZWN0JyldXG4gICAgdGhpcy5kbUJ0bkFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG0tZmlsdGVyLWJ0bicpXVxuICAgIHRoaXMuc29ydE1vZGFsQWN0aXZlID0gZmFsc2VcbiAgICBpZiAodGhpcy5tYWluKSB7XG4gICAgICB0aGlzLmluaXQoKVxuICAgIH1cbiAgfVxuXG4gIC8vIE1ldGhvZHNcbiAgbGlzdFZpZXcoKSB7XG4gICAgdGhpcy5tYWluLmNsYXNzTGlzdC5hZGQoJy0tbGlzdCcpXG4gIH1cbiAgZ3JpZFZpZXcoKSB7XG4gICAgdGhpcy5tYWluLmNsYXNzTGlzdC5yZW1vdmUoJy0tbGlzdCcpXG4gIH1cbiAgb2JzZXJ2ZUZpbHRlcnMoKSB7XG4gICAgZm9yIChjb25zdCBzZWxlY3Qgb2YgdGhpcy5sb29zZVNlbGVjdEFycikge1xuICAgICAgY29uc3QgYnRuQXJyID0gWy4uLnNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCcubG9vc2UtZmlsdGVyLWJ0bicpXVxuICAgICAgY29uc3QgaW5wdXRBcnIgPSBbLi4uc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJ0ZXh0XCJdJyldXG5cbiAgICAgIGNvbnN0IHNvbWVJc0NoZWNrZWQgPSBidG5BcnIuc29tZShlbCA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMoX19BQ1RJVkUpKVxuICAgICAgY29uc3Qgc29tZUlzVmFsdWUgPSBpbnB1dEFyci5zb21lKGVsID0+IGVsLnZhbHVlLmxlbmd0aCA+IDApXG5cbiAgICAgIGlmIChzb21lSXNDaGVja2VkIHx8IHNvbWVJc1ZhbHVlKSB7XG4gICAgICAgIHNlbGVjdC5jbGFzc0xpc3QuYWRkKF9fU0VMRUNURUQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3QuY2xhc3NMaXN0LnJlbW92ZShfX1NFTEVDVEVEKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXNldEZpbHRlcnMoKSB7XG4gICAgZm9yIChjb25zdCBzZWxlY3Qgb2YgdGhpcy5sb29zZVNlbGVjdEFycikge1xuICAgICAgY29uc3QgYnRuQXJyID0gWy4uLnNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCcubG9vc2UtZmlsdGVyLWJ0bicpXVxuICAgICAgY29uc3QgaW5wdXRBcnIgPSBbLi4uc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJ0ZXh0XCJdJyldXG5cbiAgICAgIGJ0bkFyci5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpKVxuICAgICAgaW5wdXRBcnIuZm9yRWFjaChlbCA9PiBlbC52YWx1ZSA9ICcnKVxuXG4gICAgICBzZWxlY3QuY2xhc3NMaXN0LnJlbW92ZShfX1NFTEVDVEVEKVxuICAgIH1cbiAgfVxuICBvcGVuU29ydE1vZGFsKCkge1xuICAgIGNvbnN0IHNvcnRNb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zb3J0LW1vZGFsJylcbiAgICBjb25zdCBjbG9zZUNhbGxiYWNrID0gKCkgPT4geyB0aGlzLmNsb3NlU29ydE1vZGFsKHRydWUpIH1cbiAgICBpZiAoc29ydE1vZGFsKSB7XG4gICAgICB3aW5kb3cubG9vc2VTb3J0QmFja2Ryb3AgPSBuZXcgQmFja2Ryb3Aoe1xuICAgICAgICBoYWxmOiB0cnVlLFxuICAgICAgICBjYWxsYmFjazogY2xvc2VDYWxsYmFja1xuICAgICAgfSlcbiAgICAgIGxvY2tTY3JvbGwoKVxuICAgICAgc29ydE1vZGFsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc29ydE1vZGFsLmNsYXNzTGlzdC5hZGQoX19BQ1RJVkUpXG4gICAgICB9LCA1KTtcbiAgICB9XG4gIH1cbiAgY2xvc2VTb3J0TW9kYWwoY29uZCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc29ydE1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNvcnQtbW9kYWwnKVxuICAgIGlmIChzb3J0TW9kYWwpIHtcbiAgICAgIHVubG9ja1Njcm9sbCgpXG4gICAgICBzb3J0TW9kYWwuY2xhc3NMaXN0LnJlbW92ZShfX0FDVElWRSlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzb3J0TW9kYWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUoc29ydE1vZGFsKSk7XG4gICAgICBpZiAoIWNvbmQpIHtcbiAgICAgICAgY29uc3QgYmFja2Ryb3AgPSB3aW5kb3cubG9vc2VTb3J0QmFja2Ryb3BcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgYmFja2Ryb3AuaGlkZSgpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm93QXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zb3J0LW1vZGFsLXJvdycpXVxuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93QXJyKSB7XG4gICAgICAgIHJvdy5xdWVyeVNlbGVjdG9yKCcuc29ydC1tb2RhbC1yb3dfX2JvZHknKS5zdHlsZS5oZWlnaHQgPSAwXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFwcGx5RmlsdGVycygpIHtcbiAgICB0aGlzLmNsb3NlU29ydE1vZGFsKClcbiAgfVxuICBoaWRlQWRtaW4odGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgY29uc3QgaXRlbSA9IHRhcmdldC5jbG9zZXN0KCcuZG0taXRlbScpXG4gICAgICBjb25zdCBhZG1pbkJhciA9IGl0ZW0ucXVlcnlTZWxlY3RvcignLmRtLWl0ZW1fX2FkbWluJylcbiAgICAgIGlmIChhZG1pbkJhcikge1xuICAgICAgICBhZG1pbkJhci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQmluZCBFdmVudHNcbiAgYmluZExvb3NlU2VsZWN0cygpIHtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdCBvZiB0aGlzLmxvb3NlU2VsZWN0QXJyKSB7XG4gICAgICBjb25zdCBidG4gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignLmxvb3NlLXNlbGVjdF9fYnRuJylcbiAgICAgIGNvbnN0IGRyb3AgPSBzZWxlY3QucXVlcnlTZWxlY3RvcignLmxvb3NlLXNlbGVjdF9fZHJvcCcpXG4gICAgICBpZiAoYnRuICYmIGRyb3ApIHtcbiAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgIGlmIChzZWxlY3QuY2xhc3NMaXN0LmNvbnRhaW5zKF9fQUNUSVZFKSkge1xuICAgICAgICAgICAgc2VsZWN0LmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9vc2VTZWxlY3RBcnIuZm9yRWFjaChlbCA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKSlcbiAgICAgICAgICAgIHNlbGVjdC5jbGFzc0xpc3QuYWRkKF9fQUNUSVZFKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9vc2VTZWxlY3RBcnIuc29tZShlbCA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMoX19BQ1RJVkUpKSkge1xuICAgICAgICB0aGlzLmxvb3NlU2VsZWN0QXJyLmZvckVhY2goZWwgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShfX0FDVElWRSkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0XG4gICAgICBpZiAoIXRhcmdldC5jbG9zZXN0KCcubG9vc2Utc2VsZWN0JykpIHtcbiAgICAgICAgdGhpcy5sb29zZVNlbGVjdEFyci5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgYmluZEZpbHRlckJ0bkdyb3VwKCkge1xuICAgIGNvbnN0IGdyb3VwQXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZpbHRlci1ncm91cF0nKV1cbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGdyb3VwQXJyKSB7XG4gICAgICBjb25zdCBidG5BcnIgPSBbLi4uZ3JvdXAucXVlcnlTZWxlY3RvckFsbCgnLmxvb3NlLWZpbHRlci1idG4nKV1cbiAgICAgIGZvciAoY29uc3QgYnRuIG9mIGJ0bkFycikge1xuICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgYnRuLmNsYXNzTGlzdC50b2dnbGUoX19BQ1RJVkUpXG4gICAgICAgICAgdGhpcy5vYnNlcnZlRmlsdGVycygpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBzZWxlY3Qgb2YgdGhpcy5sb29zZVNlbGVjdEFycikge1xuICAgICAgY29uc3QgaW5wdXRBcnIgPSBbLi4uc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJ0ZXh0XCJdJyldXG4gICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0QXJyKSB7XG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZUZpbHRlcnMoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBiaW5kRG1TZWxlY3RDbGljaygpIHtcbiAgICBjb25zdCBmYWRlID0gKGV4Y2VwdCA9IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgdGhpcy5kbUJ0bkFyci5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYgKGVsICE9PSBleGNlcHQgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhfX0FDVElWRSkpIHtcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKF9fRkFERSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZG1CdG5BcnIuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpXG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoX19GQURFKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGJ0biBvZiB0aGlzLmRtQnRuQXJyKSB7XG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvbWVGYWRlZCA9IHRoaXMuZG1CdG5BcnIuc29tZShlbCA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMoX19GQURFKSlcbiAgICAgICAgY29uc3QgdGFyZ2V0QWN0aXZlID0gYnRuLmNsYXNzTGlzdC5jb250YWlucyhfX0FDVElWRSlcbiAgICAgICAgY29uc3QgdGFyZ2V0RmFkZWQgPSBidG4uY2xhc3NMaXN0LmNvbnRhaW5zKF9fRkFERSlcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYnRuXG5cbiAgICAgICAgaWYgKHRhcmdldEFjdGl2ZSkge1xuICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgICAgICAgIGlmICh0aGlzLmRtQnRuQXJyLnNvbWUoZWwgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKF9fQUNUSVZFKSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKF9fRkFERSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChfX0FDVElWRSlcbiAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShfX0ZBREUpXG4gICAgICAgICAgZmFkZSh0YXJnZXQpXG4gICAgICAgIH1cblxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZFNvcnRNb2RhbEV2ZW50cygpIHtcbiAgICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zb3J0LW1vZGFsJylcbiAgICBpZiAobW9kYWwpIHtcbiAgICAgIGNvbnN0IHJvd0FyciA9IFsuLi5tb2RhbC5xdWVyeVNlbGVjdG9yQWxsKCcuc29ydC1tb2RhbC1yb3cnKV1cbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd0Fycikge1xuICAgICAgICBjb25zdCBoZWFkID0gcm93LnF1ZXJ5U2VsZWN0b3IoJy5zb3J0LW1vZGFsLXJvd19faGVhZCcpXG4gICAgICAgIGNvbnN0IGJvZHkgPSByb3cucXVlcnlTZWxlY3RvcignLnNvcnQtbW9kYWwtcm93X19ib2R5JylcblxuICAgICAgICBpZiAoaGVhZCAmJiBib2R5KSB7XG4gICAgICAgICAgaGVhZC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChib2R5LmNsaWVudEhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgcm93LmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpXG4gICAgICAgICAgICAgIGJvZHkuc3R5bGUuaGVpZ2h0ID0gMFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcm93QXJyLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAociAhPT0gcm93KSB7XG4gICAgICAgICAgICAgICAgICByLmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpXG4gICAgICAgICAgICAgICAgICByLnF1ZXJ5U2VsZWN0b3IoJy5zb3J0LW1vZGFsLXJvd19fYm9keScpLnN0eWxlLmhlaWdodCA9IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJvdy5jbGFzc0xpc3QuYWRkKF9fQUNUSVZFKVxuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYm9keS5xdWVyeVNlbGVjdG9yKCcuc29ydC1tb2RhbC1yb3dfX2NvbnRlbnQnKVxuICAgICAgICAgICAgICBib2R5LnN0eWxlLmhlaWdodCA9IGAke2NvbnRlbnQuc2Nyb2xsSGVpZ2h0ICsgMX1weGBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmJpbmRMb29zZVNlbGVjdHMoKVxuICAgIHRoaXMuYmluZEZpbHRlckJ0bkdyb3VwKClcbiAgICB0aGlzLmJpbmREbVNlbGVjdENsaWNrKClcbiAgICB0aGlzLm9ic2VydmVGaWx0ZXJzKClcbiAgICB0aGlzLmJpbmRTb3J0TW9kYWxFdmVudHMoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTG9vc2VEaWFtb25kcyIsImNvbnN0IG15QmFnID0gbmV3IE9iamVjdCh7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuYXR0YWNoRXZlbnRzKS5mb3JFYWNoKChmbikgPT4ge1xuICAgICAgaWYgKGZuICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGZuID09ICdmdW5jdGlvbicpIGZuKCk7XG4gICAgfSlcbiAgfSxcbiAgYXR0YWNoRXZlbnRzOiB7XG4gICAgZm9ybWF0U3VtbWFyeVByaWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBsaW5lcyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc3VtbWFyeS1wcmljZScpXVxuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBsaW5lLnF1ZXJ5U2VsZWN0b3IoJ3NwYW46bGFzdC1jaGlsZCcpXG4gICAgICAgIGlmIChzcGFuKSB7XG4gICAgICAgICAgY29uc3QgdGV4dCA9IHNwYW4uaW5uZXJUZXh0XG4gICAgICAgICAgbGV0IG51bSA9IE51bWJlcih0ZXh0LnJlcGxhY2UoL1teMC05Li1dL2csICcnKSlcbiAgICAgICAgICBpZiAobnVtICE9PSAwKSB7XG4gICAgICAgICAgICBudW0gPSBudW0udG9GaXhlZCgyKVxuICAgICAgICAgICAgbnVtID0gbnVtLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCIsXCIpO1xuICAgICAgICAgICAgc3Bhbi5pbm5lclRleHQgPSBgJCAke251bX1gXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRTYWxlUGVyY2VudFZhbHVlczogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgY2FyZHMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm15YmFnLWNhcmQnKV1cbiAgICAgIGZvciAoY29uc3QgY2FyZCBvZiBjYXJkcykge1xuICAgICAgICBjb25zdCBuZXdQcmljZSA9IGNhcmQucXVlcnlTZWxlY3RvcignLmNhcmQtcHJpY2VfbmV3JylcbiAgICAgICAgY29uc3Qgb2xkUHJpY2UgPSBjYXJkLnF1ZXJ5U2VsZWN0b3IoJy5jYXJkLXByaWNlX29sZCcpXG4gICAgICAgIGNvbnN0IHNhbGVFbGVtID0gY2FyZC5xdWVyeVNlbGVjdG9yKCcubXliYWctY2FyZC1zYWxlJylcbiAgICAgICAgaWYgKG5ld1ByaWNlICYmIG9sZFByaWNlICYmIHNhbGVFbGVtKSB7XG4gICAgICAgICAgY29uc3QgbmV3UHJpY2VOdW0gPSBOdW1iZXIobmV3UHJpY2UuaW5uZXJUZXh0LnJlcGxhY2UoL1teMC05XS9nLCAnJykpXG4gICAgICAgICAgY29uc3Qgb2xkUHJpY2VOdW0gPSBOdW1iZXIob2xkUHJpY2UuaW5uZXJUZXh0LnJlcGxhY2UoL1teMC05XS9nLCAnJykpXG4gICAgICAgICAgbGV0IHNhbGUgPSAoKG9sZFByaWNlTnVtIC0gbmV3UHJpY2VOdW0pIC8gb2xkUHJpY2VOdW0pICogMTAwXG4gICAgICAgICAgc2FsZSA9IE1hdGgucm91bmQoc2FsZSAvIDEwKSAqIDEwO1xuICAgICAgICAgIGlmIChzYWxlICUgMTAgPj0gNSkge1xuICAgICAgICAgICAgc2FsZSA9IE1hdGguY2VpbChzYWxlIC8gMTApICogMTA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNhbGUgPSBNYXRoLmZsb29yKHNhbGUgLyAxMCkgKiAxMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2FsZUVsZW0uaW5uZXJUZXh0ID0gYCR7c2FsZX0lIE9GRmBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2V0Q2FwaXRhbGl6ZUNoZWNrb3V0QnRuOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBidG5BcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNoZWNrb3V0X19tYWluLWJ0bicpXVxuICAgICAgZm9yIChjb25zdCBidG4gb2YgYnRuQXJyKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBidG4uaW5uZXJUZXh0LnNwbGl0KCcgJykucmVkdWNlKChhY2MsIGVsKSA9PiB7XG4gICAgICAgICAgYWNjLnB1c2goZWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBlbC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgfSwgW10pXG4gICAgICAgIGJ0bi5pbm5lclRleHQgPSB0ZXh0LmpvaW4oJyAnKVxuICAgICAgfVxuICAgIH1cblxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IG15QmFnIiwiY29uc3QgcGFzc1Jlc2V0ID0ge1xuICBJU19FTVBUWTogJ2lzLWVtcHR5JyxcbiAgSVNfRElTQUJMRUQ6ICdpcy1kaXNhYmxlZCcsXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJCgnLnBhc3MtcmVzZXQtcGFnZScpLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZW5kZXJET00oKVxuICAgICAgdGhpcy5iaW5kRXZlbnRzKClcbiAgICB9XG4gIH0sXG4gIHJlbmRlckRPTTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZm9ybSA9ICQoJyNwYXNzUmVzZXRGb3JtJylcbiAgICB0aGlzLnN1Ym1pdEJ0biA9ICQoJyNwYXNzUmVzZXRTdWJtaXQnKVxuICAgIHRoaXMuaW5wdXRBcnIgPSBbLi4udGhpcy5mb3JtLmZpbmQoJ2lucHV0W3R5cGU9XCJwYXNzd29yZFwiXScpXVxuICAgIHRoaXMuZXJyb3IgPSAkKCcucGFzcy1yZXNldC1lcnJvcicpXG4gICAgdGhpcy5sb2FkZXIgPSAkKCcucGFzcy1yZXNldC1sb2FkZXInKVxuICAgIHRoaXMubWFpbiA9ICQoJy5wYXNzLXJlc2V0X19tYWluJylcbiAgICB0aGlzLnJlc3VsdCA9ICQoJy5wYXNzLXJlc2V0X19yZXN1bHQnKVxuICB9LFxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc3VibWl0IGNsaWNrXG4gICAgJC5lYWNoKHRoaXMuc3VibWl0QnRuLCBmdW5jdGlvbiAoaSkge1xuICAgICAgcGFzc1Jlc2V0LnN1Ym1pdEJ0bltpXS5vbmNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHBhc3NSZXNldC5mb3JtLnN1Ym1pdCgpXG4gICAgICB9XG4gICAgfSlcbiAgICAvLyBpbnB1dCBldmVudHNcbiAgICAkLmVhY2godGhpcy5pbnB1dEFyciwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHBhc3NSZXNldC5pbnB1dEFycltpXS5vbmlucHV0ID0gKCkgPT4ge1xuICAgICAgICBsZXQgYXJyID0gcGFzc1Jlc2V0LmlucHV0QXJyXG4gICAgICAgIGxldCBwYXNzMSA9IGFyclswXS52YWx1ZSwgcGFzczIgPSBhcnJbMV0udmFsdWVcbiAgICAgICAgaWYgKHBhc3MyLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcGFzc1Jlc2V0LmhpZGVFcnJvcigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHBhc3MxLmxlbmd0aCAhPT0gcGFzczIubGVuZ3RoKSB7IHBhc3NSZXNldC5zaG93RXJyb3IoJ0RpZmZlcmVudCBwYXNzd29yZCBsZW5ndGgnKSB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXNzUmVzZXQuaGlkZUVycm9yKCk7IGlmIChwYXNzMSA9PT0gcGFzczIpIHsgcGFzc1Jlc2V0LnN1Y2Nlc3NFcnJvcigpIH1cbiAgICAgICAgICAgIGVsc2UgeyBwYXNzUmVzZXQuc2hvd0Vycm9yKFwiUGFzc3dvcmRzIGRvbid0IG1hdGNoXCIpIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIC8vIGZvcm0gc3VibWl0XG4gICAgdGhpcy5mb3JtWzBdLm9uc3VibWl0ID0gKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgaWYgKHBhc3NSZXNldC5mb3JtVmFsaWQoKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHBhc3NSZXNldC5zdWJtaXRCdG5bMF0uc3R5bGUsIHsgY29sb3I6ICd0cmFuc3BhcmVudCcsIGhlaWdodDogJzE0cHgnLCAnYm9yZGVyLXJhZGl1cyc6ICc1MHB4JyB9KVxuICAgICAgICBwYXNzUmVzZXQuZm9ybS5hZGRDbGFzcyhwYXNzUmVzZXQuSVNfRElTQUJMRUQpXG4gICAgICAgIHBhc3NSZXNldC5oaWRlRXJyb3IoKVxuICAgICAgICBwYXNzUmVzZXQubG9hZGVyWzBdLmFuaW1hdGUoeyB3aWR0aDogJzEwMCUnIH0sIHsgZHVyYXRpb246IDMwMDAsIGZpbGw6ICdmb3J3YXJkcycgfSkub25maW5pc2ggPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZS50YXJnZXQpLCBvYmogPSB7fVxuICAgICAgICAgIGZvcm1EYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IChvYmpba2V5XSA9IHZhbHVlKSlcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHBhc3NSZXNldC5tYWluWzBdLnN0eWxlLCB7IG9wYWNpdHk6IDAgfSk7IE9iamVjdC5hc3NpZ24ocGFzc1Jlc2V0LnJlc3VsdFswXS5zdHlsZSwgeyBvcGFjaXR5OiAwIH0pXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBwYXNzUmVzZXQubWFpbi5oaWRlKClcbiAgICAgICAgICAgIHBhc3NSZXNldC5yZXN1bHQuc2hvdygpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXNzUmVzZXQucmVzdWx0WzBdLnN0eWxlLCB7IG9wYWNpdHk6IDEgfSlcbiAgICAgICAgICAgIH0sIDUpO1xuICAgICAgICAgIH0sIDQwMSk7XG4gICAgICAgICAgLy8gYWxlcnQoSlNPTi5zdHJpbmdpZnkob2JqKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZm9ybVZhbGlkOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGFyciA9IHBhc3NSZXNldC5pbnB1dEFyclxuICAgIGFyci5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUocGFzc1Jlc2V0LklTX0VNUFRZKSlcblxuICAgIGlmIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICBsZXQgZW1wdHlJbnB1dCA9IGFyci5maWx0ZXIoZWwgPT4gZWwudmFsdWUubGVuZ3RoID09IDApXG5cbiAgICAgIGlmIChlbXB0eUlucHV0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAkLmVhY2goZW1wdHlJbnB1dCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICBlbXB0eUlucHV0W2ldLmNsYXNzTGlzdC5hZGQocGFzc1Jlc2V0LklTX0VNUFRZKVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZW1wdHlJbnB1dFtpXS5jbGFzc0xpc3QucmVtb3ZlKHBhc3NSZXNldC5JU19FTVBUWSlcbiAgICAgICAgICB9LCA0MDApO1xuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHBhc3MxID0gYXJyWzBdLnZhbHVlLCBwYXNzMiA9IGFyclsxXS52YWx1ZVxuICAgICAgICBpZiAocGFzczEgPT09IHBhc3MyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuICB9LFxuICBzaG93RXJyb3I6IGZ1bmN0aW9uICh0ZXh0ID0gJ1NvbWV0aGluZyB3ZW50IHdyb25nLi4uJykge1xuICAgIHRoaXMuZXJyb3IuaHRtbCh0ZXh0KVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5lcnJvclswXS5zdHlsZSwgeyBjb2xvcjogJyNjMDI5NDInLCBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoMHB4KScgfSlcbiAgfSxcbiAgaGlkZUVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmVycm9yWzBdLnN0eWxlLCB7IGNvbG9yOiAnI2MwMjk0MicsIG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgxNHB4KScgfSlcbiAgfSxcbiAgc3VjY2Vzc0Vycm9yOiBmdW5jdGlvbiAodGV4dCA9ICdQYXNzd29yZHMgbWF0Y2ghJykge1xuICAgIHRoaXMuZXJyb3IuaHRtbCh0ZXh0KVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5lcnJvclswXS5zdHlsZSwgeyBjb2xvcjogJyMwODhkN2InLCBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoMHB4KScgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhc3NSZXNldCIsImNsYXNzIFByb2R1Y3RQYWdlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vcHRpb25zQXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcm9kdWN0X19pdGVtLW9wdGlvbjpub3QoLi0tc3RhdGljKScpXVxuICAgIHRoaXMub3B0aW9uc1JvdyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zaWRlLXJvd19fb3B0aW9ucycpXG4gICAgdGhpcy5jb2xvclBpY2tBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNvbG9yLXBpY2snKV1cbiAgICB0aGlzLnRvZ2dsZVJvd0FyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudG9nZ2xlLXJvdycpXVxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcHJvZHVjdF9kZXNjcmlwdGlvbicpXG4gICAgdGhpcy5nYWxsZXJ5RGVza3RvcEFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZ2FsbGVyeV9kZXNrdG9wJykucXVlcnlTZWxlY3RvckFsbCgnLnByb2R1Y3RfX2dhbGxlcnknKV1cbiAgICB0aGlzLmdhbGxlcnlNb2JpbGVBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2dhbGxlcnlfbW9iaWxlJykucXVlcnlTZWxlY3RvckFsbCgnLnByb2R1Y3RfX2dhbGxlcnknKV1cblxuICAgIHRoaXMub3B0aW9uTW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcub3B0aW9uLW1vZGFsJylcbiAgICB0aGlzLm9wdGlvbk1vZGFsQ29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vcHRpb24tbW9kYWxfX2NvbnRlbnQnKVxuICAgIHRoaXMub3B0aW9uTW9kYWxOZXh0RWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW9wdGlvbi1tb2RhbC1uZXh0XScpXG4gICAgdGhpcy5vcHRpb25Nb2RhbE5hbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1vcHRpb24tbW9kYWwtbmFtZV0nKVxuICAgIHRoaXMuZXZ0TmV4dE9wdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWV2dD1cIm9wdGlvbk1vZGFsTmV4dFwiXScpXG4gICAgdGhpcy5ldnRDbG9zZU9wdGlvbk1vZGFsQXJyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZXZ0PVwib3B0aW9uTW9kYWxDbG9zZVwiXScpXG4gICAgdGhpcy5mYXZCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdF9fYWRkLWZhdicpXG4gICAgdGhpcy5hY3RpdmVPcHRpb25JbmRleCA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5maXhlZEJhciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5maXhlZC1iYXInKVxuICAgIHRoaXMuZml4ZWRCYXJUcmlnZ2VyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNpZGUtcm93X19wYXltZW50cycpXG4gICAgdGhpcy5pbml0KClcbiAgfVxuXG4gIC8vIEdhbGxlcnlcbiAgc2V0dXBEZXNrdG9wR2FsbGVyeSgpIHtcbiAgICBmb3IgKGNvbnN0IGdhbGxlcnkgb2YgdGhpcy5nYWxsZXJ5RGVza3RvcEFycikge1xuICAgICAgY29uc3QgdGh1bWJzID0gWy4uLmdhbGxlcnkucXVlcnlTZWxlY3RvcignLnByb2R1Y3RfX3RodW1iLWdhbGxlcnknKS5xdWVyeVNlbGVjdG9yQWxsKCcucHJvZHVjdC1tZWRpYScpXVxuICAgICAgY29uc3QgbWVkaWEgPSBbLi4uZ2FsbGVyeS5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdF9fbWFpbi1nYWxsZXJ5JykucXVlcnlTZWxlY3RvckFsbCgnLnByb2R1Y3QtbWVkaWEnKV1cblxuICAgICAgaWYgKHRodW1icy5sZW5ndGggJiYgbWVkaWEubGVuZ3RoKSB7XG4gICAgICAgIHRodW1icy5mb3JFYWNoKCh0aHVtYiwgaW5kZXgpID0+IHtcbiAgICAgICAgICB0aHVtYi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIG1lZGlhLmZvckVhY2goZWwgPT4gZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJylcbiAgICAgICAgICAgIG1lZGlhW2luZGV4XS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldHVwTW9iaWxlR2FsbGVyeSgpIHtcbiAgICBmb3IgKGNvbnN0IGdhbGxlcnkgb2YgdGhpcy5nYWxsZXJ5TW9iaWxlQXJyKSB7XG4gICAgICBjb25zdCBtYWluU3BsaWRlID0gZ2FsbGVyeS5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdF9fbWFpbi1nYWxsZXJ5LnNwbGlkZScpXG4gICAgICBjb25zdCB0aHVtYnNTcGxpZGUgPSBnYWxsZXJ5LnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0X190aHVtYi1nYWxsZXJ5LnNwbGlkZScpXG5cbiAgICAgIGlmIChtYWluU3BsaWRlICYmIHRodW1ic1NwbGlkZSkge1xuICAgICAgICBjb25zdCBtYWluID0gbmV3IFNwbGlkZShtYWluU3BsaWRlLCB7XG4gICAgICAgICAgdHlwZTogXCJsb29wXCIsXG4gICAgICAgICAgcGVyUGFnZTogMSxcbiAgICAgICAgICBwZXJNb3ZlOiAxLFxuICAgICAgICAgIGdhcDogOCxcbiAgICAgICAgICBhcnJvd3M6IGZhbHNlLFxuICAgICAgICAgIHBhZ2luYXRpb246IGZhbHNlLFxuICAgICAgICAgIHNwZWVkOiA3NTAsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgdGh1bWJzID0gbmV3IFNwbGlkZSh0aHVtYnNTcGxpZGUsIHtcbiAgICAgICAgICByZXdpbmQ6IHRydWUsXG4gICAgICAgICAgcGFnaW5hdGlvbjogZmFsc2UsXG4gICAgICAgICAgYXJyb3dzOiBmYWxzZSxcbiAgICAgICAgICBjb3ZlcjogdHJ1ZSxcbiAgICAgICAgICBpc05hdmlnYXRpb246IHRydWUsXG4gICAgICAgICAgZml4ZWRXaWR0aDogMzgsXG4gICAgICAgICAgZ2FwOiA0XG4gICAgICAgIH0pXG4gICAgICAgIG1haW4uc3luYyh0aHVtYnMpXG4gICAgICAgIG1haW4ubW91bnQoKVxuICAgICAgICB0aHVtYnMubW91bnQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXR1cEdhbGxlcnkoKSB7XG4gICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gOTkxKSB7XG4gICAgICB0aGlzLnNldHVwRGVza3RvcEdhbGxlcnkoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldHVwTW9iaWxlR2FsbGVyeSgpXG4gICAgfVxuICB9XG5cbiAgLy8gTWV0aG9kc1xuICBzZXRBY3RpdmVPcHRpb25zVGV4dCgpIHtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLm9wdGlvbnNBcnIpIHtcbiAgICAgIGNvbnN0IGhvbGRlciA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1vcHRpb25fX2hlYWQtcmlnaHQnKVxuICAgICAgY29uc3QgYWN0aXZlQnRuID0gb3B0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5vcHRpb24tYnRuLmlzLWFjdGl2ZScpXG5cbiAgICAgIGlmIChob2xkZXIgJiYgYWN0aXZlQnRuKSB7XG4gICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gYWN0aXZlQnRuLnRleHRDb250ZW50LnRyaW0oKVxuICAgICAgICBpZiAodGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtID0gY3JlYXRlRWxlbSgnZGl2Jywge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAncHJvZHVjdC1vcHRpb24tY3VycmVudCcsXG4gICAgICAgICAgICBpbm5lckhUTUw6IHRleHRDb250ZW50XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGhvbGRlci5wcmVwZW5kKHNlbGVjdGVkRWxlbSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRBY3RpdmVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IGN1cnJlbnRFbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtY3VycmVudC1jb2xvcl0nKVxuICAgIGlmIChjdXJyZW50RWxlbSkge1xuICAgICAgY3VycmVudEVsZW0uaW5uZXJIVE1MID0gY29sb3JcbiAgICB9XG4gIH1cbiAgc2V0QWN0aXZlQ29sb3JQaWNrRWxlbShlbGVtKSB7XG4gICAgdGhpcy5jb2xvclBpY2tBcnIuZm9yRWFjaCgocGljaykgPT4ge1xuICAgICAgaWYgKHBpY2sgPT09IGVsZW0pIHtcbiAgICAgICAgcGljay5jbGFzc0xpc3QuYWRkKCctLWFjdGl2ZScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaWNrLmNsYXNzTGlzdC5yZW1vdmUoJy0tYWN0aXZlJylcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIHNldHVwRGVzY3JpcHRpb24oKSB7XG4gICAgaWYgKHRoaXMuZGVzY3JpcHRpb24pIHtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gdGhpcy5kZXNjcmlwdGlvbi50ZXh0Q29udGVudFxuXG4gICAgICBjb25zdCBleHRyYWN0TGFzdFBhcmFncmFwaCA9ICgpID0+IHtcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gdGhpcy5kZXNjcmlwdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdwLCBkaXYsIGxpJylcbiAgICAgICAgbGV0IGhvbGRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpdGVtRGV0YWlscycpXG5cbiAgICAgICAgaWYgKGhvbGRlcikge1xuICAgICAgICAgIGZvciAobGV0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LnRleHRDb250ZW50LnRyaW0oKS5zdGFydHNXaXRoKFwiVGhlc2UgcGllY2VzIGFyZSBoYW5kY3JhZnRlZCBhbmQgbWFudWZhY3R1cmVkIGJ5IEljZWJveFwiKSkge1xuICAgICAgICAgICAgICBob2xkZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgncHJvZHVjdF9fbW9yZS10eXBvJylcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV4dHJhY3RMYXN0UGFyYWdyYXBoKClcbiAgICB9XG4gIH1cbiAgc2V0dXBTcGxpZGUoKSB7XG4gICAgY29uc3Qgc3BsaWRlQXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb3JlLXJvd19fc3BsaWRlJyldXG4gICAgZm9yIChjb25zdCBlbCBvZiBzcGxpZGVBcnIpIHtcbiAgICAgIGxldCBtYWluID0gbmV3IFNwbGlkZShlbCwge1xuICAgICAgICB0eXBlOiBcImxvb3BcIixcbiAgICAgICAgcGVyUGFnZTogNCxcbiAgICAgICAgcGVyTW92ZTogMSxcbiAgICAgICAgYXV0b3BsYXk6IDAsXG4gICAgICAgIGdhcDogXCI4cHhcIixcbiAgICAgICAgYXJyb3dzOiAxLFxuICAgICAgICBwYWdpbmF0aW9uOiAwLFxuICAgICAgICBzcGVlZDogNzUwLFxuICAgICAgICBicmVha3BvaW50czoge1xuICAgICAgICAgIDE5ODA6IHtcbiAgICAgICAgICAgIHBlclBhZ2U6IDUsXG4gICAgICAgICAgICBwZXJNb3ZlOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgMTY4MDoge1xuICAgICAgICAgICAgcGVyUGFnZTogNCxcbiAgICAgICAgICAgIHBlck1vdmU6IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAxMTIwOiB7XG4gICAgICAgICAgICBwZXJQYWdlOiA0LFxuICAgICAgICAgICAgcGVyTW92ZTogMSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIDk5MToge1xuICAgICAgICAgICAgcGVyUGFnZTogNCxcbiAgICAgICAgICAgIHBlck1vdmU6IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICA3Njc6IHtcbiAgICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgICAgcm93czogMixcbiAgICAgICAgICAgICAgY29sczogMyxcbiAgICAgICAgICAgICAgZ2FwOiB7IHJvdzogXCIxMHB4XCIsIGNvbDogXCI4cHhcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIDQ3ODoge1xuICAgICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgICByb3dzOiAyLFxuICAgICAgICAgICAgICBjb2xzOiAyLFxuICAgICAgICAgICAgICBnYXA6IHsgcm93OiBcIjI0cHhcIiwgY29sOiBcIjhweFwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KS5tb3VudCh3aW5kb3cuc3BsaWRlLkV4dGVuc2lvbnMpXG4gICAgfVxuICB9XG5cbiAgLy8gT3B0aW9uIE1vZGFsXG4gIHJldmVydE9wdGlvbnMoKSB7XG4gICAgY29uc3QgYm9keSA9IHRoaXMub3B0aW9uTW9kYWwucXVlcnlTZWxlY3RvcignLnByb2R1Y3Qtb3B0aW9uX19ib2R5JylcbiAgICBjb25zdCBndWlkZUJ0biA9IHRoaXMub3B0aW9uTW9kYWwucXVlcnlTZWxlY3RvcignLm9wdGlvbi1ndWlkZS1idG4nKVxuICAgIGNvbnN0IGVtcHR5T3B0aW9uID0gdGhpcy5vcHRpb25zQXJyLmZpbmQob3B0aW9uID0+ICFvcHRpb24ucXVlcnlTZWxlY3RvcignLnByb2R1Y3Qtb3B0aW9uX19ib2R5JykpXG4gICAgaWYgKGJvZHkgJiYgZW1wdHlPcHRpb24pIHtcbiAgICAgIGlmIChndWlkZUJ0bikge1xuICAgICAgICBib2R5LmFwcGVuZChndWlkZUJ0bilcbiAgICAgIH1cbiAgICAgIGVtcHR5T3B0aW9uLmFwcGVuZChib2R5KVxuICAgIH1cbiAgfVxuICBhcHBlbmRPcHRpb24ob3B0aW9uID0gdGhpcy5vcHRpb25zQXJyWzBdKSB7XG4gICAgdGhpcy5yZXZlcnRPcHRpb25zKClcbiAgICBpZiAob3B0aW9uKSB7XG4gICAgICBjb25zdCBvcHRpb25OYW1lID0gb3B0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LW9wdGlvbi1uYW1lJylcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMub3B0aW9uc0Fyci5pbmRleE9mKG9wdGlvbilcbiAgICAgIHRoaXMuYWN0aXZlT3B0aW9uSW5kZXggPSBjdXJyZW50SW5kZXhcbiAgICAgIGNvbnN0IG5leHRPcHRpb24gPSB0aGlzLm9wdGlvbnNBcnJbY3VycmVudEluZGV4ICsgMV0gfHwgdGhpcy5vcHRpb25zQXJyWzBdXG4gICAgICBjb25zdCBuZXh0T3B0aW9uTmFtZSA9IG5leHRPcHRpb24ucXVlcnlTZWxlY3RvcignLnByb2R1Y3Qtb3B0aW9uLW5hbWUnKVxuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1vcHRpb25fX2JvZHknKVxuXG4gICAgICBjb25zdCBndWlkZUJ0biA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCcub3B0aW9uLWd1aWRlLWJ0bicpXG4gICAgICBjb25zdCBtb2RhbFdyYXBwZXIgPSB0aGlzLm9wdGlvbk1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5vcHRpb24tbW9kYWxfX3dyYXBwZXInKVxuXG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICB0aGlzLm9wdGlvbk1vZGFsTmFtZS5pbm5lckhUTUwgPSBvcHRpb25OYW1lLnRleHRDb250ZW50XG4gICAgICAgIHRoaXMub3B0aW9uTW9kYWxOZXh0RWxlbS5pbm5lckhUTUwgPSBuZXh0T3B0aW9uTmFtZS50ZXh0Q29udGVudFxuICAgICAgICB0aGlzLm9wdGlvbk1vZGFsQ29udGVudC5hcHBlbmRDaGlsZChib2R5KVxuXG4gICAgICAgIGlmIChndWlkZUJ0biAmJiBtb2RhbFdyYXBwZXIpIHtcbiAgICAgICAgICBtb2RhbFdyYXBwZXIuYXBwZW5kKGd1aWRlQnRuKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJpbmRPcHRpb25Nb2RhbEV2ZW50cygpIHtcbiAgICB0aGlzLmV2dE5leHRPcHRpb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB0aGlzLmFwcGVuZE9wdGlvbih0aGlzLm9wdGlvbnNBcnJbdGhpcy5hY3RpdmVPcHRpb25JbmRleCArIDFdIHx8IHRoaXMub3B0aW9uc0FyclswXSlcbiAgICB9KVxuICAgIHRoaXMuZXZ0Q2xvc2VPcHRpb25Nb2RhbEFyci5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlT3B0aW9uTW9kYWwoKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG4gIGJpbmRPcHRpb25Ub2dnbGVNb2JpbGUoKSB7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5vcHRpb25zQXJyKSB7XG4gICAgICBjb25zdCBoZWFkID0gb3B0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LW9wdGlvbl9faGVhZCcpXG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LW9wdGlvbl9fYm9keScpXG5cbiAgICAgIGlmIChoZWFkICYmIGJvZHkpIHtcbiAgICAgICAgaGVhZC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFwcGVuZE9wdGlvbihvcHRpb24pXG4gICAgICAgICAgdGhpcy5zaG93T3B0aW9uTW9kYWwoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaG93T3B0aW9uTW9kYWwoKSB7XG4gICAgbG9ja1Njcm9sbCgpXG4gICAgd2luZG93Lm9wdGlvbk1vZGFsQmFja2Ryb3AgPSBuZXcgQmFja2Ryb3Aoe1xuICAgICAgaGFsZjogdHJ1ZSxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7IHRoaXMuY2xvc2VPcHRpb25Nb2RhbCgpIH1cbiAgICB9KVxuICAgIHRoaXMub3B0aW9uTW9kYWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMub3B0aW9uTW9kYWwuY2xhc3NMaXN0LmFkZCgnLS12aXNpYmxlJylcbiAgICB9LCAzKTtcbiAgfVxuICBjbG9zZU9wdGlvbk1vZGFsKCkge1xuICAgIHVubG9ja1Njcm9sbCgpXG4gICAgdGhpcy5vcHRpb25Nb2RhbC5jbGFzc0xpc3QucmVtb3ZlKCctLXZpc2libGUnKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5vcHRpb25Nb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICB0aGlzLnJldmVydE9wdGlvbnMoKVxuICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMub3B0aW9uTW9kYWwpKTtcbiAgICBpZiAod2luZG93Lm9wdGlvbk1vZGFsQmFja2Ryb3ApIHtcbiAgICAgIHdpbmRvdy5vcHRpb25Nb2RhbEJhY2tkcm9wLmhpZGUodHJ1ZSlcbiAgICB9XG4gIH1cblxuICAvLyBNZXRob2RzIC0gT3B0aW9uc1xuICBoaWRlQWxsT3B0aW9ucyhleGNsdWRlID0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9uc0Fyci5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICBpZiAob3B0aW9uICE9PSBleGNsdWRlKSB7XG4gICAgICAgIHRoaXMuaGlkZU9wdGlvbihvcHRpb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dPcHRpb24ob3B0aW9uKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKGV4Y2x1ZGUgPT0gbnVsbCkge1xuICAgICAgdGhpcy5vcHRpb25zUm93LmNsYXNzTGlzdC5yZW1vdmUoJy0tYWN0aXZlJylcbiAgICB9XG4gIH1cbiAgc2hvd09wdGlvbihvcHRpb24pIHtcbiAgICBvcHRpb24uY2xhc3NMaXN0LmFkZCgnLS1hY3RpdmUnKVxuICB9XG4gIGhpZGVPcHRpb24ob3B0aW9uKSB7XG4gICAgb3B0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJy0tYWN0aXZlJylcbiAgfVxuXG4gIC8vIEJpbmQgRXZlbnRzXG4gIGJpbmRPcHRpb25Ub2dnbGVEZXNrdG9wKCkge1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHRoaXMub3B0aW9uc0Fycikge1xuICAgICAgY29uc3QgaGVhZCA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1vcHRpb25fX2hlYWQnKVxuICAgICAgY29uc3QgYnRuQXJyID0gWy4uLm9wdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCcub3B0aW9uLWJ0bicpXVxuICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICBpZiAob3B0aW9uLmNsYXNzTGlzdC5jb250YWlucygnLS1hY3RpdmUnKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlT3B0aW9uKG9wdGlvbilcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1Jvdy5jbGFzc0xpc3QucmVtb3ZlKCctLWFjdGl2ZScpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUFsbE9wdGlvbnMob3B0aW9uKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zUm93LmNsYXNzTGlzdC5hZGQoJy0tYWN0aXZlJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXRcbiAgICAgIGlmICghdGFyZ2V0LmNsb3Nlc3QoJy5wcm9kdWN0X19pdGVtLW9wdGlvbicpKSB7XG4gICAgICAgIHRoaXMuaGlkZUFsbE9wdGlvbnMoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgYmluZE9wdGlvbkJ1dHRvbkNsaWNrKCkge1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHRoaXMub3B0aW9uc0Fycikge1xuICAgICAgY29uc3QgYnRuQXJyID0gWy4uLm9wdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCcub3B0aW9uLWJ0bicpXVxuICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtID0gb3B0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LW9wdGlvbi1jdXJyZW50JylcblxuICAgICAgaWYgKGJ0bkFyci5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCBidG4gb2YgYnRuQXJyKSB7XG4gICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlQWxsT3B0aW9ucygpXG5cbiAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gYnRuLnRleHRDb250ZW50LnRyaW0oKVxuICAgICAgICAgICAgaWYgKHRleHRDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRFbGVtLmlubmVySFRNTCA9IHRleHRDb250ZW50XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnRuQXJyLmZvckVhY2goZWwgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShJU19BQ1RJVkUpKVxuICAgICAgICAgICAgYnRuLmNsYXNzTGlzdC5hZGQoSVNfQUNUSVZFKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmluZE9wdGlvbkJ1dHRvbkNsaWNrSW5wdXRWYWx1ZSgpIHtcbiAgICBjb25zdCBidG5BcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm9wdGlvbi1idG4nKV1cbiAgICBmb3IgKGNvbnN0IGJ0biBvZiBidG5BcnIpIHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBidG4uZGF0YXNldC52YWx1ZVxuICAgICAgICBpZiAoIXZhbHVlKSB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEtdmFsdWUgYXR0cmlidXRlIGlzIHJlcXVpcmVkJylcbiAgICAgICAgY29uc3QgaW5wdXQgPSBidG4uY2xvc2VzdCgnLnByb2R1Y3RfX2l0ZW0tb3B0aW9uJykucXVlcnlTZWxlY3RvcignLmN1c3RvbS1maWVsZHMtZmV0Y2gnKVxuICAgICAgICBpZiAoIWlucHV0KSB0aHJvdyBuZXcgRXJyb3IoJ2N1c3RvbS1maWVsZHMtZmV0Y2ggZWxlbWVudCBpcyByZXF1aXJlZCcpXG4gICAgICAgICAgXG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWVcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2NoYW5nZScsIHsgYnViYmxlczogdHJ1ZSB9KVxuICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZENvbG9yUGljaygpIHtcbiAgICB0aGlzLmNvbG9yUGlja0Fyci5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgY29uc3QgYXR0ciA9IGJ0bi5kYXRhc2V0LmNvbG9yXG4gICAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgICAgdGhpcy5zZXRBY3RpdmVDb2xvcihhdHRyKVxuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlQ29sb3JQaWNrRWxlbShidG4pXG5cbiAgICAgICAgICBpZiAodGhpcy5maXhlZEJhcikge1xuICAgICAgICAgICAgdGhpcy5maXhlZEJhci5jbGFzc0xpc3QucmVtb3ZlKCctLWZpbGxlZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbiAgYmluZFRvZ2dsZVJvdygpIHtcbiAgICB0aGlzLnRvZ2dsZVJvd0Fyci5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgIGNvbnN0IGhlYWQgPSByb3cucXVlcnlTZWxlY3RvcignLnRvZ2dsZS1yb3dfX2hlYWQnKVxuICAgICAgY29uc3QgYm9keSA9IHJvdy5xdWVyeVNlbGVjdG9yKCcudG9nZ2xlLXJvd19fYm9keScpXG4gICAgICBjb25zdCB3cmFwcGVyID0gcm93LnF1ZXJ5U2VsZWN0b3IoJy50b2dnbGUtcm93X193cmFwcGVyJylcblxuICAgICAgaWYgKGhlYWQgJiYgYm9keSAmJiB3cmFwcGVyKSB7XG4gICAgICAgIGhlYWQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gd3JhcHBlci5zY3JvbGxIZWlnaHRcbiAgICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IGJvZHkub2Zmc2V0SGVpZ2h0ID4gMCAmJiByb3cuY2xhc3NMaXN0LmNvbnRhaW5zKCctLWFjdGl2ZScpXG5cbiAgICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIGJvZHkuc3R5bGUuaGVpZ2h0ID0gYDBweGBcbiAgICAgICAgICAgIHJvdy5jbGFzc0xpc3QucmVtb3ZlKCctLWFjdGl2ZScpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkuc3R5bGUuaGVpZ2h0ID0gYCR7c2Nyb2xsSGVpZ2h0fXB4YFxuICAgICAgICAgICAgcm93LmNsYXNzTGlzdC5hZGQoJy0tYWN0aXZlJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBiaW5kVG9nZ2xlRmF2KCkge1xuICAgIGlmICh0aGlzLmZhdkJ0bikge1xuICAgICAgdGhpcy5mYXZCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZmF2QnRuLmNsYXNzTGlzdC50b2dnbGUoJ2lzLWFjdGl2ZScpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpeGVkIEJhclxuICBwb3NpdGlvbkZpeGVkQmFyKCkge1xuICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWRlcicpXG4gICAgaWYgKGhlYWRlciAmJiB0aGlzLmZpeGVkQmFyICYmIHRoaXMuZml4ZWRCYXJUcmlnZ2VyKSB7XG4gICAgICB0aGlzLmZpeGVkQmFyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG5cbiAgICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gOTkxKSB7XG4gICAgICAgICAgdGhpcy5maXhlZEJhci5zdHlsZS56SW5kZXggPSAtMVxuICAgICAgICAgIHRoaXMuZml4ZWRCYXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgICAgICAgdGhpcy5maXhlZEJhci5zdHlsZS50b3AgPSAnMTAwJSdcbiAgICAgICAgICBpZiAoIWhlYWRlci5jb250YWlucyh0aGlzLmZpeGVkQmFyKSkge1xuICAgICAgICAgICAgaGVhZGVyLmFwcGVuZENoaWxkKHRoaXMuZml4ZWRCYXIpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGhlYWRlclpJbmRleCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGhlYWRlcikuZ2V0UHJvcGVydHlWYWx1ZSgnei1pbmRleCcpXG4gICAgICAgICAgdGhpcy5maXhlZEJhci5zdHlsZS56SW5kZXggPSBwYXJzZUludChoZWFkZXJaSW5kZXgsIDEwKSAtIDFcbiAgICAgICAgICB0aGlzLmZpeGVkQmFyLnN0eWxlLnRvcCA9ICdhdXRvJ1xuICAgICAgICAgIHRoaXMuZml4ZWRCYXIuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuZml4ZWRCYXIpKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZml4ZWRCYXIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpXG4gICAgICB1cGRhdGUoKVxuICAgIH1cbiAgfVxuICBvYnNlcnZlRml4ZWRCYXIoKSB7XG4gICAgY29uc3QgdHJpZ2dlckVsZW0gPSB0aGlzLmZpeGVkQmFyVHJpZ2dlclxuICAgIGNvbnN0IGJhciA9IHRoaXMuZml4ZWRCYXJcbiAgICBsZXQgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZGVyJylcblxuICAgIGlmICh0cmlnZ2VyRWxlbSAmJiBiYXIpIHtcbiAgICAgIGxldCBoZWFkZXJPZmZzZXQgPSBoZWFkZXIgPyBoZWFkZXIub2Zmc2V0SGVpZ2h0IDogMFxuICAgICAgbGV0IG9ic2VydmVyID0gbnVsbFxuXG4gICAgICBjb25zdCB1cGRhdGVPYnNlcnZlciA9ICgpID0+IHtcbiAgICAgICAgaGVhZGVyT2Zmc2V0ID0gaGVhZGVyID8gaGVhZGVyLm9mZnNldEhlaWdodCA6IDBcblxuICAgICAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9ic2VydmVyQ2FsbGJhY2sgPSAoZW50cmllcykgPT4ge1xuICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICBpZiAoZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LnRvcCA8IGhlYWRlck9mZnNldCAmJiAhZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgYmFyLmNsYXNzTGlzdC5hZGQoX19WSVNJQkxFKVxuICAgICAgICAgICAgICB0aGlzLnNldEZpeGVkQmFyTWVkaWEoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmFyLmNsYXNzTGlzdC5yZW1vdmUoX19WSVNJQkxFKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihvYnNlcnZlckNhbGxiYWNrLCB7XG4gICAgICAgICAgcm9vdDogbnVsbCxcbiAgICAgICAgICByb290TWFyZ2luOiBgLSR7aGVhZGVyT2Zmc2V0fXB4IDBweCAwcHggMHB4YCxcbiAgICAgICAgICB0aHJlc2hvbGQ6IDBcbiAgICAgICAgfSlcblxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRyaWdnZXJFbGVtKVxuICAgICAgfVxuXG4gICAgICB1cGRhdGVPYnNlcnZlcigpXG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVPYnNlcnZlcilcbiAgICB9XG4gIH1cbiAgc2V0Rml4ZWRCYXJNZWRpYSgpIHtcbiAgICBpZiAodGhpcy5maXhlZEJhcikge1xuXG4gICAgICBpZiAoIXRoaXMuZml4ZWRCYXIucXVlcnlTZWxlY3RvcignaW1nJykpIHtcbiAgICAgICAgdGhpcy5maXhlZEJhci5jbGFzc0xpc3QucmVtb3ZlKCctLWZpbGxlZCcpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZpc2libGVHYWxsZXJ5ID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcm9kdWN0X19nYWxsZXJ5JyldLmZpbmQoKGVsKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpICE9PSAnbm9uZSdcbiAgICAgIH0pXG5cbiAgICAgIGlmICh2aXNpYmxlR2FsbGVyeSkge1xuICAgICAgICBjb25zdCBtYWluR2FsbGVyeSA9IHZpc2libGVHYWxsZXJ5LnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0X19tYWluLWdhbGxlcnknKVxuICAgICAgICBjb25zdCBmaXhlZEJhck1lZGlhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZpeGVkLWJhcl9fbWVkaWEnKVxuXG4gICAgICAgIGlmIChtYWluR2FsbGVyeSAmJiBmaXhlZEJhck1lZGlhKSB7XG4gICAgICAgICAgY29uc3QgaW1hZ2UgPSBtYWluR2FsbGVyeS5xdWVyeVNlbGVjdG9yKCdpbWcnKVxuICAgICAgICAgIGNvbnN0IGZpeGVkQmFySW1hZ2UgPSBmaXhlZEJhck1lZGlhLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpXG5cbiAgICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgIGlmICghZml4ZWRCYXJJbWFnZSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXdJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgICAgICAgICAgICBuZXdJbWcuc3JjID0gaW1hZ2Uuc3JjXG4gICAgICAgICAgICAgIGZpeGVkQmFyTWVkaWEuYXBwZW5kQ2hpbGQobmV3SW1nKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZml4ZWRCYXJJbWFnZS5zcmMgPSBpbWFnZS5zcmNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5maXhlZEJhci5jbGFzc0xpc3QuYWRkKCctLWZpbGxlZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuXG4gIGluaXQoKSB7XG4gICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gOTkxKSB7XG4gICAgICB0aGlzLmJpbmRPcHRpb25Ub2dnbGVEZXNrdG9wKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaW5kT3B0aW9uVG9nZ2xlTW9iaWxlKClcbiAgICAgIHRoaXMuYmluZE9wdGlvbk1vZGFsRXZlbnRzKClcbiAgICB9XG4gICAgdGhpcy5zZXRBY3RpdmVPcHRpb25zVGV4dCgpXG4gICAgdGhpcy5iaW5kT3B0aW9uQnV0dG9uQ2xpY2soKVxuICAgIHRoaXMuYmluZE9wdGlvbkJ1dHRvbkNsaWNrSW5wdXRWYWx1ZSgpXG4gICAgLy8gdGhpcy5iaW5kQ29sb3JQaWNrKClcbiAgICB0aGlzLmJpbmRUb2dnbGVSb3coKVxuICAgIHRoaXMuYmluZFRvZ2dsZUZhdigpXG4gICAgdGhpcy5zZXR1cERlc2NyaXB0aW9uKClcbiAgICB0aGlzLnNldHVwU3BsaWRlKClcbiAgICB0aGlzLnNldHVwR2FsbGVyeSgpXG4gICAgdGhpcy5vYnNlcnZlRml4ZWRCYXIoKVxuICAgIHRoaXMucG9zaXRpb25GaXhlZEJhcigpXG4gICAgdGhpcy5zZXRGaXhlZEJhck1lZGlhKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2R1Y3RQYWdlIiwiY2xhc3MgUmVzdWx0c1BhZ2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJvb3RFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluX3Jlc3VsdHMnKTtcbiAgICB0aGlzLmZpbHRlckJveEFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucGFnZS1maWx0ZXItYm94JyldO1xuICAgIHRoaXMuZmlsdGVyTW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZmlsdGVyLW1vZGFsJyk7XG4gICAgdGhpcy5jYXJkc0dyaWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FyZHMtZ3JpZCcpO1xuICAgIHRoaXMuZmlsdGVyTW9kYWxBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmZpbHRlcnMgPSB7fTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8vIE1ldGhvZHNcbiAgc2hvd0ZpbHRlck1vZGFsKCkge1xuICAgIGxvY2tTY3JvbGwoKTtcbiAgICB3aW5kb3cuZmlsdGVyTW9kYWxCYWNrZHJvcCA9IG5ldyBCYWNrZHJvcCh7XG4gICAgICBoYWxmOiB0cnVlLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHsgdGhpcy5oaWRlRmlsdGVyTW9kYWwoKTsgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5maWx0ZXJNb2RhbC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmZpbHRlck1vZGFsLnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWSgwKVwiO1xuICAgIH0sIDMpO1xuICB9XG5cbiAgaGlkZUZpbHRlck1vZGFsKCkge1xuICAgIHVubG9ja1Njcm9sbCgpO1xuICAgIGlmICh3aW5kb3cuZmlsdGVyTW9kYWxCYWNrZHJvcCkge1xuICAgICAgd2luZG93LmZpbHRlck1vZGFsQmFja2Ryb3AuaGlkZSh0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5maWx0ZXJNb2RhbC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVkoMTAwJSlcIjtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZmlsdGVyTW9kYWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMuZmlsdGVyTW9kYWwpKTtcbiAgfVxuXG4gIGRlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24gZXhlY3V0ZWRGdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zdCBsYXRlciA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICAgIGZ1bmMoLi4uYXJncylcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpXG4gICAgfTtcbiAgfVxuXG5cbiAgb2JzZXJ2ZUZpbHRlcnMoKSB7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgaW4gdGhpcy5maWx0ZXJzKSB7XG4gICAgICBpZiAodGhpcy5maWx0ZXJzLmhhc093blByb3BlcnR5KGZpbHRlcikpIHtcbiAgICAgICAgY29uc3QgeyBidG5BcnIsIGxpc3QgfSA9IHRoaXMuZmlsdGVyc1tmaWx0ZXJdO1xuXG4gICAgICAgIGNvbnN0IHJhZGlvcyA9IFsuLi5saXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXScpXTtcbiAgICAgICAgY29uc3QgY2hlY2tib3hlcyA9IFsuLi5saXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpXTtcbiAgICAgICAgY29uc3QgbGlua3MgPSBbLi4ubGlzdC5xdWVyeVNlbGVjdG9yQWxsKCdhJyldO1xuXG4gICAgICAgIGNvbnN0IGlzRmlsbGVkID0gcmFkaW9zLnNvbWUocmFkaW8gPT4gcmFkaW8uY2hlY2tlZCkgfHxcbiAgICAgICAgICBjaGVja2JveGVzLnNvbWUoY2hlY2tib3ggPT4gY2hlY2tib3guY2hlY2tlZCkgfHxcbiAgICAgICAgICBsaW5rcy5zb21lKGxpbmsgPT4gbGluay5jbGFzc0xpc3QuY29udGFpbnMoJ2lzLWFjdGl2ZScpKTtcblxuICAgICAgICBidG5BcnIuZm9yRWFjaChidG4gPT4gYnRuLmNsYXNzTGlzdC50b2dnbGUoJy0tZmlsbGVkJywgaXNGaWxsZWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBEZXNrdG9wXG4gIHNldHVwRGVza3RvcEZpbHRlcnMoKSB7XG4gICAgdGhpcy5maWx0ZXJCb3hBcnIuZm9yRWFjaCgoYm94LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgYnRuID0gYm94LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLWZpbHRlci1idG4nKTtcbiAgICAgIGNvbnN0IGRyb3AgPSBib3gucXVlcnlTZWxlY3RvcignLnBhZ2UtZmlsdGVyLWRyb3AnKTtcbiAgICAgIGNvbnN0IG9wdGlvbnNBcnIgPSBkcm9wLnF1ZXJ5U2VsZWN0b3IoJ2EnKSA/IFsuLi5kcm9wLnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKV0gOiBbLi4uZHJvcC5xdWVyeVNlbGVjdG9yQWxsKCdsYWJlbCcpXTtcblxuICAgICAgaWYgKG9wdGlvbnNBcnIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyc1tpbmRleF0gPSB7IGJ0bkFycjogW2J0bl0sIGxpc3Q6IGRyb3AgfTtcblxuICAgICAgICBvcHRpb25zQXJyLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgICBvcHRpb24uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4gdGhpcy5vYnNlcnZlRmlsdGVycygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgY29uc3QgaXNGb2N1c2VkID0gYm94LmNsYXNzTGlzdC5jb250YWlucygnLS1mb2N1c2VkJyk7XG4gICAgICAgIHRoaXMuZmlsdGVyQm94QXJyLmZvckVhY2goZWwgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZSgnLS1mb2N1c2VkJykpO1xuICAgICAgICBpZiAoIWlzRm9jdXNlZCkgYm94LmNsYXNzTGlzdC5hZGQoJy0tZm9jdXNlZCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICBpZiAoIWUudGFyZ2V0LmNsb3Nlc3QoJy5wYWdlLWZpbHRlci1ib3gnKSkge1xuICAgICAgICB0aGlzLmZpbHRlckJveEFyci5mb3JFYWNoKGJveCA9PiBib3guY2xhc3NMaXN0LnJlbW92ZSgnLS1mb2N1c2VkJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTW9iaWxlXG4gIHNldHVwTW9iaWxlRmlsdGVycygpIHtcbiAgICBjb25zdCBmaWx0ZXJMaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZpbHRlci1tb2RhbF9fZmlsdGVyLWxpc3QnKTtcbiAgICBjb25zdCBvcHRpb25zSG9sZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZpbHRlci1tb2RhbF9fb3B0aW9ucycpO1xuICAgIGxldCBmaWx0ZXJCdG5BcnIgPSBbXTtcbiAgICBsZXQgbGlzdHNBcnIgPSBbXTtcblxuICAgIHRoaXMuZmlsdGVyQm94QXJyLmZvckVhY2goKGZpbHRlciwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGJ0biA9IGZpbHRlci5xdWVyeVNlbGVjdG9yKCcucGFnZS1maWx0ZXItYnRuJyk7XG4gICAgICBjb25zdCBkcm9wID0gZmlsdGVyLnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLWZpbHRlci1kcm9wJyk7XG4gICAgICBjb25zdCBvcHRpb25zQXJyID0gZHJvcC5xdWVyeVNlbGVjdG9yKCdhJykgPyBbLi4uZHJvcC5xdWVyeVNlbGVjdG9yQWxsKCdhJyldIDogWy4uLmRyb3AucXVlcnlTZWxlY3RvckFsbCgnbGFiZWwnKV07XG5cbiAgICAgIGlmICghb3B0aW9uc0Fyci5sZW5ndGgpIHJldHVybjtcblxuICAgICAgb3B0aW9uc0Fyci5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgIG9wdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB0aGlzLm9ic2VydmVGaWx0ZXJzKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gdGhpcy5nZXRGaWx0ZXJEaXNwbGF5TmFtZShidG4sIGZpbHRlcik7XG4gICAgICBjb25zdCBmaWx0ZXJNb2RhbEJ1dHRvbiA9IHRoaXMuY3JlYXRlRmlsdGVyQnV0dG9uKGRpc3BsYXlOYW1lKTtcbiAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLmNyZWF0ZUZpbHRlckxpc3Qob3B0aW9uc0Fycik7XG5cbiAgICAgIGZpbHRlckxpc3QuYXBwZW5kQ2hpbGQoZmlsdGVyTW9kYWxCdXR0b24pO1xuICAgICAgb3B0aW9uc0hvbGRlci5hcHBlbmRDaGlsZChsaXN0KTtcblxuICAgICAgZmlsdGVyQnRuQXJyLnB1c2goZmlsdGVyTW9kYWxCdXR0b24pO1xuICAgICAgbGlzdHNBcnIucHVzaChsaXN0KTtcblxuICAgICAgdGhpcy5zZXR1cEZpbHRlck1vZGFsQnV0dG9uQmVoYXZpb3IoZmlsdGVyTW9kYWxCdXR0b24sIGxpc3QsIGZpbHRlckJ0bkFyciwgbGlzdHNBcnIpO1xuICAgICAgdGhpcy5zZXR1cEZpbHRlck9iamVjdChpbmRleCwgYnRuLCBmaWx0ZXJNb2RhbEJ1dHRvbiwgbGlzdCk7XG4gICAgICB0aGlzLmJpbmRGaWx0ZXJCdXR0b25DbGljayhidG4sIGZpbHRlck1vZGFsQnV0dG9uLCBsaXN0LCBmaWx0ZXJCdG5BcnIsIGxpc3RzQXJyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEZpbHRlckRpc3BsYXlOYW1lKGJ0biwgZmlsdGVyKSB7XG4gICAgY29uc3QgZmlsdGVySWQgPSBmaWx0ZXIuaWQgPyBmaWx0ZXIuaWQgOiBudWxsO1xuICAgIGNvbnN0IGJ0blNwYW4gPSBidG4ucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgIGNvbnN0IHJhd05hbWUgPSAoZmlsdGVySWQgJiYgYnRuU3BhbikgPyBidG5TcGFuLmlubmVyVGV4dC50b0xvd2VyQ2FzZSgpIDogJ1NvcnQgQnknO1xuICAgIHJldHVybiAocmF3TmFtZS5pbmNsdWRlcygnc3ViY2F0ZWdvcmllcycpIHx8IHJhd05hbWUuaW5jbHVkZXMoJ3N1YmNhdGVnb3J5JykpID8gJ1N1YmNhdGVnb3JpZXMnIDpcbiAgICAgIChyYXdOYW1lLmluY2x1ZGVzKCdwcmljZScpIHx8IHJhd05hbWUuaW5jbHVkZXMoJ3ByaWNlIHJhbmdlJykpID8gJ1ByaWNlJyA6IHJhd05hbWU7XG4gIH1cblxuICBjcmVhdGVGaWx0ZXJCdXR0b24oZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbSgnYnV0dG9uJywge1xuICAgICAgY2xhc3NOYW1lOiAnZmlsdGVyLW1vZGFsX19maWx0ZXItYnRuJyxcbiAgICAgIGlubmVySFRNTDogYDxzcGFuPiR7ZGlzcGxheU5hbWV9PC9zcGFuPmBcbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZUZpbHRlckxpc3Qob3B0aW9uc0Fycikge1xuICAgIGNvbnN0IGxpc3QgPSBjcmVhdGVFbGVtKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICdmaWx0ZXItbW9kYWxfX29wdGlvbnMtbGlzdCcsXG4gICAgICBzdHlsZTogeyBkaXNwbGF5OiAnbm9uZScgfVxuICAgIH0pO1xuICAgIG9wdGlvbnNBcnIuZm9yRWFjaChlbCA9PiBsaXN0LmFwcGVuZENoaWxkKGVsKSk7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICBzZXR1cEZpbHRlck1vZGFsQnV0dG9uQmVoYXZpb3IoZmlsdGVyTW9kYWxCdXR0b24sIGxpc3QsIGZpbHRlckJ0bkFyciwgbGlzdHNBcnIpIHtcbiAgICBmaWx0ZXJNb2RhbEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGZpbHRlckJ0bkFyci5mb3JFYWNoKGJ0biA9PiBidG4uY2xhc3NMaXN0LnRvZ2dsZSgnLS1hY3RpdmUnLCBidG4gPT09IGZpbHRlck1vZGFsQnV0dG9uKSk7XG4gICAgICBsaXN0c0Fyci5mb3JFYWNoKGwgPT4gbC5zdHlsZS5kaXNwbGF5ID0gKGwgPT09IGxpc3QpID8gJ2Jsb2NrJyA6ICdub25lJyk7XG4gICAgfSk7XG4gIH1cblxuICBzZXR1cEZpbHRlck9iamVjdChpbmRleCwgYnRuLCBmaWx0ZXJNb2RhbEJ1dHRvbiwgbGlzdCkge1xuICAgIHRoaXMuZmlsdGVyc1tpbmRleF0gPSB7IGJ0bkFycjogW2J0biwgZmlsdGVyTW9kYWxCdXR0b25dLCBsaXN0OiBsaXN0IH07XG4gIH1cblxuICBiaW5kRmlsdGVyQnV0dG9uQ2xpY2soYnRuLCBmaWx0ZXJNb2RhbEJ1dHRvbiwgbGlzdCwgZmlsdGVyQnRuQXJyLCBsaXN0c0Fycikge1xuICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMuc2hvd0ZpbHRlck1vZGFsKCk7XG4gICAgICBmaWx0ZXJCdG5BcnIuZm9yRWFjaChidG4gPT4gYnRuLmNsYXNzTGlzdC5yZW1vdmUoJy0tYWN0aXZlJykpO1xuICAgICAgbGlzdHNBcnIuZm9yRWFjaChsID0+IGwuc3R5bGUuZGlzcGxheSA9ICdub25lJyk7XG4gICAgICBmaWx0ZXJNb2RhbEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCctLWFjdGl2ZScpO1xuICAgICAgbGlzdC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9KTtcbiAgfVxuXG4gIHVud3JhcEZpbHRlcnMoKSB7XG4gICAgY29uc3QgZ3JvdXBzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wYWdlLWZpbHRlcnNfX2dyb3VwJyldO1xuICAgIGdyb3Vwcy5mb3JFYWNoKGdyb3VwID0+IHtcbiAgICAgIHdoaWxlIChncm91cC5maXJzdENoaWxkKSB7XG4gICAgICAgIGdyb3VwLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGdyb3VwLmZpcnN0Q2hpbGQsIGdyb3VwKTtcbiAgICAgIH1cbiAgICAgIGdyb3VwLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgYmluZFRvdWNoRXZlbnRzKCkge1xuICAgIGxldCBzdGFydFkgPSAwO1xuICAgIGxldCBjdXJyZW50WSA9IDA7XG4gICAgbGV0IGlzRHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZmlsdGVyTW9kYWw7XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMuZmlsdGVyTW9kYWwucXVlcnlTZWxlY3RvcignLmZpbHRlci1tb2RhbF9faGVhZGVyJyk7XG5cbiAgICBoYW5kbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgc3RhcnRZID0gZS50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICBpc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuICAgIH0pO1xuXG4gICAgaGFuZGxlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAoZSkgPT4ge1xuICAgICAgaWYgKCFpc0RyYWdnaW5nKSByZXR1cm47XG4gICAgICBjdXJyZW50WSA9IGUudG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgbGV0IGRpZmZZID0gY3VycmVudFkgLSBzdGFydFk7XG5cbiAgICAgIGlmIChkaWZmWSA+IDApIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKCR7ZGlmZll9cHgpYDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGhhbmRsZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAoKSA9PiB7XG4gICAgICBpZiAoIWlzRHJhZ2dpbmcpIHJldHVybjtcbiAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgbGV0IGRpZmZZID0gY3VycmVudFkgLSBzdGFydFk7XG4gICAgICBsZXQgaGlkZU9mZnNldCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgKiAwLjU7XG4gICAgICBjb250YWluZXIuc3R5bGUudHJhbnNpdGlvbiA9ICdhbGwgLjM1cyBlYXNlJztcblxuICAgICAgaWYgKGRpZmZZID4gaGlkZU9mZnNldCkge1xuICAgICAgICB0aGlzLmhpZGVGaWx0ZXJNb2RhbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKDAlKWA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBiaW5kQ2xpY2tFdmVudHMoKSB7XG4gICAgY29uc3QgY2xvc2VBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZXZ0PVwiY2xvc2VGaWx0ZXJNb2RhbFwiXScpXTtcbiAgICBjbG9zZUFyci5mb3JFYWNoKGNsb3NlID0+IHtcbiAgICAgIGNsb3NlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5oaWRlRmlsdGVyTW9kYWwoKSk7XG4gICAgfSk7XG4gIH1cblxuICBmb3JtYXRHb2xkQ2hhaW5zU3ViaGVhZGluZygpIHtcbiAgICBjb25zdCBzdWJoZWFkaW5nID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJlc3VsdHNfX3N1YmhlYWRpbmcnKVxuICAgIGlmIChzdWJoZWFkaW5nKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gJ1dlbGNvbWUgdG8gb3VyIGNvbGxlY3Rpb24gb2YgZmluZSAxNGsgc29saWQgZ29sZCBjaGFpbnMsIHdoZXJlIGx1eHVyeSBtZWV0cyBhZmZvcmRhYmlsaXR5J1xuICAgICAgaWYgKHN1YmhlYWRpbmcuaW5uZXJIVE1MLmluY2x1ZGVzKHRleHQpKSB7XG4gICAgICAgIGNvbnN0IHNlbnRlbmNlcyA9IHN1YmhlYWRpbmcuaW5uZXJIVE1MLnNwbGl0KCcuJykuZmlsdGVyKHNlbnRlbmNlID0+IHNlbnRlbmNlLnRyaW0oKSAhPT0gJycpXG4gICAgICAgIGlmIChzZW50ZW5jZXNbMF0gPT09IHRleHQpIHtcbiAgICAgICAgICBzdWJoZWFkaW5nLmlubmVySFRNTCA9IGBcbiAgICAgICAgICA8c3Ryb25nPiR7dGV4dH0uPC9zdHJvbmc+XG4gICAgICAgICAgJHtzZW50ZW5jZXMuc2xpY2UoMSkuam9pbignLiAnKX1cbiAgICAgICAgICBgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRTdGlja3lCYXIoKSB7XG4gICAgY29uc3QgYmFyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2UtZmlsdGVycycpO1xuICAgIGlmICghYmFyKSByZXR1cm47XG5cbiAgICBsZXQgdG9wT2Zmc2V0ID0gMDtcblxuICAgIGNvbnN0IHRvcEJhbm5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50b3AtYmFubmVyJyk7XG4gICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhlYWRlcicpO1xuXG4gICAgaWYgKHRvcEJhbm5lcikge1xuICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRvcEJhbm5lcikucG9zaXRpb24gPT09ICdzdGlja3knKSB7XG4gICAgICAgIGNvbnN0IGJhbm5lckhlaWdodCA9IHRvcEJhbm5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmIChiYW5uZXJIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgdG9wT2Zmc2V0ICs9IGJhbm5lckhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIHRvcE9mZnNldCArPSBoZWFkZXIub2Zmc2V0SGVpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3BPZmZzZXQgPiAwKSB7XG4gICAgICBiYXIuc3R5bGUucG9zaXRpb24gPSAnc3RpY2t5JztcbiAgICAgIGJhci5zdHlsZS50b3AgPSBgJHt0b3BPZmZzZXR9cHhgO1xuICAgIH1cbiAgfVxuXG4gIGFkanVzdFN0aWNreUJhck9uUmVzaXplKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmRlYm91bmNlKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RpY2t5QmFyKCk7XG4gICAgfSwgMTAwKSlcbiAgfVxuXG4gIGZvcm1hdEZpbHRlclRpdGxlcygpIHtcbiAgICBjb25zdCBhcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnBhZ2UtZmlsdGVyLWJ0bicpXVxuICAgIGZvciAoY29uc3QgYnRuIG9mIGFycikge1xuICAgICAgY29uc3Qgc3BhbiA9IGJ0bi5xdWVyeVNlbGVjdG9yKCdzcGFuOmZpcnN0LWNoaWxkJylcbiAgICAgIGlmIChzcGFuKSB7XG4gICAgICAgIGNvbnN0IHJhd05hbWUgPSBzcGFuLmlubmVyVGV4dC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGNvbnN0IG5hbWUgPSAocmF3TmFtZS5pbmNsdWRlcygnc3ViY2F0ZWdvcmllcycpIHx8IHJhd05hbWUuaW5jbHVkZXMoJ3N1YmNhdGVnb3J5JykpID8gJ1N1YmNhdGVnb3JpZXMnIDpcbiAgICAgICAgICAocmF3TmFtZS5pbmNsdWRlcygncHJpY2UnKSB8fCByYXdOYW1lLmluY2x1ZGVzKCdwcmljZSByYW5nZScpKSA/ICdQcmljZScgOiByYXdOYW1lO1xuXG4gICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgIT09IHJhd05hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHNwYW4uaW5uZXJUZXh0ID0gbmFtZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVmlld1xuICBzd2l0Y2hWaWV3KG1vZGUpIHtcbiAgICBpZiAoIXRoaXMuY2FyZHNHcmlkKSByZXR1cm5cblxuICAgIGNvbnN0IGlzTGVzcyA9IG1vZGUgPT09ICdsZXNzJ1xuICAgIHRoaXMuY2FyZHNHcmlkLmNsYXNzTGlzdC5hZGQoJy0taGlkZGVuJylcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jYXJkc0dyaWQuY2xhc3NMaXN0LnRvZ2dsZSgnLS1sZXNzJywgaXNMZXNzKVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2FyZHNHcmlkLmNsYXNzTGlzdC5yZW1vdmUoJy0taGlkZGVuJylcbiAgICAgIH0sIDEwMClcbiAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmNhcmRzR3JpZCkpXG4gIH1cblxuICBiaW5kVmlld1N3aXRjaCgpIHtcbiAgICBjb25zdCBidXR0b25zID0ge1xuICAgICAgbW9yZTogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtcmVzdWx0cy1ldnQ9XCJ2aWV3TW9yZVwiXScpLFxuICAgICAgbGVzczogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtcmVzdWx0cy1ldnQ9XCJ2aWV3TGVzc1wiXScpXG4gICAgfTtcblxuICAgIGNvbnN0IHRvZ2dsZVZpZXcgPSAoYWN0aXZlQnRuLCBpbmFjdGl2ZUJ0biwgbW9kZSkgPT4ge1xuICAgICAgaWYgKCFhY3RpdmVCdG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdpcy1hY3RpdmUnKSkge1xuICAgICAgICBhY3RpdmVCdG4uY2xhc3NMaXN0LmFkZCgnaXMtYWN0aXZlJyk7XG4gICAgICAgIGluYWN0aXZlQnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWFjdGl2ZScpO1xuICAgICAgICB0aGlzLnN3aXRjaFZpZXcobW9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChidXR0b25zLm1vcmUgJiYgYnV0dG9ucy5sZXNzKSB7XG4gICAgICBidXR0b25zLm1vcmUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0b2dnbGVWaWV3KGJ1dHRvbnMubW9yZSwgYnV0dG9ucy5sZXNzLCAnbW9yZScpKTtcbiAgICAgIGJ1dHRvbnMubGVzcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRvZ2dsZVZpZXcoYnV0dG9ucy5sZXNzLCBidXR0b25zLm1vcmUsICdsZXNzJykpO1xuICAgIH1cbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gOTkxKSB7XG4gICAgICB0aGlzLnNldHVwRGVza3RvcEZpbHRlcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXR1cE1vYmlsZUZpbHRlcnMoKTtcbiAgICAgIHRoaXMudW53cmFwRmlsdGVycygpO1xuICAgICAgdGhpcy5iaW5kVG91Y2hFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZENsaWNrRXZlbnRzKCk7XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZUZpbHRlcnMoKTtcbiAgICB0aGlzLmZvcm1hdEdvbGRDaGFpbnNTdWJoZWFkaW5nKClcbiAgICB0aGlzLnNldFN0aWNreUJhcigpXG4gICAgdGhpcy5hZGp1c3RTdGlja3lCYXJPblJlc2l6ZSgpXG4gICAgdGhpcy5mb3JtYXRGaWx0ZXJUaXRsZXMoKVxuICAgIHRoaXMuYmluZFZpZXdTd2l0Y2goKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzdWx0c1BhZ2U7IiwiY29uc3Qgc2VsbFBhZ2UgPSB7XG4gIGZhcUl0ZW1zOiBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNlbGwtZmFxLWl0ZW0nKV0sXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5mYXFJdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYXR0YWNoRmFxKClcbiAgICAgICQoJy5zZWxsLWZhcS1pdGVtX19tYWluJykuZXEoMCkudHJpZ2dlcignY2xpY2snKVxuICAgIH1cbiAgfSxcbiAgYXR0YWNoRmFxOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mYXFJdGVtcy5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcbiAgICAgICQoZWwpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IG1haW4gPSAkKHRoaXMpLmZpbmQoJy5zZWxsLWZhcS1pdGVtX19tYWluJyksXG4gICAgICAgICAgcCA9ICQodGhpcykuZmluZCgncCcpLCBzdmcgPSAkKHRoaXMpLmZpbmQoJ3N2ZycpXG4gICAgICAgIGlmIChtYWluLmhlaWdodCgpID09IDApIHtcbiAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKElTX0FDVElWRSlcbiAgICAgICAgICBtYWluLmNzcyh7IGhlaWdodDogYCR7cFswXS5zY3JvbGxIZWlnaHR9cHhgIH0pXG4gICAgICAgICAgc3ZnLmNzcyh7IHRyYW5zZm9ybTogJ3JvdGF0ZSgxODBkZWcpJyB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoSVNfQUNUSVZFKVxuICAgICAgICAgIG1haW4uY3NzKHsgaGVpZ2h0OiBgMHB4YCB9KVxuICAgICAgICAgIHN2Zy5jc3MoeyB0cmFuc2Zvcm06ICdyb3RhdGUoMGRlZyknIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbGxQYWdlIiwiY2xhc3MgU2VsbFdhdGNoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5mb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZm9ybSNzZWxsX215X3dhdGNoJylcbiAgICBpZiAoIXRoaXMuZm9ybSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuc2VjdGlvbnNBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtYXNrLXNlY3Rpb25dJyldXG4gICAgdGhpcy5wcm9ncmVzc0JhciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hc2stcGFnZV9fcHJvZ3Jlc3MtYmFyJylcbiAgICB0aGlzLmN1cnJlbnRTdGVwRWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXN0ZXAtY3VycmVudF0nKVxuICAgIHRoaXMuY291bnRTdGVwRWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXN0ZXAtY291bnRdJylcbiAgICB0aGlzLmNvbnRlbnRDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXNrLXBhZ2VfX3F1aXotY29udGVudCcpXG4gICAgdGhpcy5hZGp1c3RDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXNrLXBhZ2VfX3F1aXotYWRqdXN0JylcblxuICAgIHRoaXMuZm9jdXNlZEVsID0gdW5kZWZpbmVkXG4gICAgdGhpcy53YXRjaEJyYW5kID0ge1xuICAgICAgbmFtZTogdW5kZWZpbmVkXG4gICAgfVxuICAgIHRoaXMudXBsb2FkSW5wdXQgPSB0aGlzLmZvcm0ucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cImZpbGVcIl0nKVxuICAgIHRoaXMucmVnRXhwID0ge1xuICAgICAgcm9sZXg6IC9cXGJyb2xleFxcYi9pLFxuICAgICAgYXVkZW1hcnM6IC9cXGJhdWRlbWFyc1xcYi9pLFxuICAgICAgcmljaGFyZDogL1xcYnJpY2hhcmRcXGIvaSxcbiAgICAgIHBhdGVrOiAvXFxicGF0ZWtcXGIvaSxcbiAgICAgIGNhcnRpZXI6IC9cXGJjYXJ0aWVyXFxiL2ksXG4gICAgICBicmVpdGxpbmc6IC9cXGJicmVpdGxpbmdcXGIvaVxuICAgIH1cblxuICAgIHRoaXMubG9ja2VkID0gZmFsc2VcbiAgICB0aGlzLnN0ZXBzID0gdGhpcy5zZWN0aW9uc0Fyci5sZW5ndGhcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gMVxuICAgIHRoaXMuYWN0aXZlU2VjdGlvbiA9IHRoaXMuc2VjdGlvbnNBcnJbMF1cbiAgICB0aGlzLmVuZFJlYWNoZWQgPSBmYWxzZVxuICAgIHRoaXMuYXRUaGVTdGFydCA9IHRydWVcbiAgICB0aGlzLmluaXQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHRlcnNcbiAgICovXG4gIGdldCBnZXRBY3RpdmVTZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZVNlY3Rpb25cbiAgfVxuICBnZXQgZ2V0Q3VycmVudFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN0ZXBcbiAgfVxuICBnZXQgZ2V0Rm9jdXNlZEVsKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzZWRFbFxuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZHNcbiAgICovXG4gIHRvZ2dsZVNlY3Rpb25TdGF0dXMoc2VjdGlvbiwgY29uZGl0aW9uKSB7XG4gICAgaWYgKGNvbmRpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHNlY3Rpb24uY2xhc3NMaXN0LnJlbW92ZShfX1ZBTElEKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWN0aW9uLmNsYXNzTGlzdC5hZGQoX19WQUxJRClcbiAgICB9XG4gICAgY29uc3QgYnRuID0gWy4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2VsbC1ldnQ9XCJuZXh0XCJdJyldXG4gICAgYnRuLmZvckVhY2goYnRuID0+IGJ0bi5kaXNhYmxlZCA9ICFjb25kaXRpb24pXG4gIH1cbiAgdmFsaWRhdGVTZWN0aW9uKHNlY3Rpb24pIHtcbiAgICBzZWN0aW9uID0gdGhpcy5nZXRBY3RpdmVTZWN0aW9uXG5cbiAgICBjb25zdFxuICAgICAgcmVxdWlyZWRBcnIgPSBbLi4uc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdbcmVxdWlyZWRdOm5vdChbZGlzYWJsZWRdKScpXSxcbiAgICAgIHJhZGlvQXJyID0gWy4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdOm5vdChbZGlzYWJsZWRdKScpXSxcbiAgICAgIGNoZWNrYm94QXJyID0gWy4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOm5vdChbZGlzYWJsZWRdKScpXSxcbiAgICAgIGlucHV0QXJyID0gWy4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6bm90KFt0eXBlPVwiY2hlY2tib3hcIl0pOm5vdChbdHlwZT1cInJhZGlvXCJdKScpXSxcbiAgICAgIHNlbGVjdEFyciA9IFsuLi5zZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdFtyZXF1aXJlZF0nKV0sXG4gICAgICBwaG9uZUFyciA9IFsuLi5zZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXZhbGlkYXRlPVwicGhvbmVcIl0nKV0sXG4gICAgICBmaWxlQXJyID0gWy4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cImZpbGVcIl0nKV1cblxuICAgIGNvbnN0IHJhZGlvQXJyQnlOYW1lID0gQXJyYXkuZnJvbShcbiAgICAgIG5ldyBTZXQocmFkaW9BcnIubWFwKHJhZGlvID0+IHJhZGlvLm5hbWUpKSxcbiAgICAgIG5hbWUgPT4gcmFkaW9BcnIuZmlsdGVyKHJhZGlvID0+IHJhZGlvLm5hbWUgPT09IG5hbWUpXG4gICAgKVxuXG4gICAgaWYgKHJlcXVpcmVkQXJyLnNvbWUoaW5wdXQgPT4gIWlucHV0LnZhbHVlKSkge1xuICAgICAgdGhpcy50b2dnbGVTZWN0aW9uU3RhdHVzKHNlY3Rpb24sIGZhbHNlKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCByYWRpb0dyb3VwIG9mIHJhZGlvQXJyQnlOYW1lKSB7XG4gICAgICBpZiAocmFkaW9Hcm91cC5ldmVyeShyYWRpbyA9PiAhcmFkaW8uY2hlY2tlZCkpIHtcbiAgICAgICAgdGhpcy50b2dnbGVTZWN0aW9uU3RhdHVzKHNlY3Rpb24sIGZhbHNlKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hlY2tib3hBcnIubGVuZ3RoICYmIGNoZWNrYm94QXJyLmV2ZXJ5KGNoZWNrYm94ID0+ICFjaGVja2JveC5jaGVja2VkKSkge1xuICAgICAgdGhpcy50b2dnbGVTZWN0aW9uU3RhdHVzKHNlY3Rpb24sIGZhbHNlKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHBob25lQXJyLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBwaG9uZUFycikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlXG4gICAgICAgIGNvbnN0IHZhbHVlRGlnaXRzID0gdmFsdWUucmVwbGFjZSgvXFxEL2csICcnKS5sZW5ndGhcbiAgICAgICAgY29uc3QgcmVnZXggPSAvXlxcK1xcZHsxfVxcc1xcKFxcZHszfVxcKVxcc1xcZHszfVxcLVxcZHs0fSQvXG4gICAgICAgIGlmICghcmVnZXgudGVzdCh2YWx1ZSkgJiYgdmFsdWVEaWdpdHMgPCAxMSkge1xuICAgICAgICAgIHRoaXMudG9nZ2xlU2VjdGlvblN0YXR1cyhzZWN0aW9uLCBmYWxzZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgZmlsZUlucHV0IG9mIGZpbGVBcnIpIHtcbiAgICAgIGNvbnN0IGZpbGVzID0gZmlsZUlucHV0LmZpbGVzXG4gICAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVNlY3Rpb25TdGF0dXMoc2VjdGlvbiwgZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudG9nZ2xlU2VjdGlvblN0YXR1cyhzZWN0aW9uLCB0cnVlKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgYXJyYW5nZU1vZGVscyhzdHJpbmcpIHtcbiAgICBjb25zdFxuICAgICAgaW5wdXRBcnIgPSBbLi4udGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwibW9kZWxcIl0nKV0sXG4gICAgICBncm91cElucHV0QXJyID0gaW5wdXRBcnIuZmlsdGVyKGlucHV0ID0+IGlucHV0LmRhdGFzZXQuZ3JvdXApLFxuICAgICAgZmlsdGVyZWRBcnIgPSBncm91cElucHV0QXJyLmZpbHRlcihpbnB1dCA9PiB7IHJldHVybiBzdHJpbmcudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhpbnB1dC5kYXRhc2V0Lmdyb3VwKSB9KSxcbiAgICAgIG1vZGVsR3JpZCA9IHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zZWxsLWdyaWQ9XCJtb2RlbFwiXScpLFxuICAgICAgbW9kZWxJbnB1dCA9IHRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yKCdpbnB1dCN3YXRjaF9tb2RlbCcpLFxuICAgICAgbW9kZWxJbnB1dFBhcmVudCA9IG1vZGVsSW5wdXQuY2xvc2VzdCgnLnN1cnZleS1ib3hfX25hbWVkLWdyaWQnKVxuXG4gICAgaW5wdXRBcnIuZm9yRWFjaChpbnB1dCA9PiBpbnB1dC5jaGVja2VkID0gZmFsc2UpXG4gICAgLy8gaW5wdXRBcnIuZm9yRWFjaChpbnB1dCA9PiBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpKVxuICAgIG1vZGVsSW5wdXQudmFsdWUgPSAnJ1xuICAgIG1vZGVsSW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JykpXG5cbiAgICBpZiAoIWZpbHRlcmVkQXJyLmxlbmd0aCkge1xuICAgICAgbW9kZWxHcmlkLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgIG1vZGVsSW5wdXRQYXJlbnQuc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xuICAgICAgbW9kZWxJbnB1dC5kaXNhYmxlZCA9IGZhbHNlXG4gICAgICBpbnB1dEFyci5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlXG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSBmYWxzZVxuICAgICAgICAvLyBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbEdyaWQuc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xuICAgICAgbW9kZWxJbnB1dFBhcmVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICBtb2RlbElucHV0LmRpc2FibGVkID0gdHJ1ZVxuICAgICAgaW5wdXRBcnIuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gaW5wdXQuY2xvc2VzdCgnbGFiZWwnKVxuICAgICAgICBpbnB1dC5kaXNhYmxlZCA9IGZhbHNlXG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSBmYWxzZVxuICAgICAgICBpZiAoIWZpbHRlcmVkQXJyLmluY2x1ZGVzKGlucHV0KSAmJiBpbnB1dC52YWx1ZSAhPT0gJ090aGVyJykge1xuICAgICAgICAgIGlmIChpbnB1dC52YWx1ZSkge1xuICAgICAgICAgICAgbGFiZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICB9XG4gICAgICAgIC8vIGlucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnKSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxzXG4gICAqL1xuICBvYnNlcnZlU3RlcHNFbGVtZW50cygpIHtcbiAgICB0aGlzLmN1cnJlbnRTdGVwRWxlbS5pbm5lckhUTUwgPSB0aGlzLmN1cnJlbnRTdGVwXG4gIH1cbiAgb2JzZXJ2ZUJhckVsZW1lbnRzKCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5wcm9ncmVzc0Jhci5xdWVyeVNlbGVjdG9yQWxsKCdzcGFuJylcbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4IDwgdGhpcy5jdXJyZW50U3RlcCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoX19BQ1RJVkUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBzY3JvbGxUb0Zvcm0oKSB7XG4gICAgaWYgKHRoaXMuZm9ybSkge1xuICAgICAgY29uc3QgaGVhZGVySGVpZ2h0ID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZGVyJykpLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpKVxuICAgICAgY29uc3QgYm91bmRUb3AgPSB0aGlzLmZvcm0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICBpZiAoKGJvdW5kVG9wIC0gaGVhZGVySGVpZ2h0KSA8IC0zMCkge1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9ICh3aW5kb3cuc2Nyb2xsWSArIHRoaXMuZm9ybS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIC0gKGhlYWRlckhlaWdodCArIDcwKVxuICAgICAgICB6ZW5zY3JvbGwudG9ZKGRpc3RhbmNlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNwYXRjaEZvY3VzRXZlbnQoZWxlbSkge1xuICAgIGlmIChlbGVtKSB7XG4gICAgICBjb25zdCB0YWcgPSBlbGVtLnRhZ05hbWVcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgJ0lOUFVUJyB8fCAnVEVYVEFSRUEnOlxuICAgICAgICAgIGNvbnN0IHR5cGUgPSBlbGVtLnR5cGVcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JhZGlvJyB8fCB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICBlbGVtLmNsaWNrKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgICBlbGVtLmNsaWNrKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW0uZm9jdXMoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU0VMRUNUJzpcbiAgICAgICAgICBlbGVtLmZvY3VzKClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBlbGVtLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdmb2N1cycpKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudHNcbiAgICovXG4gIHNsaWRlKHNlY3Rpb24sIGFjdGl2ZVNlY3Rpb24sIG51bWJlcikge1xuICAgIGNvbnN0IHNlY3Rpb25JbmRleCA9IHRoaXMuc2VjdGlvbnNBcnIuaW5kZXhPZihzZWN0aW9uKVxuICAgIGNvbnN0IGFjdGl2ZVNlY3Rpb25JbmRleCA9IHRoaXMuc2VjdGlvbnNBcnIuaW5kZXhPZihhY3RpdmVTZWN0aW9uKVxuXG4gICAgbGV0IGZyb21UcmFuc2xhdGUgPSAndHJhbnNsYXRlWSgyNHB4KSdcbiAgICBsZXQgdG9UcmFuc2xhdGUgPSAndHJhbnNsYXRlWSgtMjRweCknXG5cbiAgICBpZiAoYWN0aXZlU2VjdGlvbkluZGV4ID4gc2VjdGlvbkluZGV4KSB7XG4gICAgICBmcm9tVHJhbnNsYXRlID0gJ3RyYW5zbGF0ZVkoLTI0cHgpJ1xuICAgICAgdG9UcmFuc2xhdGUgPSAndHJhbnNsYXRlWSgyNHB4KSdcblxuICAgICAgY29uc3QgaW5wdXRzID0gWy4uLmFjdGl2ZVNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKV1cbiAgICB9XG5cbiAgICB0aGlzLmxvY2tlZCA9IHRydWVcbiAgICBhY3RpdmVTZWN0aW9uLnN0eWxlLm9wYWNpdHkgPSAwXG4gICAgYWN0aXZlU2VjdGlvbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnXG4gICAgYWN0aXZlU2VjdGlvbi5zdHlsZS50cmFuc2Zvcm0gPSB0b1RyYW5zbGF0ZVxuICAgIHNlY3Rpb24uc3R5bGUub3BhY2l0eSA9IDBcbiAgICBzZWN0aW9uLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSdcbiAgICBzZWN0aW9uLnN0eWxlLnRyYW5zZm9ybSA9IGZyb21UcmFuc2xhdGVcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGFjdGl2ZVNlY3Rpb24uc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgYWN0aXZlU2VjdGlvbi5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgICAgc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgICBzZWN0aW9uLmNsYXNzTGlzdC5hZGQoX19BQ1RJVkUpXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2VjdGlvbi5zdHlsZS5vcGFjaXR5ID0gMVxuICAgICAgICBzZWN0aW9uLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKDBweCknXG4gICAgICAgIHNlY3Rpb24uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJ1xuXG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2VcbiAgICAgICAgdGhpcy5hY3RpdmVTZWN0aW9uID0gc2VjdGlvblxuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gbnVtYmVyXG4gICAgICAgIHRoaXMub2JzZXJ2ZVN0ZXBzRWxlbWVudHMoKVxuICAgICAgICB0aGlzLm9ic2VydmVCYXJFbGVtZW50cygpXG5cbiAgICAgICAgaWYgKHNlY3Rpb24gPT09IHRoaXMuc2VjdGlvbnNBcnJbdGhpcy5zZWN0aW9uc0Fyci5sZW5ndGggLSAxXSkge1xuICAgICAgICAgIHRoaXMuZm9ybS5zdWJtaXQoKVxuICAgICAgICB9XG4gICAgICB9LCAzMClcbiAgICB9LCBnZXRUcmFuc2l0aW9uVGltZShhY3RpdmVTZWN0aW9uKSlcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgY29uc3QgY29uZmV0dGkgPSBuZXcgUGFnZUNvbmZldHRpKClcbiAgICBjb25mZXR0aS5wdXNoKClcbiAgfVxuICBnbyhudW1iZXIpIHtcbiAgICBpZiAoIXRoaXMubG9ja2VkKSB7XG4gICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5zZWN0aW9uc0FycltudW1iZXIgLSAxXVxuICAgICAgY29uc3QgYWN0aXZlU2VjdGlvbiA9IHRoaXMuZ2V0QWN0aXZlU2VjdGlvblxuXG4gICAgICBpZiAoIXNlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBudW1iZXIgPCAxID8gJ1NlY3Rpb24gbnVtYmVyIGNhbm5vdCBiZSBsZXNzIHRoYW4gMScgOiAnU2VjdGlvbiBudW1iZXIgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAnICsgdGhpcy5zZWN0aW9uc0Fyci5sZW5ndGhcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKVxuICAgICAgfVxuICAgICAgaWYgKCFhY3RpdmVTZWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIHNlY3Rpb24nKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VjdGlvbiAhPT0gYWN0aXZlU2VjdGlvbikge1xuICAgICAgICB0aGlzLnNsaWRlKHNlY3Rpb24sIGFjdGl2ZVNlY3Rpb24sIG51bWJlcilcbiAgICAgICAgdGhpcy5zY3JvbGxUb0Zvcm0oKVxuICAgICAgICB0aGlzLmZvY3VzZWRFbCA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEJpbmQgRXZlbnRzXG4gICAqL1xuICBiaW5kVG9nZ2xlU3RlcHNDb250cm9scygpIHtcbiAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgdGhpcy5zZWN0aW9uc0Fycikge1xuICAgICAgY29uc3QgaW5wdXRzID0gWy4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsIHNlbGVjdCcpXVxuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgIGNvbnN0IGlzQ2hlY2tib3hPclJhZGlvID0gaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBpbnB1dC50eXBlID09PSAncmFkaW8nIHx8IGlucHV0LnR5cGUgPT09ICdmaWxlJ1xuICAgICAgICBpZiAoaXNDaGVja2JveE9yUmFkaW8pIHtcbiAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVNlY3Rpb24oc2VjdGlvbilcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTZWN0aW9uKHNlY3Rpb24pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZER1YWxTZWxlY3QoKSB7XG4gICAgY29uc3QgZHVhbEFyciA9IFsuLi50aGlzLmZvcm0ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbZGF0YS1kdWFsXScpXVxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgZHVhbEFycikge1xuICAgICAgY29uc3RcbiAgICAgICAgbmFtZSA9IGlucHV0Lm5hbWUsXG4gICAgICAgIGR1YWxOYW1lID0gaW5wdXQuZGF0YXNldC5kdWFsLFxuICAgICAgICBuYW1lSW5wdXRBcnIgPSBbLi4udGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoYGlucHV0W25hbWU9XCIke25hbWV9XCJdYCldLFxuICAgICAgICBob2xkZXIgPSB0aGlzLmZvcm0ucXVlcnlTZWxlY3RvcihgZGl2W2RhdGEtZHVhbD1cIiR7ZHVhbE5hbWV9XCJdYClcblxuICAgICAgaWYgKGhvbGRlcikge1xuICAgICAgICBjb25zdCBzZWxlY3QgPSBob2xkZXIucXVlcnlTZWxlY3Rvcignc2VsZWN0LCBpbnB1dCcpXG4gICAgICAgIGlmIChzZWxlY3QpIHtcbiAgICAgICAgICBuYW1lSW5wdXRBcnIuZm9yRWFjaCgobmFtZUlucHV0KSA9PiB7XG4gICAgICAgICAgICBuYW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdC5kaXNhYmxlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3QuZGlzYWJsZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJpbmRCcmFuZFNlbGVjdCgpIHtcbiAgICBjb25zdCBicmFuZFNlbGVjdEFyciA9IFsuLi50aGlzLmZvcm0ucXVlcnlTZWxlY3RvckFsbCgnKltuYW1lPVwiYnJhbmRcIl0nKV1cbiAgICBjb25zdCBlbHNUb05hbWUgPSBbLi4udGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNlbGwtYnJhbmRdJyldXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBicmFuZFNlbGVjdEFycikge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgaWYgKGlucHV0LmRpc2FibGVkKSByZXR1cm5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZVxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSAhPT0gJ290aGVyJykge1xuICAgICAgICAgIHRoaXMud2F0Y2hCcmFuZC5uYW1lID0gdmFsdWVcbiAgICAgICAgICBlbHNUb05hbWUuZm9yRWFjaChlbCA9PiBlbC5pbm5lckhUTUwgPSB0aGlzLndhdGNoQnJhbmQubmFtZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndhdGNoQnJhbmQubmFtZSA9IHVuZGVmaW5lZFxuICAgICAgICAgIGVsc1RvTmFtZS5mb3JFYWNoKGVsID0+IGVsLmlubmVySFRNTCA9ICd5b3VyIGJyYW5kJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldHVwIG1vZGVsc1xuICAgICAgICB0aGlzLmFycmFuZ2VNb2RlbHModmFsdWUpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBiaW5kUGhvbmVJbnB1dCgpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBbLi4udGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W2RhdGEtdmFsaWRhdGU9XCJwaG9uZVwiXScpXVxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBsZXQga2V5Q29kZTtcbiAgICAgIGZ1bmN0aW9uIG1hc2soZXZlbnQpIHtcbiAgICAgICAgZXZlbnQua2V5Q29kZSAmJiAoa2V5Q29kZSA9IGV2ZW50LmtleUNvZGUpO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgaWYgKHBvcyA8IDMpIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgbGV0IG1hdHJpeCA9IFwiKzEgKF9fXykgX19fLV9fX19cIixcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBkZWYgPSBtYXRyaXgucmVwbGFjZSgvXFxEL2csIFwiXCIpLFxuICAgICAgICAgIHZhbCA9IHRoaXMudmFsdWUucmVwbGFjZSgvXFxEL2csIFwiXCIpLFxuICAgICAgICAgIG5ld1ZhbHVlID0gbWF0cml4LnJlcGxhY2UoL1tfXFxkXS9nLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgPCB2YWwubGVuZ3RoID8gdmFsLmNoYXJBdChpKyspIHx8IGRlZi5jaGFyQXQoaSkgOiBhO1xuICAgICAgICAgIH0pO1xuICAgICAgICBpID0gbmV3VmFsdWUuaW5kZXhPZihcIl9cIik7XG4gICAgICAgIGlmIChpICE9IC0xKSB7XG4gICAgICAgICAgaSA8IDUgJiYgKGkgPSAzKTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnNsaWNlKDAsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWcgPSBtYXRyaXguc3Vic3RyKDAsIHRoaXMudmFsdWUubGVuZ3RoKS5yZXBsYWNlKC9fKy9nLFxuICAgICAgICAgIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcZHsxLFwiICsgYS5sZW5ndGggKyBcIn1cIjtcbiAgICAgICAgICB9KS5yZXBsYWNlKC9bKygpXS9nLCBcIlxcXFwkJlwiKTtcbiAgICAgICAgcmVnID0gbmV3IFJlZ0V4cChcIl5cIiArIHJlZyArIFwiJFwiKTtcbiAgICAgICAgaWYgKCFyZWcudGVzdCh0aGlzLnZhbHVlKSB8fCB0aGlzLnZhbHVlLmxlbmd0aCA8IDUgfHwga2V5Q29kZSA+IDQ3ICYmIGtleUNvZGUgPCA1OCkgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PSBcImJsdXJcIiAmJiB0aGlzLnZhbHVlLmxlbmd0aCA8IDUpIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgfVxuXG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgbWFzaywgZmFsc2UpO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIG1hc2ssIGZhbHNlKTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIG1hc2ssIGZhbHNlKTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG1hc2ssIGZhbHNlKTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgaWYgKGlucHV0LnZhbHVlLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSg0LCA0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKGlucHV0LnZhbHVlLmxlbmd0aCwgaW5wdXQudmFsdWUubGVuZ3RoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBiaW5kQ3VycmVuY3lJbnB1dCgpIHtcbiAgICBjb25zdCBpbnB1dEFyciA9IFsuLi50aGlzLmZvcm0ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbZGF0YS1mb3JtYXQ9XCJjdXJyZW5jeVwiXScpXVxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRBcnIpIHtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoKSA9PiB7XG4gICAgICAgIGlmIChpbnB1dC52YWx1ZSkge1xuICAgICAgICAgIGlucHV0LnZhbHVlID0gZm9ybWF0QXNDdXJyZW5jeShpbnB1dC52YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZEhhbmRsZXJzKCkge1xuICAgIGNvbnN0IG5leHRBcnIgPSBbLi4udGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNlbGwtZXZ0PVwibmV4dFwiXScpXVxuICAgIGNvbnN0IGJhY2tBcnIgPSBbLi4udGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNlbGwtZXZ0PVwiYmFja1wiXScpXVxuXG4gICAgZm9yIChjb25zdCBidG4gb2YgbmV4dEFycikge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGlmICghYnRuLmRpc2FibGVkKSB7XG4gICAgICAgICAgdGhpcy5nbyh0aGlzLmdldEN1cnJlbnRTdGVwICsgMSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGJ0biBvZiBiYWNrQXJyKSB7XG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgaWYgKCFidG4uZGlzYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLmdvKHRoaXMuZ2V0Q3VycmVudFN0ZXAgLSAxKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBiaW5kU2V0Rm9jdXNlZEVsZW1lbnQoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gWy4uLnRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScpXVxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7IHRoaXMuZm9jdXNlZEVsID0gaW5wdXQgfSlcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4geyB0aGlzLmZvY3VzZWRFbCA9IGlucHV0IH0pXG4gICAgfVxuICB9XG4gIGJpbmRLZXlFdmVudHMoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICBpZiAodGhpcy5sb2NrZWQpIHJldHVyblxuICAgICAgaWYgKCF0aGlzLmdldEFjdGl2ZVNlY3Rpb24pIHJldHVyblxuXG4gICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5nZXRBY3RpdmVTZWN0aW9uXG4gICAgICBjb25zdCBrZXkgPSBlLmtleVxuICAgICAgY29uc3Qga2V5SXNUYWIgPSBrZXkgPT09ICdUYWInXG4gICAgICBjb25zdCBrZXlJc0VudGVyID0ga2V5ID09PSAnRW50ZXInXG4gICAgICBjb25zdCBpc0JhY2tzcGFjZSA9IGtleSA9PT0gJ0JhY2tzcGFjZSdcblxuICAgICAgaWYgKGlzQmFja3NwYWNlKSB7XG4gICAgICAgIGlmICghZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCAhZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jb250YWlucyhzZWN0aW9uKSkgcmV0dXJuXG4gICAgICAgIGNvbnN0IGJ0biA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvcignW2RhdGEtc2VsbC1ldnQ9XCJiYWNrXCJdJylcbiAgICAgICAgaWYgKGJ0biAmJiAhYnRuLmRpc2FibGVkKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgYnRuLmNsaWNrKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5SXNFbnRlcikge1xuICAgICAgICBjb25zdCBidG4gPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNlbGwtZXZ0PVwibmV4dFwiXScpXG4gICAgICAgIGlmIChidG4pIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICBpZiAoIWJ0bi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgYnRuLmNsaWNrKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGtleUlzVGFiKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBjb25zdCBmb2N1c2VkRWwgPSB0aGlzLmdldEZvY3VzZWRFbFxuICAgICAgICBjb25zdCBpbnB1dHMgPSBbLi4uc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScpXS5maWx0ZXIoKGlucHV0KSA9PiB7XG4gICAgICAgICAgaWYgKCFpbnB1dC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0Qm94ID0gaW5wdXQucGFyZW50Tm9kZS5jbG9zZXN0KCcuc3VydmV5LXNlbGVjdCcpXG4gICAgICAgICAgICBpZiAoc2VsZWN0Qm94KSB7XG4gICAgICAgICAgICAgIGlmIChzZWxlY3RCb3guc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnB1dFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkuc29ydCgoYSwgYikgPT4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAtIDIpXG4gICAgICAgIGxldCBlbGVtXG5cbiAgICAgICAgaWYgKCFmb2N1c2VkRWwpIHtcbiAgICAgICAgICBlbGVtID0gaW5wdXRzWzBdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZWxlbVdpdGhpblNlY3Rpb24gPSBpbnB1dHMuaW5jbHVkZXMoZm9jdXNlZEVsKVxuICAgICAgICAgIGlmIChlbGVtV2l0aGluU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgbmV4dEVsZW0gPSBpbnB1dHNbaW5wdXRzLmluZGV4T2YoZm9jdXNlZEVsKSArIDFdXG4gICAgICAgICAgICBpZiAobmV4dEVsZW0pIHtcbiAgICAgICAgICAgICAgZWxlbSA9IG5leHRFbGVtXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtID0gaW5wdXRzWzBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0gPSBpbnB1dHNbMF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc3BhdGNoRm9jdXNFdmVudChlbGVtKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgYmluZFN1Ym1pdCgpIHtcbiAgICAkKHRoaXMuZm9ybSkub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgZm9ybSA9ICQodGhpcyk7XG4gICAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEodGhpcyk7XG4gICAgICB2YXIgYWN0aW9uVXJsID0gZm9ybS5hdHRyKCdhY3Rpb24nKTtcbiAgICAgICQuYWpheCh7XG4gICAgICAgIHVybDogYWN0aW9uVXJsLFxuICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgIGRhdGE6IGZvcm1EYXRhLFxuICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHZhciByID0gJC5wYXJzZUpTT04oZGF0YSk7XG4gICAgICAgICAgaWYgKCFyLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vc2hvdyBlcnJvciBtZXNzYWdlIFxuICAgICAgICAgICAgYWxlcnQoci5tc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cFxuICAgKi9cbiAgc2V0dXBCYXIoKSB7XG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NCYXIpIHtcbiAgICAgIGxldCBodG1sID0gJydcbiAgICAgIHRoaXMuc2VjdGlvbnNBcnIuZm9yRWFjaCgoc2VjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgaHRtbCArPSBgPHNwYW4gZGF0YS1iYXItaWQ9XCIke2luZGV4fVwiPjwvc3Bhbj5gXG4gICAgICB9KVxuICAgICAgdGhpcy5wcm9ncmVzc0Jhci5pbm5lckhUTUwgPSBodG1sXG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnRTdGVwRWxlbSAmJiB0aGlzLmNvdW50U3RlcEVsZW0pIHtcbiAgICAgIHRoaXMuY3VycmVudFN0ZXBFbGVtLmlubmVySFRNTCA9IDFcbiAgICAgIHRoaXMuY291bnRTdGVwRWxlbS5pbm5lckhUTUwgPSB0aGlzLnNlY3Rpb25zQXJyLmxlbmd0aFxuICAgIH1cbiAgfVxuICBzZXR1cCgpIHtcbiAgICB0aGlzLnNldHVwQmFyKClcbiAgICB0aGlzLmdvKDEpXG4gICAgdGhpcy5vYnNlcnZlU3RlcHNFbGVtZW50cygpXG4gICAgdGhpcy5vYnNlcnZlQmFyRWxlbWVudHMoKVxuICAgIHRoaXMuYmluZEhhbmRsZXJzKClcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgaWYgKHRoaXMuZm9ybSkge1xuICAgICAgdGhpcy5iaW5kRHVhbFNlbGVjdCgpXG4gICAgICB0aGlzLmJpbmRUb2dnbGVTdGVwc0NvbnRyb2xzKClcbiAgICAgIHRoaXMuYmluZEJyYW5kU2VsZWN0KClcbiAgICAgIHRoaXMuYmluZFBob25lSW5wdXQoKVxuICAgICAgdGhpcy5iaW5kQ3VycmVuY3lJbnB1dCgpXG4gICAgICB0aGlzLmJpbmRTZXRGb2N1c2VkRWxlbWVudCgpXG4gICAgICB0aGlzLmJpbmRLZXlFdmVudHMoKVxuICAgICAgdGhpcy5iaW5kU3VibWl0KClcbiAgICAgIHRoaXMuc2V0dXAoKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGxXYXRjaCIsImNvbnN0IHRhZ1ByZXZpZXcgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluX3ByaW50LXRhZycpICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVzZXRPdXRwdXQoKVxuICAgICAgICB0aGlzLmF0dGFjaElucHV0KClcbiAgICAgICAgdGhpcy5hdHRhY2hJbWFnZVVwbG9hZGVyKClcbiAgICAgICAgdGhpcy5hdHRhY2hQcmV2aWV3Q29udHJvbHMoKVxuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgY29uc29sZS5sb2coJ1RBRyBQUkVWSUVXIEVSUicpXG4gICAgfVxuICB9LFxuICByZXNldE91dHB1dDogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IG91dHB1dEhvbGRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YWctcHJldmlld19fb3V0cHV0JyksXG4gICAgICBvdXRwdXRJbWFnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YWctcHJldmlld19fcGljJylcbiAgICBvdXRwdXRIb2xkZXIuaW5uZXJIVE1MID0gJydcbiAgICBvdXRwdXRIb2xkZXIuY2xhc3NMaXN0LmFkZChJU19FTVBUWSlcbiAgICBvdXRwdXRJbWFnZS5jbGFzc0xpc3QuYWRkKElTX0VNUFRZKVxuICB9LFxuICBhdHRhY2hJbnB1dDogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IG91dHB1dE9iaiA9IG5ldyBPYmplY3QoKSxcbiAgICAgIGlucHV0cyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwidGV4dFwiXS5mb3JtcGFnZV9faW5wdXQnKV0sXG4gICAgICBvdXRwdXRIb2xkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFnLXByZXZpZXdfX291dHB1dCcpLFxuICAgICAgdXBkYXRlT3V0cHV0ID0gKCkgPT4ge1xuICAgICAgICBsZXQgZmlsbGVkID0gMCwgaHRtbCA9IGBgXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG91dHB1dE9iaikge1xuICAgICAgICAgIGlmIChvdXRwdXRPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gb3V0cHV0T2JqW2tleV1cbiAgICAgICAgICAgIGlmIChvYmoudmFsdWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICsrZmlsbGVkXG4gICAgICAgICAgICAgIGh0bWwgKz0gYFxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCIke29iai5pZH1cIiBjbGFzcz1cInRhZy1vdXRwdXQtcm93XCI+XG4gICAgICAgICAgICAgICAgICA8c3Bhbj4ke29iai50aXRsZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8c3Bhbj4ke29iai52YWx1ZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsbGVkICE9PSAwKSB7XG4gICAgICAgICAgb3V0cHV0SG9sZGVyLmlubmVySFRNTCA9IGh0bWxcbiAgICAgICAgICBvdXRwdXRIb2xkZXIuY2xhc3NMaXN0LnJlbW92ZShJU19FTVBUWSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXRIb2xkZXIuaW5uZXJIVE1MID0gJydcbiAgICAgICAgICBvdXRwdXRIb2xkZXIuY2xhc3NMaXN0LmFkZChJU19FTVBUWSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xuICAgICAgb3V0cHV0T2JqW2luZGV4XSA9IHtcbiAgICAgICAgaWQ6IGlucHV0LmlkLFxuICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgIHRpdGxlOiBpbnB1dC5jbG9zZXN0KCcuZm9ybXBhZ2VfX2lucHV0LWJveCcpLnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsJykuaW5uZXJIVE1MXG4gICAgICB9XG5cbiAgICAgIGlucHV0Lm9uaW5wdXQgPSAoKSA9PiB7XG4gICAgICAgIG91dHB1dE9ialtpbmRleF0udmFsdWUgPSBpbnB1dC52YWx1ZSB8fCAnJ1xuICAgICAgICB1cGRhdGVPdXRwdXQoKVxuICAgICAgfVxuICAgICAgaW5wdXQub25rZXlkb3duID0gKGUpID0+IHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICBpc0VudGVyID0gZS5rZXkgPT09ICdFbnRlcicgfHwgZS5rZXlDb2RlID09PSAxMyxcbiAgICAgICAgICBpc0JhY2tzY2FwZSA9IGUua2V5ID09PSAnQmFja3NwYWNlJyB8fCBlLmtleSA9PT0gJ0RlbGV0ZScsXG4gICAgICAgICAgaXNFc2MgPSBlLmtleSA9PT0gJ0VzY2FwZScgfHwgZS5rZXkgPT09ICdFc2MnLFxuICAgICAgICAgIGlzVXAgPSBlLmtleSA9PT0gJ0Fycm93VXAnLFxuICAgICAgICAgIGlzRG93biA9IGUua2V5ID09PSAnQXJyb3dEb3duJyxcbiAgICAgICAgICBuZXh0ID0gaW5wdXRzW2luZGV4ICsgMV0sXG4gICAgICAgICAgcHJldiA9IGlucHV0c1tpbmRleCAtIDFdXG5cbiAgICAgICAgaWYgKGlzRW50ZXIgfHwgaXNEb3duKSB7XG4gICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkgeyBuZXh0LmZvY3VzKCkgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JhY2tzY2FwZSkge1xuICAgICAgICAgIGlmIChpbnB1dC52YWx1ZS5sZW5ndGggPT0gMCAmJiBwcmV2ICE9PSB1bmRlZmluZWQpIHsgcHJldi5mb2N1cygpIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFc2MpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IGlucHV0LmJsdXIoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VwKSB7XG4gICAgICAgICAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCkgeyBwcmV2LmZvY3VzKCkgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBbJ2ZvY3VzJywgJ2JsdXInXS5mb3JFYWNoKChldikgPT4ge1xuICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPD0gNDc5KSB7XG4gICAgICAgICAgY29uc3QgbGFiZWwgPSBpbnB1dC5jbG9zZXN0KCcuZm9ybXBhZ2VfX2lucHV0LWJveCcpLnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsJylcbiAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKGV2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICAgICAgICBsYWJlbC5zdHlsZS5vcGFjaXR5ID0gMFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQudmFsdWUubGVuZ3RoICE9PSAwKSB7IGxhYmVsLnN0eWxlLm9wYWNpdHkgPSAwIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBsYWJlbC5zdHlsZS5vcGFjaXR5ID0gMC41XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICB9KVxuICB9LFxuICBhdHRhY2hJbWFnZVVwbG9hZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgdXBsb2FkTGFiZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcHJpbnRUYWdfdXBsb2FkZXInKSxcbiAgICAgIHVwbG9hZElucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2ltYWdlX3VwbG9hZF90YWcnKSxcbiAgICAgIGltZ1ByZXZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFnLXByZXZpZXdfX3BpYycpXG5cbiAgICAvLyBEUkFHICYgRFJPUFxuICAgIGlmICh1cGxvYWRMYWJlbCAhPT0gbnVsbCkge1xuICAgICAgdXBsb2FkTGFiZWwub25kcmFnb3ZlciA9IChldnQpID0+IHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdXBsb2FkTGFiZWwuY2xhc3NMaXN0LmFkZChJU19BQ1RJVkUpXG4gICAgICB9XG4gICAgICB1cGxvYWRMYWJlbC5vbmRyYWdsZWF2ZSA9IChldnQpID0+IHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdXBsb2FkTGFiZWwuY2xhc3NMaXN0LnJlbW92ZShJU19BQ1RJVkUpXG4gICAgICB9XG4gICAgICB1cGxvYWRMYWJlbC5vbmRyb3AgPSAoZXZ0KSA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHVwbG9hZExhYmVsLmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKVxuICAgICAgICAkKCcjaW1hZ2VfdXBsb2FkX3RhZycpLnByb3AoJ2ZpbGVzJywgZXZ0LmRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gWy4uLmV2dC5kYXRhVHJhbnNmZXIuaXRlbXNdLFxuICAgICAgICAgIGZpbGUgPSBmaWxlcy5maW5kKChpdGVtKSA9PiB7IGlmIChpdGVtLmtpbmQgPT09ICdmaWxlJykgeyByZXR1cm4gaXRlbSB9IH0pXG4gICAgICAgIHByb2Nlc3NJbWFnZShmaWxlLmdldEFzRmlsZSgpKVxuICAgICAgfVxuXG4gICAgICAvLyBNQU5VQUxcbiAgICAgIGlmICh1cGxvYWRJbnB1dCAhPT0gbnVsbCkge1xuICAgICAgICB1cGxvYWRJbnB1dC5vbmNoYW5nZSA9IChldnQpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlID0gWy4uLmV2dC50YXJnZXQuZmlsZXNdWzBdXG4gICAgICAgICAgcHJvY2Vzc0ltYWdlKGZpbGUpXG4gICAgICAgICAgdXBsb2FkSW5wdXQudmFsdWUgPSAnJ1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFBST0NFU1MgSU1BR0VcbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3NJbWFnZShmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICAgICAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgICAgICAgIGltZ1ByZXZpZXcuY2xhc3NMaXN0LnJlbW92ZShJU19FTVBUWSlcbiAgICAgICAgICAgIGltZ1ByZXZpZXcuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgke2UudGFyZ2V0LnJlc3VsdH0pYFxuICAgICAgICAgIH1cbiAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG4gIH0sXG4gIGF0dGFjaFByZXZpZXdDb250cm9sczogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRhZy1wcmV2aWV3LW1vZGFsJylcbiAgICBpZiAobW9kYWwgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGhvbGRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YWctcHJldmlldy1tb2RhbF9fd3JhcHBlcicpXG4gICAgICBjb25zdCB0b2dnbGUgPSAoKSA9PiB7XG4gICAgICAgIGxldCBkaXNwbGF5ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShtb2RhbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpICE9PSAnbm9uZSdcbiAgICAgICAgaWYgKGRpc3BsYXllZCkge1xuICAgICAgICAgIHVubG9ja1Njcm9sbCgpXG4gICAgICAgICAgY29uc3QgcHJldmlldyA9IGhvbGRlci5xdWVyeVNlbGVjdG9yKCcuZm9ybXBhZ2VfX3RhZy1wcmV2aWV3JylcbiAgICAgICAgICBpZiAocHJldmlldyAhPT0gbnVsbCkgeyBwcmV2aWV3LnJlbW92ZSgpIH1cbiAgICAgICAgICBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9ja1Njcm9sbCgpXG4gICAgICAgICAgY29uc3QgcHJldmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb3JtcGFnZV9fdGFnLXByZXZpZXcnKVxuICAgICAgICAgIGhvbGRlci5hcHBlbmRDaGlsZChwcmV2aWV3LmNsb25lTm9kZSh0cnVlKSlcbiAgICAgICAgICBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXRcbiAgICAgICAgaWYgKHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZXZ0JykgPT0gJ3RvZ2dsZVByaW50VGFnUHJldmlldycpIHtcbiAgICAgICAgICB0b2dnbGUoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRhZ1ByZXZpZXciLCJmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cbmZ1bmN0aW9uIGxvY2tTY3JvbGwoKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICghZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoXCJpYi1zY3JvbGwtbG9ja1wiKSkge1xuICAgICAgbGV0IG8gPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKFwiaWItc2Nyb2xsLWxvY2tcIiwgbyksXG4gICAgICAgIChkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIiksXG4gICAgICAgIChkb2N1bWVudC5ib2R5LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiKSxcbiAgICAgICAgKGRvY3VtZW50LmJvZHkuc3R5bGUudG9wID0gXCItXCIgKyBvICsgXCJweFwiKSxcbiAgICAgICAgKGRvY3VtZW50LmJvZHkuc3R5bGUubGVmdCA9IFwiMFwiKSxcbiAgICAgICAgKGRvY3VtZW50LmJvZHkuc3R5bGUud2lkdGggPSBcIjEwMCVcIik7XG4gICAgfVxuICB9LCAxKTtcbn1cbmZ1bmN0aW9uIHVubG9ja1Njcm9sbCgpIHtcbiAgaWYgKGRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKFwiaWItc2Nyb2xsLWxvY2tcIikpIHtcbiAgICBsZXQgbyA9IGRvY3VtZW50LmJvZHkuZ2V0QXR0cmlidXRlKFwiaWItc2Nyb2xsLWxvY2tcIik7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUoXCJpYi1zY3JvbGwtbG9ja1wiKSxcbiAgICAgIChkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJcIiksXG4gICAgICAoZG9jdW1lbnQuYm9keS5zdHlsZS5wb3NpdGlvbiA9IFwiXCIpLFxuICAgICAgKGRvY3VtZW50LmJvZHkuc3R5bGUudG9wID0gXCJcIiksXG4gICAgICAoZG9jdW1lbnQuYm9keS5zdHlsZS5sZWZ0ID0gXCJcIiksXG4gICAgICAoZG9jdW1lbnQuYm9keS5zdHlsZS53aWR0aCA9IFwiXCIpLFxuICAgICAgd2luZG93LnNjcm9sbCgwLCBvKTtcbiAgfVxufVxuZnVuY3Rpb24gZWxlbURpc3BsYXllZChlbGVtKSB7XG4gIGlmICghZWxlbSkgcmV0dXJuIGZhbHNlXG4gIGxldCB0YXJnZXQgPSBlbGVtIGluc3RhbmNlb2YgalF1ZXJ5ID8gZWxlbS5nZXQoMCkgOiBlbGVtXG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnXG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtKHRhZ05hbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBjbGFzc05hbWUsIGlkLCBpbm5lckhUTUwsIHN0eWxlLCBhdHRyaWJ1dGVzLCB0b0FwcGVuZCB9ID0gb3B0aW9uc1xuICBjb25zdCBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKVxuICBpZiAoY2xhc3NOYW1lKSBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgaWYgKGlkKSBlbGVtLmlkID0gaWQ7XG4gIGlmIChpbm5lckhUTUwpIGVsZW0uaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICBpZiAoc3R5bGUpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zLnN0eWxlKSB7IGVsZW0uc3R5bGVba2V5XSA9IG9wdGlvbnMuc3R5bGVba2V5XSB9XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zLmF0dHJpYnV0ZXMpIHsgZWxlbS5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSkgfVxuICB9XG4gIGlmICh0b0FwcGVuZCkge1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdG9BcnJheSh0b0FwcGVuZCkpIHsgZWxlbS5hcHBlbmRDaGlsZChjaGlsZCkgfVxuICB9XG4gIHJldHVybiBlbGVtXG59XG5mdW5jdGlvbiByZW1vdmVDbGFzc2VzKGVsZW0sIC4uLmNsYXNzZXMpIHtcbiAgZm9yIChjb25zdCBjbHMgb2YgY2xhc3Nlcykge1xuICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbHMpXG4gIH1cbn1cbmZ1bmN0aW9uIGFkZENsYXNzZXMoZWxlbSwgLi4uY2xhc3Nlcykge1xuICBmb3IgKGNvbnN0IGNscyBvZiBjbGFzc2VzKSB7XG4gICAgZWxlbS5jbGFzc0xpc3QuYWRkKGNscylcbiAgfVxufVxuZnVuY3Rpb24gZm9ybWF0QXNDdXJyZW5jeShzdHJpbmcpIHtcbiAgc3RyaW5nID0gdHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycgPyBzdHJpbmcgOiBzdHJpbmcudG9TdHJpbmcoKVxuICBjb25zdCBudW1iZXIgPSBwYXJzZUZsb2F0KHN0cmluZy5yZXBsYWNlKC8sL2csICcnKSlcbiAgY29uc3QgcGFydHMgPSBudW1iZXIudG9GaXhlZCgyKS5zcGxpdCgnLicpXG4gIGNvbnN0IGRpZ2l0cyA9IHBhcnRzWzBdXG4gIGNvbnN0IGRlY2ltYWwgPSBwYXJ0c1sxXVxuICBjb25zdCBpbnRlZ2VyID0gZGlnaXRzLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csICcsJylcbiAgcmV0dXJuIGAke2ludGVnZXJ9LiR7ZGVjaW1hbH1gXG59XG5mdW5jdGlvbiBnZXRFdnRET00oYXR0cikge1xuICByZXR1cm4gJChgW2RhdGEtZXZ0PVwiJHthdHRyfVwiXWApO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblRpbWUoZWxlbSkge1xuICBsZXQgZWwgPSBlbGVtIGluc3RhbmNlb2YgalF1ZXJ5ID8gZWxlbVswXSA6IGVsZW07XG4gIHJldHVybiBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS50cmFuc2l0aW9uRHVyYXRpb24pICogMTAwMDtcbn1cbmZ1bmN0aW9uIGdldE9yZGluYWxUeHQobikge1xuICByZXR1cm4gbiAlIDEwID09IDEgJiYgbiAlIDEwMCAhPSAxMSA/ICdzdCcgOiBuICUgMTAgPT0gMiAmJiBuICUgMTAwICE9IDEyID8gJ25kJyA6IG4gJSAxMCA9PSAzICYmIG4gJSAxMDAgIT0gMTMgPyAncmQnIDogJ3RoJ1xufVxuZnVuY3Rpb24gZ2V0WkluZGV4KGVsZW0pIHtcbiAgcmV0dXJuIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pLmdldFByb3BlcnR5VmFsdWUoJ3otaW5kZXgnKSlcbn1cbmZ1bmN0aW9uIHRvZ2dsZUFkbWluQmFyKCkge1xuICBsZXQgYmFyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmliYS10b29sYmFyJylcbiAgaWYgKGJhciAmJiBiYXIgIT09IG51bGwpIHtcbiAgICBpZiAoYmFyLmNsYXNzTGlzdC5jb250YWlucyhJU19NSU5JTUlaRUQpKSB7XG4gICAgICBiYXIuY2xhc3NMaXN0LnJlbW92ZShJU19NSU5JTUlaRUQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJhci5jbGFzc0xpc3QuYWRkKElTX01JTklNSVpFRClcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRW1haWwoZW1haWwpIHtcbiAgdmFyIHJlZ2V4ID0gL14oW2EtekEtWjAtOV8uKy1dKStcXEAoKFthLXpBLVowLTktXSkrXFwuKSsoW2EtekEtWjAtOV17Miw0fSkrJC87XG4gIHJldHVybiByZWdleC50ZXN0KGVtYWlsKTtcbn1cbmZ1bmN0aW9uIHNhdmVDYXJ0RW1haWwoKSB7XG4gIHZhciBlbWFpbCA9ICQoJyNjYXJ0X2VtYWlsJykudmFsKCk7XG4gIGlmIChlbWFpbCAhPSAnJyAmJiBpc0VtYWlsKGVtYWlsKSkge1xuICAgICQuYWpheCh7XG4gICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgIHVybDogJy9qc29uL2NhcnQtZW1haWwnLFxuICAgICAgZGF0YTogeyBlbWFpbF9hZGRyZXNzOiBlbWFpbCB9LFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAga2xhdml5by5pZGVudGlmeSh7ICckZW1haWwnOiBlbWFpbCB9KTtcbiAgICAgICAgbWFpbE1vZGFsLmNsb3NlKCk7XG4gICAgICAgIHNob3dNZXNzYWdlKCdzdWNjZXNzJywgJ1RoYW5rIHlvdScsICdJdGVtIHdhcyBhZGRlZCB0byB5b3VyIGNhcnQuJyk7XG4gICAgICAgICQoJy5jYXJ0X3RyaWdnZXInKS5jbGljaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNob3dNZXNzYWdlKCdlcnJvcicsICdFcnJvcicsICdQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzICEnKTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvd01lc3NhZ2UodHlwZSwgdGl0bGUsIG1zZykge1xuICB2YXIgYWxlcnRfdHlwZSA9ICh0eXBlID09PSAnc3VjY2VzcycpID8gcGFnZUFsZXJ0cy5jbGFzc2VzLmluZm8gOiBwYWdlQWxlcnRzLmNsYXNzZXMuZXJyb3I7XG4gIHBhZ2VBbGVydHMuc2hvd0FsZXJ0KGFsZXJ0X3R5cGUsIHRpdGxlLCBtc2cpO1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gIGxldCB0aW1lb3V0XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgbGF0ZXIgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgIGZ1bmMoLi4uYXJncylcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRvQXJyYXksXG4gIGxvY2tTY3JvbGwsXG4gIHVubG9ja1Njcm9sbCxcbiAgZWxlbURpc3BsYXllZCxcbiAgY3JlYXRlRWxlbSxcbiAgcmVtb3ZlQ2xhc3NlcyxcbiAgYWRkQ2xhc3NlcyxcbiAgZm9ybWF0QXNDdXJyZW5jeSxcbiAgZ2V0RXZ0RE9NLFxuICBnZXRUcmFuc2l0aW9uVGltZSxcbiAgZ2V0T3JkaW5hbFR4dCxcbiAgZ2V0WkluZGV4LFxuICB0b2dnbGVBZG1pbkJhcixcbiAgaXNFbWFpbCxcbiAgc2F2ZUNhcnRFbWFpbCxcbiAgc2hvd01lc3NhZ2UsXG4gIGRlYm91bmNlXG59IiwibGV0IHZhcmlhYmxlcyA9IHtcbiAgVVBMT0FERURfQkxPR19JTUc6IG51bGwsXG4gIGFsZXJ0VGltZXI6IG51bGwsXG4gIHNpcnZUaW1lcjogbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhcmlhYmxlczsiLCIhZnVuY3Rpb24gKHQsIGUpIHsgXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBtb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA9IGUocmVxdWlyZShcImpxdWVyeVwiKSkgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFtcImpxdWVyeVwiXSwgZSkgOiAodCA9IHQgfHwgc2VsZikucGFyc2xleSA9IGUodC5qUXVlcnkpIH0odGhpcywgZnVuY3Rpb24gKGgpIHsgXCJ1c2Ugc3RyaWN0XCI7IGZ1bmN0aW9uIG4odCkgeyByZXR1cm4gKG4gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAodCkgeyByZXR1cm4gdHlwZW9mIHQgfSA6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIHQuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiB0ICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiB0IH0pKHQpIH0gZnVuY3Rpb24gbCgpIHsgcmV0dXJuIChsID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkgeyBmb3IgKHZhciBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykgeyB2YXIgaSA9IGFyZ3VtZW50c1tlXTsgZm9yICh2YXIgciBpbiBpKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSwgcikgJiYgKHRbcl0gPSBpW3JdKSB9IHJldHVybiB0IH0pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfSBmdW5jdGlvbiBvKHQsIGUpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IGlmIChBcnJheS5pc0FycmF5KHQpKSByZXR1cm4gdCB9KHQpIHx8IGZ1bmN0aW9uICh0LCBlKSB7IGlmICghKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCkgfHwgXCJbb2JqZWN0IEFyZ3VtZW50c11cIiA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKSkgcmV0dXJuOyB2YXIgaSA9IFtdLCByID0gITAsIG4gPSAhMSwgcyA9IHZvaWQgMDsgdHJ5IHsgZm9yICh2YXIgYSwgbyA9IHRbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKHIgPSAoYSA9IG8ubmV4dCgpKS5kb25lKSAmJiAoaS5wdXNoKGEudmFsdWUpLCAhZSB8fCBpLmxlbmd0aCAhPT0gZSk7IHIgPSAhMCk7IH0gY2F0Y2ggKHQpIHsgbiA9ICEwLCBzID0gdCB9IGZpbmFsbHkgeyB0cnkgeyByIHx8IG51bGwgPT0gby5yZXR1cm4gfHwgby5yZXR1cm4oKSB9IGZpbmFsbHkgeyBpZiAobikgdGhyb3cgcyB9IH0gcmV0dXJuIGkgfSh0LCBlKSB8fCBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpIH0oKSB9IGZ1bmN0aW9uIHUodCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgaWYgKEFycmF5LmlzQXJyYXkodCkpIHsgZm9yICh2YXIgZSA9IDAsIGkgPSBuZXcgQXJyYXkodC5sZW5ndGgpOyBlIDwgdC5sZW5ndGg7IGUrKylpW2VdID0gdFtlXTsgcmV0dXJuIGkgfSB9KHQpIHx8IGZ1bmN0aW9uICh0KSB7IGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHQpIHx8IFwiW29iamVjdCBBcmd1bWVudHNdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkgcmV0dXJuIEFycmF5LmZyb20odCkgfSh0KSB8fCBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKSB9KCkgfSB2YXIgdCA9IDEsIGUgPSB7fSwgZCA9IHsgYXR0cjogZnVuY3Rpb24gKHQsIGUsIGkpIHsgdmFyIHIsIG4sIHMsIGEgPSBuZXcgUmVnRXhwKFwiXlwiICsgZSwgXCJpXCIpOyBpZiAodm9pZCAwID09PSBpKSBpID0ge307IGVsc2UgZm9yIChyIGluIGkpIGkuaGFzT3duUHJvcGVydHkocikgJiYgZGVsZXRlIGlbcl07IGlmICghdCkgcmV0dXJuIGk7IGZvciAociA9IChzID0gdC5hdHRyaWJ1dGVzKS5sZW5ndGg7IHItLTspKG4gPSBzW3JdKSAmJiBuLnNwZWNpZmllZCAmJiBhLnRlc3Qobi5uYW1lKSAmJiAoaVt0aGlzLmNhbWVsaXplKG4ubmFtZS5zbGljZShlLmxlbmd0aCkpXSA9IHRoaXMuZGVzZXJpYWxpemVWYWx1ZShuLnZhbHVlKSk7IHJldHVybiBpIH0sIGNoZWNrQXR0cjogZnVuY3Rpb24gKHQsIGUsIGkpIHsgcmV0dXJuIHQuaGFzQXR0cmlidXRlKGUgKyBpKSB9LCBzZXRBdHRyOiBmdW5jdGlvbiAodCwgZSwgaSwgcikgeyB0LnNldEF0dHJpYnV0ZSh0aGlzLmRhc2hlcml6ZShlICsgaSksIFN0cmluZyhyKSkgfSwgZ2V0VHlwZTogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSB8fCBcInRleHRcIiB9LCBnZW5lcmF0ZUlEOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlwiICsgdCsrIH0sIGRlc2VyaWFsaXplVmFsdWU6IGZ1bmN0aW9uIChlKSB7IHZhciB0OyB0cnkgeyByZXR1cm4gZSA/IFwidHJ1ZVwiID09IGUgfHwgXCJmYWxzZVwiICE9IGUgJiYgKFwibnVsbFwiID09IGUgPyBudWxsIDogaXNOYU4odCA9IE51bWJlcihlKSkgPyAvXltcXFtcXHtdLy50ZXN0KGUpID8gSlNPTi5wYXJzZShlKSA6IGUgOiB0KSA6IGUgfSBjYXRjaCAodCkgeyByZXR1cm4gZSB9IH0sIGNhbWVsaXplOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5yZXBsYWNlKC8tKyguKT8vZywgZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIGUgPyBlLnRvVXBwZXJDYXNlKCkgOiBcIlwiIH0pIH0sIGRhc2hlcml6ZTogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQucmVwbGFjZSgvOjovZywgXCIvXCIpLnJlcGxhY2UoLyhbQS1aXSspKFtBLVpdW2Etel0pL2csIFwiJDFfJDJcIikucmVwbGFjZSgvKFthLXpcXGRdKShbQS1aXSkvZywgXCIkMV8kMlwiKS5yZXBsYWNlKC9fL2csIFwiLVwiKS50b0xvd2VyQ2FzZSgpIH0sIHdhcm46IGZ1bmN0aW9uICgpIHsgdmFyIHQ7IHdpbmRvdy5jb25zb2xlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygd2luZG93LmNvbnNvbGUud2FybiAmJiAodCA9IHdpbmRvdy5jb25zb2xlKS53YXJuLmFwcGx5KHQsIGFyZ3VtZW50cykgfSwgd2Fybk9uY2U6IGZ1bmN0aW9uICh0KSB7IGVbdF0gfHwgKGVbdF0gPSAhMCwgdGhpcy53YXJuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIH0sIF9yZXNldFdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7IGUgPSB7fSB9LCB0cmltU3RyaW5nOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKSB9LCBwYXJzZTogeyBkYXRlOiBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IHQubWF0Y2goL14oXFxkezQsfSktKFxcZFxcZCktKFxcZFxcZCkkLyk7IGlmICghZSkgcmV0dXJuIG51bGw7IHZhciBpID0gbyhlLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gcGFyc2VJbnQodCwgMTApIH0pLCA0KSwgciA9IChpWzBdLCBpWzFdKSwgbiA9IGlbMl0sIHMgPSBpWzNdLCBhID0gbmV3IERhdGUociwgbiAtIDEsIHMpOyByZXR1cm4gYS5nZXRGdWxsWWVhcigpICE9PSByIHx8IGEuZ2V0TW9udGgoKSArIDEgIT09IG4gfHwgYS5nZXREYXRlKCkgIT09IHMgPyBudWxsIDogYSB9LCBzdHJpbmc6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IH0sIGludGVnZXI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBpc05hTih0KSA/IG51bGwgOiBwYXJzZUludCh0LCAxMCkgfSwgbnVtYmVyOiBmdW5jdGlvbiAodCkgeyBpZiAoaXNOYU4odCkpIHRocm93IG51bGw7IHJldHVybiBwYXJzZUZsb2F0KHQpIH0sIGJvb2xlYW46IGZ1bmN0aW9uICh0KSB7IHJldHVybiAhL15cXHMqZmFsc2VcXHMqJC9pLnRlc3QodCkgfSwgb2JqZWN0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gZC5kZXNlcmlhbGl6ZVZhbHVlKHQpIH0sIHJlZ2V4cDogZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSBcIlwiOyByZXR1cm4gdCA9IC9eXFwvLipcXC8oPzpbZ2lteV0qKSQvLnRlc3QodCkgPyAoZSA9IHQucmVwbGFjZSgvLipcXC8oW2dpbXldKikkLywgXCIkMVwiKSwgdC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJeLyguKj8pL1wiICsgZSArIFwiJFwiKSwgXCIkMVwiKSkgOiBcIl5cIiArIHQgKyBcIiRcIiwgbmV3IFJlZ0V4cCh0LCBlKSB9IH0sIHBhcnNlUmVxdWlyZW1lbnQ6IGZ1bmN0aW9uICh0LCBlKSB7IHZhciBpID0gdGhpcy5wYXJzZVt0IHx8IFwic3RyaW5nXCJdOyBpZiAoIWkpIHRocm93ICdVbmtub3duIHJlcXVpcmVtZW50IHNwZWNpZmljYXRpb246IFwiJyArIHQgKyAnXCInOyB2YXIgciA9IGkoZSk7IGlmIChudWxsID09PSByKSB0aHJvdyBcIlJlcXVpcmVtZW50IGlzIG5vdCBhIFwiLmNvbmNhdCh0LCAnOiBcIicpLmNvbmNhdChlLCAnXCInKTsgcmV0dXJuIHIgfSwgbmFtZXNwYWNlRXZlbnRzOiBmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gKHQgPSB0aGlzLnRyaW1TdHJpbmcodCB8fCBcIlwiKS5zcGxpdCgvXFxzKy8pKVswXSA/IGgubWFwKHQsIGZ1bmN0aW9uICh0KSB7IHJldHVybiBcIlwiLmNvbmNhdCh0LCBcIi5cIikuY29uY2F0KGUpIH0pLmpvaW4oXCIgXCIpIDogXCJcIiB9LCBkaWZmZXJlbmNlOiBmdW5jdGlvbiAodCwgaSkgeyB2YXIgciA9IFtdOyByZXR1cm4gaC5lYWNoKHQsIGZ1bmN0aW9uICh0LCBlKSB7IC0xID09IGkuaW5kZXhPZihlKSAmJiByLnB1c2goZSkgfSksIHIgfSwgYWxsOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gaC53aGVuLmFwcGx5KGgsIHUodCkuY29uY2F0KFs0MiwgNDJdKSkgfSwgb2JqZWN0Q3JlYXRlOiBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uICh0KSB7IGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkgdGhyb3cgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgbm90IHN1cHBvcnRlZFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gbih0KSkgdGhyb3cgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3RcIik7IGkucHJvdG90eXBlID0gdDsgdmFyIGUgPSBuZXcgaTsgcmV0dXJuIGkucHJvdG90eXBlID0gbnVsbCwgZSB9LCBfU3VibWl0U2VsZWN0b3I6ICdpbnB1dFt0eXBlPVwic3VibWl0XCJdLCBidXR0b246c3VibWl0JyB9OyBmdW5jdGlvbiBpKCkgeyB9IGZ1bmN0aW9uIHIoKSB7IHRoaXMuX19pZF9fID0gZC5nZW5lcmF0ZUlEKCkgfSB2YXIgcyA9IHsgbmFtZXNwYWNlOiBcImRhdGEtcGFyc2xleS1cIiwgaW5wdXRzOiBcImlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0XCIsIGV4Y2x1ZGVkOiBcImlucHV0W3R5cGU9YnV0dG9uXSwgaW5wdXRbdHlwZT1zdWJtaXRdLCBpbnB1dFt0eXBlPXJlc2V0XSwgaW5wdXRbdHlwZT1oaWRkZW5dXCIsIHByaW9yaXR5RW5hYmxlZDogITAsIG11bHRpcGxlOiBudWxsLCBncm91cDogbnVsbCwgdWlFbmFibGVkOiAhMCwgdmFsaWRhdGlvblRocmVzaG9sZDogMywgZm9jdXM6IFwiZmlyc3RcIiwgdHJpZ2dlcjogITEsIHRyaWdnZXJBZnRlckZhaWx1cmU6IFwiaW5wdXRcIiwgZXJyb3JDbGFzczogXCJwYXJzbGV5LWVycm9yXCIsIHN1Y2Nlc3NDbGFzczogXCJwYXJzbGV5LXN1Y2Nlc3NcIiwgY2xhc3NIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IH0sIGVycm9yc0NvbnRhaW5lcjogZnVuY3Rpb24gKCkgeyB9LCBlcnJvcnNXcmFwcGVyOiAnPHVsIGNsYXNzPVwicGFyc2xleS1lcnJvcnMtbGlzdFwiPjwvdWw+JywgZXJyb3JUZW1wbGF0ZTogXCI8bGk+PC9saT5cIiB9OyByLnByb3RvdHlwZSA9IHsgYXN5bmNTdXBwb3J0OiAhMCwgX3BpcGVBY2NvcmRpbmdUb1ZhbGlkYXRpb25SZXN1bHQ6IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gdCgpIHsgdmFyIHQgPSBoLkRlZmVycmVkKCk7IHJldHVybiAhMCAhPT0gZS52YWxpZGF0aW9uUmVzdWx0ICYmIHQucmVqZWN0KCksIHQucmVzb2x2ZSgpLnByb21pc2UoKSB9IHZhciBlID0gdGhpczsgcmV0dXJuIFt0LCB0XSB9LCBhY3R1YWxpemVPcHRpb25zOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkLmF0dHIodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMubmFtZXNwYWNlLCB0aGlzLmRvbU9wdGlvbnMpLCB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5hY3R1YWxpemVPcHRpb25zICYmIHRoaXMucGFyZW50LmFjdHVhbGl6ZU9wdGlvbnMoKSwgdGhpcyB9LCBfcmVzZXRPcHRpb25zOiBmdW5jdGlvbiAodCkgeyBmb3IgKHZhciBlIGluIHRoaXMuZG9tT3B0aW9ucyA9IGQub2JqZWN0Q3JlYXRlKHRoaXMucGFyZW50Lm9wdGlvbnMpLCB0aGlzLm9wdGlvbnMgPSBkLm9iamVjdENyZWF0ZSh0aGlzLmRvbU9wdGlvbnMpLCB0KSB0Lmhhc093blByb3BlcnR5KGUpICYmICh0aGlzLm9wdGlvbnNbZV0gPSB0W2VdKTsgdGhpcy5hY3R1YWxpemVPcHRpb25zKCkgfSwgX2xpc3RlbmVyczogbnVsbCwgb246IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwge30sICh0aGlzLl9saXN0ZW5lcnNbdF0gPSB0aGlzLl9saXN0ZW5lcnNbdF0gfHwgW10pLnB1c2goZSksIHRoaXMgfSwgc3Vic2NyaWJlOiBmdW5jdGlvbiAodCwgZSkgeyBoLmxpc3RlblRvKHRoaXMsIHQudG9Mb3dlckNhc2UoKSwgZSkgfSwgb2ZmOiBmdW5jdGlvbiAodCwgZSkgeyB2YXIgaSA9IHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzLl9saXN0ZW5lcnNbdF07IGlmIChpKSBpZiAoZSkgZm9yICh2YXIgciA9IGkubGVuZ3RoOyByLS07KWlbcl0gPT09IGUgJiYgaS5zcGxpY2UociwgMSk7IGVsc2UgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1t0XTsgcmV0dXJuIHRoaXMgfSwgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICh0KSB7IGgudW5zdWJzY3JpYmVUbyh0aGlzLCB0LnRvTG93ZXJDYXNlKCkpIH0sIHRyaWdnZXI6IGZ1bmN0aW9uICh0LCBlLCBpKSB7IGUgPSBlIHx8IHRoaXM7IHZhciByLCBuID0gdGhpcy5fbGlzdGVuZXJzICYmIHRoaXMuX2xpc3RlbmVyc1t0XTsgaWYgKG4pIGZvciAodmFyIHMgPSBuLmxlbmd0aDsgcy0tOylpZiAoITEgPT09IChyID0gbltzXS5jYWxsKGUsIGUsIGkpKSkgcmV0dXJuIHI7IHJldHVybiAhdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQudHJpZ2dlcih0LCBlLCBpKSB9LCBhc3luY0lzVmFsaWQ6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiBkLndhcm5PbmNlKFwiYXN5bmNJc1ZhbGlkIGlzIGRlcHJlY2F0ZWQ7IHBsZWFzZSB1c2Ugd2hlblZhbGlkIGluc3RlYWRcIiksIHRoaXMud2hlblZhbGlkKHsgZ3JvdXA6IHQsIGZvcmNlOiBlIH0pIH0sIF9maW5kUmVsYXRlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5vcHRpb25zLm11bHRpcGxlID8gaCh0aGlzLnBhcmVudC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIuY29uY2F0KHRoaXMub3B0aW9ucy5uYW1lc3BhY2UsICdtdWx0aXBsZT1cIicpLmNvbmNhdCh0aGlzLm9wdGlvbnMubXVsdGlwbGUsICdcIl0nKSkpIDogdGhpcy4kZWxlbWVudCB9IH07IGZ1bmN0aW9uIGModCkgeyBoLmV4dGVuZCghMCwgdGhpcywgdCkgfSBjLnByb3RvdHlwZSA9IHsgdmFsaWRhdGU6IGZ1bmN0aW9uICh0LCBlKSB7IGlmICh0aGlzLmZuKSByZXR1cm4gMyA8IGFyZ3VtZW50cy5sZW5ndGggJiYgKGUgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgLTEpKSwgdGhpcy5mbih0LCBlKTsgaWYgKEFycmF5LmlzQXJyYXkodCkpIHsgaWYgKCF0aGlzLnZhbGlkYXRlTXVsdGlwbGUpIHRocm93IFwiVmFsaWRhdG9yIGBcIiArIHRoaXMubmFtZSArIFwiYCBkb2VzIG5vdCBoYW5kbGUgbXVsdGlwbGUgdmFsdWVzXCI7IHJldHVybiB0aGlzLnZhbGlkYXRlTXVsdGlwbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9IHZhciBpID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTsgaWYgKHRoaXMudmFsaWRhdGVEYXRlICYmIGkuX2lzRGF0ZUlucHV0KCkpIHJldHVybiBhcmd1bWVudHNbMF0gPSBkLnBhcnNlLmRhdGUoYXJndW1lbnRzWzBdKSwgbnVsbCAhPT0gYXJndW1lbnRzWzBdICYmIHRoaXMudmFsaWRhdGVEYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IGlmICh0aGlzLnZhbGlkYXRlTnVtYmVyKSByZXR1cm4gIXQgfHwgIWlzTmFOKHQpICYmIChhcmd1bWVudHNbMF0gPSBwYXJzZUZsb2F0KGFyZ3VtZW50c1swXSksIHRoaXMudmFsaWRhdGVOdW1iZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7IGlmICh0aGlzLnZhbGlkYXRlU3RyaW5nKSByZXR1cm4gdGhpcy52YWxpZGF0ZVN0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB0aHJvdyBcIlZhbGlkYXRvciBgXCIgKyB0aGlzLm5hbWUgKyBcImAgb25seSBoYW5kbGVzIG11bHRpcGxlIHZhbHVlc1wiIH0sIHBhcnNlUmVxdWlyZW1lbnRzOiBmdW5jdGlvbiAodCwgZSkgeyBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgdCkgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0IDogW3RdOyB2YXIgaSA9IHRoaXMucmVxdWlyZW1lbnRUeXBlOyBpZiAoQXJyYXkuaXNBcnJheShpKSkgeyBmb3IgKHZhciByID0gZnVuY3Rpb24gKHQsIGUpIHsgdmFyIGkgPSB0Lm1hdGNoKC9eXFxzKlxcWyguKilcXF1cXHMqJC8pOyBpZiAoIWkpIHRocm93ICdSZXF1aXJlbWVudCBpcyBub3QgYW4gYXJyYXk6IFwiJyArIHQgKyAnXCInOyB2YXIgciA9IGlbMV0uc3BsaXQoXCIsXCIpLm1hcChkLnRyaW1TdHJpbmcpOyBpZiAoci5sZW5ndGggIT09IGUpIHRocm93IFwiUmVxdWlyZW1lbnQgaGFzIFwiICsgci5sZW5ndGggKyBcIiB2YWx1ZXMgd2hlbiBcIiArIGUgKyBcIiBhcmUgbmVlZGVkXCI7IHJldHVybiByIH0odCwgaS5sZW5ndGgpLCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspcltuXSA9IGQucGFyc2VSZXF1aXJlbWVudChpW25dLCByW25dKTsgcmV0dXJuIHIgfSByZXR1cm4gaC5pc1BsYWluT2JqZWN0KGkpID8gZnVuY3Rpb24gKHQsIGUsIGkpIHsgdmFyIHIgPSBudWxsLCBuID0ge307IGZvciAodmFyIHMgaW4gdCkgaWYgKHMpIHsgdmFyIGEgPSBpKHMpOyBcInN0cmluZ1wiID09IHR5cGVvZiBhICYmIChhID0gZC5wYXJzZVJlcXVpcmVtZW50KHRbc10sIGEpKSwgbltzXSA9IGEgfSBlbHNlIHIgPSBkLnBhcnNlUmVxdWlyZW1lbnQodFtzXSwgZSk7IHJldHVybiBbciwgbl0gfShpLCB0LCBlKSA6IFtkLnBhcnNlUmVxdWlyZW1lbnQoaSwgdCldIH0sIHJlcXVpcmVtZW50VHlwZTogXCJzdHJpbmdcIiwgcHJpb3JpdHk6IDIgfTsgZnVuY3Rpb24gYSh0LCBlKSB7IHRoaXMuX19jbGFzc19fID0gXCJWYWxpZGF0b3JSZWdpc3RyeVwiLCB0aGlzLmxvY2FsZSA9IFwiZW5cIiwgdGhpcy5pbml0KHQgfHwge30sIGUgfHwge30pIH0gdmFyIHAgPSB7IGVtYWlsOiAvXigoKFthLXpBLVpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpBLVpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16QS1aXXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16QS1aXXxcXGR8LXxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16QS1aXXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2EtekEtWl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpBLVpdfFxcZHwtfF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkkLywgbnVtYmVyOiAvXi0/KFxcZCpcXC4pP1xcZCsoZVstK10/XFxkKyk/JC9pLCBpbnRlZ2VyOiAvXi0/XFxkKyQvLCBkaWdpdHM6IC9eXFxkKyQvLCBhbHBoYW51bTogL15cXHcrJC9pLCBkYXRlOiB7IHRlc3Q6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBudWxsICE9PSBkLnBhcnNlLmRhdGUodCkgfSB9LCB1cmw6IG5ldyBSZWdFeHAoXCJeKD86KD86aHR0cHM/fGZ0cCk6Ly8pPyg/OlxcXFxTKyg/OjpcXFxcUyopP0ApPyg/Oig/OlsxLTldXFxcXGQ/fDFcXFxcZFxcXFxkfDJbMDFdXFxcXGR8MjJbMC0zXSkoPzpcXFxcLig/OjE/XFxcXGR7MSwyfXwyWzAtNF1cXFxcZHwyNVswLTVdKSl7Mn0oPzpcXFxcLig/OlsxLTldXFxcXGQ/fDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16QS1aXFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0tKikqW2EtekEtWlxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKykoPzpcXFxcLig/OlthLXpBLVpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XS0qKSpbYS16QS1aXFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0rKSooPzpcXFxcLig/OlthLXpBLVpcXFxcdTAwYTEtXFxcXHVmZmZmXXsyLH0pKSkoPzo6XFxcXGR7Miw1fSk/KD86L1xcXFxTKik/JFwiKSB9OyBwLnJhbmdlID0gcC5udW1iZXI7IGZ1bmN0aW9uIGYodCkgeyB2YXIgZSA9IChcIlwiICsgdCkubWF0Y2goLyg/OlxcLihcXGQrKSk/KD86W2VFXShbKy1dP1xcZCspKT8kLyk7IHJldHVybiBlID8gTWF0aC5tYXgoMCwgKGVbMV0gPyBlWzFdLmxlbmd0aCA6IDApIC0gKGVbMl0gPyArZVsyXSA6IDApKSA6IDAgfSBmdW5jdGlvbiBtKHMsIGEpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IGZvciAodmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoLCBpID0gbmV3IEFycmF5KDEgPCBlID8gZSAtIDEgOiAwKSwgciA9IDE7IHIgPCBlOyByKyspaVtyIC0gMV0gPSBhcmd1bWVudHNbcl07IHJldHVybiBpLnBvcCgpLCBhLmFwcGx5KHZvaWQgMCwgW3RdLmNvbmNhdCh1KChuID0gcywgaS5tYXAoZC5wYXJzZVtuXSkpKSkpOyB2YXIgbiB9IH0gZnVuY3Rpb24gZyh0KSB7IHJldHVybiB7IHZhbGlkYXRlRGF0ZTogbShcImRhdGVcIiwgdCksIHZhbGlkYXRlTnVtYmVyOiBtKFwibnVtYmVyXCIsIHQpLCByZXF1aXJlbWVudFR5cGU6IHQubGVuZ3RoIDw9IDIgPyBcInN0cmluZ1wiIDogW1wic3RyaW5nXCIsIFwic3RyaW5nXCJdLCBwcmlvcml0eTogMzAgfSB9IGEucHJvdG90eXBlID0geyBpbml0OiBmdW5jdGlvbiAodCwgZSkgeyBmb3IgKHZhciBpIGluIHRoaXMuY2F0YWxvZyA9IGUsIHRoaXMudmFsaWRhdG9ycyA9IGwoe30sIHRoaXMudmFsaWRhdG9ycyksIHQpIHRoaXMuYWRkVmFsaWRhdG9yKGksIHRbaV0uZm4sIHRbaV0ucHJpb3JpdHkpOyB3aW5kb3cuUGFyc2xleS50cmlnZ2VyKFwicGFyc2xleTp2YWxpZGF0b3I6aW5pdFwiKSB9LCBzZXRMb2NhbGU6IGZ1bmN0aW9uICh0KSB7IGlmICh2b2lkIDAgPT09IHRoaXMuY2F0YWxvZ1t0XSkgdGhyb3cgbmV3IEVycm9yKHQgKyBcIiBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBjYXRhbG9nXCIpOyByZXR1cm4gdGhpcy5sb2NhbGUgPSB0LCB0aGlzIH0sIGFkZENhdGFsb2c6IGZ1bmN0aW9uICh0LCBlLCBpKSB7IHJldHVybiBcIm9iamVjdFwiID09PSBuKGUpICYmICh0aGlzLmNhdGFsb2dbdF0gPSBlKSwgITAgPT09IGkgPyB0aGlzLnNldExvY2FsZSh0KSA6IHRoaXMgfSwgYWRkTWVzc2FnZTogZnVuY3Rpb24gKHQsIGUsIGkpIHsgcmV0dXJuIHZvaWQgMCA9PT0gdGhpcy5jYXRhbG9nW3RdICYmICh0aGlzLmNhdGFsb2dbdF0gPSB7fSksIHRoaXMuY2F0YWxvZ1t0XVtlXSA9IGksIHRoaXMgfSwgYWRkTWVzc2FnZXM6IGZ1bmN0aW9uICh0LCBlKSB7IGZvciAodmFyIGkgaW4gZSkgdGhpcy5hZGRNZXNzYWdlKHQsIGksIGVbaV0pOyByZXR1cm4gdGhpcyB9LCBhZGRWYWxpZGF0b3I6IGZ1bmN0aW9uICh0LCBlLCBpKSB7IGlmICh0aGlzLnZhbGlkYXRvcnNbdF0pIGQud2FybignVmFsaWRhdG9yIFwiJyArIHQgKyAnXCIgaXMgYWxyZWFkeSBkZWZpbmVkLicpOyBlbHNlIGlmIChzLmhhc093blByb3BlcnR5KHQpKSByZXR1cm4gdm9pZCBkLndhcm4oJ1wiJyArIHQgKyAnXCIgaXMgYSByZXN0cmljdGVkIGtleXdvcmQgYW5kIGlzIG5vdCBhIHZhbGlkIHZhbGlkYXRvciBuYW1lLicpOyByZXR1cm4gdGhpcy5fc2V0VmFsaWRhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfSwgaGFzVmFsaWRhdG9yOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gISF0aGlzLnZhbGlkYXRvcnNbdF0gfSwgdXBkYXRlVmFsaWRhdG9yOiBmdW5jdGlvbiAodCwgZSwgaSkgeyByZXR1cm4gdGhpcy52YWxpZGF0b3JzW3RdID8gdGhpcy5fc2V0VmFsaWRhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAoZC53YXJuKCdWYWxpZGF0b3IgXCInICsgdCArICdcIiBpcyBub3QgYWxyZWFkeSBkZWZpbmVkLicpLCB0aGlzLmFkZFZhbGlkYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB9LCByZW1vdmVWYWxpZGF0b3I6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0aGlzLnZhbGlkYXRvcnNbdF0gfHwgZC53YXJuKCdWYWxpZGF0b3IgXCInICsgdCArICdcIiBpcyBub3QgZGVmaW5lZC4nKSwgZGVsZXRlIHRoaXMudmFsaWRhdG9yc1t0XSwgdGhpcyB9LCBfc2V0VmFsaWRhdG9yOiBmdW5jdGlvbiAodCwgZSwgaSkgeyBmb3IgKHZhciByIGluIFwib2JqZWN0XCIgIT09IG4oZSkgJiYgKGUgPSB7IGZuOiBlLCBwcmlvcml0eTogaSB9KSwgZS52YWxpZGF0ZSB8fCAoZSA9IG5ldyBjKGUpKSwgKHRoaXMudmFsaWRhdG9yc1t0XSA9IGUpLm1lc3NhZ2VzIHx8IHt9KSB0aGlzLmFkZE1lc3NhZ2UociwgdCwgZS5tZXNzYWdlc1tyXSk7IHJldHVybiB0aGlzIH0sIGdldEVycm9yTWVzc2FnZTogZnVuY3Rpb24gKHQpIHsgdmFyIGU7IFwidHlwZVwiID09PSB0Lm5hbWUgPyBlID0gKHRoaXMuY2F0YWxvZ1t0aGlzLmxvY2FsZV1bdC5uYW1lXSB8fCB7fSlbdC5yZXF1aXJlbWVudHNdIDogZSA9IHRoaXMuZm9ybWF0TWVzc2FnZSh0aGlzLmNhdGFsb2dbdGhpcy5sb2NhbGVdW3QubmFtZV0sIHQucmVxdWlyZW1lbnRzKTsgcmV0dXJuIGUgfHwgdGhpcy5jYXRhbG9nW3RoaXMubG9jYWxlXS5kZWZhdWx0TWVzc2FnZSB8fCB0aGlzLmNhdGFsb2cuZW4uZGVmYXVsdE1lc3NhZ2UgfSwgZm9ybWF0TWVzc2FnZTogZnVuY3Rpb24gKHQsIGUpIHsgaWYgKFwib2JqZWN0XCIgIT09IG4oZSkpIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gdC5yZXBsYWNlKC8lcy9pLCBlKSA6IFwiXCI7IGZvciAodmFyIGkgaW4gZSkgdCA9IHRoaXMuZm9ybWF0TWVzc2FnZSh0LCBlW2ldKTsgcmV0dXJuIHQgfSwgdmFsaWRhdG9yczogeyBub3RibGFuazogeyB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIC9cXFMvLnRlc3QodCkgfSwgcHJpb3JpdHk6IDIgfSwgcmVxdWlyZWQ6IHsgdmFsaWRhdGVNdWx0aXBsZTogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDAgPCB0Lmxlbmd0aCB9LCB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIC9cXFMvLnRlc3QodCkgfSwgcHJpb3JpdHk6IDUxMiB9LCB0eXBlOiB7IHZhbGlkYXRlU3RyaW5nOiBmdW5jdGlvbiAodCwgZSwgaSkgeyB2YXIgciA9IDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gaSA/IGkgOiB7fSwgbiA9IHIuc3RlcCwgcyA9IHZvaWQgMCA9PT0gbiA/IFwiYW55XCIgOiBuLCBhID0gci5iYXNlLCBvID0gdm9pZCAwID09PSBhID8gMCA6IGEsIGwgPSBwW2VdOyBpZiAoIWwpIHRocm93IG5ldyBFcnJvcihcInZhbGlkYXRvciB0eXBlIGBcIiArIGUgKyBcImAgaXMgbm90IHN1cHBvcnRlZFwiKTsgaWYgKCF0KSByZXR1cm4gITA7IGlmICghbC50ZXN0KHQpKSByZXR1cm4gITE7IGlmIChcIm51bWJlclwiID09PSBlICYmICEvXmFueSQvaS50ZXN0KHMgfHwgXCJcIikpIHsgdmFyIHUgPSBOdW1iZXIodCksIGQgPSBNYXRoLm1heChmKHMpLCBmKG8pKTsgaWYgKGYodSkgPiBkKSByZXR1cm4gITE7IHZhciBoID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucm91bmQodCAqIE1hdGgucG93KDEwLCBkKSkgfTsgaWYgKChoKHUpIC0gaChvKSkgJSBoKHMpICE9IDApIHJldHVybiAhMSB9IHJldHVybiAhMCB9LCByZXF1aXJlbWVudFR5cGU6IHsgXCJcIjogXCJzdHJpbmdcIiwgc3RlcDogXCJzdHJpbmdcIiwgYmFzZTogXCJudW1iZXJcIiB9LCBwcmlvcml0eTogMjU2IH0sIHBhdHRlcm46IHsgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiAhdCB8fCBlLnRlc3QodCkgfSwgcmVxdWlyZW1lbnRUeXBlOiBcInJlZ2V4cFwiLCBwcmlvcml0eTogNjQgfSwgbWlubGVuZ3RoOiB7IHZhbGlkYXRlU3RyaW5nOiBmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gIXQgfHwgdC5sZW5ndGggPj0gZSB9LCByZXF1aXJlbWVudFR5cGU6IFwiaW50ZWdlclwiLCBwcmlvcml0eTogMzAgfSwgbWF4bGVuZ3RoOiB7IHZhbGlkYXRlU3RyaW5nOiBmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gdC5sZW5ndGggPD0gZSB9LCByZXF1aXJlbWVudFR5cGU6IFwiaW50ZWdlclwiLCBwcmlvcml0eTogMzAgfSwgbGVuZ3RoOiB7IHZhbGlkYXRlU3RyaW5nOiBmdW5jdGlvbiAodCwgZSwgaSkgeyByZXR1cm4gIXQgfHwgdC5sZW5ndGggPj0gZSAmJiB0Lmxlbmd0aCA8PSBpIH0sIHJlcXVpcmVtZW50VHlwZTogW1wiaW50ZWdlclwiLCBcImludGVnZXJcIl0sIHByaW9yaXR5OiAzMCB9LCBtaW5jaGVjazogeyB2YWxpZGF0ZU11bHRpcGxlOiBmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gdC5sZW5ndGggPj0gZSB9LCByZXF1aXJlbWVudFR5cGU6IFwiaW50ZWdlclwiLCBwcmlvcml0eTogMzAgfSwgbWF4Y2hlY2s6IHsgdmFsaWRhdGVNdWx0aXBsZTogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHQubGVuZ3RoIDw9IGUgfSwgcmVxdWlyZW1lbnRUeXBlOiBcImludGVnZXJcIiwgcHJpb3JpdHk6IDMwIH0sIGNoZWNrOiB7IHZhbGlkYXRlTXVsdGlwbGU6IGZ1bmN0aW9uICh0LCBlLCBpKSB7IHJldHVybiB0Lmxlbmd0aCA+PSBlICYmIHQubGVuZ3RoIDw9IGkgfSwgcmVxdWlyZW1lbnRUeXBlOiBbXCJpbnRlZ2VyXCIsIFwiaW50ZWdlclwiXSwgcHJpb3JpdHk6IDMwIH0sIG1pbjogZyhmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gZSA8PSB0IH0pLCBtYXg6IGcoZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHQgPD0gZSB9KSwgcmFuZ2U6IGcoZnVuY3Rpb24gKHQsIGUsIGkpIHsgcmV0dXJuIGUgPD0gdCAmJiB0IDw9IGkgfSksIGVxdWFsdG86IHsgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uICh0LCBlKSB7IGlmICghdCkgcmV0dXJuICEwOyB2YXIgaSA9IGgoZSk7IHJldHVybiBpLmxlbmd0aCA/IHQgPT09IGkudmFsKCkgOiB0ID09PSBlIH0sIHByaW9yaXR5OiAyNTYgfSwgZXV2YXRpbjogeyB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gKHQpIHsgaWYgKCF0KSByZXR1cm4gITA7IHJldHVybiAvXltBLVpdW0EtWl1bQS1aYS16MC05IC1dezIsfSQvLnRlc3QodCkgfSwgcHJpb3JpdHk6IDMwIH0gfSB9OyB2YXIgdiA9IHt9OyB2LkZvcm0gPSB7IF9hY3R1YWxpemVUcmlnZ2VyczogZnVuY3Rpb24gKCkgeyB2YXIgZSA9IHRoaXM7IHRoaXMuJGVsZW1lbnQub24oXCJzdWJtaXQuUGFyc2xleVwiLCBmdW5jdGlvbiAodCkgeyBlLm9uU3VibWl0VmFsaWRhdGUodCkgfSksIHRoaXMuJGVsZW1lbnQub24oXCJjbGljay5QYXJzbGV5XCIsIGQuX1N1Ym1pdFNlbGVjdG9yLCBmdW5jdGlvbiAodCkgeyBlLm9uU3VibWl0QnV0dG9uKHQpIH0pLCAhMSAhPT0gdGhpcy5vcHRpb25zLnVpRW5hYmxlZCAmJiB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm92YWxpZGF0ZVwiLCBcIlwiKSB9LCBmb2N1czogZnVuY3Rpb24gKCkgeyBpZiAoISh0aGlzLl9mb2N1c2VkRmllbGQgPSBudWxsKSA9PT0gdGhpcy52YWxpZGF0aW9uUmVzdWx0IHx8IFwibm9uZVwiID09PSB0aGlzLm9wdGlvbnMuZm9jdXMpIHJldHVybiBudWxsOyBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMuZmllbGRzLmxlbmd0aDsgdCsrKSB7IHZhciBlID0gdGhpcy5maWVsZHNbdF07IGlmICghMCAhPT0gZS52YWxpZGF0aW9uUmVzdWx0ICYmIDAgPCBlLnZhbGlkYXRpb25SZXN1bHQubGVuZ3RoICYmIHZvaWQgMCA9PT0gZS5vcHRpb25zLm5vRm9jdXMgJiYgKHRoaXMuX2ZvY3VzZWRGaWVsZCA9IGUuJGVsZW1lbnQsIFwiZmlyc3RcIiA9PT0gdGhpcy5vcHRpb25zLmZvY3VzKSkgYnJlYWsgfSByZXR1cm4gbnVsbCA9PT0gdGhpcy5fZm9jdXNlZEZpZWxkID8gbnVsbCA6IHRoaXMuX2ZvY3VzZWRGaWVsZC5mb2N1cygpIH0sIF9kZXN0cm95VUk6IGZ1bmN0aW9uICgpIHsgdGhpcy4kZWxlbWVudC5vZmYoXCIuUGFyc2xleVwiKSB9IH0sIHYuRmllbGQgPSB7IF9yZWZsb3dVSTogZnVuY3Rpb24gKCkgeyBpZiAodGhpcy5fYnVpbGRVSSgpLCB0aGlzLl91aSkgeyB2YXIgdCA9IGZ1bmN0aW9uIHQoZSwgaSwgcikgeyBmb3IgKHZhciBuID0gW10sIHMgPSBbXSwgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSsrKSB7IGZvciAodmFyIG8gPSAhMSwgbCA9IDA7IGwgPCBpLmxlbmd0aDsgbCsrKWlmIChlW2FdLmFzc2VydC5uYW1lID09PSBpW2xdLmFzc2VydC5uYW1lKSB7IG8gPSAhMDsgYnJlYWsgfSBvID8gcy5wdXNoKGVbYV0pIDogbi5wdXNoKGVbYV0pIH0gcmV0dXJuIHsga2VwdDogcywgYWRkZWQ6IG4sIHJlbW92ZWQ6IHIgPyBbXSA6IHQoaSwgZSwgITApLmFkZGVkIH0gfSh0aGlzLnZhbGlkYXRpb25SZXN1bHQsIHRoaXMuX3VpLmxhc3RWYWxpZGF0aW9uUmVzdWx0KTsgdGhpcy5fdWkubGFzdFZhbGlkYXRpb25SZXN1bHQgPSB0aGlzLnZhbGlkYXRpb25SZXN1bHQsIHRoaXMuX21hbmFnZVN0YXR1c0NsYXNzKCksIHRoaXMuX21hbmFnZUVycm9yc01lc3NhZ2VzKHQpLCB0aGlzLl9hY3R1YWxpemVUcmlnZ2VycygpLCAhdC5rZXB0Lmxlbmd0aCAmJiAhdC5hZGRlZC5sZW5ndGggfHwgdGhpcy5fZmFpbGVkT25jZSB8fCAodGhpcy5fZmFpbGVkT25jZSA9ICEwLCB0aGlzLl9hY3R1YWxpemVUcmlnZ2VycygpKSB9IH0sIGdldEVycm9yc01lc3NhZ2VzOiBmdW5jdGlvbiAoKSB7IGlmICghMCA9PT0gdGhpcy52YWxpZGF0aW9uUmVzdWx0KSByZXR1cm4gW107IGZvciAodmFyIHQgPSBbXSwgZSA9IDA7IGUgPCB0aGlzLnZhbGlkYXRpb25SZXN1bHQubGVuZ3RoOyBlKyspdC5wdXNoKHRoaXMudmFsaWRhdGlvblJlc3VsdFtlXS5lcnJvck1lc3NhZ2UgfHwgdGhpcy5fZ2V0RXJyb3JNZXNzYWdlKHRoaXMudmFsaWRhdGlvblJlc3VsdFtlXS5hc3NlcnQpKTsgcmV0dXJuIHQgfSwgYWRkRXJyb3I6IGZ1bmN0aW9uICh0LCBlKSB7IHZhciBpID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBlID8gZSA6IHt9LCByID0gaS5tZXNzYWdlLCBuID0gaS5hc3NlcnQsIHMgPSBpLnVwZGF0ZUNsYXNzLCBhID0gdm9pZCAwID09PSBzIHx8IHM7IHRoaXMuX2J1aWxkVUkoKSwgdGhpcy5fYWRkRXJyb3IodCwgeyBtZXNzYWdlOiByLCBhc3NlcnQ6IG4gfSksIGEgJiYgdGhpcy5fZXJyb3JDbGFzcygpIH0sIHVwZGF0ZUVycm9yOiBmdW5jdGlvbiAodCwgZSkgeyB2YXIgaSA9IDEgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gZSA/IGUgOiB7fSwgciA9IGkubWVzc2FnZSwgbiA9IGkuYXNzZXJ0LCBzID0gaS51cGRhdGVDbGFzcywgYSA9IHZvaWQgMCA9PT0gcyB8fCBzOyB0aGlzLl9idWlsZFVJKCksIHRoaXMuX3VwZGF0ZUVycm9yKHQsIHsgbWVzc2FnZTogciwgYXNzZXJ0OiBuIH0pLCBhICYmIHRoaXMuX2Vycm9yQ2xhc3MoKSB9LCByZW1vdmVFcnJvcjogZnVuY3Rpb24gKHQsIGUpIHsgdmFyIGkgPSAoMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBlID8gZSA6IHt9KS51cGRhdGVDbGFzcywgciA9IHZvaWQgMCA9PT0gaSB8fCBpOyB0aGlzLl9idWlsZFVJKCksIHRoaXMuX3JlbW92ZUVycm9yKHQpLCByICYmIHRoaXMuX21hbmFnZVN0YXR1c0NsYXNzKCkgfSwgX21hbmFnZVN0YXR1c0NsYXNzOiBmdW5jdGlvbiAoKSB7IHRoaXMuaGFzQ29uc3RyYWludHMoKSAmJiB0aGlzLm5lZWRzVmFsaWRhdGlvbigpICYmICEwID09PSB0aGlzLnZhbGlkYXRpb25SZXN1bHQgPyB0aGlzLl9zdWNjZXNzQ2xhc3MoKSA6IDAgPCB0aGlzLnZhbGlkYXRpb25SZXN1bHQubGVuZ3RoID8gdGhpcy5fZXJyb3JDbGFzcygpIDogdGhpcy5fcmVzZXRDbGFzcygpIH0sIF9tYW5hZ2VFcnJvcnNNZXNzYWdlczogZnVuY3Rpb24gKHQpIHsgaWYgKHZvaWQgMCA9PT0gdGhpcy5vcHRpb25zLmVycm9yc01lc3NhZ2VzRGlzYWJsZWQpIHsgaWYgKHZvaWQgMCAhPT0gdGhpcy5vcHRpb25zLmVycm9yTWVzc2FnZSkgcmV0dXJuIHQuYWRkZWQubGVuZ3RoIHx8IHQua2VwdC5sZW5ndGggPyAodGhpcy5faW5zZXJ0RXJyb3JXcmFwcGVyKCksIDAgPT09IHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLmZpbmQoXCIucGFyc2xleS1jdXN0b20tZXJyb3ItbWVzc2FnZVwiKS5sZW5ndGggJiYgdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIuYXBwZW5kKGgodGhpcy5vcHRpb25zLmVycm9yVGVtcGxhdGUpLmFkZENsYXNzKFwicGFyc2xleS1jdXN0b20tZXJyb3ItbWVzc2FnZVwiKSksIHRoaXMuX3VpLiRlcnJvckNsYXNzSGFuZGxlci5hdHRyKFwiYXJpYS1kZXNjcmliZWRieVwiLCB0aGlzLl91aS5lcnJvcnNXcmFwcGVySWQpLCB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5hZGRDbGFzcyhcImZpbGxlZFwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIiwgXCJmYWxzZVwiKS5maW5kKFwiLnBhcnNsZXktY3VzdG9tLWVycm9yLW1lc3NhZ2VcIikuaHRtbCh0aGlzLm9wdGlvbnMuZXJyb3JNZXNzYWdlKSkgOiAodGhpcy5fdWkuJGVycm9yQ2xhc3NIYW5kbGVyLnJlbW92ZUF0dHIoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpLCB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5yZW1vdmVDbGFzcyhcImZpbGxlZFwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpLmZpbmQoXCIucGFyc2xleS1jdXN0b20tZXJyb3ItbWVzc2FnZVwiKS5yZW1vdmUoKSk7IGZvciAodmFyIGUgPSAwOyBlIDwgdC5yZW1vdmVkLmxlbmd0aDsgZSsrKXRoaXMuX3JlbW92ZUVycm9yKHQucmVtb3ZlZFtlXS5hc3NlcnQubmFtZSk7IGZvciAoZSA9IDA7IGUgPCB0LmFkZGVkLmxlbmd0aDsgZSsrKXRoaXMuX2FkZEVycm9yKHQuYWRkZWRbZV0uYXNzZXJ0Lm5hbWUsIHsgbWVzc2FnZTogdC5hZGRlZFtlXS5lcnJvck1lc3NhZ2UsIGFzc2VydDogdC5hZGRlZFtlXS5hc3NlcnQgfSk7IGZvciAoZSA9IDA7IGUgPCB0LmtlcHQubGVuZ3RoOyBlKyspdGhpcy5fdXBkYXRlRXJyb3IodC5rZXB0W2VdLmFzc2VydC5uYW1lLCB7IG1lc3NhZ2U6IHQua2VwdFtlXS5lcnJvck1lc3NhZ2UsIGFzc2VydDogdC5rZXB0W2VdLmFzc2VydCB9KSB9IH0sIF9hZGRFcnJvcjogZnVuY3Rpb24gKHQsIGUpIHsgdmFyIGkgPSBlLm1lc3NhZ2UsIHIgPSBlLmFzc2VydDsgdGhpcy5faW5zZXJ0RXJyb3JXcmFwcGVyKCksIHRoaXMuX3VpLiRlcnJvckNsYXNzSGFuZGxlci5hdHRyKFwiYXJpYS1kZXNjcmliZWRieVwiLCB0aGlzLl91aS5lcnJvcnNXcmFwcGVySWQpLCB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5hZGRDbGFzcyhcImZpbGxlZFwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIiwgXCJmYWxzZVwiKS5hcHBlbmQoaCh0aGlzLm9wdGlvbnMuZXJyb3JUZW1wbGF0ZSkuYWRkQ2xhc3MoXCJwYXJzbGV5LVwiICsgdCkuaHRtbChpIHx8IHRoaXMuX2dldEVycm9yTWVzc2FnZShyKSkpIH0sIF91cGRhdGVFcnJvcjogZnVuY3Rpb24gKHQsIGUpIHsgdmFyIGkgPSBlLm1lc3NhZ2UsIHIgPSBlLmFzc2VydDsgdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIuYWRkQ2xhc3MoXCJmaWxsZWRcIikuZmluZChcIi5wYXJzbGV5LVwiICsgdCkuaHRtbChpIHx8IHRoaXMuX2dldEVycm9yTWVzc2FnZShyKSkgfSwgX3JlbW92ZUVycm9yOiBmdW5jdGlvbiAodCkgeyB0aGlzLl91aS4kZXJyb3JDbGFzc0hhbmRsZXIucmVtb3ZlQXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIiksIHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLnJlbW92ZUNsYXNzKFwiZmlsbGVkXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIikuZmluZChcIi5wYXJzbGV5LVwiICsgdCkucmVtb3ZlKCkgfSwgX2dldEVycm9yTWVzc2FnZTogZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSB0Lm5hbWUgKyBcIk1lc3NhZ2VcIjsgcmV0dXJuIHZvaWQgMCAhPT0gdGhpcy5vcHRpb25zW2VdID8gd2luZG93LlBhcnNsZXkuZm9ybWF0TWVzc2FnZSh0aGlzLm9wdGlvbnNbZV0sIHQucmVxdWlyZW1lbnRzKSA6IHdpbmRvdy5QYXJzbGV5LmdldEVycm9yTWVzc2FnZSh0KSB9LCBfYnVpbGRVSTogZnVuY3Rpb24gKCkgeyBpZiAoIXRoaXMuX3VpICYmICExICE9PSB0aGlzLm9wdGlvbnMudWlFbmFibGVkKSB7IHZhciB0ID0ge307IHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLm5hbWVzcGFjZSArIFwiaWRcIiwgdGhpcy5fX2lkX18pLCB0LiRlcnJvckNsYXNzSGFuZGxlciA9IHRoaXMuX21hbmFnZUNsYXNzSGFuZGxlcigpLCB0LmVycm9yc1dyYXBwZXJJZCA9IFwicGFyc2xleS1pZC1cIiArICh0aGlzLm9wdGlvbnMubXVsdGlwbGUgPyBcIm11bHRpcGxlLVwiICsgdGhpcy5vcHRpb25zLm11bHRpcGxlIDogdGhpcy5fX2lkX18pLCB0LiRlcnJvcnNXcmFwcGVyID0gaCh0aGlzLm9wdGlvbnMuZXJyb3JzV3JhcHBlcikuYXR0cihcImlkXCIsIHQuZXJyb3JzV3JhcHBlcklkKSwgdC5sYXN0VmFsaWRhdGlvblJlc3VsdCA9IFtdLCB0LnZhbGlkYXRpb25JbmZvcm1hdGlvblZpc2libGUgPSAhMSwgdGhpcy5fdWkgPSB0IH0gfSwgX21hbmFnZUNsYXNzSGFuZGxlcjogZnVuY3Rpb24gKCkgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlciAmJiBoKHRoaXMub3B0aW9ucy5jbGFzc0hhbmRsZXIpLmxlbmd0aCkgcmV0dXJuIGgodGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlcik7IHZhciB0ID0gdGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlcjsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHRoaXMub3B0aW9ucy5jbGFzc0hhbmRsZXIgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW5kb3dbdGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlcl0gJiYgKHQgPSB3aW5kb3dbdGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlcl0pLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQpIHsgdmFyIGUgPSB0LmNhbGwodGhpcywgdGhpcyk7IGlmICh2b2lkIDAgIT09IGUgJiYgZS5sZW5ndGgpIHJldHVybiBlIH0gZWxzZSB7IGlmIChcIm9iamVjdFwiID09PSBuKHQpICYmIHQgaW5zdGFuY2VvZiBqUXVlcnkgJiYgdC5sZW5ndGgpIHJldHVybiB0OyB0ICYmIGQud2FybihcIlRoZSBjbGFzcyBoYW5kbGVyIGBcIiArIHQgKyBcImAgZG9lcyBub3QgZXhpc3QgaW4gRE9NIG5vciBhcyBhIGdsb2JhbCBKUyBmdW5jdGlvblwiKSB9IHJldHVybiB0aGlzLl9pbnB1dEhvbGRlcigpIH0sIF9pbnB1dEhvbGRlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5vcHRpb25zLm11bHRpcGxlICYmIFwiU0VMRUNUXCIgIT09IHRoaXMuZWxlbWVudC5ub2RlTmFtZSA/IHRoaXMuJGVsZW1lbnQucGFyZW50KCkgOiB0aGlzLiRlbGVtZW50IH0sIF9pbnNlcnRFcnJvcldyYXBwZXI6IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSB0aGlzLm9wdGlvbnMuZXJyb3JzQ29udGFpbmVyOyBpZiAoMCAhPT0gdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIucGFyZW50KCkubGVuZ3RoKSByZXR1cm4gdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIucGFyZW50KCk7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0KSB7IGlmIChoKHQpLmxlbmd0aCkgcmV0dXJuIGgodCkuYXBwZW5kKHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyKTsgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW5kb3dbdF0gPyB0ID0gd2luZG93W3RdIDogZC53YXJuKFwiVGhlIGVycm9ycyBjb250YWluZXIgYFwiICsgdCArIFwiYCBkb2VzIG5vdCBleGlzdCBpbiBET00gbm9yIGFzIGEgZ2xvYmFsIEpTIGZ1bmN0aW9uXCIpIH0gcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCAmJiAodCA9IHQuY2FsbCh0aGlzLCB0aGlzKSksIFwib2JqZWN0XCIgPT09IG4odCkgJiYgdC5sZW5ndGggPyB0LmFwcGVuZCh0aGlzLl91aS4kZXJyb3JzV3JhcHBlcikgOiB0aGlzLl9pbnB1dEhvbGRlcigpLmFmdGVyKHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyKSB9LCBfYWN0dWFsaXplVHJpZ2dlcnM6IGZ1bmN0aW9uICgpIHsgdmFyIHQsIGUgPSB0aGlzLCBpID0gdGhpcy5fZmluZFJlbGF0ZWQoKTsgaS5vZmYoXCIuUGFyc2xleVwiKSwgdGhpcy5fZmFpbGVkT25jZSA/IGkub24oZC5uYW1lc3BhY2VFdmVudHModGhpcy5vcHRpb25zLnRyaWdnZXJBZnRlckZhaWx1cmUsIFwiUGFyc2xleVwiKSwgZnVuY3Rpb24gKCkgeyBlLl92YWxpZGF0ZUlmTmVlZGVkKCkgfSkgOiAodCA9IGQubmFtZXNwYWNlRXZlbnRzKHRoaXMub3B0aW9ucy50cmlnZ2VyLCBcIlBhcnNsZXlcIikpICYmIGkub24odCwgZnVuY3Rpb24gKHQpIHsgZS5fdmFsaWRhdGVJZk5lZWRlZCh0KSB9KSB9LCBfdmFsaWRhdGVJZk5lZWRlZDogZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSB0aGlzOyB0ICYmIC9rZXl8aW5wdXQvLnRlc3QodC50eXBlKSAmJiAoIXRoaXMuX3VpIHx8ICF0aGlzLl91aS52YWxpZGF0aW9uSW5mb3JtYXRpb25WaXNpYmxlKSAmJiB0aGlzLmdldFZhbHVlKCkubGVuZ3RoIDw9IHRoaXMub3B0aW9ucy52YWxpZGF0aW9uVGhyZXNob2xkIHx8ICh0aGlzLm9wdGlvbnMuZGVib3VuY2UgPyAod2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9kZWJvdW5jZWQpLCB0aGlzLl9kZWJvdW5jZWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBlLnZhbGlkYXRlKCkgfSwgdGhpcy5vcHRpb25zLmRlYm91bmNlKSkgOiB0aGlzLnZhbGlkYXRlKCkpIH0sIF9yZXNldFVJOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2ZhaWxlZE9uY2UgPSAhMSwgdGhpcy5fYWN0dWFsaXplVHJpZ2dlcnMoKSwgdm9pZCAwICE9PSB0aGlzLl91aSAmJiAodGhpcy5fdWkuJGVycm9yc1dyYXBwZXIucmVtb3ZlQ2xhc3MoXCJmaWxsZWRcIikuY2hpbGRyZW4oKS5yZW1vdmUoKSwgdGhpcy5fcmVzZXRDbGFzcygpLCB0aGlzLl91aS5sYXN0VmFsaWRhdGlvblJlc3VsdCA9IFtdLCB0aGlzLl91aS52YWxpZGF0aW9uSW5mb3JtYXRpb25WaXNpYmxlID0gITEpIH0sIF9kZXN0cm95VUk6IGZ1bmN0aW9uICgpIHsgdGhpcy5fcmVzZXRVSSgpLCB2b2lkIDAgIT09IHRoaXMuX3VpICYmIHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLnJlbW92ZSgpLCBkZWxldGUgdGhpcy5fdWkgfSwgX3N1Y2Nlc3NDbGFzczogZnVuY3Rpb24gKCkgeyB0aGlzLl91aS52YWxpZGF0aW9uSW5mb3JtYXRpb25WaXNpYmxlID0gITAsIHRoaXMuX3VpLiRlcnJvckNsYXNzSGFuZGxlci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnN1Y2Nlc3NDbGFzcykgfSwgX2Vycm9yQ2xhc3M6IGZ1bmN0aW9uICgpIHsgdGhpcy5fdWkudmFsaWRhdGlvbkluZm9ybWF0aW9uVmlzaWJsZSA9ICEwLCB0aGlzLl91aS4kZXJyb3JDbGFzc0hhbmRsZXIucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnN1Y2Nlc3NDbGFzcykuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpIH0sIF9yZXNldENsYXNzOiBmdW5jdGlvbiAoKSB7IHRoaXMuX3VpLiRlcnJvckNsYXNzSGFuZGxlci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuc3VjY2Vzc0NsYXNzKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykgfSB9OyBmdW5jdGlvbiB5KHQsIGUsIGkpIHsgdGhpcy5fX2NsYXNzX18gPSBcIkZvcm1cIiwgdGhpcy5lbGVtZW50ID0gdCwgdGhpcy4kZWxlbWVudCA9IGgodCksIHRoaXMuZG9tT3B0aW9ucyA9IGUsIHRoaXMub3B0aW9ucyA9IGksIHRoaXMucGFyZW50ID0gd2luZG93LlBhcnNsZXksIHRoaXMuZmllbGRzID0gW10sIHRoaXMudmFsaWRhdGlvblJlc3VsdCA9IG51bGwgfSB2YXIgXyA9IHsgcGVuZGluZzogbnVsbCwgcmVzb2x2ZWQ6ICEwLCByZWplY3RlZDogITEgfTsgeS5wcm90b3R5cGUgPSB7IG9uU3VibWl0VmFsaWRhdGU6IGZ1bmN0aW9uICh0KSB7IHZhciBlID0gdGhpczsgaWYgKCEwICE9PSB0LnBhcnNsZXkpIHsgdmFyIGkgPSB0aGlzLl9zdWJtaXRTb3VyY2UgfHwgdGhpcy4kZWxlbWVudC5maW5kKGQuX1N1Ym1pdFNlbGVjdG9yKVswXTsgaWYgKHRoaXMuX3N1Ym1pdFNvdXJjZSA9IG51bGwsIHRoaXMuJGVsZW1lbnQuZmluZChcIi5wYXJzbGV5LXN5bnRoZXRpYy1zdWJtaXQtYnV0dG9uXCIpLnByb3AoXCJkaXNhYmxlZFwiLCAhMCksICFpIHx8IG51bGwgPT09IGkuZ2V0QXR0cmlidXRlKFwiZm9ybW5vdmFsaWRhdGVcIikpIHsgd2luZG93LlBhcnNsZXkuX3JlbW90ZUNhY2hlID0ge307IHZhciByID0gdGhpcy53aGVuVmFsaWRhdGUoeyBldmVudDogdCB9KTsgXCJyZXNvbHZlZFwiID09PSByLnN0YXRlKCkgJiYgITEgIT09IHRoaXMuX3RyaWdnZXIoXCJzdWJtaXRcIikgfHwgKHQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIHQucHJldmVudERlZmF1bHQoKSwgXCJwZW5kaW5nXCIgPT09IHIuc3RhdGUoKSAmJiByLmRvbmUoZnVuY3Rpb24gKCkgeyBlLl9zdWJtaXQoaSkgfSkpIH0gfSB9LCBvblN1Ym1pdEJ1dHRvbjogZnVuY3Rpb24gKHQpIHsgdGhpcy5fc3VibWl0U291cmNlID0gdC5jdXJyZW50VGFyZ2V0IH0sIF9zdWJtaXQ6IGZ1bmN0aW9uICh0KSB7IGlmICghMSAhPT0gdGhpcy5fdHJpZ2dlcihcInN1Ym1pdFwiKSkgeyBpZiAodCkgeyB2YXIgZSA9IHRoaXMuJGVsZW1lbnQuZmluZChcIi5wYXJzbGV5LXN5bnRoZXRpYy1zdWJtaXQtYnV0dG9uXCIpLnByb3AoXCJkaXNhYmxlZFwiLCAhMSk7IDAgPT09IGUubGVuZ3RoICYmIChlID0gaCgnPGlucHV0IGNsYXNzPVwicGFyc2xleS1zeW50aGV0aWMtc3VibWl0LWJ1dHRvblwiIHR5cGU9XCJoaWRkZW5cIj4nKS5hcHBlbmRUbyh0aGlzLiRlbGVtZW50KSksIGUuYXR0cih7IG5hbWU6IHQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSwgdmFsdWU6IHQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfSkgfSB0aGlzLiRlbGVtZW50LnRyaWdnZXIobChoLkV2ZW50KFwic3VibWl0XCIpLCB7IHBhcnNsZXk6ICEwIH0pKSB9IH0sIHZhbGlkYXRlOiBmdW5jdGlvbiAodCkgeyBpZiAoMSA8PSBhcmd1bWVudHMubGVuZ3RoICYmICFoLmlzUGxhaW5PYmplY3QodCkpIHsgZC53YXJuT25jZShcIkNhbGxpbmcgdmFsaWRhdGUgb24gYSBwYXJzbGV5IGZvcm0gd2l0aG91dCBwYXNzaW5nIGFyZ3VtZW50cyBhcyBhbiBvYmplY3QgaXMgZGVwcmVjYXRlZC5cIik7IHZhciBlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgdCA9IHsgZ3JvdXA6IGVbMF0sIGZvcmNlOiBlWzFdLCBldmVudDogZVsyXSB9IH0gcmV0dXJuIF9bdGhpcy53aGVuVmFsaWRhdGUodCkuc3RhdGUoKV0gfSwgd2hlblZhbGlkYXRlOiBmdW5jdGlvbiAodCkgeyB2YXIgZSwgaSA9IHRoaXMsIHIgPSAwIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IHQgPyB0IDoge30sIG4gPSByLmdyb3VwLCBzID0gci5mb3JjZSwgYSA9IHIuZXZlbnQ7ICh0aGlzLnN1Ym1pdEV2ZW50ID0gYSkgJiYgKHRoaXMuc3VibWl0RXZlbnQgPSBsKHt9LCBhLCB7IHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7IGQud2Fybk9uY2UoXCJVc2luZyBgdGhpcy5zdWJtaXRFdmVudC5wcmV2ZW50RGVmYXVsdCgpYCBpcyBkZXByZWNhdGVkOyBpbnN0ZWFkLCBjYWxsIGB0aGlzLnZhbGlkYXRpb25SZXN1bHQgPSBmYWxzZWBcIiksIGkudmFsaWRhdGlvblJlc3VsdCA9ICExIH0gfSkpLCB0aGlzLnZhbGlkYXRpb25SZXN1bHQgPSAhMCwgdGhpcy5fdHJpZ2dlcihcInZhbGlkYXRlXCIpLCB0aGlzLl9yZWZyZXNoRmllbGRzKCk7IHZhciBvID0gdGhpcy5fd2l0aG91dFJlYWN0dWFsaXppbmdGb3JtT3B0aW9ucyhmdW5jdGlvbiAoKSB7IHJldHVybiBoLm1hcChpLmZpZWxkcywgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQud2hlblZhbGlkYXRlKHsgZm9yY2U6IHMsIGdyb3VwOiBuIH0pIH0pIH0pOyByZXR1cm4gKGUgPSBkLmFsbChvKS5kb25lKGZ1bmN0aW9uICgpIHsgaS5fdHJpZ2dlcihcInN1Y2Nlc3NcIikgfSkuZmFpbChmdW5jdGlvbiAoKSB7IGkudmFsaWRhdGlvblJlc3VsdCA9ICExLCBpLmZvY3VzKCksIGkuX3RyaWdnZXIoXCJlcnJvclwiKSB9KS5hbHdheXMoZnVuY3Rpb24gKCkgeyBpLl90cmlnZ2VyKFwidmFsaWRhdGVkXCIpIH0pKS5waXBlLmFwcGx5KGUsIHUodGhpcy5fcGlwZUFjY29yZGluZ1RvVmFsaWRhdGlvblJlc3VsdCgpKSkgfSwgaXNWYWxpZDogZnVuY3Rpb24gKHQpIHsgaWYgKDEgPD0gYXJndW1lbnRzLmxlbmd0aCAmJiAhaC5pc1BsYWluT2JqZWN0KHQpKSB7IGQud2Fybk9uY2UoXCJDYWxsaW5nIGlzVmFsaWQgb24gYSBwYXJzbGV5IGZvcm0gd2l0aG91dCBwYXNzaW5nIGFyZ3VtZW50cyBhcyBhbiBvYmplY3QgaXMgZGVwcmVjYXRlZC5cIik7IHZhciBlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgdCA9IHsgZ3JvdXA6IGVbMF0sIGZvcmNlOiBlWzFdIH0gfSByZXR1cm4gX1t0aGlzLndoZW5WYWxpZCh0KS5zdGF0ZSgpXSB9LCB3aGVuVmFsaWQ6IGZ1bmN0aW9uICh0KSB7IHZhciBlID0gdGhpcywgaSA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gdCA/IHQgOiB7fSwgciA9IGkuZ3JvdXAsIG4gPSBpLmZvcmNlOyB0aGlzLl9yZWZyZXNoRmllbGRzKCk7IHZhciBzID0gdGhpcy5fd2l0aG91dFJlYWN0dWFsaXppbmdGb3JtT3B0aW9ucyhmdW5jdGlvbiAoKSB7IHJldHVybiBoLm1hcChlLmZpZWxkcywgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQud2hlblZhbGlkKHsgZ3JvdXA6IHIsIGZvcmNlOiBuIH0pIH0pIH0pOyByZXR1cm4gZC5hbGwocykgfSwgcmVmcmVzaDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVmcmVzaEZpZWxkcygpLCB0aGlzIH0sIHJlc2V0OiBmdW5jdGlvbiAoKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgdGhpcy5maWVsZHMubGVuZ3RoOyB0KyspdGhpcy5maWVsZHNbdF0ucmVzZXQoKTsgdGhpcy5fdHJpZ2dlcihcInJlc2V0XCIpIH0sIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHsgdGhpcy5fZGVzdHJveVVJKCk7IGZvciAodmFyIHQgPSAwOyB0IDwgdGhpcy5maWVsZHMubGVuZ3RoOyB0KyspdGhpcy5maWVsZHNbdF0uZGVzdHJveSgpOyB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoXCJQYXJzbGV5XCIpLCB0aGlzLl90cmlnZ2VyKFwiZGVzdHJveVwiKSB9LCBfcmVmcmVzaEZpZWxkczogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5hY3R1YWxpemVPcHRpb25zKCkuX2JpbmRGaWVsZHMoKSB9LCBfYmluZEZpZWxkczogZnVuY3Rpb24gKCkgeyB2YXIgbiA9IHRoaXMsIHQgPSB0aGlzLmZpZWxkczsgcmV0dXJuIHRoaXMuZmllbGRzID0gW10sIHRoaXMuZmllbGRzTWFwcGVkQnlJZCA9IHt9LCB0aGlzLl93aXRob3V0UmVhY3R1YWxpemluZ0Zvcm1PcHRpb25zKGZ1bmN0aW9uICgpIHsgbi4kZWxlbWVudC5maW5kKG4ub3B0aW9ucy5pbnB1dHMpLm5vdChuLm9wdGlvbnMuZXhjbHVkZWQpLm5vdChcIltcIi5jb25jYXQobi5vcHRpb25zLm5hbWVzcGFjZSwgXCJleGNsdWRlZD10cnVlXVwiKSkuZWFjaChmdW5jdGlvbiAodCwgZSkgeyB2YXIgaSA9IG5ldyB3aW5kb3cuUGFyc2xleS5GYWN0b3J5KGUsIHt9LCBuKTsgaWYgKFwiRmllbGRcIiA9PT0gaS5fX2NsYXNzX18gfHwgXCJGaWVsZE11bHRpcGxlXCIgPT09IGkuX19jbGFzc19fKSB7IHZhciByID0gaS5fX2NsYXNzX18gKyBcIi1cIiArIGkuX19pZF9fOyB2b2lkIDAgPT09IG4uZmllbGRzTWFwcGVkQnlJZFtyXSAmJiAobi5maWVsZHNNYXBwZWRCeUlkW3JdID0gaSwgbi5maWVsZHMucHVzaChpKSkgfSB9KSwgaC5lYWNoKGQuZGlmZmVyZW5jZSh0LCBuLmZpZWxkcyksIGZ1bmN0aW9uICh0LCBlKSB7IGUucmVzZXQoKSB9KSB9KSwgdGhpcyB9LCBfd2l0aG91dFJlYWN0dWFsaXppbmdGb3JtT3B0aW9uczogZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSB0aGlzLmFjdHVhbGl6ZU9wdGlvbnM7IHRoaXMuYWN0dWFsaXplT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMgfTsgdmFyIGkgPSB0KCk7IHJldHVybiB0aGlzLmFjdHVhbGl6ZU9wdGlvbnMgPSBlLCBpIH0sIF90cmlnZ2VyOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdGhpcy50cmlnZ2VyKFwiZm9ybTpcIiArIHQpIH0gfTsgZnVuY3Rpb24gYih0LCBlLCBpLCByLCBuKSB7IHZhciBzID0gd2luZG93LlBhcnNsZXkuX3ZhbGlkYXRvclJlZ2lzdHJ5LnZhbGlkYXRvcnNbZV0sIGEgPSBuZXcgYyhzKTsgbCh0aGlzLCB7IHZhbGlkYXRvcjogYSwgbmFtZTogZSwgcmVxdWlyZW1lbnRzOiBpLCBwcmlvcml0eTogciA9IHIgfHwgdC5vcHRpb25zW2UgKyBcIlByaW9yaXR5XCJdIHx8IGEucHJpb3JpdHksIGlzRG9tQ29uc3RyYWludDogbiA9ICEwID09PSBuIH0pLCB0aGlzLl9wYXJzZVJlcXVpcmVtZW50cyh0Lm9wdGlvbnMpIH0gZnVuY3Rpb24gdyh0LCBlLCBpLCByKSB7IHRoaXMuX19jbGFzc19fID0gXCJGaWVsZFwiLCB0aGlzLmVsZW1lbnQgPSB0LCB0aGlzLiRlbGVtZW50ID0gaCh0KSwgdm9pZCAwICE9PSByICYmICh0aGlzLnBhcmVudCA9IHIpLCB0aGlzLm9wdGlvbnMgPSBpLCB0aGlzLmRvbU9wdGlvbnMgPSBlLCB0aGlzLmNvbnN0cmFpbnRzID0gW10sIHRoaXMuY29uc3RyYWludHNCeU5hbWUgPSB7fSwgdGhpcy52YWxpZGF0aW9uUmVzdWx0ID0gITAsIHRoaXMuX2JpbmRDb25zdHJhaW50cygpIH0gdmFyIEYgPSB7IHBlbmRpbmc6IG51bGwsIHJlc29sdmVkOiAhMCwgcmVqZWN0ZWQ6ICEoYi5wcm90b3R5cGUgPSB7IHZhbGlkYXRlOiBmdW5jdGlvbiAodCwgZSkgeyB2YXIgaTsgcmV0dXJuIChpID0gdGhpcy52YWxpZGF0b3IpLnZhbGlkYXRlLmFwcGx5KGksIFt0XS5jb25jYXQodSh0aGlzLnJlcXVpcmVtZW50TGlzdCksIFtlXSkpIH0sIF9wYXJzZVJlcXVpcmVtZW50czogZnVuY3Rpb24gKGkpIHsgdmFyIHIgPSB0aGlzOyB0aGlzLnJlcXVpcmVtZW50TGlzdCA9IHRoaXMudmFsaWRhdG9yLnBhcnNlUmVxdWlyZW1lbnRzKHRoaXMucmVxdWlyZW1lbnRzLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gaVtyLm5hbWUgKyAoKGUgPSB0KVswXS50b1VwcGVyQ2FzZSgpICsgZS5zbGljZSgxKSldOyB2YXIgZSB9KSB9IH0pIH07IHcucHJvdG90eXBlID0geyB2YWxpZGF0ZTogZnVuY3Rpb24gKHQpIHsgMSA8PSBhcmd1bWVudHMubGVuZ3RoICYmICFoLmlzUGxhaW5PYmplY3QodCkgJiYgKGQud2Fybk9uY2UoXCJDYWxsaW5nIHZhbGlkYXRlIG9uIGEgcGFyc2xleSBmaWVsZCB3aXRob3V0IHBhc3NpbmcgYXJndW1lbnRzIGFzIGFuIG9iamVjdCBpcyBkZXByZWNhdGVkLlwiKSwgdCA9IHsgb3B0aW9uczogdCB9KTsgdmFyIGUgPSB0aGlzLndoZW5WYWxpZGF0ZSh0KTsgaWYgKCFlKSByZXR1cm4gITA7IHN3aXRjaCAoZS5zdGF0ZSgpKSB7IGNhc2UgXCJwZW5kaW5nXCI6IHJldHVybiBudWxsOyBjYXNlIFwicmVzb2x2ZWRcIjogcmV0dXJuICEwOyBjYXNlIFwicmVqZWN0ZWRcIjogcmV0dXJuIHRoaXMudmFsaWRhdGlvblJlc3VsdCB9IH0sIHdoZW5WYWxpZGF0ZTogZnVuY3Rpb24gKHQpIHsgdmFyIGUsIGkgPSB0aGlzLCByID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSB0ID8gdCA6IHt9LCBuID0gci5mb3JjZSwgcyA9IHIuZ3JvdXA7IGlmICh0aGlzLnJlZnJlc2goKSwgIXMgfHwgdGhpcy5faXNJbkdyb3VwKHMpKSByZXR1cm4gdGhpcy52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fdHJpZ2dlcihcInZhbGlkYXRlXCIpLCAoZSA9IHRoaXMud2hlblZhbGlkKHsgZm9yY2U6IG4sIHZhbHVlOiB0aGlzLnZhbHVlLCBfcmVmcmVzaGVkOiAhMCB9KS5hbHdheXMoZnVuY3Rpb24gKCkgeyBpLl9yZWZsb3dVSSgpIH0pLmRvbmUoZnVuY3Rpb24gKCkgeyBpLl90cmlnZ2VyKFwic3VjY2Vzc1wiKSB9KS5mYWlsKGZ1bmN0aW9uICgpIHsgaS5fdHJpZ2dlcihcImVycm9yXCIpIH0pLmFsd2F5cyhmdW5jdGlvbiAoKSB7IGkuX3RyaWdnZXIoXCJ2YWxpZGF0ZWRcIikgfSkpLnBpcGUuYXBwbHkoZSwgdSh0aGlzLl9waXBlQWNjb3JkaW5nVG9WYWxpZGF0aW9uUmVzdWx0KCkpKSB9LCBoYXNDb25zdHJhaW50czogZnVuY3Rpb24gKCkgeyByZXR1cm4gMCAhPT0gdGhpcy5jb25zdHJhaW50cy5sZW5ndGggfSwgbmVlZHNWYWxpZGF0aW9uOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdm9pZCAwID09PSB0ICYmICh0ID0gdGhpcy5nZXRWYWx1ZSgpKSwgISghdC5sZW5ndGggJiYgIXRoaXMuX2lzUmVxdWlyZWQoKSAmJiB2b2lkIDAgPT09IHRoaXMub3B0aW9ucy52YWxpZGF0ZUlmRW1wdHkpIH0sIF9pc0luR3JvdXA6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5ncm91cCkgPyAtMSAhPT0gaC5pbkFycmF5KHQsIHRoaXMub3B0aW9ucy5ncm91cCkgOiB0aGlzLm9wdGlvbnMuZ3JvdXAgPT09IHQgfSwgaXNWYWxpZDogZnVuY3Rpb24gKHQpIHsgaWYgKDEgPD0gYXJndW1lbnRzLmxlbmd0aCAmJiAhaC5pc1BsYWluT2JqZWN0KHQpKSB7IGQud2Fybk9uY2UoXCJDYWxsaW5nIGlzVmFsaWQgb24gYSBwYXJzbGV5IGZpZWxkIHdpdGhvdXQgcGFzc2luZyBhcmd1bWVudHMgYXMgYW4gb2JqZWN0IGlzIGRlcHJlY2F0ZWQuXCIpOyB2YXIgZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7IHQgPSB7IGZvcmNlOiBlWzBdLCB2YWx1ZTogZVsxXSB9IH0gdmFyIGkgPSB0aGlzLndoZW5WYWxpZCh0KTsgcmV0dXJuICFpIHx8IEZbaS5zdGF0ZSgpXSB9LCB3aGVuVmFsaWQ6IGZ1bmN0aW9uICh0KSB7IHZhciByID0gdGhpcywgZSA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gdCA/IHQgOiB7fSwgaSA9IGUuZm9yY2UsIG4gPSB2b2lkIDAgIT09IGkgJiYgaSwgcyA9IGUudmFsdWUsIGEgPSBlLmdyb3VwOyBpZiAoZS5fcmVmcmVzaGVkIHx8IHRoaXMucmVmcmVzaCgpLCAhYSB8fCB0aGlzLl9pc0luR3JvdXAoYSkpIHsgaWYgKHRoaXMudmFsaWRhdGlvblJlc3VsdCA9ICEwLCAhdGhpcy5oYXNDb25zdHJhaW50cygpKSByZXR1cm4gaC53aGVuKCk7IGlmIChudWxsID09IHMgJiYgKHMgPSB0aGlzLmdldFZhbHVlKCkpLCAhdGhpcy5uZWVkc1ZhbGlkYXRpb24ocykgJiYgITAgIT09IG4pIHJldHVybiBoLndoZW4oKTsgdmFyIG8gPSB0aGlzLl9nZXRHcm91cGVkQ29uc3RyYWludHMoKSwgbCA9IFtdOyByZXR1cm4gaC5lYWNoKG8sIGZ1bmN0aW9uICh0LCBlKSB7IHZhciBpID0gZC5hbGwoaC5tYXAoZSwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHIuX3ZhbGlkYXRlQ29uc3RyYWludChzLCB0KSB9KSk7IGlmIChsLnB1c2goaSksIFwicmVqZWN0ZWRcIiA9PT0gaS5zdGF0ZSgpKSByZXR1cm4gITEgfSksIGQuYWxsKGwpIH0gfSwgX3ZhbGlkYXRlQ29uc3RyYWludDogZnVuY3Rpb24gKHQsIGUpIHsgdmFyIGkgPSB0aGlzLCByID0gZS52YWxpZGF0ZSh0LCB0aGlzKTsgcmV0dXJuICExID09PSByICYmIChyID0gaC5EZWZlcnJlZCgpLnJlamVjdCgpKSwgZC5hbGwoW3JdKS5mYWlsKGZ1bmN0aW9uICh0KSB7IGkudmFsaWRhdGlvblJlc3VsdCBpbnN0YW5jZW9mIEFycmF5IHx8IChpLnZhbGlkYXRpb25SZXN1bHQgPSBbXSksIGkudmFsaWRhdGlvblJlc3VsdC5wdXNoKHsgYXNzZXJ0OiBlLCBlcnJvck1lc3NhZ2U6IFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgdCB9KSB9KSB9LCBnZXRWYWx1ZTogZnVuY3Rpb24gKCkgeyB2YXIgdDsgcmV0dXJuIG51bGwgPT0gKHQgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRoaXMub3B0aW9ucy52YWx1ZSA/IHRoaXMub3B0aW9ucy52YWx1ZSh0aGlzKSA6IHZvaWQgMCAhPT0gdGhpcy5vcHRpb25zLnZhbHVlID8gdGhpcy5vcHRpb25zLnZhbHVlIDogdGhpcy4kZWxlbWVudC52YWwoKSkgPyBcIlwiIDogdGhpcy5faGFuZGxlV2hpdGVzcGFjZSh0KSB9LCByZXNldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzZXRVSSgpLCB0aGlzLl90cmlnZ2VyKFwicmVzZXRcIikgfSwgZGVzdHJveTogZnVuY3Rpb24gKCkgeyB0aGlzLl9kZXN0cm95VUkoKSwgdGhpcy4kZWxlbWVudC5yZW1vdmVEYXRhKFwiUGFyc2xleVwiKSwgdGhpcy4kZWxlbWVudC5yZW1vdmVEYXRhKFwiRmllbGRNdWx0aXBsZVwiKSwgdGhpcy5fdHJpZ2dlcihcImRlc3Ryb3lcIikgfSwgcmVmcmVzaDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVmcmVzaENvbnN0cmFpbnRzKCksIHRoaXMgfSwgX3JlZnJlc2hDb25zdHJhaW50czogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5hY3R1YWxpemVPcHRpb25zKCkuX2JpbmRDb25zdHJhaW50cygpIH0sIHJlZnJlc2hDb25zdHJhaW50czogZnVuY3Rpb24gKCkgeyByZXR1cm4gZC53YXJuT25jZShcIlBhcnNsZXkncyByZWZyZXNoQ29uc3RyYWludHMgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSByZWZyZXNoXCIpLCB0aGlzLnJlZnJlc2goKSB9LCBhZGRDb25zdHJhaW50OiBmdW5jdGlvbiAodCwgZSwgaSwgcikgeyBpZiAod2luZG93LlBhcnNsZXkuX3ZhbGlkYXRvclJlZ2lzdHJ5LnZhbGlkYXRvcnNbdF0pIHsgdmFyIG4gPSBuZXcgYih0aGlzLCB0LCBlLCBpLCByKTsgXCJ1bmRlZmluZWRcIiAhPT0gdGhpcy5jb25zdHJhaW50c0J5TmFtZVtuLm5hbWVdICYmIHRoaXMucmVtb3ZlQ29uc3RyYWludChuLm5hbWUpLCB0aGlzLmNvbnN0cmFpbnRzLnB1c2gobiksIHRoaXMuY29uc3RyYWludHNCeU5hbWVbbi5uYW1lXSA9IG4gfSByZXR1cm4gdGhpcyB9LCByZW1vdmVDb25zdHJhaW50OiBmdW5jdGlvbiAodCkgeyBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuY29uc3RyYWludHMubGVuZ3RoOyBlKyspaWYgKHQgPT09IHRoaXMuY29uc3RyYWludHNbZV0ubmFtZSkgeyB0aGlzLmNvbnN0cmFpbnRzLnNwbGljZShlLCAxKTsgYnJlYWsgfSByZXR1cm4gZGVsZXRlIHRoaXMuY29uc3RyYWludHNCeU5hbWVbdF0sIHRoaXMgfSwgdXBkYXRlQ29uc3RyYWludDogZnVuY3Rpb24gKHQsIGUsIGkpIHsgcmV0dXJuIHRoaXMucmVtb3ZlQ29uc3RyYWludCh0KS5hZGRDb25zdHJhaW50KHQsIGUsIGkpIH0sIF9iaW5kQ29uc3RyYWludHM6IGZ1bmN0aW9uICgpIHsgZm9yICh2YXIgdCA9IFtdLCBlID0ge30sIGkgPSAwOyBpIDwgdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKykhMSA9PT0gdGhpcy5jb25zdHJhaW50c1tpXS5pc0RvbUNvbnN0cmFpbnQgJiYgKHQucHVzaCh0aGlzLmNvbnN0cmFpbnRzW2ldKSwgZVt0aGlzLmNvbnN0cmFpbnRzW2ldLm5hbWVdID0gdGhpcy5jb25zdHJhaW50c1tpXSk7IGZvciAodmFyIHIgaW4gdGhpcy5jb25zdHJhaW50cyA9IHQsIHRoaXMuY29uc3RyYWludHNCeU5hbWUgPSBlLCB0aGlzLm9wdGlvbnMpIHRoaXMuYWRkQ29uc3RyYWludChyLCB0aGlzLm9wdGlvbnNbcl0sIHZvaWQgMCwgITApOyByZXR1cm4gdGhpcy5fYmluZEh0bWw1Q29uc3RyYWludHMoKSB9LCBfYmluZEh0bWw1Q29uc3RyYWludHM6IGZ1bmN0aW9uICgpIHsgbnVsbCAhPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInJlcXVpcmVkXCIpICYmIHRoaXMuYWRkQ29uc3RyYWludChcInJlcXVpcmVkXCIsICEwLCB2b2lkIDAsICEwKSwgbnVsbCAhPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInBhdHRlcm5cIikgJiYgdGhpcy5hZGRDb25zdHJhaW50KFwicGF0dGVyblwiLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGF0dGVyblwiKSwgdm9pZCAwLCAhMCk7IHZhciB0ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm1pblwiKSwgZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtYXhcIik7IG51bGwgIT09IHQgJiYgbnVsbCAhPT0gZSA/IHRoaXMuYWRkQ29uc3RyYWludChcInJhbmdlXCIsIFt0LCBlXSwgdm9pZCAwLCAhMCkgOiBudWxsICE9PSB0ID8gdGhpcy5hZGRDb25zdHJhaW50KFwibWluXCIsIHQsIHZvaWQgMCwgITApIDogbnVsbCAhPT0gZSAmJiB0aGlzLmFkZENvbnN0cmFpbnQoXCJtYXhcIiwgZSwgdm9pZCAwLCAhMCksIG51bGwgIT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtaW5sZW5ndGhcIikgJiYgbnVsbCAhPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm1heGxlbmd0aFwiKSA/IHRoaXMuYWRkQ29uc3RyYWludChcImxlbmd0aFwiLCBbdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm1pbmxlbmd0aFwiKSwgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm1heGxlbmd0aFwiKV0sIHZvaWQgMCwgITApIDogbnVsbCAhPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm1pbmxlbmd0aFwiKSA/IHRoaXMuYWRkQ29uc3RyYWludChcIm1pbmxlbmd0aFwiLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibWlubGVuZ3RoXCIpLCB2b2lkIDAsICEwKSA6IG51bGwgIT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtYXhsZW5ndGhcIikgJiYgdGhpcy5hZGRDb25zdHJhaW50KFwibWF4bGVuZ3RoXCIsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtYXhsZW5ndGhcIiksIHZvaWQgMCwgITApOyB2YXIgaSA9IGQuZ2V0VHlwZSh0aGlzLmVsZW1lbnQpOyByZXR1cm4gXCJudW1iZXJcIiA9PT0gaSA/IHRoaXMuYWRkQ29uc3RyYWludChcInR5cGVcIiwgW1wibnVtYmVyXCIsIHsgc3RlcDogdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInN0ZXBcIikgfHwgXCIxXCIsIGJhc2U6IHQgfHwgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIH1dLCB2b2lkIDAsICEwKSA6IC9eKGVtYWlsfHVybHxyYW5nZXxkYXRlKSQvaS50ZXN0KGkpID8gdGhpcy5hZGRDb25zdHJhaW50KFwidHlwZVwiLCBpLCB2b2lkIDAsICEwKSA6IHRoaXMgfSwgX2lzUmVxdWlyZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZvaWQgMCAhPT0gdGhpcy5jb25zdHJhaW50c0J5TmFtZS5yZXF1aXJlZCAmJiAhMSAhPT0gdGhpcy5jb25zdHJhaW50c0J5TmFtZS5yZXF1aXJlZC5yZXF1aXJlbWVudHMgfSwgX3RyaWdnZXI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0aGlzLnRyaWdnZXIoXCJmaWVsZDpcIiArIHQpIH0sIF9oYW5kbGVXaGl0ZXNwYWNlOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gITAgPT09IHRoaXMub3B0aW9ucy50cmltVmFsdWUgJiYgZC53YXJuT25jZSgnZGF0YS1wYXJzbGV5LXRyaW0tdmFsdWU9XCJ0cnVlXCIgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBkYXRhLXBhcnNsZXktd2hpdGVzcGFjZT1cInRyaW1cIicpLCBcInNxdWlzaFwiID09PSB0aGlzLm9wdGlvbnMud2hpdGVzcGFjZSAmJiAodCA9IHQucmVwbGFjZSgvXFxzezIsfS9nLCBcIiBcIikpLCBcInRyaW1cIiAhPT0gdGhpcy5vcHRpb25zLndoaXRlc3BhY2UgJiYgXCJzcXVpc2hcIiAhPT0gdGhpcy5vcHRpb25zLndoaXRlc3BhY2UgJiYgITAgIT09IHRoaXMub3B0aW9ucy50cmltVmFsdWUgfHwgKHQgPSBkLnRyaW1TdHJpbmcodCkpLCB0IH0sIF9pc0RhdGVJbnB1dDogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IHRoaXMuY29uc3RyYWludHNCeU5hbWUudHlwZTsgcmV0dXJuIHQgJiYgXCJkYXRlXCIgPT09IHQucmVxdWlyZW1lbnRzIH0sIF9nZXRHcm91cGVkQ29uc3RyYWludHM6IGZ1bmN0aW9uICgpIHsgaWYgKCExID09PSB0aGlzLm9wdGlvbnMucHJpb3JpdHlFbmFibGVkKSByZXR1cm4gW3RoaXMuY29uc3RyYWludHNdOyBmb3IgKHZhciB0ID0gW10sIGUgPSB7fSwgaSA9IDA7IGkgPCB0aGlzLmNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7IHZhciByID0gdGhpcy5jb25zdHJhaW50c1tpXS5wcmlvcml0eTsgZVtyXSB8fCB0LnB1c2goZVtyXSA9IFtdKSwgZVtyXS5wdXNoKHRoaXMuY29uc3RyYWludHNbaV0pIH0gcmV0dXJuIHQuc29ydChmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gZVswXS5wcmlvcml0eSAtIHRbMF0ucHJpb3JpdHkgfSksIHQgfSB9OyBmdW5jdGlvbiBDKCkgeyB0aGlzLl9fY2xhc3NfXyA9IFwiRmllbGRNdWx0aXBsZVwiIH0gQy5wcm90b3R5cGUgPSB7IGFkZEVsZW1lbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0aGlzLiRlbGVtZW50cy5wdXNoKHQpLCB0aGlzIH0sIF9yZWZyZXNoQ29uc3RyYWludHM6IGZ1bmN0aW9uICgpIHsgdmFyIHQ7IGlmICh0aGlzLmNvbnN0cmFpbnRzID0gW10sIFwiU0VMRUNUXCIgPT09IHRoaXMuZWxlbWVudC5ub2RlTmFtZSkgcmV0dXJuIHRoaXMuYWN0dWFsaXplT3B0aW9ucygpLl9iaW5kQ29uc3RyYWludHMoKSwgdGhpczsgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLiRlbGVtZW50cy5sZW5ndGg7IGUrKylpZiAoaChcImh0bWxcIikuaGFzKHRoaXMuJGVsZW1lbnRzW2VdKS5sZW5ndGgpIHsgdCA9IHRoaXMuJGVsZW1lbnRzW2VdLmRhdGEoXCJGaWVsZE11bHRpcGxlXCIpLl9yZWZyZXNoQ29uc3RyYWludHMoKS5jb25zdHJhaW50czsgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKXRoaXMuYWRkQ29uc3RyYWludCh0W2ldLm5hbWUsIHRbaV0ucmVxdWlyZW1lbnRzLCB0W2ldLnByaW9yaXR5LCB0W2ldLmlzRG9tQ29uc3RyYWludCkgfSBlbHNlIHRoaXMuJGVsZW1lbnRzLnNwbGljZShlLCAxKTsgcmV0dXJuIHRoaXMgfSwgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdGhpcy5vcHRpb25zLnZhbHVlKSByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlKHRoaXMpOyBpZiAodm9pZCAwICE9PSB0aGlzLm9wdGlvbnMudmFsdWUpIHJldHVybiB0aGlzLm9wdGlvbnMudmFsdWU7IGlmIChcIklOUFVUXCIgPT09IHRoaXMuZWxlbWVudC5ub2RlTmFtZSkgeyB2YXIgdCA9IGQuZ2V0VHlwZSh0aGlzLmVsZW1lbnQpOyBpZiAoXCJyYWRpb1wiID09PSB0KSByZXR1cm4gdGhpcy5fZmluZFJlbGF0ZWQoKS5maWx0ZXIoXCI6Y2hlY2tlZFwiKS52YWwoKSB8fCBcIlwiOyBpZiAoXCJjaGVja2JveFwiID09PSB0KSB7IHZhciBlID0gW107IHJldHVybiB0aGlzLl9maW5kUmVsYXRlZCgpLmZpbHRlcihcIjpjaGVja2VkXCIpLmVhY2goZnVuY3Rpb24gKCkgeyBlLnB1c2goaCh0aGlzKS52YWwoKSkgfSksIGUgfSB9IHJldHVybiBcIlNFTEVDVFwiID09PSB0aGlzLmVsZW1lbnQubm9kZU5hbWUgJiYgbnVsbCA9PT0gdGhpcy4kZWxlbWVudC52YWwoKSA/IFtdIDogdGhpcy4kZWxlbWVudC52YWwoKSB9LCBfaW5pdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kZWxlbWVudHMgPSBbdGhpcy4kZWxlbWVudF0sIHRoaXMgfSB9OyBmdW5jdGlvbiBBKHQsIGUsIGkpIHsgdGhpcy5lbGVtZW50ID0gdCwgdGhpcy4kZWxlbWVudCA9IGgodCk7IHZhciByID0gdGhpcy4kZWxlbWVudC5kYXRhKFwiUGFyc2xleVwiKTsgaWYgKHIpIHJldHVybiB2b2lkIDAgIT09IGkgJiYgci5wYXJlbnQgPT09IHdpbmRvdy5QYXJzbGV5ICYmIChyLnBhcmVudCA9IGksIHIuX3Jlc2V0T3B0aW9ucyhyLm9wdGlvbnMpKSwgXCJvYmplY3RcIiA9PT0gbihlKSAmJiBsKHIub3B0aW9ucywgZSksIHI7IGlmICghdGhpcy4kZWxlbWVudC5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IGJpbmQgUGFyc2xleSBvbiBhbiBleGlzdGluZyBlbGVtZW50LlwiKTsgaWYgKHZvaWQgMCAhPT0gaSAmJiBcIkZvcm1cIiAhPT0gaS5fX2NsYXNzX18pIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBpbnN0YW5jZSBtdXN0IGJlIGEgRm9ybSBpbnN0YW5jZVwiKTsgcmV0dXJuIHRoaXMucGFyZW50ID0gaSB8fCB3aW5kb3cuUGFyc2xleSwgdGhpcy5pbml0KGUpIH0gQS5wcm90b3R5cGUgPSB7IGluaXQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0aGlzLl9fY2xhc3NfXyA9IFwiUGFyc2xleVwiLCB0aGlzLl9fdmVyc2lvbl9fID0gXCIyLjkuMlwiLCB0aGlzLl9faWRfXyA9IGQuZ2VuZXJhdGVJRCgpLCB0aGlzLl9yZXNldE9wdGlvbnModCksIFwiRk9STVwiID09PSB0aGlzLmVsZW1lbnQubm9kZU5hbWUgfHwgZC5jaGVja0F0dHIodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMubmFtZXNwYWNlLCBcInZhbGlkYXRlXCIpICYmICF0aGlzLiRlbGVtZW50LmlzKHRoaXMub3B0aW9ucy5pbnB1dHMpID8gdGhpcy5iaW5kKFwicGFyc2xleUZvcm1cIikgOiB0aGlzLmlzTXVsdGlwbGUoKSA/IHRoaXMuaGFuZGxlTXVsdGlwbGUoKSA6IHRoaXMuYmluZChcInBhcnNsZXlGaWVsZFwiKSB9LCBpc011bHRpcGxlOiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gZC5nZXRUeXBlKHRoaXMuZWxlbWVudCk7IHJldHVybiBcInJhZGlvXCIgPT09IHQgfHwgXCJjaGVja2JveFwiID09PSB0IHx8IFwiU0VMRUNUXCIgPT09IHRoaXMuZWxlbWVudC5ub2RlTmFtZSAmJiBudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgfSwgaGFuZGxlTXVsdGlwbGU6IGZ1bmN0aW9uICgpIHsgdmFyIHQsIGUsIHIgPSB0aGlzOyBpZiAodGhpcy5vcHRpb25zLm11bHRpcGxlID0gdGhpcy5vcHRpb25zLm11bHRpcGxlIHx8ICh0ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm5hbWVcIikpIHx8IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSwgXCJTRUxFQ1RcIiA9PT0gdGhpcy5lbGVtZW50Lm5vZGVOYW1lICYmIG51bGwgIT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSkgcmV0dXJuIHRoaXMub3B0aW9ucy5tdWx0aXBsZSA9IHRoaXMub3B0aW9ucy5tdWx0aXBsZSB8fCB0aGlzLl9faWRfXywgdGhpcy5iaW5kKFwicGFyc2xleUZpZWxkTXVsdGlwbGVcIik7IGlmICghdGhpcy5vcHRpb25zLm11bHRpcGxlKSByZXR1cm4gZC53YXJuKFwiVG8gYmUgYm91bmQgYnkgUGFyc2xleSwgYSByYWRpbywgYSBjaGVja2JveCBhbmQgYSBtdWx0aXBsZSBzZWxlY3QgaW5wdXQgbXVzdCBoYXZlIGVpdGhlciBhIG5hbWUgb3IgYSBtdWx0aXBsZSBvcHRpb24uXCIsIHRoaXMuJGVsZW1lbnQpLCB0aGlzOyB0aGlzLm9wdGlvbnMubXVsdGlwbGUgPSB0aGlzLm9wdGlvbnMubXVsdGlwbGUucmVwbGFjZSgvKDp8XFwufFxcW3xcXF18XFx7fFxcfXxcXCQpL2csIFwiXCIpLCB0ICYmIGgoJ2lucHV0W25hbWU9XCInICsgdCArICdcIl0nKS5lYWNoKGZ1bmN0aW9uICh0LCBlKSB7IHZhciBpID0gZC5nZXRUeXBlKGUpOyBcInJhZGlvXCIgIT09IGkgJiYgXCJjaGVja2JveFwiICE9PSBpIHx8IGUuc2V0QXR0cmlidXRlKHIub3B0aW9ucy5uYW1lc3BhY2UgKyBcIm11bHRpcGxlXCIsIHIub3B0aW9ucy5tdWx0aXBsZSkgfSk7IGZvciAodmFyIGkgPSB0aGlzLl9maW5kUmVsYXRlZCgpLCBuID0gMDsgbiA8IGkubGVuZ3RoOyBuKyspaWYgKHZvaWQgMCAhPT0gKGUgPSBoKGkuZ2V0KG4pKS5kYXRhKFwiUGFyc2xleVwiKSkpIHsgdGhpcy4kZWxlbWVudC5kYXRhKFwiRmllbGRNdWx0aXBsZVwiKSB8fCBlLmFkZEVsZW1lbnQodGhpcy4kZWxlbWVudCk7IGJyZWFrIH0gcmV0dXJuIHRoaXMuYmluZChcInBhcnNsZXlGaWVsZFwiLCAhMCksIGUgfHwgdGhpcy5iaW5kKFwicGFyc2xleUZpZWxkTXVsdGlwbGVcIikgfSwgYmluZDogZnVuY3Rpb24gKHQsIGUpIHsgdmFyIGk7IHN3aXRjaCAodCkgeyBjYXNlIFwicGFyc2xleUZvcm1cIjogaSA9IGguZXh0ZW5kKG5ldyB5KHRoaXMuZWxlbWVudCwgdGhpcy5kb21PcHRpb25zLCB0aGlzLm9wdGlvbnMpLCBuZXcgciwgd2luZG93LlBhcnNsZXlFeHRlbmQpLl9iaW5kRmllbGRzKCk7IGJyZWFrOyBjYXNlIFwicGFyc2xleUZpZWxkXCI6IGkgPSBoLmV4dGVuZChuZXcgdyh0aGlzLmVsZW1lbnQsIHRoaXMuZG9tT3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLnBhcmVudCksIG5ldyByLCB3aW5kb3cuUGFyc2xleUV4dGVuZCk7IGJyZWFrOyBjYXNlIFwicGFyc2xleUZpZWxkTXVsdGlwbGVcIjogaSA9IGguZXh0ZW5kKG5ldyB3KHRoaXMuZWxlbWVudCwgdGhpcy5kb21PcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMucGFyZW50KSwgbmV3IEMsIG5ldyByLCB3aW5kb3cuUGFyc2xleUV4dGVuZCkuX2luaXQoKTsgYnJlYWs7IGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcih0ICsgXCJpcyBub3QgYSBzdXBwb3J0ZWQgUGFyc2xleSB0eXBlXCIpIH1yZXR1cm4gdGhpcy5vcHRpb25zLm11bHRpcGxlICYmIGQuc2V0QXR0cih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5uYW1lc3BhY2UsIFwibXVsdGlwbGVcIiwgdGhpcy5vcHRpb25zLm11bHRpcGxlKSwgdm9pZCAwICE9PSBlID8gdGhpcy4kZWxlbWVudC5kYXRhKFwiRmllbGRNdWx0aXBsZVwiLCBpKSA6ICh0aGlzLiRlbGVtZW50LmRhdGEoXCJQYXJzbGV5XCIsIGkpLCBpLl9hY3R1YWxpemVUcmlnZ2VycygpLCBpLl90cmlnZ2VyKFwiaW5pdFwiKSksIGkgfSB9OyB2YXIgRSA9IGguZm4uanF1ZXJ5LnNwbGl0KFwiLlwiKTsgaWYgKHBhcnNlSW50KEVbMF0pIDw9IDEgJiYgcGFyc2VJbnQoRVsxXSkgPCA4KSB0aHJvdyBcIlRoZSBsb2FkZWQgdmVyc2lvbiBvZiBqUXVlcnkgaXMgdG9vIG9sZC4gUGxlYXNlIHVwZ3JhZGUgdG8gMS44Lnggb3IgYmV0dGVyLlwiOyBFLmZvckVhY2ggfHwgZC53YXJuKFwiUGFyc2xleSByZXF1aXJlcyBFUzUgdG8gcnVuIHByb3Blcmx5LiBQbGVhc2UgaW5jbHVkZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cIik7IHZhciB4ID0gbChuZXcgciwgeyBlbGVtZW50OiBkb2N1bWVudCwgJGVsZW1lbnQ6IGgoZG9jdW1lbnQpLCBhY3R1YWxpemVPcHRpb25zOiBudWxsLCBfcmVzZXRPcHRpb25zOiBudWxsLCBGYWN0b3J5OiBBLCB2ZXJzaW9uOiBcIjIuOS4yXCIgfSk7IGwody5wcm90b3R5cGUsIHYuRmllbGQsIHIucHJvdG90eXBlKSwgbCh5LnByb3RvdHlwZSwgdi5Gb3JtLCByLnByb3RvdHlwZSksIGwoQS5wcm90b3R5cGUsIHIucHJvdG90eXBlKSwgaC5mbi5wYXJzbGV5ID0gaC5mbi5wc2x5ID0gZnVuY3Rpb24gKHQpIHsgaWYgKDEgPCB0aGlzLmxlbmd0aCkgeyB2YXIgZSA9IFtdOyByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgZS5wdXNoKGgodGhpcykucGFyc2xleSh0KSkgfSksIGUgfSBpZiAoMCAhPSB0aGlzLmxlbmd0aCkgcmV0dXJuIG5ldyBBKHRoaXNbMF0sIHQpIH0sIHZvaWQgMCA9PT0gd2luZG93LlBhcnNsZXlFeHRlbmQgJiYgKHdpbmRvdy5QYXJzbGV5RXh0ZW5kID0ge30pLCB4Lm9wdGlvbnMgPSBsKGQub2JqZWN0Q3JlYXRlKHMpLCB3aW5kb3cuUGFyc2xleUNvbmZpZyksIHdpbmRvdy5QYXJzbGV5Q29uZmlnID0geC5vcHRpb25zLCB3aW5kb3cuUGFyc2xleSA9IHdpbmRvdy5wc2x5ID0geCwgeC5VdGlscyA9IGQsIHdpbmRvdy5QYXJzbGV5VXRpbHMgPSB7fSwgaC5lYWNoKGQsIGZ1bmN0aW9uICh0LCBlKSB7IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiAod2luZG93LlBhcnNsZXlVdGlsc1t0XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQud2Fybk9uY2UoXCJBY2Nlc3NpbmcgYHdpbmRvdy5QYXJzbGV5VXRpbHNgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgd2luZG93LlBhcnNsZXkuVXRpbHNgIGluc3RlYWQuXCIpLCBkW3RdLmFwcGx5KGQsIGFyZ3VtZW50cykgfSkgfSk7IHZhciAkID0gd2luZG93LlBhcnNsZXkuX3ZhbGlkYXRvclJlZ2lzdHJ5ID0gbmV3IGEod2luZG93LlBhcnNsZXlDb25maWcudmFsaWRhdG9ycywgd2luZG93LlBhcnNsZXlDb25maWcuaTE4bik7IHdpbmRvdy5QYXJzbGV5VmFsaWRhdG9yID0ge30sIGguZWFjaChcInNldExvY2FsZSBhZGRDYXRhbG9nIGFkZE1lc3NhZ2UgYWRkTWVzc2FnZXMgZ2V0RXJyb3JNZXNzYWdlIGZvcm1hdE1lc3NhZ2UgYWRkVmFsaWRhdG9yIHVwZGF0ZVZhbGlkYXRvciByZW1vdmVWYWxpZGF0b3IgaGFzVmFsaWRhdG9yXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiAodCwgZSkgeyB3aW5kb3cuUGFyc2xleVtlXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICRbZV0uYXBwbHkoJCwgYXJndW1lbnRzKSB9LCB3aW5kb3cuUGFyc2xleVZhbGlkYXRvcltlXSA9IGZ1bmN0aW9uICgpIHsgdmFyIHQ7IHJldHVybiBkLndhcm5PbmNlKFwiQWNjZXNzaW5nIHRoZSBtZXRob2QgJ1wiLmNvbmNhdChlLCBcIicgdGhyb3VnaCBWYWxpZGF0b3IgaXMgZGVwcmVjYXRlZC4gU2ltcGx5IGNhbGwgJ3dpbmRvdy5QYXJzbGV5LlwiKS5jb25jYXQoZSwgXCIoLi4uKSdcIikpLCAodCA9IHdpbmRvdy5QYXJzbGV5KVtlXS5hcHBseSh0LCBhcmd1bWVudHMpIH0gfSksIHdpbmRvdy5QYXJzbGV5LlVJID0gdiwgd2luZG93LlBhcnNsZXlVSSA9IHsgcmVtb3ZlRXJyb3I6IGZ1bmN0aW9uICh0LCBlLCBpKSB7IHZhciByID0gITAgIT09IGk7IHJldHVybiBkLndhcm5PbmNlKFwiQWNjZXNzaW5nIFVJIGlzIGRlcHJlY2F0ZWQuIENhbGwgJ3JlbW92ZUVycm9yJyBvbiB0aGUgaW5zdGFuY2UgZGlyZWN0bHkuIFBsZWFzZSBjb21tZW50IGluIGlzc3VlIDEwNzMgYXMgdG8geW91ciBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QuXCIpLCB0LnJlbW92ZUVycm9yKGUsIHsgdXBkYXRlQ2xhc3M6IHIgfSkgfSwgZ2V0RXJyb3JzTWVzc2FnZXM6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBkLndhcm5PbmNlKFwiQWNjZXNzaW5nIFVJIGlzIGRlcHJlY2F0ZWQuIENhbGwgJ2dldEVycm9yc01lc3NhZ2VzJyBvbiB0aGUgaW5zdGFuY2UgZGlyZWN0bHkuXCIpLCB0LmdldEVycm9yc01lc3NhZ2VzKCkgfSB9LCBoLmVhY2goXCJhZGRFcnJvciB1cGRhdGVFcnJvclwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24gKHQsIGEpIHsgd2luZG93LlBhcnNsZXlVSVthXSA9IGZ1bmN0aW9uICh0LCBlLCBpLCByLCBuKSB7IHZhciBzID0gITAgIT09IG47IHJldHVybiBkLndhcm5PbmNlKFwiQWNjZXNzaW5nIFVJIGlzIGRlcHJlY2F0ZWQuIENhbGwgJ1wiLmNvbmNhdChhLCBcIicgb24gdGhlIGluc3RhbmNlIGRpcmVjdGx5LiBQbGVhc2UgY29tbWVudCBpbiBpc3N1ZSAxMDczIGFzIHRvIHlvdXIgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kLlwiKSksIHRbYV0oZSwgeyBtZXNzYWdlOiBpLCBhc3NlcnQ6IHIsIHVwZGF0ZUNsYXNzOiBzIH0pIH0gfSksICExICE9PSB3aW5kb3cuUGFyc2xleUNvbmZpZy5hdXRvQmluZCAmJiBoKGZ1bmN0aW9uICgpIHsgaChcIltkYXRhLXBhcnNsZXktdmFsaWRhdGVdXCIpLmxlbmd0aCAmJiBoKFwiW2RhdGEtcGFyc2xleS12YWxpZGF0ZV1cIikucGFyc2xleSgpIH0pOyBmdW5jdGlvbiBWKCkgeyBkLndhcm5PbmNlKFwiUGFyc2xleSdzIHB1YnN1YiBtb2R1bGUgaXMgZGVwcmVjYXRlZDsgdXNlIHRoZSAnb24nIGFuZCAnb2ZmJyBtZXRob2RzIG9uIHBhcnNsZXkgaW5zdGFuY2VzIG9yIHdpbmRvdy5QYXJzbGV5XCIpIH0gdmFyIFAgPSBoKHt9KTsgZnVuY3Rpb24gTyhlLCBpKSB7IHJldHVybiBlLnBhcnNsZXlBZGFwdGVkQ2FsbGJhY2sgfHwgKGUucGFyc2xleUFkYXB0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApOyB0LnVuc2hpZnQodGhpcyksIGUuYXBwbHkoaSB8fCBQLCB0KSB9KSwgZS5wYXJzbGV5QWRhcHRlZENhbGxiYWNrIH0gdmFyIFQgPSBcInBhcnNsZXk6XCI7IGZ1bmN0aW9uIE0odCkgeyByZXR1cm4gMCA9PT0gdC5sYXN0SW5kZXhPZihULCAwKSA/IHQuc3Vic3RyKFQubGVuZ3RoKSA6IHQgfSByZXR1cm4gaC5saXN0ZW4gPSBmdW5jdGlvbiAodCwgZSkgeyB2YXIgaTsgaWYgKFYoKSwgXCJvYmplY3RcIiA9PT0gbihhcmd1bWVudHNbMV0pICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYXJndW1lbnRzWzJdICYmIChpID0gYXJndW1lbnRzWzFdLCBlID0gYXJndW1lbnRzWzJdKSwgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBwYXJhbWV0ZXJzXCIpOyB3aW5kb3cuUGFyc2xleS5vbihNKHQpLCBPKGUsIGkpKSB9LCBoLmxpc3RlblRvID0gZnVuY3Rpb24gKHQsIGUsIGkpIHsgaWYgKFYoKSwgISh0IGluc3RhbmNlb2YgdyB8fCB0IGluc3RhbmNlb2YgeSkpIHRocm93IG5ldyBFcnJvcihcIk11c3QgZ2l2ZSBQYXJzbGV5IGluc3RhbmNlXCIpOyBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGkpIHRocm93IG5ldyBFcnJvcihcIldyb25nIHBhcmFtZXRlcnNcIik7IHQub24oTShlKSwgTyhpKSkgfSwgaC51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICh0LCBlKSB7IGlmIChWKCksIFwic3RyaW5nXCIgIT0gdHlwZW9mIHQgfHwgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBhcmd1bWVudHNcIik7IHdpbmRvdy5QYXJzbGV5Lm9mZihNKHQpLCBlLnBhcnNsZXlBZGFwdGVkQ2FsbGJhY2spIH0sIGgudW5zdWJzY3JpYmVUbyA9IGZ1bmN0aW9uICh0LCBlKSB7IGlmIChWKCksICEodCBpbnN0YW5jZW9mIHcgfHwgdCBpbnN0YW5jZW9mIHkpKSB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IGdpdmUgUGFyc2xleSBpbnN0YW5jZVwiKTsgdC5vZmYoTShlKSkgfSwgaC51bnN1YnNjcmliZUFsbCA9IGZ1bmN0aW9uIChlKSB7IFYoKSwgd2luZG93LlBhcnNsZXkub2ZmKE0oZSkpLCBoKFwiZm9ybSxpbnB1dCx0ZXh0YXJlYSxzZWxlY3RcIikuZWFjaChmdW5jdGlvbiAoKSB7IHZhciB0ID0gaCh0aGlzKS5kYXRhKFwiUGFyc2xleVwiKTsgdCAmJiB0Lm9mZihNKGUpKSB9KSB9LCBoLmVtaXQgPSBmdW5jdGlvbiAodCwgZSkgeyBWKCk7IHZhciBpID0gZSBpbnN0YW5jZW9mIHcgfHwgZSBpbnN0YW5jZW9mIHksIHIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIGkgPyAyIDogMSk7IHIudW5zaGlmdChNKHQpKSwgaSB8fCAoZSA9IHdpbmRvdy5QYXJzbGV5KSwgZS50cmlnZ2VyLmFwcGx5KGUsIHUocikpIH0sIGguZXh0ZW5kKCEwLCB4LCB7IGFzeW5jVmFsaWRhdG9yczogeyBkZWZhdWx0OiB7IGZuOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMjAwIDw9IHQuc3RhdHVzICYmIHQuc3RhdHVzIDwgMzAwIH0sIHVybDogITEgfSwgcmV2ZXJzZTogeyBmbjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuc3RhdHVzIDwgMjAwIHx8IDMwMCA8PSB0LnN0YXR1cyB9LCB1cmw6ICExIH0gfSwgYWRkQXN5bmNWYWxpZGF0b3I6IGZ1bmN0aW9uICh0LCBlLCBpLCByKSB7IHJldHVybiB4LmFzeW5jVmFsaWRhdG9yc1t0XSA9IHsgZm46IGUsIHVybDogaSB8fCAhMSwgb3B0aW9uczogciB8fCB7fSB9LCB0aGlzIH0gfSksIHguYWRkVmFsaWRhdG9yKFwicmVtb3RlXCIsIHsgcmVxdWlyZW1lbnRUeXBlOiB7IFwiXCI6IFwic3RyaW5nXCIsIHZhbGlkYXRvcjogXCJzdHJpbmdcIiwgcmV2ZXJzZTogXCJib29sZWFuXCIsIG9wdGlvbnM6IFwib2JqZWN0XCIgfSwgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uICh0LCBlLCBpLCByKSB7IHZhciBuLCBzLCBhID0ge30sIG8gPSBpLnZhbGlkYXRvciB8fCAoITAgPT09IGkucmV2ZXJzZSA/IFwicmV2ZXJzZVwiIDogXCJkZWZhdWx0XCIpOyBpZiAodm9pZCAwID09PSB4LmFzeW5jVmFsaWRhdG9yc1tvXSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGluZyBhbiB1bmRlZmluZWQgYXN5bmMgdmFsaWRhdG9yOiBgXCIgKyBvICsgXCJgXCIpOyAtMSA8IChlID0geC5hc3luY1ZhbGlkYXRvcnNbb10udXJsIHx8IGUpLmluZGV4T2YoXCJ7dmFsdWV9XCIpID8gZSA9IGUucmVwbGFjZShcInt2YWx1ZX1cIiwgZW5jb2RlVVJJQ29tcG9uZW50KHQpKSA6IGFbci5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm5hbWVcIikgfHwgci5lbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpXSA9IHQ7IHZhciBsID0gaC5leHRlbmQoITAsIGkub3B0aW9ucyB8fCB7fSwgeC5hc3luY1ZhbGlkYXRvcnNbb10ub3B0aW9ucyk7IG4gPSBoLmV4dGVuZCghMCwge30sIHsgdXJsOiBlLCBkYXRhOiBhLCB0eXBlOiBcIkdFVFwiIH0sIGwpLCByLnRyaWdnZXIoXCJmaWVsZDphamF4b3B0aW9uc1wiLCByLCBuKSwgcyA9IGgucGFyYW0obiksIHZvaWQgMCA9PT0geC5fcmVtb3RlQ2FjaGUgJiYgKHguX3JlbW90ZUNhY2hlID0ge30pOyBmdW5jdGlvbiB1KCkgeyB2YXIgdCA9IHguYXN5bmNWYWxpZGF0b3JzW29dLmZuLmNhbGwociwgZCwgZSwgaSk7IHJldHVybiB0ID0gdCB8fCBoLkRlZmVycmVkKCkucmVqZWN0KCksIGgud2hlbih0KSB9IHZhciBkID0geC5fcmVtb3RlQ2FjaGVbc10gPSB4Ll9yZW1vdGVDYWNoZVtzXSB8fCBoLmFqYXgobik7IHJldHVybiBkLnRoZW4odSwgdSkgfSwgcHJpb3JpdHk6IC0xIH0pLCB4Lm9uKFwiZm9ybTpzdWJtaXRcIiwgZnVuY3Rpb24gKCkgeyB4Ll9yZW1vdGVDYWNoZSA9IHt9IH0pLCByLnByb3RvdHlwZS5hZGRBc3luY1ZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQud2Fybk9uY2UoXCJBY2Nlc3NpbmcgdGhlIG1ldGhvZCBgYWRkQXN5bmNWYWxpZGF0b3JgIHRocm91Z2ggYW4gaW5zdGFuY2UgaXMgZGVwcmVjYXRlZC4gU2ltcGx5IGNhbGwgYFBhcnNsZXkuYWRkQXN5bmNWYWxpZGF0b3IoLi4uKWBcIiksIHguYWRkQXN5bmNWYWxpZGF0b3IuYXBwbHkoeCwgYXJndW1lbnRzKSB9LCB4LmFkZE1lc3NhZ2VzKFwiZW5cIiwgeyBkZWZhdWx0TWVzc2FnZTogXCJUaGlzIHZhbHVlIHNlZW1zIHRvIGJlIGludmFsaWQuXCIsIHR5cGU6IHsgZW1haWw6IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgYSB2YWxpZCBlbWFpbC5cIiwgdXJsOiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIGEgdmFsaWQgdXJsLlwiLCBudW1iZXI6IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgYSB2YWxpZCBudW1iZXIuXCIsIGludGVnZXI6IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgYSB2YWxpZCBpbnRlZ2VyLlwiLCBkaWdpdHM6IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgZGlnaXRzLlwiLCBhbHBoYW51bTogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSBhbHBoYW51bWVyaWMuXCIgfSwgbm90Ymxhbms6IFwiVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIGJsYW5rLlwiLCByZXF1aXJlZDogXCJUaGlzIHZhbHVlIGlzIHJlcXVpcmVkLlwiLCBwYXR0ZXJuOiBcIlRoaXMgdmFsdWUgc2VlbXMgdG8gYmUgaW52YWxpZC5cIiwgbWluOiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlcy5cIiwgbWF4OiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gJXMuXCIsIHJhbmdlOiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIGJldHdlZW4gJXMgYW5kICVzLlwiLCBtaW5sZW5ndGg6IFwiVGhpcyB2YWx1ZSBpcyB0b28gc2hvcnQuIEl0IHNob3VsZCBoYXZlICVzIGNoYXJhY3RlcnMgb3IgbW9yZS5cIiwgbWF4bGVuZ3RoOiBcIlRoaXMgdmFsdWUgaXMgdG9vIGxvbmcuIEl0IHNob3VsZCBoYXZlICVzIGNoYXJhY3RlcnMgb3IgZmV3ZXIuXCIsIGxlbmd0aDogXCJUaGlzIHZhbHVlIGxlbmd0aCBpcyBpbnZhbGlkLiBJdCBzaG91bGQgYmUgYmV0d2VlbiAlcyBhbmQgJXMgY2hhcmFjdGVycyBsb25nLlwiLCBtaW5jaGVjazogXCJZb3UgbXVzdCBzZWxlY3QgYXQgbGVhc3QgJXMgY2hvaWNlcy5cIiwgbWF4Y2hlY2s6IFwiWW91IG11c3Qgc2VsZWN0ICVzIGNob2ljZXMgb3IgZmV3ZXIuXCIsIGNoZWNrOiBcIllvdSBtdXN0IHNlbGVjdCBiZXR3ZWVuICVzIGFuZCAlcyBjaG9pY2VzLlwiLCBlcXVhbHRvOiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIHRoZSBzYW1lLlwiLCBldXZhdGluOiBcIkl0J3Mgbm90IGEgdmFsaWQgVkFUIElkZW50aWZpY2F0aW9uIE51bWJlci5cIiB9KSwgeC5zZXRMb2NhbGUoXCJlblwiKSwgKG5ldyBmdW5jdGlvbiAoKSB7IHZhciByID0gdGhpcywgbiA9IHdpbmRvdyB8fCBnbG9iYWw7IGwodGhpcywgeyBpc05hdGl2ZUV2ZW50OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5vcmlnaW5hbEV2ZW50ICYmICExICE9PSB0Lm9yaWdpbmFsRXZlbnQuaXNUcnVzdGVkIH0sIGZha2VJbnB1dEV2ZW50OiBmdW5jdGlvbiAodCkgeyByLmlzTmF0aXZlRXZlbnQodCkgJiYgaCh0LnRhcmdldCkudHJpZ2dlcihcImlucHV0XCIpIH0sIG1pc2JlaGF2ZXM6IGZ1bmN0aW9uICh0KSB7IHIuaXNOYXRpdmVFdmVudCh0KSAmJiAoci5iZWhhdmVzT2sodCksIGgoZG9jdW1lbnQpLm9uKFwiY2hhbmdlLmlucHV0ZXZlbnRcIiwgdC5kYXRhLnNlbGVjdG9yLCByLmZha2VJbnB1dEV2ZW50KSwgci5mYWtlSW5wdXRFdmVudCh0KSkgfSwgYmVoYXZlc09rOiBmdW5jdGlvbiAodCkgeyByLmlzTmF0aXZlRXZlbnQodCkgJiYgaChkb2N1bWVudCkub2ZmKFwiaW5wdXQuaW5wdXRldmVudFwiLCB0LmRhdGEuc2VsZWN0b3IsIHIuYmVoYXZlc09rKS5vZmYoXCJjaGFuZ2UuaW5wdXRldmVudFwiLCB0LmRhdGEuc2VsZWN0b3IsIHIubWlzYmVoYXZlcykgfSwgaW5zdGFsbDogZnVuY3Rpb24gKCkgeyBpZiAoIW4uaW5wdXRFdmVudFBhdGNoZWQpIHsgbi5pbnB1dEV2ZW50UGF0Y2hlZCA9IFwiMC4wLjNcIjsgZm9yICh2YXIgdCA9IDAsIGUgPSBbXCJzZWxlY3RcIiwgJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScsICdpbnB1dFt0eXBlPVwicmFkaW9cIl0nLCAnaW5wdXRbdHlwZT1cImZpbGVcIl0nXTsgdCA8IGUubGVuZ3RoOyB0KyspIHsgdmFyIGkgPSBlW3RdOyBoKGRvY3VtZW50KS5vbihcImlucHV0LmlucHV0ZXZlbnRcIiwgaSwgeyBzZWxlY3RvcjogaSB9LCByLmJlaGF2ZXNPaykub24oXCJjaGFuZ2UuaW5wdXRldmVudFwiLCBpLCB7IHNlbGVjdG9yOiBpIH0sIHIubWlzYmVoYXZlcykgfSB9IH0sIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkgeyBkZWxldGUgbi5pbnB1dEV2ZW50UGF0Y2hlZCwgaChkb2N1bWVudCkub2ZmKFwiLmlucHV0ZXZlbnRcIikgfSB9KSB9KS5pbnN0YWxsKCksIHggfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzbGV5Lm1pbi5qcy5tYXAiLCIvKipcbiAqIEBwb3BwZXJqcy9jb3JlIHYyLjExLjggLSBNSVQgTGljZW5zZVxuICovXG5cbiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP3QoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLHQpOnQoKGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczplfHxzZWxmKS5Qb3BwZXI9e30pfSh0aGlzLChmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KGUpe2lmKG51bGw9PWUpcmV0dXJuIHdpbmRvdztpZihcIltvYmplY3QgV2luZG93XVwiIT09ZS50b1N0cmluZygpKXt2YXIgdD1lLm93bmVyRG9jdW1lbnQ7cmV0dXJuIHQmJnQuZGVmYXVsdFZpZXd8fHdpbmRvd31yZXR1cm4gZX1mdW5jdGlvbiBuKGUpe3JldHVybiBlIGluc3RhbmNlb2YgdChlKS5FbGVtZW50fHxlIGluc3RhbmNlb2YgRWxlbWVudH1mdW5jdGlvbiByKGUpe3JldHVybiBlIGluc3RhbmNlb2YgdChlKS5IVE1MRWxlbWVudHx8ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50fWZ1bmN0aW9uIG8oZSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNoYWRvd1Jvb3QmJihlIGluc3RhbmNlb2YgdChlKS5TaGFkb3dSb290fHxlIGluc3RhbmNlb2YgU2hhZG93Um9vdCl9dmFyIGk9TWF0aC5tYXgsYT1NYXRoLm1pbixzPU1hdGgucm91bmQ7ZnVuY3Rpb24gZigpe3ZhciBlPW5hdmlnYXRvci51c2VyQWdlbnREYXRhO3JldHVybiBudWxsIT1lJiZlLmJyYW5kcyYmQXJyYXkuaXNBcnJheShlLmJyYW5kcyk/ZS5icmFuZHMubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5icmFuZCtcIi9cIitlLnZlcnNpb259KSkuam9pbihcIiBcIik6bmF2aWdhdG9yLnVzZXJBZ2VudH1mdW5jdGlvbiBjKCl7cmV0dXJuIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZigpKX1mdW5jdGlvbiBwKGUsbyxpKXt2b2lkIDA9PT1vJiYobz0hMSksdm9pZCAwPT09aSYmKGk9ITEpO3ZhciBhPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksZj0xLHA9MTtvJiZyKGUpJiYoZj1lLm9mZnNldFdpZHRoPjAmJnMoYS53aWR0aCkvZS5vZmZzZXRXaWR0aHx8MSxwPWUub2Zmc2V0SGVpZ2h0PjAmJnMoYS5oZWlnaHQpL2Uub2Zmc2V0SGVpZ2h0fHwxKTt2YXIgdT0obihlKT90KGUpOndpbmRvdykudmlzdWFsVmlld3BvcnQsbD0hYygpJiZpLGQ9KGEubGVmdCsobCYmdT91Lm9mZnNldExlZnQ6MCkpL2YsaD0oYS50b3ArKGwmJnU/dS5vZmZzZXRUb3A6MCkpL3AsbT1hLndpZHRoL2Ysdj1hLmhlaWdodC9wO3JldHVybnt3aWR0aDptLGhlaWdodDp2LHRvcDpoLHJpZ2h0OmQrbSxib3R0b206aCt2LGxlZnQ6ZCx4OmQseTpofX1mdW5jdGlvbiB1KGUpe3ZhciBuPXQoZSk7cmV0dXJue3Njcm9sbExlZnQ6bi5wYWdlWE9mZnNldCxzY3JvbGxUb3A6bi5wYWdlWU9mZnNldH19ZnVuY3Rpb24gbChlKXtyZXR1cm4gZT8oZS5ub2RlTmFtZXx8XCJcIikudG9Mb3dlckNhc2UoKTpudWxsfWZ1bmN0aW9uIGQoZSl7cmV0dXJuKChuKGUpP2Uub3duZXJEb2N1bWVudDplLmRvY3VtZW50KXx8d2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnR9ZnVuY3Rpb24gaChlKXtyZXR1cm4gcChkKGUpKS5sZWZ0K3UoZSkuc2Nyb2xsTGVmdH1mdW5jdGlvbiBtKGUpe3JldHVybiB0KGUpLmdldENvbXB1dGVkU3R5bGUoZSl9ZnVuY3Rpb24gdihlKXt2YXIgdD1tKGUpLG49dC5vdmVyZmxvdyxyPXQub3ZlcmZsb3dYLG89dC5vdmVyZmxvd1k7cmV0dXJuL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG4rbytyKX1mdW5jdGlvbiB5KGUsbixvKXt2b2lkIDA9PT1vJiYobz0hMSk7dmFyIGksYSxmPXIobiksYz1yKG4pJiZmdW5jdGlvbihlKXt2YXIgdD1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG49cyh0LndpZHRoKS9lLm9mZnNldFdpZHRofHwxLHI9cyh0LmhlaWdodCkvZS5vZmZzZXRIZWlnaHR8fDE7cmV0dXJuIDEhPT1ufHwxIT09cn0obiksbT1kKG4pLHk9cChlLGMsbyksZz17c2Nyb2xsTGVmdDowLHNjcm9sbFRvcDowfSxiPXt4OjAseTowfTtyZXR1cm4oZnx8IWYmJiFvKSYmKChcImJvZHlcIiE9PWwobil8fHYobSkpJiYoZz0oaT1uKSE9PXQoaSkmJnIoaSk/e3Njcm9sbExlZnQ6KGE9aSkuc2Nyb2xsTGVmdCxzY3JvbGxUb3A6YS5zY3JvbGxUb3B9OnUoaSkpLHIobik/KChiPXAobiwhMCkpLngrPW4uY2xpZW50TGVmdCxiLnkrPW4uY2xpZW50VG9wKTptJiYoYi54PWgobSkpKSx7eDp5LmxlZnQrZy5zY3JvbGxMZWZ0LWIueCx5OnkudG9wK2cuc2Nyb2xsVG9wLWIueSx3aWR0aDp5LndpZHRoLGhlaWdodDp5LmhlaWdodH19ZnVuY3Rpb24gZyhlKXt2YXIgdD1wKGUpLG49ZS5vZmZzZXRXaWR0aCxyPWUub2Zmc2V0SGVpZ2h0O3JldHVybiBNYXRoLmFicyh0LndpZHRoLW4pPD0xJiYobj10LndpZHRoKSxNYXRoLmFicyh0LmhlaWdodC1yKTw9MSYmKHI9dC5oZWlnaHQpLHt4OmUub2Zmc2V0TGVmdCx5OmUub2Zmc2V0VG9wLHdpZHRoOm4saGVpZ2h0OnJ9fWZ1bmN0aW9uIGIoZSl7cmV0dXJuXCJodG1sXCI9PT1sKGUpP2U6ZS5hc3NpZ25lZFNsb3R8fGUucGFyZW50Tm9kZXx8KG8oZSk/ZS5ob3N0Om51bGwpfHxkKGUpfWZ1bmN0aW9uIHgoZSl7cmV0dXJuW1wiaHRtbFwiLFwiYm9keVwiLFwiI2RvY3VtZW50XCJdLmluZGV4T2YobChlKSk+PTA/ZS5vd25lckRvY3VtZW50LmJvZHk6cihlKSYmdihlKT9lOngoYihlKSl9ZnVuY3Rpb24gdyhlLG4pe3ZhciByO3ZvaWQgMD09PW4mJihuPVtdKTt2YXIgbz14KGUpLGk9bz09PShudWxsPT0ocj1lLm93bmVyRG9jdW1lbnQpP3ZvaWQgMDpyLmJvZHkpLGE9dChvKSxzPWk/W2FdLmNvbmNhdChhLnZpc3VhbFZpZXdwb3J0fHxbXSx2KG8pP286W10pOm8sZj1uLmNvbmNhdChzKTtyZXR1cm4gaT9mOmYuY29uY2F0KHcoYihzKSkpfWZ1bmN0aW9uIE8oZSl7cmV0dXJuW1widGFibGVcIixcInRkXCIsXCJ0aFwiXS5pbmRleE9mKGwoZSkpPj0wfWZ1bmN0aW9uIGooZSl7cmV0dXJuIHIoZSkmJlwiZml4ZWRcIiE9PW0oZSkucG9zaXRpb24/ZS5vZmZzZXRQYXJlbnQ6bnVsbH1mdW5jdGlvbiBFKGUpe2Zvcih2YXIgbj10KGUpLGk9aihlKTtpJiZPKGkpJiZcInN0YXRpY1wiPT09bShpKS5wb3NpdGlvbjspaT1qKGkpO3JldHVybiBpJiYoXCJodG1sXCI9PT1sKGkpfHxcImJvZHlcIj09PWwoaSkmJlwic3RhdGljXCI9PT1tKGkpLnBvc2l0aW9uKT9uOml8fGZ1bmN0aW9uKGUpe3ZhciB0PS9maXJlZm94L2kudGVzdChmKCkpO2lmKC9UcmlkZW50L2kudGVzdChmKCkpJiZyKGUpJiZcImZpeGVkXCI9PT1tKGUpLnBvc2l0aW9uKXJldHVybiBudWxsO3ZhciBuPWIoZSk7Zm9yKG8obikmJihuPW4uaG9zdCk7cihuKSYmW1wiaHRtbFwiLFwiYm9keVwiXS5pbmRleE9mKGwobikpPDA7KXt2YXIgaT1tKG4pO2lmKFwibm9uZVwiIT09aS50cmFuc2Zvcm18fFwibm9uZVwiIT09aS5wZXJzcGVjdGl2ZXx8XCJwYWludFwiPT09aS5jb250YWlufHwtMSE9PVtcInRyYW5zZm9ybVwiLFwicGVyc3BlY3RpdmVcIl0uaW5kZXhPZihpLndpbGxDaGFuZ2UpfHx0JiZcImZpbHRlclwiPT09aS53aWxsQ2hhbmdlfHx0JiZpLmZpbHRlciYmXCJub25lXCIhPT1pLmZpbHRlcilyZXR1cm4gbjtuPW4ucGFyZW50Tm9kZX1yZXR1cm4gbnVsbH0oZSl8fG59dmFyIEQ9XCJ0b3BcIixBPVwiYm90dG9tXCIsTD1cInJpZ2h0XCIsUD1cImxlZnRcIixNPVwiYXV0b1wiLGs9W0QsQSxMLFBdLFc9XCJzdGFydFwiLEI9XCJlbmRcIixIPVwidmlld3BvcnRcIixUPVwicG9wcGVyXCIsUj1rLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jb25jYXQoW3QrXCItXCIrVyx0K1wiLVwiK0JdKX0pLFtdKSxTPVtdLmNvbmNhdChrLFtNXSkucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBlLmNvbmNhdChbdCx0K1wiLVwiK1csdCtcIi1cIitCXSl9KSxbXSksVj1bXCJiZWZvcmVSZWFkXCIsXCJyZWFkXCIsXCJhZnRlclJlYWRcIixcImJlZm9yZU1haW5cIixcIm1haW5cIixcImFmdGVyTWFpblwiLFwiYmVmb3JlV3JpdGVcIixcIndyaXRlXCIsXCJhZnRlcldyaXRlXCJdO2Z1bmN0aW9uIHEoZSl7dmFyIHQ9bmV3IE1hcCxuPW5ldyBTZXQscj1bXTtmdW5jdGlvbiBvKGUpe24uYWRkKGUubmFtZSksW10uY29uY2F0KGUucmVxdWlyZXN8fFtdLGUucmVxdWlyZXNJZkV4aXN0c3x8W10pLmZvckVhY2goKGZ1bmN0aW9uKGUpe2lmKCFuLmhhcyhlKSl7dmFyIHI9dC5nZXQoZSk7ciYmbyhyKX19KSksci5wdXNoKGUpfXJldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3Quc2V0KGUubmFtZSxlKX0pKSxlLmZvckVhY2goKGZ1bmN0aW9uKGUpe24uaGFzKGUubmFtZSl8fG8oZSl9KSkscn1mdW5jdGlvbiBDKGUsdCl7dmFyIG49dC5nZXRSb290Tm9kZSYmdC5nZXRSb290Tm9kZSgpO2lmKGUuY29udGFpbnModCkpcmV0dXJuITA7aWYobiYmbyhuKSl7dmFyIHI9dDtkb3tpZihyJiZlLmlzU2FtZU5vZGUocikpcmV0dXJuITA7cj1yLnBhcmVudE5vZGV8fHIuaG9zdH13aGlsZShyKX1yZXR1cm4hMX1mdW5jdGlvbiBOKGUpe3JldHVybiBPYmplY3QuYXNzaWduKHt9LGUse2xlZnQ6ZS54LHRvcDplLnkscmlnaHQ6ZS54K2Uud2lkdGgsYm90dG9tOmUueStlLmhlaWdodH0pfWZ1bmN0aW9uIEkoZSxyLG8pe3JldHVybiByPT09SD9OKGZ1bmN0aW9uKGUsbil7dmFyIHI9dChlKSxvPWQoZSksaT1yLnZpc3VhbFZpZXdwb3J0LGE9by5jbGllbnRXaWR0aCxzPW8uY2xpZW50SGVpZ2h0LGY9MCxwPTA7aWYoaSl7YT1pLndpZHRoLHM9aS5oZWlnaHQ7dmFyIHU9YygpOyh1fHwhdSYmXCJmaXhlZFwiPT09bikmJihmPWkub2Zmc2V0TGVmdCxwPWkub2Zmc2V0VG9wKX1yZXR1cm57d2lkdGg6YSxoZWlnaHQ6cyx4OmYraChlKSx5OnB9fShlLG8pKTpuKHIpP2Z1bmN0aW9uKGUsdCl7dmFyIG49cChlLCExLFwiZml4ZWRcIj09PXQpO3JldHVybiBuLnRvcD1uLnRvcCtlLmNsaWVudFRvcCxuLmxlZnQ9bi5sZWZ0K2UuY2xpZW50TGVmdCxuLmJvdHRvbT1uLnRvcCtlLmNsaWVudEhlaWdodCxuLnJpZ2h0PW4ubGVmdCtlLmNsaWVudFdpZHRoLG4ud2lkdGg9ZS5jbGllbnRXaWR0aCxuLmhlaWdodD1lLmNsaWVudEhlaWdodCxuLng9bi5sZWZ0LG4ueT1uLnRvcCxufShyLG8pOk4oZnVuY3Rpb24oZSl7dmFyIHQsbj1kKGUpLHI9dShlKSxvPW51bGw9PSh0PWUub3duZXJEb2N1bWVudCk/dm9pZCAwOnQuYm9keSxhPWkobi5zY3JvbGxXaWR0aCxuLmNsaWVudFdpZHRoLG8/by5zY3JvbGxXaWR0aDowLG8/by5jbGllbnRXaWR0aDowKSxzPWkobi5zY3JvbGxIZWlnaHQsbi5jbGllbnRIZWlnaHQsbz9vLnNjcm9sbEhlaWdodDowLG8/by5jbGllbnRIZWlnaHQ6MCksZj0tci5zY3JvbGxMZWZ0K2goZSksYz0tci5zY3JvbGxUb3A7cmV0dXJuXCJydGxcIj09PW0ob3x8bikuZGlyZWN0aW9uJiYoZis9aShuLmNsaWVudFdpZHRoLG8/by5jbGllbnRXaWR0aDowKS1hKSx7d2lkdGg6YSxoZWlnaHQ6cyx4OmYseTpjfX0oZChlKSkpfWZ1bmN0aW9uIF8oZSx0LG8scyl7dmFyIGY9XCJjbGlwcGluZ1BhcmVudHNcIj09PXQ/ZnVuY3Rpb24oZSl7dmFyIHQ9dyhiKGUpKSxvPVtcImFic29sdXRlXCIsXCJmaXhlZFwiXS5pbmRleE9mKG0oZSkucG9zaXRpb24pPj0wJiZyKGUpP0UoZSk6ZTtyZXR1cm4gbihvKT90LmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIG4oZSkmJkMoZSxvKSYmXCJib2R5XCIhPT1sKGUpfSkpOltdfShlKTpbXS5jb25jYXQodCksYz1bXS5jb25jYXQoZixbb10pLHA9Y1swXSx1PWMucmVkdWNlKChmdW5jdGlvbih0LG4pe3ZhciByPUkoZSxuLHMpO3JldHVybiB0LnRvcD1pKHIudG9wLHQudG9wKSx0LnJpZ2h0PWEoci5yaWdodCx0LnJpZ2h0KSx0LmJvdHRvbT1hKHIuYm90dG9tLHQuYm90dG9tKSx0LmxlZnQ9aShyLmxlZnQsdC5sZWZ0KSx0fSksSShlLHAscykpO3JldHVybiB1LndpZHRoPXUucmlnaHQtdS5sZWZ0LHUuaGVpZ2h0PXUuYm90dG9tLXUudG9wLHUueD11LmxlZnQsdS55PXUudG9wLHV9ZnVuY3Rpb24gRihlKXtyZXR1cm4gZS5zcGxpdChcIi1cIilbMF19ZnVuY3Rpb24gVShlKXtyZXR1cm4gZS5zcGxpdChcIi1cIilbMV19ZnVuY3Rpb24geihlKXtyZXR1cm5bXCJ0b3BcIixcImJvdHRvbVwiXS5pbmRleE9mKGUpPj0wP1wieFwiOlwieVwifWZ1bmN0aW9uIFgoZSl7dmFyIHQsbj1lLnJlZmVyZW5jZSxyPWUuZWxlbWVudCxvPWUucGxhY2VtZW50LGk9bz9GKG8pOm51bGwsYT1vP1Uobyk6bnVsbCxzPW4ueCtuLndpZHRoLzItci53aWR0aC8yLGY9bi55K24uaGVpZ2h0LzItci5oZWlnaHQvMjtzd2l0Y2goaSl7Y2FzZSBEOnQ9e3g6cyx5Om4ueS1yLmhlaWdodH07YnJlYWs7Y2FzZSBBOnQ9e3g6cyx5Om4ueStuLmhlaWdodH07YnJlYWs7Y2FzZSBMOnQ9e3g6bi54K24ud2lkdGgseTpmfTticmVhaztjYXNlIFA6dD17eDpuLngtci53aWR0aCx5OmZ9O2JyZWFrO2RlZmF1bHQ6dD17eDpuLngseTpuLnl9fXZhciBjPWk/eihpKTpudWxsO2lmKG51bGwhPWMpe3ZhciBwPVwieVwiPT09Yz9cImhlaWdodFwiOlwid2lkdGhcIjtzd2l0Y2goYSl7Y2FzZSBXOnRbY109dFtjXS0obltwXS8yLXJbcF0vMik7YnJlYWs7Y2FzZSBCOnRbY109dFtjXSsobltwXS8yLXJbcF0vMil9fXJldHVybiB0fWZ1bmN0aW9uIFkoZSl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30se3RvcDowLHJpZ2h0OjAsYm90dG9tOjAsbGVmdDowfSxlKX1mdW5jdGlvbiBHKGUsdCl7cmV0dXJuIHQucmVkdWNlKChmdW5jdGlvbih0LG4pe3JldHVybiB0W25dPWUsdH0pLHt9KX1mdW5jdGlvbiBKKGUsdCl7dm9pZCAwPT09dCYmKHQ9e30pO3ZhciByPXQsbz1yLnBsYWNlbWVudCxpPXZvaWQgMD09PW8/ZS5wbGFjZW1lbnQ6byxhPXIuc3RyYXRlZ3kscz12b2lkIDA9PT1hP2Uuc3RyYXRlZ3k6YSxmPXIuYm91bmRhcnksYz12b2lkIDA9PT1mP1wiY2xpcHBpbmdQYXJlbnRzXCI6Zix1PXIucm9vdEJvdW5kYXJ5LGw9dm9pZCAwPT09dT9IOnUsaD1yLmVsZW1lbnRDb250ZXh0LG09dm9pZCAwPT09aD9UOmgsdj1yLmFsdEJvdW5kYXJ5LHk9dm9pZCAwIT09diYmdixnPXIucGFkZGluZyxiPXZvaWQgMD09PWc/MDpnLHg9WShcIm51bWJlclwiIT10eXBlb2YgYj9iOkcoYixrKSksdz1tPT09VD9cInJlZmVyZW5jZVwiOlQsTz1lLnJlY3RzLnBvcHBlcixqPWUuZWxlbWVudHNbeT93Om1dLEU9XyhuKGopP2o6ai5jb250ZXh0RWxlbWVudHx8ZChlLmVsZW1lbnRzLnBvcHBlciksYyxsLHMpLFA9cChlLmVsZW1lbnRzLnJlZmVyZW5jZSksTT1YKHtyZWZlcmVuY2U6UCxlbGVtZW50Ok8sc3RyYXRlZ3k6XCJhYnNvbHV0ZVwiLHBsYWNlbWVudDppfSksVz1OKE9iamVjdC5hc3NpZ24oe30sTyxNKSksQj1tPT09VD9XOlAsUj17dG9wOkUudG9wLUIudG9wK3gudG9wLGJvdHRvbTpCLmJvdHRvbS1FLmJvdHRvbSt4LmJvdHRvbSxsZWZ0OkUubGVmdC1CLmxlZnQreC5sZWZ0LHJpZ2h0OkIucmlnaHQtRS5yaWdodCt4LnJpZ2h0fSxTPWUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7aWYobT09PVQmJlMpe3ZhciBWPVNbaV07T2JqZWN0LmtleXMoUikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHQ9W0wsQV0uaW5kZXhPZihlKT49MD8xOi0xLG49W0QsQV0uaW5kZXhPZihlKT49MD9cInlcIjpcInhcIjtSW2VdKz1WW25dKnR9KSl9cmV0dXJuIFJ9dmFyIEs9e3BsYWNlbWVudDpcImJvdHRvbVwiLG1vZGlmaWVyczpbXSxzdHJhdGVneTpcImFic29sdXRlXCJ9O2Z1bmN0aW9uIFEoKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxuPTA7bjxlO24rKyl0W25dPWFyZ3VtZW50c1tuXTtyZXR1cm4hdC5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4hKGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KX0pKX1mdW5jdGlvbiBaKGUpe3ZvaWQgMD09PWUmJihlPXt9KTt2YXIgdD1lLHI9dC5kZWZhdWx0TW9kaWZpZXJzLG89dm9pZCAwPT09cj9bXTpyLGk9dC5kZWZhdWx0T3B0aW9ucyxhPXZvaWQgMD09PWk/SzppO3JldHVybiBmdW5jdGlvbihlLHQscil7dm9pZCAwPT09ciYmKHI9YSk7dmFyIGkscyxmPXtwbGFjZW1lbnQ6XCJib3R0b21cIixvcmRlcmVkTW9kaWZpZXJzOltdLG9wdGlvbnM6T2JqZWN0LmFzc2lnbih7fSxLLGEpLG1vZGlmaWVyc0RhdGE6e30sZWxlbWVudHM6e3JlZmVyZW5jZTplLHBvcHBlcjp0fSxhdHRyaWJ1dGVzOnt9LHN0eWxlczp7fX0sYz1bXSxwPSExLHU9e3N0YXRlOmYsc2V0T3B0aW9uczpmdW5jdGlvbihyKXt2YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByP3IoZi5vcHRpb25zKTpyO2woKSxmLm9wdGlvbnM9T2JqZWN0LmFzc2lnbih7fSxhLGYub3B0aW9ucyxpKSxmLnNjcm9sbFBhcmVudHM9e3JlZmVyZW5jZTpuKGUpP3coZSk6ZS5jb250ZXh0RWxlbWVudD93KGUuY29udGV4dEVsZW1lbnQpOltdLHBvcHBlcjp3KHQpfTt2YXIgcyxwLGQ9ZnVuY3Rpb24oZSl7dmFyIHQ9cShlKTtyZXR1cm4gVi5yZWR1Y2UoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGUuY29uY2F0KHQuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZS5waGFzZT09PW59KSkpfSksW10pfSgocz1bXS5jb25jYXQobyxmLm9wdGlvbnMubW9kaWZpZXJzKSxwPXMucmVkdWNlKChmdW5jdGlvbihlLHQpe3ZhciBuPWVbdC5uYW1lXTtyZXR1cm4gZVt0Lm5hbWVdPW4/T2JqZWN0LmFzc2lnbih7fSxuLHQse29wdGlvbnM6T2JqZWN0LmFzc2lnbih7fSxuLm9wdGlvbnMsdC5vcHRpb25zKSxkYXRhOk9iamVjdC5hc3NpZ24oe30sbi5kYXRhLHQuZGF0YSl9KTp0LGV9KSx7fSksT2JqZWN0LmtleXMocCkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gcFtlXX0pKSkpO3JldHVybiBmLm9yZGVyZWRNb2RpZmllcnM9ZC5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmVuYWJsZWR9KSksZi5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZSxuPWUub3B0aW9ucyxyPXZvaWQgMD09PW4/e306bixvPWUuZWZmZWN0O2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG8pe3ZhciBpPW8oe3N0YXRlOmYsbmFtZTp0LGluc3RhbmNlOnUsb3B0aW9uczpyfSksYT1mdW5jdGlvbigpe307Yy5wdXNoKGl8fGEpfX0pKSx1LnVwZGF0ZSgpfSxmb3JjZVVwZGF0ZTpmdW5jdGlvbigpe2lmKCFwKXt2YXIgZT1mLmVsZW1lbnRzLHQ9ZS5yZWZlcmVuY2Usbj1lLnBvcHBlcjtpZihRKHQsbikpe2YucmVjdHM9e3JlZmVyZW5jZTp5KHQsRShuKSxcImZpeGVkXCI9PT1mLm9wdGlvbnMuc3RyYXRlZ3kpLHBvcHBlcjpnKG4pfSxmLnJlc2V0PSExLGYucGxhY2VtZW50PWYub3B0aW9ucy5wbGFjZW1lbnQsZi5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBmLm1vZGlmaWVyc0RhdGFbZS5uYW1lXT1PYmplY3QuYXNzaWduKHt9LGUuZGF0YSl9KSk7Zm9yKHZhciByPTA7cjxmLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoO3IrKylpZighMCE9PWYucmVzZXQpe3ZhciBvPWYub3JkZXJlZE1vZGlmaWVyc1tyXSxpPW8uZm4sYT1vLm9wdGlvbnMscz12b2lkIDA9PT1hP3t9OmEsYz1vLm5hbWU7XCJmdW5jdGlvblwiPT10eXBlb2YgaSYmKGY9aSh7c3RhdGU6ZixvcHRpb25zOnMsbmFtZTpjLGluc3RhbmNlOnV9KXx8Zil9ZWxzZSBmLnJlc2V0PSExLHI9LTF9fX0sdXBkYXRlOihpPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihlKXt1LmZvcmNlVXBkYXRlKCksZShmKX0pKX0sZnVuY3Rpb24oKXtyZXR1cm4gc3x8KHM9bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe1Byb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cz12b2lkIDAsZShpKCkpfSkpfSkpKSxzfSksZGVzdHJveTpmdW5jdGlvbigpe2woKSxwPSEwfX07aWYoIVEoZSx0KSlyZXR1cm4gdTtmdW5jdGlvbiBsKCl7Yy5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZSgpfSkpLGM9W119cmV0dXJuIHUuc2V0T3B0aW9ucyhyKS50aGVuKChmdW5jdGlvbihlKXshcCYmci5vbkZpcnN0VXBkYXRlJiZyLm9uRmlyc3RVcGRhdGUoZSl9KSksdX19dmFyICQ9e3Bhc3NpdmU6ITB9O3ZhciBlZT17bmFtZTpcImV2ZW50TGlzdGVuZXJzXCIsZW5hYmxlZDohMCxwaGFzZTpcIndyaXRlXCIsZm46ZnVuY3Rpb24oKXt9LGVmZmVjdDpmdW5jdGlvbihlKXt2YXIgbj1lLnN0YXRlLHI9ZS5pbnN0YW5jZSxvPWUub3B0aW9ucyxpPW8uc2Nyb2xsLGE9dm9pZCAwPT09aXx8aSxzPW8ucmVzaXplLGY9dm9pZCAwPT09c3x8cyxjPXQobi5lbGVtZW50cy5wb3BwZXIpLHA9W10uY29uY2F0KG4uc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2Usbi5zY3JvbGxQYXJlbnRzLnBvcHBlcik7cmV0dXJuIGEmJnAuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsci51cGRhdGUsJCl9KSksZiYmYy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsci51cGRhdGUsJCksZnVuY3Rpb24oKXthJiZwLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHIudXBkYXRlLCQpfSkpLGYmJmMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHIudXBkYXRlLCQpfX0sZGF0YTp7fX07dmFyIHRlPXtuYW1lOlwicG9wcGVyT2Zmc2V0c1wiLGVuYWJsZWQ6ITAscGhhc2U6XCJyZWFkXCIsZm46ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdGF0ZSxuPWUubmFtZTt0Lm1vZGlmaWVyc0RhdGFbbl09WCh7cmVmZXJlbmNlOnQucmVjdHMucmVmZXJlbmNlLGVsZW1lbnQ6dC5yZWN0cy5wb3BwZXIsc3RyYXRlZ3k6XCJhYnNvbHV0ZVwiLHBsYWNlbWVudDp0LnBsYWNlbWVudH0pfSxkYXRhOnt9fSxuZT17dG9wOlwiYXV0b1wiLHJpZ2h0OlwiYXV0b1wiLGJvdHRvbTpcImF1dG9cIixsZWZ0OlwiYXV0b1wifTtmdW5jdGlvbiByZShlKXt2YXIgbixyPWUucG9wcGVyLG89ZS5wb3BwZXJSZWN0LGk9ZS5wbGFjZW1lbnQsYT1lLnZhcmlhdGlvbixmPWUub2Zmc2V0cyxjPWUucG9zaXRpb24scD1lLmdwdUFjY2VsZXJhdGlvbix1PWUuYWRhcHRpdmUsbD1lLnJvdW5kT2Zmc2V0cyxoPWUuaXNGaXhlZCx2PWYueCx5PXZvaWQgMD09PXY/MDp2LGc9Zi55LGI9dm9pZCAwPT09Zz8wOmcseD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBsP2woe3g6eSx5OmJ9KTp7eDp5LHk6Yn07eT14LngsYj14Lnk7dmFyIHc9Zi5oYXNPd25Qcm9wZXJ0eShcInhcIiksTz1mLmhhc093blByb3BlcnR5KFwieVwiKSxqPVAsTT1ELGs9d2luZG93O2lmKHUpe3ZhciBXPUUociksSD1cImNsaWVudEhlaWdodFwiLFQ9XCJjbGllbnRXaWR0aFwiO2lmKFc9PT10KHIpJiZcInN0YXRpY1wiIT09bShXPWQocikpLnBvc2l0aW9uJiZcImFic29sdXRlXCI9PT1jJiYoSD1cInNjcm9sbEhlaWdodFwiLFQ9XCJzY3JvbGxXaWR0aFwiKSxXPVcsaT09PUR8fChpPT09UHx8aT09PUwpJiZhPT09QilNPUEsYi09KGgmJlc9PT1rJiZrLnZpc3VhbFZpZXdwb3J0P2sudmlzdWFsVmlld3BvcnQuaGVpZ2h0OldbSF0pLW8uaGVpZ2h0LGIqPXA/MTotMTtpZihpPT09UHx8KGk9PT1EfHxpPT09QSkmJmE9PT1CKWo9TCx5LT0oaCYmVz09PWsmJmsudmlzdWFsVmlld3BvcnQ/ay52aXN1YWxWaWV3cG9ydC53aWR0aDpXW1RdKS1vLndpZHRoLHkqPXA/MTotMX12YXIgUixTPU9iamVjdC5hc3NpZ24oe3Bvc2l0aW9uOmN9LHUmJm5lKSxWPSEwPT09bD9mdW5jdGlvbihlLHQpe3ZhciBuPWUueCxyPWUueSxvPXQuZGV2aWNlUGl4ZWxSYXRpb3x8MTtyZXR1cm57eDpzKG4qbykvb3x8MCx5OnMocipvKS9vfHwwfX0oe3g6eSx5OmJ9LHQocikpOnt4OnkseTpifTtyZXR1cm4geT1WLngsYj1WLnkscD9PYmplY3QuYXNzaWduKHt9LFMsKChSPXt9KVtNXT1PP1wiMFwiOlwiXCIsUltqXT13P1wiMFwiOlwiXCIsUi50cmFuc2Zvcm09KGsuZGV2aWNlUGl4ZWxSYXRpb3x8MSk8PTE/XCJ0cmFuc2xhdGUoXCIreStcInB4LCBcIitiK1wicHgpXCI6XCJ0cmFuc2xhdGUzZChcIit5K1wicHgsIFwiK2IrXCJweCwgMClcIixSKSk6T2JqZWN0LmFzc2lnbih7fSxTLCgobj17fSlbTV09Tz9iK1wicHhcIjpcIlwiLG5bal09dz95K1wicHhcIjpcIlwiLG4udHJhbnNmb3JtPVwiXCIsbikpfXZhciBvZT17bmFtZTpcImNvbXB1dGVTdHlsZXNcIixlbmFibGVkOiEwLHBoYXNlOlwiYmVmb3JlV3JpdGVcIixmbjpmdW5jdGlvbihlKXt2YXIgdD1lLnN0YXRlLG49ZS5vcHRpb25zLHI9bi5ncHVBY2NlbGVyYXRpb24sbz12b2lkIDA9PT1yfHxyLGk9bi5hZGFwdGl2ZSxhPXZvaWQgMD09PWl8fGkscz1uLnJvdW5kT2Zmc2V0cyxmPXZvaWQgMD09PXN8fHMsYz17cGxhY2VtZW50OkYodC5wbGFjZW1lbnQpLHZhcmlhdGlvbjpVKHQucGxhY2VtZW50KSxwb3BwZXI6dC5lbGVtZW50cy5wb3BwZXIscG9wcGVyUmVjdDp0LnJlY3RzLnBvcHBlcixncHVBY2NlbGVyYXRpb246byxpc0ZpeGVkOlwiZml4ZWRcIj09PXQub3B0aW9ucy5zdHJhdGVneX07bnVsbCE9dC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMmJih0LnN0eWxlcy5wb3BwZXI9T2JqZWN0LmFzc2lnbih7fSx0LnN0eWxlcy5wb3BwZXIscmUoT2JqZWN0LmFzc2lnbih7fSxjLHtvZmZzZXRzOnQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLHBvc2l0aW9uOnQub3B0aW9ucy5zdHJhdGVneSxhZGFwdGl2ZTphLHJvdW5kT2Zmc2V0czpmfSkpKSksbnVsbCE9dC5tb2RpZmllcnNEYXRhLmFycm93JiYodC5zdHlsZXMuYXJyb3c9T2JqZWN0LmFzc2lnbih7fSx0LnN0eWxlcy5hcnJvdyxyZShPYmplY3QuYXNzaWduKHt9LGMse29mZnNldHM6dC5tb2RpZmllcnNEYXRhLmFycm93LHBvc2l0aW9uOlwiYWJzb2x1dGVcIixhZGFwdGl2ZTohMSxyb3VuZE9mZnNldHM6Zn0pKSkpLHQuYXR0cmlidXRlcy5wb3BwZXI9T2JqZWN0LmFzc2lnbih7fSx0LmF0dHJpYnV0ZXMucG9wcGVyLHtcImRhdGEtcG9wcGVyLXBsYWNlbWVudFwiOnQucGxhY2VtZW50fSl9LGRhdGE6e319O3ZhciBpZT17bmFtZTpcImFwcGx5U3R5bGVzXCIsZW5hYmxlZDohMCxwaGFzZTpcIndyaXRlXCIsZm46ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdGF0ZTtPYmplY3Qua2V5cyh0LmVsZW1lbnRzKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj10LnN0eWxlc1tlXXx8e30sbz10LmF0dHJpYnV0ZXNbZV18fHt9LGk9dC5lbGVtZW50c1tlXTtyKGkpJiZsKGkpJiYoT2JqZWN0LmFzc2lnbihpLnN0eWxlLG4pLE9iamVjdC5rZXlzKG8pLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciB0PW9bZV07ITE9PT10P2kucmVtb3ZlQXR0cmlidXRlKGUpOmkuc2V0QXR0cmlidXRlKGUsITA9PT10P1wiXCI6dCl9KSkpfSkpfSxlZmZlY3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdGF0ZSxuPXtwb3BwZXI6e3Bvc2l0aW9uOnQub3B0aW9ucy5zdHJhdGVneSxsZWZ0OlwiMFwiLHRvcDpcIjBcIixtYXJnaW46XCIwXCJ9LGFycm93Ontwb3NpdGlvbjpcImFic29sdXRlXCJ9LHJlZmVyZW5jZTp7fX07cmV0dXJuIE9iamVjdC5hc3NpZ24odC5lbGVtZW50cy5wb3BwZXIuc3R5bGUsbi5wb3BwZXIpLHQuc3R5bGVzPW4sdC5lbGVtZW50cy5hcnJvdyYmT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLmFycm93LnN0eWxlLG4uYXJyb3cpLGZ1bmN0aW9uKCl7T2JqZWN0LmtleXModC5lbGVtZW50cykuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG89dC5lbGVtZW50c1tlXSxpPXQuYXR0cmlidXRlc1tlXXx8e30sYT1PYmplY3Qua2V5cyh0LnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShlKT90LnN0eWxlc1tlXTpuW2VdKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbdF09XCJcIixlfSkse30pO3IobykmJmwobykmJihPYmplY3QuYXNzaWduKG8uc3R5bGUsYSksT2JqZWN0LmtleXMoaSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7by5yZW1vdmVBdHRyaWJ1dGUoZSl9KSkpfSkpfX0scmVxdWlyZXM6W1wiY29tcHV0ZVN0eWxlc1wiXX07dmFyIGFlPXtuYW1lOlwib2Zmc2V0XCIsZW5hYmxlZDohMCxwaGFzZTpcIm1haW5cIixyZXF1aXJlczpbXCJwb3BwZXJPZmZzZXRzXCJdLGZuOmZ1bmN0aW9uKGUpe3ZhciB0PWUuc3RhdGUsbj1lLm9wdGlvbnMscj1lLm5hbWUsbz1uLm9mZnNldCxpPXZvaWQgMD09PW8/WzAsMF06byxhPVMucmVkdWNlKChmdW5jdGlvbihlLG4pe3JldHVybiBlW25dPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1GKGUpLG89W1AsRF0uaW5kZXhPZihyKT49MD8tMToxLGk9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uKE9iamVjdC5hc3NpZ24oe30sdCx7cGxhY2VtZW50OmV9KSk6bixhPWlbMF0scz1pWzFdO3JldHVybiBhPWF8fDAscz0oc3x8MCkqbyxbUCxMXS5pbmRleE9mKHIpPj0wP3t4OnMseTphfTp7eDphLHk6c319KG4sdC5yZWN0cyxpKSxlfSkse30pLHM9YVt0LnBsYWNlbWVudF0sZj1zLngsYz1zLnk7bnVsbCE9dC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMmJih0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54Kz1mLHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkrPWMpLHQubW9kaWZpZXJzRGF0YVtyXT1hfX0sc2U9e2xlZnQ6XCJyaWdodFwiLHJpZ2h0OlwibGVmdFwiLGJvdHRvbTpcInRvcFwiLHRvcDpcImJvdHRvbVwifTtmdW5jdGlvbiBmZShlKXtyZXR1cm4gZS5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywoZnVuY3Rpb24oZSl7cmV0dXJuIHNlW2VdfSkpfXZhciBjZT17c3RhcnQ6XCJlbmRcIixlbmQ6XCJzdGFydFwifTtmdW5jdGlvbiBwZShlKXtyZXR1cm4gZS5yZXBsYWNlKC9zdGFydHxlbmQvZywoZnVuY3Rpb24oZSl7cmV0dXJuIGNlW2VdfSkpfWZ1bmN0aW9uIHVlKGUsdCl7dm9pZCAwPT09dCYmKHQ9e30pO3ZhciBuPXQscj1uLnBsYWNlbWVudCxvPW4uYm91bmRhcnksaT1uLnJvb3RCb3VuZGFyeSxhPW4ucGFkZGluZyxzPW4uZmxpcFZhcmlhdGlvbnMsZj1uLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxjPXZvaWQgMD09PWY/UzpmLHA9VShyKSx1PXA/cz9SOlIuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gVShlKT09PXB9KSk6ayxsPXUuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gYy5pbmRleE9mKGUpPj0wfSkpOzA9PT1sLmxlbmd0aCYmKGw9dSk7dmFyIGQ9bC5yZWR1Y2UoKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbbl09SihlLHtwbGFjZW1lbnQ6bixib3VuZGFyeTpvLHJvb3RCb3VuZGFyeTppLHBhZGRpbmc6YX0pW0YobildLHR9KSx7fSk7cmV0dXJuIE9iamVjdC5rZXlzKGQpLnNvcnQoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGRbZV0tZFt0XX0pKX12YXIgbGU9e25hbWU6XCJmbGlwXCIsZW5hYmxlZDohMCxwaGFzZTpcIm1haW5cIixmbjpmdW5jdGlvbihlKXt2YXIgdD1lLnN0YXRlLG49ZS5vcHRpb25zLHI9ZS5uYW1lO2lmKCF0Lm1vZGlmaWVyc0RhdGFbcl0uX3NraXApe2Zvcih2YXIgbz1uLm1haW5BeGlzLGk9dm9pZCAwPT09b3x8byxhPW4uYWx0QXhpcyxzPXZvaWQgMD09PWF8fGEsZj1uLmZhbGxiYWNrUGxhY2VtZW50cyxjPW4ucGFkZGluZyxwPW4uYm91bmRhcnksdT1uLnJvb3RCb3VuZGFyeSxsPW4uYWx0Qm91bmRhcnksZD1uLmZsaXBWYXJpYXRpb25zLGg9dm9pZCAwPT09ZHx8ZCxtPW4uYWxsb3dlZEF1dG9QbGFjZW1lbnRzLHY9dC5vcHRpb25zLnBsYWNlbWVudCx5PUYodiksZz1mfHwoeT09PXZ8fCFoP1tmZSh2KV06ZnVuY3Rpb24oZSl7aWYoRihlKT09PU0pcmV0dXJuW107dmFyIHQ9ZmUoZSk7cmV0dXJuW3BlKGUpLHQscGUodCldfSh2KSksYj1bdl0uY29uY2F0KGcpLnJlZHVjZSgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZS5jb25jYXQoRihuKT09PU0/dWUodCx7cGxhY2VtZW50Om4sYm91bmRhcnk6cCxyb290Qm91bmRhcnk6dSxwYWRkaW5nOmMsZmxpcFZhcmlhdGlvbnM6aCxhbGxvd2VkQXV0b1BsYWNlbWVudHM6bX0pOm4pfSksW10pLHg9dC5yZWN0cy5yZWZlcmVuY2Usdz10LnJlY3RzLnBvcHBlcixPPW5ldyBNYXAsaj0hMCxFPWJbMF0saz0wO2s8Yi5sZW5ndGg7aysrKXt2YXIgQj1iW2tdLEg9RihCKSxUPVUoQik9PT1XLFI9W0QsQV0uaW5kZXhPZihIKT49MCxTPVI/XCJ3aWR0aFwiOlwiaGVpZ2h0XCIsVj1KKHQse3BsYWNlbWVudDpCLGJvdW5kYXJ5OnAscm9vdEJvdW5kYXJ5OnUsYWx0Qm91bmRhcnk6bCxwYWRkaW5nOmN9KSxxPVI/VD9MOlA6VD9BOkQ7eFtTXT53W1NdJiYocT1mZShxKSk7dmFyIEM9ZmUocSksTj1bXTtpZihpJiZOLnB1c2goVltIXTw9MCkscyYmTi5wdXNoKFZbcV08PTAsVltDXTw9MCksTi5ldmVyeSgoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KSkpe0U9QixqPSExO2JyZWFrfU8uc2V0KEIsTil9aWYoailmb3IodmFyIEk9ZnVuY3Rpb24oZSl7dmFyIHQ9Yi5maW5kKChmdW5jdGlvbih0KXt2YXIgbj1PLmdldCh0KTtpZihuKXJldHVybiBuLnNsaWNlKDAsZSkuZXZlcnkoKGZ1bmN0aW9uKGUpe3JldHVybiBlfSkpfSkpO2lmKHQpcmV0dXJuIEU9dCxcImJyZWFrXCJ9LF89aD8zOjE7Xz4wO18tLSl7aWYoXCJicmVha1wiPT09SShfKSlicmVha310LnBsYWNlbWVudCE9PUUmJih0Lm1vZGlmaWVyc0RhdGFbcl0uX3NraXA9ITAsdC5wbGFjZW1lbnQ9RSx0LnJlc2V0PSEwKX19LHJlcXVpcmVzSWZFeGlzdHM6W1wib2Zmc2V0XCJdLGRhdGE6e19za2lwOiExfX07ZnVuY3Rpb24gZGUoZSx0LG4pe3JldHVybiBpKGUsYSh0LG4pKX12YXIgaGU9e25hbWU6XCJwcmV2ZW50T3ZlcmZsb3dcIixlbmFibGVkOiEwLHBoYXNlOlwibWFpblwiLGZuOmZ1bmN0aW9uKGUpe3ZhciB0PWUuc3RhdGUsbj1lLm9wdGlvbnMscj1lLm5hbWUsbz1uLm1haW5BeGlzLHM9dm9pZCAwPT09b3x8byxmPW4uYWx0QXhpcyxjPXZvaWQgMCE9PWYmJmYscD1uLmJvdW5kYXJ5LHU9bi5yb290Qm91bmRhcnksbD1uLmFsdEJvdW5kYXJ5LGQ9bi5wYWRkaW5nLGg9bi50ZXRoZXIsbT12b2lkIDA9PT1ofHxoLHY9bi50ZXRoZXJPZmZzZXQseT12b2lkIDA9PT12PzA6dixiPUoodCx7Ym91bmRhcnk6cCxyb290Qm91bmRhcnk6dSxwYWRkaW5nOmQsYWx0Qm91bmRhcnk6bH0pLHg9Rih0LnBsYWNlbWVudCksdz1VKHQucGxhY2VtZW50KSxPPSF3LGo9eih4KSxNPVwieFwiPT09aj9cInlcIjpcInhcIixrPXQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLEI9dC5yZWN0cy5yZWZlcmVuY2UsSD10LnJlY3RzLnBvcHBlcixUPVwiZnVuY3Rpb25cIj09dHlwZW9mIHk/eShPYmplY3QuYXNzaWduKHt9LHQucmVjdHMse3BsYWNlbWVudDp0LnBsYWNlbWVudH0pKTp5LFI9XCJudW1iZXJcIj09dHlwZW9mIFQ/e21haW5BeGlzOlQsYWx0QXhpczpUfTpPYmplY3QuYXNzaWduKHttYWluQXhpczowLGFsdEF4aXM6MH0sVCksUz10Lm1vZGlmaWVyc0RhdGEub2Zmc2V0P3QubW9kaWZpZXJzRGF0YS5vZmZzZXRbdC5wbGFjZW1lbnRdOm51bGwsVj17eDowLHk6MH07aWYoayl7aWYocyl7dmFyIHEsQz1cInlcIj09PWo/RDpQLE49XCJ5XCI9PT1qP0E6TCxJPVwieVwiPT09aj9cImhlaWdodFwiOlwid2lkdGhcIixfPWtbal0sWD1fK2JbQ10sWT1fLWJbTl0sRz1tPy1IW0ldLzI6MCxLPXc9PT1XP0JbSV06SFtJXSxRPXc9PT1XPy1IW0ldOi1CW0ldLFo9dC5lbGVtZW50cy5hcnJvdywkPW0mJlo/ZyhaKTp7d2lkdGg6MCxoZWlnaHQ6MH0sZWU9dC5tb2RpZmllcnNEYXRhW1wiYXJyb3cjcGVyc2lzdGVudFwiXT90Lm1vZGlmaWVyc0RhdGFbXCJhcnJvdyNwZXJzaXN0ZW50XCJdLnBhZGRpbmc6e3RvcDowLHJpZ2h0OjAsYm90dG9tOjAsbGVmdDowfSx0ZT1lZVtDXSxuZT1lZVtOXSxyZT1kZSgwLEJbSV0sJFtJXSksb2U9Tz9CW0ldLzItRy1yZS10ZS1SLm1haW5BeGlzOkstcmUtdGUtUi5tYWluQXhpcyxpZT1PPy1CW0ldLzIrRytyZStuZStSLm1haW5BeGlzOlErcmUrbmUrUi5tYWluQXhpcyxhZT10LmVsZW1lbnRzLmFycm93JiZFKHQuZWxlbWVudHMuYXJyb3cpLHNlPWFlP1wieVwiPT09aj9hZS5jbGllbnRUb3B8fDA6YWUuY2xpZW50TGVmdHx8MDowLGZlPW51bGwhPShxPW51bGw9PVM/dm9pZCAwOlNbal0pP3E6MCxjZT1fK2llLWZlLHBlPWRlKG0/YShYLF8rb2UtZmUtc2UpOlgsXyxtP2koWSxjZSk6WSk7a1tqXT1wZSxWW2pdPXBlLV99aWYoYyl7dmFyIHVlLGxlPVwieFwiPT09aj9EOlAsaGU9XCJ4XCI9PT1qP0E6TCxtZT1rW01dLHZlPVwieVwiPT09TT9cImhlaWdodFwiOlwid2lkdGhcIix5ZT1tZStiW2xlXSxnZT1tZS1iW2hlXSxiZT0tMSE9PVtELFBdLmluZGV4T2YoeCkseGU9bnVsbCE9KHVlPW51bGw9PVM/dm9pZCAwOlNbTV0pP3VlOjAsd2U9YmU/eWU6bWUtQlt2ZV0tSFt2ZV0teGUrUi5hbHRBeGlzLE9lPWJlP21lK0JbdmVdK0hbdmVdLXhlLVIuYWx0QXhpczpnZSxqZT1tJiZiZT9mdW5jdGlvbihlLHQsbil7dmFyIHI9ZGUoZSx0LG4pO3JldHVybiByPm4/bjpyfSh3ZSxtZSxPZSk6ZGUobT93ZTp5ZSxtZSxtP09lOmdlKTtrW01dPWplLFZbTV09amUtbWV9dC5tb2RpZmllcnNEYXRhW3JdPVZ9fSxyZXF1aXJlc0lmRXhpc3RzOltcIm9mZnNldFwiXX07dmFyIG1lPXtuYW1lOlwiYXJyb3dcIixlbmFibGVkOiEwLHBoYXNlOlwibWFpblwiLGZuOmZ1bmN0aW9uKGUpe3ZhciB0LG49ZS5zdGF0ZSxyPWUubmFtZSxvPWUub3B0aW9ucyxpPW4uZWxlbWVudHMuYXJyb3csYT1uLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxzPUYobi5wbGFjZW1lbnQpLGY9eihzKSxjPVtQLExdLmluZGV4T2Yocyk+PTA/XCJoZWlnaHRcIjpcIndpZHRoXCI7aWYoaSYmYSl7dmFyIHA9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gWShcIm51bWJlclwiIT10eXBlb2YoZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2UoT2JqZWN0LmFzc2lnbih7fSx0LnJlY3RzLHtwbGFjZW1lbnQ6dC5wbGFjZW1lbnR9KSk6ZSk/ZTpHKGUsaykpfShvLnBhZGRpbmcsbiksdT1nKGkpLGw9XCJ5XCI9PT1mP0Q6UCxkPVwieVwiPT09Zj9BOkwsaD1uLnJlY3RzLnJlZmVyZW5jZVtjXStuLnJlY3RzLnJlZmVyZW5jZVtmXS1hW2ZdLW4ucmVjdHMucG9wcGVyW2NdLG09YVtmXS1uLnJlY3RzLnJlZmVyZW5jZVtmXSx2PUUoaSkseT12P1wieVwiPT09Zj92LmNsaWVudEhlaWdodHx8MDp2LmNsaWVudFdpZHRofHwwOjAsYj1oLzItbS8yLHg9cFtsXSx3PXktdVtjXS1wW2RdLE89eS8yLXVbY10vMitiLGo9ZGUoeCxPLHcpLE09ZjtuLm1vZGlmaWVyc0RhdGFbcl09KCh0PXt9KVtNXT1qLHQuY2VudGVyT2Zmc2V0PWotTyx0KX19LGVmZmVjdDpmdW5jdGlvbihlKXt2YXIgdD1lLnN0YXRlLG49ZS5vcHRpb25zLmVsZW1lbnQscj12b2lkIDA9PT1uP1wiW2RhdGEtcG9wcGVyLWFycm93XVwiOm47bnVsbCE9ciYmKFwic3RyaW5nXCIhPXR5cGVvZiByfHwocj10LmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKHIpKSkmJkModC5lbGVtZW50cy5wb3BwZXIscikmJih0LmVsZW1lbnRzLmFycm93PXIpfSxyZXF1aXJlczpbXCJwb3BwZXJPZmZzZXRzXCJdLHJlcXVpcmVzSWZFeGlzdHM6W1wicHJldmVudE92ZXJmbG93XCJdfTtmdW5jdGlvbiB2ZShlLHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPXt4OjAseTowfSkse3RvcDplLnRvcC10LmhlaWdodC1uLnkscmlnaHQ6ZS5yaWdodC10LndpZHRoK24ueCxib3R0b206ZS5ib3R0b20tdC5oZWlnaHQrbi55LGxlZnQ6ZS5sZWZ0LXQud2lkdGgtbi54fX1mdW5jdGlvbiB5ZShlKXtyZXR1cm5bRCxMLEEsUF0uc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF0+PTB9KSl9dmFyIGdlPXtuYW1lOlwiaGlkZVwiLGVuYWJsZWQ6ITAscGhhc2U6XCJtYWluXCIscmVxdWlyZXNJZkV4aXN0czpbXCJwcmV2ZW50T3ZlcmZsb3dcIl0sZm46ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdGF0ZSxuPWUubmFtZSxyPXQucmVjdHMucmVmZXJlbmNlLG89dC5yZWN0cy5wb3BwZXIsaT10Lm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93LGE9Sih0LHtlbGVtZW50Q29udGV4dDpcInJlZmVyZW5jZVwifSkscz1KKHQse2FsdEJvdW5kYXJ5OiEwfSksZj12ZShhLHIpLGM9dmUocyxvLGkpLHA9eWUoZiksdT15ZShjKTt0Lm1vZGlmaWVyc0RhdGFbbl09e3JlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czpmLHBvcHBlckVzY2FwZU9mZnNldHM6Yyxpc1JlZmVyZW5jZUhpZGRlbjpwLGhhc1BvcHBlckVzY2FwZWQ6dX0sdC5hdHRyaWJ1dGVzLnBvcHBlcj1PYmplY3QuYXNzaWduKHt9LHQuYXR0cmlidXRlcy5wb3BwZXIse1wiZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlblwiOnAsXCJkYXRhLXBvcHBlci1lc2NhcGVkXCI6dX0pfX0sYmU9Wih7ZGVmYXVsdE1vZGlmaWVyczpbZWUsdGUsb2UsaWVdfSkseGU9W2VlLHRlLG9lLGllLGFlLGxlLGhlLG1lLGdlXSx3ZT1aKHtkZWZhdWx0TW9kaWZpZXJzOnhlfSk7ZS5hcHBseVN0eWxlcz1pZSxlLmFycm93PW1lLGUuY29tcHV0ZVN0eWxlcz1vZSxlLmNyZWF0ZVBvcHBlcj13ZSxlLmNyZWF0ZVBvcHBlckxpdGU9YmUsZS5kZWZhdWx0TW9kaWZpZXJzPXhlLGUuZGV0ZWN0T3ZlcmZsb3c9SixlLmV2ZW50TGlzdGVuZXJzPWVlLGUuZmxpcD1sZSxlLmhpZGU9Z2UsZS5vZmZzZXQ9YWUsZS5wb3BwZXJHZW5lcmF0b3I9WixlLnBvcHBlck9mZnNldHM9dGUsZS5wcmV2ZW50T3ZlcmZsb3c9aGUsT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXIubWluLmpzLm1hcCIsIi8qIVxuICogQHNwbGlkZWpzL3NwbGlkZS1leHRlbnNpb24tZ3JpZFxuICogVmVyc2lvbiAgOiAwLjQuMVxuICogTGljZW5zZSAgOiBNSVRcbiAqIENvcHlyaWdodDogMjAyMiBOYW90b3NoaSBGdWppdGFcbiovKGZ1bmN0aW9uKE8pe3R5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZD9kZWZpbmUoTyk6TygpfSkoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBPKG4pe24ubGVuZ3RoPTB9ZnVuY3Rpb24gUyhuLHQsaSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4sdCxpKX1mdW5jdGlvbiBUKG4pe3JldHVybiBuLmJpbmQuYXBwbHkobixbbnVsbF0uY29uY2F0KFMoYXJndW1lbnRzLDEpKSl9ZnVuY3Rpb24gVihuLHQpe3JldHVybiB0eXBlb2YgdD09PW59dmFyIFE9QXJyYXkuaXNBcnJheTtUKFYsXCJmdW5jdGlvblwiKSxUKFYsXCJzdHJpbmdcIiksVChWLFwidW5kZWZpbmVkXCIpO2Z1bmN0aW9uIFgobil7cmV0dXJuIFEobik/bjpbbl19ZnVuY3Rpb24gWihuLHQpe1gobikuZm9yRWFjaCh0KX12YXIgaG49T2JqZWN0LmtleXM7ZnVuY3Rpb24gRW4obix0LGkpe2lmKG4pe3ZhciByPWhuKG4pO3I9aT9yLnJldmVyc2UoKTpyO2Zvcih2YXIgZj0wO2Y8ci5sZW5ndGg7ZisrKXt2YXIgYT1yW2ZdO2lmKGEhPT1cIl9fcHJvdG9fX1wiJiZ0KG5bYV0sYSk9PT0hMSlicmVha319cmV0dXJuIG59ZnVuY3Rpb24gZ24obil7cmV0dXJuIFMoYXJndW1lbnRzLDEpLmZvckVhY2goZnVuY3Rpb24odCl7RW4odCxmdW5jdGlvbihpLHIpe25bcl09dFtyXX0pfSksbn12YXIgaj1cInNwbGlkZVwiO2Z1bmN0aW9uIG1uKCl7dmFyIG49W107ZnVuY3Rpb24gdCh1LGMsbCx2KXtmKHUsYyxmdW5jdGlvbihkLGcsbSl7dmFyIF89XCJhZGRFdmVudExpc3RlbmVyXCJpbiBkLEM9Xz9kLnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZChkLGcsbCx2KTpkLnJlbW92ZUxpc3RlbmVyLmJpbmQoZCxsKTtfP2QuYWRkRXZlbnRMaXN0ZW5lcihnLGwsdik6ZC5hZGRMaXN0ZW5lcihsKSxuLnB1c2goW2QsZyxtLGwsQ10pfSl9ZnVuY3Rpb24gaSh1LGMsbCl7Zih1LGMsZnVuY3Rpb24odixkLGcpe249bi5maWx0ZXIoZnVuY3Rpb24obSl7cmV0dXJuIG1bMF09PT12JiZtWzFdPT09ZCYmbVsyXT09PWcmJighbHx8bVszXT09PWwpPyhtWzRdKCksITEpOiEwfSl9KX1mdW5jdGlvbiByKHUsYyxsKXt2YXIgdixkPSEwO3JldHVybiB0eXBlb2YgQ3VzdG9tRXZlbnQ9PVwiZnVuY3Rpb25cIj92PW5ldyBDdXN0b21FdmVudChjLHtidWJibGVzOmQsZGV0YWlsOmx9KToodj1kb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpLHYuaW5pdEN1c3RvbUV2ZW50KGMsZCwhMSxsKSksdS5kaXNwYXRjaEV2ZW50KHYpLHZ9ZnVuY3Rpb24gZih1LGMsbCl7Wih1LGZ1bmN0aW9uKHYpe3YmJlooYyxmdW5jdGlvbihkKXtkLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGcpe3ZhciBtPWcuc3BsaXQoXCIuXCIpO2wodixtWzBdLG1bMV0pfSl9KX0pfWZ1bmN0aW9uIGEoKXtuLmZvckVhY2goZnVuY3Rpb24odSl7dVs0XSgpfSksTyhuKX1yZXR1cm57YmluZDp0LHVuYmluZDppLGRpc3BhdGNoOnIsZGVzdHJveTphfX12YXIgcG49XCJ2aXNpYmxlXCIseW49XCJoaWRkZW5cIixIPVwicmVmcmVzaFwiLHduPVwidXBkYXRlZFwiLF9uPVwiZGVzdHJveVwiO2Z1bmN0aW9uIGsobil7dmFyIHQ9bj9uLmV2ZW50LmJ1czpkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksaT1tbigpO2Z1bmN0aW9uIHIoYSx1KXtpLmJpbmQodCxYKGEpLmpvaW4oXCIgXCIpLGZ1bmN0aW9uKGMpe3UuYXBwbHkodSxRKGMuZGV0YWlsKT9jLmRldGFpbDpbXSl9KX1mdW5jdGlvbiBmKGEpe2kuZGlzcGF0Y2godCxhLFMoYXJndW1lbnRzLDEpKX1yZXR1cm4gbiYmbi5ldmVudC5vbihfbixpLmRlc3Ryb3kpLGduKGkse2J1czp0LG9uOnIsb2ZmOlQoaS51bmJpbmQsdCksZW1pdDpmfSl9dmFyIENuPWosJD1qK1wiX19zbGlkZVwiLEFuPSQrXCJfX2NvbnRhaW5lclwiO2Z1bmN0aW9uIG5uKG4pe24ubGVuZ3RoPTB9ZnVuY3Rpb24gSShuLHQsaSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4sdCxpKX1mdW5jdGlvbiBCKG4pe3JldHVybiBuLmJpbmQuYXBwbHkobixbbnVsbF0uY29uY2F0KEkoYXJndW1lbnRzLDEpKSl9ZnVuY3Rpb24gTihuLHQpe3JldHVybiB0eXBlb2YgdD09PW59ZnVuY3Rpb24gYm4obil7cmV0dXJuIVAobikmJk4oXCJvYmplY3RcIixuKX12YXIgRj1BcnJheS5pc0FycmF5O0IoTixcImZ1bmN0aW9uXCIpO3ZhciBHPUIoTixcInN0cmluZ1wiKSxMbj1CKE4sXCJ1bmRlZmluZWRcIik7ZnVuY3Rpb24gUChuKXtyZXR1cm4gbj09PW51bGx9ZnVuY3Rpb24gRG4obil7cmV0dXJuIG4gaW5zdGFuY2VvZiBIVE1MRWxlbWVudH1mdW5jdGlvbiBVKG4pe3JldHVybiBGKG4pP246W25dfWZ1bmN0aW9uIEEobix0KXtVKG4pLmZvckVhY2godCl9ZnVuY3Rpb24gdG4obix0KXtyZXR1cm4gbi5wdXNoLmFwcGx5KG4sVSh0KSksbn1mdW5jdGlvbiBybihuLHQsaSl7biYmQSh0LGZ1bmN0aW9uKHIpe3ImJm4uY2xhc3NMaXN0W2k/XCJhZGRcIjpcInJlbW92ZVwiXShyKX0pfWZ1bmN0aW9uIHEobix0KXtybihuLEcodCk/dC5zcGxpdChcIiBcIik6dCwhMCl9ZnVuY3Rpb24gUihuLHQpe0EodCxuLmFwcGVuZENoaWxkLmJpbmQobikpfWZ1bmN0aW9uIE9uKG4sdCl7cmV0dXJuIERuKG4pJiYobi5tc01hdGNoZXNTZWxlY3Rvcnx8bi5tYXRjaGVzKS5jYWxsKG4sdCl9ZnVuY3Rpb24gVG4obix0KXt2YXIgaT1uP0kobi5jaGlsZHJlbik6W107cmV0dXJuIHQ/aS5maWx0ZXIoZnVuY3Rpb24ocil7cmV0dXJuIE9uKHIsdCl9KTppfWZ1bmN0aW9uIG9uKG4sdCl7cmV0dXJuIHQ/VG4obix0KVswXTpuLmZpcnN0RWxlbWVudENoaWxkfXZhciBlbj1PYmplY3Qua2V5cztmdW5jdGlvbiB1bihuLHQsaSl7aWYobil7dmFyIHI9ZW4obik7cj1pP3IucmV2ZXJzZSgpOnI7Zm9yKHZhciBmPTA7ZjxyLmxlbmd0aDtmKyspe3ZhciBhPXJbZl07aWYoYSE9PVwiX19wcm90b19fXCImJnQoblthXSxhKT09PSExKWJyZWFrfX1yZXR1cm4gbn1mdW5jdGlvbiAkbihuKXtyZXR1cm4gSShhcmd1bWVudHMsMSkuZm9yRWFjaChmdW5jdGlvbih0KXt1bih0LGZ1bmN0aW9uKGkscil7bltyXT10W3JdfSl9KSxufWZ1bmN0aW9uIEluKG4sdCl7VSh0fHxlbihuKSkuZm9yRWFjaChmdW5jdGlvbihpKXtkZWxldGUgbltpXX0pfWZ1bmN0aW9uIEoobix0KXtBKG4sZnVuY3Rpb24oaSl7QSh0LGZ1bmN0aW9uKHIpe2kmJmkucmVtb3ZlQXR0cmlidXRlKHIpfSl9KX1mdW5jdGlvbiBLKG4sdCxpKXtibih0KT91bih0LGZ1bmN0aW9uKHIsZil7SyhuLGYscil9KTpBKG4sZnVuY3Rpb24ocil7UChpKXx8aT09PVwiXCI/SihyLHQpOnIuc2V0QXR0cmlidXRlKHQsU3RyaW5nKGkpKX0pfWZ1bmN0aW9uIGZuKG4sdCxpKXt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KG4pO3JldHVybiB0JiYoRyh0KT9xKHIsdCk6SyhyLHQpKSxpJiZSKGkscikscn1mdW5jdGlvbiBwKG4sdCxpKXtpZihMbihpKSlyZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShuKVt0XTtQKGkpfHwobi5zdHlsZVt0XT1cIlwiK2kpfWZ1bmN0aW9uIE5uKG4sdCl7cmV0dXJuIG4mJm4uY2xhc3NMaXN0LmNvbnRhaW5zKHQpfWZ1bmN0aW9uIFJuKG4pe0EobixmdW5jdGlvbih0KXt0JiZ0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KX0pfWZ1bmN0aW9uIGFuKG4sdCl7cmV0dXJuIHQ/SShuLnF1ZXJ5U2VsZWN0b3JBbGwodCkpOltdfWZ1bmN0aW9uIGNuKG4sdCl7cm4obix0LCExKX1mdW5jdGlvbiB4KG4pe3JldHVybiBHKG4pP246bj9uK1wicHhcIjpcIlwifXZhciB4bj1cInNwbGlkZVwiO2Z1bmN0aW9uIE1uKG4sdCl7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiW1wiK3huK1wiXSBcIisodHx8XCJcIikpfXZhciBTbj1NYXRoLm1pbixVbj1NYXRoLm1heCxxbj1NYXRoLmZsb29yLEpuPU1hdGguY2VpbCxLbj1NYXRoLmFicztmdW5jdGlvbiBWbihuKXtyZXR1cm4gbjwxMD9cIjBcIituOlwiXCIrbn12YXIgc249JCtcIl9fcm93XCIsej0kK1wiLS1jb2xcIixIbj17cm93czoxLGNvbHM6MSxkaW1lbnNpb25zOltdLGdhcDp7fX07ZnVuY3Rpb24gQm4obil7ZnVuY3Rpb24gdCgpe3ZhciBmPW4ucm93cyxhPW4uY29scyx1PW4uZGltZW5zaW9ucztyZXR1cm4gRih1KSYmdS5sZW5ndGg/dTpbW2YsYV1dfWZ1bmN0aW9uIGkoZil7dmFyIGE9dCgpO3JldHVybiBhW1NuKGYsYS5sZW5ndGgtMSldfWZ1bmN0aW9uIHIoZil7Zm9yKHZhciBhPXQoKSx1LGMsbD0wLHY9MDt2PGEubGVuZ3RoO3YrKyl7dmFyIGQ9YVt2XTtpZih1PWRbMF18fDEsYz1kWzFdfHwxLGwrPXUqYyxmPGwpYnJlYWt9cmV0dXJuIE1uKHUmJmMsXCJJbnZhbGlkIGRpbWVuc2lvblwiKSxbdSxjXX1yZXR1cm57Z2V0OmksZ2V0QXQ6cn19ZnVuY3Rpb24gRm4obix0LGkpe3ZhciByPWsobiksZj1yLm9uLGE9ci5kZXN0cm95LHU9bi5Db21wb25lbnRzLGM9bi5vcHRpb25zLGw9dS5EaXJlY3Rpb24ucmVzb2x2ZSx2PXUuU2xpZGVzLmZvckVhY2g7ZnVuY3Rpb24gZCgpe20oKSxjLnNsaWRlRm9jdXMmJihmKHBuLFcpLGYoeW4sWSkpfWZ1bmN0aW9uIGcoKXt2KGZ1bmN0aW9uKGUpe3ZhciBzPWUuc2xpZGU7RChzLCExKSxNKHMpLmZvckVhY2goZnVuY3Rpb24obyl7SihvLFwic3R5bGVcIil9KSxiKHMpLmZvckVhY2goZnVuY3Rpb24obyl7TChvLCEwKSxKKG8sXCJzdHlsZVwiKX0pfSksYSgpfWZ1bmN0aW9uIG0oKXt2KGZ1bmN0aW9uKGUpe3ZhciBzPWUuc2xpZGUsbz1pLmdldChlLmlzQ2xvbmU/ZS5zbGlkZUluZGV4OmUuaW5kZXgpLGg9b1swXSxFPW9bMV07XyhoLHMpLEMoRSxzKSxiKGUuc2xpZGUpLmZvckVhY2goZnVuY3Rpb24oeSx3KXt5LmlkPWUuc2xpZGUuaWQrXCItY29sXCIrVm4odysxKSxuLm9wdGlvbnMuY292ZXImJkwoeSl9KX0pfWZ1bmN0aW9uIF8oZSxzKXt2YXIgbz10LmdhcC5yb3csaD1cImNhbGMoXCIrMTAwL2UrXCIlXCIrKG8/XCIgLSBcIit4KG8pK1wiICogXCIrKGUtMSkvZTpcIlwiKStcIilcIjtNKHMpLmZvckVhY2goZnVuY3Rpb24oRSx5LHcpe3AoRSxcImhlaWdodFwiLGgpLHAoRSxcImRpc3BsYXlcIixcImZsZXhcIikscChFLFwibWFyZ2luXCIsXCIwIDAgXCIreChvKStcIiAwXCIpLHAoRSxcInBhZGRpbmdcIiwwKSx5PT09dy5sZW5ndGgtMSYmcChFLFwibWFyZ2luQm90dG9tXCIsMCl9KX1mdW5jdGlvbiBDKGUscyl7dmFyIG89dC5nYXAuY29sLGg9XCJjYWxjKFwiKzEwMC9lK1wiJVwiKyhvP1wiIC0gXCIreChvKStcIiAqIFwiKyhlLTEpL2U6XCJcIikrXCIpXCI7YihzKS5mb3JFYWNoKGZ1bmN0aW9uKEUseSx3KXtwKEUsXCJ3aWR0aFwiLGgpLHkhPT13Lmxlbmd0aC0xJiZwKEUsbChcIm1hcmdpblJpZ2h0XCIpLHgobykpfSl9ZnVuY3Rpb24gTChlLHMpe3ZhciBvPW9uKGUsXCIuXCIrQW4pLGg9b24ob3x8ZSxcImltZ1wiKTtoJiZoLnNyYyYmKHAob3x8ZSxcImJhY2tncm91bmRcIixzP1wiXCI6J2NlbnRlci9jb3ZlciBuby1yZXBlYXQgdXJsKFwiJytoLnNyYysnXCIpJykscChoLFwiZGlzcGxheVwiLHM/XCJcIjpcIm5vbmVcIikpfWZ1bmN0aW9uIE0oZSl7cmV0dXJuIGFuKGUsXCIuXCIrc24pfWZ1bmN0aW9uIGIoZSl7cmV0dXJuIGFuKGUsXCIuXCIreil9ZnVuY3Rpb24gRChlLHMpe2IoZSkuZm9yRWFjaChmdW5jdGlvbihvKXtLKG8sXCJ0YWJpbmRleFwiLHM/MDpudWxsKX0pfWZ1bmN0aW9uIFcoZSl7RChlLnNsaWRlLCEwKX1mdW5jdGlvbiBZKGUpe0QoZS5zbGlkZSwhMSl9cmV0dXJue21vdW50OmQsZGVzdHJveTpnfX1mdW5jdGlvbiBHbihuLHQsaSl7dmFyIHI9ayhuKSxmPXIub24sYT1yLm9mZix1PXQuRWxlbWVudHMsYz17fSxsPUJuKGMpLHY9Rm4obixjLGwpLGQ9Q24rXCItLWdyaWRcIixnPVtdO2Z1bmN0aW9uIG0oKXtfKCksZih3bixfKX1mdW5jdGlvbiBfKCl7SW4oYyksJG4oYyxIbixpLmdyaWR8fHt9KSxZKCk/KEMoKSx0bihnLHUuc2xpZGVzKSxxKG4ucm9vdCxkKSxSKHUubGlzdCxiKCkpLGEoSCksZihILE0pLEwoKSk6ZSgpJiYoQygpLEwoKSl9ZnVuY3Rpb24gQygpe2lmKGUoKSl7dmFyIHM9dS5zbGlkZXM7di5kZXN0cm95KCksZy5mb3JFYWNoKGZ1bmN0aW9uKG8pe2NuKG8seiksUih1Lmxpc3Qsbyl9KSxSbihzKSxjbihuLnJvb3QsZCksbm4ocyksdG4ocyxnKSxubihnKSxhKEgpfX1mdW5jdGlvbiBMKCl7bi5yZWZyZXNoKCl9ZnVuY3Rpb24gTSgpe2UoKSYmdi5tb3VudCgpfWZ1bmN0aW9uIGIoKXt2YXIgcz1bXSxvPTAsaD0wLEUseTtyZXR1cm4gZy5mb3JFYWNoKGZ1bmN0aW9uKHcsUG4pe3ZhciBkbj1sLmdldEF0KFBuKSx2bj1kblswXSxsbj1kblsxXTtofHwob3x8KEU9Zm4ody50YWdOYW1lLCQpLHMucHVzaChFKSkseT1EKHZuLHcsRSkpLFcobG4sdyx5KSwrK2g+PWxuJiYoaD0wLG89KytvPj12bj8wOm8pfSksc31mdW5jdGlvbiBEKHMsbyxoKXt2YXIgRT1vLnRhZ05hbWUudG9Mb3dlckNhc2UoKT09PVwibGlcIj9cInVsXCI6XCJkaXZcIjtyZXR1cm4gZm4oRSxzbixoKX1mdW5jdGlvbiBXKHMsbyxoKXtyZXR1cm4gcShvLHopLFIoaCxvKSxvfWZ1bmN0aW9uIFkoKXtpZihpLmdyaWQpe3ZhciBzPWMucm93cyxvPWMuY29scyxoPWMuZGltZW5zaW9ucztyZXR1cm4gcz4xfHxvPjF8fEYoaCkmJmgubGVuZ3RoPjB9cmV0dXJuITF9ZnVuY3Rpb24gZSgpe3JldHVybiBObihuLnJvb3QsZCl9cmV0dXJue21vdW50Om0sZGVzdHJveTpDfX10eXBlb2Ygd2luZG93PFwidVwiJiYod2luZG93LnNwbGlkZT13aW5kb3cuc3BsaWRlfHx7fSx3aW5kb3cuc3BsaWRlLkV4dGVuc2lvbnM9d2luZG93LnNwbGlkZS5FeHRlbnNpb25zfHx7fSx3aW5kb3cuc3BsaWRlLkV4dGVuc2lvbnMuR3JpZD1Hbil9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwbGlkZS1leHRlbnNpb24tZ3JpZC5taW4uanMubWFwIiwiZnVuY3Rpb24gcihuLHQpe2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKXt2YXIgcj10W2ldO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobixyLmtleSxyKX19ZnVuY3Rpb24gSnQobix0LGkpe3QmJnIobi5wcm90b3R5cGUsdCksaSYmcihuLGkpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSl9XG4vKiFcbiAqIFNwbGlkZS5qc1xuICogVmVyc2lvbiAgOiA0LjEuNFxuICogTGljZW5zZSAgOiBNSVRcbiAqIENvcHlyaWdodDogMjAyMiBOYW90b3NoaSBGdWppdGFcbiAqL1xudmFyIG4sdDtuPXRoaXMsdD1mdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciB2PVwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIixHPTQscm49NSxyPXtDUkVBVEVEOjEsTU9VTlRFRDoyLElETEU6MyxNT1ZJTkc6RyxTQ1JPTExJTkc6cm4sRFJBR0dJTkc6NixERVNUUk9ZRUQ6N307ZnVuY3Rpb24gRChuKXtuLmxlbmd0aD0wfWZ1bmN0aW9uIG8obix0LGkpe3JldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuLHQsaSl9ZnVuY3Rpb24gUihuKXtyZXR1cm4gbi5iaW5kLmFwcGx5KG4sW251bGxdLmNvbmNhdChvKGFyZ3VtZW50cywxKSkpfWZ1bmN0aW9uIG9uKCl7fXZhciBwPXNldFRpbWVvdXQ7ZnVuY3Rpb24gaChuKXtyZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG4pfWZ1bmN0aW9uIHUobix0KXtyZXR1cm4gdHlwZW9mIHQ9PT1ufWZ1bmN0aW9uIHVuKG4pe3JldHVybiFjKG4pJiZ1KFwib2JqZWN0XCIsbil9dmFyIGU9QXJyYXkuaXNBcnJheSx4PVIodSxcImZ1bmN0aW9uXCIpLEM9Uih1LFwic3RyaW5nXCIpLGVuPVIodSxcInVuZGVmaW5lZFwiKTtmdW5jdGlvbiBjKG4pe3JldHVybiBudWxsPT09bn1mdW5jdGlvbiBtKG4pe3RyeXtyZXR1cm4gbiBpbnN0YW5jZW9mKG4ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlld3x8d2luZG93KS5IVE1MRWxlbWVudH1jYXRjaChuKXtyZXR1cm4hMX19ZnVuY3Rpb24geShuKXtyZXR1cm4gZShuKT9uOltuXX1mdW5jdGlvbiBnKG4sdCl7eShuKS5mb3JFYWNoKHQpfWZ1bmN0aW9uIGIobix0KXtyZXR1cm4tMTxuLmluZGV4T2YodCl9ZnVuY3Rpb24gayhuLHQpe3JldHVybiBuLnB1c2guYXBwbHkobix5KHQpKSxufWZ1bmN0aW9uIEEodCxuLGkpe3QmJmcobixmdW5jdGlvbihuKXtuJiZ0LmNsYXNzTGlzdFtpP1wiYWRkXCI6XCJyZW1vdmVcIl0obil9KX1mdW5jdGlvbiBNKG4sdCl7QShuLEModCk/dC5zcGxpdChcIiBcIik6dCwhMCl9ZnVuY3Rpb24gTChuLHQpe2codCxuLmFwcGVuZENoaWxkLmJpbmQobikpfWZ1bmN0aW9uIE8obixpKXtnKG4sZnVuY3Rpb24obil7dmFyIHQ9KGl8fG4pLnBhcmVudE5vZGU7dCYmdC5pbnNlcnRCZWZvcmUobixpKX0pfWZ1bmN0aW9uIGNuKG4sdCl7cmV0dXJuIG0obikmJihuLm1zTWF0Y2hlc1NlbGVjdG9yfHxuLm1hdGNoZXMpLmNhbGwobix0KX1mdW5jdGlvbiBTKG4sdCl7bj1uP28obi5jaGlsZHJlbik6W107cmV0dXJuIHQ/bi5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIGNuKG4sdCl9KTpufWZ1bmN0aW9uIGZuKG4sdCl7cmV0dXJuIHQ/UyhuLHQpWzBdOm4uZmlyc3RFbGVtZW50Q2hpbGR9dmFyIEU9T2JqZWN0LmtleXM7ZnVuY3Rpb24gdyh0LGksbil7dCYmKG4/RSh0KS5yZXZlcnNlKCk6RSh0KSkuZm9yRWFjaChmdW5jdGlvbihuKXtcIl9fcHJvdG9fX1wiIT09biYmaSh0W25dLG4pfSl9ZnVuY3Rpb24gYW4ocil7cmV0dXJuIG8oYXJndW1lbnRzLDEpLmZvckVhY2goZnVuY3Rpb24oaSl7dyhpLGZ1bmN0aW9uKG4sdCl7clt0XT1pW3RdfSl9KSxyfWZ1bmN0aW9uIGQoaSl7cmV0dXJuIG8oYXJndW1lbnRzLDEpLmZvckVhY2goZnVuY3Rpb24obil7dyhuLGZ1bmN0aW9uKG4sdCl7ZShuKT9pW3RdPW4uc2xpY2UoKTp1bihuKT9pW3RdPWQoe30sdW4oaVt0XSk/aVt0XTp7fSxuKTppW3RdPW59KX0pLGl9ZnVuY3Rpb24gc24odCxuKXtnKG58fEUodCksZnVuY3Rpb24obil7ZGVsZXRlIHRbbl19KX1mdW5jdGlvbiBQKG4saSl7ZyhuLGZ1bmN0aW9uKHQpe2coaSxmdW5jdGlvbihuKXt0JiZ0LnJlbW92ZUF0dHJpYnV0ZShuKX0pfSl9ZnVuY3Rpb24gSShpLHQscil7dW4odCk/dyh0LGZ1bmN0aW9uKG4sdCl7SShpLHQsbil9KTpnKGksZnVuY3Rpb24obil7YyhyKXx8XCJcIj09PXI/UChuLHQpOm4uc2V0QXR0cmlidXRlKHQsU3RyaW5nKHIpKX0pfWZ1bmN0aW9uIGoobix0LGkpe249ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuKTtyZXR1cm4gdCYmKEModCk/TTpJKShuLHQpLGkmJkwoaSxuKSxufWZ1bmN0aW9uIF8obix0LGkpe2lmKGVuKGkpKXJldHVybiBnZXRDb21wdXRlZFN0eWxlKG4pW3RdO2MoaSl8fChuLnN0eWxlW3RdPVwiXCIraSl9ZnVuY3Rpb24gbG4obix0KXtfKG4sXCJkaXNwbGF5XCIsdCl9ZnVuY3Rpb24gZG4obil7bi5zZXRBY3RpdmUmJm4uc2V0QWN0aXZlKCl8fG4uZm9jdXMoe3ByZXZlbnRTY3JvbGw6ITB9KX1mdW5jdGlvbiB6KG4sdCl7cmV0dXJuIG4uZ2V0QXR0cmlidXRlKHQpfWZ1bmN0aW9uIHZuKG4sdCl7cmV0dXJuIG4mJm4uY2xhc3NMaXN0LmNvbnRhaW5zKHQpfWZ1bmN0aW9uIE4obil7cmV0dXJuIG4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCl9ZnVuY3Rpb24gVChuKXtnKG4sZnVuY3Rpb24obil7biYmbi5wYXJlbnROb2RlJiZuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobil9KX1mdW5jdGlvbiBobihuKXtyZXR1cm4gZm4oKG5ldyBET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyhuLFwidGV4dC9odG1sXCIpLmJvZHkpfWZ1bmN0aW9uIEYobix0KXtuLnByZXZlbnREZWZhdWx0KCksdCYmKG4uc3RvcFByb3BhZ2F0aW9uKCksbi5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSl9ZnVuY3Rpb24gcG4obix0KXtyZXR1cm4gbiYmbi5xdWVyeVNlbGVjdG9yKHQpfWZ1bmN0aW9uIGduKG4sdCl7cmV0dXJuIHQ/byhuLnF1ZXJ5U2VsZWN0b3JBbGwodCkpOltdfWZ1bmN0aW9uIFgobix0KXtBKG4sdCwhMSl9ZnVuY3Rpb24gbW4obil7cmV0dXJuIG4udGltZVN0YW1wfWZ1bmN0aW9uIFcobil7cmV0dXJuIEMobik/bjpuP24rXCJweFwiOlwiXCJ9dmFyIHluPVwic3BsaWRlXCIsZj1cImRhdGEtXCIreW47ZnVuY3Rpb24gYm4obix0KXtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJbXCIreW4rXCJdIFwiKyh0fHxcIlwiKSl9dmFyIFk9TWF0aC5taW4sd249TWF0aC5tYXgseG49TWF0aC5mbG9vcixrbj1NYXRoLmNlaWwsVT1NYXRoLmFicztmdW5jdGlvbiBTbihuLHQsaSl7cmV0dXJuIFUobi10KTxpfWZ1bmN0aW9uIEVuKG4sdCxpLHIpe3ZhciBvPVkodCxpKSx0PXduKHQsaSk7cmV0dXJuIHI/bzxuJiZuPHQ6bzw9biYmbjw9dH1mdW5jdGlvbiBxKG4sdCxpKXt2YXIgcj1ZKHQsaSksdD13bih0LGkpO3JldHVybiBZKHduKHIsbiksdCl9ZnVuY3Rpb24gTG4obil7cmV0dXJuKDA8biktKG48MCl9ZnVuY3Rpb24gT24odCxuKXtyZXR1cm4gZyhuLGZ1bmN0aW9uKG4pe3Q9dC5yZXBsYWNlKFwiJXNcIixcIlwiK24pfSksdH1mdW5jdGlvbiBBbihuKXtyZXR1cm4gbjwxMD9cIjBcIituOlwiXCIrbn12YXIgX249e307ZnVuY3Rpb24gem4oKXt2YXIgYz1bXTtmdW5jdGlvbiBpKG4saSxyKXtnKG4sZnVuY3Rpb24odCl7dCYmZyhpLGZ1bmN0aW9uKG4pe24uc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24obil7bj1uLnNwbGl0KFwiLlwiKTtyKHQsblswXSxuWzFdKX0pfSl9KX1yZXR1cm57YmluZDpmdW5jdGlvbihuLHQsdSxlKXtpKG4sdCxmdW5jdGlvbihuLHQsaSl7dmFyIHI9XCJhZGRFdmVudExpc3RlbmVyXCJpbiBuLG89cj9uLnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZChuLHQsdSxlKTpuLnJlbW92ZUxpc3RlbmVyLmJpbmQobix1KTtyP24uYWRkRXZlbnRMaXN0ZW5lcih0LHUsZSk6bi5hZGRMaXN0ZW5lcih1KSxjLnB1c2goW24sdCxpLHUsb10pfSl9LHVuYmluZDpmdW5jdGlvbihuLHQsbyl7aShuLHQsZnVuY3Rpb24odCxpLHIpe2M9Yy5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuISEoblswXSE9PXR8fG5bMV0hPT1pfHxuWzJdIT09cnx8byYmblszXSE9PW8pfHwobls0XSgpLCExKX0pfSl9LGRpc3BhdGNoOmZ1bmN0aW9uKG4sdCxpKXt2YXIgcjtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBDdXN0b21FdmVudD9yPW5ldyBDdXN0b21FdmVudCh0LHtidWJibGVzOiEwLGRldGFpbDppfSk6KHI9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKSkuaW5pdEN1c3RvbUV2ZW50KHQsITAsITEsaSksbi5kaXNwYXRjaEV2ZW50KHIpLHJ9LGRlc3Ryb3k6ZnVuY3Rpb24oKXtjLmZvckVhY2goZnVuY3Rpb24obil7bls0XSgpfSksRChjKX19fXZhciBCPVwibW91bnRlZFwiLEg9XCJtb3ZlXCIsRG49XCJtb3ZlZFwiLE1uPVwiY2xpY2tcIixQbj1cImFjdGl2ZVwiLEluPVwiaW5hY3RpdmVcIixSbj1cInZpc2libGVcIixDbj1cImhpZGRlblwiLEo9XCJyZWZyZXNoXCIsSz1cInVwZGF0ZWRcIixqbj1cInJlc2l6ZVwiLE5uPVwicmVzaXplZFwiLFRuPVwic2Nyb2xsXCIsVj1cInNjcm9sbGVkXCIsYT1cImRlc3Ryb3lcIixHbj1cIm5hdmlnYXRpb246bW91bnRlZFwiLEZuPVwiYXV0b3BsYXk6cGxheVwiLFhuPVwiYXV0b3BsYXk6cGF1c2VcIixXbj1cImxhenlsb2FkOmxvYWRlZFwiLFluPVwic2tcIixVbj1cInNoXCI7ZnVuY3Rpb24gUShuKXt2YXIgaT1uP24uZXZlbnQuYnVzOmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxyPXpuKCk7cmV0dXJuIG4mJm4uZXZlbnQub24oYSxyLmRlc3Ryb3kpLGFuKHIse2J1czppLG9uOmZ1bmN0aW9uKG4sdCl7ci5iaW5kKGkseShuKS5qb2luKFwiIFwiKSxmdW5jdGlvbihuKXt0LmFwcGx5KHQsZShuLmRldGFpbCk/bi5kZXRhaWw6W10pfSl9LG9mZjpSKHIudW5iaW5kLGkpLGVtaXQ6ZnVuY3Rpb24obil7ci5kaXNwYXRjaChpLG4sbyhhcmd1bWVudHMsMSkpfX0pfWZ1bmN0aW9uIHFuKHQsbixpLHIpe3ZhciBvLHUsZT1EYXRlLm5vdyxjPTAsZj0hMCxhPTA7ZnVuY3Rpb24gcygpe2lmKCFmKXtpZihjPXQ/WSgoZSgpLW8pL3QsMSk6MSxpJiZpKGMpLDE8PWMmJihuKCksbz1lKCksciYmKythPj1yKSlyZXR1cm4gbCgpO3U9aChzKX19ZnVuY3Rpb24gbCgpe2Y9ITB9ZnVuY3Rpb24gZCgpe3UmJmNhbmNlbEFuaW1hdGlvbkZyYW1lKHUpLGY9ISh1PWM9MCl9cmV0dXJue3N0YXJ0OmZ1bmN0aW9uKG4pe258fGQoKSxvPWUoKS0obj9jKnQ6MCksZj0hMSx1PWgocyl9LHJld2luZDpmdW5jdGlvbigpe289ZSgpLGM9MCxpJiZpKGMpfSxwYXVzZTpsLGNhbmNlbDpkLHNldDpmdW5jdGlvbihuKXt0PW59LGlzUGF1c2VkOmZ1bmN0aW9uKCl7cmV0dXJuIGZ9fX1mdW5jdGlvbiBzKG4pe3ZhciB0PW47cmV0dXJue3NldDpmdW5jdGlvbihuKXt0PW59LGlzOmZ1bmN0aW9uKG4pe3JldHVybiBiKHkobiksdCl9fX12YXIgbj1cIkFycm93XCIsQm49bitcIkxlZnRcIixIbj1uK1wiUmlnaHRcIix0PW4rXCJVcFwiLG49bitcIkRvd25cIixKbj1cInR0YlwiLGw9e3dpZHRoOltcImhlaWdodFwiXSxsZWZ0OltcInRvcFwiLFwicmlnaHRcIl0scmlnaHQ6W1wiYm90dG9tXCIsXCJsZWZ0XCJdLHg6W1wieVwiXSxYOltcIllcIl0sWTpbXCJYXCJdLEFycm93TGVmdDpbdCxIbl0sQXJyb3dSaWdodDpbbixCbl19O3ZhciBaPVwicm9sZVwiLCQ9XCJ0YWJpbmRleFwiLGk9XCJhcmlhLVwiLEtuPWkrXCJjb250cm9sc1wiLFZuPWkrXCJjdXJyZW50XCIsUW49aStcInNlbGVjdGVkXCIsbm49aStcImxhYmVsXCIsWm49aStcImxhYmVsbGVkYnlcIiwkbj1pK1wiaGlkZGVuXCIsbnQ9aStcIm9yaWVudGF0aW9uXCIsdHQ9aStcInJvbGVkZXNjcmlwdGlvblwiLGl0PWkrXCJsaXZlXCIscnQ9aStcImJ1c3lcIixvdD1pK1wiYXRvbWljXCIsdXQ9W1osJCxcImRpc2FibGVkXCIsS24sVm4sbm4sWm4sJG4sbnQsdHRdLGk9eW4rXCJfX1wiLGV0PXluLGN0PWkrXCJ0cmFja1wiLGZ0PWkrXCJsaXN0XCIsYXQ9aStcInNsaWRlXCIsc3Q9YXQrXCItLWNsb25lXCIsbHQ9YXQrXCJfX2NvbnRhaW5lclwiLGR0PWkrXCJhcnJvd3NcIix2dD1pK1wiYXJyb3dcIixodD12dCtcIi0tcHJldlwiLHB0PXZ0K1wiLS1uZXh0XCIsZ3Q9aStcInBhZ2luYXRpb25cIixtdD1ndCtcIl9fcGFnZVwiLHl0PWkrXCJwcm9ncmVzc1wiK1wiX19iYXJcIixidD1pK1widG9nZ2xlXCIsd3Q9aStcInNyXCIsdG49XCJpcy1hY3RpdmVcIix4dD1cImlzLXByZXZcIixrdD1cImlzLW5leHRcIixTdD1cImlzLXZpc2libGVcIixFdD1cImlzLWxvYWRpbmdcIixMdD1cImlzLWZvY3VzLWluXCIsT3Q9XCJpcy1vdmVyZmxvd1wiLEF0PVt0bixTdCx4dCxrdCxFdCxMdCxPdF07dmFyIF90PVwidG91Y2hzdGFydCBtb3VzZWRvd25cIix6dD1cInRvdWNobW92ZSBtb3VzZW1vdmVcIixEdD1cInRvdWNoZW5kIHRvdWNoY2FuY2VsIG1vdXNldXAgY2xpY2tcIjt2YXIgTXQ9XCJzbGlkZVwiLFB0PVwibG9vcFwiLEl0PVwiZmFkZVwiO2Z1bmN0aW9uIFJ0KG8scix0LHUpe3ZhciBlLG49UShvKSxpPW4ub24sYz1uLmVtaXQsZj1uLmJpbmQsYT1vLkNvbXBvbmVudHMscz1vLnJvb3QsbD1vLm9wdGlvbnMsZD1sLmlzTmF2aWdhdGlvbix2PWwudXBkYXRlT25Nb3ZlLGg9bC5pMThuLHA9bC5wYWdpbmF0aW9uLGc9bC5zbGlkZUZvY3VzLG09YS5EaXJlY3Rpb24ucmVzb2x2ZSx5PXoodSxcInN0eWxlXCIpLGI9eih1LG5uKSx3PS0xPHQseD1mbih1LFwiLlwiK2x0KTtmdW5jdGlvbiBrKCl7dmFyIG49by5zcGxpZGVzLm1hcChmdW5jdGlvbihuKXtuPW4uc3BsaWRlLkNvbXBvbmVudHMuU2xpZGVzLmdldEF0KHIpO3JldHVybiBuP24uc2xpZGUuaWQ6XCJcIn0pLmpvaW4oXCIgXCIpO0kodSxubixPbihoLnNsaWRlWCwodz90OnIpKzEpKSxJKHUsS24sbiksSSh1LFosZz9cImJ1dHRvblwiOlwiXCIpLGcmJlAodSx0dCl9ZnVuY3Rpb24gUygpe2V8fEUoKX1mdW5jdGlvbiBFKCl7dmFyIG4sdCxpO2V8fChuPW8uaW5kZXgsKGk9TCgpKSE9PXZuKHUsdG4pJiYoQSh1LHRuLGkpLEkodSxWbixkJiZpfHxcIlwiKSxjKGk/UG46SW4sTykpLGk9ZnVuY3Rpb24oKXtpZihvLmlzKEl0KSlyZXR1cm4gTCgpO3ZhciBuPU4oYS5FbGVtZW50cy50cmFjayksdD1OKHUpLGk9bShcImxlZnRcIiwhMCkscj1tKFwicmlnaHRcIiwhMCk7cmV0dXJuIHhuKG5baV0pPD1rbih0W2ldKSYmeG4odFtyXSk8PWtuKG5bcl0pfSgpLHQ9IWkmJighTCgpfHx3KSxvLnN0YXRlLmlzKFtHLHJuXSl8fEkodSwkbix0fHxcIlwiKSxJKGduKHUsbC5mb2N1c2FibGVOb2Rlc3x8XCJcIiksJCx0Py0xOlwiXCIpLGcmJkkodSwkLHQ/LTE6MCksaSE9PXZuKHUsU3QpJiYoQSh1LFN0LGkpLGMoaT9SbjpDbixPKSksaXx8ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCE9PXV8fCh0PWEuU2xpZGVzLmdldEF0KG8uaW5kZXgpKSYmZG4odC5zbGlkZSksQSh1LHh0LHI9PT1uLTEpLEEodSxrdCxyPT09bisxKSl9ZnVuY3Rpb24gTCgpe3ZhciBuPW8uaW5kZXg7cmV0dXJuIG49PT1yfHxsLmNsb25lU3RhdHVzJiZuPT09dH12YXIgTz17aW5kZXg6cixzbGlkZUluZGV4OnQsc2xpZGU6dSxjb250YWluZXI6eCxpc0Nsb25lOncsbW91bnQ6ZnVuY3Rpb24oKXt3fHwodS5pZD1zLmlkK1wiLXNsaWRlXCIrQW4ocisxKSxJKHUsWixwP1widGFicGFuZWxcIjpcImdyb3VwXCIpLEkodSx0dCxoLnNsaWRlKSxJKHUsbm4sYnx8T24oaC5zbGlkZUxhYmVsLFtyKzEsby5sZW5ndGhdKSkpLGYodSxcImNsaWNrXCIsUihjLE1uLE8pKSxmKHUsXCJrZXlkb3duXCIsUihjLFluLE8pKSxpKFtEbixVbixWXSxFKSxpKEduLGspLHYmJmkoSCxTKX0sZGVzdHJveTpmdW5jdGlvbigpe2U9ITAsbi5kZXN0cm95KCksWCh1LEF0KSxQKHUsdXQpLEkodSxcInN0eWxlXCIseSksSSh1LG5uLGJ8fFwiXCIpfSx1cGRhdGU6RSxzdHlsZTpmdW5jdGlvbihuLHQsaSl7XyhpJiZ4fHx1LG4sdCl9LGlzV2l0aGluOmZ1bmN0aW9uKG4sdCl7cmV0dXJuIG49VShuLXIpLChuPXd8fCFsLnJld2luZCYmIW8uaXMoUHQpP246WShuLG8ubGVuZ3RoLW4pKTw9dH19O3JldHVybiBPfXZhciBDdD1mK1wiLWludGVydmFsXCI7dmFyIGp0PXtwYXNzaXZlOiExLGNhcHR1cmU6ITB9O3ZhciBOdD17U3BhY2ViYXI6XCIgXCIsUmlnaHQ6SG4sTGVmdDpCbixVcDp0LERvd246bn07ZnVuY3Rpb24gVHQobil7cmV0dXJuIG49QyhuKT9uOm4ua2V5LE50W25dfHxufXZhciBHdD1cImtleWRvd25cIjt2YXIgRnQ9ZitcIi1sYXp5XCIsWHQ9RnQrXCItc3Jjc2V0XCIsV3Q9XCJbXCIrRnQrXCJdLCBbXCIrWHQrXCJdXCI7dmFyIFl0PVtcIiBcIixcIkVudGVyXCJdO3ZhciBVdD1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxNZWRpYTpmdW5jdGlvbihyLG4sbyl7dmFyIHU9ci5zdGF0ZSx0PW8uYnJlYWtwb2ludHN8fHt9LGU9by5yZWR1Y2VkTW90aW9ufHx7fSxpPXpuKCksYz1bXTtmdW5jdGlvbiBmKG4pe24mJmkuZGVzdHJveSgpfWZ1bmN0aW9uIGEobix0KXt0PW1hdGNoTWVkaWEodCk7aS5iaW5kKHQsXCJjaGFuZ2VcIixzKSxjLnB1c2goW24sdF0pfWZ1bmN0aW9uIHMoKXt2YXIgbj11LmlzKDcpLHQ9by5kaXJlY3Rpb24saT1jLnJlZHVjZShmdW5jdGlvbihuLHQpe3JldHVybiBkKG4sdFsxXS5tYXRjaGVzP3RbMF06e30pfSx7fSk7c24obyksbChpKSxvLmRlc3Ryb3k/ci5kZXN0cm95KFwiY29tcGxldGVseVwiPT09by5kZXN0cm95KTpuPyhmKCEwKSxyLm1vdW50KCkpOnQhPT1vLmRpcmVjdGlvbiYmci5yZWZyZXNoKCl9ZnVuY3Rpb24gbChuLHQsaSl7ZChvLG4pLHQmJmQoT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pLG4pLCFpJiZ1LmlzKDEpfHxyLmVtaXQoSyxvKX1yZXR1cm57c2V0dXA6ZnVuY3Rpb24oKXt2YXIgaT1cIm1pblwiPT09by5tZWRpYVF1ZXJ5O0UodCkuc29ydChmdW5jdGlvbihuLHQpe3JldHVybiBpPytuLSt0Oit0LStufSkuZm9yRWFjaChmdW5jdGlvbihuKXthKHRbbl0sXCIoXCIrKGk/XCJtaW5cIjpcIm1heFwiKStcIi13aWR0aDpcIituK1wicHgpXCIpfSksYShlLHYpLHMoKX0sZGVzdHJveTpmLHJlZHVjZTpmdW5jdGlvbihuKXttYXRjaE1lZGlhKHYpLm1hdGNoZXMmJihuP2QobyxlKTpzbihvLEUoZSkpKX0sc2V0Omx9fSxEaXJlY3Rpb246ZnVuY3Rpb24obix0LG8pe3JldHVybntyZXNvbHZlOmZ1bmN0aW9uKG4sdCxpKXt2YXIgcj1cInJ0bFwiIT09KGk9aXx8by5kaXJlY3Rpb24pfHx0P2k9PT1Kbj8wOi0xOjE7cmV0dXJuIGxbbl0mJmxbbl1bcl18fG4ucmVwbGFjZSgvd2lkdGh8bGVmdHxyaWdodC9pLGZ1bmN0aW9uKG4sdCl7bj1sW24udG9Mb3dlckNhc2UoKV1bcl18fG47cmV0dXJuIDA8dD9uLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSk6bn0pfSxvcmllbnQ6ZnVuY3Rpb24obil7cmV0dXJuIG4qKFwicnRsXCI9PT1vLmRpcmVjdGlvbj8xOi0xKX19fSxFbGVtZW50czpmdW5jdGlvbihuLHQsaSl7dmFyIHIsbyx1LGU9UShuKSxjPWUub24sZj1lLmJpbmQsYT1uLnJvb3Qscz1pLmkxOG4sbD17fSxkPVtdLHY9W10saD1bXTtmdW5jdGlvbiBwKCl7cj15KFwiLlwiK2N0KSxvPWZuKHIsXCIuXCIrZnQpLGJuKHImJm8sXCJBIHRyYWNrL2xpc3QgZWxlbWVudCBpcyBtaXNzaW5nLlwiKSxrKGQsUyhvLFwiLlwiK2F0K1wiOm5vdCguXCIrc3QrXCIpXCIpKSx3KHthcnJvd3M6ZHQscGFnaW5hdGlvbjpndCxwcmV2Omh0LG5leHQ6cHQsYmFyOnl0LHRvZ2dsZTpidH0sZnVuY3Rpb24obix0KXtsW3RdPXkoXCIuXCIrbil9KSxhbihsLHtyb290OmEsdHJhY2s6cixsaXN0Om8sc2xpZGVzOmR9KTt2YXIgbj1hLmlkfHxmdW5jdGlvbihuKXtyZXR1cm5cIlwiK24rQW4oX25bbl09KF9uW25dfHwwKSsxKX0oeW4pLHQ9aS5yb2xlO2EuaWQ9bixyLmlkPXIuaWR8fG4rXCItdHJhY2tcIixvLmlkPW8uaWR8fG4rXCItbGlzdFwiLCF6KGEsWikmJlwiU0VDVElPTlwiIT09YS50YWdOYW1lJiZ0JiZJKGEsWix0KSxJKGEsdHQscy5jYXJvdXNlbCksSShvLFosXCJwcmVzZW50YXRpb25cIiksbSgpfWZ1bmN0aW9uIGcobil7dmFyIHQ9dXQuY29uY2F0KFwic3R5bGVcIik7RChkKSxYKGEsdiksWChyLGgpLFAoW3Isb10sdCksUChhLG4/dDpbXCJzdHlsZVwiLHR0XSl9ZnVuY3Rpb24gbSgpe1goYSx2KSxYKHIsaCksdj1iKGV0KSxoPWIoY3QpLE0oYSx2KSxNKHIsaCksSShhLG5uLGkubGFiZWwpLEkoYSxabixpLmxhYmVsbGVkYnkpfWZ1bmN0aW9uIHkobil7bj1wbihhLG4pO3JldHVybiBuJiZmdW5jdGlvbihuLHQpe2lmKHgobi5jbG9zZXN0KSlyZXR1cm4gbi5jbG9zZXN0KHQpO2Zvcih2YXIgaT1uO2kmJjE9PT1pLm5vZGVUeXBlJiYhY24oaSx0KTspaT1pLnBhcmVudEVsZW1lbnQ7cmV0dXJuIGl9KG4sXCIuXCIrZXQpPT09YT9uOnZvaWQgMH1mdW5jdGlvbiBiKG4pe3JldHVybltuK1wiLS1cIitpLnR5cGUsbitcIi0tXCIraS5kaXJlY3Rpb24saS5kcmFnJiZuK1wiLS1kcmFnZ2FibGVcIixpLmlzTmF2aWdhdGlvbiYmbitcIi0tbmF2XCIsbj09PWV0JiZ0bl19cmV0dXJuIGFuKGwse3NldHVwOnAsbW91bnQ6ZnVuY3Rpb24oKXtjKEosZyksYyhKLHApLGMoSyxtKSxmKGRvY3VtZW50LF90K1wiIGtleWRvd25cIixmdW5jdGlvbihuKXt1PVwia2V5ZG93blwiPT09bi50eXBlfSx7Y2FwdHVyZTohMH0pLGYoYSxcImZvY3VzaW5cIixmdW5jdGlvbigpe0EoYSxMdCwhIXUpfSl9LGRlc3Ryb3k6Z30pfSxTbGlkZXM6ZnVuY3Rpb24ocixvLHUpe3ZhciBuPVEociksdD1uLm9uLGU9bi5lbWl0LGM9bi5iaW5kLGY9KG49by5FbGVtZW50cykuc2xpZGVzLGE9bi5saXN0LHM9W107ZnVuY3Rpb24gaSgpe2YuZm9yRWFjaChmdW5jdGlvbihuLHQpe2Qobix0LC0xKX0pfWZ1bmN0aW9uIGwoKXtoKGZ1bmN0aW9uKG4pe24uZGVzdHJveSgpfSksRChzKX1mdW5jdGlvbiBkKG4sdCxpKXt0PVJ0KHIsdCxpLG4pO3QubW91bnQoKSxzLnB1c2godCkscy5zb3J0KGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4uaW5kZXgtdC5pbmRleH0pfWZ1bmN0aW9uIHYobil7cmV0dXJuIG4/cChmdW5jdGlvbihuKXtyZXR1cm4hbi5pc0Nsb25lfSk6c31mdW5jdGlvbiBoKG4sdCl7dih0KS5mb3JFYWNoKG4pfWZ1bmN0aW9uIHAodCl7cmV0dXJuIHMuZmlsdGVyKHgodCk/dDpmdW5jdGlvbihuKXtyZXR1cm4gQyh0KT9jbihuLnNsaWRlLHQpOmIoeSh0KSxuLmluZGV4KX0pfXJldHVybnttb3VudDpmdW5jdGlvbigpe2koKSx0KEosbCksdChKLGkpfSxkZXN0cm95OmwsdXBkYXRlOmZ1bmN0aW9uKCl7aChmdW5jdGlvbihuKXtuLnVwZGF0ZSgpfSl9LHJlZ2lzdGVyOmQsZ2V0OnYsZ2V0SW46ZnVuY3Rpb24obil7dmFyIHQ9by5Db250cm9sbGVyLGk9dC50b0luZGV4KG4pLHI9dC5oYXNGb2N1cygpPzE6dS5wZXJQYWdlO3JldHVybiBwKGZ1bmN0aW9uKG4pe3JldHVybiBFbihuLmluZGV4LGksaStyLTEpfSl9LGdldEF0OmZ1bmN0aW9uKG4pe3JldHVybiBwKG4pWzBdfSxhZGQ6ZnVuY3Rpb24obixvKXtnKG4sZnVuY3Rpb24obil7dmFyIHQsaSxyO20obj1DKG4pP2huKG4pOm4pJiYoKHQ9ZltvXSk/TyhuLHQpOkwoYSxuKSxNKG4sdS5jbGFzc2VzLnNsaWRlKSx0PW4saT1SKGUsam4pLHQ9Z24odCxcImltZ1wiKSwocj10Lmxlbmd0aCk/dC5mb3JFYWNoKGZ1bmN0aW9uKG4pe2MobixcImxvYWQgZXJyb3JcIixmdW5jdGlvbigpey0tcnx8aSgpfSl9KTppKCkpfSksZShKKX0scmVtb3ZlOmZ1bmN0aW9uKG4pe1QocChuKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4uc2xpZGV9KSksZShKKX0sZm9yRWFjaDpoLGZpbHRlcjpwLHN0eWxlOmZ1bmN0aW9uKHQsaSxyKXtoKGZ1bmN0aW9uKG4pe24uc3R5bGUodCxpLHIpfSl9LGdldExlbmd0aDpmdW5jdGlvbihuKXtyZXR1cm4obj9mOnMpLmxlbmd0aH0saXNFbm91Z2g6ZnVuY3Rpb24oKXtyZXR1cm4gcy5sZW5ndGg+dS5wZXJQYWdlfX19LExheW91dDpmdW5jdGlvbih0LG4saSl7dmFyIHIsbyx1LGU9KGE9USh0KSkub24sYz1hLmJpbmQsZj1hLmVtaXQsYT1uLlNsaWRlcyxzPW4uRGlyZWN0aW9uLnJlc29sdmUsbD0obj1uLkVsZW1lbnRzKS5yb290LGQ9bi50cmFjayx2PW4ubGlzdCxoPWEuZ2V0QXQscD1hLnN0eWxlO2Z1bmN0aW9uIGcoKXtyPWkuZGlyZWN0aW9uPT09Sm4sXyhsLFwibWF4V2lkdGhcIixXKGkud2lkdGgpKSxfKGQscyhcInBhZGRpbmdMZWZ0XCIpLHkoITEpKSxfKGQscyhcInBhZGRpbmdSaWdodFwiKSx5KCEwKSksbSghMCl9ZnVuY3Rpb24gbShuKXt2YXIgdD1OKGwpOyFuJiZvLndpZHRoPT09dC53aWR0aCYmby5oZWlnaHQ9PT10LmhlaWdodHx8KF8oZCxcImhlaWdodFwiLGZ1bmN0aW9uKCl7dmFyIG49XCJcIjtyJiYoYm4obj1iKCksXCJoZWlnaHQgb3IgaGVpZ2h0UmF0aW8gaXMgbWlzc2luZy5cIiksbj1cImNhbGMoXCIrbitcIiAtIFwiK3koITEpK1wiIC0gXCIreSghMCkrXCIpXCIpO3JldHVybiBufSgpKSxwKHMoXCJtYXJnaW5SaWdodFwiKSxXKGkuZ2FwKSkscChcIndpZHRoXCIsaS5hdXRvV2lkdGg/bnVsbDpXKGkuZml4ZWRXaWR0aCl8fChyP1wiXCI6dygpKSkscChcImhlaWdodFwiLFcoaS5maXhlZEhlaWdodCl8fChyP2kuYXV0b0hlaWdodD9udWxsOncoKTpiKCkpLCEwKSxvPXQsZihObiksdSE9PSh1PU8oKSkmJihBKGwsT3QsdSksZihcIm92ZXJmbG93XCIsdSkpKX1mdW5jdGlvbiB5KG4pe3ZhciB0PWkucGFkZGluZyxuPXMobj9cInJpZ2h0XCI6XCJsZWZ0XCIpO3JldHVybiB0JiZXKHRbbl18fCh1bih0KT8wOnQpKXx8XCIwcHhcIn1mdW5jdGlvbiBiKCl7cmV0dXJuIFcoaS5oZWlnaHR8fE4odikud2lkdGgqaS5oZWlnaHRSYXRpbyl9ZnVuY3Rpb24gdygpe3ZhciBuPVcoaS5nYXApO3JldHVyblwiY2FsYygoMTAwJVwiKyhuJiZcIiArIFwiK24pK1wiKS9cIisoaS5wZXJQYWdlfHwxKSsobiYmXCIgLSBcIituKStcIilcIn1mdW5jdGlvbiB4KCl7cmV0dXJuIE4odilbcyhcIndpZHRoXCIpXX1mdW5jdGlvbiBrKG4sdCl7bj1oKG58fDApO3JldHVybiBuP04obi5zbGlkZSlbcyhcIndpZHRoXCIpXSsodD8wOkwoKSk6MH1mdW5jdGlvbiBTKG4sdCl7dmFyIGksbj1oKG4pO3JldHVybiBuPyhuPU4obi5zbGlkZSlbcyhcInJpZ2h0XCIpXSxpPU4odilbcyhcImxlZnRcIildLFUobi1pKSsodD8wOkwoKSkpOjB9ZnVuY3Rpb24gRShuKXtyZXR1cm4gUyh0Lmxlbmd0aC0xKS1TKDApK2soMCxuKX1mdW5jdGlvbiBMKCl7dmFyIG49aCgwKTtyZXR1cm4gbiYmcGFyc2VGbG9hdChfKG4uc2xpZGUscyhcIm1hcmdpblJpZ2h0XCIpKSl8fDB9ZnVuY3Rpb24gTygpe3JldHVybiB0LmlzKEl0KXx8RSghMCk+eCgpfXJldHVybnttb3VudDpmdW5jdGlvbigpe3ZhciBuLHQsaTtnKCksYyh3aW5kb3csXCJyZXNpemUgbG9hZFwiLChuPVIoZixqbiksaT1xbih0fHwwLG4sbnVsbCwxKSxmdW5jdGlvbigpe2kuaXNQYXVzZWQoKSYmaS5zdGFydCgpfSkpLGUoW0ssSl0sZyksZShqbixtKX0scmVzaXplOm0sbGlzdFNpemU6eCxzbGlkZVNpemU6ayxzbGlkZXJTaXplOkUsdG90YWxTaXplOlMsZ2V0UGFkZGluZzpmdW5jdGlvbihuKXtyZXR1cm4gcGFyc2VGbG9hdChfKGQscyhcInBhZGRpbmdcIisobj9cIlJpZ2h0XCI6XCJMZWZ0XCIpKSkpfHwwfSxpc092ZXJmbG93Ok99fSxDbG9uZXM6ZnVuY3Rpb24oYyxpLGYpe3ZhciB0LHI9UShjKSxuPXIub24sYT1pLkVsZW1lbnRzLHM9aS5TbGlkZXMsbz1pLkRpcmVjdGlvbi5yZXNvbHZlLGw9W107ZnVuY3Rpb24gdSgpe2lmKG4oSixkKSxuKFtLLGpuXSx2KSx0PWgoKSl7dmFyIG89dCx1PXMuZ2V0KCkuc2xpY2UoKSxlPXUubGVuZ3RoO2lmKGUpe2Zvcig7dS5sZW5ndGg8bzspayh1LHUpO2sodS5zbGljZSgtbyksdS5zbGljZSgwLG8pKS5mb3JFYWNoKGZ1bmN0aW9uKG4sdCl7dmFyIGk9dDxvLHI9ZnVuY3Rpb24obix0KXtuPW4uY2xvbmVOb2RlKCEwKTtyZXR1cm4gTShuLGYuY2xhc3Nlcy5jbG9uZSksbi5pZD1jLnJvb3QuaWQrXCItY2xvbmVcIitBbih0KzEpLG59KG4uc2xpZGUsdCk7aT9PKHIsdVswXS5zbGlkZSk6TChhLmxpc3QsciksayhsLHIpLHMucmVnaXN0ZXIocix0LW8rKGk/MDplKSxuLmluZGV4KX0pfWkuTGF5b3V0LnJlc2l6ZSghMCl9fWZ1bmN0aW9uIGQoKXtlKCksdSgpfWZ1bmN0aW9uIGUoKXtUKGwpLEQobCksci5kZXN0cm95KCl9ZnVuY3Rpb24gdigpe3ZhciBuPWgoKTt0IT09biYmKHQ8bnx8IW4pJiZyLmVtaXQoSil9ZnVuY3Rpb24gaCgpe3ZhciBuLHQ9Zi5jbG9uZXM7cmV0dXJuIGMuaXMoUHQpP2VuKHQpJiYodD0obj1mW28oXCJmaXhlZFdpZHRoXCIpXSYmaS5MYXlvdXQuc2xpZGVTaXplKDApKSYma24oTihhLnRyYWNrKVtvKFwid2lkdGhcIildL24pfHxmW28oXCJhdXRvV2lkdGhcIildJiZjLmxlbmd0aHx8MipmLnBlclBhZ2UpOnQ9MCx0fXJldHVybnttb3VudDp1LGRlc3Ryb3k6ZX19LE1vdmU6ZnVuY3Rpb24ocixjLG8pe3ZhciBlLG49UShyKSx0PW4ub24sZj1uLmVtaXQsYT1yLnN0YXRlLnNldCx1PShuPWMuTGF5b3V0KS5zbGlkZVNpemUsaT1uLmdldFBhZGRpbmcscz1uLnRvdGFsU2l6ZSxsPW4ubGlzdFNpemUsZD1uLnNsaWRlclNpemUsdj0obj1jLkRpcmVjdGlvbikucmVzb2x2ZSxoPW4ub3JpZW50LHA9KG49Yy5FbGVtZW50cykubGlzdCxnPW4udHJhY2s7ZnVuY3Rpb24gbSgpe2MuQ29udHJvbGxlci5pc0J1c3koKXx8KGMuU2Nyb2xsLmNhbmNlbCgpLHkoci5pbmRleCksYy5TbGlkZXMudXBkYXRlKCkpfWZ1bmN0aW9uIHkobil7YihTKG4sITApKX1mdW5jdGlvbiBiKG4sdCl7ci5pcyhJdCl8fCh0PXQ/bjpmdW5jdGlvbihuKXt7dmFyIHQsaTtyLmlzKFB0KSYmKHQ9ayhuKSxpPXQ+Yy5Db250cm9sbGVyLmdldEVuZCgpLCh0PDB8fGkpJiYobj13KG4saSkpKX1yZXR1cm4gbn0obiksXyhwLFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVcIit2KFwiWFwiKStcIihcIit0K1wicHgpXCIpLG4hPT10JiZmKFVuKSl9ZnVuY3Rpb24gdyhuLHQpe3ZhciBpPW4tTCh0KSxyPWQoKTtyZXR1cm4gbi09aChyKihrbihVKGkpL3IpfHwxKSkqKHQ/MTotMSl9ZnVuY3Rpb24geCgpe2IoRSgpLCEwKSxlLmNhbmNlbCgpfWZ1bmN0aW9uIGsobil7Zm9yKHZhciB0PWMuU2xpZGVzLmdldCgpLGk9MCxyPTEvMCxvPTA7bzx0Lmxlbmd0aDtvKyspe3ZhciB1PXRbb10uaW5kZXgsZT1VKFModSwhMCktbik7aWYoIShlPD1yKSlicmVhaztyPWUsaT11fXJldHVybiBpfWZ1bmN0aW9uIFMobix0KXt2YXIgaT1oKHMobi0xKS0obj1uLFwiY2VudGVyXCI9PT0oaT1vLmZvY3VzKT8obCgpLXUobiwhMCkpLzI6K2kqdShuKXx8MCkpO3JldHVybiB0PyhuPWksbj1vLnRyaW1TcGFjZSYmci5pcyhNdCk/cShuLDAsaChkKCEwKS1sKCkpKTpuKTppfWZ1bmN0aW9uIEUoKXt2YXIgbj12KFwibGVmdFwiKTtyZXR1cm4gTihwKVtuXS1OKGcpW25dK2goaSghMSkpfWZ1bmN0aW9uIEwobil7cmV0dXJuIFMobj9jLkNvbnRyb2xsZXIuZ2V0RW5kKCk6MCwhIW8udHJpbVNwYWNlKX1yZXR1cm57bW91bnQ6ZnVuY3Rpb24oKXtlPWMuVHJhbnNpdGlvbix0KFtCLE5uLEssSl0sbSl9LG1vdmU6ZnVuY3Rpb24obix0LGkscil7dmFyIG8sdTtuIT09dCYmKG89aTxuLHU9aCh3KEUoKSxvKSksbz8wPD11OnU8PXBbdihcInNjcm9sbFdpZHRoXCIpXS1OKGcpW3YoXCJ3aWR0aFwiKV0pJiYoeCgpLGIodyhFKCksaTxuKSwhMCkpLGEoRyksZihILHQsaSxuKSxlLnN0YXJ0KHQsZnVuY3Rpb24oKXthKDMpLGYoRG4sdCxpLG4pLHImJnIoKX0pfSxqdW1wOnksdHJhbnNsYXRlOmIsc2hpZnQ6dyxjYW5jZWw6eCx0b0luZGV4OmssdG9Qb3NpdGlvbjpTLGdldFBvc2l0aW9uOkUsZ2V0TGltaXQ6TCxleGNlZWRlZExpbWl0OmZ1bmN0aW9uKG4sdCl7dD1lbih0KT9FKCk6dDt2YXIgaT0hMCE9PW4mJmgodCk8aChMKCExKSksbj0hMSE9PW4mJmgodCk+aChMKCEwKSk7cmV0dXJuIGl8fG59LHJlcG9zaXRpb246bX19LENvbnRyb2xsZXI6ZnVuY3Rpb24obyx1LGUpe3ZhciBjLGYsYSxzLG49UShvKSx0PW4ub24saT1uLmVtaXQsbD11Lk1vdmUsZD1sLmdldFBvc2l0aW9uLHI9bC5nZXRMaW1pdCx2PWwudG9Qb3NpdGlvbixoPShuPXUuU2xpZGVzKS5pc0Vub3VnaCxwPW4uZ2V0TGVuZ3RoLGc9ZS5vbWl0RW5kLG09by5pcyhQdCkseT1vLmlzKE10KSxiPVIoTCwhMSksdz1SKEwsITApLHg9ZS5zdGFydHx8MCxrPXg7ZnVuY3Rpb24gUygpe2Y9cCghMCksYT1lLnBlck1vdmUscz1lLnBlclBhZ2UsYz1fKCk7dmFyIG49cSh4LDAsZz9jOmYtMSk7biE9PXgmJih4PW4sbC5yZXBvc2l0aW9uKCkpfWZ1bmN0aW9uIEUoKXtjIT09XygpJiZpKFwiZWlcIil9ZnVuY3Rpb24gTChuLHQpe3ZhciBpPWF8fChQKCk/MTpzKSxpPU8oeCtpKihuPy0xOjEpLHgsIShhfHxQKCkpKTtyZXR1cm4tMT09PWkmJnkmJiFTbihkKCkscighbiksMSk/bj8wOmM6dD9pOkEoaSl9ZnVuY3Rpb24gTyhuLHQsaSl7dmFyIHI7cmV0dXJuIGgoKXx8UCgpPygocj1mdW5jdGlvbihuKXtpZih5JiZcIm1vdmVcIj09PWUudHJpbVNwYWNlJiZuIT09eClmb3IodmFyIHQ9ZCgpO3Q9PT12KG4sITApJiZFbihuLDAsby5sZW5ndGgtMSwhZS5yZXdpbmQpOyluPHg/LS1uOisrbjtyZXR1cm4gbn0obikpIT09biYmKHQ9bixuPXIsaT0hMSksbjwwfHxjPG4/bj1hfHwhRW4oMCxuLHQsITApJiYhRW4oYyx0LG4sITApP20/aT9uPDA/LShmJXN8fHMpOmY6bjplLnJld2luZD9uPDA/YzowOi0xOnooRChuKSk6aSYmbiE9PXQmJihuPXooRCh0KSsobjx0Py0xOjEpKSkpOm49LTEsbn1mdW5jdGlvbiBBKG4pe3JldHVybiBtPyhuK2YpJWZ8fDA6bn1mdW5jdGlvbiBfKCl7Zm9yKHZhciBuPWYtKFAoKXx8bSYmYT8xOnMpO2cmJjA8bi0tOylpZih2KGYtMSwhMCkhPT12KG4sITApKXtuKys7YnJlYWt9cmV0dXJuIHEobiwwLGYtMSl9ZnVuY3Rpb24geihuKXtyZXR1cm4gcShQKCk/bjpzKm4sMCxjKX1mdW5jdGlvbiBEKG4pe3JldHVybiBQKCk/WShuLGMpOnhuKChjPD1uP2YtMTpuKS9zKX1mdW5jdGlvbiBNKG4pe24hPT14JiYoaz14LHg9bil9ZnVuY3Rpb24gUCgpe3JldHVybiFlbihlLmZvY3VzKXx8ZS5pc05hdmlnYXRpb259ZnVuY3Rpb24gSSgpe3JldHVybiBvLnN0YXRlLmlzKFtHLHJuXSkmJiEhZS53YWl0Rm9yVHJhbnNpdGlvbn1yZXR1cm57bW91bnQ6ZnVuY3Rpb24oKXtTKCksdChbSyxKLFwiZWlcIl0sUyksdChObixFKX0sZ286ZnVuY3Rpb24obix0LGkpe3ZhciByO0koKXx8LTE8KHI9QShuPWZ1bmN0aW9uKG4pe3ZhciB0PXg7e3ZhciBpLHI7QyhuKT8ocj1uLm1hdGNoKC8oWytcXC08Pl0pKFxcZCspPy8pfHxbXSxpPXJbMV0scj1yWzJdLFwiK1wiPT09aXx8XCItXCI9PT1pP3Q9Tyh4KyArKFwiXCIraSsoK3J8fDEpKSx4KTpcIj5cIj09PWk/dD1yP3ooK3IpOmIoITApOlwiPFwiPT09aSYmKHQ9dyghMCkpKTp0PW0/bjpxKG4sMCxjKX1yZXR1cm4gdH0obikpKSYmKHR8fHIhPT14KSYmKE0ociksbC5tb3ZlKG4scixrLGkpKX0sc2Nyb2xsOmZ1bmN0aW9uKG4sdCxpLHIpe3UuU2Nyb2xsLnNjcm9sbChuLHQsaSxmdW5jdGlvbigpe3ZhciBuPUEobC50b0luZGV4KGQoKSkpO00oZz9ZKG4sYyk6biksciYmcigpfSl9LGdldE5leHQ6YixnZXRQcmV2OncsZ2V0QWRqYWNlbnQ6TCxnZXRFbmQ6XyxzZXRJbmRleDpNLGdldEluZGV4OmZ1bmN0aW9uKG4pe3JldHVybiBuP2s6eH0sdG9JbmRleDp6LHRvUGFnZTpELHRvRGVzdDpmdW5jdGlvbihuKXtyZXR1cm4gbj1sLnRvSW5kZXgobikseT9xKG4sMCxjKTpufSxoYXNGb2N1czpQLGlzQnVzeTpJfX0sQXJyb3dzOmZ1bmN0aW9uKG8sbix0KXt2YXIgaSxyLHU9UShvKSxlPXUub24sYz11LmJpbmQsZj11LmVtaXQsYT10LmNsYXNzZXMscz10LmkxOG4sbD1uLkVsZW1lbnRzLGQ9bi5Db250cm9sbGVyLHY9bC5hcnJvd3MsaD1sLnRyYWNrLHA9dixnPWwucHJldixtPWwubmV4dCx5PXt9O2Z1bmN0aW9uIGIoKXt2YXIgbj10LmFycm93czshbnx8ZyYmbXx8KHA9dnx8aihcImRpdlwiLGEuYXJyb3dzKSxnPVMoITApLG09UyghMSksaT0hMCxMKHAsW2csbV0pLHZ8fE8ocCxoKSksZyYmbSYmKGFuKHkse3ByZXY6ZyxuZXh0Om19KSxsbihwLG4/XCJcIjpcIm5vbmVcIiksTShwLHI9ZHQrXCItLVwiK3QuZGlyZWN0aW9uKSxuJiYoZShbQixEbixKLFYsXCJlaVwiXSxFKSxjKG0sXCJjbGlja1wiLFIoayxcIj5cIikpLGMoZyxcImNsaWNrXCIsUihrLFwiPFwiKSksRSgpLEkoW2csbV0sS24saC5pZCksZihcImFycm93czptb3VudGVkXCIsZyxtKSkpLGUoSyx3KX1mdW5jdGlvbiB3KCl7eCgpLGIoKX1mdW5jdGlvbiB4KCl7dS5kZXN0cm95KCksWChwLHIpLGk/KFQodj9bZyxtXTpwKSxnPW09bnVsbCk6UChbZyxtXSx1dCl9ZnVuY3Rpb24gayhuKXtkLmdvKG4sITApfWZ1bmN0aW9uIFMobil7cmV0dXJuIGhuKCc8YnV0dG9uIGNsYXNzPVwiJythLmFycm93K1wiIFwiKyhuP2EucHJldjphLm5leHQpKydcIiB0eXBlPVwiYnV0dG9uXCI+PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCA0MCA0MFwiIHdpZHRoPVwiNDBcIiBoZWlnaHQ9XCI0MFwiIGZvY3VzYWJsZT1cImZhbHNlXCI+PHBhdGggZD1cIicrKHQuYXJyb3dQYXRofHxcIm0xNS41IDAuOTMyLTQuMyA0LjM4IDE0LjUgMTQuNi0xNC41IDE0LjUgNC4zIDQuNCAxNC42LTE0LjYgNC40LTQuMy00LjQtNC40LTE0LjYtMTQuNnpcIikrJ1wiIC8+Jyl9ZnVuY3Rpb24gRSgpe3ZhciBuLHQsaSxyO2cmJm0mJihyPW8uaW5kZXgsbj1kLmdldFByZXYoKSx0PWQuZ2V0TmV4dCgpLGk9LTE8biYmcjxuP3MubGFzdDpzLnByZXYscj0tMTx0JiZ0PHI/cy5maXJzdDpzLm5leHQsZy5kaXNhYmxlZD1uPDAsbS5kaXNhYmxlZD10PDAsSShnLG5uLGkpLEkobSxubixyKSxmKFwiYXJyb3dzOnVwZGF0ZWRcIixnLG0sbix0KSl9cmV0dXJue2Fycm93czp5LG1vdW50OmIsZGVzdHJveTp4LHVwZGF0ZTpFfX0sQXV0b3BsYXk6ZnVuY3Rpb24obix0LGkpe3ZhciByLG8sdT1RKG4pLGU9dS5vbixjPXUuYmluZCxmPXUuZW1pdCxhPXFuKGkuaW50ZXJ2YWwsbi5nby5iaW5kKG4sXCI+XCIpLGZ1bmN0aW9uKG4pe3ZhciB0PWwuYmFyO3QmJl8odCxcIndpZHRoXCIsMTAwKm4rXCIlXCIpLGYoXCJhdXRvcGxheTpwbGF5aW5nXCIsbil9KSxzPWEuaXNQYXVzZWQsbD10LkVsZW1lbnRzLGQ9KHU9dC5FbGVtZW50cykucm9vdCx2PXUudG9nZ2xlLGg9aS5hdXRvcGxheSxwPVwicGF1c2VcIj09PWg7ZnVuY3Rpb24gZygpe3MoKSYmdC5TbGlkZXMuaXNFbm91Z2goKSYmKGEuc3RhcnQoIWkucmVzZXRQcm9ncmVzcyksbz1yPXA9ITEsYigpLGYoRm4pKX1mdW5jdGlvbiBtKG4pe3A9ISEobj12b2lkIDA9PT1uPyEwOm4pLGIoKSxzKCl8fChhLnBhdXNlKCksZihYbikpfWZ1bmN0aW9uIHkoKXtwfHwocnx8bz9tKCExKTpnKCkpfWZ1bmN0aW9uIGIoKXt2JiYoQSh2LHRuLCFwKSxJKHYsbm4saS5pMThuW3A/XCJwbGF5XCI6XCJwYXVzZVwiXSkpfWZ1bmN0aW9uIHcobil7bj10LlNsaWRlcy5nZXRBdChuKTthLnNldChuJiYreihuLnNsaWRlLEN0KXx8aS5pbnRlcnZhbCl9cmV0dXJue21vdW50OmZ1bmN0aW9uKCl7aCYmKGkucGF1c2VPbkhvdmVyJiZjKGQsXCJtb3VzZWVudGVyIG1vdXNlbGVhdmVcIixmdW5jdGlvbihuKXtyPVwibW91c2VlbnRlclwiPT09bi50eXBlLHkoKX0pLGkucGF1c2VPbkZvY3VzJiZjKGQsXCJmb2N1c2luIGZvY3Vzb3V0XCIsZnVuY3Rpb24obil7bz1cImZvY3VzaW5cIj09PW4udHlwZSx5KCl9KSx2JiZjKHYsXCJjbGlja1wiLGZ1bmN0aW9uKCl7cD9nKCk6bSghMCl9KSxlKFtILFRuLEpdLGEucmV3aW5kKSxlKEgsdyksdiYmSSh2LEtuLGwudHJhY2suaWQpLHB8fGcoKSxiKCkpfSxkZXN0cm95OmEuY2FuY2VsLHBsYXk6ZyxwYXVzZTptLGlzUGF1c2VkOnN9fSxDb3ZlcjpmdW5jdGlvbihuLHQsaSl7dmFyIHI9UShuKS5vbjtmdW5jdGlvbiBvKGkpe3QuU2xpZGVzLmZvckVhY2goZnVuY3Rpb24obil7dmFyIHQ9Zm4obi5jb250YWluZXJ8fG4uc2xpZGUsXCJpbWdcIik7dCYmdC5zcmMmJnUoaSx0LG4pfSl9ZnVuY3Rpb24gdShuLHQsaSl7aS5zdHlsZShcImJhY2tncm91bmRcIixuPydjZW50ZXIvY292ZXIgbm8tcmVwZWF0IHVybChcIicrdC5zcmMrJ1wiKSc6XCJcIiwhMCksbG4odCxuP1wibm9uZVwiOlwiXCIpfXJldHVybnttb3VudDpmdW5jdGlvbigpe2kuY292ZXImJihyKFduLFIodSwhMCkpLHIoW0IsSyxKXSxSKG8sITApKSl9LGRlc3Ryb3k6UihvLCExKX19LFNjcm9sbDpmdW5jdGlvbihuLGMsdSl7dmFyIGYsYSx0PVEobiksaT10Lm9uLHM9dC5lbWl0LGw9bi5zdGF0ZS5zZXQsZD1jLk1vdmUsdj1kLmdldFBvc2l0aW9uLGU9ZC5nZXRMaW1pdCxoPWQuZXhjZWVkZWRMaW1pdCxwPWQudHJhbnNsYXRlLGc9bi5pcyhNdCksbT0xO2Z1bmN0aW9uIHkobix0LGkscixvKXt2YXIgdSxlPXYoKSxpPSh4KCksIWl8fGcmJmgoKXx8KGk9Yy5MYXlvdXQuc2xpZGVyU2l6ZSgpLHU9TG4obikqaSp4bihVKG4pL2kpfHwwLG49ZC50b1Bvc2l0aW9uKGMuQ29udHJvbGxlci50b0Rlc3QobiVpKSkrdSksU24oZSxuLDEpKTttPTEsdD1pPzA6dHx8d24oVShuLWUpLzEuNSw4MDApLGE9cixmPXFuKHQsYixSKHcsZSxuLG8pLDEpLGwocm4pLHMoVG4pLGYuc3RhcnQoKX1mdW5jdGlvbiBiKCl7bCgzKSxhJiZhKCkscyhWKX1mdW5jdGlvbiB3KG4sdCxpLHIpe3ZhciBvPXYoKSxyPShuKyh0LW4pKih0PXIsKG49dS5lYXNpbmdGdW5jKT9uKHQpOjEtTWF0aC5wb3coMS10LDQpKS1vKSptO3AobytyKSxnJiYhaSYmaCgpJiYobSo9LjYsVShyKTwxMCYmeShlKGgoITApKSw2MDAsITEsYSwhMCkpfWZ1bmN0aW9uIHgoKXtmJiZmLmNhbmNlbCgpfWZ1bmN0aW9uIHIoKXtmJiYhZi5pc1BhdXNlZCgpJiYoeCgpLGIoKSl9cmV0dXJue21vdW50OmZ1bmN0aW9uKCl7aShILHgpLGkoW0ssSl0scil9LGRlc3Ryb3k6eCxzY3JvbGw6eSxjYW5jZWw6cn19LERyYWc6ZnVuY3Rpb24oZSxvLGMpe3ZhciBmLHQsdSxhLHMsbCxkLHYsbj1RKGUpLGk9bi5vbixoPW4uZW1pdCxwPW4uYmluZCxnPW4udW5iaW5kLG09ZS5zdGF0ZSx5PW8uTW92ZSxiPW8uU2Nyb2xsLHc9by5Db250cm9sbGVyLHg9by5FbGVtZW50cy50cmFjayxrPW8uTWVkaWEucmVkdWNlLHI9KG49by5EaXJlY3Rpb24pLnJlc29sdmUsUz1uLm9yaWVudCxFPXkuZ2V0UG9zaXRpb24sTD15LmV4Y2VlZGVkTGltaXQsTz0hMTtmdW5jdGlvbiBqKCl7dmFyIG49Yy5kcmFnO0MoIW4pLGE9XCJmcmVlXCI9PT1ufWZ1bmN0aW9uIE4obil7dmFyIHQsaSxyO2w9ITEsZHx8KHQ9UihuKSxpPW4udGFyZ2V0LHI9Yy5ub0RyYWcsY24oaSxcIi5cIittdCtcIiwgLlwiK3Z0KXx8ciYmY24oaSxyKXx8IXQmJm4uYnV0dG9ufHwody5pc0J1c3koKT9GKG4sITApOih2PXQ/eDp3aW5kb3cscz1tLmlzKFtHLHJuXSksdT1udWxsLHAodix6dCxBLGp0KSxwKHYsRHQsXyxqdCkseS5jYW5jZWwoKSxiLmNhbmNlbCgpLHoobikpKSl9ZnVuY3Rpb24gQShuKXt2YXIgdCxpLHIsbyx1O20uaXMoNil8fChtLnNldCg2KSxoKFwiZHJhZ1wiKSksbi5jYW5jZWxhYmxlJiYocz8oeS50cmFuc2xhdGUoZitEKG4pLyhPJiZlLmlzKE10KT81OjEpKSx1PTIwMDxNKG4pLHQ9TyE9PShPPUwoKSksKHV8fHQpJiZ6KG4pLGw9ITAsaChcImRyYWdnaW5nXCIpLEYobikpOlUoRCh1PW4pKT5VKEQodSwhMCkpJiYodD1uLGk9Yy5kcmFnTWluVGhyZXNob2xkLHI9dW4oaSksbz1yJiZpLm1vdXNlfHwwLHI9KHI/aS50b3VjaDoraSl8fDEwLHM9VShEKHQpKT4oUih0KT9yOm8pLEYobikpKX1mdW5jdGlvbiBfKG4pe3ZhciB0LGkscjttLmlzKDYpJiYobS5zZXQoMyksaChcImRyYWdnZWRcIikpLHMmJihpPWZ1bmN0aW9uKG4pe3JldHVybiBFKCkrTG4obikqWShVKG4pKihjLmZsaWNrUG93ZXJ8fDYwMCksYT8xLzA6by5MYXlvdXQubGlzdFNpemUoKSooYy5mbGlja01heFBhZ2VzfHwxKSl9KHQ9ZnVuY3Rpb24obil7aWYoZS5pcyhQdCl8fCFPKXt2YXIgdD1NKG4pO2lmKHQmJnQ8MjAwKXJldHVybiBEKG4pL3R9cmV0dXJuIDB9KHQ9bikpLHI9Yy5yZXdpbmQmJmMucmV3aW5kQnlEcmFnLGsoITEpLGE/dy5zY3JvbGwoaSwwLGMuc25hcCk6ZS5pcyhJdCk/dy5nbyhTKExuKHQpKTwwP3I/XCI8XCI6XCItXCI6cj9cIj5cIjpcIitcIik6ZS5pcyhNdCkmJk8mJnI/dy5nbyhMKCEwKT9cIj5cIjpcIjxcIik6dy5nbyh3LnRvRGVzdChpKSwhMCksayghMCksRihuKSksZyh2LHp0LEEpLGcodixEdCxfKSxzPSExfWZ1bmN0aW9uIFQobil7IWQmJmwmJkYobiwhMCl9ZnVuY3Rpb24geihuKXt1PXQsdD1uLGY9RSgpfWZ1bmN0aW9uIEQobix0KXtyZXR1cm4gSShuLHQpLUkoUChuKSx0KX1mdW5jdGlvbiBNKG4pe3JldHVybiBtbihuKS1tbihQKG4pKX1mdW5jdGlvbiBQKG4pe3JldHVybiB0PT09biYmdXx8dH1mdW5jdGlvbiBJKG4sdCl7cmV0dXJuKFIobik/bi5jaGFuZ2VkVG91Y2hlc1swXTpuKVtcInBhZ2VcIityKHQ/XCJZXCI6XCJYXCIpXX1mdW5jdGlvbiBSKG4pe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBUb3VjaEV2ZW50JiZuIGluc3RhbmNlb2YgVG91Y2hFdmVudH1mdW5jdGlvbiBDKG4pe2Q9bn1yZXR1cm57bW91bnQ6ZnVuY3Rpb24oKXtwKHgsenQsb24sanQpLHAoeCxEdCxvbixqdCkscCh4LF90LE4sanQpLHAoeCxcImNsaWNrXCIsVCx7Y2FwdHVyZTohMH0pLHAoeCxcImRyYWdzdGFydFwiLEYpLGkoW0IsS10sail9LGRpc2FibGU6Qyxpc0RyYWdnaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHN9fX0sS2V5Ym9hcmQ6ZnVuY3Rpb24odCxuLGkpe3ZhciByLG8sdT1RKHQpLGU9dS5vbixjPXUuYmluZCxmPXUudW5iaW5kLGE9dC5yb290LHM9bi5EaXJlY3Rpb24ucmVzb2x2ZTtmdW5jdGlvbiBsKCl7dmFyIG49aS5rZXlib2FyZDtuJiYocj1cImdsb2JhbFwiPT09bj93aW5kb3c6YSxjKHIsR3QsaCkpfWZ1bmN0aW9uIGQoKXtmKHIsR3QpfWZ1bmN0aW9uIHYoKXt2YXIgbj1vO289ITAscChmdW5jdGlvbigpe289bn0pfWZ1bmN0aW9uIGgobil7b3x8KChuPVR0KG4pKT09PXMoQm4pP3QuZ28oXCI8XCIpOm49PT1zKEhuKSYmdC5nbyhcIj5cIikpfXJldHVybnttb3VudDpmdW5jdGlvbigpe2woKSxlKEssZCksZShLLGwpLGUoSCx2KX0sZGVzdHJveTpkLGRpc2FibGU6ZnVuY3Rpb24obil7bz1ufX19LExhenlMb2FkOmZ1bmN0aW9uKGksbixvKXt2YXIgdD1RKGkpLHI9dC5vbix1PXQub2ZmLGU9dC5iaW5kLGM9dC5lbWl0LGY9XCJzZXF1ZW50aWFsXCI9PT1vLmxhenlMb2FkLGE9W0RuLFZdLHM9W107ZnVuY3Rpb24gbCgpe0Qocyksbi5TbGlkZXMuZm9yRWFjaChmdW5jdGlvbihyKXtnbihyLnNsaWRlLFd0KS5mb3JFYWNoKGZ1bmN0aW9uKG4pe3ZhciB0PXoobixGdCksaT16KG4sWHQpO3Q9PT1uLnNyYyYmaT09PW4uc3Jjc2V0fHwodD1vLmNsYXNzZXMuc3Bpbm5lcix0PWZuKGk9bi5wYXJlbnRFbGVtZW50LFwiLlwiK3QpfHxqKFwic3BhblwiLHQsaSkscy5wdXNoKFtuLHIsdF0pLG4uc3JjfHxsbihuLFwibm9uZVwiKSl9KX0pLChmP3A6KHUoYSkscihhLGQpLGQpKSgpfWZ1bmN0aW9uIGQoKXsocz1zLmZpbHRlcihmdW5jdGlvbihuKXt2YXIgdD1vLnBlclBhZ2UqKChvLnByZWxvYWRQYWdlc3x8MSkrMSktMTtyZXR1cm4hblsxXS5pc1dpdGhpbihpLmluZGV4LHQpfHx2KG4pfSkpLmxlbmd0aHx8dShhKX1mdW5jdGlvbiB2KG4pe3ZhciB0PW5bMF07TShuWzFdLnNsaWRlLEV0KSxlKHQsXCJsb2FkIGVycm9yXCIsUihoLG4pKSxJKHQsXCJzcmNcIix6KHQsRnQpKSxJKHQsXCJzcmNzZXRcIix6KHQsWHQpKSxQKHQsRnQpLFAodCxYdCl9ZnVuY3Rpb24gaChuLHQpe3ZhciBpPW5bMF0scj1uWzFdO1goci5zbGlkZSxFdCksXCJlcnJvclwiIT09dC50eXBlJiYoVChuWzJdKSxsbihpLFwiXCIpLGMoV24saSxyKSxjKGpuKSksZiYmcCgpfWZ1bmN0aW9uIHAoKXtzLmxlbmd0aCYmdihzLnNoaWZ0KCkpfXJldHVybnttb3VudDpmdW5jdGlvbigpe28ubGF6eUxvYWQmJihsKCkscihKLGwpKX0sZGVzdHJveTpSKEQscyksY2hlY2s6ZH19LFBhZ2luYXRpb246ZnVuY3Rpb24obCxuLGQpe3ZhciB2LGgsdD1RKGwpLHA9dC5vbixnPXQuZW1pdCxtPXQuYmluZCx5PW4uU2xpZGVzLGI9bi5FbGVtZW50cyx3PW4uQ29udHJvbGxlcix4PXcuaGFzRm9jdXMscj13LmdldEluZGV4LGU9dy5nbyxjPW4uRGlyZWN0aW9uLnJlc29sdmUsaz1iLnBhZ2luYXRpb24sUz1bXTtmdW5jdGlvbiBFKCl7diYmKFQoaz9vKHYuY2hpbGRyZW4pOnYpLFgodixoKSxEKFMpLHY9bnVsbCksdC5kZXN0cm95KCl9ZnVuY3Rpb24gTChuKXtlKFwiPlwiK24sITApfWZ1bmN0aW9uIE8obix0KXt2YXIgaT1TLmxlbmd0aCxyPVR0KHQpLG89QSgpLHU9LTEsbz0ocj09PWMoSG4sITEsbyk/dT0rK24laTpyPT09YyhCbiwhMSxvKT91PSgtLW4raSklaTpcIkhvbWVcIj09PXI/dT0wOlwiRW5kXCI9PT1yJiYodT1pLTEpLFNbdV0pO28mJihkbihvLmJ1dHRvbiksZShcIj5cIit1KSxGKHQsITApKX1mdW5jdGlvbiBBKCl7cmV0dXJuIGQucGFnaW5hdGlvbkRpcmVjdGlvbnx8ZC5kaXJlY3Rpb259ZnVuY3Rpb24gXyhuKXtyZXR1cm4gU1t3LnRvUGFnZShuKV19ZnVuY3Rpb24geigpe3ZhciBuLHQ9XyhyKCEwKSksaT1fKHIoKSk7dCYmKFgobj10LmJ1dHRvbix0biksUChuLFFuKSxJKG4sJCwtMSkpLGkmJihNKG49aS5idXR0b24sdG4pLEkobixRbiwhMCksSShuLCQsXCJcIikpLGcoXCJwYWdpbmF0aW9uOnVwZGF0ZWRcIix7bGlzdDp2LGl0ZW1zOlN9LHQsaSl9cmV0dXJue2l0ZW1zOlMsbW91bnQ6ZnVuY3Rpb24gbigpe0UoKSxwKFtLLEosXCJlaVwiXSxuKTt2YXIgdD1kLnBhZ2luYXRpb247aWYoayYmbG4oayx0P1wiXCI6XCJub25lXCIpLHQpe3AoW0gsVG4sVl0seik7dmFyIHQ9bC5sZW5ndGgsaT1kLmNsYXNzZXMscj1kLmkxOG4sbz1kLnBlclBhZ2UsdT14KCk/dy5nZXRFbmQoKSsxOmtuKHQvbyk7TSh2PWt8fGooXCJ1bFwiLGkucGFnaW5hdGlvbixiLnRyYWNrLnBhcmVudEVsZW1lbnQpLGg9Z3QrXCItLVwiK0EoKSksSSh2LFosXCJ0YWJsaXN0XCIpLEkodixubixyLnNlbGVjdCksSSh2LG50LEEoKT09PUpuP1widmVydGljYWxcIjpcIlwiKTtmb3IodmFyIGU9MDtlPHU7ZSsrKXt2YXIgYz1qKFwibGlcIixudWxsLHYpLGY9aihcImJ1dHRvblwiLHtjbGFzczppLnBhZ2UsdHlwZTpcImJ1dHRvblwifSxjKSxhPXkuZ2V0SW4oZSkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuLnNsaWRlLmlkfSkscz0heCgpJiYxPG8/ci5wYWdlWDpyLnNsaWRlWDttKGYsXCJjbGlja1wiLFIoTCxlKSksZC5wYWdpbmF0aW9uS2V5Ym9hcmQmJm0oZixcImtleWRvd25cIixSKE8sZSkpLEkoYyxaLFwicHJlc2VudGF0aW9uXCIpLEkoZixaLFwidGFiXCIpLEkoZixLbixhLmpvaW4oXCIgXCIpKSxJKGYsbm4sT24ocyxlKzEpKSxJKGYsJCwtMSksUy5wdXNoKHtsaTpjLGJ1dHRvbjpmLHBhZ2U6ZX0pfXooKSxnKFwicGFnaW5hdGlvbjptb3VudGVkXCIse2xpc3Q6dixpdGVtczpTfSxfKGwuaW5kZXgpKX19LGRlc3Ryb3k6RSxnZXRBdDpfLHVwZGF0ZTp6fX0sU3luYzpmdW5jdGlvbihpLG4sdCl7dmFyIHI9dC5pc05hdmlnYXRpb24sbz10LnNsaWRlRm9jdXMsdT1bXTtmdW5jdGlvbiBlKCl7dmFyIG4sdDtpLnNwbGlkZXMuZm9yRWFjaChmdW5jdGlvbihuKXtuLmlzUGFyZW50fHwoZihpLG4uc3BsaWRlKSxmKG4uc3BsaWRlLGkpKX0pLHImJihuPVEoaSksKHQ9bi5vbikoTW4scyksdChZbixsKSx0KFtCLEtdLGEpLHUucHVzaChuKSxuLmVtaXQoR24saS5zcGxpZGVzKSl9ZnVuY3Rpb24gYygpe3UuZm9yRWFjaChmdW5jdGlvbihuKXtuLmRlc3Ryb3koKX0pLEQodSl9ZnVuY3Rpb24gZihuLHIpe249UShuKTtuLm9uKEgsZnVuY3Rpb24obix0LGkpe3IuZ28oci5pcyhQdCk/aTpuKX0pLHUucHVzaChuKX1mdW5jdGlvbiBhKCl7SShuLkVsZW1lbnRzLmxpc3QsbnQsdC5kaXJlY3Rpb249PT1Kbj9cInZlcnRpY2FsXCI6XCJcIil9ZnVuY3Rpb24gcyhuKXtpLmdvKG4uaW5kZXgpfWZ1bmN0aW9uIGwobix0KXtiKFl0LFR0KHQpKSYmKHMobiksRih0KSl9cmV0dXJue3NldHVwOlIobi5NZWRpYS5zZXQse3NsaWRlRm9jdXM6ZW4obyk/cjpvfSwhMCksbW91bnQ6ZSxkZXN0cm95OmMscmVtb3VudDpmdW5jdGlvbigpe2MoKSxlKCl9fX0sV2hlZWw6ZnVuY3Rpb24oZSxjLGYpe3ZhciBuPVEoZSkuYmluZCxhPTA7ZnVuY3Rpb24gdChuKXt2YXIgdCxpLHIsbyx1O24uY2FuY2VsYWJsZSYmKHQ9KHU9bi5kZWx0YVkpPDAsaT1tbihuKSxyPWYud2hlZWxNaW5UaHJlc2hvbGR8fDAsbz1mLndoZWVsU2xlZXB8fDAsVSh1KT5yJiZvPGktYSYmKGUuZ28odD9cIjxcIjpcIj5cIiksYT1pKSx1PXQsZi5yZWxlYXNlV2hlZWwmJiFlLnN0YXRlLmlzKEcpJiYtMT09PWMuQ29udHJvbGxlci5nZXRBZGphY2VudCh1KXx8RihuKSl9cmV0dXJue21vdW50OmZ1bmN0aW9uKCl7Zi53aGVlbCYmbihjLkVsZW1lbnRzLnRyYWNrLFwid2hlZWxcIix0LGp0KX19fSxMaXZlOmZ1bmN0aW9uKG4sdCxpKXt2YXIgcj1RKG4pLm9uLG89dC5FbGVtZW50cy50cmFjayx1PWkubGl2ZSYmIWkuaXNOYXZpZ2F0aW9uLGU9aihcInNwYW5cIix3dCksYz1xbig5MCxSKGYsITEpKTtmdW5jdGlvbiBmKG4pe0kobyxydCxuKSxuPyhMKG8sZSksYy5zdGFydCgpKTooVChlKSxjLmNhbmNlbCgpKX1mdW5jdGlvbiBhKG4pe3UmJkkobyxpdCxuP1wib2ZmXCI6XCJwb2xpdGVcIil9cmV0dXJue21vdW50OmZ1bmN0aW9uKCl7dSYmKGEoIXQuQXV0b3BsYXkuaXNQYXVzZWQoKSksSShvLG90LCEwKSxlLnRleHRDb250ZW50PVwi4oCmXCIscihGbixSKGEsITApKSxyKFhuLFIoYSwhMSkpLHIoW0RuLFZdLFIoZiwhMCkpKX0sZGlzYWJsZTphLGRlc3Ryb3k6ZnVuY3Rpb24oKXtQKG8sW2l0LG90LHJ0XSksVChlKX19fX0pLHF0PXt0eXBlOlwic2xpZGVcIixyb2xlOlwicmVnaW9uXCIsc3BlZWQ6NDAwLHBlclBhZ2U6MSxjbG9uZVN0YXR1czohMCxhcnJvd3M6ITAscGFnaW5hdGlvbjohMCxwYWdpbmF0aW9uS2V5Ym9hcmQ6ITAsaW50ZXJ2YWw6NWUzLHBhdXNlT25Ib3ZlcjohMCxwYXVzZU9uRm9jdXM6ITAscmVzZXRQcm9ncmVzczohMCxlYXNpbmc6XCJjdWJpYy1iZXppZXIoMC4yNSwgMSwgMC41LCAxKVwiLGRyYWc6ITAsZGlyZWN0aW9uOlwibHRyXCIsdHJpbVNwYWNlOiEwLGZvY3VzYWJsZU5vZGVzOlwiYSwgYnV0dG9uLCB0ZXh0YXJlYSwgaW5wdXQsIHNlbGVjdCwgaWZyYW1lXCIsbGl2ZTohMCxjbGFzc2VzOntzbGlkZTphdCxjbG9uZTpzdCxhcnJvd3M6ZHQsYXJyb3c6dnQscHJldjpodCxuZXh0OnB0LHBhZ2luYXRpb246Z3QscGFnZTptdCxzcGlubmVyOmkrXCJzcGlubmVyXCJ9LGkxOG46e3ByZXY6XCJQcmV2aW91cyBzbGlkZVwiLG5leHQ6XCJOZXh0IHNsaWRlXCIsZmlyc3Q6XCJHbyB0byBmaXJzdCBzbGlkZVwiLGxhc3Q6XCJHbyB0byBsYXN0IHNsaWRlXCIsc2xpZGVYOlwiR28gdG8gc2xpZGUgJXNcIixwYWdlWDpcIkdvIHRvIHBhZ2UgJXNcIixwbGF5OlwiU3RhcnQgYXV0b3BsYXlcIixwYXVzZTpcIlBhdXNlIGF1dG9wbGF5XCIsY2Fyb3VzZWw6XCJjYXJvdXNlbFwiLHNsaWRlOlwic2xpZGVcIixzZWxlY3Q6XCJTZWxlY3QgYSBzbGlkZSB0byBzaG93XCIsc2xpZGVMYWJlbDpcIiVzIG9mICVzXCJ9LHJlZHVjZWRNb3Rpb246e3NwZWVkOjAscmV3aW5kU3BlZWQ6MCxhdXRvcGxheTpcInBhdXNlXCJ9fTtmdW5jdGlvbiBCdChuLHQsaSl7dmFyIHI9dC5TbGlkZXM7ZnVuY3Rpb24gbygpe3IuZm9yRWFjaChmdW5jdGlvbihuKXtuLnN0eWxlKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKC1cIisxMDAqbi5pbmRleCtcIiUpXCIpfSl9cmV0dXJue21vdW50OmZ1bmN0aW9uKCl7UShuKS5vbihbQixKXSxvKX0sc3RhcnQ6ZnVuY3Rpb24obix0KXtyLnN0eWxlKFwidHJhbnNpdGlvblwiLFwib3BhY2l0eSBcIitpLnNwZWVkK1wibXMgXCIraS5lYXNpbmcpLHAodCl9LGNhbmNlbDpvbn19ZnVuY3Rpb24gSHQodSxuLGUpe3ZhciBjLGY9bi5Nb3ZlLGE9bi5Db250cm9sbGVyLHM9bi5TY3JvbGwsdD1uLkVsZW1lbnRzLmxpc3QsbD1SKF8sdCxcInRyYW5zaXRpb25cIik7ZnVuY3Rpb24gaSgpe2woXCJcIikscy5jYW5jZWwoKX1yZXR1cm57bW91bnQ6ZnVuY3Rpb24oKXtRKHUpLmJpbmQodCxcInRyYW5zaXRpb25lbmRcIixmdW5jdGlvbihuKXtuLnRhcmdldD09PXQmJmMmJihpKCksYygpKX0pfSxzdGFydDpmdW5jdGlvbihuLHQpe3ZhciBpPWYudG9Qb3NpdGlvbihuLCEwKSxyPWYuZ2V0UG9zaXRpb24oKSxvPWZ1bmN0aW9uKG4pe3ZhciB0PWUucmV3aW5kU3BlZWQ7aWYodS5pcyhNdCkmJnQpe3ZhciBpPWEuZ2V0SW5kZXgoITApLHI9YS5nZXRFbmQoKTtpZigwPT09aSYmcjw9bnx8cjw9aSYmMD09PW4pcmV0dXJuIHR9cmV0dXJuIGUuc3BlZWR9KG4pOzE8PVUoaS1yKSYmMTw9bz9lLnVzZVNjcm9sbD9zLnNjcm9sbChpLG8sITEsdCk6KGwoXCJ0cmFuc2Zvcm0gXCIrbytcIm1zIFwiK2UuZWFzaW5nKSxmLnRyYW5zbGF0ZShpLCEwKSxjPXQpOihmLmp1bXAobiksdCgpKX0sY2FuY2VsOml9fXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBpKG4sdCl7dGhpcy5ldmVudD1RKCksdGhpcy5Db21wb25lbnRzPXt9LHRoaXMuc3RhdGU9cygxKSx0aGlzLnNwbGlkZXM9W10sdGhpcy5uPXt9LHRoaXMudD17fTtuPUMobik/cG4oZG9jdW1lbnQsbik6bjtibihuLG4rXCIgaXMgaW52YWxpZC5cIiksdD1kKHtsYWJlbDp6KHRoaXMucm9vdD1uLG5uKXx8XCJcIixsYWJlbGxlZGJ5Onoobixabil8fFwiXCJ9LHF0LGkuZGVmYXVsdHMsdHx8e30pO3RyeXtkKHQsSlNPTi5wYXJzZSh6KG4sZikpKX1jYXRjaChuKXtibighMSxcIkludmFsaWQgSlNPTlwiKX10aGlzLm49T2JqZWN0LmNyZWF0ZShkKHt9LHQpKX12YXIgbj1pLnByb3RvdHlwZTtyZXR1cm4gbi5tb3VudD1mdW5jdGlvbihuLHQpe3ZhciBpPXRoaXMscj10aGlzLnN0YXRlLG89dGhpcy5Db21wb25lbnRzO3JldHVybiBibihyLmlzKFsxLDddKSxcIkFscmVhZHkgbW91bnRlZCFcIiksci5zZXQoMSksdGhpcy5pPW8sdGhpcy5yPXR8fHRoaXMucnx8KHRoaXMuaXMoSXQpP0J0Okh0KSx0aGlzLnQ9bnx8dGhpcy50LHcoYW4oe30sVXQsdGhpcy50LHtUcmFuc2l0aW9uOnRoaXMucn0pLGZ1bmN0aW9uKG4sdCl7bj1uKGksbyxpLm4pOyhvW3RdPW4pLnNldHVwJiZuLnNldHVwKCl9KSx3KG8sZnVuY3Rpb24obil7bi5tb3VudCYmbi5tb3VudCgpfSksdGhpcy5lbWl0KEIpLE0odGhpcy5yb290LFwiaXMtaW5pdGlhbGl6ZWRcIiksci5zZXQoMyksdGhpcy5lbWl0KFwicmVhZHlcIiksdGhpc30sbi5zeW5jPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnNwbGlkZXMucHVzaCh7c3BsaWRlOm59KSxuLnNwbGlkZXMucHVzaCh7c3BsaWRlOnRoaXMsaXNQYXJlbnQ6ITB9KSx0aGlzLnN0YXRlLmlzKDMpJiYodGhpcy5pLlN5bmMucmVtb3VudCgpLG4uQ29tcG9uZW50cy5TeW5jLnJlbW91bnQoKSksdGhpc30sbi5nbz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5pLkNvbnRyb2xsZXIuZ28obiksdGhpc30sbi5vbj1mdW5jdGlvbihuLHQpe3JldHVybiB0aGlzLmV2ZW50Lm9uKG4sdCksdGhpc30sbi5vZmY9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZXZlbnQub2ZmKG4pLHRoaXN9LG4uZW1pdD1mdW5jdGlvbihuKXt2YXIgdDtyZXR1cm4odD10aGlzLmV2ZW50KS5lbWl0LmFwcGx5KHQsW25dLmNvbmNhdChvKGFyZ3VtZW50cywxKSkpLHRoaXN9LG4uYWRkPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIHRoaXMuaS5TbGlkZXMuYWRkKG4sdCksdGhpc30sbi5yZW1vdmU9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuaS5TbGlkZXMucmVtb3ZlKG4pLHRoaXN9LG4uaXM9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMubi50eXBlPT09bn0sbi5yZWZyZXNoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW1pdChKKSx0aGlzfSxuLmRlc3Ryb3k9ZnVuY3Rpb24odCl7dm9pZCAwPT09dCYmKHQ9ITApO3ZhciBuPXRoaXMuZXZlbnQsaT10aGlzLnN0YXRlO3JldHVybiBpLmlzKDEpP1EodGhpcykub24oXCJyZWFkeVwiLHRoaXMuZGVzdHJveS5iaW5kKHRoaXMsdCkpOih3KHRoaXMuaSxmdW5jdGlvbihuKXtuLmRlc3Ryb3kmJm4uZGVzdHJveSh0KX0sITApLG4uZW1pdChhKSxuLmRlc3Ryb3koKSx0JiZEKHRoaXMuc3BsaWRlcyksaS5zZXQoNykpLHRoaXN9LEp0KGksW3trZXk6XCJvcHRpb25zXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubn0sc2V0OmZ1bmN0aW9uKG4pe3RoaXMuaS5NZWRpYS5zZXQobiwhMCwhMCl9fSx7a2V5OlwibGVuZ3RoXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaS5TbGlkZXMuZ2V0TGVuZ3RoKCEwKX19LHtrZXk6XCJpbmRleFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmkuQ29udHJvbGxlci5nZXRJbmRleCgpfX1dKSxpfSgpO3JldHVybiB0LmRlZmF1bHRzPXt9LHQuU1RBVEVTPXIsdH0sXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6KG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpufHxzZWxmKS5TcGxpZGU9dCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BsaWRlLm1pbi5qcy5tYXAiLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKHJlcXVpcmUoXCJAcG9wcGVyanMvY29yZVwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJAcG9wcGVyanMvY29yZVwiXSxlKToodD10fHxzZWxmKS50aXBweT1lKHQuUG9wcGVyKX0odGhpcywoZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50LG49ISFlJiYhIXdpbmRvdy5tc0NyeXB0byxyPXtwYXNzaXZlOiEwLGNhcHR1cmU6ITB9LG89ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuYm9keX07ZnVuY3Rpb24gaSh0LGUsbil7aWYoQXJyYXkuaXNBcnJheSh0KSl7dmFyIHI9dFtlXTtyZXR1cm4gbnVsbD09cj9BcnJheS5pc0FycmF5KG4pP25bZV06bjpyfXJldHVybiB0fWZ1bmN0aW9uIGEodCxlKXt2YXIgbj17fS50b1N0cmluZy5jYWxsKHQpO3JldHVybiAwPT09bi5pbmRleE9mKFwiW29iamVjdFwiKSYmbi5pbmRleE9mKGUrXCJdXCIpPi0xfWZ1bmN0aW9uIHModCxlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3QuYXBwbHkodm9pZCAwLGUpOnR9ZnVuY3Rpb24gdSh0LGUpe3JldHVybiAwPT09ZT90OmZ1bmN0aW9uKHIpe2NsZWFyVGltZW91dChuKSxuPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dChyKX0pLGUpfTt2YXIgbn1mdW5jdGlvbiBwKHQsZSl7dmFyIG49T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbih0KXtkZWxldGUgblt0XX0pKSxufWZ1bmN0aW9uIGModCl7cmV0dXJuW10uY29uY2F0KHQpfWZ1bmN0aW9uIGYodCxlKXstMT09PXQuaW5kZXhPZihlKSYmdC5wdXNoKGUpfWZ1bmN0aW9uIGwodCl7cmV0dXJuIHQuc3BsaXQoXCItXCIpWzBdfWZ1bmN0aW9uIGQodCl7cmV0dXJuW10uc2xpY2UuY2FsbCh0KX1mdW5jdGlvbiB2KHQpe3JldHVybiBPYmplY3Qua2V5cyh0KS5yZWR1Y2UoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIHZvaWQgMCE9PXRbbl0mJihlW25dPXRbbl0pLGV9KSx7fSl9ZnVuY3Rpb24gbSgpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpfWZ1bmN0aW9uIGcodCl7cmV0dXJuW1wiRWxlbWVudFwiLFwiRnJhZ21lbnRcIl0uc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGEodCxlKX0pKX1mdW5jdGlvbiBoKHQpe3JldHVybiBhKHQsXCJNb3VzZUV2ZW50XCIpfWZ1bmN0aW9uIGIodCl7cmV0dXJuISghdHx8IXQuX3RpcHB5fHx0Ll90aXBweS5yZWZlcmVuY2UhPT10KX1mdW5jdGlvbiB5KHQpe3JldHVybiBnKHQpP1t0XTpmdW5jdGlvbih0KXtyZXR1cm4gYSh0LFwiTm9kZUxpc3RcIil9KHQpP2QodCk6QXJyYXkuaXNBcnJheSh0KT90OmQoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KSl9ZnVuY3Rpb24gdyh0LGUpe3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7dCYmKHQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uPWUrXCJtc1wiKX0pKX1mdW5jdGlvbiB4KHQsZSl7dC5mb3JFYWNoKChmdW5jdGlvbih0KXt0JiZ0LnNldEF0dHJpYnV0ZShcImRhdGEtc3RhdGVcIixlKX0pKX1mdW5jdGlvbiBFKHQpe3ZhciBlLG49Yyh0KVswXTtyZXR1cm4gbnVsbCE9biYmbnVsbCE9KGU9bi5vd25lckRvY3VtZW50KSYmZS5ib2R5P24ub3duZXJEb2N1bWVudDpkb2N1bWVudH1mdW5jdGlvbiBPKHQsZSxuKXt2YXIgcj1lK1wiRXZlbnRMaXN0ZW5lclwiO1tcInRyYW5zaXRpb25lbmRcIixcIndlYmtpdFRyYW5zaXRpb25FbmRcIl0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dFtyXShlLG4pfSkpfWZ1bmN0aW9uIEModCxlKXtmb3IodmFyIG49ZTtuOyl7dmFyIHI7aWYodC5jb250YWlucyhuKSlyZXR1cm4hMDtuPW51bGw9PW4uZ2V0Um9vdE5vZGV8fG51bGw9PShyPW4uZ2V0Um9vdE5vZGUoKSk/dm9pZCAwOnIuaG9zdH1yZXR1cm4hMX12YXIgVD17aXNUb3VjaDohMX0sQT0wO2Z1bmN0aW9uIEwoKXtULmlzVG91Y2h8fChULmlzVG91Y2g9ITAsd2luZG93LnBlcmZvcm1hbmNlJiZkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsRCkpfWZ1bmN0aW9uIEQoKXt2YXIgdD1wZXJmb3JtYW5jZS5ub3coKTt0LUE8MjAmJihULmlzVG91Y2g9ITEsZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLEQpKSxBPXR9ZnVuY3Rpb24gaygpe3ZhciB0PWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7aWYoYih0KSl7dmFyIGU9dC5fdGlwcHk7dC5ibHVyJiYhZS5zdGF0ZS5pc1Zpc2libGUmJnQuYmx1cigpfX12YXIgUj1PYmplY3QuYXNzaWduKHthcHBlbmRUbzpvLGFyaWE6e2NvbnRlbnQ6XCJhdXRvXCIsZXhwYW5kZWQ6XCJhdXRvXCJ9LGRlbGF5OjAsZHVyYXRpb246WzMwMCwyNTBdLGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6bnVsbCxoaWRlT25DbGljazohMCxpZ25vcmVBdHRyaWJ1dGVzOiExLGludGVyYWN0aXZlOiExLGludGVyYWN0aXZlQm9yZGVyOjIsaW50ZXJhY3RpdmVEZWJvdW5jZTowLG1vdmVUcmFuc2l0aW9uOlwiXCIsb2Zmc2V0OlswLDEwXSxvbkFmdGVyVXBkYXRlOmZ1bmN0aW9uKCl7fSxvbkJlZm9yZVVwZGF0ZTpmdW5jdGlvbigpe30sb25DcmVhdGU6ZnVuY3Rpb24oKXt9LG9uRGVzdHJveTpmdW5jdGlvbigpe30sb25IaWRkZW46ZnVuY3Rpb24oKXt9LG9uSGlkZTpmdW5jdGlvbigpe30sb25Nb3VudDpmdW5jdGlvbigpe30sb25TaG93OmZ1bmN0aW9uKCl7fSxvblNob3duOmZ1bmN0aW9uKCl7fSxvblRyaWdnZXI6ZnVuY3Rpb24oKXt9LG9uVW50cmlnZ2VyOmZ1bmN0aW9uKCl7fSxvbkNsaWNrT3V0c2lkZTpmdW5jdGlvbigpe30scGxhY2VtZW50OlwidG9wXCIscGx1Z2luczpbXSxwb3BwZXJPcHRpb25zOnt9LHJlbmRlcjpudWxsLHNob3dPbkNyZWF0ZTohMSx0b3VjaDohMCx0cmlnZ2VyOlwibW91c2VlbnRlciBmb2N1c1wiLHRyaWdnZXJUYXJnZXQ6bnVsbH0se2FuaW1hdGVGaWxsOiExLGZvbGxvd0N1cnNvcjohMSxpbmxpbmVQb3NpdGlvbmluZzohMSxzdGlja3k6ITF9LHthbGxvd0hUTUw6ITEsYW5pbWF0aW9uOlwiZmFkZVwiLGFycm93OiEwLGNvbnRlbnQ6XCJcIixpbmVydGlhOiExLG1heFdpZHRoOjM1MCxyb2xlOlwidG9vbHRpcFwiLHRoZW1lOlwiXCIsekluZGV4Ojk5OTl9KSxQPU9iamVjdC5rZXlzKFIpO2Z1bmN0aW9uIGoodCl7dmFyIGU9KHQucGx1Z2luc3x8W10pLnJlZHVjZSgoZnVuY3Rpb24oZSxuKXt2YXIgcixvPW4ubmFtZSxpPW4uZGVmYXVsdFZhbHVlO28mJihlW29dPXZvaWQgMCE9PXRbb10/dFtvXTpudWxsIT0ocj1SW29dKT9yOmkpO3JldHVybiBlfSkse30pO3JldHVybiBPYmplY3QuYXNzaWduKHt9LHQsZSl9ZnVuY3Rpb24gTSh0LGUpe3ZhciBuPU9iamVjdC5hc3NpZ24oe30sZSx7Y29udGVudDpzKGUuY29udGVudCxbdF0pfSxlLmlnbm9yZUF0dHJpYnV0ZXM/e306ZnVuY3Rpb24odCxlKXtyZXR1cm4oZT9PYmplY3Qua2V5cyhqKE9iamVjdC5hc3NpZ24oe30sUix7cGx1Z2luczplfSkpKTpQKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsbil7dmFyIHI9KHQuZ2V0QXR0cmlidXRlKFwiZGF0YS10aXBweS1cIituKXx8XCJcIikudHJpbSgpO2lmKCFyKXJldHVybiBlO2lmKFwiY29udGVudFwiPT09billW25dPXI7ZWxzZSB0cnl7ZVtuXT1KU09OLnBhcnNlKHIpfWNhdGNoKHQpe2Vbbl09cn1yZXR1cm4gZX0pLHt9KX0odCxlLnBsdWdpbnMpKTtyZXR1cm4gbi5hcmlhPU9iamVjdC5hc3NpZ24oe30sUi5hcmlhLG4uYXJpYSksbi5hcmlhPXtleHBhbmRlZDpcImF1dG9cIj09PW4uYXJpYS5leHBhbmRlZD9lLmludGVyYWN0aXZlOm4uYXJpYS5leHBhbmRlZCxjb250ZW50OlwiYXV0b1wiPT09bi5hcmlhLmNvbnRlbnQ/ZS5pbnRlcmFjdGl2ZT9udWxsOlwiZGVzY3JpYmVkYnlcIjpuLmFyaWEuY29udGVudH0sbn1mdW5jdGlvbiBWKHQsZSl7dC5pbm5lckhUTUw9ZX1mdW5jdGlvbiBJKHQpe3ZhciBlPW0oKTtyZXR1cm4hMD09PXQ/ZS5jbGFzc05hbWU9XCJ0aXBweS1hcnJvd1wiOihlLmNsYXNzTmFtZT1cInRpcHB5LXN2Zy1hcnJvd1wiLGcodCk/ZS5hcHBlbmRDaGlsZCh0KTpWKGUsdCkpLGV9ZnVuY3Rpb24gUyh0LGUpe2coZS5jb250ZW50KT8oVih0LFwiXCIpLHQuYXBwZW5kQ2hpbGQoZS5jb250ZW50KSk6XCJmdW5jdGlvblwiIT10eXBlb2YgZS5jb250ZW50JiYoZS5hbGxvd0hUTUw/Vih0LGUuY29udGVudCk6dC50ZXh0Q29udGVudD1lLmNvbnRlbnQpfWZ1bmN0aW9uIEIodCl7dmFyIGU9dC5maXJzdEVsZW1lbnRDaGlsZCxuPWQoZS5jaGlsZHJlbik7cmV0dXJue2JveDplLGNvbnRlbnQ6bi5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0aXBweS1jb250ZW50XCIpfSkpLGFycm93Om4uZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2xhc3NMaXN0LmNvbnRhaW5zKFwidGlwcHktYXJyb3dcIil8fHQuY2xhc3NMaXN0LmNvbnRhaW5zKFwidGlwcHktc3ZnLWFycm93XCIpfSkpLGJhY2tkcm9wOm4uZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2xhc3NMaXN0LmNvbnRhaW5zKFwidGlwcHktYmFja2Ryb3BcIil9KSl9fWZ1bmN0aW9uIE4odCl7dmFyIGU9bSgpLG49bSgpO24uY2xhc3NOYW1lPVwidGlwcHktYm94XCIsbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN0YXRlXCIsXCJoaWRkZW5cIiksbi5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLFwiLTFcIik7dmFyIHI9bSgpO2Z1bmN0aW9uIG8obixyKXt2YXIgbz1CKGUpLGk9by5ib3gsYT1vLmNvbnRlbnQscz1vLmFycm93O3IudGhlbWU/aS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRoZW1lXCIsci50aGVtZSk6aS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRoZW1lXCIpLFwic3RyaW5nXCI9PXR5cGVvZiByLmFuaW1hdGlvbj9pLnNldEF0dHJpYnV0ZShcImRhdGEtYW5pbWF0aW9uXCIsci5hbmltYXRpb24pOmkucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1hbmltYXRpb25cIiksci5pbmVydGlhP2kuc2V0QXR0cmlidXRlKFwiZGF0YS1pbmVydGlhXCIsXCJcIik6aS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWluZXJ0aWFcIiksaS5zdHlsZS5tYXhXaWR0aD1cIm51bWJlclwiPT10eXBlb2Ygci5tYXhXaWR0aD9yLm1heFdpZHRoK1wicHhcIjpyLm1heFdpZHRoLHIucm9sZT9pLnNldEF0dHJpYnV0ZShcInJvbGVcIixyLnJvbGUpOmkucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKSxuLmNvbnRlbnQ9PT1yLmNvbnRlbnQmJm4uYWxsb3dIVE1MPT09ci5hbGxvd0hUTUx8fFMoYSx0LnByb3BzKSxyLmFycm93P3M/bi5hcnJvdyE9PXIuYXJyb3cmJihpLnJlbW92ZUNoaWxkKHMpLGkuYXBwZW5kQ2hpbGQoSShyLmFycm93KSkpOmkuYXBwZW5kQ2hpbGQoSShyLmFycm93KSk6cyYmaS5yZW1vdmVDaGlsZChzKX1yZXR1cm4gci5jbGFzc05hbWU9XCJ0aXBweS1jb250ZW50XCIsci5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN0YXRlXCIsXCJoaWRkZW5cIiksUyhyLHQucHJvcHMpLGUuYXBwZW5kQ2hpbGQobiksbi5hcHBlbmRDaGlsZChyKSxvKHQucHJvcHMsdC5wcm9wcykse3BvcHBlcjplLG9uVXBkYXRlOm99fU4uJCR0aXBweT0hMDt2YXIgSD0xLFU9W10sXz1bXTtmdW5jdGlvbiB6KGUsYSl7dmFyIHAsZyxiLHksQSxMLEQsayxQPU0oZSxPYmplY3QuYXNzaWduKHt9LFIsaih2KGEpKSkpLFY9ITEsST0hMSxTPSExLE49ITEsej1bXSxGPXUod3QsUC5pbnRlcmFjdGl2ZURlYm91bmNlKSxXPUgrKyxYPShrPVAucGx1Z2lucykuZmlsdGVyKChmdW5jdGlvbih0LGUpe3JldHVybiBrLmluZGV4T2YodCk9PT1lfSkpLFk9e2lkOlcscmVmZXJlbmNlOmUscG9wcGVyOm0oKSxwb3BwZXJJbnN0YW5jZTpudWxsLHByb3BzOlAsc3RhdGU6e2lzRW5hYmxlZDohMCxpc1Zpc2libGU6ITEsaXNEZXN0cm95ZWQ6ITEsaXNNb3VudGVkOiExLGlzU2hvd246ITF9LHBsdWdpbnM6WCxjbGVhckRlbGF5VGltZW91dHM6ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQocCksY2xlYXJUaW1lb3V0KGcpLGNhbmNlbEFuaW1hdGlvbkZyYW1lKGIpfSxzZXRQcm9wczpmdW5jdGlvbih0KXtpZihZLnN0YXRlLmlzRGVzdHJveWVkKXJldHVybjthdChcIm9uQmVmb3JlVXBkYXRlXCIsW1ksdF0pLGJ0KCk7dmFyIG49WS5wcm9wcyxyPU0oZSxPYmplY3QuYXNzaWduKHt9LG4sdih0KSx7aWdub3JlQXR0cmlidXRlczohMH0pKTtZLnByb3BzPXIsaHQoKSxuLmludGVyYWN0aXZlRGVib3VuY2UhPT1yLmludGVyYWN0aXZlRGVib3VuY2UmJihwdCgpLEY9dSh3dCxyLmludGVyYWN0aXZlRGVib3VuY2UpKTtuLnRyaWdnZXJUYXJnZXQmJiFyLnRyaWdnZXJUYXJnZXQ/YyhuLnRyaWdnZXJUYXJnZXQpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKX0pKTpyLnRyaWdnZXJUYXJnZXQmJmUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKTt1dCgpLGl0KCksSiYmSihuLHIpO1kucG9wcGVySW5zdGFuY2UmJihDdCgpLEF0KCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHQuX3RpcHB5LnBvcHBlckluc3RhbmNlLmZvcmNlVXBkYXRlKX0pKSk7YXQoXCJvbkFmdGVyVXBkYXRlXCIsW1ksdF0pfSxzZXRDb250ZW50OmZ1bmN0aW9uKHQpe1kuc2V0UHJvcHMoe2NvbnRlbnQ6dH0pfSxzaG93OmZ1bmN0aW9uKCl7dmFyIHQ9WS5zdGF0ZS5pc1Zpc2libGUsZT1ZLnN0YXRlLmlzRGVzdHJveWVkLG49IVkuc3RhdGUuaXNFbmFibGVkLHI9VC5pc1RvdWNoJiYhWS5wcm9wcy50b3VjaCxhPWkoWS5wcm9wcy5kdXJhdGlvbiwwLFIuZHVyYXRpb24pO2lmKHR8fGV8fG58fHIpcmV0dXJuO2lmKGV0KCkuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikpcmV0dXJuO2lmKGF0KFwib25TaG93XCIsW1ldLCExKSwhMT09PVkucHJvcHMub25TaG93KFkpKXJldHVybjtZLnN0YXRlLmlzVmlzaWJsZT0hMCx0dCgpJiYoJC5zdHlsZS52aXNpYmlsaXR5PVwidmlzaWJsZVwiKTtpdCgpLGR0KCksWS5zdGF0ZS5pc01vdW50ZWR8fCgkLnN0eWxlLnRyYW5zaXRpb249XCJub25lXCIpO2lmKHR0KCkpe3ZhciB1PXJ0KCkscD11LmJveCxjPXUuY29udGVudDt3KFtwLGNdLDApfUw9ZnVuY3Rpb24oKXt2YXIgdDtpZihZLnN0YXRlLmlzVmlzaWJsZSYmIU4pe2lmKE49ITAsJC5vZmZzZXRIZWlnaHQsJC5zdHlsZS50cmFuc2l0aW9uPVkucHJvcHMubW92ZVRyYW5zaXRpb24sdHQoKSYmWS5wcm9wcy5hbmltYXRpb24pe3ZhciBlPXJ0KCksbj1lLmJveCxyPWUuY29udGVudDt3KFtuLHJdLGEpLHgoW24scl0sXCJ2aXNpYmxlXCIpfXN0KCksdXQoKSxmKF8sWSksbnVsbD09KHQ9WS5wb3BwZXJJbnN0YW5jZSl8fHQuZm9yY2VVcGRhdGUoKSxhdChcIm9uTW91bnRcIixbWV0pLFkucHJvcHMuYW5pbWF0aW9uJiZ0dCgpJiZmdW5jdGlvbih0LGUpe210KHQsZSl9KGEsKGZ1bmN0aW9uKCl7WS5zdGF0ZS5pc1Nob3duPSEwLGF0KFwib25TaG93blwiLFtZXSl9KSl9fSxmdW5jdGlvbigpe3ZhciB0LGU9WS5wcm9wcy5hcHBlbmRUbyxuPWV0KCk7dD1ZLnByb3BzLmludGVyYWN0aXZlJiZlPT09b3x8XCJwYXJlbnRcIj09PWU/bi5wYXJlbnROb2RlOnMoZSxbbl0pO3QuY29udGFpbnMoJCl8fHQuYXBwZW5kQ2hpbGQoJCk7WS5zdGF0ZS5pc01vdW50ZWQ9ITAsQ3QoKX0oKX0saGlkZTpmdW5jdGlvbigpe3ZhciB0PSFZLnN0YXRlLmlzVmlzaWJsZSxlPVkuc3RhdGUuaXNEZXN0cm95ZWQsbj0hWS5zdGF0ZS5pc0VuYWJsZWQscj1pKFkucHJvcHMuZHVyYXRpb24sMSxSLmR1cmF0aW9uKTtpZih0fHxlfHxuKXJldHVybjtpZihhdChcIm9uSGlkZVwiLFtZXSwhMSksITE9PT1ZLnByb3BzLm9uSGlkZShZKSlyZXR1cm47WS5zdGF0ZS5pc1Zpc2libGU9ITEsWS5zdGF0ZS5pc1Nob3duPSExLE49ITEsVj0hMSx0dCgpJiYoJC5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCIpO2lmKHB0KCksdnQoKSxpdCghMCksdHQoKSl7dmFyIG89cnQoKSxhPW8uYm94LHM9by5jb250ZW50O1kucHJvcHMuYW5pbWF0aW9uJiYodyhbYSxzXSxyKSx4KFthLHNdLFwiaGlkZGVuXCIpKX1zdCgpLHV0KCksWS5wcm9wcy5hbmltYXRpb24/dHQoKSYmZnVuY3Rpb24odCxlKXttdCh0LChmdW5jdGlvbigpeyFZLnN0YXRlLmlzVmlzaWJsZSYmJC5wYXJlbnROb2RlJiYkLnBhcmVudE5vZGUuY29udGFpbnMoJCkmJmUoKX0pKX0ocixZLnVubW91bnQpOlkudW5tb3VudCgpfSxoaWRlV2l0aEludGVyYWN0aXZpdHk6ZnVuY3Rpb24odCl7bnQoKS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsRiksZihVLEYpLEYodCl9LGVuYWJsZTpmdW5jdGlvbigpe1kuc3RhdGUuaXNFbmFibGVkPSEwfSxkaXNhYmxlOmZ1bmN0aW9uKCl7WS5oaWRlKCksWS5zdGF0ZS5pc0VuYWJsZWQ9ITF9LHVubW91bnQ6ZnVuY3Rpb24oKXtZLnN0YXRlLmlzVmlzaWJsZSYmWS5oaWRlKCk7aWYoIVkuc3RhdGUuaXNNb3VudGVkKXJldHVybjtUdCgpLEF0KCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5fdGlwcHkudW5tb3VudCgpfSkpLCQucGFyZW50Tm9kZSYmJC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCQpO189Xy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0IT09WX0pKSxZLnN0YXRlLmlzTW91bnRlZD0hMSxhdChcIm9uSGlkZGVuXCIsW1ldKX0sZGVzdHJveTpmdW5jdGlvbigpe2lmKFkuc3RhdGUuaXNEZXN0cm95ZWQpcmV0dXJuO1kuY2xlYXJEZWxheVRpbWVvdXRzKCksWS51bm1vdW50KCksYnQoKSxkZWxldGUgZS5fdGlwcHksWS5zdGF0ZS5pc0Rlc3Ryb3llZD0hMCxhdChcIm9uRGVzdHJveVwiLFtZXSl9fTtpZighUC5yZW5kZXIpcmV0dXJuIFk7dmFyIHE9UC5yZW5kZXIoWSksJD1xLnBvcHBlcixKPXEub25VcGRhdGU7JC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRpcHB5LXJvb3RcIixcIlwiKSwkLmlkPVwidGlwcHktXCIrWS5pZCxZLnBvcHBlcj0kLGUuX3RpcHB5PVksJC5fdGlwcHk9WTt2YXIgRz1YLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuZm4oWSl9KSksSz1lLmhhc0F0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIik7cmV0dXJuIGh0KCksdXQoKSxpdCgpLGF0KFwib25DcmVhdGVcIixbWV0pLFAuc2hvd09uQ3JlYXRlJiZMdCgpLCQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwoZnVuY3Rpb24oKXtZLnByb3BzLmludGVyYWN0aXZlJiZZLnN0YXRlLmlzVmlzaWJsZSYmWS5jbGVhckRlbGF5VGltZW91dHMoKX0pKSwkLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsKGZ1bmN0aW9uKCl7WS5wcm9wcy5pbnRlcmFjdGl2ZSYmWS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoXCJtb3VzZWVudGVyXCIpPj0wJiZudCgpLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixGKX0pKSxZO2Z1bmN0aW9uIFEoKXt2YXIgdD1ZLnByb3BzLnRvdWNoO3JldHVybiBBcnJheS5pc0FycmF5KHQpP3Q6W3QsMF19ZnVuY3Rpb24gWigpe3JldHVyblwiaG9sZFwiPT09USgpWzBdfWZ1bmN0aW9uIHR0KCl7dmFyIHQ7cmV0dXJuIShudWxsPT0odD1ZLnByb3BzLnJlbmRlcil8fCF0LiQkdGlwcHkpfWZ1bmN0aW9uIGV0KCl7cmV0dXJuIER8fGV9ZnVuY3Rpb24gbnQoKXt2YXIgdD1ldCgpLnBhcmVudE5vZGU7cmV0dXJuIHQ/RSh0KTpkb2N1bWVudH1mdW5jdGlvbiBydCgpe3JldHVybiBCKCQpfWZ1bmN0aW9uIG90KHQpe3JldHVybiBZLnN0YXRlLmlzTW91bnRlZCYmIVkuc3RhdGUuaXNWaXNpYmxlfHxULmlzVG91Y2h8fHkmJlwiZm9jdXNcIj09PXkudHlwZT8wOmkoWS5wcm9wcy5kZWxheSx0PzA6MSxSLmRlbGF5KX1mdW5jdGlvbiBpdCh0KXt2b2lkIDA9PT10JiYodD0hMSksJC5zdHlsZS5wb2ludGVyRXZlbnRzPVkucHJvcHMuaW50ZXJhY3RpdmUmJiF0P1wiXCI6XCJub25lXCIsJC5zdHlsZS56SW5kZXg9XCJcIitZLnByb3BzLnpJbmRleH1mdW5jdGlvbiBhdCh0LGUsbil7dmFyIHI7KHZvaWQgMD09PW4mJihuPSEwKSxHLmZvckVhY2goKGZ1bmN0aW9uKG4pe25bdF0mJm5bdF0uYXBwbHkobixlKX0pKSxuKSYmKHI9WS5wcm9wcylbdF0uYXBwbHkocixlKX1mdW5jdGlvbiBzdCgpe3ZhciB0PVkucHJvcHMuYXJpYTtpZih0LmNvbnRlbnQpe3ZhciBuPVwiYXJpYS1cIit0LmNvbnRlbnQscj0kLmlkO2MoWS5wcm9wcy50cmlnZ2VyVGFyZ2V0fHxlKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT10LmdldEF0dHJpYnV0ZShuKTtpZihZLnN0YXRlLmlzVmlzaWJsZSl0LnNldEF0dHJpYnV0ZShuLGU/ZStcIiBcIityOnIpO2Vsc2V7dmFyIG89ZSYmZS5yZXBsYWNlKHIsXCJcIikudHJpbSgpO28/dC5zZXRBdHRyaWJ1dGUobixvKTp0LnJlbW92ZUF0dHJpYnV0ZShuKX19KSl9fWZ1bmN0aW9uIHV0KCl7IUsmJlkucHJvcHMuYXJpYS5leHBhbmRlZCYmYyhZLnByb3BzLnRyaWdnZXJUYXJnZXR8fGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe1kucHJvcHMuaW50ZXJhY3RpdmU/dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsWS5zdGF0ZS5pc1Zpc2libGUmJnQ9PT1ldCgpP1widHJ1ZVwiOlwiZmFsc2VcIik6dC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIpfSkpfWZ1bmN0aW9uIHB0KCl7bnQoKS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsRiksVT1VLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQhPT1GfSkpfWZ1bmN0aW9uIGN0KHQpe2lmKCFULmlzVG91Y2h8fCFTJiZcIm1vdXNlZG93blwiIT09dC50eXBlKXt2YXIgbj10LmNvbXBvc2VkUGF0aCYmdC5jb21wb3NlZFBhdGgoKVswXXx8dC50YXJnZXQ7aWYoIVkucHJvcHMuaW50ZXJhY3RpdmV8fCFDKCQsbikpe2lmKGMoWS5wcm9wcy50cmlnZ2VyVGFyZ2V0fHxlKS5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gQyh0LG4pfSkpKXtpZihULmlzVG91Y2gpcmV0dXJuO2lmKFkuc3RhdGUuaXNWaXNpYmxlJiZZLnByb3BzLnRyaWdnZXIuaW5kZXhPZihcImNsaWNrXCIpPj0wKXJldHVybn1lbHNlIGF0KFwib25DbGlja091dHNpZGVcIixbWSx0XSk7ITA9PT1ZLnByb3BzLmhpZGVPbkNsaWNrJiYoWS5jbGVhckRlbGF5VGltZW91dHMoKSxZLmhpZGUoKSxJPSEwLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ST0hMX0pKSxZLnN0YXRlLmlzTW91bnRlZHx8dnQoKSl9fX1mdW5jdGlvbiBmdCgpe1M9ITB9ZnVuY3Rpb24gbHQoKXtTPSExfWZ1bmN0aW9uIGR0KCl7dmFyIHQ9bnQoKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixjdCwhMCksdC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIixjdCxyKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsbHQsciksdC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsZnQscil9ZnVuY3Rpb24gdnQoKXt2YXIgdD1udCgpO3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGN0LCEwKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLGN0LHIpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIixsdCxyKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIixmdCxyKX1mdW5jdGlvbiBtdCh0LGUpe3ZhciBuPXJ0KCkuYm94O2Z1bmN0aW9uIHIodCl7dC50YXJnZXQ9PT1uJiYoTyhuLFwicmVtb3ZlXCIsciksZSgpKX1pZigwPT09dClyZXR1cm4gZSgpO08obixcInJlbW92ZVwiLEEpLE8obixcImFkZFwiLHIpLEE9cn1mdW5jdGlvbiBndCh0LG4scil7dm9pZCAwPT09ciYmKHI9ITEpLGMoWS5wcm9wcy50cmlnZ2VyVGFyZ2V0fHxlKS5mb3JFYWNoKChmdW5jdGlvbihlKXtlLmFkZEV2ZW50TGlzdGVuZXIodCxuLHIpLHoucHVzaCh7bm9kZTplLGV2ZW50VHlwZTp0LGhhbmRsZXI6bixvcHRpb25zOnJ9KX0pKX1mdW5jdGlvbiBodCgpe3ZhciB0O1ooKSYmKGd0KFwidG91Y2hzdGFydFwiLHl0LHtwYXNzaXZlOiEwfSksZ3QoXCJ0b3VjaGVuZFwiLHh0LHtwYXNzaXZlOiEwfSkpLCh0PVkucHJvcHMudHJpZ2dlcix0LnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pKS5mb3JFYWNoKChmdW5jdGlvbih0KXtpZihcIm1hbnVhbFwiIT09dClzd2l0Y2goZ3QodCx5dCksdCl7Y2FzZVwibW91c2VlbnRlclwiOmd0KFwibW91c2VsZWF2ZVwiLHh0KTticmVhaztjYXNlXCJmb2N1c1wiOmd0KG4/XCJmb2N1c291dFwiOlwiYmx1clwiLEV0KTticmVhaztjYXNlXCJmb2N1c2luXCI6Z3QoXCJmb2N1c291dFwiLEV0KX19KSl9ZnVuY3Rpb24gYnQoKXt6LmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPXQubm9kZSxuPXQuZXZlbnRUeXBlLHI9dC5oYW5kbGVyLG89dC5vcHRpb25zO2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihuLHIsbyl9KSksej1bXX1mdW5jdGlvbiB5dCh0KXt2YXIgZSxuPSExO2lmKFkuc3RhdGUuaXNFbmFibGVkJiYhT3QodCkmJiFJKXt2YXIgcj1cImZvY3VzXCI9PT0obnVsbD09KGU9eSk/dm9pZCAwOmUudHlwZSk7eT10LEQ9dC5jdXJyZW50VGFyZ2V0LHV0KCksIVkuc3RhdGUuaXNWaXNpYmxlJiZoKHQpJiZVLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlKHQpfSkpLFwiY2xpY2tcIj09PXQudHlwZSYmKFkucHJvcHMudHJpZ2dlci5pbmRleE9mKFwibW91c2VlbnRlclwiKTwwfHxWKSYmITEhPT1ZLnByb3BzLmhpZGVPbkNsaWNrJiZZLnN0YXRlLmlzVmlzaWJsZT9uPSEwOkx0KHQpLFwiY2xpY2tcIj09PXQudHlwZSYmKFY9IW4pLG4mJiFyJiZEdCh0KX19ZnVuY3Rpb24gd3QodCl7dmFyIGU9dC50YXJnZXQsbj1ldCgpLmNvbnRhaW5zKGUpfHwkLmNvbnRhaW5zKGUpO1wibW91c2Vtb3ZlXCI9PT10LnR5cGUmJm58fGZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5jbGllbnRYLHI9ZS5jbGllbnRZO3JldHVybiB0LmV2ZXJ5KChmdW5jdGlvbih0KXt2YXIgZT10LnBvcHBlclJlY3Qsbz10LnBvcHBlclN0YXRlLGk9dC5wcm9wcy5pbnRlcmFjdGl2ZUJvcmRlcixhPWwoby5wbGFjZW1lbnQpLHM9by5tb2RpZmllcnNEYXRhLm9mZnNldDtpZighcylyZXR1cm4hMDt2YXIgdT1cImJvdHRvbVwiPT09YT9zLnRvcC55OjAscD1cInRvcFwiPT09YT9zLmJvdHRvbS55OjAsYz1cInJpZ2h0XCI9PT1hP3MubGVmdC54OjAsZj1cImxlZnRcIj09PWE/cy5yaWdodC54OjAsZD1lLnRvcC1yK3U+aSx2PXItZS5ib3R0b20tcD5pLG09ZS5sZWZ0LW4rYz5pLGc9bi1lLnJpZ2h0LWY+aTtyZXR1cm4gZHx8dnx8bXx8Z30pKX0oQXQoKS5jb25jYXQoJCkubWFwKChmdW5jdGlvbih0KXt2YXIgZSxuPW51bGw9PShlPXQuX3RpcHB5LnBvcHBlckluc3RhbmNlKT92b2lkIDA6ZS5zdGF0ZTtyZXR1cm4gbj97cG9wcGVyUmVjdDp0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHBvcHBlclN0YXRlOm4scHJvcHM6UH06bnVsbH0pKS5maWx0ZXIoQm9vbGVhbiksdCkmJihwdCgpLER0KHQpKX1mdW5jdGlvbiB4dCh0KXtPdCh0KXx8WS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoXCJjbGlja1wiKT49MCYmVnx8KFkucHJvcHMuaW50ZXJhY3RpdmU/WS5oaWRlV2l0aEludGVyYWN0aXZpdHkodCk6RHQodCkpfWZ1bmN0aW9uIEV0KHQpe1kucHJvcHMudHJpZ2dlci5pbmRleE9mKFwiZm9jdXNpblwiKTwwJiZ0LnRhcmdldCE9PWV0KCl8fFkucHJvcHMuaW50ZXJhY3RpdmUmJnQucmVsYXRlZFRhcmdldCYmJC5jb250YWlucyh0LnJlbGF0ZWRUYXJnZXQpfHxEdCh0KX1mdW5jdGlvbiBPdCh0KXtyZXR1cm4hIVQuaXNUb3VjaCYmWigpIT09dC50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKT49MH1mdW5jdGlvbiBDdCgpe1R0KCk7dmFyIG49WS5wcm9wcyxyPW4ucG9wcGVyT3B0aW9ucyxvPW4ucGxhY2VtZW50LGk9bi5vZmZzZXQsYT1uLmdldFJlZmVyZW5jZUNsaWVudFJlY3Qscz1uLm1vdmVUcmFuc2l0aW9uLHU9dHQoKT9CKCQpLmFycm93Om51bGwscD1hP3tnZXRCb3VuZGluZ0NsaWVudFJlY3Q6YSxjb250ZXh0RWxlbWVudDphLmNvbnRleHRFbGVtZW50fHxldCgpfTplLGM9W3tuYW1lOlwib2Zmc2V0XCIsb3B0aW9uczp7b2Zmc2V0Oml9fSx7bmFtZTpcInByZXZlbnRPdmVyZmxvd1wiLG9wdGlvbnM6e3BhZGRpbmc6e3RvcDoyLGJvdHRvbToyLGxlZnQ6NSxyaWdodDo1fX19LHtuYW1lOlwiZmxpcFwiLG9wdGlvbnM6e3BhZGRpbmc6NX19LHtuYW1lOlwiY29tcHV0ZVN0eWxlc1wiLG9wdGlvbnM6e2FkYXB0aXZlOiFzfX0se25hbWU6XCIkJHRpcHB5XCIsZW5hYmxlZDohMCxwaGFzZTpcImJlZm9yZVdyaXRlXCIscmVxdWlyZXM6W1wiY29tcHV0ZVN0eWxlc1wiXSxmbjpmdW5jdGlvbih0KXt2YXIgZT10LnN0YXRlO2lmKHR0KCkpe3ZhciBuPXJ0KCkuYm94O1tcInBsYWNlbWVudFwiLFwicmVmZXJlbmNlLWhpZGRlblwiLFwiZXNjYXBlZFwiXS5mb3JFYWNoKChmdW5jdGlvbih0KXtcInBsYWNlbWVudFwiPT09dD9uLnNldEF0dHJpYnV0ZShcImRhdGEtcGxhY2VtZW50XCIsZS5wbGFjZW1lbnQpOmUuYXR0cmlidXRlcy5wb3BwZXJbXCJkYXRhLXBvcHBlci1cIit0XT9uLnNldEF0dHJpYnV0ZShcImRhdGEtXCIrdCxcIlwiKTpuLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtXCIrdCl9KSksZS5hdHRyaWJ1dGVzLnBvcHBlcj17fX19fV07dHQoKSYmdSYmYy5wdXNoKHtuYW1lOlwiYXJyb3dcIixvcHRpb25zOntlbGVtZW50OnUscGFkZGluZzozfX0pLGMucHVzaC5hcHBseShjLChudWxsPT1yP3ZvaWQgMDpyLm1vZGlmaWVycyl8fFtdKSxZLnBvcHBlckluc3RhbmNlPXQuY3JlYXRlUG9wcGVyKHAsJCxPYmplY3QuYXNzaWduKHt9LHIse3BsYWNlbWVudDpvLG9uRmlyc3RVcGRhdGU6TCxtb2RpZmllcnM6Y30pKX1mdW5jdGlvbiBUdCgpe1kucG9wcGVySW5zdGFuY2UmJihZLnBvcHBlckluc3RhbmNlLmRlc3Ryb3koKSxZLnBvcHBlckluc3RhbmNlPW51bGwpfWZ1bmN0aW9uIEF0KCl7cmV0dXJuIGQoJC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtdGlwcHktcm9vdF1cIikpfWZ1bmN0aW9uIEx0KHQpe1kuY2xlYXJEZWxheVRpbWVvdXRzKCksdCYmYXQoXCJvblRyaWdnZXJcIixbWSx0XSksZHQoKTt2YXIgZT1vdCghMCksbj1RKCkscj1uWzBdLG89blsxXTtULmlzVG91Y2gmJlwiaG9sZFwiPT09ciYmbyYmKGU9byksZT9wPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7WS5zaG93KCl9KSxlKTpZLnNob3coKX1mdW5jdGlvbiBEdCh0KXtpZihZLmNsZWFyRGVsYXlUaW1lb3V0cygpLGF0KFwib25VbnRyaWdnZXJcIixbWSx0XSksWS5zdGF0ZS5pc1Zpc2libGUpe2lmKCEoWS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoXCJtb3VzZWVudGVyXCIpPj0wJiZZLnByb3BzLnRyaWdnZXIuaW5kZXhPZihcImNsaWNrXCIpPj0wJiZbXCJtb3VzZWxlYXZlXCIsXCJtb3VzZW1vdmVcIl0uaW5kZXhPZih0LnR5cGUpPj0wJiZWKSl7dmFyIGU9b3QoITEpO2U/Zz1zZXRUaW1lb3V0KChmdW5jdGlvbigpe1kuc3RhdGUuaXNWaXNpYmxlJiZZLmhpZGUoKX0pLGUpOmI9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKChmdW5jdGlvbigpe1kuaGlkZSgpfSkpfX1lbHNlIHZ0KCl9fWZ1bmN0aW9uIEYodCxlKXt2b2lkIDA9PT1lJiYoZT17fSk7dmFyIG49Ui5wbHVnaW5zLmNvbmNhdChlLnBsdWdpbnN8fFtdKTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLEwsciksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsayk7dmFyIG89T2JqZWN0LmFzc2lnbih7fSxlLHtwbHVnaW5zOm59KSxpPXkodCkucmVkdWNlKChmdW5jdGlvbih0LGUpe3ZhciBuPWUmJnooZSxvKTtyZXR1cm4gbiYmdC5wdXNoKG4pLHR9KSxbXSk7cmV0dXJuIGcodCk/aVswXTppfUYuZGVmYXVsdFByb3BzPVIsRi5zZXREZWZhdWx0UHJvcHM9ZnVuY3Rpb24odCl7T2JqZWN0LmtleXModCkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7UltlXT10W2VdfSkpfSxGLmN1cnJlbnRJbnB1dD1UO3ZhciBXPU9iamVjdC5hc3NpZ24oe30sdC5hcHBseVN0eWxlcyx7ZWZmZWN0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGUsbj17cG9wcGVyOntwb3NpdGlvbjplLm9wdGlvbnMuc3RyYXRlZ3ksbGVmdDpcIjBcIix0b3A6XCIwXCIsbWFyZ2luOlwiMFwifSxhcnJvdzp7cG9zaXRpb246XCJhYnNvbHV0ZVwifSxyZWZlcmVuY2U6e319O09iamVjdC5hc3NpZ24oZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsbi5wb3BwZXIpLGUuc3R5bGVzPW4sZS5lbGVtZW50cy5hcnJvdyYmT2JqZWN0LmFzc2lnbihlLmVsZW1lbnRzLmFycm93LnN0eWxlLG4uYXJyb3cpfX0pLFg9e21vdXNlb3ZlcjpcIm1vdXNlZW50ZXJcIixmb2N1c2luOlwiZm9jdXNcIixjbGljazpcImNsaWNrXCJ9O3ZhciBZPXtuYW1lOlwiYW5pbWF0ZUZpbGxcIixkZWZhdWx0VmFsdWU6ITEsZm46ZnVuY3Rpb24odCl7dmFyIGU7aWYobnVsbD09KGU9dC5wcm9wcy5yZW5kZXIpfHwhZS4kJHRpcHB5KXJldHVybnt9O3ZhciBuPUIodC5wb3BwZXIpLHI9bi5ib3gsbz1uLmNvbnRlbnQsaT10LnByb3BzLmFuaW1hdGVGaWxsP2Z1bmN0aW9uKCl7dmFyIHQ9bSgpO3JldHVybiB0LmNsYXNzTmFtZT1cInRpcHB5LWJhY2tkcm9wXCIseChbdF0sXCJoaWRkZW5cIiksdH0oKTpudWxsO3JldHVybntvbkNyZWF0ZTpmdW5jdGlvbigpe2kmJihyLmluc2VydEJlZm9yZShpLHIuZmlyc3RFbGVtZW50Q2hpbGQpLHIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbmltYXRlZmlsbFwiLFwiXCIpLHIuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIix0LnNldFByb3BzKHthcnJvdzohMSxhbmltYXRpb246XCJzaGlmdC1hd2F5XCJ9KSl9LG9uTW91bnQ6ZnVuY3Rpb24oKXtpZihpKXt2YXIgdD1yLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbixlPU51bWJlcih0LnJlcGxhY2UoXCJtc1wiLFwiXCIpKTtvLnN0eWxlLnRyYW5zaXRpb25EZWxheT1NYXRoLnJvdW5kKGUvMTApK1wibXNcIixpLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbj10LHgoW2ldLFwidmlzaWJsZVwiKX19LG9uU2hvdzpmdW5jdGlvbigpe2kmJihpLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbj1cIjBtc1wiKX0sb25IaWRlOmZ1bmN0aW9uKCl7aSYmeChbaV0sXCJoaWRkZW5cIil9fX19O3ZhciBxPXtjbGllbnRYOjAsY2xpZW50WTowfSwkPVtdO2Z1bmN0aW9uIEoodCl7dmFyIGU9dC5jbGllbnRYLG49dC5jbGllbnRZO3E9e2NsaWVudFg6ZSxjbGllbnRZOm59fXZhciBHPXtuYW1lOlwiZm9sbG93Q3Vyc29yXCIsZGVmYXVsdFZhbHVlOiExLGZuOmZ1bmN0aW9uKHQpe3ZhciBlPXQucmVmZXJlbmNlLG49RSh0LnByb3BzLnRyaWdnZXJUYXJnZXR8fGUpLHI9ITEsbz0hMSxpPSEwLGE9dC5wcm9wcztmdW5jdGlvbiBzKCl7cmV0dXJuXCJpbml0aWFsXCI9PT10LnByb3BzLmZvbGxvd0N1cnNvciYmdC5zdGF0ZS5pc1Zpc2libGV9ZnVuY3Rpb24gdSgpe24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLGYpfWZ1bmN0aW9uIHAoKXtuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixmKX1mdW5jdGlvbiBjKCl7cj0hMCx0LnNldFByb3BzKHtnZXRSZWZlcmVuY2VDbGllbnRSZWN0Om51bGx9KSxyPSExfWZ1bmN0aW9uIGYobil7dmFyIHI9IW4udGFyZ2V0fHxlLmNvbnRhaW5zKG4udGFyZ2V0KSxvPXQucHJvcHMuZm9sbG93Q3Vyc29yLGk9bi5jbGllbnRYLGE9bi5jbGllbnRZLHM9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx1PWktcy5sZWZ0LHA9YS1zLnRvcDshciYmdC5wcm9wcy5pbnRlcmFjdGl2ZXx8dC5zZXRQcm9wcyh7Z2V0UmVmZXJlbmNlQ2xpZW50UmVjdDpmdW5jdGlvbigpe3ZhciB0PWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbj1pLHI9YTtcImluaXRpYWxcIj09PW8mJihuPXQubGVmdCt1LHI9dC50b3ArcCk7dmFyIHM9XCJob3Jpem9udGFsXCI9PT1vP3QudG9wOnIsYz1cInZlcnRpY2FsXCI9PT1vP3QucmlnaHQ6bixmPVwiaG9yaXpvbnRhbFwiPT09bz90LmJvdHRvbTpyLGw9XCJ2ZXJ0aWNhbFwiPT09bz90LmxlZnQ6bjtyZXR1cm57d2lkdGg6Yy1sLGhlaWdodDpmLXMsdG9wOnMscmlnaHQ6Yyxib3R0b206ZixsZWZ0Omx9fX0pfWZ1bmN0aW9uIGwoKXt0LnByb3BzLmZvbGxvd0N1cnNvciYmKCQucHVzaCh7aW5zdGFuY2U6dCxkb2M6bn0pLGZ1bmN0aW9uKHQpe3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLEopfShuKSl9ZnVuY3Rpb24gZCgpezA9PT0oJD0kLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaW5zdGFuY2UhPT10fSkpKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRvYz09PW59KSkubGVuZ3RoJiZmdW5jdGlvbih0KXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixKKX0obil9cmV0dXJue29uQ3JlYXRlOmwsb25EZXN0cm95OmQsb25CZWZvcmVVcGRhdGU6ZnVuY3Rpb24oKXthPXQucHJvcHN9LG9uQWZ0ZXJVcGRhdGU6ZnVuY3Rpb24oZSxuKXt2YXIgaT1uLmZvbGxvd0N1cnNvcjtyfHx2b2lkIDAhPT1pJiZhLmZvbGxvd0N1cnNvciE9PWkmJihkKCksaT8obCgpLCF0LnN0YXRlLmlzTW91bnRlZHx8b3x8cygpfHx1KCkpOihwKCksYygpKSl9LG9uTW91bnQ6ZnVuY3Rpb24oKXt0LnByb3BzLmZvbGxvd0N1cnNvciYmIW8mJihpJiYoZihxKSxpPSExKSxzKCl8fHUoKSl9LG9uVHJpZ2dlcjpmdW5jdGlvbih0LGUpe2goZSkmJihxPXtjbGllbnRYOmUuY2xpZW50WCxjbGllbnRZOmUuY2xpZW50WX0pLG89XCJmb2N1c1wiPT09ZS50eXBlfSxvbkhpZGRlbjpmdW5jdGlvbigpe3QucHJvcHMuZm9sbG93Q3Vyc29yJiYoYygpLHAoKSxpPSEwKX19fX07dmFyIEs9e25hbWU6XCJpbmxpbmVQb3NpdGlvbmluZ1wiLGRlZmF1bHRWYWx1ZTohMSxmbjpmdW5jdGlvbih0KXt2YXIgZSxuPXQucmVmZXJlbmNlO3ZhciByPS0xLG89ITEsaT1bXSxhPXtuYW1lOlwidGlwcHlJbmxpbmVQb3NpdGlvbmluZ1wiLGVuYWJsZWQ6ITAscGhhc2U6XCJhZnRlcldyaXRlXCIsZm46ZnVuY3Rpb24obyl7dmFyIGE9by5zdGF0ZTt0LnByb3BzLmlubGluZVBvc2l0aW9uaW5nJiYoLTEhPT1pLmluZGV4T2YoYS5wbGFjZW1lbnQpJiYoaT1bXSksZSE9PWEucGxhY2VtZW50JiYtMT09PWkuaW5kZXhPZihhLnBsYWNlbWVudCkmJihpLnB1c2goYS5wbGFjZW1lbnQpLHQuc2V0UHJvcHMoe2dldFJlZmVyZW5jZUNsaWVudFJlY3Q6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe2lmKG4ubGVuZ3RoPDJ8fG51bGw9PT10KXJldHVybiBlO2lmKDI9PT1uLmxlbmd0aCYmcj49MCYmblswXS5sZWZ0Pm5bMV0ucmlnaHQpcmV0dXJuIG5bcl18fGU7c3dpdGNoKHQpe2Nhc2VcInRvcFwiOmNhc2VcImJvdHRvbVwiOnZhciBvPW5bMF0saT1uW24ubGVuZ3RoLTFdLGE9XCJ0b3BcIj09PXQscz1vLnRvcCx1PWkuYm90dG9tLHA9YT9vLmxlZnQ6aS5sZWZ0LGM9YT9vLnJpZ2h0OmkucmlnaHQ7cmV0dXJue3RvcDpzLGJvdHRvbTp1LGxlZnQ6cCxyaWdodDpjLHdpZHRoOmMtcCxoZWlnaHQ6dS1zfTtjYXNlXCJsZWZ0XCI6Y2FzZVwicmlnaHRcIjp2YXIgZj1NYXRoLm1pbi5hcHBseShNYXRoLG4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5sZWZ0fSkpKSxsPU1hdGgubWF4LmFwcGx5KE1hdGgsbi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJpZ2h0fSkpKSxkPW4uZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm5cImxlZnRcIj09PXQ/ZS5sZWZ0PT09ZjplLnJpZ2h0PT09bH0pKSx2PWRbMF0udG9wLG09ZFtkLmxlbmd0aC0xXS5ib3R0b207cmV0dXJue3RvcDp2LGJvdHRvbTptLGxlZnQ6ZixyaWdodDpsLHdpZHRoOmwtZixoZWlnaHQ6bS12fTtkZWZhdWx0OnJldHVybiBlfX0obCh0KSxuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGQobi5nZXRDbGllbnRSZWN0cygpKSxyKX0oYS5wbGFjZW1lbnQpfX0pKSxlPWEucGxhY2VtZW50KX19O2Z1bmN0aW9uIHMoKXt2YXIgZTtvfHwoZT1mdW5jdGlvbih0LGUpe3ZhciBuO3JldHVybntwb3BwZXJPcHRpb25zOk9iamVjdC5hc3NpZ24oe30sdC5wb3BwZXJPcHRpb25zLHttb2RpZmllcnM6W10uY29uY2F0KCgobnVsbD09KG49dC5wb3BwZXJPcHRpb25zKT92b2lkIDA6bi5tb2RpZmllcnMpfHxbXSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lIT09ZS5uYW1lfSkpLFtlXSl9KX19KHQucHJvcHMsYSksbz0hMCx0LnNldFByb3BzKGUpLG89ITEpfXJldHVybntvbkNyZWF0ZTpzLG9uQWZ0ZXJVcGRhdGU6cyxvblRyaWdnZXI6ZnVuY3Rpb24oZSxuKXtpZihoKG4pKXt2YXIgbz1kKHQucmVmZXJlbmNlLmdldENsaWVudFJlY3RzKCkpLGk9by5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC5sZWZ0LTI8PW4uY2xpZW50WCYmdC5yaWdodCsyPj1uLmNsaWVudFgmJnQudG9wLTI8PW4uY2xpZW50WSYmdC5ib3R0b20rMj49bi5jbGllbnRZfSkpLGE9by5pbmRleE9mKGkpO3I9YT4tMT9hOnJ9fSxvbkhpZGRlbjpmdW5jdGlvbigpe3I9LTF9fX19O3ZhciBRPXtuYW1lOlwic3RpY2t5XCIsZGVmYXVsdFZhbHVlOiExLGZuOmZ1bmN0aW9uKHQpe3ZhciBlPXQucmVmZXJlbmNlLG49dC5wb3BwZXI7ZnVuY3Rpb24gcihlKXtyZXR1cm4hMD09PXQucHJvcHMuc3RpY2t5fHx0LnByb3BzLnN0aWNreT09PWV9dmFyIG89bnVsbCxpPW51bGw7ZnVuY3Rpb24gYSgpe3ZhciBzPXIoXCJyZWZlcmVuY2VcIik/KHQucG9wcGVySW5zdGFuY2U/dC5wb3BwZXJJbnN0YW5jZS5zdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2U6ZSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk6bnVsbCx1PXIoXCJwb3BwZXJcIik/bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTpudWxsOyhzJiZaKG8scyl8fHUmJlooaSx1KSkmJnQucG9wcGVySW5zdGFuY2UmJnQucG9wcGVySW5zdGFuY2UudXBkYXRlKCksbz1zLGk9dSx0LnN0YXRlLmlzTW91bnRlZCYmcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGEpfXJldHVybntvbk1vdW50OmZ1bmN0aW9uKCl7dC5wcm9wcy5zdGlja3kmJmEoKX19fX07ZnVuY3Rpb24gWih0LGUpe3JldHVybiF0fHwhZXx8KHQudG9wIT09ZS50b3B8fHQucmlnaHQhPT1lLnJpZ2h0fHx0LmJvdHRvbSE9PWUuYm90dG9tfHx0LmxlZnQhPT1lLmxlZnQpfXJldHVybiBlJiZmdW5jdGlvbih0KXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7ZS50ZXh0Q29udGVudD10LGUuc2V0QXR0cmlidXRlKFwiZGF0YS10aXBweS1zdHlsZXNoZWV0XCIsXCJcIik7dmFyIG49ZG9jdW1lbnQuaGVhZCxyPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJoZWFkPnN0eWxlLGhlYWQ+bGlua1wiKTtyP24uaW5zZXJ0QmVmb3JlKGUscik6bi5hcHBlbmRDaGlsZChlKX0oJy50aXBweS1ib3hbZGF0YS1hbmltYXRpb249ZmFkZV1bZGF0YS1zdGF0ZT1oaWRkZW5de29wYWNpdHk6MH1bZGF0YS10aXBweS1yb290XXttYXgtd2lkdGg6Y2FsYygxMDB2dyAtIDEwcHgpfS50aXBweS1ib3h7cG9zaXRpb246cmVsYXRpdmU7YmFja2dyb3VuZC1jb2xvcjojMzMzO2NvbG9yOiNmZmY7Ym9yZGVyLXJhZGl1czo0cHg7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS40O3doaXRlLXNwYWNlOm5vcm1hbDtvdXRsaW5lOjA7dHJhbnNpdGlvbi1wcm9wZXJ0eTp0cmFuc2Zvcm0sdmlzaWJpbGl0eSxvcGFjaXR5fS50aXBweS1ib3hbZGF0YS1wbGFjZW1lbnRePXRvcF0+LnRpcHB5LWFycm93e2JvdHRvbTowfS50aXBweS1ib3hbZGF0YS1wbGFjZW1lbnRePXRvcF0+LnRpcHB5LWFycm93OmJlZm9yZXtib3R0b206LTdweDtsZWZ0OjA7Ym9yZGVyLXdpZHRoOjhweCA4cHggMDtib3JkZXItdG9wLWNvbG9yOmluaXRpYWw7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgdG9wfS50aXBweS1ib3hbZGF0YS1wbGFjZW1lbnRePWJvdHRvbV0+LnRpcHB5LWFycm93e3RvcDowfS50aXBweS1ib3hbZGF0YS1wbGFjZW1lbnRePWJvdHRvbV0+LnRpcHB5LWFycm93OmJlZm9yZXt0b3A6LTdweDtsZWZ0OjA7Ym9yZGVyLXdpZHRoOjAgOHB4IDhweDtib3JkZXItYm90dG9tLWNvbG9yOmluaXRpYWw7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgYm90dG9tfS50aXBweS1ib3hbZGF0YS1wbGFjZW1lbnRePWxlZnRdPi50aXBweS1hcnJvd3tyaWdodDowfS50aXBweS1ib3hbZGF0YS1wbGFjZW1lbnRePWxlZnRdPi50aXBweS1hcnJvdzpiZWZvcmV7Ym9yZGVyLXdpZHRoOjhweCAwIDhweCA4cHg7Ym9yZGVyLWxlZnQtY29sb3I6aW5pdGlhbDtyaWdodDotN3B4O3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyIGxlZnR9LnRpcHB5LWJveFtkYXRhLXBsYWNlbWVudF49cmlnaHRdPi50aXBweS1hcnJvd3tsZWZ0OjB9LnRpcHB5LWJveFtkYXRhLXBsYWNlbWVudF49cmlnaHRdPi50aXBweS1hcnJvdzpiZWZvcmV7bGVmdDotN3B4O2JvcmRlci13aWR0aDo4cHggOHB4IDhweCAwO2JvcmRlci1yaWdodC1jb2xvcjppbml0aWFsO3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyIHJpZ2h0fS50aXBweS1ib3hbZGF0YS1pbmVydGlhXVtkYXRhLXN0YXRlPXZpc2libGVde3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguNTQsMS41LC4zOCwxLjExKX0udGlwcHktYXJyb3d7d2lkdGg6MTZweDtoZWlnaHQ6MTZweDtjb2xvcjojMzMzfS50aXBweS1hcnJvdzpiZWZvcmV7Y29udGVudDpcIlwiO3Bvc2l0aW9uOmFic29sdXRlO2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItc3R5bGU6c29saWR9LnRpcHB5LWNvbnRlbnR7cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZzo1cHggOXB4O3otaW5kZXg6MX0nKSxGLnNldERlZmF1bHRQcm9wcyh7cGx1Z2luczpbWSxHLEssUV0scmVuZGVyOk59KSxGLmNyZWF0ZVNpbmdsZXRvbj1mdW5jdGlvbih0LGUpe3ZhciBuO3ZvaWQgMD09PWUmJihlPXt9KTt2YXIgcixvPXQsaT1bXSxhPVtdLHM9ZS5vdmVycmlkZXMsdT1bXSxmPSExO2Z1bmN0aW9uIGwoKXthPW8ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gYyh0LnByb3BzLnRyaWdnZXJUYXJnZXR8fHQucmVmZXJlbmNlKX0pKS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuY29uY2F0KGUpfSksW10pfWZ1bmN0aW9uIGQoKXtpPW8ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWZlcmVuY2V9KSl9ZnVuY3Rpb24gdih0KXtvLmZvckVhY2goKGZ1bmN0aW9uKGUpe3Q/ZS5lbmFibGUoKTplLmRpc2FibGUoKX0pKX1mdW5jdGlvbiBnKHQpe3JldHVybiBvLm1hcCgoZnVuY3Rpb24oZSl7dmFyIG49ZS5zZXRQcm9wcztyZXR1cm4gZS5zZXRQcm9wcz1mdW5jdGlvbihvKXtuKG8pLGUucmVmZXJlbmNlPT09ciYmdC5zZXRQcm9wcyhvKX0sZnVuY3Rpb24oKXtlLnNldFByb3BzPW59fSkpfWZ1bmN0aW9uIGgodCxlKXt2YXIgbj1hLmluZGV4T2YoZSk7aWYoZSE9PXIpe3I9ZTt2YXIgdT0oc3x8W10pLmNvbmNhdChcImNvbnRlbnRcIikucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0W2VdPW9bbl0ucHJvcHNbZV0sdH0pLHt9KTt0LnNldFByb3BzKE9iamVjdC5hc3NpZ24oe30sdSx7Z2V0UmVmZXJlbmNlQ2xpZW50UmVjdDpcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LmdldFJlZmVyZW5jZUNsaWVudFJlY3Q/dS5nZXRSZWZlcmVuY2VDbGllbnRSZWN0OmZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIG51bGw9PSh0PWlbbl0pP3ZvaWQgMDp0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpfX0pKX19dighMSksZCgpLGwoKTt2YXIgYj17Zm46ZnVuY3Rpb24oKXtyZXR1cm57b25EZXN0cm95OmZ1bmN0aW9uKCl7dighMCl9LG9uSGlkZGVuOmZ1bmN0aW9uKCl7cj1udWxsfSxvbkNsaWNrT3V0c2lkZTpmdW5jdGlvbih0KXt0LnByb3BzLnNob3dPbkNyZWF0ZSYmIWYmJihmPSEwLHI9bnVsbCl9LG9uU2hvdzpmdW5jdGlvbih0KXt0LnByb3BzLnNob3dPbkNyZWF0ZSYmIWYmJihmPSEwLGgodCxpWzBdKSl9LG9uVHJpZ2dlcjpmdW5jdGlvbih0LGUpe2godCxlLmN1cnJlbnRUYXJnZXQpfX19fSx5PUYobSgpLE9iamVjdC5hc3NpZ24oe30scChlLFtcIm92ZXJyaWRlc1wiXSkse3BsdWdpbnM6W2JdLmNvbmNhdChlLnBsdWdpbnN8fFtdKSx0cmlnZ2VyVGFyZ2V0OmEscG9wcGVyT3B0aW9uczpPYmplY3QuYXNzaWduKHt9LGUucG9wcGVyT3B0aW9ucyx7bW9kaWZpZXJzOltdLmNvbmNhdCgobnVsbD09KG49ZS5wb3BwZXJPcHRpb25zKT92b2lkIDA6bi5tb2RpZmllcnMpfHxbXSxbV10pfSl9KSksdz15LnNob3c7eS5zaG93PWZ1bmN0aW9uKHQpe2lmKHcoKSwhciYmbnVsbD09dClyZXR1cm4gaCh5LGlbMF0pO2lmKCFyfHxudWxsIT10KXtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gaVt0XSYmaCh5LGlbdF0pO2lmKG8uaW5kZXhPZih0KT49MCl7dmFyIGU9dC5yZWZlcmVuY2U7cmV0dXJuIGgoeSxlKX1yZXR1cm4gaS5pbmRleE9mKHQpPj0wP2goeSx0KTp2b2lkIDB9fSx5LnNob3dOZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9aVswXTtpZighcilyZXR1cm4geS5zaG93KDApO3ZhciBlPWkuaW5kZXhPZihyKTt5LnNob3coaVtlKzFdfHx0KX0seS5zaG93UHJldmlvdXM9ZnVuY3Rpb24oKXt2YXIgdD1pW2kubGVuZ3RoLTFdO2lmKCFyKXJldHVybiB5LnNob3codCk7dmFyIGU9aS5pbmRleE9mKHIpLG49aVtlLTFdfHx0O3kuc2hvdyhuKX07dmFyIHg9eS5zZXRQcm9wcztyZXR1cm4geS5zZXRQcm9wcz1mdW5jdGlvbih0KXtzPXQub3ZlcnJpZGVzfHxzLHgodCl9LHkuc2V0SW5zdGFuY2VzPWZ1bmN0aW9uKHQpe3YoITApLHUuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQoKX0pKSxvPXQsdighMSksZCgpLGwoKSx1PWcoeSkseS5zZXRQcm9wcyh7dHJpZ2dlclRhcmdldDphfSl9LHU9Zyh5KSx5fSxGLmRlbGVnYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIG49W10sbz1bXSxpPSExLGE9ZS50YXJnZXQscz1wKGUsW1widGFyZ2V0XCJdKSx1PU9iamVjdC5hc3NpZ24oe30scyx7dHJpZ2dlcjpcIm1hbnVhbFwiLHRvdWNoOiExfSksZj1PYmplY3QuYXNzaWduKHt0b3VjaDpSLnRvdWNofSxzLHtzaG93T25DcmVhdGU6ITB9KSxsPUYodCx1KTtmdW5jdGlvbiBkKHQpe2lmKHQudGFyZ2V0JiYhaSl7dmFyIG49dC50YXJnZXQuY2xvc2VzdChhKTtpZihuKXt2YXIgcj1uLmdldEF0dHJpYnV0ZShcImRhdGEtdGlwcHktdHJpZ2dlclwiKXx8ZS50cmlnZ2VyfHxSLnRyaWdnZXI7aWYoIW4uX3RpcHB5JiYhKFwidG91Y2hzdGFydFwiPT09dC50eXBlJiZcImJvb2xlYW5cIj09dHlwZW9mIGYudG91Y2h8fFwidG91Y2hzdGFydFwiIT09dC50eXBlJiZyLmluZGV4T2YoWFt0LnR5cGVdKTwwKSl7dmFyIHM9RihuLGYpO3MmJihvPW8uY29uY2F0KHMpKX19fX1mdW5jdGlvbiB2KHQsZSxyLG8pe3ZvaWQgMD09PW8mJihvPSExKSx0LmFkZEV2ZW50TGlzdGVuZXIoZSxyLG8pLG4ucHVzaCh7bm9kZTp0LGV2ZW50VHlwZTplLGhhbmRsZXI6cixvcHRpb25zOm99KX1yZXR1cm4gYyhsKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT10LmRlc3Ryb3ksYT10LmVuYWJsZSxzPXQuZGlzYWJsZTt0LmRlc3Ryb3k9ZnVuY3Rpb24odCl7dm9pZCAwPT09dCYmKHQ9ITApLHQmJm8uZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5kZXN0cm95KCl9KSksbz1bXSxuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPXQubm9kZSxuPXQuZXZlbnRUeXBlLHI9dC5oYW5kbGVyLG89dC5vcHRpb25zO2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihuLHIsbyl9KSksbj1bXSxlKCl9LHQuZW5hYmxlPWZ1bmN0aW9uKCl7YSgpLG8uZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuZW5hYmxlKCl9KSksaT0hMX0sdC5kaXNhYmxlPWZ1bmN0aW9uKCl7cygpLG8uZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGlzYWJsZSgpfSkpLGk9ITB9LGZ1bmN0aW9uKHQpe3ZhciBlPXQucmVmZXJlbmNlO3YoZSxcInRvdWNoc3RhcnRcIixkLHIpLHYoZSxcIm1vdXNlb3ZlclwiLGQpLHYoZSxcImZvY3VzaW5cIixkKSx2KGUsXCJjbGlja1wiLGQpfSh0KX0pKSxsfSxGLmhpZGVBbGw9ZnVuY3Rpb24odCl7dmFyIGU9dm9pZCAwPT09dD97fTp0LG49ZS5leGNsdWRlLHI9ZS5kdXJhdGlvbjtfLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPSExO2lmKG4mJihlPWIobik/dC5yZWZlcmVuY2U9PT1uOnQucG9wcGVyPT09bi5wb3BwZXIpLCFlKXt2YXIgbz10LnByb3BzLmR1cmF0aW9uO3Quc2V0UHJvcHMoe2R1cmF0aW9uOnJ9KSx0LmhpZGUoKSx0LnN0YXRlLmlzRGVzdHJveWVkfHx0LnNldFByb3BzKHtkdXJhdGlvbjpvfSl9fSkpfSxGLnJvdW5kQXJyb3c9Jzxzdmcgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0wIDZzMS43OTYtLjAxMyA0LjY3LTMuNjE1QzUuODUxLjkgNi45My4wMDYgOCAwYzEuMDctLjAwNiAyLjE0OC44ODcgMy4zNDMgMi4zODVDMTQuMjMzIDYuMDA1IDE2IDYgMTYgNkgwelwiPjwvc3ZnPicsRn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpcHB5LWJ1bmRsZS51bWQubWluLmpzLm1hcCIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGZhY3RvcnkoKSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KClcbiAgfSBlbHNlIHtcbiAgICAoZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIC8vIFRvIG1ha2Ugc3VyZSBaZW5zY3JvbGwgY2FuIGJlIHJlZmVyZW5jZWQgZnJvbSB0aGUgaGVhZGVyLCBiZWZvcmUgYGJvZHlgIGlzIGF2YWlsYWJsZVxuICAgICAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgcm9vdC56ZW5zY3JvbGwgPSBmYWN0b3J5KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJldHJ5IDltcyBsYXRlclxuICAgICAgICBzZXRUaW1lb3V0KGluc3RhbGwsIDkpXG4gICAgICB9XG4gICAgfSkoKVxuICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgXCJ1c2Ugc3RyaWN0XCJcblxuXG4gIC8vIERldGVjdCBpZiB0aGUgYnJvd3NlciBhbHJlYWR5IHN1cHBvcnRzIG5hdGl2ZSBzbW9vdGggc2Nyb2xsaW5nIChlLmcuLCBGaXJlZm94IDM2KyBhbmQgQ2hyb21lIDQ5KykgYW5kIGl0IGlzIGVuYWJsZWQ6XG4gIHZhciBpc05hdGl2ZVNtb290aFNjcm9sbEVuYWJsZWRPbiA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0gJiYgXCJnZXRDb21wdXRlZFN0eWxlXCIgaW4gd2luZG93ICYmXG4gICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKVtcInNjcm9sbC1iZWhhdmlvclwiXSA9PT0gXCJzbW9vdGhcIlxuICB9XG5cblxuICAvLyBFeGl0IGlmIGl04oCZcyBub3QgYSBicm93c2VyIGVudmlyb25tZW50OlxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFwiZG9jdW1lbnRcIiBpbiB3aW5kb3cpKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuXG4gIHZhciBtYWtlU2Nyb2xsZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBkZWZhdWx0RHVyYXRpb24sIGVkZ2VPZmZzZXQpIHtcblxuICAgIC8vIFVzZSBkZWZhdWx0cyBpZiBub3QgcHJvdmlkZWRcbiAgICBkZWZhdWx0RHVyYXRpb24gPSBkZWZhdWx0RHVyYXRpb24gfHwgOTk5IC8vbXNcbiAgICBpZiAoIWVkZ2VPZmZzZXQgJiYgZWRnZU9mZnNldCAhPT0gMCkge1xuICAgICAgLy8gV2hlbiBzY3JvbGxpbmcsIHRoaXMgYW1vdW50IG9mIGRpc3RhbmNlIGlzIGtlcHQgZnJvbSB0aGUgZWRnZXMgb2YgdGhlIGNvbnRhaW5lcjpcbiAgICAgIGVkZ2VPZmZzZXQgPSA5IC8vcHhcbiAgICB9XG5cbiAgICAvLyBIYW5kbGluZyB0aGUgbGlmZS1jeWNsZSBvZiB0aGUgc2Nyb2xsZXJcbiAgICB2YXIgc2Nyb2xsVGltZW91dElkXG4gICAgdmFyIHNldFNjcm9sbFRpbWVvdXRJZCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgc2Nyb2xsVGltZW91dElkID0gbmV3VmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBjdXJyZW50IHNtb290aCBzY3JvbGwgb3BlcmF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICovXG4gICAgdmFyIHN0b3BTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsVGltZW91dElkKVxuICAgICAgc2V0U2Nyb2xsVGltZW91dElkKDApXG4gICAgfVxuXG4gICAgdmFyIGdldFRvcFdpdGhFZGdlT2Zmc2V0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBjb250YWluZXIuZ2V0VG9wT2YoZWxlbSkgLSBlZGdlT2Zmc2V0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgdG8gYSBzcGVjaWZpYyB2ZXJ0aWNhbCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3RhcmdldFl9IFRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB3aXRoaW4gdGhlIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSB7ZHVyYXRpb259IE9wdGlvbmFsbHkgdGhlIGR1cmF0aW9uIG9mIHRoZSBzY3JvbGwgb3BlcmF0aW9uLlxuICAgICAqICAgICAgICBJZiBub3QgcHJvdmlkZWQgdGhlIGRlZmF1bHQgZHVyYXRpb24gaXMgdXNlZC5cbiAgICAgKiBAcGFyYW0ge29uRG9uZX0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBvbmNlIHRoZSBzY3JvbGwgZmluaXNoZWQuXG4gICAgICovXG4gICAgdmFyIHNjcm9sbFRvWSA9IGZ1bmN0aW9uICh0YXJnZXRZLCBkdXJhdGlvbiwgb25Eb25lKSB7XG4gICAgICBzdG9wU2Nyb2xsKClcbiAgICAgIGlmIChkdXJhdGlvbiA9PT0gMCB8fCAoZHVyYXRpb24gJiYgZHVyYXRpb24gPCAwKSB8fCBpc05hdGl2ZVNtb290aFNjcm9sbEVuYWJsZWRPbihjb250YWluZXIuYm9keSkpIHtcbiAgICAgICAgY29udGFpbmVyLnRvWSh0YXJnZXRZKVxuICAgICAgICBpZiAob25Eb25lKSB7XG4gICAgICAgICAgb25Eb25lKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXJ0WSA9IGNvbnRhaW5lci5nZXRZKClcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5tYXgoMCwgdGFyZ2V0WSkgLSBzdGFydFlcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgTWF0aC5taW4oTWF0aC5hYnMoZGlzdGFuY2UpLCBkZWZhdWx0RHVyYXRpb24pO1xuICAgICAgICAoZnVuY3Rpb24gbG9vcFNjcm9sbCgpIHtcbiAgICAgICAgICBzZXRTY3JvbGxUaW1lb3V0SWQoc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcGVyY2VudGFnZTpcbiAgICAgICAgICAgIHZhciBwID0gTWF0aC5taW4oMSwgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lKSAvIGR1cmF0aW9uKVxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSB2ZXJ0aWNhbCBwb3NpdGlvbjpcbiAgICAgICAgICAgIHZhciB5ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihzdGFydFkgKyBkaXN0YW5jZSAqIChwIDwgMC41ID8gMiAqIHAgKiBwIDogcCAqICg0IC0gcCAqIDIpIC0gMSkpKVxuICAgICAgICAgICAgY29udGFpbmVyLnRvWSh5KVxuICAgICAgICAgICAgaWYgKHAgPCAxICYmIChjb250YWluZXIuZ2V0SGVpZ2h0KCkgKyB5KSA8IGNvbnRhaW5lci5ib2R5LnNjcm9sbEhlaWdodCkge1xuICAgICAgICAgICAgICBsb29wU2Nyb2xsKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoc3RvcFNjcm9sbCwgOTkpIC8vIHdpdGggY29vbGRvd24gdGltZVxuICAgICAgICAgICAgICBpZiAob25Eb25lKSB7XG4gICAgICAgICAgICAgICAgb25Eb25lKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDkpKVxuICAgICAgICB9KSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyB0byB0aGUgdG9wIG9mIGEgc3BlY2lmaWMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZWxlbX0gVGhlIGVsZW1lbnQgdG8gc2Nyb2xsIHRvLlxuICAgICAqIEBwYXJhbSB7ZHVyYXRpb259IE9wdGlvbmFsbHkgdGhlIGR1cmF0aW9uIG9mIHRoZSBzY3JvbGwgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7b25Eb25lfSBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIG9uY2UgdGhlIHNjcm9sbCBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICB2YXIgc2Nyb2xsVG9FbGVtID0gZnVuY3Rpb24gKGVsZW0sIGR1cmF0aW9uLCBvbkRvbmUpIHtcbiAgICAgIHNjcm9sbFRvWShnZXRUb3BXaXRoRWRnZU9mZnNldChlbGVtKSwgZHVyYXRpb24sIG9uRG9uZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIGFuIGVsZW1lbnQgaW50byB2aWV3IGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZWxlbX0gVGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtkdXJhdGlvbn0gT3B0aW9uYWxseSB0aGUgZHVyYXRpb24gb2YgdGhlIHNjcm9sbCBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtvbkRvbmV9IEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb25jZSB0aGUgc2Nyb2xsIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIHZhciBzY3JvbGxJbnRvVmlldyA9IGZ1bmN0aW9uIChlbGVtLCBkdXJhdGlvbiwgb25Eb25lKSB7XG4gICAgICB2YXIgZWxlbUhlaWdodCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICB2YXIgZWxlbUJvdHRvbSA9IGNvbnRhaW5lci5nZXRUb3BPZihlbGVtKSArIGVsZW1IZWlnaHRcbiAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXIuZ2V0SGVpZ2h0KClcbiAgICAgIHZhciB5ID0gY29udGFpbmVyLmdldFkoKVxuICAgICAgdmFyIGNvbnRhaW5lckJvdHRvbSA9IHkgKyBjb250YWluZXJIZWlnaHRcbiAgICAgIGlmIChnZXRUb3BXaXRoRWRnZU9mZnNldChlbGVtKSA8IHkgfHwgKGVsZW1IZWlnaHQgKyBlZGdlT2Zmc2V0KSA+IGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICAvLyBFbGVtZW50IGlzIGNsaXBwZWQgYXQgdG9wIG9yIGlzIGhpZ2hlciB0aGFuIHNjcmVlbi5cbiAgICAgICAgc2Nyb2xsVG9FbGVtKGVsZW0sIGR1cmF0aW9uLCBvbkRvbmUpXG4gICAgICB9IGVsc2UgaWYgKChlbGVtQm90dG9tICsgZWRnZU9mZnNldCkgPiBjb250YWluZXJCb3R0b20pIHtcbiAgICAgICAgLy8gRWxlbWVudCBpcyBjbGlwcGVkIGF0IHRoZSBib3R0b20uXG4gICAgICAgIHNjcm9sbFRvWShlbGVtQm90dG9tIC0gY29udGFpbmVySGVpZ2h0ICsgZWRnZU9mZnNldCwgZHVyYXRpb24sIG9uRG9uZSlcbiAgICAgIH0gZWxzZSBpZiAob25Eb25lKSB7XG4gICAgICAgIG9uRG9uZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyB0byB0aGUgY2VudGVyIG9mIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2VsZW19IFRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7ZHVyYXRpb259IE9wdGlvbmFsbHkgdGhlIGR1cmF0aW9uIG9mIHRoZSBzY3JvbGwgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7b2Zmc2V0fSBPcHRpb25hbGx5IHRoZSBvZmZzZXQgb2YgdGhlIHRvcCBvZiB0aGUgZWxlbWVudCBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlbi5cbiAgICAgKiAgICAgICAgQSB2YWx1ZSBvZiAwIGlzIGlnbm9yZWQuXG4gICAgICogQHBhcmFtIHtvbkRvbmV9IEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb25jZSB0aGUgc2Nyb2xsIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIHZhciBzY3JvbGxUb0NlbnRlck9mID0gZnVuY3Rpb24gKGVsZW0sIGR1cmF0aW9uLCBvZmZzZXQsIG9uRG9uZSkge1xuICAgICAgc2Nyb2xsVG9ZKE1hdGgubWF4KDAsIGNvbnRhaW5lci5nZXRUb3BPZihlbGVtKSAtIGNvbnRhaW5lci5nZXRIZWlnaHQoKSAvIDIgKyAob2Zmc2V0IHx8IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IC8gMikpLCBkdXJhdGlvbiwgb25Eb25lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgZGVmYXVsdCBzZXR0aW5ncyBmb3IgdGhpcyBzY3JvbGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bmV3RGVmYXVsdER1cmF0aW9ufSBPcHRpb25hbGx5IGEgbmV3IHZhbHVlIGZvciBkZWZhdWx0IGR1cmF0aW9uLCB1c2VkIGZvciBlYWNoIHNjcm9sbCBtZXRob2QgYnkgZGVmYXVsdC5cbiAgICAgKiAgICAgICAgSWdub3JlZCBpZiBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICAgKiBAcGFyYW0ge25ld0VkZ2VPZmZzZXR9IE9wdGlvbmFsbHkgYSBuZXcgdmFsdWUgZm9yIHRoZSBlZGdlIG9mZnNldCwgdXNlZCBieSBlYWNoIHNjcm9sbCBtZXRob2QgYnkgZGVmYXVsdC4gSWdub3JlZCBpZiBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgY3VycmVudCB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIHNldHVwID0gZnVuY3Rpb24gKG5ld0RlZmF1bHREdXJhdGlvbiwgbmV3RWRnZU9mZnNldCkge1xuICAgICAgaWYgKG5ld0RlZmF1bHREdXJhdGlvbiA9PT0gMCB8fCBuZXdEZWZhdWx0RHVyYXRpb24pIHtcbiAgICAgICAgZGVmYXVsdER1cmF0aW9uID0gbmV3RGVmYXVsdER1cmF0aW9uXG4gICAgICB9XG4gICAgICBpZiAobmV3RWRnZU9mZnNldCA9PT0gMCB8fCBuZXdFZGdlT2Zmc2V0KSB7XG4gICAgICAgIGVkZ2VPZmZzZXQgPSBuZXdFZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWZhdWx0RHVyYXRpb246IGRlZmF1bHREdXJhdGlvbixcbiAgICAgICAgZWRnZU9mZnNldDogZWRnZU9mZnNldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzZXR1cDogc2V0dXAsXG4gICAgICB0bzogc2Nyb2xsVG9FbGVtLFxuICAgICAgdG9ZOiBzY3JvbGxUb1ksXG4gICAgICBpbnRvVmlldzogc2Nyb2xsSW50b1ZpZXcsXG4gICAgICBjZW50ZXI6IHNjcm9sbFRvQ2VudGVyT2YsXG4gICAgICBzdG9wOiBzdG9wU2Nyb2xsLFxuICAgICAgbW92aW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXNjcm9sbFRpbWVvdXRJZCB9LFxuICAgICAgZ2V0WTogY29udGFpbmVyLmdldFksXG4gICAgICBnZXRUb3BPZjogY29udGFpbmVyLmdldFRvcE9mXG4gICAgfVxuXG4gIH1cblxuXG4gIHZhciBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gIHZhciBnZXREb2NZID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93LnNjcm9sbFkgfHwgZG9jRWxlbS5zY3JvbGxUb3AgfVxuXG4gIC8vIENyZWF0ZSBhIHNjcm9sbGVyIGZvciB0aGUgZG9jdW1lbnQ6XG4gIHZhciB6ZW5zY3JvbGwgPSBtYWtlU2Nyb2xsZXIoe1xuICAgIGJvZHk6IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSxcbiAgICB0b1k6IGZ1bmN0aW9uICh5KSB7IHdpbmRvdy5zY3JvbGxUbygwLCB5KSB9LFxuICAgIGdldFk6IGdldERvY1ksXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jRWxlbS5jbGllbnRIZWlnaHQgfSxcbiAgICBnZXRUb3BPZjogZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgZ2V0RG9jWSgpIC0gZG9jRWxlbS5vZmZzZXRUb3AgfVxuICB9KVxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzY3JvbGxlciBmcm9tIHRoZSBwcm92aWRlZCBjb250YWluZXIgZWxlbWVudCAoZS5nLiwgYSBESVYpXG4gICAqXG4gICAqIEBwYXJhbSB7c2Nyb2xsQ29udGFpbmVyfSBUaGUgdmVydGljYWwgcG9zaXRpb24gd2l0aGluIHRoZSBkb2N1bWVudC5cbiAgICogQHBhcmFtIHtkZWZhdWx0RHVyYXRpb259IE9wdGlvbmFsbHkgYSB2YWx1ZSBmb3IgZGVmYXVsdCBkdXJhdGlvbiwgdXNlZCBmb3IgZWFjaCBzY3JvbGwgbWV0aG9kIGJ5IGRlZmF1bHQuXG4gICAqICAgICAgICBJZ25vcmVkIGlmIDAgb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gICAqIEBwYXJhbSB7ZWRnZU9mZnNldH0gT3B0aW9uYWxseSBhIHZhbHVlIGZvciB0aGUgZWRnZSBvZmZzZXQsIHVzZWQgYnkgZWFjaCBzY3JvbGwgbWV0aG9kIGJ5IGRlZmF1bHQuIFxuICAgKiAgICAgICAgSWdub3JlZCBpZiBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICogQHJldHVybnMgQSBzY3JvbGxlciBvYmplY3QsIHNpbWlsYXIgdG8gYHplbnNjcm9sbGAgYnV0IGNvbnRyb2xsaW5nIHRoZSBwcm92aWRlZCBlbGVtZW50LlxuICAgKi9cbiAgemVuc2Nyb2xsLmNyZWF0ZVNjcm9sbGVyID0gZnVuY3Rpb24gKHNjcm9sbENvbnRhaW5lciwgZGVmYXVsdER1cmF0aW9uLCBlZGdlT2Zmc2V0KSB7XG4gICAgcmV0dXJuIG1ha2VTY3JvbGxlcih7XG4gICAgICBib2R5OiBzY3JvbGxDb250YWluZXIsXG4gICAgICB0b1k6IGZ1bmN0aW9uICh5KSB7IHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgPSB5IH0sXG4gICAgICBnZXRZOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wIH0sXG4gICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hdGgubWluKHNjcm9sbENvbnRhaW5lci5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2NFbGVtLmNsaWVudEhlaWdodCkgfSxcbiAgICAgIGdldFRvcE9mOiBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS5vZmZzZXRUb3AgfVxuICAgIH0sIGRlZmF1bHREdXJhdGlvbiwgZWRnZU9mZnNldClcbiAgfVxuXG5cbiAgLy8gQXV0b21hdGljIGxpbmstc21vb3RoaW5nIG9uIGFjaG9yc1xuICAvLyBFeGNsdWRlIElFOC0gb3Igd2hlbiBuYXRpdmUgaXMgZW5hYmxlZCBvciBaZW5zY3JvbGwgYXV0by0gaXMgZGlzYWJsZWRcbiAgaWYgKFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIHdpbmRvdyAmJiAhd2luZG93Lm5vWmVuc21vb3RoICYmICFpc05hdGl2ZVNtb290aFNjcm9sbEVuYWJsZWRPbihkb2N1bWVudC5ib2R5KSkge1xuXG4gICAgdmFyIGlzSGlzdG9yeVN1cHBvcnRlZCA9IFwiaGlzdG9yeVwiIGluIHdpbmRvdyAmJiBcInB1c2hTdGF0ZVwiIGluIGhpc3RvcnlcbiAgICB2YXIgaXNTY3JvbGxSZXN0b3JhdGlvblN1cHBvcnRlZCA9IGlzSGlzdG9yeVN1cHBvcnRlZCAmJiBcInNjcm9sbFJlc3RvcmF0aW9uXCIgaW4gaGlzdG9yeVxuXG4gICAgLy8gT24gZmlyc3QgbG9hZCAmIHJlZnJlc2ggbWFrZSBzdXJlIHRoZSBicm93c2VyIHJlc3RvcmVzIHRoZSBwb3NpdGlvbiBmaXJzdFxuICAgIGlmIChpc1Njcm9sbFJlc3RvcmF0aW9uU3VwcG9ydGVkKSB7XG4gICAgICBoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCJcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xuXG4gICAgICBpZiAoaXNTY3JvbGxSZXN0b3JhdGlvblN1cHBvcnRlZCkge1xuICAgICAgICAvLyBTZXQgaXQgdG8gbWFudWFsXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIiB9LCA5KVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmIChldmVudC5zdGF0ZSAmJiBcInplbnNjcm9sbFlcIiBpbiBldmVudC5zdGF0ZSkge1xuICAgICAgICAgICAgemVuc2Nyb2xsLnRvWShldmVudC5zdGF0ZS56ZW5zY3JvbGxZKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UpXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBlZGdlIG9mZnNldCBvbiBmaXJzdCBsb2FkIGlmIG5lY2Vzc2FyeVxuICAgICAgLy8gVGhpcyBtYXkgbm90IHdvcmsgb24gSUUgKG9yIG9sZGVyIGNvbXB1dGVyPykgYXMgaXQgcmVxdWlyZXMgbW9yZSB0aW1lb3V0LCBhcm91bmQgMTAwIG1zXG4gICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gQWRqdXN0bWVudCBpcyBvbmx5IG5lZWRlZCBpZiB0aGVyZSBpcyBhbiBlZGdlIG9mZnNldDpcbiAgICAgICAgICB2YXIgZWRnZU9mZnNldCA9IHplbnNjcm9sbC5zZXR1cCgpLmVkZ2VPZmZzZXRcbiAgICAgICAgICBpZiAoZWRnZU9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldEVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdChcIiNcIilbMV0pXG4gICAgICAgICAgICBpZiAodGFyZ2V0RWxlbSkge1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0WSA9IE1hdGgubWF4KDAsIHplbnNjcm9sbC5nZXRUb3BPZih0YXJnZXRFbGVtKSAtIGVkZ2VPZmZzZXQpXG4gICAgICAgICAgICAgIHZhciBkaWZmID0gemVuc2Nyb2xsLmdldFkoKSAtIHRhcmdldFlcbiAgICAgICAgICAgICAgLy8gT25seSBkbyB0aGUgYWRqdXN0bWVudCBpZiB0aGUgYnJvd3NlciBpcyB2ZXJ5IGNsb3NlIHRvIHRoZSBlbGVtZW50OlxuICAgICAgICAgICAgICBpZiAoMCA8PSBkaWZmICYmIGRpZmYgPCA5KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHRhcmdldFkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIDkpXG4gICAgICB9XG5cbiAgICB9LCBmYWxzZSlcblxuICAgIC8vIEhhbmRsaW5nIGNsaWNrcyBvbiBhbmNob3JzXG4gICAgdmFyIFJFX25vWmVuc21vb3RoID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKW5vWmVuc21vb3RoKFxcXFxzfCQpXCIpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBhbmNob3IgPSBldmVudC50YXJnZXRcbiAgICAgIHdoaWxlIChhbmNob3IgJiYgYW5jaG9yLnRhZ05hbWUgIT09IFwiQVwiKSB7XG4gICAgICAgIGFuY2hvciA9IGFuY2hvci5wYXJlbnROb2RlXG4gICAgICB9XG4gICAgICAvLyBMZXQgdGhlIGJyb3dzZXIgaGFuZGxlIHRoZSBjbGljayBpZiBpdCB3YXNuJ3Qgd2l0aCB0aGUgcHJpbWFyeSBidXR0b24sIG9yIHdpdGggc29tZSBtb2RpZmllciBrZXlzOlxuICAgICAgaWYgKCFhbmNob3IgfHwgZXZlbnQud2hpY2ggIT09IDEgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgc2Nyb2xsaW5nIHBvc2l0aW9uIHNvIGl0IGNhbiBiZSB1c2VkIGZvciBzY3JvbGwgcmVzdG9yYXRpb246XG4gICAgICBpZiAoaXNTY3JvbGxSZXN0b3JhdGlvblN1cHBvcnRlZCkge1xuICAgICAgICB2YXIgaGlzdG9yeVN0YXRlID0gaGlzdG9yeS5zdGF0ZSAmJiB0eXBlb2YgaGlzdG9yeS5zdGF0ZSA9PT0gXCJvYmplY3RcIiA/IGhpc3Rvcnkuc3RhdGUgOiB7fVxuICAgICAgICBoaXN0b3J5U3RhdGUuemVuc2Nyb2xsWSA9IHplbnNjcm9sbC5nZXRZKClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBBdm9pZCB0aGUgQ2hyb21lIFNlY3VyaXR5IGV4Y2VwdGlvbiBvbiBmaWxlIHByb3RvY29sLCBlLmcuLCBmaWxlOi8vaW5kZXguaHRtbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBGaW5kIHRoZSByZWZlcmVuY2VkIElEOlxuICAgICAgdmFyIGhyZWYgPSBhbmNob3IuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSB8fCBcIlwiXG4gICAgICBpZiAoaHJlZi5pbmRleE9mKFwiI1wiKSA9PT0gMCAmJiAhUkVfbm9aZW5zbW9vdGgudGVzdChhbmNob3IuY2xhc3NOYW1lKSkge1xuICAgICAgICB2YXIgdGFyZ2V0WSA9IDBcbiAgICAgICAgdmFyIHRhcmdldEVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChocmVmLnN1YnN0cmluZygxKSlcbiAgICAgICAgaWYgKGhyZWYgIT09IFwiI1wiKSB7XG4gICAgICAgICAgaWYgKCF0YXJnZXRFbGVtKSB7XG4gICAgICAgICAgICAvLyBMZXQgdGhlIGJyb3dzZXIgaGFuZGxlIHRoZSBjbGljayBpZiB0aGUgdGFyZ2V0IElEIGlzIG5vdCBmb3VuZC5cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRZID0gemVuc2Nyb2xsLmdldFRvcE9mKHRhcmdldEVsZW0pXG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAvLyBCeSBkZWZhdWx0IHRyaWdnZXIgdGhlIGJyb3dzZXIncyBgaGFzaGNoYW5nZWAgZXZlbnQuLi5cbiAgICAgICAgdmFyIG9uRG9uZSA9IGZ1bmN0aW9uICgpIHsgd2luZG93LmxvY2F0aW9uID0gaHJlZiB9XG4gICAgICAgIC8vIC4uLnVubGVzcyB0aGVyZSBpcyBhbiBlZGdlIG9mZnNldCBzcGVjaWZpZWRcbiAgICAgICAgdmFyIGVkZ2VPZmZzZXQgPSB6ZW5zY3JvbGwuc2V0dXAoKS5lZGdlT2Zmc2V0XG4gICAgICAgIGlmIChlZGdlT2Zmc2V0KSB7XG4gICAgICAgICAgdGFyZ2V0WSA9IE1hdGgubWF4KDAsIHRhcmdldFkgLSBlZGdlT2Zmc2V0KVxuICAgICAgICAgIGlmIChpc0hpc3RvcnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIG9uRG9uZSA9IGZ1bmN0aW9uICgpIHsgaGlzdG9yeS5wdXNoU3RhdGUoe30sIFwiXCIsIGhyZWYpIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgemVuc2Nyb2xsLnRvWSh0YXJnZXRZLCBudWxsLCBvbkRvbmUpXG4gICAgICB9XG4gICAgfSwgZmFsc2UpXG5cbiAgfVxuXG5cbiAgcmV0dXJuIHplbnNjcm9sbFxufSkpOyJdfQ==
