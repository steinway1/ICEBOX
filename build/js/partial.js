(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/**
 * @popperjs/core v2.11.8 - MIT License
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

var max = Math.max;
var min = Math.min;
var round = Math.round;

function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = isElement(element) ? getWindow(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

function getVariation(placement) {
  return placement.split('-')[1];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
            _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            effect = _ref.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var passive = {
  passive: true
};

function effect$2(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect$2,
  data: {}
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
      y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, getWindow(popper)) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$1(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$1,
  requires: ['computeStyles']
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}

var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = offset + overflow[mainSide];
    var max$1 = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper$1 = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers$1
}); // eslint-disable-next-line import/no-unused-modules

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

exports.applyStyles = applyStyles$1;
exports.arrow = arrow$1;
exports.computeStyles = computeStyles$1;
exports.createPopper = createPopper;
exports.createPopperLite = createPopper$1;
exports.defaultModifiers = defaultModifiers;
exports.detectOverflow = detectOverflow;
exports.eventListeners = eventListeners;
exports.flip = flip$1;
exports.hide = hide$1;
exports.offset = offset$1;
exports.popperGenerator = popperGenerator;
exports.popperOffsets = popperOffsets$1;
exports.preventOverflow = preventOverflow$1;


},{}],2:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{}],3:[function(require,module,exports){
// ==================================================
// fancyBox v3.5.7
//
// Licensed GPLv3 for open source use
// or fancyBox Commercial License for commercial use
//
// http://fancyapps.com/fancybox/
// Copyright 2019 fancyApps
//
// ==================================================
!function(t,e,n,o){"use strict";function i(t,e){var o,i,a,s=[],r=0;t&&t.isDefaultPrevented()||(t.preventDefault(),e=e||{},t&&t.data&&(e=h(t.data.options,e)),o=e.$target||n(t.currentTarget).trigger("blur"),(a=n.fancybox.getInstance())&&a.$trigger&&a.$trigger.is(o)||(e.selector?s=n(e.selector):(i=o.attr("data-fancybox")||"",i?(s=t.data?t.data.items:[],s=s.length?s.filter('[data-fancybox="'+i+'"]'):n('[data-fancybox="'+i+'"]')):s=[o]),r=n(s).index(o),r<0&&(r=0),a=n.fancybox.open(s,e,r),a.$trigger=o))}if(t.console=t.console||{info:function(t){}},n){if(n.fn.fancybox)return void console.info("fancyBox already initialized");var a={closeExisting:!1,loop:!1,gutter:50,keyboard:!0,preventCaptionOverlap:!0,arrows:!0,infobar:!0,smallBtn:"auto",toolbar:"auto",buttons:["zoom","slideShow","thumbs","close"],idleTime:3,protect:!1,modal:!1,image:{preload:!1},ajax:{settings:{data:{fancybox:!0}}},iframe:{tpl:'<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" allowfullscreen="allowfullscreen" allow="autoplay; fullscreen" src=""></iframe>',preload:!0,css:{},attr:{scrolling:"auto"}},video:{tpl:'<video class="fancybox-video" controls controlsList="nodownload" poster="{{poster}}"><source src="{{src}}" type="{{format}}" />Sorry, your browser doesn\'t support embedded videos, <a href="{{src}}">download</a> and watch with your favorite video player!</video>',format:"",autoStart:!0},defaultType:"image",animationEffect:"zoom",animationDuration:366,zoomOpacity:"auto",transitionEffect:"fade",transitionDuration:366,slideClass:"",baseClass:"",baseTpl:'<div class="fancybox-container" role="dialog" tabindex="-1"><div class="fancybox-bg"></div><div class="fancybox-inner"><div class="fancybox-infobar"><span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span></div><div class="fancybox-toolbar">{{buttons}}</div><div class="fancybox-navigation">{{arrows}}</div><div class="fancybox-stage"></div><div class="fancybox-caption"><div class="fancybox-caption__body"></div></div></div></div>',spinnerTpl:'<div class="fancybox-loading"></div>',errorTpl:'<div class="fancybox-error"><p>{{ERROR}}</p></div>',btnTpl:{download:'<a download data-fancybox-download class="fancybox-button fancybox-button--download" title="{{DOWNLOAD}}" href="javascript:;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.62 17.09V19H5.38v-1.91zm-2.97-6.96L17 11.45l-5 4.87-5-4.87 1.36-1.32 2.68 2.64V5h1.92v7.77z"/></svg></a>',zoom:'<button data-fancybox-zoom class="fancybox-button fancybox-button--zoom" title="{{ZOOM}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.7 17.3l-3-3a5.9 5.9 0 0 0-.6-7.6 5.9 5.9 0 0 0-8.4 0 5.9 5.9 0 0 0 0 8.4 5.9 5.9 0 0 0 7.7.7l3 3a1 1 0 0 0 1.3 0c.4-.5.4-1 0-1.5zM8.1 13.8a4 4 0 0 1 0-5.7 4 4 0 0 1 5.7 0 4 4 0 0 1 0 5.7 4 4 0 0 1-5.7 0z"/></svg></button>',close:'<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 10.6L6.6 5.2 5.2 6.6l5.4 5.4-5.4 5.4 1.4 1.4 5.4-5.4 5.4 5.4 1.4-1.4-5.4-5.4 5.4-5.4-1.4-1.4-5.4 5.4z"/></svg></button>',arrowLeft:'<button data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}"><div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.28 15.7l-1.34 1.37L5 12l4.94-5.07 1.34 1.38-2.68 2.72H19v1.94H8.6z"/></svg></div></button>',arrowRight:'<button data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}"><div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.4 12.97l-2.68 2.72 1.34 1.38L19 12l-4.94-5.07-1.34 1.38 2.68 2.72H5v1.94z"/></svg></div></button>',smallBtn:'<button type="button" data-fancybox-close class="fancybox-button fancybox-close-small" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 24 24"><path d="M13 12l5-5-1-1-5 5-5-5-1 1 5 5-5 5 1 1 5-5 5 5 1-1z"/></svg></button>'},parentEl:"body",hideScrollbar:!0,autoFocus:!0,backFocus:!0,trapFocus:!0,fullScreen:{autoStart:!1},touch:{vertical:!0,momentum:!0},hash:null,media:{},slideShow:{autoStart:!1,speed:3e3},thumbs:{autoStart:!1,hideOnClose:!0,parentEl:".fancybox-container",axis:"y"},wheel:"auto",onInit:n.noop,beforeLoad:n.noop,afterLoad:n.noop,beforeShow:n.noop,afterShow:n.noop,beforeClose:n.noop,afterClose:n.noop,onActivate:n.noop,onDeactivate:n.noop,clickContent:function(t,e){return"image"===t.type&&"zoom"},clickSlide:"close",clickOutside:"close",dblclickContent:!1,dblclickSlide:!1,dblclickOutside:!1,mobile:{preventCaptionOverlap:!1,idleTime:!1,clickContent:function(t,e){return"image"===t.type&&"toggleControls"},clickSlide:function(t,e){return"image"===t.type?"toggleControls":"close"},dblclickContent:function(t,e){return"image"===t.type&&"zoom"},dblclickSlide:function(t,e){return"image"===t.type&&"zoom"}},lang:"en",i18n:{en:{CLOSE:"Close",NEXT:"Next",PREV:"Previous",ERROR:"The requested content cannot be loaded. <br/> Please try again later.",PLAY_START:"Start slideshow",PLAY_STOP:"Pause slideshow",FULL_SCREEN:"Full screen",THUMBS:"Thumbnails",DOWNLOAD:"Download",SHARE:"Share",ZOOM:"Zoom"},de:{CLOSE:"Schlie&szlig;en",NEXT:"Weiter",PREV:"Zur&uuml;ck",ERROR:"Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es sp&auml;ter nochmal.",PLAY_START:"Diaschau starten",PLAY_STOP:"Diaschau beenden",FULL_SCREEN:"Vollbild",THUMBS:"Vorschaubilder",DOWNLOAD:"Herunterladen",SHARE:"Teilen",ZOOM:"Vergr&ouml;&szlig;ern"}}},s=n(t),r=n(e),c=0,l=function(t){return t&&t.hasOwnProperty&&t instanceof n},d=function(){return t.requestAnimationFrame||t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||t.oRequestAnimationFrame||function(e){return t.setTimeout(e,1e3/60)}}(),u=function(){return t.cancelAnimationFrame||t.webkitCancelAnimationFrame||t.mozCancelAnimationFrame||t.oCancelAnimationFrame||function(e){t.clearTimeout(e)}}(),f=function(){var t,n=e.createElement("fakeelement"),o={transition:"transitionend",OTransition:"oTransitionEnd",MozTransition:"transitionend",WebkitTransition:"webkitTransitionEnd"};for(t in o)if(void 0!==n.style[t])return o[t];return"transitionend"}(),p=function(t){return t&&t.length&&t[0].offsetHeight},h=function(t,e){var o=n.extend(!0,{},t,e);return n.each(e,function(t,e){n.isArray(e)&&(o[t]=e)}),o},g=function(t){var o,i;return!(!t||t.ownerDocument!==e)&&(n(".fancybox-container").css("pointer-events","none"),o={x:t.getBoundingClientRect().left+t.offsetWidth/2,y:t.getBoundingClientRect().top+t.offsetHeight/2},i=e.elementFromPoint(o.x,o.y)===t,n(".fancybox-container").css("pointer-events",""),i)},b=function(t,e,o){var i=this;i.opts=h({index:o},n.fancybox.defaults),n.isPlainObject(e)&&(i.opts=h(i.opts,e)),n.fancybox.isMobile&&(i.opts=h(i.opts,i.opts.mobile)),i.id=i.opts.id||++c,i.currIndex=parseInt(i.opts.index,10)||0,i.prevIndex=null,i.prevPos=null,i.currPos=0,i.firstRun=!0,i.group=[],i.slides={},i.addContent(t),i.group.length&&i.init()};n.extend(b.prototype,{init:function(){var o,i,a=this,s=a.group[a.currIndex],r=s.opts;r.closeExisting&&n.fancybox.close(!0),n("body").addClass("fancybox-active"),!n.fancybox.getInstance()&&!1!==r.hideScrollbar&&!n.fancybox.isMobile&&e.body.scrollHeight>t.innerHeight&&(n("head").append('<style id="fancybox-style-noscroll" type="text/css">.compensate-for-scrollbar{margin-right:'+(t.innerWidth-e.documentElement.clientWidth)+"px;}</style>"),n("body").addClass("compensate-for-scrollbar")),i="",n.each(r.buttons,function(t,e){i+=r.btnTpl[e]||""}),o=n(a.translate(a,r.baseTpl.replace("{{buttons}}",i).replace("{{arrows}}",r.btnTpl.arrowLeft+r.btnTpl.arrowRight))).attr("id","fancybox-container-"+a.id).addClass(r.baseClass).data("FancyBox",a).appendTo(r.parentEl),a.$refs={container:o},["bg","inner","infobar","toolbar","stage","caption","navigation"].forEach(function(t){a.$refs[t]=o.find(".fancybox-"+t)}),a.trigger("onInit"),a.activate(),a.jumpTo(a.currIndex)},translate:function(t,e){var n=t.opts.i18n[t.opts.lang]||t.opts.i18n.en;return e.replace(/\{\{(\w+)\}\}/g,function(t,e){return void 0===n[e]?t:n[e]})},addContent:function(t){var e,o=this,i=n.makeArray(t);n.each(i,function(t,e){var i,a,s,r,c,l={},d={};n.isPlainObject(e)?(l=e,d=e.opts||e):"object"===n.type(e)&&n(e).length?(i=n(e),d=i.data()||{},d=n.extend(!0,{},d,d.options),d.$orig=i,l.src=o.opts.src||d.src||i.attr("href"),l.type||l.src||(l.type="inline",l.src=e)):l={type:"html",src:e+""},l.opts=n.extend(!0,{},o.opts,d),n.isArray(d.buttons)&&(l.opts.buttons=d.buttons),n.fancybox.isMobile&&l.opts.mobile&&(l.opts=h(l.opts,l.opts.mobile)),a=l.type||l.opts.type,r=l.src||"",!a&&r&&((s=r.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i))?(a="video",l.opts.video.format||(l.opts.video.format="video/"+("ogv"===s[1]?"ogg":s[1]))):r.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)?a="image":r.match(/\.(pdf)((\?|#).*)?$/i)?(a="iframe",l=n.extend(!0,l,{contentType:"pdf",opts:{iframe:{preload:!1}}})):"#"===r.charAt(0)&&(a="inline")),a?l.type=a:o.trigger("objectNeedsType",l),l.contentType||(l.contentType=n.inArray(l.type,["html","inline","ajax"])>-1?"html":l.type),l.index=o.group.length,"auto"==l.opts.smallBtn&&(l.opts.smallBtn=n.inArray(l.type,["html","inline","ajax"])>-1),"auto"===l.opts.toolbar&&(l.opts.toolbar=!l.opts.smallBtn),l.$thumb=l.opts.$thumb||null,l.opts.$trigger&&l.index===o.opts.index&&(l.$thumb=l.opts.$trigger.find("img:first"),l.$thumb.length&&(l.opts.$orig=l.opts.$trigger)),l.$thumb&&l.$thumb.length||!l.opts.$orig||(l.$thumb=l.opts.$orig.find("img:first")),l.$thumb&&!l.$thumb.length&&(l.$thumb=null),l.thumb=l.opts.thumb||(l.$thumb?l.$thumb[0].src:null),"function"===n.type(l.opts.caption)&&(l.opts.caption=l.opts.caption.apply(e,[o,l])),"function"===n.type(o.opts.caption)&&(l.opts.caption=o.opts.caption.apply(e,[o,l])),l.opts.caption instanceof n||(l.opts.caption=void 0===l.opts.caption?"":l.opts.caption+""),"ajax"===l.type&&(c=r.split(/\s+/,2),c.length>1&&(l.src=c.shift(),l.opts.filter=c.shift())),l.opts.modal&&(l.opts=n.extend(!0,l.opts,{trapFocus:!0,infobar:0,toolbar:0,smallBtn:0,keyboard:0,slideShow:0,fullScreen:0,thumbs:0,touch:0,clickContent:!1,clickSlide:!1,clickOutside:!1,dblclickContent:!1,dblclickSlide:!1,dblclickOutside:!1})),o.group.push(l)}),Object.keys(o.slides).length&&(o.updateControls(),(e=o.Thumbs)&&e.isActive&&(e.create(),e.focus()))},addEvents:function(){var e=this;e.removeEvents(),e.$refs.container.on("click.fb-close","[data-fancybox-close]",function(t){t.stopPropagation(),t.preventDefault(),e.close(t)}).on("touchstart.fb-prev click.fb-prev","[data-fancybox-prev]",function(t){t.stopPropagation(),t.preventDefault(),e.previous()}).on("touchstart.fb-next click.fb-next","[data-fancybox-next]",function(t){t.stopPropagation(),t.preventDefault(),e.next()}).on("click.fb","[data-fancybox-zoom]",function(t){e[e.isScaledDown()?"scaleToActual":"scaleToFit"]()}),s.on("orientationchange.fb resize.fb",function(t){t&&t.originalEvent&&"resize"===t.originalEvent.type?(e.requestId&&u(e.requestId),e.requestId=d(function(){e.update(t)})):(e.current&&"iframe"===e.current.type&&e.$refs.stage.hide(),setTimeout(function(){e.$refs.stage.show(),e.update(t)},n.fancybox.isMobile?600:250))}),r.on("keydown.fb",function(t){var o=n.fancybox?n.fancybox.getInstance():null,i=o.current,a=t.keyCode||t.which;if(9==a)return void(i.opts.trapFocus&&e.focus(t));if(!(!i.opts.keyboard||t.ctrlKey||t.altKey||t.shiftKey||n(t.target).is("input,textarea,video,audio,select")))return 8===a||27===a?(t.preventDefault(),void e.close(t)):37===a||38===a?(t.preventDefault(),void e.previous()):39===a||40===a?(t.preventDefault(),void e.next()):void e.trigger("afterKeydown",t,a)}),e.group[e.currIndex].opts.idleTime&&(e.idleSecondsCounter=0,r.on("mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle",function(t){e.idleSecondsCounter=0,e.isIdle&&e.showControls(),e.isIdle=!1}),e.idleInterval=t.setInterval(function(){++e.idleSecondsCounter>=e.group[e.currIndex].opts.idleTime&&!e.isDragging&&(e.isIdle=!0,e.idleSecondsCounter=0,e.hideControls())},1e3))},removeEvents:function(){var e=this;s.off("orientationchange.fb resize.fb"),r.off("keydown.fb .fb-idle"),this.$refs.container.off(".fb-close .fb-prev .fb-next"),e.idleInterval&&(t.clearInterval(e.idleInterval),e.idleInterval=null)},previous:function(t){return this.jumpTo(this.currPos-1,t)},next:function(t){return this.jumpTo(this.currPos+1,t)},jumpTo:function(t,e){var o,i,a,s,r,c,l,d,u,f=this,h=f.group.length;if(!(f.isDragging||f.isClosing||f.isAnimating&&f.firstRun)){if(t=parseInt(t,10),!(a=f.current?f.current.opts.loop:f.opts.loop)&&(t<0||t>=h))return!1;if(o=f.firstRun=!Object.keys(f.slides).length,r=f.current,f.prevIndex=f.currIndex,f.prevPos=f.currPos,s=f.createSlide(t),h>1&&((a||s.index<h-1)&&f.createSlide(t+1),(a||s.index>0)&&f.createSlide(t-1)),f.current=s,f.currIndex=s.index,f.currPos=s.pos,f.trigger("beforeShow",o),f.updateControls(),s.forcedDuration=void 0,n.isNumeric(e)?s.forcedDuration=e:e=s.opts[o?"animationDuration":"transitionDuration"],e=parseInt(e,10),i=f.isMoved(s),s.$slide.addClass("fancybox-slide--current"),o)return s.opts.animationEffect&&e&&f.$refs.container.css("transition-duration",e+"ms"),f.$refs.container.addClass("fancybox-is-open").trigger("focus"),f.loadSlide(s),void f.preload("image");c=n.fancybox.getTranslate(r.$slide),l=n.fancybox.getTranslate(f.$refs.stage),n.each(f.slides,function(t,e){n.fancybox.stop(e.$slide,!0)}),r.pos!==s.pos&&(r.isComplete=!1),r.$slide.removeClass("fancybox-slide--complete fancybox-slide--current"),i?(u=c.left-(r.pos*c.width+r.pos*r.opts.gutter),n.each(f.slides,function(t,o){o.$slide.removeClass("fancybox-animated").removeClass(function(t,e){return(e.match(/(^|\s)fancybox-fx-\S+/g)||[]).join(" ")});var i=o.pos*c.width+o.pos*o.opts.gutter;n.fancybox.setTranslate(o.$slide,{top:0,left:i-l.left+u}),o.pos!==s.pos&&o.$slide.addClass("fancybox-slide--"+(o.pos>s.pos?"next":"previous")),p(o.$slide),n.fancybox.animate(o.$slide,{top:0,left:(o.pos-s.pos)*c.width+(o.pos-s.pos)*o.opts.gutter},e,function(){o.$slide.css({transform:"",opacity:""}).removeClass("fancybox-slide--next fancybox-slide--previous"),o.pos===f.currPos&&f.complete()})})):e&&s.opts.transitionEffect&&(d="fancybox-animated fancybox-fx-"+s.opts.transitionEffect,r.$slide.addClass("fancybox-slide--"+(r.pos>s.pos?"next":"previous")),n.fancybox.animate(r.$slide,d,e,function(){r.$slide.removeClass(d).removeClass("fancybox-slide--next fancybox-slide--previous")},!1)),s.isLoaded?f.revealContent(s):f.loadSlide(s),f.preload("image")}},createSlide:function(t){var e,o,i=this;return o=t%i.group.length,o=o<0?i.group.length+o:o,!i.slides[t]&&i.group[o]&&(e=n('<div class="fancybox-slide"></div>').appendTo(i.$refs.stage),i.slides[t]=n.extend(!0,{},i.group[o],{pos:t,$slide:e,isLoaded:!1}),i.updateSlide(i.slides[t])),i.slides[t]},scaleToActual:function(t,e,o){var i,a,s,r,c,l=this,d=l.current,u=d.$content,f=n.fancybox.getTranslate(d.$slide).width,p=n.fancybox.getTranslate(d.$slide).height,h=d.width,g=d.height;l.isAnimating||l.isMoved()||!u||"image"!=d.type||!d.isLoaded||d.hasError||(l.isAnimating=!0,n.fancybox.stop(u),t=void 0===t?.5*f:t,e=void 0===e?.5*p:e,i=n.fancybox.getTranslate(u),i.top-=n.fancybox.getTranslate(d.$slide).top,i.left-=n.fancybox.getTranslate(d.$slide).left,r=h/i.width,c=g/i.height,a=.5*f-.5*h,s=.5*p-.5*g,h>f&&(a=i.left*r-(t*r-t),a>0&&(a=0),a<f-h&&(a=f-h)),g>p&&(s=i.top*c-(e*c-e),s>0&&(s=0),s<p-g&&(s=p-g)),l.updateCursor(h,g),n.fancybox.animate(u,{top:s,left:a,scaleX:r,scaleY:c},o||366,function(){l.isAnimating=!1}),l.SlideShow&&l.SlideShow.isActive&&l.SlideShow.stop())},scaleToFit:function(t){var e,o=this,i=o.current,a=i.$content;o.isAnimating||o.isMoved()||!a||"image"!=i.type||!i.isLoaded||i.hasError||(o.isAnimating=!0,n.fancybox.stop(a),e=o.getFitPos(i),o.updateCursor(e.width,e.height),n.fancybox.animate(a,{top:e.top,left:e.left,scaleX:e.width/a.width(),scaleY:e.height/a.height()},t||366,function(){o.isAnimating=!1}))},getFitPos:function(t){var e,o,i,a,s=this,r=t.$content,c=t.$slide,l=t.width||t.opts.width,d=t.height||t.opts.height,u={};return!!(t.isLoaded&&r&&r.length)&&(e=n.fancybox.getTranslate(s.$refs.stage).width,o=n.fancybox.getTranslate(s.$refs.stage).height,e-=parseFloat(c.css("paddingLeft"))+parseFloat(c.css("paddingRight"))+parseFloat(r.css("marginLeft"))+parseFloat(r.css("marginRight")),o-=parseFloat(c.css("paddingTop"))+parseFloat(c.css("paddingBottom"))+parseFloat(r.css("marginTop"))+parseFloat(r.css("marginBottom")),l&&d||(l=e,d=o),i=Math.min(1,e/l,o/d),l*=i,d*=i,l>e-.5&&(l=e),d>o-.5&&(d=o),"image"===t.type?(u.top=Math.floor(.5*(o-d))+parseFloat(c.css("paddingTop")),u.left=Math.floor(.5*(e-l))+parseFloat(c.css("paddingLeft"))):"video"===t.contentType&&(a=t.opts.width&&t.opts.height?l/d:t.opts.ratio||16/9,d>l/a?d=l/a:l>d*a&&(l=d*a)),u.width=l,u.height=d,u)},update:function(t){var e=this;n.each(e.slides,function(n,o){e.updateSlide(o,t)})},updateSlide:function(t,e){var o=this,i=t&&t.$content,a=t.width||t.opts.width,s=t.height||t.opts.height,r=t.$slide;o.adjustCaption(t),i&&(a||s||"video"===t.contentType)&&!t.hasError&&(n.fancybox.stop(i),n.fancybox.setTranslate(i,o.getFitPos(t)),t.pos===o.currPos&&(o.isAnimating=!1,o.updateCursor())),o.adjustLayout(t),r.length&&(r.trigger("refresh"),t.pos===o.currPos&&o.$refs.toolbar.add(o.$refs.navigation.find(".fancybox-button--arrow_right")).toggleClass("compensate-for-scrollbar",r.get(0).scrollHeight>r.get(0).clientHeight)),o.trigger("onUpdate",t,e)},centerSlide:function(t){var e=this,o=e.current,i=o.$slide;!e.isClosing&&o&&(i.siblings().css({transform:"",opacity:""}),i.parent().children().removeClass("fancybox-slide--previous fancybox-slide--next"),n.fancybox.animate(i,{top:0,left:0,opacity:1},void 0===t?0:t,function(){i.css({transform:"",opacity:""}),o.isComplete||e.complete()},!1))},isMoved:function(t){var e,o,i=t||this.current;return!!i&&(o=n.fancybox.getTranslate(this.$refs.stage),e=n.fancybox.getTranslate(i.$slide),!i.$slide.hasClass("fancybox-animated")&&(Math.abs(e.top-o.top)>.5||Math.abs(e.left-o.left)>.5))},updateCursor:function(t,e){var o,i,a=this,s=a.current,r=a.$refs.container;s&&!a.isClosing&&a.Guestures&&(r.removeClass("fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-zoomOut fancybox-can-swipe fancybox-can-pan"),o=a.canPan(t,e),i=!!o||a.isZoomable(),r.toggleClass("fancybox-is-zoomable",i),n("[data-fancybox-zoom]").prop("disabled",!i),o?r.addClass("fancybox-can-pan"):i&&("zoom"===s.opts.clickContent||n.isFunction(s.opts.clickContent)&&"zoom"==s.opts.clickContent(s))?r.addClass("fancybox-can-zoomIn"):s.opts.touch&&(s.opts.touch.vertical||a.group.length>1)&&"video"!==s.contentType&&r.addClass("fancybox-can-swipe"))},isZoomable:function(){var t,e=this,n=e.current;if(n&&!e.isClosing&&"image"===n.type&&!n.hasError){if(!n.isLoaded)return!0;if((t=e.getFitPos(n))&&(n.width>t.width||n.height>t.height))return!0}return!1},isScaledDown:function(t,e){var o=this,i=!1,a=o.current,s=a.$content;return void 0!==t&&void 0!==e?i=t<a.width&&e<a.height:s&&(i=n.fancybox.getTranslate(s),i=i.width<a.width&&i.height<a.height),i},canPan:function(t,e){var o=this,i=o.current,a=null,s=!1;return"image"===i.type&&(i.isComplete||t&&e)&&!i.hasError&&(s=o.getFitPos(i),void 0!==t&&void 0!==e?a={width:t,height:e}:i.isComplete&&(a=n.fancybox.getTranslate(i.$content)),a&&s&&(s=Math.abs(a.width-s.width)>1.5||Math.abs(a.height-s.height)>1.5)),s},loadSlide:function(t){var e,o,i,a=this;if(!t.isLoading&&!t.isLoaded){if(t.isLoading=!0,!1===a.trigger("beforeLoad",t))return t.isLoading=!1,!1;switch(e=t.type,o=t.$slide,o.off("refresh").trigger("onReset").addClass(t.opts.slideClass),e){case"image":a.setImage(t);break;case"iframe":a.setIframe(t);break;case"html":a.setContent(t,t.src||t.content);break;case"video":a.setContent(t,t.opts.video.tpl.replace(/\{\{src\}\}/gi,t.src).replace("{{format}}",t.opts.videoFormat||t.opts.video.format||"").replace("{{poster}}",t.thumb||""));break;case"inline":n(t.src).length?a.setContent(t,n(t.src)):a.setError(t);break;case"ajax":a.showLoading(t),i=n.ajax(n.extend({},t.opts.ajax.settings,{url:t.src,success:function(e,n){"success"===n&&a.setContent(t,e)},error:function(e,n){e&&"abort"!==n&&a.setError(t)}})),o.one("onReset",function(){i.abort()});break;default:a.setError(t)}return!0}},setImage:function(t){var o,i=this;setTimeout(function(){var e=t.$image;i.isClosing||!t.isLoading||e&&e.length&&e[0].complete||t.hasError||i.showLoading(t)},50),i.checkSrcset(t),t.$content=n('<div class="fancybox-content"></div>').addClass("fancybox-is-hidden").appendTo(t.$slide.addClass("fancybox-slide--image")),!1!==t.opts.preload&&t.opts.width&&t.opts.height&&t.thumb&&(t.width=t.opts.width,t.height=t.opts.height,o=e.createElement("img"),o.onerror=function(){n(this).remove(),t.$ghost=null},o.onload=function(){i.afterLoad(t)},t.$ghost=n(o).addClass("fancybox-image").appendTo(t.$content).attr("src",t.thumb)),i.setBigImage(t)},checkSrcset:function(e){var n,o,i,a,s=e.opts.srcset||e.opts.image.srcset;if(s){i=t.devicePixelRatio||1,a=t.innerWidth*i,o=s.split(",").map(function(t){var e={};return t.trim().split(/\s+/).forEach(function(t,n){var o=parseInt(t.substring(0,t.length-1),10);if(0===n)return e.url=t;o&&(e.value=o,e.postfix=t[t.length-1])}),e}),o.sort(function(t,e){return t.value-e.value});for(var r=0;r<o.length;r++){var c=o[r];if("w"===c.postfix&&c.value>=a||"x"===c.postfix&&c.value>=i){n=c;break}}!n&&o.length&&(n=o[o.length-1]),n&&(e.src=n.url,e.width&&e.height&&"w"==n.postfix&&(e.height=e.width/e.height*n.value,e.width=n.value),e.opts.srcset=s)}},setBigImage:function(t){var o=this,i=e.createElement("img"),a=n(i);t.$image=a.one("error",function(){o.setError(t)}).one("load",function(){var e;t.$ghost||(o.resolveImageSlideSize(t,this.naturalWidth,this.naturalHeight),o.afterLoad(t)),o.isClosing||(t.opts.srcset&&(e=t.opts.sizes,e&&"auto"!==e||(e=(t.width/t.height>1&&s.width()/s.height()>1?"100":Math.round(t.width/t.height*100))+"vw"),a.attr("sizes",e).attr("srcset",t.opts.srcset)),t.$ghost&&setTimeout(function(){t.$ghost&&!o.isClosing&&t.$ghost.hide()},Math.min(300,Math.max(1e3,t.height/1600))),o.hideLoading(t))}).addClass("fancybox-image").attr("src",t.src).appendTo(t.$content),(i.complete||"complete"==i.readyState)&&a.naturalWidth&&a.naturalHeight?a.trigger("load"):i.error&&a.trigger("error")},resolveImageSlideSize:function(t,e,n){var o=parseInt(t.opts.width,10),i=parseInt(t.opts.height,10);t.width=e,t.height=n,o>0&&(t.width=o,t.height=Math.floor(o*n/e)),i>0&&(t.width=Math.floor(i*e/n),t.height=i)},setIframe:function(t){var e,o=this,i=t.opts.iframe,a=t.$slide;t.$content=n('<div class="fancybox-content'+(i.preload?" fancybox-is-hidden":"")+'"></div>').css(i.css).appendTo(a),a.addClass("fancybox-slide--"+t.contentType),t.$iframe=e=n(i.tpl.replace(/\{rnd\}/g,(new Date).getTime())).attr(i.attr).appendTo(t.$content),i.preload?(o.showLoading(t),e.on("load.fb error.fb",function(e){this.isReady=1,t.$slide.trigger("refresh"),o.afterLoad(t)}),a.on("refresh.fb",function(){var n,o,s=t.$content,r=i.css.width,c=i.css.height;if(1===e[0].isReady){try{n=e.contents(),o=n.find("body")}catch(t){}o&&o.length&&o.children().length&&(a.css("overflow","visible"),s.css({width:"100%","max-width":"100%",height:"9999px"}),void 0===r&&(r=Math.ceil(Math.max(o[0].clientWidth,o.outerWidth(!0)))),s.css("width",r||"").css("max-width",""),void 0===c&&(c=Math.ceil(Math.max(o[0].clientHeight,o.outerHeight(!0)))),s.css("height",c||""),a.css("overflow","auto")),s.removeClass("fancybox-is-hidden")}})):o.afterLoad(t),e.attr("src",t.src),a.one("onReset",function(){try{n(this).find("iframe").hide().unbind().attr("src","//about:blank")}catch(t){}n(this).off("refresh.fb").empty(),t.isLoaded=!1,t.isRevealed=!1})},setContent:function(t,e){var o=this;o.isClosing||(o.hideLoading(t),t.$content&&n.fancybox.stop(t.$content),t.$slide.empty(),l(e)&&e.parent().length?((e.hasClass("fancybox-content")||e.parent().hasClass("fancybox-content"))&&e.parents(".fancybox-slide").trigger("onReset"),t.$placeholder=n("<div>").hide().insertAfter(e),e.css("display","inline-block")):t.hasError||("string"===n.type(e)&&(e=n("<div>").append(n.trim(e)).contents()),t.opts.filter&&(e=n("<div>").html(e).find(t.opts.filter))),t.$slide.one("onReset",function(){n(this).find("video,audio").trigger("pause"),t.$placeholder&&(t.$placeholder.after(e.removeClass("fancybox-content").hide()).remove(),t.$placeholder=null),t.$smallBtn&&(t.$smallBtn.remove(),t.$smallBtn=null),t.hasError||(n(this).empty(),t.isLoaded=!1,t.isRevealed=!1)}),n(e).appendTo(t.$slide),n(e).is("video,audio")&&(n(e).addClass("fancybox-video"),n(e).wrap("<div></div>"),t.contentType="video",t.opts.width=t.opts.width||n(e).attr("width"),t.opts.height=t.opts.height||n(e).attr("height")),t.$content=t.$slide.children().filter("div,form,main,video,audio,article,.fancybox-content").first(),t.$content.siblings().hide(),t.$content.length||(t.$content=t.$slide.wrapInner("<div></div>").children().first()),t.$content.addClass("fancybox-content"),t.$slide.addClass("fancybox-slide--"+t.contentType),o.afterLoad(t))},setError:function(t){t.hasError=!0,t.$slide.trigger("onReset").removeClass("fancybox-slide--"+t.contentType).addClass("fancybox-slide--error"),t.contentType="html",this.setContent(t,this.translate(t,t.opts.errorTpl)),t.pos===this.currPos&&(this.isAnimating=!1)},showLoading:function(t){var e=this;(t=t||e.current)&&!t.$spinner&&(t.$spinner=n(e.translate(e,e.opts.spinnerTpl)).appendTo(t.$slide).hide().fadeIn("fast"))},hideLoading:function(t){var e=this;(t=t||e.current)&&t.$spinner&&(t.$spinner.stop().remove(),delete t.$spinner)},afterLoad:function(t){var e=this;e.isClosing||(t.isLoading=!1,t.isLoaded=!0,e.trigger("afterLoad",t),e.hideLoading(t),!t.opts.smallBtn||t.$smallBtn&&t.$smallBtn.length||(t.$smallBtn=n(e.translate(t,t.opts.btnTpl.smallBtn)).appendTo(t.$content)),t.opts.protect&&t.$content&&!t.hasError&&(t.$content.on("contextmenu.fb",function(t){return 2==t.button&&t.preventDefault(),!0}),"image"===t.type&&n('<div class="fancybox-spaceball"></div>').appendTo(t.$content)),e.adjustCaption(t),e.adjustLayout(t),t.pos===e.currPos&&e.updateCursor(),e.revealContent(t))},adjustCaption:function(t){var e,n=this,o=t||n.current,i=o.opts.caption,a=o.opts.preventCaptionOverlap,s=n.$refs.caption,r=!1;s.toggleClass("fancybox-caption--separate",a),a&&i&&i.length&&(o.pos!==n.currPos?(e=s.clone().appendTo(s.parent()),e.children().eq(0).empty().html(i),r=e.outerHeight(!0),e.empty().remove()):n.$caption&&(r=n.$caption.outerHeight(!0)),o.$slide.css("padding-bottom",r||""))},adjustLayout:function(t){var e,n,o,i,a=this,s=t||a.current;s.isLoaded&&!0!==s.opts.disableLayoutFix&&(s.$content.css("margin-bottom",""),s.$content.outerHeight()>s.$slide.height()+.5&&(o=s.$slide[0].style["padding-bottom"],i=s.$slide.css("padding-bottom"),parseFloat(i)>0&&(e=s.$slide[0].scrollHeight,s.$slide.css("padding-bottom",0),Math.abs(e-s.$slide[0].scrollHeight)<1&&(n=i),s.$slide.css("padding-bottom",o))),s.$content.css("margin-bottom",n))},revealContent:function(t){var e,o,i,a,s=this,r=t.$slide,c=!1,l=!1,d=s.isMoved(t),u=t.isRevealed;return t.isRevealed=!0,e=t.opts[s.firstRun?"animationEffect":"transitionEffect"],i=t.opts[s.firstRun?"animationDuration":"transitionDuration"],i=parseInt(void 0===t.forcedDuration?i:t.forcedDuration,10),!d&&t.pos===s.currPos&&i||(e=!1),"zoom"===e&&(t.pos===s.currPos&&i&&"image"===t.type&&!t.hasError&&(l=s.getThumbPos(t))?c=s.getFitPos(t):e="fade"),"zoom"===e?(s.isAnimating=!0,c.scaleX=c.width/l.width,c.scaleY=c.height/l.height,a=t.opts.zoomOpacity,"auto"==a&&(a=Math.abs(t.width/t.height-l.width/l.height)>.1),a&&(l.opacity=.1,c.opacity=1),n.fancybox.setTranslate(t.$content.removeClass("fancybox-is-hidden"),l),p(t.$content),void n.fancybox.animate(t.$content,c,i,function(){s.isAnimating=!1,s.complete()})):(s.updateSlide(t),e?(n.fancybox.stop(r),o="fancybox-slide--"+(t.pos>=s.prevPos?"next":"previous")+" fancybox-animated fancybox-fx-"+e,r.addClass(o).removeClass("fancybox-slide--current"),t.$content.removeClass("fancybox-is-hidden"),p(r),"image"!==t.type&&t.$content.hide().show(0),void n.fancybox.animate(r,"fancybox-slide--current",i,function(){r.removeClass(o).css({transform:"",opacity:""}),t.pos===s.currPos&&s.complete()},!0)):(t.$content.removeClass("fancybox-is-hidden"),u||!d||"image"!==t.type||t.hasError||t.$content.hide().fadeIn("fast"),void(t.pos===s.currPos&&s.complete())))},getThumbPos:function(t){var e,o,i,a,s,r=!1,c=t.$thumb;return!(!c||!g(c[0]))&&(e=n.fancybox.getTranslate(c),o=parseFloat(c.css("border-top-width")||0),i=parseFloat(c.css("border-right-width")||0),a=parseFloat(c.css("border-bottom-width")||0),s=parseFloat(c.css("border-left-width")||0),r={top:e.top+o,left:e.left+s,width:e.width-i-s,height:e.height-o-a,scaleX:1,scaleY:1},e.width>0&&e.height>0&&r)},complete:function(){var t,e=this,o=e.current,i={};!e.isMoved()&&o.isLoaded&&(o.isComplete||(o.isComplete=!0,o.$slide.siblings().trigger("onReset"),e.preload("inline"),p(o.$slide),o.$slide.addClass("fancybox-slide--complete"),n.each(e.slides,function(t,o){o.pos>=e.currPos-1&&o.pos<=e.currPos+1?i[o.pos]=o:o&&(n.fancybox.stop(o.$slide),o.$slide.off().remove())}),e.slides=i),e.isAnimating=!1,e.updateCursor(),e.trigger("afterShow"),o.opts.video.autoStart&&o.$slide.find("video,audio").filter(":visible:first").trigger("play").one("ended",function(){Document.exitFullscreen?Document.exitFullscreen():this.webkitExitFullscreen&&this.webkitExitFullscreen(),e.next()}),o.opts.autoFocus&&"html"===o.contentType&&(t=o.$content.find("input[autofocus]:enabled:visible:first"),t.length?t.trigger("focus"):e.focus(null,!0)),o.$slide.scrollTop(0).scrollLeft(0))},preload:function(t){var e,n,o=this;o.group.length<2||(n=o.slides[o.currPos+1],e=o.slides[o.currPos-1],e&&e.type===t&&o.loadSlide(e),n&&n.type===t&&o.loadSlide(n))},focus:function(t,o){var i,a,s=this,r=["a[href]","area[href]",'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',"select:not([disabled]):not([aria-hidden])","textarea:not([disabled]):not([aria-hidden])","button:not([disabled]):not([aria-hidden])","iframe","object","embed","video","audio","[contenteditable]",'[tabindex]:not([tabindex^="-"])'].join(",");s.isClosing||(i=!t&&s.current&&s.current.isComplete?s.current.$slide.find("*:visible"+(o?":not(.fancybox-close-small)":"")):s.$refs.container.find("*:visible"),i=i.filter(r).filter(function(){return"hidden"!==n(this).css("visibility")&&!n(this).hasClass("disabled")}),i.length?(a=i.index(e.activeElement),t&&t.shiftKey?(a<0||0==a)&&(t.preventDefault(),i.eq(i.length-1).trigger("focus")):(a<0||a==i.length-1)&&(t&&t.preventDefault(),i.eq(0).trigger("focus"))):s.$refs.container.trigger("focus"))},activate:function(){var t=this;n(".fancybox-container").each(function(){var e=n(this).data("FancyBox");e&&e.id!==t.id&&!e.isClosing&&(e.trigger("onDeactivate"),e.removeEvents(),e.isVisible=!1)}),t.isVisible=!0,(t.current||t.isIdle)&&(t.update(),t.updateControls()),t.trigger("onActivate"),t.addEvents()},close:function(t,e){var o,i,a,s,r,c,l,u=this,f=u.current,h=function(){u.cleanUp(t)};return!u.isClosing&&(u.isClosing=!0,!1===u.trigger("beforeClose",t)?(u.isClosing=!1,d(function(){u.update()}),!1):(u.removeEvents(),a=f.$content,o=f.opts.animationEffect,i=n.isNumeric(e)?e:o?f.opts.animationDuration:0,f.$slide.removeClass("fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated"),!0!==t?n.fancybox.stop(f.$slide):o=!1,f.$slide.siblings().trigger("onReset").remove(),i&&u.$refs.container.removeClass("fancybox-is-open").addClass("fancybox-is-closing").css("transition-duration",i+"ms"),u.hideLoading(f),u.hideControls(!0),u.updateCursor(),"zoom"!==o||a&&i&&"image"===f.type&&!u.isMoved()&&!f.hasError&&(l=u.getThumbPos(f))||(o="fade"),"zoom"===o?(n.fancybox.stop(a),s=n.fancybox.getTranslate(a),c={top:s.top,left:s.left,scaleX:s.width/l.width,scaleY:s.height/l.height,width:l.width,height:l.height},r=f.opts.zoomOpacity,
"auto"==r&&(r=Math.abs(f.width/f.height-l.width/l.height)>.1),r&&(l.opacity=0),n.fancybox.setTranslate(a,c),p(a),n.fancybox.animate(a,l,i,h),!0):(o&&i?n.fancybox.animate(f.$slide.addClass("fancybox-slide--previous").removeClass("fancybox-slide--current"),"fancybox-animated fancybox-fx-"+o,i,h):!0===t?setTimeout(h,i):h(),!0)))},cleanUp:function(e){var o,i,a,s=this,r=s.current.opts.$orig;s.current.$slide.trigger("onReset"),s.$refs.container.empty().remove(),s.trigger("afterClose",e),s.current.opts.backFocus&&(r&&r.length&&r.is(":visible")||(r=s.$trigger),r&&r.length&&(i=t.scrollX,a=t.scrollY,r.trigger("focus"),n("html, body").scrollTop(a).scrollLeft(i))),s.current=null,o=n.fancybox.getInstance(),o?o.activate():(n("body").removeClass("fancybox-active compensate-for-scrollbar"),n("#fancybox-style-noscroll").remove())},trigger:function(t,e){var o,i=Array.prototype.slice.call(arguments,1),a=this,s=e&&e.opts?e:a.current;if(s?i.unshift(s):s=a,i.unshift(a),n.isFunction(s.opts[t])&&(o=s.opts[t].apply(s,i)),!1===o)return o;"afterClose"!==t&&a.$refs?a.$refs.container.trigger(t+".fb",i):r.trigger(t+".fb",i)},updateControls:function(){var t=this,o=t.current,i=o.index,a=t.$refs.container,s=t.$refs.caption,r=o.opts.caption;o.$slide.trigger("refresh"),r&&r.length?(t.$caption=s,s.children().eq(0).html(r)):t.$caption=null,t.hasHiddenControls||t.isIdle||t.showControls(),a.find("[data-fancybox-count]").html(t.group.length),a.find("[data-fancybox-index]").html(i+1),a.find("[data-fancybox-prev]").prop("disabled",!o.opts.loop&&i<=0),a.find("[data-fancybox-next]").prop("disabled",!o.opts.loop&&i>=t.group.length-1),"image"===o.type?a.find("[data-fancybox-zoom]").show().end().find("[data-fancybox-download]").attr("href",o.opts.image.src||o.src).show():o.opts.toolbar&&a.find("[data-fancybox-download],[data-fancybox-zoom]").hide(),n(e.activeElement).is(":hidden,[disabled]")&&t.$refs.container.trigger("focus")},hideControls:function(t){var e=this,n=["infobar","toolbar","nav"];!t&&e.current.opts.preventCaptionOverlap||n.push("caption"),this.$refs.container.removeClass(n.map(function(t){return"fancybox-show-"+t}).join(" ")),this.hasHiddenControls=!0},showControls:function(){var t=this,e=t.current?t.current.opts:t.opts,n=t.$refs.container;t.hasHiddenControls=!1,t.idleSecondsCounter=0,n.toggleClass("fancybox-show-toolbar",!(!e.toolbar||!e.buttons)).toggleClass("fancybox-show-infobar",!!(e.infobar&&t.group.length>1)).toggleClass("fancybox-show-caption",!!t.$caption).toggleClass("fancybox-show-nav",!!(e.arrows&&t.group.length>1)).toggleClass("fancybox-is-modal",!!e.modal)},toggleControls:function(){this.hasHiddenControls?this.showControls():this.hideControls()}}),n.fancybox={version:"3.5.7",defaults:a,getInstance:function(t){var e=n('.fancybox-container:not(".fancybox-is-closing"):last').data("FancyBox"),o=Array.prototype.slice.call(arguments,1);return e instanceof b&&("string"===n.type(t)?e[t].apply(e,o):"function"===n.type(t)&&t.apply(e,o),e)},open:function(t,e,n){return new b(t,e,n)},close:function(t){var e=this.getInstance();e&&(e.close(),!0===t&&this.close(t))},destroy:function(){this.close(!0),r.add("body").off("click.fb-start","**")},isMobile:/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),use3d:function(){var n=e.createElement("div");return t.getComputedStyle&&t.getComputedStyle(n)&&t.getComputedStyle(n).getPropertyValue("transform")&&!(e.documentMode&&e.documentMode<11)}(),getTranslate:function(t){var e;return!(!t||!t.length)&&(e=t[0].getBoundingClientRect(),{top:e.top||0,left:e.left||0,width:e.width,height:e.height,opacity:parseFloat(t.css("opacity"))})},setTranslate:function(t,e){var n="",o={};if(t&&e)return void 0===e.left&&void 0===e.top||(n=(void 0===e.left?t.position().left:e.left)+"px, "+(void 0===e.top?t.position().top:e.top)+"px",n=this.use3d?"translate3d("+n+", 0px)":"translate("+n+")"),void 0!==e.scaleX&&void 0!==e.scaleY?n+=" scale("+e.scaleX+", "+e.scaleY+")":void 0!==e.scaleX&&(n+=" scaleX("+e.scaleX+")"),n.length&&(o.transform=n),void 0!==e.opacity&&(o.opacity=e.opacity),void 0!==e.width&&(o.width=e.width),void 0!==e.height&&(o.height=e.height),t.css(o)},animate:function(t,e,o,i,a){var s,r=this;n.isFunction(o)&&(i=o,o=null),r.stop(t),s=r.getTranslate(t),t.on(f,function(c){(!c||!c.originalEvent||t.is(c.originalEvent.target)&&"z-index"!=c.originalEvent.propertyName)&&(r.stop(t),n.isNumeric(o)&&t.css("transition-duration",""),n.isPlainObject(e)?void 0!==e.scaleX&&void 0!==e.scaleY&&r.setTranslate(t,{top:e.top,left:e.left,width:s.width*e.scaleX,height:s.height*e.scaleY,scaleX:1,scaleY:1}):!0!==a&&t.removeClass(e),n.isFunction(i)&&i(c))}),n.isNumeric(o)&&t.css("transition-duration",o+"ms"),n.isPlainObject(e)?(void 0!==e.scaleX&&void 0!==e.scaleY&&(delete e.width,delete e.height,t.parent().hasClass("fancybox-slide--image")&&t.parent().addClass("fancybox-is-scaling")),n.fancybox.setTranslate(t,e)):t.addClass(e),t.data("timer",setTimeout(function(){t.trigger(f)},o+33))},stop:function(t,e){t&&t.length&&(clearTimeout(t.data("timer")),e&&t.trigger(f),t.off(f).css("transition-duration",""),t.parent().removeClass("fancybox-is-scaling"))}},n.fn.fancybox=function(t){var e;return t=t||{},e=t.selector||!1,e?n("body").off("click.fb-start",e).on("click.fb-start",e,{options:t},i):this.off("click.fb-start").on("click.fb-start",{items:this,options:t},i),this},r.on("click.fb-start","[data-fancybox]",i),r.on("click.fb-start","[data-fancybox-trigger]",function(t){n('[data-fancybox="'+n(this).attr("data-fancybox-trigger")+'"]').eq(n(this).attr("data-fancybox-index")||0).trigger("click.fb-start",{$trigger:n(this)})}),function(){var t=null;r.on("mousedown mouseup focus blur",".fancybox-button",function(e){switch(e.type){case"mousedown":t=n(this);break;case"mouseup":t=null;break;case"focusin":n(".fancybox-button").removeClass("fancybox-focus"),n(this).is(t)||n(this).is("[disabled]")||n(this).addClass("fancybox-focus");break;case"focusout":n(".fancybox-button").removeClass("fancybox-focus")}})}()}}(window,document,jQuery),function(t){"use strict";var e={youtube:{matcher:/(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(watch\?(.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(.*)|[\w-]{11}|\?listType=(.*)&list=(.*))(.*)/i,params:{autoplay:1,autohide:1,fs:1,rel:0,hd:1,wmode:"transparent",enablejsapi:1,html5:1},paramPlace:8,type:"iframe",url:"https://www.youtube-nocookie.com/embed/$4",thumb:"https://img.youtube.com/vi/$4/hqdefault.jpg"},vimeo:{matcher:/^.+vimeo.com\/(.*\/)?([\d]+)(.*)?/,params:{autoplay:1,hd:1,show_title:1,show_byline:1,show_portrait:0,fullscreen:1},paramPlace:3,type:"iframe",url:"//player.vimeo.com/video/$2"},instagram:{matcher:/(instagr\.am|instagram\.com)\/p\/([a-zA-Z0-9_\-]+)\/?/i,type:"image",url:"//$1/p/$2/media/?size=l"},gmap_place:{matcher:/(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(((maps\/(place\/(.*)\/)?\@(.*),(\d+.?\d+?)z))|(\?ll=))(.*)?/i,type:"iframe",url:function(t){return"//maps.google."+t[2]+"/?ll="+(t[9]?t[9]+"&z="+Math.floor(t[10])+(t[12]?t[12].replace(/^\//,"&"):""):t[12]+"").replace(/\?/,"&")+"&output="+(t[12]&&t[12].indexOf("layer=c")>0?"svembed":"embed")}},gmap_search:{matcher:/(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(maps\/search\/)(.*)/i,type:"iframe",url:function(t){return"//maps.google."+t[2]+"/maps?q="+t[5].replace("query=","q=").replace("api=1","")+"&output=embed"}}},n=function(e,n,o){if(e)return o=o||"","object"===t.type(o)&&(o=t.param(o,!0)),t.each(n,function(t,n){e=e.replace("$"+t,n||"")}),o.length&&(e+=(e.indexOf("?")>0?"&":"?")+o),e};t(document).on("objectNeedsType.fb",function(o,i,a){var s,r,c,l,d,u,f,p=a.src||"",h=!1;s=t.extend(!0,{},e,a.opts.media),t.each(s,function(e,o){if(c=p.match(o.matcher)){if(h=o.type,f=e,u={},o.paramPlace&&c[o.paramPlace]){d=c[o.paramPlace],"?"==d[0]&&(d=d.substring(1)),d=d.split("&");for(var i=0;i<d.length;++i){var s=d[i].split("=",2);2==s.length&&(u[s[0]]=decodeURIComponent(s[1].replace(/\+/g," ")))}}return l=t.extend(!0,{},o.params,a.opts[e],u),p="function"===t.type(o.url)?o.url.call(this,c,l,a):n(o.url,c,l),r="function"===t.type(o.thumb)?o.thumb.call(this,c,l,a):n(o.thumb,c),"youtube"===e?p=p.replace(/&t=((\d+)m)?(\d+)s/,function(t,e,n,o){return"&start="+((n?60*parseInt(n,10):0)+parseInt(o,10))}):"vimeo"===e&&(p=p.replace("&%23","#")),!1}}),h?(a.opts.thumb||a.opts.$thumb&&a.opts.$thumb.length||(a.opts.thumb=r),"iframe"===h&&(a.opts=t.extend(!0,a.opts,{iframe:{preload:!1,attr:{scrolling:"no"}}})),t.extend(a,{type:h,src:p,origSrc:a.src,contentSource:f,contentType:"image"===h?"image":"gmap_place"==f||"gmap_search"==f?"map":"video"})):p&&(a.type=a.opts.defaultType)});var o={youtube:{src:"https://www.youtube.com/iframe_api",class:"YT",loading:!1,loaded:!1},vimeo:{src:"https://player.vimeo.com/api/player.js",class:"Vimeo",loading:!1,loaded:!1},load:function(t){var e,n=this;if(this[t].loaded)return void setTimeout(function(){n.done(t)});this[t].loading||(this[t].loading=!0,e=document.createElement("script"),e.type="text/javascript",e.src=this[t].src,"youtube"===t?window.onYouTubeIframeAPIReady=function(){n[t].loaded=!0,n.done(t)}:e.onload=function(){n[t].loaded=!0,n.done(t)},document.body.appendChild(e))},done:function(e){var n,o,i;"youtube"===e&&delete window.onYouTubeIframeAPIReady,(n=t.fancybox.getInstance())&&(o=n.current.$content.find("iframe"),"youtube"===e&&void 0!==YT&&YT?i=new YT.Player(o.attr("id"),{events:{onStateChange:function(t){0==t.data&&n.next()}}}):"vimeo"===e&&void 0!==Vimeo&&Vimeo&&(i=new Vimeo.Player(o),i.on("ended",function(){n.next()})))}};t(document).on({"afterShow.fb":function(t,e,n){e.group.length>1&&("youtube"===n.contentSource||"vimeo"===n.contentSource)&&o.load(n.contentSource)}})}(jQuery),function(t,e,n){"use strict";var o=function(){return t.requestAnimationFrame||t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||t.oRequestAnimationFrame||function(e){return t.setTimeout(e,1e3/60)}}(),i=function(){return t.cancelAnimationFrame||t.webkitCancelAnimationFrame||t.mozCancelAnimationFrame||t.oCancelAnimationFrame||function(e){t.clearTimeout(e)}}(),a=function(e){var n=[];e=e.originalEvent||e||t.e,e=e.touches&&e.touches.length?e.touches:e.changedTouches&&e.changedTouches.length?e.changedTouches:[e];for(var o in e)e[o].pageX?n.push({x:e[o].pageX,y:e[o].pageY}):e[o].clientX&&n.push({x:e[o].clientX,y:e[o].clientY});return n},s=function(t,e,n){return e&&t?"x"===n?t.x-e.x:"y"===n?t.y-e.y:Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2)):0},r=function(t){if(t.is('a,area,button,[role="button"],input,label,select,summary,textarea,video,audio,iframe')||n.isFunction(t.get(0).onclick)||t.data("selectable"))return!0;for(var e=0,o=t[0].attributes,i=o.length;e<i;e++)if("data-fancybox-"===o[e].nodeName.substr(0,14))return!0;return!1},c=function(e){var n=t.getComputedStyle(e)["overflow-y"],o=t.getComputedStyle(e)["overflow-x"],i=("scroll"===n||"auto"===n)&&e.scrollHeight>e.clientHeight,a=("scroll"===o||"auto"===o)&&e.scrollWidth>e.clientWidth;return i||a},l=function(t){for(var e=!1;;){if(e=c(t.get(0)))break;if(t=t.parent(),!t.length||t.hasClass("fancybox-stage")||t.is("body"))break}return e},d=function(t){var e=this;e.instance=t,e.$bg=t.$refs.bg,e.$stage=t.$refs.stage,e.$container=t.$refs.container,e.destroy(),e.$container.on("touchstart.fb.touch mousedown.fb.touch",n.proxy(e,"ontouchstart"))};d.prototype.destroy=function(){var t=this;t.$container.off(".fb.touch"),n(e).off(".fb.touch"),t.requestId&&(i(t.requestId),t.requestId=null),t.tapped&&(clearTimeout(t.tapped),t.tapped=null)},d.prototype.ontouchstart=function(o){var i=this,c=n(o.target),d=i.instance,u=d.current,f=u.$slide,p=u.$content,h="touchstart"==o.type;if(h&&i.$container.off("mousedown.fb.touch"),(!o.originalEvent||2!=o.originalEvent.button)&&f.length&&c.length&&!r(c)&&!r(c.parent())&&(c.is("img")||!(o.originalEvent.clientX>c[0].clientWidth+c.offset().left))){if(!u||d.isAnimating||u.$slide.hasClass("fancybox-animated"))return o.stopPropagation(),void o.preventDefault();i.realPoints=i.startPoints=a(o),i.startPoints.length&&(u.touch&&o.stopPropagation(),i.startEvent=o,i.canTap=!0,i.$target=c,i.$content=p,i.opts=u.opts.touch,i.isPanning=!1,i.isSwiping=!1,i.isZooming=!1,i.isScrolling=!1,i.canPan=d.canPan(),i.startTime=(new Date).getTime(),i.distanceX=i.distanceY=i.distance=0,i.canvasWidth=Math.round(f[0].clientWidth),i.canvasHeight=Math.round(f[0].clientHeight),i.contentLastPos=null,i.contentStartPos=n.fancybox.getTranslate(i.$content)||{top:0,left:0},i.sliderStartPos=n.fancybox.getTranslate(f),i.stagePos=n.fancybox.getTranslate(d.$refs.stage),i.sliderStartPos.top-=i.stagePos.top,i.sliderStartPos.left-=i.stagePos.left,i.contentStartPos.top-=i.stagePos.top,i.contentStartPos.left-=i.stagePos.left,n(e).off(".fb.touch").on(h?"touchend.fb.touch touchcancel.fb.touch":"mouseup.fb.touch mouseleave.fb.touch",n.proxy(i,"ontouchend")).on(h?"touchmove.fb.touch":"mousemove.fb.touch",n.proxy(i,"ontouchmove")),n.fancybox.isMobile&&e.addEventListener("scroll",i.onscroll,!0),((i.opts||i.canPan)&&(c.is(i.$stage)||i.$stage.find(c).length)||(c.is(".fancybox-image")&&o.preventDefault(),n.fancybox.isMobile&&c.parents(".fancybox-caption").length))&&(i.isScrollable=l(c)||l(c.parent()),n.fancybox.isMobile&&i.isScrollable||o.preventDefault(),(1===i.startPoints.length||u.hasError)&&(i.canPan?(n.fancybox.stop(i.$content),i.isPanning=!0):i.isSwiping=!0,i.$container.addClass("fancybox-is-grabbing")),2===i.startPoints.length&&"image"===u.type&&(u.isLoaded||u.$ghost)&&(i.canTap=!1,i.isSwiping=!1,i.isPanning=!1,i.isZooming=!0,n.fancybox.stop(i.$content),i.centerPointStartX=.5*(i.startPoints[0].x+i.startPoints[1].x)-n(t).scrollLeft(),i.centerPointStartY=.5*(i.startPoints[0].y+i.startPoints[1].y)-n(t).scrollTop(),i.percentageOfImageAtPinchPointX=(i.centerPointStartX-i.contentStartPos.left)/i.contentStartPos.width,i.percentageOfImageAtPinchPointY=(i.centerPointStartY-i.contentStartPos.top)/i.contentStartPos.height,i.startDistanceBetweenFingers=s(i.startPoints[0],i.startPoints[1]))))}},d.prototype.onscroll=function(t){var n=this;n.isScrolling=!0,e.removeEventListener("scroll",n.onscroll,!0)},d.prototype.ontouchmove=function(t){var e=this;return void 0!==t.originalEvent.buttons&&0===t.originalEvent.buttons?void e.ontouchend(t):e.isScrolling?void(e.canTap=!1):(e.newPoints=a(t),void((e.opts||e.canPan)&&e.newPoints.length&&e.newPoints.length&&(e.isSwiping&&!0===e.isSwiping||t.preventDefault(),e.distanceX=s(e.newPoints[0],e.startPoints[0],"x"),e.distanceY=s(e.newPoints[0],e.startPoints[0],"y"),e.distance=s(e.newPoints[0],e.startPoints[0]),e.distance>0&&(e.isSwiping?e.onSwipe(t):e.isPanning?e.onPan():e.isZooming&&e.onZoom()))))},d.prototype.onSwipe=function(e){var a,s=this,r=s.instance,c=s.isSwiping,l=s.sliderStartPos.left||0;if(!0!==c)"x"==c&&(s.distanceX>0&&(s.instance.group.length<2||0===s.instance.current.index&&!s.instance.current.opts.loop)?l+=Math.pow(s.distanceX,.8):s.distanceX<0&&(s.instance.group.length<2||s.instance.current.index===s.instance.group.length-1&&!s.instance.current.opts.loop)?l-=Math.pow(-s.distanceX,.8):l+=s.distanceX),s.sliderLastPos={top:"x"==c?0:s.sliderStartPos.top+s.distanceY,left:l},s.requestId&&(i(s.requestId),s.requestId=null),s.requestId=o(function(){s.sliderLastPos&&(n.each(s.instance.slides,function(t,e){var o=e.pos-s.instance.currPos;n.fancybox.setTranslate(e.$slide,{top:s.sliderLastPos.top,left:s.sliderLastPos.left+o*s.canvasWidth+o*e.opts.gutter})}),s.$container.addClass("fancybox-is-sliding"))});else if(Math.abs(s.distance)>10){if(s.canTap=!1,r.group.length<2&&s.opts.vertical?s.isSwiping="y":r.isDragging||!1===s.opts.vertical||"auto"===s.opts.vertical&&n(t).width()>800?s.isSwiping="x":(a=Math.abs(180*Math.atan2(s.distanceY,s.distanceX)/Math.PI),s.isSwiping=a>45&&a<135?"y":"x"),"y"===s.isSwiping&&n.fancybox.isMobile&&s.isScrollable)return void(s.isScrolling=!0);r.isDragging=s.isSwiping,s.startPoints=s.newPoints,n.each(r.slides,function(t,e){var o,i;n.fancybox.stop(e.$slide),o=n.fancybox.getTranslate(e.$slide),i=n.fancybox.getTranslate(r.$refs.stage),e.$slide.css({transform:"",opacity:"","transition-duration":""}).removeClass("fancybox-animated").removeClass(function(t,e){return(e.match(/(^|\s)fancybox-fx-\S+/g)||[]).join(" ")}),e.pos===r.current.pos&&(s.sliderStartPos.top=o.top-i.top,s.sliderStartPos.left=o.left-i.left),n.fancybox.setTranslate(e.$slide,{top:o.top-i.top,left:o.left-i.left})}),r.SlideShow&&r.SlideShow.isActive&&r.SlideShow.stop()}},d.prototype.onPan=function(){var t=this;if(s(t.newPoints[0],t.realPoints[0])<(n.fancybox.isMobile?10:5))return void(t.startPoints=t.newPoints);t.canTap=!1,t.contentLastPos=t.limitMovement(),t.requestId&&i(t.requestId),t.requestId=o(function(){n.fancybox.setTranslate(t.$content,t.contentLastPos)})},d.prototype.limitMovement=function(){var t,e,n,o,i,a,s=this,r=s.canvasWidth,c=s.canvasHeight,l=s.distanceX,d=s.distanceY,u=s.contentStartPos,f=u.left,p=u.top,h=u.width,g=u.height;return i=h>r?f+l:f,a=p+d,t=Math.max(0,.5*r-.5*h),e=Math.max(0,.5*c-.5*g),n=Math.min(r-h,.5*r-.5*h),o=Math.min(c-g,.5*c-.5*g),l>0&&i>t&&(i=t-1+Math.pow(-t+f+l,.8)||0),l<0&&i<n&&(i=n+1-Math.pow(n-f-l,.8)||0),d>0&&a>e&&(a=e-1+Math.pow(-e+p+d,.8)||0),d<0&&a<o&&(a=o+1-Math.pow(o-p-d,.8)||0),{top:a,left:i}},d.prototype.limitPosition=function(t,e,n,o){var i=this,a=i.canvasWidth,s=i.canvasHeight;return n>a?(t=t>0?0:t,t=t<a-n?a-n:t):t=Math.max(0,a/2-n/2),o>s?(e=e>0?0:e,e=e<s-o?s-o:e):e=Math.max(0,s/2-o/2),{top:e,left:t}},d.prototype.onZoom=function(){var e=this,a=e.contentStartPos,r=a.width,c=a.height,l=a.left,d=a.top,u=s(e.newPoints[0],e.newPoints[1]),f=u/e.startDistanceBetweenFingers,p=Math.floor(r*f),h=Math.floor(c*f),g=(r-p)*e.percentageOfImageAtPinchPointX,b=(c-h)*e.percentageOfImageAtPinchPointY,m=(e.newPoints[0].x+e.newPoints[1].x)/2-n(t).scrollLeft(),v=(e.newPoints[0].y+e.newPoints[1].y)/2-n(t).scrollTop(),y=m-e.centerPointStartX,x=v-e.centerPointStartY,w=l+(g+y),$=d+(b+x),S={top:$,left:w,scaleX:f,scaleY:f};e.canTap=!1,e.newWidth=p,e.newHeight=h,e.contentLastPos=S,e.requestId&&i(e.requestId),e.requestId=o(function(){n.fancybox.setTranslate(e.$content,e.contentLastPos)})},d.prototype.ontouchend=function(t){var o=this,s=o.isSwiping,r=o.isPanning,c=o.isZooming,l=o.isScrolling;if(o.endPoints=a(t),o.dMs=Math.max((new Date).getTime()-o.startTime,1),o.$container.removeClass("fancybox-is-grabbing"),n(e).off(".fb.touch"),e.removeEventListener("scroll",o.onscroll,!0),o.requestId&&(i(o.requestId),o.requestId=null),o.isSwiping=!1,o.isPanning=!1,o.isZooming=!1,o.isScrolling=!1,o.instance.isDragging=!1,o.canTap)return o.onTap(t);o.speed=100,o.velocityX=o.distanceX/o.dMs*.5,o.velocityY=o.distanceY/o.dMs*.5,r?o.endPanning():c?o.endZooming():o.endSwiping(s,l)},d.prototype.endSwiping=function(t,e){var o=this,i=!1,a=o.instance.group.length,s=Math.abs(o.distanceX),r="x"==t&&a>1&&(o.dMs>130&&s>10||s>50);o.sliderLastPos=null,"y"==t&&!e&&Math.abs(o.distanceY)>50?(n.fancybox.animate(o.instance.current.$slide,{top:o.sliderStartPos.top+o.distanceY+150*o.velocityY,opacity:0},200),i=o.instance.close(!0,250)):r&&o.distanceX>0?i=o.instance.previous(300):r&&o.distanceX<0&&(i=o.instance.next(300)),!1!==i||"x"!=t&&"y"!=t||o.instance.centerSlide(200),o.$container.removeClass("fancybox-is-sliding")},d.prototype.endPanning=function(){var t,e,o,i=this;i.contentLastPos&&(!1===i.opts.momentum||i.dMs>350?(t=i.contentLastPos.left,e=i.contentLastPos.top):(t=i.contentLastPos.left+500*i.velocityX,e=i.contentLastPos.top+500*i.velocityY),o=i.limitPosition(t,e,i.contentStartPos.width,i.contentStartPos.height),o.width=i.contentStartPos.width,o.height=i.contentStartPos.height,n.fancybox.animate(i.$content,o,366))},d.prototype.endZooming=function(){var t,e,o,i,a=this,s=a.instance.current,r=a.newWidth,c=a.newHeight;a.contentLastPos&&(t=a.contentLastPos.left,e=a.contentLastPos.top,i={top:e,left:t,width:r,height:c,scaleX:1,scaleY:1},n.fancybox.setTranslate(a.$content,i),r<a.canvasWidth&&c<a.canvasHeight?a.instance.scaleToFit(150):r>s.width||c>s.height?a.instance.scaleToActual(a.centerPointStartX,a.centerPointStartY,150):(o=a.limitPosition(t,e,r,c),n.fancybox.animate(a.$content,o,150)))},d.prototype.onTap=function(e){var o,i=this,s=n(e.target),r=i.instance,c=r.current,l=e&&a(e)||i.startPoints,d=l[0]?l[0].x-n(t).scrollLeft()-i.stagePos.left:0,u=l[0]?l[0].y-n(t).scrollTop()-i.stagePos.top:0,f=function(t){var o=c.opts[t];if(n.isFunction(o)&&(o=o.apply(r,[c,e])),o)switch(o){case"close":r.close(i.startEvent);break;case"toggleControls":r.toggleControls();break;case"next":r.next();break;case"nextOrClose":r.group.length>1?r.next():r.close(i.startEvent);break;case"zoom":"image"==c.type&&(c.isLoaded||c.$ghost)&&(r.canPan()?r.scaleToFit():r.isScaledDown()?r.scaleToActual(d,u):r.group.length<2&&r.close(i.startEvent))}};if((!e.originalEvent||2!=e.originalEvent.button)&&(s.is("img")||!(d>s[0].clientWidth+s.offset().left))){if(s.is(".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container"))o="Outside";else if(s.is(".fancybox-slide"))o="Slide";else{if(!r.current.$content||!r.current.$content.find(s).addBack().filter(s).length)return;o="Content"}if(i.tapped){if(clearTimeout(i.tapped),i.tapped=null,Math.abs(d-i.tapX)>50||Math.abs(u-i.tapY)>50)return this;f("dblclick"+o)}else i.tapX=d,i.tapY=u,c.opts["dblclick"+o]&&c.opts["dblclick"+o]!==c.opts["click"+o]?i.tapped=setTimeout(function(){i.tapped=null,r.isAnimating||f("click"+o)},500):f("click"+o);return this}},n(e).on("onActivate.fb",function(t,e){e&&!e.Guestures&&(e.Guestures=new d(e))}).on("beforeClose.fb",function(t,e){e&&e.Guestures&&e.Guestures.destroy()})}(window,document,jQuery),function(t,e){"use strict";e.extend(!0,e.fancybox.defaults,{btnTpl:{slideShow:'<button data-fancybox-play class="fancybox-button fancybox-button--play" title="{{PLAY_START}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.5 5.4v13.2l11-6.6z"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.33 5.75h2.2v12.5h-2.2V5.75zm5.15 0h2.2v12.5h-2.2V5.75z"/></svg></button>'},slideShow:{autoStart:!1,speed:3e3,progress:!0}});var n=function(t){this.instance=t,this.init()};e.extend(n.prototype,{timer:null,isActive:!1,$button:null,init:function(){var t=this,n=t.instance,o=n.group[n.currIndex].opts.slideShow;t.$button=n.$refs.toolbar.find("[data-fancybox-play]").on("click",function(){t.toggle()}),n.group.length<2||!o?t.$button.hide():o.progress&&(t.$progress=e('<div class="fancybox-progress"></div>').appendTo(n.$refs.inner))},set:function(t){var n=this,o=n.instance,i=o.current;i&&(!0===t||i.opts.loop||o.currIndex<o.group.length-1)?n.isActive&&"video"!==i.contentType&&(n.$progress&&e.fancybox.animate(n.$progress.show(),{scaleX:1},i.opts.slideShow.speed),n.timer=setTimeout(function(){o.current.opts.loop||o.current.index!=o.group.length-1?o.next():o.jumpTo(0)},i.opts.slideShow.speed)):(n.stop(),o.idleSecondsCounter=0,o.showControls())},clear:function(){var t=this;clearTimeout(t.timer),t.timer=null,t.$progress&&t.$progress.removeAttr("style").hide()},start:function(){var t=this,e=t.instance.current;e&&(t.$button.attr("title",(e.opts.i18n[e.opts.lang]||e.opts.i18n.en).PLAY_STOP).removeClass("fancybox-button--play").addClass("fancybox-button--pause"),t.isActive=!0,e.isComplete&&t.set(!0),t.instance.trigger("onSlideShowChange",!0))},stop:function(){var t=this,e=t.instance.current;t.clear(),t.$button.attr("title",(e.opts.i18n[e.opts.lang]||e.opts.i18n.en).PLAY_START).removeClass("fancybox-button--pause").addClass("fancybox-button--play"),t.isActive=!1,t.instance.trigger("onSlideShowChange",!1),t.$progress&&t.$progress.removeAttr("style").hide()},toggle:function(){var t=this;t.isActive?t.stop():t.start()}}),e(t).on({"onInit.fb":function(t,e){e&&!e.SlideShow&&(e.SlideShow=new n(e))},"beforeShow.fb":function(t,e,n,o){var i=e&&e.SlideShow;o?i&&n.opts.slideShow.autoStart&&i.start():i&&i.isActive&&i.clear()},"afterShow.fb":function(t,e,n){var o=e&&e.SlideShow;o&&o.isActive&&o.set()},"afterKeydown.fb":function(n,o,i,a,s){var r=o&&o.SlideShow;!r||!i.opts.slideShow||80!==s&&32!==s||e(t.activeElement).is("button,a,input")||(a.preventDefault(),r.toggle())},"beforeClose.fb onDeactivate.fb":function(t,e){var n=e&&e.SlideShow;n&&n.stop()}}),e(t).on("visibilitychange",function(){var n=e.fancybox.getInstance(),o=n&&n.SlideShow;o&&o.isActive&&(t.hidden?o.clear():o.set())})}(document,jQuery),function(t,e){"use strict";var n=function(){for(var e=[["requestFullscreen","exitFullscreen","fullscreenElement","fullscreenEnabled","fullscreenchange","fullscreenerror"],["webkitRequestFullscreen","webkitExitFullscreen","webkitFullscreenElement","webkitFullscreenEnabled","webkitfullscreenchange","webkitfullscreenerror"],["webkitRequestFullScreen","webkitCancelFullScreen","webkitCurrentFullScreenElement","webkitCancelFullScreen","webkitfullscreenchange","webkitfullscreenerror"],["mozRequestFullScreen","mozCancelFullScreen","mozFullScreenElement","mozFullScreenEnabled","mozfullscreenchange","mozfullscreenerror"],["msRequestFullscreen","msExitFullscreen","msFullscreenElement","msFullscreenEnabled","MSFullscreenChange","MSFullscreenError"]],n={},o=0;o<e.length;o++){var i=e[o];if(i&&i[1]in t){for(var a=0;a<i.length;a++)n[e[0][a]]=i[a];return n}}return!1}();if(n){var o={request:function(e){e=e||t.documentElement,e[n.requestFullscreen](e.ALLOW_KEYBOARD_INPUT)},exit:function(){t[n.exitFullscreen]()},toggle:function(e){e=e||t.documentElement,this.isFullscreen()?this.exit():this.request(e)},isFullscreen:function(){return Boolean(t[n.fullscreenElement])},enabled:function(){return Boolean(t[n.fullscreenEnabled])}};e.extend(!0,e.fancybox.defaults,{btnTpl:{fullScreen:'<button data-fancybox-fullscreen class="fancybox-button fancybox-button--fsenter" title="{{FULL_SCREEN}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z"/></svg></button>'},fullScreen:{autoStart:!1}}),e(t).on(n.fullscreenchange,function(){var t=o.isFullscreen(),n=e.fancybox.getInstance();n&&(n.current&&"image"===n.current.type&&n.isAnimating&&(n.isAnimating=!1,n.update(!0,!0,0),n.isComplete||n.complete()),n.trigger("onFullscreenChange",t),n.$refs.container.toggleClass("fancybox-is-fullscreen",t),n.$refs.toolbar.find("[data-fancybox-fullscreen]").toggleClass("fancybox-button--fsenter",!t).toggleClass("fancybox-button--fsexit",t))})}e(t).on({"onInit.fb":function(t,e){var i;if(!n)return void e.$refs.toolbar.find("[data-fancybox-fullscreen]").remove();e&&e.group[e.currIndex].opts.fullScreen?(i=e.$refs.container,i.on("click.fb-fullscreen","[data-fancybox-fullscreen]",function(t){t.stopPropagation(),t.preventDefault(),o.toggle()}),e.opts.fullScreen&&!0===e.opts.fullScreen.autoStart&&o.request(),e.FullScreen=o):e&&e.$refs.toolbar.find("[data-fancybox-fullscreen]").hide()},"afterKeydown.fb":function(t,e,n,o,i){e&&e.FullScreen&&70===i&&(o.preventDefault(),e.FullScreen.toggle())},"beforeClose.fb":function(t,e){e&&e.FullScreen&&e.$refs.container.hasClass("fancybox-is-fullscreen")&&o.exit()}})}(document,jQuery),function(t,e){"use strict";var n="fancybox-thumbs";e.fancybox.defaults=e.extend(!0,{btnTpl:{thumbs:'<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.59 14.59h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76H5.65V5.65z"/></svg></button>'},thumbs:{autoStart:!1,hideOnClose:!0,parentEl:".fancybox-container",axis:"y"}},e.fancybox.defaults);var o=function(t){this.init(t)};e.extend(o.prototype,{$button:null,$grid:null,$list:null,isVisible:!1,isActive:!1,init:function(t){var e=this,n=t.group,o=0;e.instance=t,e.opts=n[t.currIndex].opts.thumbs,t.Thumbs=e,e.$button=t.$refs.toolbar.find("[data-fancybox-thumbs]");for(var i=0,a=n.length;i<a&&(n[i].thumb&&o++,!(o>1));i++);o>1&&e.opts?(e.$button.removeAttr("style").on("click",function(){e.toggle()}),e.isActive=!0):e.$button.hide()},create:function(){var t,o=this,i=o.instance,a=o.opts.parentEl,s=[];o.$grid||(o.$grid=e('<div class="'+n+" "+n+"-"+o.opts.axis+'"></div>').appendTo(i.$refs.container.find(a).addBack().filter(a)),o.$grid.on("click","a",function(){i.jumpTo(e(this).attr("data-index"))})),o.$list||(o.$list=e('<div class="'+n+'__list">').appendTo(o.$grid)),e.each(i.group,function(e,n){t=n.thumb,t||"image"!==n.type||(t=n.src),s.push('<a href="javascript:;" tabindex="0" data-index="'+e+'"'+(t&&t.length?' style="background-image:url('+t+')"':'class="fancybox-thumbs-missing"')+"></a>")}),o.$list[0].innerHTML=s.join(""),"x"===o.opts.axis&&o.$list.width(parseInt(o.$grid.css("padding-right"),10)+i.group.length*o.$list.children().eq(0).outerWidth(!0))},focus:function(t){var e,n,o=this,i=o.$list,a=o.$grid;o.instance.current&&(e=i.children().removeClass("fancybox-thumbs-active").filter('[data-index="'+o.instance.current.index+'"]').addClass("fancybox-thumbs-active"),n=e.position(),"y"===o.opts.axis&&(n.top<0||n.top>i.height()-e.outerHeight())?i.stop().animate({scrollTop:i.scrollTop()+n.top},t):"x"===o.opts.axis&&(n.left<a.scrollLeft()||n.left>a.scrollLeft()+(a.width()-e.outerWidth()))&&i.parent().stop().animate({scrollLeft:n.left},t))},update:function(){var t=this;t.instance.$refs.container.toggleClass("fancybox-show-thumbs",this.isVisible),t.isVisible?(t.$grid||t.create(),t.instance.trigger("onThumbsShow"),t.focus(0)):t.$grid&&t.instance.trigger("onThumbsHide"),t.instance.update()},hide:function(){this.isVisible=!1,this.update()},show:function(){this.isVisible=!0,this.update()},toggle:function(){this.isVisible=!this.isVisible,this.update()}}),e(t).on({"onInit.fb":function(t,e){var n;e&&!e.Thumbs&&(n=new o(e),n.isActive&&!0===n.opts.autoStart&&n.show())},"beforeShow.fb":function(t,e,n,o){var i=e&&e.Thumbs;i&&i.isVisible&&i.focus(o?0:250)},"afterKeydown.fb":function(t,e,n,o,i){var a=e&&e.Thumbs;a&&a.isActive&&71===i&&(o.preventDefault(),a.toggle())},"beforeClose.fb":function(t,e){var n=e&&e.Thumbs;n&&n.isVisible&&!1!==n.opts.hideOnClose&&n.$grid.hide()}})}(document,jQuery),function(t,e){"use strict";function n(t){var e={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;","`":"&#x60;","=":"&#x3D;"};return String(t).replace(/[&<>"'`=\/]/g,function(t){return e[t]})}e.extend(!0,e.fancybox.defaults,{btnTpl:{share:'<button data-fancybox-share class="fancybox-button fancybox-button--share" title="{{SHARE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2.55 19c1.4-8.4 9.1-9.8 11.9-9.8V5l7 7-7 6.3v-3.5c-2.8 0-10.5 2.1-11.9 4.2z"/></svg></button>'},share:{url:function(t,e){return!t.currentHash&&"inline"!==e.type&&"html"!==e.type&&(e.origSrc||e.src)||window.location},
tpl:'<div class="fancybox-share"><h1>{{SHARE}}</h1><p><a class="fancybox-share__button fancybox-share__button--fb" href="https://www.facebook.com/sharer/sharer.php?u={{url}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196" /></svg><span>Facebook</span></a><a class="fancybox-share__button fancybox-share__button--tw" href="https://twitter.com/intent/tweet?url={{url}}&text={{descr}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z" /></svg><span>Twitter</span></a><a class="fancybox-share__button fancybox-share__button--pt" href="https://www.pinterest.com/pin/create/button/?url={{url}}&description={{descr}}&media={{media}}"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z" fill="#fff"/></svg><span>Pinterest</span></a></p><p><input class="fancybox-share__input" type="text" value="{{url_raw}}" onclick="select()" /></p></div>'}}),e(t).on("click","[data-fancybox-share]",function(){var t,o,i=e.fancybox.getInstance(),a=i.current||null;a&&("function"===e.type(a.opts.share.url)&&(t=a.opts.share.url.apply(a,[i,a])),o=a.opts.share.tpl.replace(/\{\{media\}\}/g,"image"===a.type?encodeURIComponent(a.src):"").replace(/\{\{url\}\}/g,encodeURIComponent(t)).replace(/\{\{url_raw\}\}/g,n(t)).replace(/\{\{descr\}\}/g,i.$caption?encodeURIComponent(i.$caption.text()):""),e.fancybox.open({src:i.translate(i,o),type:"html",opts:{touch:!1,animationEffect:!1,afterLoad:function(t,e){i.$refs.container.one("beforeClose.fb",function(){t.close(null,0)}),e.$content.find(".fancybox-share__button").click(function(){return window.open(this.href,"Share","width=550, height=450"),!1})},mobile:{autoFocus:!1}}}))})}(document,jQuery),function(t,e,n){"use strict";function o(){var e=t.location.hash.substr(1),n=e.split("-"),o=n.length>1&&/^\+?\d+$/.test(n[n.length-1])?parseInt(n.pop(-1),10)||1:1,i=n.join("-");return{hash:e,index:o<1?1:o,gallery:i}}function i(t){""!==t.gallery&&n("[data-fancybox='"+n.escapeSelector(t.gallery)+"']").eq(t.index-1).focus().trigger("click.fb-start")}function a(t){var e,n;return!!t&&(e=t.current?t.current.opts:t.opts,""!==(n=e.hash||(e.$orig?e.$orig.data("fancybox")||e.$orig.data("fancybox-trigger"):""))&&n)}n.escapeSelector||(n.escapeSelector=function(t){return(t+"").replace(/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,function(t,e){return e?"\0"===t?"�":t.slice(0,-1)+"\\"+t.charCodeAt(t.length-1).toString(16)+" ":"\\"+t})}),n(function(){!1!==n.fancybox.defaults.hash&&(n(e).on({"onInit.fb":function(t,e){var n,i;!1!==e.group[e.currIndex].opts.hash&&(n=o(),(i=a(e))&&n.gallery&&i==n.gallery&&(e.currIndex=n.index-1))},"beforeShow.fb":function(n,o,i,s){var r;i&&!1!==i.opts.hash&&(r=a(o))&&(o.currentHash=r+(o.group.length>1?"-"+(i.index+1):""),t.location.hash!=="#"+o.currentHash&&(s&&!o.origHash&&(o.origHash=t.location.hash),o.hashTimer&&clearTimeout(o.hashTimer),o.hashTimer=setTimeout(function(){"replaceState"in t.history?(t.history[s?"pushState":"replaceState"]({},e.title,t.location.pathname+t.location.search+"#"+o.currentHash),s&&(o.hasCreatedHistory=!0)):t.location.hash=o.currentHash,o.hashTimer=null},300)))},"beforeClose.fb":function(n,o,i){i&&!1!==i.opts.hash&&(clearTimeout(o.hashTimer),o.currentHash&&o.hasCreatedHistory?t.history.back():o.currentHash&&("replaceState"in t.history?t.history.replaceState({},e.title,t.location.pathname+t.location.search+(o.origHash||"")):t.location.hash=o.origHash),o.currentHash=null)}}),n(t).on("hashchange.fb",function(){var t=o(),e=null;n.each(n(".fancybox-container").get().reverse(),function(t,o){var i=n(o).data("FancyBox");if(i&&i.currentHash)return e=i,!1}),e?e.currentHash===t.gallery+"-"+t.index||1===t.index&&e.currentHash==t.gallery||(e.currentHash=null,e.close()):""!==t.gallery&&i(t)}),setTimeout(function(){n.fancybox.getInstance()||i(o())},50))})}(window,document,jQuery),function(t,e){"use strict";var n=(new Date).getTime();e(t).on({"onInit.fb":function(t,e,o){e.$refs.stage.on("mousewheel DOMMouseScroll wheel MozMousePixelScroll",function(t){var o=e.current,i=(new Date).getTime();e.group.length<2||!1===o.opts.wheel||"auto"===o.opts.wheel&&"image"!==o.type||(t.preventDefault(),t.stopPropagation(),o.$slide.hasClass("fancybox-animated")||(t=t.originalEvent||t,i-n<250||(n=i,e[(-t.deltaY||-t.deltaX||t.wheelDelta||-t.detail)<0?"next":"previous"]())))})}})}(document,jQuery);
},{}],4:[function(require,module,exports){
/*
 * International Telephone Input v18.2.1
 * https://github.com/jackocnr/intl-tel-input.git
 * Licensed under the MIT license
 */

!function(a){var b=function(a,b,c){"use strict";return function(){function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}function f(a,b,c){return b&&e(a.prototype,b),c&&e(a,c),a}for(var g=[["Afghanistan (‫افغانستان‬‎)","af","93"],["Albania (Shqipëri)","al","355"],["Algeria (‫الجزائر‬‎)","dz","213"],["American Samoa","as","1",5,["684"]],["Andorra","ad","376"],["Angola","ao","244"],["Anguilla","ai","1",6,["264"]],["Antigua and Barbuda","ag","1",7,["268"]],["Argentina","ar","54"],["Armenia (Հայաստան)","am","374"],["Aruba","aw","297"],["Australia","au","61",0],["Austria (Österreich)","at","43"],["Azerbaijan (Azərbaycan)","az","994"],["Bahamas","bs","1",8,["242"]],["Bahrain (‫البحرين‬‎)","bh","973"],["Bangladesh (বাংলাদেশ)","bd","880"],["Barbados","bb","1",9,["246"]],["Belarus (Беларусь)","by","375"],["Belgium (België)","be","32"],["Belize","bz","501"],["Benin (Bénin)","bj","229"],["Bermuda","bm","1",10,["441"]],["Bhutan (འབྲུག)","bt","975"],["Bolivia","bo","591"],["Bosnia and Herzegovina (Босна и Херцеговина)","ba","387"],["Botswana","bw","267"],["Brazil (Brasil)","br","55"],["British Indian Ocean Territory","io","246"],["British Virgin Islands","vg","1",11,["284"]],["Brunei","bn","673"],["Bulgaria (България)","bg","359"],["Burkina Faso","bf","226"],["Burundi (Uburundi)","bi","257"],["Cambodia (កម្ពុជា)","kh","855"],["Cameroon (Cameroun)","cm","237"],["Canada","ca","1",1,["204","226","236","249","250","289","306","343","365","387","403","416","418","431","437","438","450","506","514","519","548","579","581","587","604","613","639","647","672","705","709","742","778","780","782","807","819","825","867","873","902","905"]],["Cape Verde (Kabu Verdi)","cv","238"],["Caribbean Netherlands","bq","599",1,["3","4","7"]],["Cayman Islands","ky","1",12,["345"]],["Central African Republic (République centrafricaine)","cf","236"],["Chad (Tchad)","td","235"],["Chile","cl","56"],["China (中国)","cn","86"],["Christmas Island","cx","61",2],["Cocos (Keeling) Islands","cc","61",1],["Colombia","co","57"],["Comoros (‫جزر القمر‬‎)","km","269"],["Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)","cd","243"],["Congo (Republic) (Congo-Brazzaville)","cg","242"],["Cook Islands","ck","682"],["Costa Rica","cr","506"],["Côte d’Ivoire","ci","225"],["Croatia (Hrvatska)","hr","385"],["Cuba","cu","53"],["Curaçao","cw","599",0],["Cyprus (Κύπρος)","cy","357"],["Czech Republic (Česká republika)","cz","420"],["Denmark (Danmark)","dk","45"],["Djibouti","dj","253"],["Dominica","dm","1",13,["767"]],["Dominican Republic (República Dominicana)","do","1",2,["809","829","849"]],["Ecuador","ec","593"],["Egypt (‫مصر‬‎)","eg","20"],["El Salvador","sv","503"],["Equatorial Guinea (Guinea Ecuatorial)","gq","240"],["Eritrea","er","291"],["Estonia (Eesti)","ee","372"],["Ethiopia","et","251"],["Falkland Islands (Islas Malvinas)","fk","500"],["Faroe Islands (Føroyar)","fo","298"],["Fiji","fj","679"],["Finland (Suomi)","fi","358",0],["France","fr","33"],["French Guiana (Guyane française)","gf","594"],["French Polynesia (Polynésie française)","pf","689"],["Gabon","ga","241"],["Gambia","gm","220"],["Georgia (საქართველო)","ge","995"],["Germany (Deutschland)","de","49"],["Ghana (Gaana)","gh","233"],["Gibraltar","gi","350"],["Greece (Ελλάδα)","gr","30"],["Greenland (Kalaallit Nunaat)","gl","299"],["Grenada","gd","1",14,["473"]],["Guadeloupe","gp","590",0],["Guam","gu","1",15,["671"]],["Guatemala","gt","502"],["Guernsey","gg","44",1,["1481","7781","7839","7911"]],["Guinea (Guinée)","gn","224"],["Guinea-Bissau (Guiné Bissau)","gw","245"],["Guyana","gy","592"],["Haiti","ht","509"],["Honduras","hn","504"],["Hong Kong (香港)","hk","852"],["Hungary (Magyarország)","hu","36"],["Iceland (Ísland)","is","354"],["India (भारत)","in","91"],["Indonesia","id","62"],["Iran (‫ایران‬‎)","ir","98"],["Iraq (‫العراق‬‎)","iq","964"],["Ireland","ie","353"],["Isle of Man","im","44",2,["1624","74576","7524","7924","7624"]],["Israel (‫ישראל‬‎)","il","972"],["Italy (Italia)","it","39",0],["Jamaica","jm","1",4,["876","658"]],["Japan (日本)","jp","81"],["Jersey","je","44",3,["1534","7509","7700","7797","7829","7937"]],["Jordan (‫الأردن‬‎)","jo","962"],["Kazakhstan (Казахстан)","kz","7",1,["33","7"]],["Kenya","ke","254"],["Kiribati","ki","686"],["Kosovo","xk","383"],["Kuwait (‫الكويت‬‎)","kw","965"],["Kyrgyzstan (Кыргызстан)","kg","996"],["Laos (ລາວ)","la","856"],["Latvia (Latvija)","lv","371"],["Lebanon (‫لبنان‬‎)","lb","961"],["Lesotho","ls","266"],["Liberia","lr","231"],["Libya (‫ليبيا‬‎)","ly","218"],["Liechtenstein","li","423"],["Lithuania (Lietuva)","lt","370"],["Luxembourg","lu","352"],["Macau (澳門)","mo","853"],["Macedonia (FYROM) (Македонија)","mk","389"],["Madagascar (Madagasikara)","mg","261"],["Malawi","mw","265"],["Malaysia","my","60"],["Maldives","mv","960"],["Mali","ml","223"],["Malta","mt","356"],["Marshall Islands","mh","692"],["Martinique","mq","596"],["Mauritania (‫موريتانيا‬‎)","mr","222"],["Mauritius (Moris)","mu","230"],["Mayotte","yt","262",1,["269","639"]],["Mexico (México)","mx","52"],["Micronesia","fm","691"],["Moldova (Republica Moldova)","md","373"],["Monaco","mc","377"],["Mongolia (Монгол)","mn","976"],["Montenegro (Crna Gora)","me","382"],["Montserrat","ms","1",16,["664"]],["Morocco (‫المغرب‬‎)","ma","212",0],["Mozambique (Moçambique)","mz","258"],["Myanmar (Burma) (မြန်မာ)","mm","95"],["Namibia (Namibië)","na","264"],["Nauru","nr","674"],["Nepal (नेपाल)","np","977"],["Netherlands (Nederland)","nl","31"],["New Caledonia (Nouvelle-Calédonie)","nc","687"],["New Zealand","nz","64"],["Nicaragua","ni","505"],["Niger (Nijar)","ne","227"],["Nigeria","ng","234"],["Niue","nu","683"],["Norfolk Island","nf","672"],["North Korea (조선 민주주의 인민 공화국)","kp","850"],["Northern Mariana Islands","mp","1",17,["670"]],["Norway (Norge)","no","47",0],["Oman (‫عُمان‬‎)","om","968"],["Pakistan (‫پاکستان‬‎)","pk","92"],["Palau","pw","680"],["Palestine (‫فلسطين‬‎)","ps","970"],["Panama (Panamá)","pa","507"],["Papua New Guinea","pg","675"],["Paraguay","py","595"],["Peru (Perú)","pe","51"],["Philippines","ph","63"],["Poland (Polska)","pl","48"],["Portugal","pt","351"],["Puerto Rico","pr","1",3,["787","939"]],["Qatar (‫قطر‬‎)","qa","974"],["Réunion (La Réunion)","re","262",0],["Romania (România)","ro","40"],["Russia (Россия)","ru","7",0],["Rwanda","rw","250"],["Saint Barthélemy","bl","590",1],["Saint Helena","sh","290"],["Saint Kitts and Nevis","kn","1",18,["869"]],["Saint Lucia","lc","1",19,["758"]],["Saint Martin (Saint-Martin (partie française))","mf","590",2],["Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)","pm","508"],["Saint Vincent and the Grenadines","vc","1",20,["784"]],["Samoa","ws","685"],["San Marino","sm","378"],["São Tomé and Príncipe (São Tomé e Príncipe)","st","239"],["Saudi Arabia (‫المملكة العربية السعودية‬‎)","sa","966"],["Senegal (Sénégal)","sn","221"],["Serbia (Србија)","rs","381"],["Seychelles","sc","248"],["Sierra Leone","sl","232"],["Singapore","sg","65"],["Sint Maarten","sx","1",21,["721"]],["Slovakia (Slovensko)","sk","421"],["Slovenia (Slovenija)","si","386"],["Solomon Islands","sb","677"],["Somalia (Soomaaliya)","so","252"],["South Africa","za","27"],["South Korea (대한민국)","kr","82"],["South Sudan (‫جنوب السودان‬‎)","ss","211"],["Spain (España)","es","34"],["Sri Lanka (ශ්‍රී ලංකාව)","lk","94"],["Sudan (‫السودان‬‎)","sd","249"],["Suriname","sr","597"],["Svalbard and Jan Mayen","sj","47",1,["79"]],["Swaziland","sz","268"],["Sweden (Sverige)","se","46"],["Switzerland (Schweiz)","ch","41"],["Syria (‫سوريا‬‎)","sy","963"],["Taiwan (台灣)","tw","886"],["Tajikistan","tj","992"],["Tanzania","tz","255"],["Thailand (ไทย)","th","66"],["Timor-Leste","tl","670"],["Togo","tg","228"],["Tokelau","tk","690"],["Tonga","to","676"],["Trinidad and Tobago","tt","1",22,["868"]],["Tunisia (‫تونس‬‎)","tn","216"],["Turkey (Türkiye)","tr","90"],["Turkmenistan","tm","993"],["Turks and Caicos Islands","tc","1",23,["649"]],["Tuvalu","tv","688"],["U.S. Virgin Islands","vi","1",24,["340"]],["Uganda","ug","256"],["Ukraine (Україна)","ua","380"],["United Arab Emirates (‫الإمارات العربية المتحدة‬‎)","ae","971"],["United Kingdom","gb","44",0],["United States","us","1",0],["Uruguay","uy","598"],["Uzbekistan (Oʻzbekiston)","uz","998"],["Vanuatu","vu","678"],["Vatican City (Città del Vaticano)","va","39",1,["06698"]],["Venezuela","ve","58"],["Vietnam (Việt Nam)","vn","84"],["Wallis and Futuna (Wallis-et-Futuna)","wf","681"],["Western Sahara (‫الصحراء الغربية‬‎)","eh","212",1,["5288","5289"]],["Yemen (‫اليمن‬‎)","ye","967"],["Zambia","zm","260"],["Zimbabwe","zw","263"],["Åland Islands","ax","358",1,["18"]]],h=0;h<g.length;h++){var i=g[h];g[h]={name:i[0],iso2:i[1],dialCode:i[2],priority:i[3]||0,areaCodes:i[4]||null}}a.intlTelInputGlobals={getInstance:function(b){var c=b.getAttribute("data-intl-tel-input-id");return a.intlTelInputGlobals.instances[c]},instances:{}};var j=0,k={allowDropdown:!0,autoHideDialCode:!0,autoPlaceholder:"polite",customContainer:"",customPlaceholder:null,dropdownContainer:null,excludeCountries:[],formatOnDisplay:!0,geoIpLookup:null,hiddenInput:"",initialCountry:"",localizedCountries:null,nationalMode:!0,onlyCountries:[],placeholderNumberType:"MOBILE",preferredCountries:["us","gb"],separateDialCode:!1,utilsScript:""},l=["800","822","833","844","855","866","877","880","881","882","883","884","885","886","887","888","889"];a.addEventListener("load",function(){a.intlTelInputGlobals.windowLoaded=!0});var m=function(a,b){for(var c=Object.keys(a),d=0;d<c.length;d++)b(c[d],a[c[d]])},n=function(b){m(a.intlTelInputGlobals.instances,function(c){a.intlTelInputGlobals.instances[c][b]()})},o=function(){function e(a,b){var c=this;d(this,e),this.id=j++,this.a=a,this.b=null,this.c=null;var f=b||{};this.d={},m(k,function(a,b){c.d[a]=f.hasOwnProperty(a)?f[a]:b}),this.e=Boolean(a.getAttribute("placeholder"))}return f(e,[{key:"_init",value:function(){var a=this;if(this.d.nationalMode&&(this.d.autoHideDialCode=!1),this.d.separateDialCode&&(this.d.autoHideDialCode=this.d.nationalMode=!1),this.g=/Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),this.g&&(b.body.classList.add("iti-mobile"),this.d.dropdownContainer||(this.d.dropdownContainer=b.body)),"undefined"!=typeof Promise){var c=new Promise(function(b,c){a.h=b,a.i=c}),d=new Promise(function(b,c){a.i0=b,a.i1=c});this.promise=Promise.all([c,d])}else this.h=this.i=function(){},this.i0=this.i1=function(){};this.s={},this._b(),this._f(),this._h(),this._i(),this._i3()}},{key:"_b",value:function(){this._d(),this._d2(),this._e(),this.d.localizedCountries&&this._d0(),(this.d.onlyCountries.length||this.d.localizedCountries)&&this.p.sort(this._d1)}},{key:"_c",value:function(a,b,d){b.length>this.dialCodeMaxLen&&(this.dialCodeMaxLen=b.length),this.q.hasOwnProperty(b)||(this.q[b]=[]);for(var e=0;e<this.q[b].length;e++)if(this.q[b][e]===a)return;var f=d!==c?d:this.q[b].length;this.q[b][f]=a}},{key:"_d",value:function(){if(this.d.onlyCountries.length){var a=this.d.onlyCountries.map(function(a){return a.toLowerCase()});this.p=g.filter(function(b){return a.indexOf(b.iso2)>-1})}else if(this.d.excludeCountries.length){var b=this.d.excludeCountries.map(function(a){return a.toLowerCase()});this.p=g.filter(function(a){return-1===b.indexOf(a.iso2)})}else this.p=g}},{key:"_d0",value:function(){for(var a=0;a<this.p.length;a++){var b=this.p[a].iso2.toLowerCase();this.d.localizedCountries.hasOwnProperty(b)&&(this.p[a].name=this.d.localizedCountries[b])}}},{key:"_d1",value:function(a,b){return a.name.localeCompare(b.name)}},{key:"_d2",value:function(){this.dialCodeMaxLen=0,this.q={};for(var a=0;a<this.p.length;a++){var b=this.p[a];this._c(b.iso2,b.dialCode,b.priority)}for(var c=0;c<this.p.length;c++){var d=this.p[c];if(d.areaCodes)for(var e=this.q[d.dialCode][0],f=0;f<d.areaCodes.length;f++){for(var g=d.areaCodes[f],h=1;h<g.length;h++){var i=d.dialCode+g.substr(0,h);this._c(e,i),this._c(d.iso2,i)}this._c(d.iso2,d.dialCode+g)}}}},{key:"_e",value:function(){this.preferredCountries=[];for(var a=0;a<this.d.preferredCountries.length;a++){var b=this.d.preferredCountries[a].toLowerCase(),c=this._y(b,!1,!0);c&&this.preferredCountries.push(c)}}},{key:"_e2",value:function(a,c,d){var e=b.createElement(a);return c&&m(c,function(a,b){return e.setAttribute(a,b)}),d&&d.appendChild(e),e}},{key:"_f",value:function(){this.a.setAttribute("autocomplete","off");var a="iti";this.d.allowDropdown&&(a+=" iti--allow-dropdown"),this.d.separateDialCode&&(a+=" iti--separate-dial-code"),this.d.customContainer&&(a+=" ",a+=this.d.customContainer);var b=this._e2("div",{"class":a});if(this.a.parentNode.insertBefore(b,this.a),this.k=this._e2("div",{"class":"iti__flag-container"},b),b.appendChild(this.a),this.selectedFlag=this._e2("div",{"class":"iti__selected-flag",role:"combobox","aria-owns":"country-listbox"},this.k),this.l=this._e2("div",{"class":"iti__flag"},this.selectedFlag),this.d.separateDialCode&&(this.t=this._e2("div",{"class":"iti__selected-dial-code"},this.selectedFlag)),this.d.allowDropdown&&(this.selectedFlag.setAttribute("tabindex","0"),this.u=this._e2("div",{"class":"iti__arrow"},this.selectedFlag),this.m=this._e2("ul",{"class":"iti__country-list iti__hide",id:"country-listbox","aria-expanded":"false",role:"listbox"}),this.preferredCountries.length&&(this._g(this.preferredCountries,"iti__preferred"),this._e2("li",{"class":"iti__divider",role:"separator","aria-disabled":"true"},this.m)),this._g(this.p,"iti__standard"),this.d.dropdownContainer?(this.dropdown=this._e2("div",{"class":"iti iti--container"}),this.dropdown.appendChild(this.m)):this.k.appendChild(this.m)),this.d.hiddenInput){var c=this.d.hiddenInput,d=this.a.getAttribute("name");if(d){var e=d.lastIndexOf("[");-1!==e&&(c="".concat(d.substr(0,e),"[").concat(c,"]"))}this.hiddenInput=this._e2("input",{type:"hidden",name:c}),b.appendChild(this.hiddenInput)}}},{key:"_g",value:function(a,b){for(var c="",d=0;d<a.length;d++){var e=a[d];c+="<li class='iti__country ".concat(b,"' tabIndex='-1' id='iti-item-").concat(e.iso2,"' role='option' data-dial-code='").concat(e.dialCode,"' data-country-code='").concat(e.iso2,"'>"),c+="<div class='iti__flag-box'><div class='iti__flag iti__".concat(e.iso2,"'></div></div>"),c+="<span class='iti__country-name'>".concat(e.name,"</span>"),c+="<span class='iti__dial-code'>+".concat(e.dialCode,"</span>"),c+="</li>"}this.m.insertAdjacentHTML("beforeend",c)}},{key:"_h",value:function(){var a=this.a.value,b=this._5(a),c=this._w(a),d=this.d,e=d.initialCountry,f=d.nationalMode,g=d.autoHideDialCode,h=d.separateDialCode;b&&!c?this._v(a):"auto"!==e&&(e?this._z(e.toLowerCase()):b&&c?this._z("us"):(this.j=this.preferredCountries.length?this.preferredCountries[0].iso2:this.p[0].iso2,a||this._z(this.j)),a||f||g||h||(this.a.value="+".concat(this.s.dialCode))),a&&this._u(a)}},{key:"_i",value:function(){this._j(),this.d.autoHideDialCode&&this._l(),this.d.allowDropdown&&this._i2(),this.hiddenInput&&this._i0()}},{key:"_i0",value:function(){var a=this;this._a14=function(){a.hiddenInput.value=a.getNumber()},this.a.form&&this.a.form.addEventListener("submit",this._a14)}},{key:"_i1",value:function(){for(var a=this.a;a&&"LABEL"!==a.tagName;)a=a.parentNode;return a}},{key:"_i2",value:function(){var a=this;this._a9=function(b){a.m.classList.contains("iti__hide")?a.a.focus():b.preventDefault()};var b=this._i1();b&&b.addEventListener("click",this._a9),this._a10=function(){!a.m.classList.contains("iti__hide")||a.a.disabled||a.a.readOnly||a._n()},this.selectedFlag.addEventListener("click",this._a10),this._a11=function(b){a.m.classList.contains("iti__hide")&&-1!==["ArrowUp","ArrowDown"," ","Enter"].indexOf(b.key)&&(b.preventDefault(),b.stopPropagation(),a._n()),"Tab"===b.key&&a._2()},this.k.addEventListener("keydown",this._a11)}},{key:"_i3",value:function(){var b=this;this.d.utilsScript&&!a.intlTelInputUtils?a.intlTelInputGlobals.windowLoaded?a.intlTelInputGlobals.loadUtils(this.d.utilsScript):a.addEventListener("load",function(){a.intlTelInputGlobals.loadUtils(b.d.utilsScript)}):this.i0(),"auto"===this.d.initialCountry?this._i4():this.h()}},{key:"_i4",value:function(){a.intlTelInputGlobals.autoCountry?this.handleAutoCountry():a.intlTelInputGlobals.startedLoadingAutoCountry||(a.intlTelInputGlobals.startedLoadingAutoCountry=!0,"function"==typeof this.d.geoIpLookup&&this.d.geoIpLookup(function(b){a.intlTelInputGlobals.autoCountry=b.toLowerCase(),setTimeout(function(){return n("handleAutoCountry")})},function(){return n("rejectAutoCountryPromise")}))}},{key:"_j",value:function(){var a=this;this._a12=function(){a._v(a.a.value)&&a._8()},this.a.addEventListener("keyup",this._a12),this._a13=function(){setTimeout(a._a12)},this.a.addEventListener("cut",this._a13),this.a.addEventListener("paste",this._a13)}},{key:"_j2",value:function(a){var b=this.a.getAttribute("maxlength");return b&&a.length>b?a.substr(0,b):a}},{key:"_l",value:function(){var a=this;this._a8=function(){a._l2()},this.a.form&&this.a.form.addEventListener("submit",this._a8),this.a.addEventListener("blur",this._a8)}},{key:"_l2",value:function(){if("+"===this.a.value.charAt(0)){var a=this._m(this.a.value);a&&this.s.dialCode!==a||(this.a.value="")}}},{key:"_m",value:function(a){return a.replace(/\D/g,"")}},{key:"_m2",value:function(a){var c=b.createEvent("Event");c.initEvent(a,!0,!0),this.a.dispatchEvent(c)}},{key:"_n",value:function(){this.m.classList.remove("iti__hide"),this.m.setAttribute("aria-expanded","true"),this._o(),this.b&&(this._x(this.b,!1),this._3(this.b,!0)),this._p(),this.u.classList.add("iti__arrow--up"),this._m2("open:countrydropdown")}},{key:"_n2",value:function(a,b,c){c&&!a.classList.contains(b)?a.classList.add(b):!c&&a.classList.contains(b)&&a.classList.remove(b)}},{key:"_o",value:function(){var c=this;if(this.d.dropdownContainer&&this.d.dropdownContainer.appendChild(this.dropdown),!this.g){var d=this.a.getBoundingClientRect(),e=a.pageYOffset||b.documentElement.scrollTop,f=d.top+e,g=this.m.offsetHeight,h=f+this.a.offsetHeight+g<e+a.innerHeight,i=f-g>e;if(this._n2(this.m,"iti__country-list--dropup",!h&&i),this.d.dropdownContainer){var j=!h&&i?0:this.a.offsetHeight;this.dropdown.style.top="".concat(f+j,"px"),this.dropdown.style.left="".concat(d.left+b.body.scrollLeft,"px"),this._a4=function(){return c._2()},a.addEventListener("scroll",this._a4)}}}},{key:"_o2",value:function(a){for(var b=a;b&&b!==this.m&&!b.classList.contains("iti__country");)b=b.parentNode;return b===this.m?null:b}},{key:"_p",value:function(){var a=this;this._a0=function(b){var c=a._o2(b.target);c&&a._x(c,!1)},this.m.addEventListener("mouseover",this._a0),this._a1=function(b){var c=a._o2(b.target);c&&a._1(c)},this.m.addEventListener("click",this._a1);var c=!0;this._a2=function(){c||a._2(),c=!1},b.documentElement.addEventListener("click",this._a2);var d="",e=null;this._a3=function(b){b.preventDefault(),"ArrowUp"===b.key||"ArrowDown"===b.key?a._q(b.key):"Enter"===b.key?a._r():"Escape"===b.key?a._2():/^[a-zA-ZÀ-ÿ ]$/.test(b.key)&&(e&&clearTimeout(e),d+=b.key.toLowerCase(),a._s(d),e=setTimeout(function(){d=""},1e3))},b.addEventListener("keydown",this._a3)}},{key:"_q",value:function(a){var b="ArrowUp"===a?this.c.previousElementSibling:this.c.nextElementSibling;b&&(b.classList.contains("iti__divider")&&(b="ArrowUp"===a?b.previousElementSibling:b.nextElementSibling),this._x(b,!0))}},{key:"_r",value:function(){this.c&&this._1(this.c)}},{key:"_s",value:function(a){for(var b=0;b<this.p.length;b++)if(this._t(this.p[b].name,a)){var c=this.m.querySelector("#iti-item-".concat(this.p[b].iso2));this._x(c,!1),this._3(c,!0);break}}},{key:"_t",value:function(a,b){return a.substr(0,b.length).toLowerCase()===b}},{key:"_u",value:function(b){var c=b;if(this.d.formatOnDisplay&&a.intlTelInputUtils&&this.s){var d=!this.d.separateDialCode&&(this.d.nationalMode||"+"!==c.charAt(0)),e=intlTelInputUtils.numberFormat,f=e.NATIONAL,g=e.INTERNATIONAL,h=d?f:g;c=intlTelInputUtils.formatNumber(c,this.s.iso2,h)}c=this._7(c),this.a.value=c}},{key:"_v",value:function(a){var b=a,c=this.s.dialCode,d="1"===c;b&&this.d.nationalMode&&d&&"+"!==b.charAt(0)&&("1"!==b.charAt(0)&&(b="1".concat(b)),b="+".concat(b)),this.d.separateDialCode&&c&&"+"!==b.charAt(0)&&(b="+".concat(c).concat(b));var e=this._5(b),f=this._m(b),g=null;if(e){var h=this.q[this._m(e)],i=-1!==h.indexOf(this.s.iso2)&&f.length<=e.length-1;if(!("1"===c&&this._w(f))&&!i)for(var j=0;j<h.length;j++)if(h[j]){g=h[j];break}}else"+"===b.charAt(0)&&f.length?g="":b&&"+"!==b||(g=this.j);return null!==g&&this._z(g)}},{key:"_w",value:function(a){var b=this._m(a);if("1"===b.charAt(0)){var c=b.substr(1,3);return-1!==l.indexOf(c)}return!1}},{key:"_x",value:function(a,b){var c=this.c;c&&c.classList.remove("iti__highlight"),this.c=a,this.c.classList.add("iti__highlight"),b&&this.c.focus()}},{key:"_y",value:function(a,b,c){for(var d=b?g:this.p,e=0;e<d.length;e++)if(d[e].iso2===a)return d[e];if(c)return null;throw new Error("No country data for '".concat(a,"'"))}},{key:"_z",value:function(a){var b=this.s.iso2?this.s:{};this.s=a?this._y(a,!1,!1):{},this.s.iso2&&(this.j=this.s.iso2),this.l.setAttribute("class","iti__flag iti__".concat(a));var c=a?"".concat(this.s.name,": +").concat(this.s.dialCode):"Unknown";if(this.selectedFlag.setAttribute("title",c),this.d.separateDialCode){var d=this.s.dialCode?"+".concat(this.s.dialCode):"";this.t.innerHTML=d;var e=this.selectedFlag.offsetWidth||this._getHiddenSelectedFlagWidth();this.a.style.paddingLeft="".concat(e+6,"px")}if(this._0(),this.d.allowDropdown){var f=this.b;if(f&&(f.classList.remove("iti__active"),f.setAttribute("aria-selected","false")),a){var g=this.m.querySelector("#iti-item-".concat(a));g.setAttribute("aria-selected","true"),g.classList.add("iti__active"),this.b=g,this.m.setAttribute("aria-activedescendant",g.getAttribute("id"))}}return b.iso2!==a}},{key:"_getHiddenSelectedFlagWidth",value:function(){var a=this.a.parentNode.cloneNode();a.style.visibility="hidden",b.body.appendChild(a);var c=this.selectedFlag.cloneNode(!0);a.appendChild(c);var d=c.offsetWidth;return a.remove(),d}},{key:"_0",value:function(){var b="aggressive"===this.d.autoPlaceholder||!this.e&&"polite"===this.d.autoPlaceholder;if(a.intlTelInputUtils&&b){var c=intlTelInputUtils.numberType[this.d.placeholderNumberType],d=this.s.iso2?intlTelInputUtils.getExampleNumber(this.s.iso2,this.d.nationalMode,c):"";d=this._7(d),"function"==typeof this.d.customPlaceholder&&(d=this.d.customPlaceholder(d,this.s)),this.a.setAttribute("placeholder",d)}}},{key:"_1",value:function(a){var b=this._z(a.getAttribute("data-country-code"));this._2(),this._4(a.getAttribute("data-dial-code"),!0),this.a.focus();var c=this.a.value.length;this.a.setSelectionRange(c,c),b&&this._8()}},{key:"_2",value:function(){this.m.classList.add("iti__hide"),this.m.setAttribute("aria-expanded","false"),this.u.classList.remove("iti__arrow--up"),b.removeEventListener("keydown",this._a3),b.documentElement.removeEventListener("click",this._a2),this.m.removeEventListener("mouseover",this._a0),this.m.removeEventListener("click",this._a1),this.d.dropdownContainer&&(this.g||a.removeEventListener("scroll",this._a4),this.dropdown.parentNode&&this.dropdown.parentNode.removeChild(this.dropdown)),this._m2("close:countrydropdown")}},{key:"_3",value:function(c,d){var e=this.m,f=a.pageYOffset||b.documentElement.scrollTop,g=e.offsetHeight,h=e.getBoundingClientRect().top+f,i=h+g,j=c.offsetHeight,k=c.getBoundingClientRect().top+f,l=k+j,m=k-h+e.scrollTop,n=g/2-j/2;if(k<h)d&&(m-=n),e.scrollTop=m;else if(l>i){d&&(m+=n);var o=g-j;e.scrollTop=m-o}}},{key:"_4",value:function(a,b){var c,d=this.a.value,e="+".concat(a);if("+"===d.charAt(0)){var f=this._5(d);c=f?d.replace(f,e):e}else{if(this.d.nationalMode||this.d.separateDialCode)return;if(d)c=e+d;else{if(!b&&this.d.autoHideDialCode)return;c=e}}this.a.value=c}},{key:"_5",value:function(a){var b="";if("+"===a.charAt(0))for(var c="",d=0;d<a.length;d++){var e=a.charAt(d);if(!isNaN(parseInt(e,10))&&(c+=e,this.q[c]&&(b=a.substr(0,d+1)),c.length===this.dialCodeMaxLen))break}return b}},{key:"_6",value:function(){var a=this.a.value.trim(),b=this.s.dialCode,c=this._m(a);return(this.d.separateDialCode&&"+"!==a.charAt(0)&&b&&c?"+".concat(b):"")+a}},{key:"_7",value:function(a){var b=a;if(this.d.separateDialCode){var c=this._5(b);if(c){c="+".concat(this.s.dialCode);var d=" "===b[c.length]||"-"===b[c.length]?c.length+1:c.length;b=b.substr(d)}}return this._j2(b)}},{key:"_8",value:function(){this._m2("countrychange")}},{key:"handleAutoCountry",value:function(){"auto"===this.d.initialCountry&&(this.j=a.intlTelInputGlobals.autoCountry,this.a.value||this.setCountry(this.j),this.h())}},{key:"handleUtils",value:function(){a.intlTelInputUtils&&(this.a.value&&this._u(this.a.value),this._0()),this.i0()}},{key:"destroy",value:function(){var b=this.a.form;if(this.d.allowDropdown){this._2(),this.selectedFlag.removeEventListener("click",this._a10),this.k.removeEventListener("keydown",this._a11);var c=this._i1();c&&c.removeEventListener("click",this._a9)}this.hiddenInput&&b&&b.removeEventListener("submit",this._a14),this.d.autoHideDialCode&&(b&&b.removeEventListener("submit",this._a8),this.a.removeEventListener("blur",this._a8)),this.a.removeEventListener("keyup",this._a12),this.a.removeEventListener("cut",this._a13),this.a.removeEventListener("paste",this._a13),this.a.removeAttribute("data-intl-tel-input-id");var d=this.a.parentNode;d.parentNode.insertBefore(this.a,d),d.parentNode.removeChild(d),delete a.intlTelInputGlobals.instances[this.id]}},{key:"getExtension",value:function(){return a.intlTelInputUtils?intlTelInputUtils.getExtension(this._6(),this.s.iso2):""}},{key:"getNumber",value:function(b){if(a.intlTelInputUtils){var c=this.s.iso2;return intlTelInputUtils.formatNumber(this._6(),c,b)}return""}},{key:"getNumberType",value:function(){return a.intlTelInputUtils?intlTelInputUtils.getNumberType(this._6(),this.s.iso2):-99}},{key:"getSelectedCountryData",value:function(){return this.s}},{key:"getValidationError",value:function(){if(a.intlTelInputUtils){var b=this.s.iso2;return intlTelInputUtils.getValidationError(this._6(),b)}return-99}},{key:"isValidNumber",value:function(){var b=this._6().trim(),c=this.d.nationalMode?this.s.iso2:"";return a.intlTelInputUtils?intlTelInputUtils.isValidNumber(b,c):null}},{key:"setCountry",value:function(a){var b=a.toLowerCase();this.l.classList.contains("iti__".concat(b))||(this._z(b),this._4(this.s.dialCode,!1),this._8())}},{key:"setNumber",value:function(a){var b=this._v(a);this._u(a),b&&this._8()}},{key:"setPlaceholderNumberType",value:function(a){this.d.placeholderNumberType=a,this._0()}}]),e}()
;a.intlTelInputGlobals.getCountryData=function(){return g};var p=function(a,c,d){var e=b.createElement("script");e.onload=function(){n("handleUtils"),c&&c()},e.onerror=function(){n("rejectUtilsScriptPromise"),d&&d()},e.className="iti-load-utils",e.async=!0,e.src=a,b.body.appendChild(e)};return a.intlTelInputGlobals.loadUtils=function(b){if(!a.intlTelInputUtils&&!a.intlTelInputGlobals.startedLoadingUtilsScript){if(a.intlTelInputGlobals.startedLoadingUtilsScript=!0,"undefined"!=typeof Promise)return new Promise(function(a,c){return p(b,a,c)});p(b)}return null},a.intlTelInputGlobals.defaults=k,a.intlTelInputGlobals.version="16.0.0",function(b,c){var d=new o(b,c);return d._init(),b.setAttribute("data-intl-tel-input-id",d.id),a.intlTelInputGlobals.instances[d.id]=d,d}}()}(window,document);"object"==typeof module&&module.exports?module.exports=b:window.intlTelInput=b}();
},{}],5:[function(require,module,exports){
/*!
  Zoom 1.7.21
  license: MIT
  http://www.jacklmoore.com/zoom
*/
(function ($) {
  var defaults = {
    url: false,
    callback: false,
    target: false,
    duration: 120,
    on: 'mouseover', // other options: grab, click, toggle
    touch: true, // enables a touch fallback
    onZoomIn: false,
    onZoomOut: false,
    magnify: 1
  };

  // Core Zoom Logic, independent of event listeners.
  $.zoom = function (target, source, img, magnify) {
    var targetHeight,
      targetWidth,
      sourceHeight,
      sourceWidth,
      xRatio,
      yRatio,
      offset,
      $target = $(target),
      position = $target.css('position'),
      $source = $(source);

    // The parent element needs positioning so that the zoomed element can be correctly positioned within.
    target.style.position = /(absolute|fixed)/.test(position) ? position : 'relative';
    target.style.overflow = 'hidden';
    img.style.width = img.style.height = '';

    $(img)
      .addClass('zoomImg')
      .css({
        position: 'absolute',
        top: 0,
        left: 0,
        opacity: 0,
        width: img.width * magnify,
        height: img.height * magnify,
        border: 'none',
        maxWidth: 'none',
        maxHeight: 'none'
      })
      .appendTo(target);

    return {
      init: function () {
        targetWidth = $target.outerWidth();
        targetHeight = $target.outerHeight();

        if (source === target) {
          sourceWidth = targetWidth;
          sourceHeight = targetHeight;
        } else {
          sourceWidth = $source.outerWidth();
          sourceHeight = $source.outerHeight();
        }

        xRatio = (img.width - targetWidth) / sourceWidth;
        yRatio = (img.height - targetHeight) / sourceHeight;

        offset = $source.offset();
      },
      move: function (e) {
        var left = (e.pageX - offset.left),
          top = (e.pageY - offset.top);

        top = Math.max(Math.min(top, sourceHeight), 0);
        left = Math.max(Math.min(left, sourceWidth), 0);

        img.style.left = (left * -xRatio) + 'px';
        img.style.top = (top * -yRatio) + 'px';
      }
    };
  };

  $.fn.zoom = function (options) {
    return this.each(function () {
      var
        settings = $.extend({}, defaults, options || {}),
        //target will display the zoomed image
        target = settings.target && $(settings.target)[0] || this,
        //source will provide zoom location info (thumbnail)
        source = this,
        $source = $(source),
        img = document.createElement('img'),
        $img = $(img),
        mousemove = 'mousemove.zoom',
        clicked = false,
        touched = false;

      // If a url wasn't specified, look for an image element.
      if (!settings.url) {
        var srcElement = source.querySelector('img');
        if (srcElement) {
          settings.url = srcElement.getAttribute('data-src') || srcElement.currentSrc || srcElement.src;
        }
        if (!settings.url) {
          return;
        }
      }

      $source.one('zoom.destroy', function (position, overflow) {
        $source.off(".zoom");
        target.style.position = position;
        target.style.overflow = overflow;
        img.onload = null;
        $img.remove();
      }.bind(this, target.style.position, target.style.overflow));

      img.onload = function () {
        var zoom = $.zoom(target, source, img, settings.magnify);

        function start(e) {
          zoom.init();
          zoom.move(e);

          // Skip the fade-in for IE8 and lower since it chokes on fading-in
          // and changing position based on mousemovement at the same time.
          $img.stop()
            .fadeTo($.support.opacity ? settings.duration : 0, 1, $.isFunction(settings.onZoomIn) ? settings.onZoomIn.call(img) : false);
        }

        function stop() {
          $img.stop()
            .fadeTo(settings.duration, 0, $.isFunction(settings.onZoomOut) ? settings.onZoomOut.call(img) : false);
        }

        // Mouse events
        if (settings.on === 'grab') {
          $source
            .on('mousedown.zoom',
              function (e) {
                if (e.which === 1) {
                  $(document).one('mouseup.zoom',
                    function () {
                      stop();

                      $(document).off(mousemove, zoom.move);
                    }
                  );

                  start(e);

                  $(document).on(mousemove, zoom.move);

                  e.preventDefault();
                }
              }
            );
        } else if (settings.on === 'click') {
          $source.on('click.zoom',
            function (e) {
              if (clicked) {
                // bubble the event up to the document to trigger the unbind.
                return;
              } else {
                clicked = true;
                start(e);
                $(document).on(mousemove, zoom.move);
                $(document).one('click.zoom',
                  function () {
                    stop();
                    clicked = false;
                    $(document).off(mousemove, zoom.move);
                  }
                );
                return false;
              }
            }
          );
        } else if (settings.on === 'toggle') {
          $source.on('click.zoom',
            function (e) {
              if (clicked) {
                stop();
              } else {
                start(e);
              }
              clicked = !clicked;
            }
          );
        } else if (settings.on === 'mouseover') {
          zoom.init(); // Preemptively call init because IE7 will fire the mousemove handler before the hover handler.

          $source
            .on('mouseenter.zoom', start)
            .on('mouseleave.zoom', stop)
            .on(mousemove, zoom.move);
        }

        // Touch fallback
        if (settings.touch) {
          $source
            .on('touchstart.zoom', function (e) {
              e.preventDefault();
              if (touched) {
                touched = false;
                stop();
              } else {
                touched = true;
                start(e.originalEvent.touches[0] || e.originalEvent.changedTouches[0]);
              }
            })
            .on('touchmove.zoom', function (e) {
              e.preventDefault();
              zoom.move(e.originalEvent.touches[0] || e.originalEvent.changedTouches[0]);
            })
            .on('touchend.zoom', function (e) {
              e.preventDefault();
              if (touched) {
                touched = false;
                stop();
              }
            });
        }

        if ($.isFunction(settings.callback)) {
          settings.callback.call(img);
        }
      };

      img.setAttribute('role', 'presentation');
      img.alt = '';
      img.src = settings.url;
    });
  };

  $.fn.zoom.defaults = defaults;
}(window.jQuery));
},{}],6:[function(require,module,exports){
/*!
* country-region-selector
* ------------------------
* 1.0.0
* @author Ben Keen
* @repo https://github.com/benkeen/country-region-selector
* @licence MIT
*/

!function (a, n) { if ("function" == typeof define && define.amd) define([], n); else if ("object" == typeof exports) try { module.exports = n(require()) } catch (a) { module.exports = n() } else a.crs = n() }(this, function () { "use strict"; var m = !0, h = !0, M = [], l = [["Afghanistan", "AF", "Badakhshan~BDS|Badghis~BDG|Baghlan~BGL|Balkh~BAL|Bamyan~BAM|Daykundi~DAY|Farah~FRA|Faryab~FYB|Ghazni~GHA|Ghor~GHO|Helmand~HEL|Herat~HER|Jowzjan~JOW|Kabul~KAB|Kandahar~KAN|Kapisa~KAP|Khost~KHO|Kunar~KNR|Kunduz~KDZ|Laghman~LAG|Logar~LOW|Maidan Wardak~WAR|Nangarhar~NAN|Nimruz~NIM|Nuristan~NUR|Paktia~PIA|Paktika~PKA|Panjshir~PAN|Parwan~PAR|Samangan~SAM|Sar-e Pol~SAR|Takhar~TAK|Urozgan~ORU|Zabul~ZAB"], ["Åland Islands", "AX", "Brändö~BR|Eckerö~EC|Finström~FN|Föglö~FG|Geta~GT|Hammarland~HM|Jomala~JM|Kumlinge~KM|Kökar~KK|Lemland~LE|Lumparland~LU|Mariehamn~MH|Saltvik~SV|Sottunga~ST|Sund~SD|Vårdö~VR"], ["Albania", "AL", "Berat~01|Dibër~09|Durrës~02|Elbasan~03|Fier~04|Gjirokastër~05|Korçë~06|Kukës~07|Lezhë~08|Shkodër~10|Tirana~11|Vlorë~12"], ["Algeria", "DZ", "Adrar~01|Aïn Defla~44|Aïn Témouchent~46|Algiers~16|Annaba~23|Batna~05|Béchar~08|Béjaïa~06|Biskra~07|Blida~09|Bordj Bou Arréridj~34|Bouïra~10|Boumerdès~35|Chlef~02|Constantine~25|Djelfa~17|El Bayadh~32|El Oued~39|El Tarf~36|Ghardaïa~47|Guelma~24|Illizi~33|Jijel~18|Khenchela~40|Laghouat~03|Mascara~29|Médéa~26|Mila~43|Mostaganem~27|Msila~28|Naâma~45|Oran~31|Ouargla~30|Oum el Bouaghi~04|Relizane~48|Saïda~20|Sétif~19|Sidi Bel Abbès~22|Skikda~21|Souk Ahras~41|Tamanghasset~11|Tébessa~12|Tiaret~14|Tindouf~37|Tipaza~42|Tissemsilt~38|Tizi Ouzou~15|Tlemcen~13"], ["American Samoa", "AS", "Tutuila~01|Aunu'u~02|Ta'ū~03|Ofu‑Olosega~04|Rose Atoll~21|Swains Island~22"], ["Andorra", "AD", "Andorra la Vella~07|Canillo~02|Encamp~03|Escaldes-Engordany~08|La Massana~04|Ordino~05|Sant Julià de Lòria~06"], ["Angola", "AO", "Bengo~BGO|Benguela~BGU|Bié~BIE|Cabinda~CAB|Cuando Cubango~CCU|Cuanza Norte~CNO|Cuanza Sul~CUS|Cunene~CNN|Huambo~HUA|Huíla~HUI|Luanda~LUA|Lunda Norte~LNO|Lunda Sul~LSU|Malanje~MAL|Moxico~MOX|Namibe~NAM|Uíge~UIG|Zaire~ZAI"], ["Anguilla", "AI", "Anguilla~01|Anguillita Island~02|Blowing Rock~03|Cove Cay~04|Crocus Cay~05|Deadman's Cay~06|Dog Island~07|East Cay~08|Little Island~09|Little Scrub Island~10|Mid Cay~11|North Cay~12|Prickly Pear Cays~13|Rabbit Island~14|Sandy Island/Sand Island~15|Scilly Cay~16|Scrub Island~17|Seal Island~18|Sombrero/Hat Island~19|South Cay~20|South Wager Island~21|West Cay~22"], ["Antarctica", "AQ", "Antarctica~AQ"], ["Antigua and Barbuda", "AG", "Antigua Island~01|Barbuda Island~02|Bird Island~04|Bishop Island~05|Blake Island~06|Crump Island~09|Dulcina Island~10|Exchange Island~11|Five Islands~12|Great Bird Island~13|Green Island~14|Guiana Island~15|Hawes Island~17|Hells Gate Island~16|Henry Island~18|Johnson Island~19|Kid Island~20|Lobster Island~22|Maiden Island~24|Moor Island~25|Nanny Island~26|Pelican Island~27|Prickly Pear Island~28|Rabbit Island~29|Red Head Island~31|Redonda Island~03|Sandy Island~32|Smith Island~33|The Sisters~34|Vernon Island~35|Wicked Will Island~36|York Island~37"], ["Argentina", "AR", "Buenos Aires~B|Capital Federal~C|Catamarca~K|Chaco~H|Chubut~U|Córdoba~X|Corrientes~W|Entre Ríos~E|Formosa~P|Jujuy~Y|La Pampa~L|La Rioja~F|Mendoza~M|Misiones~N|Neuquén~Q|Río Negro~R|Salta~A|San Juan~J|San Luis~D|Santa Cruz~Z|Santa Fe~S|Santiago del Estero~G|Tierra del Fuego~V|Tucumán~T"], ["Armenia", "AM", "Aragatsotn~AG|Ararat~AR|Armavir~AV|Gegharkunik~GR|Kotayk~KT|Lori~LO|Shirak~SH|Syunik~SU|Tavush~TV|Vayots Dzor~VD|Yerevan~ER"], ["Aruba", "AW", "Aruba~AW"], ["Australia", "AU", "Australian Capital Territory~ACT|New South Wales~NSW|Northern Territory~NT|Queensland~QLD|South Australia~SA|Tasmania~TAS|Victoria~VIC|Western Australia~WA"], ["Austria", "AT", "Burgenland~1|Kärnten~2|Niederösterreich~3|Oberösterreich~4|Salzburg~5|Steiermark~6|Tirol~7|Vorarlberg~8|Wien~9"], ["Azerbaijan", "AZ", "Abşeron~ABS|Ağcabədi~AGC|Ağdam~AGM|Ağdaş~AGS|Ağstafa~AGA|Ağsu~AGU|Astara~AST|Babək~BAB|Balakən~BAL|Bərdə~BAR|Beyləqan~BEY|Biləsuvar~BIL|Cəbrayıl~CAB|Cəlilabad~CAL|Culfa~CUL|Daşkəsən~DAS|Füzuli~FUZ|Gədəbəy~GAD|Goranboy~GOR|Göyçay~GOY|Göygöl~GYG|Hacıqabul~HAC|İmişli~IMI|İsmayıllı~ISM|Kəlbəcər~KAL|Kǝngǝrli~KAN|Kürdəmir~KUR|Laçın~LAC|Lənkəran~LAN|Lerik~LER|Masallı~MAS|Neftçala~NEF|Oğuz~OGU|Ordubad~ORD|Qəbələ~QAB|Qax~QAX|Qazax~QAZ|Qobustan~QOB|Quba~QBA|Qubadli~QBI|Qusar~QUS|Saatlı~SAT|Sabirabad~SAB|Şabran~SBN|Sədərək~SAD|Şahbuz~SAH|Şəki~SAK|Salyan~SAL|Şamaxı~SMI|Şəmkir~SKR|Samux~SMX|Şərur~SAR|Siyəzən~SIY|Şuşa~SUS|Tərtər~TAR|Tovuz~TOV|Ucar~UCA|Xaçmaz~XAC|Xızı~XIZ|Xocalı~XCI|Xocavənd~XVD|Yardımlı~YAR|Yevlax~YEV|Zəngilan~ZAN|Zaqatala~ZAQ|Zərdab~ZAR"], ["Bahamas", "BS", "Acklins Island~01|Berry Islands~22|Bimini~02|Black Point~23|Cat Island~03|Central Abaco~24|Crooked Island and Long Cay~28|East Grand Bahama~29|Exuma~04|Freeport~05|Fresh Creek~06|Governor's Harbour~07|Green Turtle Cay~08|Harbour Island~09|High Rock~10|Inagua~11|Kemps Bay~12|Long Island~13|Marsh Harbour~14|Mayaguana~15|Moore’s Island~40|New Providence~16|Nichollstown and Berry Islands~17|North Abaco~42|North Andros~41|North Eleuthera~33|Ragged Island~18|Rock Sound~19|San Salvador and Rum Cay~20|Sandy Point~21|South Abaco~35|South Andros~36|South Eleuthera~37|West Grand Bahama~39"], ["Bahrain", "BH", "Al Janūbīyah~14|Al Manāmah~13|Al Muḩarraq~15|Al Wusţá~16|Ash Shamālīyah~17"], ["Bangladesh", "BD", "Barisal~A|Chittagong~B|Dhaka~C|Khulna~D|Mymensingh~M|Rajshahi~E|Rangpur~F|Sylhet~G"], ["Barbados", "BB", "Christ Church~01|Saint Andrew~02|Saint George~03|Saint James~04|Saint John~05|Saint Joseph~06|Saint Lucy~07|Saint Michael~08|Saint Peter~09|Saint Philip~10|Saint Thomas~11"], ["Belarus", "BY", "Brest voblast~BR|Gorod Minsk~HO|Homiel voblast~HO|Hrodna voblast~HR|Mahilyow voblast~MA|Minsk voblast~MI|Vitsebsk voblast~VI"], ["Belgium", "BE", "Bruxelles-Capitale~BRU|Région Flamande~VLG|Région Wallonië~WAL"], ["Belize", "BZ", "Belize District~BZ|Cayo District~CY|Corozal District~CZL|Orange Walk District~OW|Stann Creek District~SC|Toledo District~TOL"], ["Benin", "BJ", "Alibori~AL|Atakora~AK|Atlantique~AQ|Borgou~BO|Collines Department~CO|Donga~DO|Kouffo~KO|Littoral Department~LI|Mono Department~MO|Ouémé~OU|Plateau~PL|Zou~ZO"], ["Bermuda", "BM", "City of Hamilton~03|Devonshire Parish~01|Hamilton Parish~02|Paget Parish~04|Pembroke Parish~05|Sandys Parish~08|Smith's Parish~09|Southampton Parish~10|St. George's Parish~07|Town of St. George~06|Warwick Parish~11"], ["Bhutan", "BT", "Bumthang~33|Chhukha~12|Dagana~22|Gasa~GA|Haa~13|Lhuntse~44|Mongar~42|Paro~11|Pemagatshel~43|Punakha~23|Samdrup Jongkhar~45|Samtse~14|Sarpang~31|Thimphu~15|Trashigang~41|Trashiyangtse~TY|Trongsa~32|Tsirang~21|Wangdue Phodrang~24|Zhemgang~34"], ["Bolivia", "BO", "Beni~B|Chuquisaca~H|Cochabamba~C|La Paz~L|Oruro~O|Pando~N|Potosí~P|Santa Cruz~S|Tarija~T"], ["Bonaire, Sint Eustatius and Saba", "BQ", "Bonaire~BO|Saba Isand~SA|Sint Eustatius~SE"], ["Bosnia and Herzegovina", "BA", "Brčko Distrikt~BRC|Federacija Bosne i Hercegovine~BIH|Republika Srpska~SRP"], ["Botswana", "BW", "Central~CE|Ghanzi~GH|Kgalagadi~KG|Kgatleng~KL|Kweneng~KW|North West~NW|North-East~NE|South East~SE|Southern~SO"], ["Bouvet Island", "BV", "Bouvet Island~BV"], ["Brazil", "BR", "Acre~AC|Alagoas~AL|Amapá~AP|Amazonas~AM|Bahia~BA|Ceará~CE|Distrito Federal~DF|Espírito Santo~ES|Goiás~GO|Maranhão~MA|Mato Grosso~MT|Mato Grosso do Sul~MS|Minas Gerais~MG|Pará~PA|Paraíba~PB|Paraná~PR|Pernambuco~PE|Piauí~PI|Rio de Janeiro~RJ|Rio Grande do Norte~RN|Rio Grande do Sul~RS|Rondônia~RO|Roraima~RR|Santa Catarina~SC|São Paulo~SP|Sergipe~SE|Tocantins~TO"], ["British Indian Ocean Territory", "IO", "British Indian Ocean Territory~IO"], ["Brunei Darussalam", "BN", "Belait~BE|Brunei Muara~BM|Temburong~TE|Tutong~TU"], ["Bulgaria", "BG", "Blagoevgrad~01|Burgas~02|Dobrich~08|Gabrovo~07|Jambol~28|Khaskovo~26|Kjustendil~10|Kurdzhali~09|Lovech~11|Montana~12|Pazardzhik~13|Pernik~14|Pleven~15|Plovdiv~16|Razgrad~17|Ruse~18|Shumen~27|Silistra~19|Sliven~20|Smoljan~21|Sofija~23|Sofija-Grad~22|Stara Zagora~24|Turgovishhe~25|Varna~03|Veliko Turnovo~04|Vidin~05|Vraca~06"], ["Burkina Faso", "BF", "Balé~BAL|Bam/Lake Bam~BAM|Banwa Province~BAN|Bazèga~BAZ|Bougouriba~BGR|Boulgou Province~BLG|Boulkiemdé~BLK|Comoé/Komoe~COM|Ganzourgou Province~GAN|Gnagna~GNA|Gourma Province~GOU|Houet~HOU|Ioba~IOB|Kadiogo~KAD|Kénédougou~KEN|Komondjari~KMD|Kompienga~KMP|Kossi Province~KOS|Koulpélogo~KOP|Kouritenga~KOT|Kourwéogo~KOW|Léraba~LER|Loroum~LOR|Mouhoun~MOU|Namentenga~NAM|Naouri/Nahouri~NAO|Nayala~NAY|Noumbiel~NOU|Oubritenga~OUB|Oudalan~OUD|Passoré~PAS|Poni~PON|Sanguié~SNG|Sanmatenga~SMT|Séno~SEN|Sissili~SIS|Soum~SOM|Sourou~SOR|Tapoa~TAP|Tui/Tuy~TUI|Yagha~YAG|Yatenga~YAT|Ziro~ZIR|Zondoma~ZON|Zoundwéogo~ZOU"], ["Burundi", "BI", "Bubanza~BB|Bujumbura Mairie~BM|Bujumbura Rural~BL|Bururi~BR|Cankuzo~CA|Cibitoke~CI|Gitega~GI|Karuzi~KR|Kayanza~KY|Kirundo~KI|Makamba~MA|Muramvya~MU|Muyinga~MY|Mwaro~MW|Ngozi~NG|Rutana~RT|Ruyigi~RY"], ["Cambodia", "KH", "Baat Dambang~2|Banteay Mean Chey~1|Kampong Chaam~3|Kampong Chhnang~4|Kampong Spueu~5|Kampong Thum~6|Kampot~7|Kandaal~8|Kaoh Kong~9|Kracheh~10|Krong Kaeb~23|Krong Pailin~24|Krong Preah Sihanouk~18|Mondol Kiri~11|Otdar Mean Chey~22|Phnom Penh~12|Pousaat~15|Preah Vihear~13|Prey Veaeng~14|Rotanah Kiri~16|Siem Reab~17|Stueng Treng~19|Svaay Rieng~20|Taakaev~21|Tbong Khmum~25"], ["Cameroon", "CM", "Adamaoua~AD|Centre~CE|Est~ES|Extrême-Nord~EN|Littoral~LT|Nord~NO|Nord-Ouest~NW|Ouest~OU|Sud~SU|Sud-Ouest~SW"], ["Canada", "CA", "Alberta~AB|British Columbia~BC|Manitoba~MB|New Brunswick~NB|Newfoundland and Labrador~NL|Northwest Territories~NT|Nova Scotia~NS|Nunavut~NU|Ontario~ON|Prince Edward Island~PE|Quebec~QC|Saskatchewan~SK|Yukon~YT"], ["Cape Verde", "CV", "Boa Vista~BV|Brava~BR|Calheta de São Miguel~CS|Maio~MA|Mosteiros~MO|Paúl~PA|Porto Novo~PN|Praia~PR|Ribeira Brava~RB|Ribeira Grande~RG|Sal~SL|Santa Catarina~CA|Santa Cruz~CR|São Domingos~SD|São Filipe~SF|São Nicolau~SN|São Vicente~SV|Tarrafal~TA|Tarrafal de São Nicolau~TS"], ["Cayman Islands", "KY", "Creek|Eastern|Midland|South Town|Spot Bay|Stake Bay|West End|Western"], ["Central African Republic", "CF", "Bamingui-Bangoran~BB|Bangui~BGF|Basse-Kotto~BK|Haute-Kotto~HK|Haut-Mbomou~HM|Kémo~KG|Lobaye~LB|Mambéré-Kadéï~HS|Mbomou~MB|Nana-Grebizi~10|Nana-Mambéré~NM|Ombella-M'Poko~MP|Ouaka~UK|Ouham~AC|Ouham Péndé~OP|Sangha-Mbaéré~SE|Vakaga~VK"], ["Chad", "TD", "Bahr el Ghazal~BG|Batha~BA|Borkou~BO|Chari-Baguirmi~CB|Ennedi-Est~EE|Ennedi-Ouest~EO|Guéra~GR|Hadjer Lamis~HL|Kanem~KA|Lac~LC|Logone Occidental~LO|Logone Oriental~LR|Mondoul~MA|Mayo-Kébbi-Est~ME|Moyen-Chari~MC|Ouaddai~OD|Salamat~SA|Sila~SI|Tandjilé~TA|Tibesti~TI|Ville de Ndjamena~ND|Wadi Fira~WF"], ["Chile", "CL", "Aisén del General Carlos Ibáñez del Campo~AI|Antofagasta~AN|Araucanía~AR|Arica y Parinacota~AP|Atacama~AT|Bío-Bío~BI|Coquimbo~CO|Libertador General Bernardo O'Higgins~LI|Los Lagos~LL|Los Ríos~LR|Magallanes y Antartica Chilena~MA|Marga-Marga~|Maule~ML|Región Metropolitana de Santiago~RM|Tarapacá~TA|Valparaíso~VS"], ["China", "CN", "Anhui~34|Beijing~11|Chongqing~50|Fujian~35|Gansu~62|Guangdong~44|Guangxi~45|Guizhou~52|Hainan~46|Hebei~13|Heilongjiang~23|Henan~41|Hong Kong~91|Hubei~42|Hunan~43|Inner Mongolia~15|Jiangsu~32|Jiangxi~36|Jilin~22|Liaoning~21|Macau~92|Ningxia~64|Qinghai~63|Shaanxi~61|Shandong~37|Shanghai~31|Shanxi~14|Sichuan~51|Tianjin~12|Tibet~54|Xinjiang~65|Yunnan~53|Zhejiang~33"], ["Christmas Island", "CX", "Christmas Island~CX"], ["Cocos (Keeling) Islands", "CC", "Direction Island~DI|Home Island~HM|Horsburgh Island~HR|North Keeling Island~NK|South Island~SI|West Island~WI"], ["Colombia", "CO", "Amazonas~AMA|Antioquia~ANT|Arauca~ARA|Archipiélago de San Andrés~SAP|Atlántico~ATL|Bogotá D.C.~DC|Bolívar~BOL|Boyacá~BOY|Caldas~CAL|Caquetá~CAQ|Casanare~CAS|Cauca~CAU|Cesar~CES|Chocó~CHO|Córdoba~COR|Cundinamarca~CUN|Guainía~GUA|Guaviare~GUV|Huila~HUI|La Guajira~LAG|Magdalena~MAG|Meta~MET|Nariño~NAR|Norte de Santander~NSA|Putumayo~PUT|Quindío~QUI|Risaralda~RIS|Santander~SAN|Sucre~SUC|Tolima~TOL|Valle del Cauca~VAC|Vaupés~VAU|Vichada~VID"], ["Comoros", "KM", "Andjazîdja~G|Andjouân~A|Moûhîlî~M"], ["Congo, Republic of the (Brazzaville)", "CG", "Bouenza~11|Brazzaville~BZV|Cuvette~8|Cuvette-Ouest~15|Kouilou~5|Lékoumou~2|Likouala~7|Niari~9|Plateaux~14|Pointe-Noire~16|Pool~12|Sangha~13"], ["Congo, the Democratic Republic of the (Kinshasa)", "CD", "Bandundu~BN|Bas-Congo~BC|Équateur~EQ|Kasaï-Occidental~KE|Kasaï-Oriental~KW|Katanga~KA|Kinshasa~KN|Maniema~MA|Nord-Kivu~NK|Orientale~OR|Sud-Kivu~SK"], ["Cook Islands", "CK", "Aitutaki|Atiu|Avarua|Mangaia|Manihiki|Ma'uke|Mitiaro|Nassau|Palmerston|Penrhyn|Pukapuka|Rakahanga"], ["Costa Rica", "CR", "Alajuela~2|Cartago~3|Guanacaste~5|Heredia~4|Limón~7|Puntarenas~6|San José~1"], ["Côte d'Ivoire, Republic of", "CI", "Agnéby~16|Bafing~17|Bas-Sassandra~09|Denguélé~10|Dix-Huit Montagnes~06|Fromager~18|Haut-Sassandra~02|Lacs~07|Lagunes~01|Marahoué~12|Moyen-Cavally~19|Moyen-Comoé~05|N'zi-Comoé~11|Savanes~03|Sud-Bandama~15|Sud-Comoé~13|Vallée du Bandama~04|Worodougou~14|Zanzan~08"], ["Croatia", "HR", "Bjelovarsko-Bilogorska Županija~07|Brodsko-Posavska Županija~12|Dubrovačko-Neretvanska Županija~19|Grad Zagreb~21|Istarska Županija~18|Karlovačka Županija~04|Koprivničko-Krizevačka Županija~06|Krapinsko-Zagorska Županija~02|Ličko-Senjska Županija~09|Međimurska Županija~20|Osječko-Baranjska Županija~14|Požeško-Slavonska Županija~11|Primorsko-Goranska Županija~08|Sisačko-Moslavačka Županija~03|Splitsko-Dalmatinska Županija~17|Sibensko-Kninska Županija~15|Varaždinska Županija~05|Virovitičko-Podravska Županija~10|Vukovarsko-Srijemska Županija~16|Zadarska Županija~13|Zagrebacka Zupanija~01"], ["Cuba", "CU", "Artemisa~15|Camagüey~09|Ciego de Ávila~08|Cienfuegos~06|Granma~12|Guantánamo~14|Holguín~11|Isla de la Juventud~99|La Habana~03|Las Tunas~10|Matanzas~04|Mayabeque~16|Pinar del Río~01|Sancti Spíritus~07|Santiago de Cuba~13|Villa Clara~05"], ["Curaçao", "CW", "Curaçao~CW"], ["Cyprus", "CY", "Ammochostos~04|Keryneia~05|Larnaka~03|Lefkosia~01|Lemesos~02|Pafos~05"], ["Czech Republic", "CZ", "Hlavní město Praha~PR|Jihočeský kraj~JC|Jihomoravský kraj~JM|Karlovarský kraj~KA|Královéhradecký kraj~KR|Liberecký kraj~LI|Moravskoslezský kraj~MO|Olomoucký kraj~OL|Pardubický kraj~PA|Plzeňský kraj~PL|Středočeský kraj~ST|Ústecký kraj~US|Vysočina~VY|Zlínský kraj~ZL"], ["Denmark", "DK", "Hovedstaden~84|Kujalleq~GL-KU|Midtjylland~82|Norderøerne~FO-01|Nordjylland~81|Østerø~FO-06|Qaasuitsup~GL-QA|Qeqqata~GL-QE|Sandø~FO-02|Sermersooq~GL-SM|Sjælland~85|Strømø~FO-03|Suderø~FO-04|Syddanmark~83|Vågø~FO-05"], ["Djibouti", "DJ", "Ali Sabieh~AS|Arta~AR|Dikhil~DI|Obock~OB|Tadjourah~TA"], ["Dominica", "DM", "Saint Andrew Parish~02|Saint David Parish~03|Saint George Parish~04|Saint John Parish~05|Saint Joseph Parish~06|Saint Luke Parish~07|Saint Mark Parish~08|Saint Patrick Parish~09|Saint Paul Parish~10|Saint Peter Parish~11"], ["Dominican Republic", "DO", "Cibao Central~02|Del Valle~37|Distrito Nacional~01|Enriquillo~38|Norcentral~04|Nordeste~34|Noroeste~34|Norte~35|Valdesia~42"], ["Ecuador", "EC", "Azuay~A|Bolívar~B|Cañar~F|Carchi~C|Chimborazo~H|Cotopaxi~X|El Oro~O|Esmeraldas~E|Galápagos~W|Guayas~G|Imbabura~I|Loja~L|Los Ríos~R|Manabí~M|Morona-Santiago~S|Napo~N|Orellana~D|Pastaza~Y|Pichincha~P|Santa Elena~SE|Santo Domingo de los Tsáchilas~SD|Sucumbíos~U|Tungurahua~T|Zamora-Chinchipe~Z"], ["Egypt", "EG", "Alexandria~ALX|Aswan~ASN|Asyout~AST|Bani Sueif~BNS|Beheira~BH|Cairo~C|Daqahlia~DK|Dumiat~DT|El Bahr El Ahmar~BA|El Ismailia~IS|El Suez~SUZ|El Wadi El Gedeed~WAD|Fayoum~FYM|Gharbia~GH|Giza~SUZ|Helwan~HU|Kafr El Sheikh~KFS|Luxor~LX|Matrouh~MT|Menia~MN|Menofia~MNF|North Sinai~SIN|Port Said~PTS|Qalubia~KB|Qena~KN|Sharqia~SHR|Sixth of October~SU|Sohag~SHG|South Sinai~JS"], ["El Salvador", "SV", "Ahuachapán~AH|Cabañas~CA|Cuscatlán~CU|Chalatenango~CH|La Libertad~LI|La Paz~PA|La Unión~UN|Morazán~MO|San Miguel~SM|San Salvador~SS|Santa Ana~SA|San Vicente~SV|Sonsonate~SO|Usulután~US"], ["Equatorial Guinea", "GQ", "Annobón~AN|Bioko Norte~BN|Bioko Sur~BS|Centro Sur~CS|Kié-Ntem~KN|Litoral~LI|Wele-Nzas~WN"], ["Eritrea", "ER", "Anseba~AN|Debub~DU|Debub-Keih-Bahri~DK|Gash-Barka~GB|Maekel~MA|Semien-Keih-Bahri~SK"], ["Estonia", "EE", "Harjumaa (Tallinn)~37|Hiiumaa (Kardla)~39|Ida-Virumaa (Johvi)~44|Järvamaa (Paide)~41|Jõgevamaa (Jogeva)~49|Läänemaa~57|Lääne-Virumaa (Rakvere)~59|Pärnumaa (Parnu)~67|Põlvamaa (Polva)~65|Raplamaa (Rapla)~70|Saaremaa (Kuessaare)~74|Tartumaa (Tartu)~78|Valgamaa (Valga)~82|Viljandimaa (Viljandi)~84|Võrumaa (Voru)~86"], ["Ethiopia", "ET", "Addis Ababa~AA|Afar~AF|Amhara~AM|Benshangul-Gumaz~BE|Dire Dawa~DD|Gambela~GA|Harari~HA|Oromia~OR|Somali~SO|Southern Nations Nationalities and People's Region~SN|Tigray~TI"], ["Falkland Islands (Islas Malvinas)", "FK", "Falkland Islands (Islas Malvinas)"], ["Faroe Islands", "FO", "Bordoy|Eysturoy|Mykines|Sandoy|Skuvoy|Streymoy|Suduroy|Tvoroyri|Vagar"], ["Fiji", "FJ", "Ba~01|Bua~01|Cakaudrove~03|Kadavu~04|Lau~05|Lomaiviti~06|Macuata~07|Nadroga and Navosa~08|Naitasiri~09|Namosi~10|Ra~011|Rewa~12|Rotuma~R|Serua~12|Tailevu~14"], ["Finland", "FI", "Ahvenanmaan lääni~AL|Etelä-Suomen lääni~ES|Itä-Suomen lääni~IS|Länsi-Suomen lääni~LS|Lapin lääni~LL|Oulun lääni~OL"], ["France", "FR", "Auvergne-Rhône-Alpes~ARA|Bourgogne-Franche-Comté~BFC|Bretagne~BRE|Centre-Val de Loire~CVL|Corse~COR|Grand Est~GES|Hauts-de-France~HDF|Île-de-France~IDF|Normandie~NOR|Nouvelle-Aquitaine~NAQ|Occitanie~OCC|Pays de la Loire~PDL|Provence-Alpes-Cote d'Azur~PAC|Clipperton~CP|Guadeloupe~GP|Guyane~GF|Martinique~MQ|Mayotte~YT|Novelle-Calédonie~NC|Polynésie~PF|Saint-Pierre-et-Miquelon~PM|Saint Barthélemy~BL|Saint Martin~MF|Réunion~RE|Terres Australes Françaises~TF|Wallis-et-Futuna~WF"], ["French Guiana", "GF", "French Guiana"], ["French Polynesia", "PF", "Archipel des Marquises|Archipel des Tuamotu|Archipel des Tubuai|Iles du Vent|Iles Sous-le-Vent"], ["French Southern and Antarctic Lands", "TF", "Adelie Land|Ile Crozet|Iles Kerguelen|Iles Saint-Paul et Amsterdam"], ["Gabon", "GA", "Estuaire~1|Haut-Ogooué~2|Moyen-Ogooué~3|Ngounié~4|Nyanga~5|Ogooué-Ivindo~6|Ogooué-Lolo~7|Ogooué-Maritime~8|Woleu-Ntem~9"], ["Gambia, The", "GM", "Banjul~B|Central River~M|Lower River~L|North Bank~N|Upper River~U|Western~W"], ["Georgia", "GE", "Abkhazia (Sokhumi)~AB|Ajaria (Bat'umi)~AJ|Guria~GU|Imereti~IM|K'akheti~KA|Kvemo Kartli~KK|Mtshkheta-Mtianeti~MM|Rach'a-Lexhkumi-KvemoSvaneti~RL|Samegrelo-Zemo Svaneti~SZ|Samtskhe-Javakheti~SJ|Shida Kartli~SK|Tbilisi~TB"], ["Germany", "DE", "Baden-Württemberg~BW|Bayern~BY|Berlin~BE|Brandenburg~BB|Bremen~HB|Hamburg~HH|Hessen~HE|Mecklenburg-Vorpommern~MV|Niedersachsen~NI|Nordrhein-Westfalen~NW|Rheinland-Pfalz~RP|Saarland~SL|Sachsen~SN|Sachsen-Anhalt~ST|Schleswig-Holstein~SH|Thüringen~TH"], ["Ghana", "GH", "Ashanti~AH|Brong-Ahafo~BA|Central~CP|Eastern~EP|Greater Accra~AA|Northern~NP|Upper East~UE|Upper West~UW|Volta~TV|Western~WP"], ["Gibraltar", "GI", "Gibraltar"], ["Greece", "GR", "Anatolikí Makedonía kai Thráki~A|Attikḯ~I|Dytikí Elláda~G|Dytikí Makedonía~C|Ionía Nísia~F|Kentrikí Makedonía~B|Krítí~M|Notío Aigaío~L|Peloponnísos~J|Stereá Elláda~H|Thessalía~E|Voreío Aigaío~K|Ípeiros~D|Ágion Óros~69"], ["Greenland", "GL", "Kommune Kujalleq~KU|Kommuneqarfik Sermersooq~SM|Qaasuitsup Kommunia~QA|Qeqqata Kommunia~QE"], ["Grenada", "GD", "Saint Andrew~01|Saint David~02|Saint George~03|Saint John~04|Saint Mark~05|Saint Patrick~06|Southern Grenadine Islands~10"], ["Guadeloupe", "GP", "Guadeloupe"], ["Guam", "GU", "Guam"], ["Guatemala", "GT", "Alta Verapaz~AV|Baja Verapaz~BV|Chimaltenango~CM|Chiquimula~CQ|El Progreso~PR|Escuintla~ES|Guatemala~GU|Huehuetenango~HU|Izabal~IZ|Jalapa~JA|Jutiapa~JU|Petén~PE|Quetzaltenango~QZ|Quiché~QC|Retalhuleu~Re|Sacatepéquez~SA|San Marcos~SM|Santa Rosa~SR|Sololá~SO|Suchitepéquez~SU|Totonicapán~TO|Zacapa~ZA"], ["Guernsey", "GG", "Castel|Forest|St. Andrew|St. Martin|St. Peter Port|St. Pierre du Bois|St. Sampson|St. Saviour|Torteval|Vale"], ["Guinea", "GN", "Boké~B|Conakry~C|Faranah~F|Kankan~K|Kindia~D|Labé~L|Mamou~M|Nzérékoré~N"], ["Guinea-Bissau", "GW", "Bafatá~BA|Biombo~BM|Bissau~BS|Bolama-Bijagos~BL|Cacheu~CA|Gabú~GA|Oio~OI|Quinara~QU|Tombali~TO"], ["Guyana", "GY", "Barima-Waini~BA|Cuyuni-Mazaruni~CU|Demerara-Mahaica~DE|East Berbice-Corentyne~EB|Essequibo Islands-West Demerara~ES|Mahaica-Berbice~MA|Pomeroon-Supenaam~PM|Potaro-Siparuni~PT|Upper Demerara-Berbice~UD|Upper Takutu-Upper Essequibo~UT"], ["Haiti", "HT", "Artibonite~AR|Centre~CE|Grand'Anse~GA|Nippes~NI|Nord~ND|Nord-Est~NE|Nord-Ouest~NO|Ouest~OU|Sud~SD|Sud-Est~SE"], ["Heard Island and McDonald Islands", "HM", "Heard Island and McDonald Islands"], ["Holy See (Vatican City)", "VA", "Holy See (Vatican City)~01"], ["Honduras", "HN", "Atlántida~AT|Choluteca~CH|Colón~CL|Comayagua~CM|Copán~CP|Cortés~CR|El Paraíso~EP|Francisco Morazan~FM|Gracias a Dios~GD|Intibucá~IN|Islas de la Bahía~IB|La Paz~LP|Lempira~LE|Ocotepeque~OC|Olancho~OL|Santa Bárbara~SB|Valle~VA|Yoro~YO"], ["Hong Kong", "HK", "Hong Kong"], ["Hungary", "HU", "Bács-Kiskun~BK|Baranya~BA|Békés~BE|Békéscsaba~BC|Borsod-Abauj-Zemplen~BZ|Budapest~BU|Csongrád~CS|Debrecen~DE|Dunaújváros~DU|Eger~EG|Érd~ER|Fejér~FE|Győr~GY|Győr-Moson-Sopron~GS|Hajdú-Bihar~HB|Heves~HE|Hódmezővásárhely~HV|Jász-Nagykun-Szolnok~N|Kaposvár~KV|Kecskemét~KM|Komárom-Esztergom~KE|Miskolc~MI|Nagykanizsa~NK|Nógrád~NO|Nyíregyháza~NY|Pécs~PS|Pest~PE|Salgótarján~ST|Somogy~SO|Sopron~SN|Szabolcs-á-Bereg~SZ|Szeged~SD|Székesfehérvár~SF|Szekszárd~SS|Szolnok~SK|Szombathely~SH|Tatabánya~TB|Tolna~TO|Vas~VA|Veszprém~VE|Veszprém (City)~VM|Zala~ZA|Zalaegerszeg~ZE"], ["Iceland", "IS", "Austurland~7|Höfuðborgarsvæði utan Reykjavíkur~1|Norðurland eystra~6|Norðurland vestra~5|Suðurland~8|Suðurnes~2|Vestfirðir~4|Vesturland~3"], ["India", "IN", "Andaman and Nicobar Islands~AN|Andhra Pradesh~AP|Arunachal Pradesh~AR|Assam~AS|Bihar~BR|Chandigarh~CH|Chhattisgarh~CT|Dadra and Nagar Haveli~DN|Daman and Diu~DD|Delhi~DL|Goa~GA|Gujarat~GJ|Haryana~HR|Himachal Pradesh~HP|Jammu and Kashmir~JK|Jharkhand~JH|Karnataka~KA|Kerala~KL|Lakshadweep~LD|Madhya Pradesh~MP|Maharashtra~MH|Manipur~MN|Meghalaya~ML|Mizoram~MZ|Nagaland~NL|Odisha~OR|Puducherry~PY|Punjab~PB|Rajasthan~RJ|Sikkim~WK|Tamil Nadu~TN|Telangana~TG|Tripura~TR|Uttarakhand~UT|Uttar Pradesh~UP|West Bengal~WB"], ["Indonesia", "ID", "Aceh~AC|Bali~BA|Bangka Belitung~BB|Banten~BT|Bengkulu~BE|Gorontalo~GO|Jakarta Raya~JK|Jambi~JA|Jawa Barat~JB|Jawa Tengah~JT|Jawa Timur~JI|Kalimantan Barat~KB|Kalimantan Selatan~KS|Kalimantan Tengah~KT|Kalimantan Timur~KI|Kalimantan Utara~KU|Kepulauan Riau~KR|Lampung~LA|Maluku~MA|Maluku Utara~MU|Nusa Tenggara Barat~NB|Nusa Tenggara Timur~NT|Papua~PA|Papua Barat~PB|Riau~RI|Sulawesi Selatan~SR|Sulawesi Tengah~ST|Sulawesi Tenggara~SG|Sulawesi Utara~SA|Sumatera Barat~SB|Sumatera Selatan~SS|Sumatera Utara~SU|Yogyakarta~YO"], ["Iran, Islamic Republic of", "IR", "Alborz~32|Ardabīl~03|Āz̄arbāyjān-e Gharbī~02|Āz̄arbāyjān-e Sharqī~01|Būshehr~06|Chahār Maḩāl va Bakhtīārī~08|Eşfahān~04|Fārs~14|Gīlān~19|Golestān~27|Hamadān~24|Hormozgān~23|Īlām~05|Kermān~15|Kermānshāh~17|Khorāsān-e Jonūbī~29|Khorāsān-e Raẕavī~30|Khorāsān-e Shomālī~61|Khūzestān~10|Kohgīlūyeh va Bowyer Aḩmad~18|Kordestān~16|Lorestān~20|Markazi~22|Māzandarān~21|Qazvīn~28|Qom~26|Semnān~12|Sīstān va Balūchestān~13|Tehrān~07|Yazd~25|Zanjān~11"], ["Iraq", "IQ", "Al Anbār~AN|Al Başrah~BA|Al Muthanná~MU|Al Qādisīyah~QA|An Najaf~NA|Arbīl~AR|As Sulaymānīyah~SU|Bābil~BB|Baghdād~BG|Dohuk~DA|Dhī Qār~DQ|Diyālá~DI|Karbalā'~KA|Kirkuk~KI|Maysān~MA|Nīnawá~NI|Şalāḩ ad Dīn~SD|Wāsiţ~WA"], ["Ireland", "IE", "Carlow~CW|Cavan~CN|Clare~CE|Cork~CO|Donegal~DL|Dublin~D|Galway~G|Kerry~KY|Kildare~KE|Kilkenny~KK|Laois~LS|Leitrim~LM|Limerick~LK|Longford~LD|Louth~LH|Mayo~MO|Meath~MH|Monaghan~MN|Offaly~OY|Roscommon~RN|Sligo~SO|Tipperary~TA|Waterford~WD|Westmeath~WH|Wexford~WX|Wicklow~WW"], ["Isle of Man", "IM", "Isle of Man"], ["Israel", "IL", "HaDarom~D|HaMerkaz~M|HaTsafon~Z|H̱efa~HA|Tel-Aviv~TA|Yerushalayim~JM"], ["Italy", "IT", "Abruzzo~65|Basilicata~77|Calabria~78|Campania~72|Emilia-Romagna~45|Friuli-Venezia Giulia~36|Lazio~62|Liguria~42|Lombardia~25|Marche~57|Molise~67|Piemonte~21|Puglia~75|Sardegna~88|Sicilia~82|Toscana~52|Trentino-Alto Adige~32|Umbria~55|Valle d'Aosta~23|Veneto~34"], ["Jamaica", "JM", "Clarendon~13|Hanover~09|Kingston~01|Manchester~12|Portland~04|Saint Andrew~02|Saint Ann~06|Saint Catherine~14|Saint Elizabeth~11|Saint James~08|Saint Mary~05|Saint Thomas~03|Trelawny~07|Westmoreland~10"], ["Japan", "JP", "Aichi~23|Akita~05|Aomori~02|Chiba~12|Ehime~38|Fukui~18|Fukuoka~40|Fukushima~07|Gifu~21|Gunma~10|Hiroshima~34|Hokkaido~01|Hyogo~28|Ibaraki~08|Ishikawa~17|Iwate~03|Kagawa~37|Kagoshima~46|Kanagawa~14|Kochi~39|Kumamoto~43|Kyoto~26|Mie~24|Miyagi~04|Miyazaki~45|Nagano~20|Nagasaki~42|Nara~29|Niigata~15|Oita~44|Okayama~33|Okinawa~47|Osaka~27|Saga~41|Saitama~11|Shiga~25|Shimane~32|Shizuoka~22|Tochigi~09|Tokushima~36|Tokyo~13|Tottori~31|Toyama~16|Wakayama~30|Yamagata~06|Yamaguchi~35|Yamanashi~19"], ["Jersey", "JE", "Jersey"], ["Jordan", "JO", "‘Ajlūn~AJ|Al 'Aqabah~AQ|Al Balqā’~BA|Al Karak~KA|Al Mafraq~MA|Al ‘A̅şimah~AM|Aţ Ţafīlah~AT|Az Zarqā’~AZ|Irbid~IR|Jarash~JA|Ma‘ān~MN|Mādabā~MD"], ["Kazakhstan", "KZ", "Almaty~ALA|Aqmola~AKM|Aqtobe~AKT|Astana~AST|Atyrau~ATY|Batys Qazaqstan~ZAP|Bayqongyr|Mangghystau~MAN|Ongtustik Qazaqstan~YUZ|Pavlodar~PAV|Qaraghandy~KAR|Qostanay~KUS|Qyzylorda~KZY|Shyghys Qazaqstan~VOS|Soltustik Qazaqstan~SEV|Zhambyl~ZHA"], ["Kenya", "KE", "Baringo~01|Bomet~02|Bungoma~03|Busia~04|Eleyo/Marakwet~05|Embu~06|Garissa~07|Homa Bay~08|Isiolo~09|Kajiado~10|Kakamega~11|Kericho~12|Kiambu~13|Kilifi~14|Kirinyaga~15|Kisii~16|Kisumu~17|Kitui~18|Kwale~19|Laikipia~20|Lamu~21|Machakos~22|Makueni~23|Mandera~24|Marsabit~25|Meru~26|Migori~27|Mombasa~28|Murang'a~29|Nairobi City~30|Nakuru~31|Nandi~32|Narok~33|Nyamira~34|Nyandarua~35|Nyeri~36|Samburu~37|Siaya~38|Taita/Taveta~39|Tana River~40|Tharaka-Nithi~41|Trans Nzoia~42|Turkana~43|Uasin Gishu~44|Vihiga~45|Wajir~46|West Pokot~47"], ["Kiribati", "KI", "Abaiang|Abemama|Aranuka|Arorae|Banaba|Beru|Butaritari|Central Gilberts|Gilbert Islands~G|Kanton|Kiritimati|Kuria|Line Islands~L|Maiana|Makin|Marakei|Nikunau|Nonouti|Northern Gilberts|Onotoa|Phoenix Islands~P|Southern Gilberts|Tabiteuea|Tabuaeran|Tamana|Tarawa|Teraina"], ["Korea, Democratic People's Republic of", "KP", "Chagang-do (Chagang Province)~04|Hamgyong-bukto (North Hamgyong Province)~09|Hamgyong-namdo (South Hamgyong Province)~08|Hwanghae-bukto (North Hwanghae Province)~06|Hwanghae-namdo (South Hwanghae Province)~05|Kangwon-do (Kangwon Province)~07|Nasŏn (Najin-Sŏnbong)~13|P'yongan-bukto (North P'yongan Province)~03|P'yongan-namdo (South P'yongan Province)~02|P'yongyang-si (P'yongyang City)~01|Yanggang-do (Yanggang Province)~10"], ["Korea, Republic of", "KR", "Ch'ungch'ongbuk-do~43|Ch'ungch'ongnam-do~44|Cheju-do~49|Chollabuk-do~45|Chollanam-do~46|Inch'on-Kwangyokhi~28|Kang-won-do~42|Kwangju-Kwangyokshi~28|Kyonggi-do~41|Kyongsangbuk-do~47|Kyongsangnam-do~48|Pusan-Kwangyokshi~26|Seoul-T'ukpyolshi~11|Sejong~50|Taegu-Kwangyokshi~27|Taejon-Kwangyokshi~30|Ulsan-Kwangyokshi~31"], ["Kuwait", "KW", "Al Aḩmadi~AH|Al Farwānīyah~FA|Al Jahrā’~JA|Al ‘Āşimah~KU|Ḩawallī~HA|Mubārak al Kabir~MU"], ["Kyrgyzstan", "KG", "Batken Oblasty~B|Bishkek Shaary~GB|Chuy Oblasty (Bishkek)~C|Jalal-Abad Oblasty~J|Naryn Oblasty~N|Osh Oblasty~O|Talas Oblasty~T|Ysyk-Kol Oblasty (Karakol)~Y"], ["Laos", "LA", "Attapu~AT|Bokèo~BK|Bolikhamxai~BL|Champasak~CH|Houaphan~HO|Khammouan~KH|Louang Namtha~LM|Louangphabang~LP|Oudômxai~OU|Phôngsali~PH|Salavan~SL|Savannakhét~SV|Vientiane~VI|Xaignabouli~XA|Xékong~XE|Xaisomboun~XS|Xiangkhouang~XI"], ["Latvia", "LV", "Aglona~001|Aizkraukle~002|Aizpute~003|Aknīste~004|Aloja~005|Alsunga~06|Alūksne~007|Amata~008|Ape~009|Auce~010|Ādaži~011|Babīte~012|Baldone~013|Baltinava~014|Balvi~015|Bauska~016|Beverīna~017|Brocēni~018|Burtnieki~019|Carnikava~020|Cesvaine~021|Cēsis~022|Cibla~023|Dagda~024|Daugavpils~025|Daugavpils (City)~DGV|Dobele~026|Dundaga~027|Durbe~028|Engure~029|Ērgļi~030|Garkalne~031|Grobiņa~032|Gulbene~033|Iecava~034|Ikšķile~035|Ilūkste~036|Inčukalns~037|Jaunjelgava~038|Jaunpiebalga~039|Jaunpils~040|Jelgava~041|Jelgava (City)~JEL|Jēkabpils~042|Jēkabpils (City)~JKB|Jūrmala (City)~JUR|Kandava~043|Kārsava~044|Kocēni~045|Koknese~046|Krāslava~047|Krimulda~048|Krustpils~049|Kuldīga~050|Ķegums~051|Ķekava~052|Lielvārde~053|Liepāja~LPX|Limbaži~054|Līgatne~055|Līvāni~056|Lubāna~057|Ludza~058|Madona~059|Mazsalaca~060|Mālpils~061|Mārupe~062|Mērsrags~063|Naukšēni~064|Nereta~065|Nīca~066|Ogre~067|Olaine~068|Ozolnieki~069|Pārgauja~070|Pāvilosta~071|Pļaviņas~072|Preiļi~073|Priekule~074|Priekuļi~075|Rauna~076|Rēzekne~077|Rēzekne (City)~REZ|Riebiņi~078|Rīga~RIX|Roja~079|Ropaži~080|Rucava~081|Rugāji~082|Rundāle~083|Rūjiena~084|Sala~085|Salacgrīva~086|Salaspils~087|Saldus~088|Saulkrasti~089|Sēja~090|Sigulda~091|Skrīveri~092|Skrunda~093|Smiltene~094|Stopiņi~095|Strenči~096|Talsi~097|Tērvete~098|Tukums~099|Vaiņode~100|Valka~101|Valmiera~VMR|Varakļāni~102|Vārkava~103|Vecpiebalga~104|Vecumnieki~105|Ventspils~106|Ventspils (City)~VEN|Viesīte~107|Viļaka~108|Viļāni~109|Zilupe~110"], ["Lebanon", "LB", "Aakkâr~AK|Baalbelk-Hermel~BH|Béqaa~BI|Beyrouth~BA|Liban-Nord~AS|Liban-Sud~JA|Mont-Liban~JL|Nabatîyé~NA"], ["Lesotho", "LS", "Berea~D|Butha-Buthe~B|Leribe~C|Mafeteng~E|Maseru~A|Mohales Hoek~F|Mokhotlong~J|Qacha's Nek~H|Quthing~G|Thaba-Tseka~K"], ["Liberia", "LR", "Bomi~BM|Bong~BG|Gbarpolu~GP|Grand Bassa~GB|Grand Cape Mount~CM|Grand Gedeh~GG|Grand Kru~GK|Lofa~LO|Margibi~MG|Maryland~MY|Montserrado~MO|Nimba~NI|River Cess~RI|River Geee~RG|Sinoe~SI"], ["Libya", "LY", "Al Buţnān~BU|Al Jabal al Akhḑar~JA|Al Jabal al Gharbī~JG|Al Jafārah~JA|Al Jufrah~JU|Al Kufrah~FK|Al Marj~MJ|Al Marquab~MB|Al Wāḩāt~WA|An Nuqaţ al Khams~NQ|Az Zāwiyah~ZA|Banghāzī~BA|Darnah~DR|Ghāt~GH|Mişrātah~MI|Murzuq~MQ|Nālūt~NL|Sabhā~SB|Surt~SR|Ţarābulus~TB|Yafran~WD|Wādī ash Shāţiʾ~WS"], ["Liechtenstein", "LI", "Balzers~01|Eschen~02|Gamprin~03|Mauren~04|Planken~05|Ruggell~06|Schaan~07|Schellenberg~08|Triesen~09|Triesenberg~10|Vaduz~11"], ["Lithuania", "LT", "Alytaus~AL|Kauno~KU|Klaipėdos~KL|Marijampolės~MR|Panevėžio~PN|Šiaulių~SA|Tauragės~TA|Telšių~TE|Utenos~UT|Vilniaus~VL"], ["Luxembourg", "LU", "Capellen~CA|Clevaux~CL|Diekirch~DI|Echternach~EC|Esch-sur-Alzette~ES|Grevenmacher~GR|Luxembourg~LU|Mersch~ME|Redange~RD|Remich~RM|Vianden~VD|Wiltz~WI"], ["Macao", "MO", "Macao"], ["Macedonia, Republic of", "MK", "Aračinovo~02|Berovo~03|Bitola~04|Bogdanci~05|Bogovinje~06|Bosilovo~07|Brvenica~08|Centar Župa~78|Čaška~08|Češinovo-Obleševo~81|Čučer Sandevo~82|Debar~21|Debarca~22|Delčevo~23|Demir Hisar~25|Demir Kapija~24|Doran~26|Dolneni~27|Gevgelija~18|Gostivar~19|Gradsko~20|Ilinden~34|Jegunovce~35|Karbinci~37|Kavadarci~36|Kičevo~40|Kočani~42|Konče~41|Kratovo~43|Kriva Palanka~44|Krivogaštani~45|Kruševo~46|Kumanovo~47|Lipkovo~48|Lozovo~49|Makedonska Kamenica~51|Makedonski Brod~52|Mavrovo i Rostuša~50|Mogila~53|Negotino~54|Novaci~55|Novo Selo~56|Ohrid~58|Pehčevo~60|Petrovec~59|Plasnica~61|Prilep~62|Probištip~63|Radoviš~|Rankovce~65|Resen~66|Rosoman~67|Skopje~85|Sopište~70|Staro Nagoričane~71|Struga~72|Strumica~73|Studeničani~74|Sveti Nikole~69|Štip~83|Tearce~75|Tetovo~76|Valandovo~10|Vasilevo~11|Veles~13|Vevčani~12|Vinica~14|Vrapčište~16|Zelenikovo~32|Zrnovci~33|Želino~30"], ["Madagascar", "MG", "Antananarivo~T|Antsiranana~D|Fianarantsoa~F|Mahajanga~M|Toamasina~A|Toliara~U"], ["Malawi", "MW", "Balaka~BA|Blantyre~BL|Chikwawa~CK|Chiradzulu~CR|Chitipa~CT|Dedza~DE|Dowa~DO|Karonga~KR|Kasungu~KS|Likoma~LK|Lilongwe~LI|Machinga~MH|Mangochi~MG|Mchinji~MC|Mulanje~MU|Mwanza~MW|Mzimba~MZ|Nkhata Bay~NE|Nkhotakota~NB|Nsanje~NS|Ntcheu~NU|Ntchisi~NI|Phalombe~PH|Rumphi~RU|Salima~SA|Thyolo~TH|Zomba~ZO"], ["Malaysia", "MY", "Johor~01|Kedah~02|Kelantan~03|Melaka~04|Negeri Sembilan~05|Pahang~06|Perak~08|Perlis~09|Pulau Pinang~07|Sabah~12|Sarawak~13|Selangor~10|Terengganu~11|Wilayah Persekutuan (Kuala Lumpur)~14|Wilayah Persekutuan (Labuan)~15|Wilayah Persekutuan (Putrajaya)~16"], ["Maldives", "MV", "Alifu Alifu~02|Alifu Dhaalu~00|Baa~20|Dhaalu~17|Faafu~14|Gaafu Alifu~27|Gaafu Dhaalu~28|Gnaviyani~29|Haa Alifu~07|Haa Dhaalu~23|Kaafu~29|Laamu~05|Lhaviyani~03|Malé~MLE|Meemu~12|Noonu~25|Raa~13|Seenu~01|Shaviyani~24|Thaa~08|Vaavu~04"], ["Mali", "ML", "Bamako~BKO|Gao~7|Kayes~1|Kidal~8|Koulikoro~2|Mopti~5|Segou~4|Sikasso~3|Tombouctou~6"], ["Malta", "MT", "Attard~01|Balzan~02|Birgu~03|Birkirkara~04|Birżebbuġa~05|Bormla~06|Dingli~07|Fgura~08|Floriana~09|Fontana~10|Guda~11|Gżira~12|Għajnsielem~13|Għarb~14|Għargħur~15|Għasri~16|Għaxaq~17|Ħamrun~18|Iklin~19|Isla~20|Kalkara~21|Kerċem~22|Kirkop~23|Lija~24|Luqa~25|Marsa~26|Marsaskala~27|Marsaxlokk~28|Mdina~29|Mellieħa~30|Mġarr~31|Mosta~32|Mqabba~33|Msida~34|Mtarfa~35|Munxar~36|Nadur~37|Naxxar~38|Paola~39|Pembroke~40|Pietà~41|Qala~42|Qormi~43|Qrendi~44|Rabat Għawdex~45|Rabat Malta~46|Safi~47|San Ġiljan~48|San Ġwann~49|San Lawrenz~50|San Pawl il-Baħar~51|Sannat~52|Santa Luċija~53|Santa Venera~54|Siġġiewi~55|Sliema~56|Swieqi~57|Tai Xbiex~58|Tarzien~59|Valletta~60|Xagħra~61|Xewkija~62|Xgħajra~63|Żabbar~64|Żebbuġ Għawde~65|Żebbuġ Malta~66|Żejtun~67|Żurrieq~68"], ["Marshall Islands", "MH", "Ailinglaplap~ALL|Ailuk~ALK|Arno~ARN|Aur~AUR|Bikini and Kili~KIL|Ebon~EBO|Jabat~JAB|Jaluit~JAL|Kwajalein~KWA|Lae~LAE|Lib~LIB|Likiep~LIK|Majuro~MAJ|Maloelap~MAL|Mejit~MEJ|Namdrik~NMK|Namu~NMU|Rongelap~RON|Ujae~UJA|Utrik~UTI|Wotho~WTH|Wotje~WTJ"], ["Martinique", "MQ", "Martinique"], ["Mauritania", "MR", "Adrar~07|Assaba~03|Brakna~05|Dakhlet Nouadhibou~08|Gorgol~04|Guidimaka~10|Hodh Ech Chargui~01|Hodh El Gharbi~02|Inchiri~12|Nouakchott Nord~14|Nouakchott Ouest~13|Nouakchott Sud~15|Tagant~09|Tiris Zemmour~11|Trarza~06"], ["Mauritius", "MU", "Agalega Islands~AG|Beau Bassin-Rose Hill~BR|Black River~BL|Cargados Carajos Shoals~CC|Curepipe~CU|Flacq~FL|Grand Port~GP|Moka~MO|Pamplemousses~PA|Plaines Wilhems~PW|Port Louis (City)~PU|Port Louis~PL|Riviere du Rempart~RR|Rodrigues Island~RO|Savanne~SA|Vacoas-Phoenix~CP"], ["Mayotte", "YT", "Dzaoudzi~01|Pamandzi~02|Mamoudzou~03|Dembeni~04|Bandrélé~05|Kani-Kéli~06|Bouéni~07|Chirongui~08|Sada~09|Ouangani~10|Chiconi~11|Tsingoni~12|M'Tsangamouji~13|Acoua~14|Mtsamboro~15|Bandraboua~16|Koungou~17"], ["Mexico", "MX", "Aguascalientes~AGU|Baja California~BCN|Baja California Sur~BCS|Campeche~CAM|Ciudad de México~DIF|Chiapas~CHP|Chihuahua~CHH|Coahuila de Zaragoza~COA|Colima~COL|Durango~DUR|Estado de México~MEX|Guanajuato~GUA|Guerrero~GRO|Hidalgo~HID|Jalisco~JAL|Michoacán de Ocampo~MIC|Morelos~MOR|Nayarit~NAY|Nuevo León~NLE|Oaxaca~OAX|Puebla~PUE|Querétaro de Arteaga~QUE|Quintana Roo~ROO|San Luis Potosí~SLP|Sinaloa~SIN|Sonora~SON|Tabasco~TAB|Tamaulipas~TAM|Tlaxcala~TLA|Veracruz~VER|Yucatán~YUC|Zacatecas~ZAC"], ["Micronesia, Federated States of", "FM", "Chuuk (Truk)~TRK|Kosrae~KSA|Pohnpei~PNI|Yap~YAP"], ["Moldova", "MD", "Aenii Noi~AN|Basarabeasca~BS|Bălți~BA|Bender~BD|Briceni~BR|Cahul~CA|Cantemir~CT|Călărași~CL|Căușeni~CS|Chișinău~CU|Cimișlia~CM|Criuleni~CR|Dondușeni~DO|Drochia~DR|Dubăsari~DU|Edineț~ED|Fălești~FA|Florești~FL|Găgăuzia~GA|Glodeni~GL|Hîncești~HI|Ialoveni~IA|Leova~LE|Nisporeni~NI|Ocnița~OC|Orhei~OR|Rezina~RE|Rîșcani~RI|Sîngerei~SI|Soroca~SO|Stînga Nistrului~SN|Strășeni~ST|Șoldănești~SD|Ștefan Vodă~SV|Taraclia~TA|Telenești~TE|Ungheni~UN"], ["Monaco", "MC", "Colle~CL|Condamine~CO|Fontvieille~FO|Gare~GA|Jardin Exotique~JE|Larvotto~LA|Malbousquet~MA|Monaco-Ville~MO|Moneghetti~MG|Monte-Carlo~MC|Moulins~MU|Port-Hercule~PH|Saint-Roman~SR|Sainte-Dévote~SD|Source~SO|Spélugues~SP|Vallon de la Rousse~VR"], ["Mongolia", "MN", "Arhangay~073|Bayan-Olgiy~071|Bayanhongor~069|Bulgan~067|Darhan~037|Dornod~061|Dornogovi~063|Dundgovi~059|Dzavhan~065|Govi-Altay~065|Govi-Sumber~064|Hovd~043|Hovsgol~041|Omnogovi~053|Ovorhangay~055|Selenge~049|Suhbaatar~051|Tov~047|Ulaanbaatar~1|Uvs~046"], ["Montenegro", "ME", "Andrijevica~01|Bar~02|Berane~03|Bijelo Polje~04|Budva~05|Cetinje~06|Danilovgrad~07|Gusinje~22|Herceg Novi~08|Kolašin~09|Kotor~10|Mojkovac~11|Nikšić~12|Petnica~23|Plav~13|Plužine~14|Pljevlja~15|Podgorica~16|Rožaje~17|Šavnik~18|Tivat~19|Ulcinj~20|Žabljak~21"], ["Montserrat", "MS", "Saint Anthony|Saint Georges|Saint Peter's"], ["Morocco", "MA", "Chaouia-Ouardigha~09|Doukhala-Abda~10|Fès-Boulemane~05|Gharb-Chrarda-Beni Hssen~02|Grand Casablanca~08|Guelmim-Es Semara~14|Laâyoune-Boujdour-Sakia el Hamra~15|Marrakech-Tensift-Al Haouz~11|Meknès-Tafilalet~06|Oriental~04|Oued ed Dahab-Lagouira~16|Souss-Massa-Drâa~13|Tadla-Azilal~12|Tanger-Tétouan~01|Taza-Al Hoceima-Taounate~03"], ["Mozambique", "MZ", "Cabo Delgado~P|Gaza~G|Inhambane~I|Manica~B|Maputo~L|Maputo (City)~MPM|Nampula~N|Niassa~A|Sofala~S|Tete~T|Zambezia~Q"], ["Myanmar", "MM", "Ayeyarwady~07|Bago~02|Chin~14|Kachin~11|Kayah~12|Kayin~13|Magway~03|Mandalay~04|Mon~15|Nay Pyi Taw~18|Rakhine~16|Sagaing~01|Shan~17|Tanintharyi~05|Yangon~06"], ["Namibia", "NA", "Erongo~ER|Hardap~HA|Kavango East~KE|Kavango West~KW|Karas~KA|Khomas~KH|Kunene~KU|Ohangwena~OW|Omaheke~OH|Omusati~OS|Oshana~ON|Oshikoto~OT|Otjozondjupa~OD|Zambezi~CA"], ["Nauru", "NR", "Aiwo~01|Anabar~02|Anetan~03|Anibare~04|Baiti~05|Boe~06|Buada~07|Denigomodu~08|Ewa~09|Ijuw~10|Meneng~11|Nibok~12|Uaboe~13|Yaren~14"], ["Nepal", "NP", "Bagmati~BA|Bheri~BH|Dhawalagiri~DH|Gandaki~GA|Janakpur~JA|Karnali~KA|Kosi~KO|Lumbini~LU|Mahakali~MA|Mechi~ME|Narayani~NA|Rapti~RA|Sagarmatha~SA|Seti~SE"], ["Netherlands", "NL", "Drenthe~DR|Flevoland~FL|Friesland~FR|Gelderland~GE|Groningen~GR|Limburg~LI|Noord-Brabant~NB|Noord-Holland~NH|Overijssel~OV|Utrecht~UT|Zeeland~ZE|Zuid-Holland~ZH"], ["New Caledonia", "NC", "Iles Loyaute|Nord|Sud"], ["New Zealand", "NZ", "Auckland~AUK|Bay of Plenty~BOP|Canterbury~CAN|Gisborne~GIS|Hawke's Bay~HKB|Marlborough~MBH|Manawatu-Wanganui~MWT|Northland~NTL|Nelson~NSN|Otago~OTA|Southland~STL|Taranaki~TKI|Tasman~TAS|Waikato~WKO|Wellington~WGN|West Coast~WTC|Chatham Islands Territory~CIT"], ["Nicaragua", "NI", "Boaco~BO|Carazo~CA|Chinandega~CI|Chontales~CO|Estelí~ES|Granada~GR|Jinotega~JI|León~LE|Madriz~MD|Managua~MN|Masaya~MS|Matagalpa~MT|Nueva Segovia~NS|Río San Juan~SJ|Rivas~RI|Atlántico Norte~AN|Atlántico Sur~AS"], ["Niger", "NE", "Agadez~1|Diffa~2|Dosso~3|Maradi~4|Niamey~8|Tahoua~5|Tillabéri~6|Zinder~7"], ["Nigeria", "NG", "Abia~AB|Abuja Federal Capital Territory~FC|Adamawa~AD|Akwa Ibom~AK|Anambra~AN|Bauchi~BA|Bayelsa~BY|Benue~BE|Borno~BO|Cross River~CR|Delta~DE|Ebonyi~EB|Edo~ED|Ekiti~EK|Enugu~EN|Gombe~GO|Imo~IM|Jigawa~JI|Kaduna~KD|Kano~KN|Katsina~KT|Kebbi~KE|Kogi~KO|Kwara~KW|Lagos~LA|Nassarawa~NA|Niger~NI|Ogun~OG|Ondo~ON|Osun~OS|Oyo~OY|Plateau~PL|Rivers~RI|Sokoto~SO|Taraba~TA|Yobe~YO|Zamfara~ZA"], ["Niue", "NU", "Niue"], ["Norfolk Island", "NF", "Norfolk Island"], ["Northern Mariana Islands", "MP", "Northern Islands|Rota|Saipan|Tinian"], ["Norway", "NO", "Akershus~02|Aust-Agder~09|Buskerud~06|Finnmark~20|Hedmark~04|Hordaland~12|Møre og Romsdal~15|Nordland~18|Nord-Trøndelag~17|Oppland~05|Oslo~03|Rogaland~11|Sogn og Fjordane~14|Sør-Trøndelag~16|Telemark~08|Troms~19|Vest-Agder~10|Vestfold~07|Østfold~01|Jan Mayen~22|Svalbard~21"], ["Oman", "OM", "Ad Dakhiliyah~DA|Al Buraymi~BU|Al Wusta~WU|Az Zahirah~ZA|Janub al Batinah~BS|Janub ash Sharqiyah~SS|Masqat~MA|Musandam~MU|Shamal al Batinah~BJ|Shamal ash Sharqiyah~SJ|Zufar~ZU"], ["Pakistan", "PK", "Āzād Kashmīr~JK|Balōchistān~BA|Gilgit-Baltistān~GB|Islāmābād~IS|Khaībar Pakhtūnkhwās~KP|Punjāb~PB|Sindh~SD|Federally Administered Tribal Areas~TA"], ["Palau", "PW", "Aimeliik~002|Airai~004|Angaur~010|Hatobohei~050|Kayangel~100|Koror~150|Melekeok~212|Ngaraard~214|Ngarchelong~218|Ngardmau~222|Ngatpang~224|Ngchesar~226|Ngeremlengui~227|Ngiwal~228|Peleliu~350|Sonsoral~350"], ["Palestine, State of", "PS", "Ak Khalīl~HBN|Al Quds~JEM|Arīḩā wal Aghwār~JRH|Bayt Laḩm~BTH|Dayr al Balaḩ~DEB|Ghazzah~GZA|Janīn~JEN|Khān Yūnis~KYS|Nāblus~NBS|Qalqīyah~QQA|Rafaḩ~RFH|Rām Allāh wal Bīrah~RBH|Salfīt~SLT|Shamāl Ghazzah~NGZ|Ţūbās~TBS|Ţūlkarm~TKM"], ["Panama", "PA", "Bocas del Toro~1|Chiriquí~4|Coclé~2|Colón~3|Darién~5|Emberá~EM|Herrera~6|Kuna Yala~KY|Los Santos~7|Ngäbe-Buglé~NB|Panamá~8|Panamá Oeste~10|Veraguas~9"], ["Papua New Guinea", "PG", "Bougainville~NSB|Central~CPM|Chimbu~CPK|East New Britain~EBR|East Sepik~ESW|Eastern Highlands~EHG|Enga~EPW|Gulf~GPK|Hela~HLA|Jiwaka~JWK|Madang~MOM|Manus~MRL|Milne Bay~MBA|Morobe~MPL|Port Moresby~NCD|New Ireland~NIK|Northern~NPP|Southern Highlands~SHM|West New Britain~WBK|West Sepik~SAN|Western~WPD|Western Highlands~WHM"], ["Paraguay", "PY", "Alto Paraguay~16|Alto Parana~10|Amambay~13|Asuncion~ASU|Caaguazu~5|Caazapa~6|Canindeyu~14|Central~11|Concepcion~1|Cordillera~3|Guaira~4|Itapua~7|Misiones~8|Neembucu~12|Paraguari~9|Presidente Hayes~15|San Pedro~2"], ["Peru", "PE", "Amazonas~AMA|Ancash~ANC|Apurimac~APU|Arequipa~ARE|Ayacucho~AYA|Cajamarca~CAJ|Callao~CAL|Cusco~CUS|Huancavelica~HUV|Huanuco~HUC|Ica~ICA|Junin~JUN|La Libertad~LAL|Lambayeque~LAM|Lima~LIM|Loreto~LOR|Madre de Dios~MDD|Moquegua~MOQ|Municipalidad Metropolitana de Lima~LMA|Pasco~PAS|Piura~PIU|Puno~PUN|San Martin~SAM|Tacna~TAC|Tumbes~TUM|Ucayali~UCA"], ["Philippines", "PH", "Abra~ABR|Agusan del Norte~AGN|Agusan del Sur~AGS|Aklan~AKL|Albay~ALB|Antique~ANT|Apayao~APA|Aurora~AUR|Basilan~BAS|Bataan~BAN|Batanes~BTN|Batangas~BTG|Benguet~BEN|Biliran~BIL|Bohol~BOH|Bukidnon~BUK|Bulacan~BUL|Cagayan~CAG|Camarines Norte~CAN|Camarines Sur~CAS|Camiguin~CAM|Capiz~CAP|Catanduanes~CAT|Cavite~CAV|Cebu~CEB|Compostela~COM|Cotabato~NCO|Davao del Norte~DAV|Davao del Sur~DAS|Davao Occidental~DVO|Davao Oriental~DAO|Dinagat Islands~DIN|Eastern Samar~EAS|Guimaras~GUI|Ifugao~IFU|Ilocos Norte~ILN|Ilocos Sur~ILS|Iloilo~ILI|Isabela~ISA|Kalinga~KAL|La Union~LUN|Laguna~LAG|Lanao del Norte~LAN|Lanao del Sur~LAS|Leyte~LEY|Maguindanao~MAG|Masbate~MAS|Metro Manila~00|Mindoro Occidental~MDC|Mindoro Oriental~MDR|Misamis Occidental~MSC|Misamis Oriental~MSR|Mountain Province~MOU|Negros Occidental~NEC|Negros Oriental~NER|Northern Samar~NSA|Nueva Ecija~NUE|Nueva Vizcaya~NUV|Palawan~PLW|Pampanga~PAM|Pangasinan~PAN|Quezon~QUE|Quirino~QUI|Rizal~RIZ|Romblon~ROM|Samar~WSA|Sarangani~SAR|Siquijor~SIG|Sorsogon~SOR|Southern Leyte~SLE|Sultan Kudarat~AUK|Sulu~SLU|Surigao del Norte~SUN|Surigao del Sur~SUR|Tarlac~TAR|Tawi-Tawi~TAW|Zambales~ZMB|Zamboanga del Norte~ZAN|Zamboanga del Sur~ZAS|Zamboanga Sibugay~ZSI"], ["Pitcairn", "PN", "Pitcairn Islands"], ["Poland", "PL", "Dolnośląskie~DS|Kujawsko-pomorskie~KP|Łódzkie~LD|Lubelskie~LU|Lubuskie~LB|Malopolskie~MA|Mazowieckie~MZ|Opolskie~OP|Podkarpackie~PK|Podlaskie~PD|Pomorskie~PM|Śląskie~SL|Świętokrzyskie~SK|Warmińsko-mazurskie~WN|Wielkopolskie~WP|Zachodniopomorskie~ZP"], ["Portugal", "PT", "Acores~20|Aveiro~01|Beja~02|Braga~03|Braganca~04|Castelo Branco~05|Coimbra~06|Evora~07|Faro~08|Guarda~09|Leiria~10|Lisboa~11|Madeira~30|Portalegre~12|Porto~13|Santarem~14|Setubal~15|Viana do Castelo~16|Vila Real~17|Viseu~18"], ["Puerto Rico", "PR", "Adjuntas|Aguada|Aguadilla|Aguas Buenas|Aibonito|Anasco|Arecibo|Arroyo|Barceloneta|Barranquitas|Bayamon|Cabo Rojo|Caguas|Camuy|Canovanas|Carolina|Cat|Ceiba|Ciales|Cidra|Coamo|Comerio|Corozal|Culebra|Dorado|Fajardo|Florida|Guanica|Guayama|Guayanilla|Guaynabo|Gurabo|Hatillo|Hormigueros|Humacao|Isabe|Juana Diaz|Juncos|Lajas|Lares|Las Marias|Las oiza|Luquillo|Manati|Maricao|Maunabo|Mayaguez|Moca|Morovis|Naguabo|Naranjito|Orocovis|Patillas|Penuelas|Ponce|Quebradillas|Rincon|Rio Grande|Sabana linas|San German|San Juan|San Lorenzo|San Sebastian|Santa Isabel|Toa Alta|Toa Baja|Trujillo Alto|Utuado|Vega Alta|Vega ues|Villalba|Yabucoa|Yauco"], ["Qatar", "QA", "Ad Dawḩah~DA|Al Khawr wa adh Dhakhīrah~KH|Al Wakrah~WA|Ar Rayyān~RA|Ash Shamāl~MS|Az̧ Za̧`āyin~ZA|Umm Şalāl~US"], ["Réunion", "RE", "Réunion"], ["Romania", "RO", "Alba~AB|Arad~AR|Arges~AG|Bacau~BC|Bihor~BH|Bistrita-Nasaud~BN|Botosani~BT|Braila~BR|Brasov~BV|Bucuresti~B|Buzau~BZ|Calarasi~CL|Caras-Severin~CS|Cluj~CJ|Constanta~CT|Covasna~CV|Dambovita~DB|Dolj~DJ|Galati~GL|Giurgiu~GR|Gorj~GJ|Harghita~HR|Hunedoara~HD|Ialomita~IL|Iasi~IS|Maramures~MM|Mehedinti~MH|Mures~MS|Neamt~NT|Olt~OT|Prahova~PH|Salaj~SJ|Satu Mare~SM|Sibiu~SB|Suceava~SV|Teleorman~TR|Timis~TM|Tulcea~TL|Valcea~VL|Vaslui~VS|Vrancea~VN"], ["Russian Federation", "RU", "Republic of Adygea~AD|Republic of Altai (Gorno-Altaysk)~AL|Altai Krai~ALT|Amur Oblast~AMU|Arkhangelsk Oblast~ARK|Astrakhan Oblast~AST|Republic of Bashkortostan~BA|Belgorod Oblast~BEL|Bryansk Oblast~BRY|Republic of Buryatia~BU|Chechen Republic~CE|Chelyabinsk Oblast~CHE|Chukotka Autonomous Okrug~CHU|Chuvash Republic~CU|Republic of Dagestan~DA|Republic of Ingushetia~IN|Irkutsk Oblast~IRK|Ivanovo Oblast~IVA|Jewish Autonomous Oblast~JEW|Kabardino-Balkar Republic~KB|Kaliningrad Oblast~KLN|Republic of Kalmykia~KL|Kaluga Oblast~KLU|Kamchatka Krai~KAM|Karachay-Cherkess Republic~KC|Republic of Karelia~KR|Khabarovsk Krai~KHA|Republic of Khakassia~KK|Khanty-Mansi Autonomous Okrug - Yugra~KHM|Kemerovo Oblast~KEM|Kirov Oblast~KIR|Komi Republic~KO|Kostroma Oblast~KOS|Krasnodar Krai~KDA|Krasnoyarsk Krai~KYA|Kurgan Oblast~KGN|Kursk Oblast~KRS|Leningrad Oblast~LEN|Lipetsk Oblast~LIP|Magadan Oblast~MAG|Mari El Republic~ME|Republic of Mordovia~MO|Moscow Oblast~MOS|Moscow~MOW|Murmansk Oblast~MU|Nenets Autonomous Okrug~NEN|Nizhny Novgorod Oblast~NIZ|Novgorod Oblast~NGR|Novosibirsk Oblast~NVS|Omsk Oblast~OMS|Orenburg Oblast~ORE|Oryol Oblast~ORL|Penza Oblast~PNZ|Perm Krai~PER|Primorsky Krai~PRI|Pskov Oblast~PSK|Rostov Oblast~ROS|Ryazan Oblast~RYA|Saint Petersburg~SPE|Sakha (Yakutia) Republic~SA|Sakhalin Oblast~SAK|Samara Oblast~SAM|Saratov Oblast~SAR|Republic of North Ossetia-Alania~NOA|Smolensk Oblast~SMO|Stavropol Krai~STA|Sverdlovsk Oblast~SVE|Tambov Oblast~TAM|Republic of Tatarstan~TA|Tomsk Oblast~TOM|Tuva Republic~TU|Tula Oblast~TUL|Tver Oblast~TVE|Tyumen Oblast~TYU|Udmurt Republic~UD|Ulyanovsk Oblast~ULY|Vladimir Oblast~VLA|Volgograd Oblast~VGG|Vologda Oblast~VLG|Voronezh Oblast~VOR|Yamalo-Nenets Autonomous Okrug~YAN|Yaroslavl Oblast~YAR|Zabaykalsky Krai~ZAB"], ["Rwanda", "RW", "Kigali~01|Eastern~02|Northern~03|Western~04|Southern~05"], ["Saint Barthélemy", "BL", "Au Vent~02|Sous le Vent~01"], ["Saint Helena, Ascension and Tristan da Cunha", "SH", "Ascension~AC|Saint Helena~HL|Tristan da Cunha~TA"], ["Saint Kitts and Nevis", "KN", "Saint Kitts~K|Nevis~N"], ["Saint Lucia", "LC", "Anse-la-Raye~01|Canaries~12|Castries~02|Choiseul~03|Dennery~05|Gros Islet~06|Laborie~07|Micoud~08|Soufriere~10|Vieux Fort~11"], ["Saint Martin", "MF", "Saint Martin"], ["Saint Pierre and Miquelon", "PM", "Miquelon|Saint Pierre"], ["Saint Vincent and the Grenadines", "VC", "Charlotte~01|Grenadines~06|Saint Andrew~02|Saint David~03|Saint George~04|Saint Patrick~05"], ["Samoa", "WS", "A'ana~AA|Aiga-i-le-Tai~AL|Atua~AT|Fa'asaleleaga~FA|Gaga'emauga~GE|Gagaifomauga~GI|Palauli~PA|Satupa'itea~SA|Tuamasaga~TU|Va'a-o-Fonoti~VF|Vaisigano~VS"], ["San Marino", "SM", "Acquaviva~01|Borgo Maggiore~06|Chiesanuova~02|Domagnano~03|Faetano~04|Fiorentino~05|Montegiardino~08|San Marino~07|Serravalle~09"], ["Sao Tome and Principe", "ST", "Principe~P|Sao Tome~S"], ["Saudi Arabia", "SA", "'Asir~14|Al Bahah~11|Al Hudud ash Shamaliyah~08|Al Jawf~12|Al Madinah al Munawwarah~03|Al Qasim~05|Ar Riyad~01|Ash Sharqiyah~04|Ha'il~06|Jazan~09|Makkah al Mukarramah~02|Najran~10|Tabuk~07"], ["Senegal", "SN", "Dakar~DK|Diourbel~DB|Fatick~FK|Kaffrine~KA|Kaolack~KL|Kedougou~KE|Kolda~KD|Louga~LG|Matam~MT|Saint-Louis~SL|Sedhiou~SE|Tambacounda~TC|Thies~TH|Ziguinchor~ZG"], ["Serbia", "RS", "Beograd (Belgrade)~00|Borski~14|Braničevski~11|Jablanički~23|Južnobački~06|Južnobanatski~04|Kolubarski~09|Kosovski~25|Kosovsko-Mitrovački~28|Kosovsko-Pomoravski~29|Mačvanski~08|Moravički~17|Nišavski~20|Pčinjski~24|Pećki~26|Pirotski~22|Podunavski~10|Pomoravski~13|Prizrenski~27|Rasinski~19|Raški~18|Severnobački~01|Severnobanatski~03|Srednjebanatski~02|Sremski~07|Šumadijski~12|Toplički~21|Zaječarski~15|Zapadnobački~05|Zlatiborski~16"], ["Seychelles", "SC", "Anse aux Pins~01|Anse Boileau~02|Anse Etoile~03|Anse Royale~05|Anu Cap~04|Baie Lazare~06|Baie Sainte Anne~07|Beau Vallon~08|Bel Air~09|Bel Ombre~10|Cascade~11|Glacis~12|Grand'Anse Mahe~13|Grand'Anse Praslin~14|La Digue~15|La Riviere Anglaise~16|Les Mamelles~24|Mont Buxton~17|Mont Fleuri~18|Plaisance~19|Pointe La Rue~20|Port Glaud~21|Roche Caiman~25|Saint Louis~22|Takamaka~23"], ["Sierra Leone", "SL", "Eastern~E|Northern~N|Southern~S|Western~W"], ["Singapore", "SG", "Central Singapore~01|North East~02|North West~03|South East~04|South West~05"], ["Sint Maarten (Dutch part)", "SX", "Sint Maarten"], ["Slovakia", "SK", "Banskobystricky~BC|Bratislavsky~BL|Kosicky~KI|Nitriansky~NI|Presovsky~PV|Trenciansky~TC|Trnavsky~TA|Zilinsky~ZI"], ["Slovenia", "SI", "Ajdovscina~001|Apace~195|Beltinci~002|Benedikt~148|Bistrica ob Sotli~149|Bled~003|Bloke~150|Bohinj~004|Borovnica~005|Bovec~006|Braslovce~151|Brda~007|Brezice~009|Brezovica~008|Cankova~152|Celje~011|Cerklje na Gorenjskem~012|Cerknica~013|Cerkno~014|Cerkvenjak~153|Cirkulane~196|Crensovci~015|Crna na Koroskem~016|Crnomelj~017|Destrnik~018|Divaca~019|Dobje~154|Dobrepolje~020|Dobrna~155|Dobrova-Polhov Gradec~021|Dobrovnik~156|Dol pri Ljubljani~022|Dolenjske Toplice~157|Domzale~023|Dornava~024|Dravograd~025|Duplek~026|Gorenja Vas-Poljane~027|Gorisnica~028|Gorje~207|Gornja Radgona~029|Gornji Grad~030|Gornji Petrovci~031|Grad~158|Grosuplje~032|Hajdina~159|Hoce-Slivnica~160|Hodos~161|Horjul~162|Hrastnik~034|Hrpelje-Kozina~035|Idrija~036|Ig~037|Ilirska Bistrica~038|Ivancna Gorica~039|Izola~040s|Jesenice~041|Jursinci~042|Kamnik~043|Kanal~044|Kidricevo~045|Kobarid~046|Kobilje~047|Kocevje~048|Komen~049|Komenda~164|Koper~050|Kodanjevica na Krki~197|Kostel~165|Kozje~051|Kranj~052|Kranjska Gora~053|Krizevci~166|Krsko~054|Kungota~055|Kuzma~056|Lasko~057|Lenart~058|Lendava~059|Litija~068|Ljubljana~061|Ljubno~062|Ljutomer~063|Log-Dragomer~208|Logatec~064|Loska Dolina~065|Loski Potok~066|Lovrenc na Pohorju~167|Lukovica~068|Luce~067|Majsperk~069|Makole~198|Maribor~070|Markovci~168|Medvode~071|Menges~072|Metlika~073|Mezica~074|Miklavz na Dravskem Polju~169|Miren-Kostanjevica~075|Mirna~212|Mirna Pec~170|Mislinja~076|Mokronog-Trebelno~199|Moravce~077|Moravske Toplice~078|Mozirje~079|Murska Sobota~080|Naklo~082|Nazarje~083|Nova Gorica~084|Novo Mesto~085|Odranci~086|Ormoz~087|Osilnica~088|Pesnica~089|Piran~090|Pivka~091|Podcetrtek~092|Podlehnik~172|Podvelka~093|Poljcane~200|Postojna~094|Prebold~174|Preddvor~095|Prevalje~175|Ptuj~096|Race-Fram~098|Radece~099|Radenci~100|Radlje ob Dravi~101|Radovljica~102|Ravne na Koroskem~103|Razkrizje~176|Recica ob Savinji~209|Rence-Vogrsko~201|Ribnica~104|Ribnica na Poboriu~177|Rogaska Slatina~106|Rogasovci~105|Rogatec~107|Ruse~108|Salovci~033|Selnica ob Dravi~178|Semic~109|Sempeter-Vrtojba~183|Sencur~117|Sentilj~118|Sentjernej~119|Sentjur~120|Sentrupert~211|Sevnica~110|Sezana~111|Skocjan~121|Skofja Loka~122|Skofljica~123|Slovenj Gradec~112|Slovenska Bistrica~113|Slovenske Konjice~114|Smarje pri elsah~124|Smarjeske Toplice~206|Smartno ob Paki~125|Smartno pri Litiji~194|Sodrazica~179|Solcava~180|Sostanj~126|Sredisce ob Dravi~202|Starse~115|Store~127|Straza~203|Sveta Ana~181|Sveta Trojica v Slovenskih Goricah~204|Sveta Andraz v Slovenskih Goricah~182|Sveti Jurij~116|Sveti Jurij v Slovenskih Goricah~210|Sveti Tomaz~205|Tabor~184|Tisina~128|Tolmin~128|Trbovlje~129|Trebnje~130|Trnovska Vas~185|Trzin~186|Trzic~131|Turnisce~132|Velenje~133|Velika Polana~187|Velike Lasce~134|Verzej~188|Videm~135|Vipava~136|Vitanje~137|Vodice~138|Vojnik~139|Vransko~189|Vrhnika~140|Vuzenica~141|Zagorje ob Savi~142|Zavrc~143|Zrece~144|Zalec~190|Zelezniki~146|Zetale~191|Ziri~147|Zirovnica~192|Zuzemberk~193"], ["Solomon Islands", "SB", "Central~CE|Choiseul~CH|Guadalcanal~GU|Honiara~CT|Isabel~IS|Makira-Ulawa~MK|Malaita~ML|Rennell and Bellona~RB|Temotu~TE|Western~WE"], ["Somalia", "SO", "Awdal~AW|Bakool~BK|Banaadir~BN|Bari~BR|Bay~BY|Galguduud~GA|Gedo~GE|Hiiraan~HI|Jubbada Dhexe~JD|Jubbada Hoose~JH|Mudug~MU|Nugaal~NU|Sanaag~SA|Shabeellaha Dhexe~SD|Shabeellaha Hoose~SH|Sool~SO|Togdheer~TO|Woqooyi Galbeed~WO"], ["South Africa", "ZA", "Eastern Cape~EC|Free State~FS|Gauteng~GT|KwaZulu-Natal~NL|Limpopo~LP|Mpumalanga~MP|Northern Cape~NC|North West~NW|Western Cape~WC"], ["South Georgia and South Sandwich Islands", "GS", "Bird Island|Bristol Island|Clerke Rocks|Montagu Island|Saunders Island|South Georgia|Southern Thule|Traversay Islands"], ["South Sudan", "SS", "Central Equatoria~CE|Eastern Equatoria~EE|Jonglei~JG|Lakes~LK|Northern Bahr el Ghazal~BN|Unity~UY|Upper Nile~NU|Warrap~WR|Western Bahr el Ghazal~BW|Western Equatoria~EW"], ["Spain", "ES", "Albacete~CM|Alicante~VC|Almería~AN|Araba/Álava~VI|Asturias~O|Ávila~AV|Badajoz~BA|Barcelona~B|Bizkaia~BI|Burgos~BU|Cáceres~CC|Cádiz~CA|Cantabria~S|Castellón~CS|Cueta~CU|Ciudad Real~CR|Córdoba~CO|A Coruña~C|Cuenca~CU|Gipuzkoa~SS|Girona~GI|Granada~GR|Guadalajara~GU|Huelva~H|Huesca~HU|Illes Balears~PM|Jaén~J|León~LE|Lleida~L|Lugo~LU|Madrid~M|Málaga~MA|Melilla~ML|Murcia~MU|Navarre~NA|Ourense~OR|Palencia~P|Las Palmas~GC|Pontevedra~PO|La Rioja~LO|Salamanca~SA|Santa Cruz de Tenerife~TF|Segovia~SG|Sevilla~SE|Soria~SO|Tarragona~T|Teruel~TE|Toledo~TO|Valencia~V|Valladolid~VA|Zamora~ZA|Zaragoza~Z"], ["Sri Lanka", "LK", "Basnahira~1|Dakunu~3|Madhyama~2|Naegenahira~5|Sabaragamuwa~9|Uturu~4|Uturumaeda~7|Vayamba~6|Uva~8"], ["Sudan", "SD", "Al Bahr al Ahmar~RS|Al Jazirah~GZ|Al Khartum~KH|Al Qadarif~GD|An Nil al Abyad~NW|An Nil al Azraq~NB|Ash Shamaliyah~NO|Gharb Darfur~DW|Gharb Kurdufan~GK|Janub Darfur~DS|Janub Kurdufan~KS|Kassala~KA|Nahr an Nil~NR|Shamal Darfur~DN|Sharq Darfur~DE|Shiamal Kurdufan~KN|Sinnar~SI|Wasat Darfur Zalinjay~DC"], ["Suriname", "SR", "Brokopondo~BR|Commewijne~CM|Coronie~CR|Marowijne~MA|Nickerie~NI|Para~PR|Paramaribo~PM|Saramacca~SA|Sipaliwini~SI|Wanica~WA"], ["Swaziland", "SZ", "Hhohho~HH|Lubombo~LU|Manzini~MA|Shiselweni~SH"], ["Sweden", "SE", "Blekinge~K|Dalarnas~W|Gotlands~X|Gavleborgs~I|Hallands~N|Jamtlands~Z|Jonkopings~F|Kalmar~H|Kronobergs~G|Norrbottens~BD|Orebro~T|Ostergotlands~E|Skane~M|Sodermanlands~D|Stockholm~AB|Varmlands~S|Vasterbottens~AC|Vasternorrlands~Y|Vastmanlands~U|Vastra Gotalands~O"], ["Switzerland", "CH", "Aargau~AG|Appenzell Ausserrhoden~AR|Appenzell Innerhoden~AI|Basel-Landschaft~BL|Basel-Stadt~BS|Bern~BE|Fribourg~FR|Genève~GE|Glarus~GL|Graubünden~GR|Jura~JU|Luzern~LU|Neuchâtel~NE|Nidwalden~NW|Obwalden~OW|Sankt Gallen~SG|Schaffhausen~SH|Schwyz~SZ|Solothurn~SO|Thurgau~TG|Ticino~TI|Uri~UR|Valais~VS|Vaud~VD|Zug~ZG|Zürich~ZH"], ["Syrian Arab Republic", "SY", "Al Hasakah~HA|Al Ladhiqiyah~LA|Al Qunaytirah~QU|Ar Raqqah~RA|As Suwayda'~SU|Dar'a~DR|Dayr az Zawr~DY|Dimashq~DI|Halab~HL|Hamah~HM|Hims~HI|Idlib~ID|Rif Dimashq~RD|Tartus~TA"], ["Taiwan", "TW", "Chang-hua~CHA|Chia-i~CYQ|Hsin-chu~HSQ|Hua-lien~HUA|Kao-hsiung~KHH|Keelung~KEE|Kinmen~KIN|Lienchiang~LIE|Miao-li~MIA|Nan-t'ou~NAN|P'eng-hu~PEN|New Taipei~NWT|P'ing-chung~PIF|T'ai-chung~TXG|T'ai-nan~TNN|T'ai-pei~TPE|T'ai-tung~TTT|T'ao-yuan~TAO|Yi-lan~ILA|Yun-lin~YUN"], ["Tajikistan", "TJ", "Dushanbe~DU|Kŭhistoni Badakhshon~GB|Khatlon~KT|Sughd~SU"], ["Tanzania, United Republic of", "TZ", "Arusha~01|Coast~19|Dar es Salaam~02|Dodoma~03|Iringa~04|Kagera~05|Kigoma~08|Kilimanjaro~09|Lindi~12|Manyara~26|Mara~13|Mbeya~14|Morogoro~16|Mtwara~17|Mwanza~18|Pemba North~06|Pemba South~10|Rukwa~20|Ruvuma~21|Shinyanga~22|Singida~23|Tabora~24|Tanga~25|Zanzibar North~07|Zanzibar Central/South~11|Zanzibar Urban/West~15"], ["Thailand", "TH", "Amnat Charoen~37|Ang Thong~15|Bueng Kan~38|Buri Ram~31|Chachoengsao~24|Chai Nat~18|Chaiyaphum~36|Chanthaburi~22|Chiang Mai~50|Chiang Rai~57|Chon Buri~20|Chumphon~86|Kalasin~46|Kamphaeng Phet~62|Kanchanaburi~71|Khon Kaen~40|Krabi~81|Krung Thep Mahanakhon (Bangkok)~10|Lampang~52|Lamphun~51|Loei~42|Lop Buri~16|Mae Hong Son~58|Maha Sarakham~44|Mukdahan~49|Nakhon Nayok~26|Nakhon Phathom~73|Nakhon Phanom~48|Nakhon Ratchasima~30|Nakhon Sawan~60|Nakhon Si Thammarat~80|Nan~55|Narathiwat~96|Nong Bua Lam Phu~39|Nong Khai~43|Nonthaburi~12|Pathum Thani~13|Pattani~94|Phangnga~82|Phatthalung~93|Phayao~56|Phetchabun~76|Phetchaburi~76|Phichit~66|Phitsanulok~65|Phra Nakhon Si Ayutthaya~14|Phrae~54|Phuket~83|Prachin Buri~25|Prachuap Khiri Khan~77|Ranong~85|Ratchaburi~70|Rayong~21|Roi Et~45|Sa Kaeo~27|Sakon Nakhon~47|Samut Prakan~11|Samut Sakhon~74|Samut Songkhram~75|Saraburi~19|Satun~91|Sing Buri~17|Si Sa ket~33|Songkhla~90|Sukhothai~64|Suphan Buri~72|Surat Thani~84|Surin~32|Tak~63|Trang~92|Trat~23|Ubon Ratchathani~34|Udon Thani~41|Uthai Thani~61|Uttaradit~53|Yala~95|Yasothon~35"], ["Timor-Leste", "TL", "Aileu~AL|Ainaro~AN|Baucau~BA|Bobonaro~BO|Cova Lima~CO|Dili~DI|Ermera~ER|Lautem~LA|Liquica~LI|Manatuto~MT|Manufahi~MF|Oecussi~OE|Viqueque~VI"], ["Togo", "TG", "Centre~C|Kara~K|Maritime~M|Plateaux~P|Savannes~S"], ["Tokelau", "TK", "Atafu|Fakaofo|Nukunonu"], ["Tonga", "TO", "'Eua~01|Ha'apai~02|Niuas~03|Tongatapu~04|Vava'u~05"], ["Trinidad and Tobago", "TT", "Arima~ARI|Chaguanas~CHA|Couva-Tabaquite-Talparo~CTT|Diefo Martin~DMN|Mayaro-Rio Claro~MRC|Penal-Debe~PED|Point Fortin~PTF|Port-of-Spain~POS|Princes Town~PRT|San Fernando~SFO|San Juan-Laventille~SJL|Sangre Grande~SGE|Siparia~SIP|Tobago~TOB|Tunapuna-Piarco~TUP"], ["Tunisia", "TN", "Ariana~12|Beja~31|Ben Arous~13|Bizerte~23|Gabes~81|Gafsa~71|Jendouba~32|Kairouan~41|Kasserine~42|Kebili~73|Kef~33|Mahdia~53|Medenine~82|Monastir~52|Nabeul~21|Sfax~61|Sidi Bouzid~43|Siliana~34|Sousse~51|Tataouine~83|Tozeur~72|Tunis~11|Zaghouan~22"], ["Turkey", "TR", "Adana~01|Adiyaman~02|Afyonkarahisar~03|Agri~04|Aksaray~68|Amasya~05|Ankara~06|Antalya~07|Ardahan~75|Artvin~08|Aydin~09|Balikesir~10|Bartin~74|Batman~72|Bayburt~69|Bilecik~11|Bingol~12|Bitlis~13|Bolu~14|Burdur~15|Bursa~16|Canakkale~17|Cankiri~18|Corum~19|Denizli~20|Diyarbakir~21|Duzce~81|Edirne~22|Elazig~23|Erzincan~24|Erzurum~25|Eskisehir~26|Gaziantep~27|Giresun~28|Gumushane~29|Hakkari~30|Hatay~31|Igdir~76|Isparta~32|Istanbul~34|Izmir~35|Kahramanmaras~46|Karabuk~78|Karaman~70|Kars~36|Kastamonu~37|Kayseri~38|Kilis~79|Kirikkale~71|Kirklareli~39|Kirsehir~40|Kocaeli~41|Konya~42|Kutahya~43|Malatya~44|Manisa~45|Mardin~47|Mersin~33|Mugla~48|Mus~49|Nevsehir~50|Nigde~51|Ordu~52|Osmaniye~80|Rize~53|Sakarya~54|Samsun~55|Sanliurfa~63|Siirt~56|Sinop~57|Sirnak~73|Sivas~58|Tekirdag~59|Tokat~60|Trabzon~61|Tunceli~62|Usak~64|Van~65|Yalova~77|Yozgat~66|Zonguldak~67"], ["Turkmenistan", "TM", "Ahal~A|Asgabat~S|Balkan~B|Dashoguz~D|Lebap~L|Mary~M"], ["Turks and Caicos Islands", "TC", "Turks and Caicos Islands"], ["Tuvalu", "TV", "Funafuti~FUN|Nanumanga~NMG|Nanumea~NMA|Niutao~NIT|Nui~NUI|Nukufetau~NKF|Nukulaelae~NKL|Vaitupu~VAU"], ["Uganda", "UG", "Abim~317|Adjumani~301|Amolatar~314|Amuria~216|Amuru~319|Apac~302|Arua~303|Budaka~217|Bududa~223|Bugiri~201|Bukedea~224|Bukwa~218|Buliisa~419|Bundibugyo~401|Bushenyi~402|Busia~202|Butaleja~219|Dokolo~318|Gulu~304|Hoima~403|Ibanda~416|Iganga~203|Isingiro~417|Jinja~204|Kaabong~315|Kabale~404|Kabarole~405|Kaberamaido~213|Kalangala~101|Kaliro~220|Kampala~102|Kamuli~205|Kamwenge~413|Kanungu~414|Kapchorwa~206|Kasese~406|Katakwi~207|Kayunga~112|Kibaale~407|Kiboga~103|Kiruhura~418|Kisoro~408|Kitgum~305|Koboko~316|Kotido~306|Kumi~208|Kyenjojo~415|Lira~307|Luwero~104|Lyantonde~116|Manafwa~221|Maracha~320|Masaka~105|Masindi~409|Mayuge~214|Mbale~209|Mbarara~410|Mityana~114|Moroto~308|Moyo~309|Mpigi~106|Mubende~107|Mukono~108|Nakapiripirit~311|Nakaseke~115|Nakasongola~109|Namutumba~222|Nebbi~310|Ntungamo~411|Oyam~321|Pader~312|Pallisa~210|Rakai~110|Rukungiri~412|Sembabule~111|Sironko~215|Soroti~211|Tororo~212|Wakiso~113|Yumbe~313"], ["Ukraine", "UA", "Cherkasy~71|Chernihiv~74|Chernivtsi~77|Dnipropetrovsk~12|Donetsk~14|Ivano-Frankivsk~26|Kharkiv~63|Kherson~65|Khmelnytskyi~68|Kiev~32|Kirovohrad~35|Luhansk~09|Lviv~46|Mykolaiv~48|Odessa~51|Poltava~53|Rivne~56|Sumy~59|Ternopil~61|Vinnytsia~05|Volyn~07|Zakarpattia~21|Zaporizhia~23|Zhytomyr~18|Avtonomna Respublika Krym~43|Kyïv~30|Sevastopol~40"], ["United Arab Emirates", "AE", "Abu Dhabi~AZ|Ajman~AJ|Dubai~DU|Fujairah~FU|Ras al Khaimah~RK|Sharjah~SH|Umm Al Quwain~UQ"], ["United Kingdom", "GB", "Avon~AVN|Bedfordshire~BDF|Berkshire~BRK|Bristol, City of~COB|Buckinghamshire~BKM|Cambridgeshire~CAM|Cheshire~CHS|Cleveland~CLV|Cornwall~CON|Cumbria~CMA|Derbyshire~DBY|Devon~DEV|Dorset~DOR|Durham~DUR|East Sussex~SXE|Essex~ESS|Gloucestershire~GLS|Greater London~LND|Greater Manchester~GTM|Hampshire (County of Southampton)~HAM|Hereford and Worcester~HWR|Herefordshire~HEF|Hertfordshire~HRT|Isle of Wight~IOW|Kent~KEN|Lancashire~LAN|Leicestershire~LEI|Lincolnshire~LIN|London~LDN|Merseyside~MSY|Middlesex~MDX|Norfolk~NFK|Northamptonshire~NTH|Northumberland~NBL|North Humberside~NHM|North Yorkshire~NYK|Nottinghamshire~NTT|Oxfordshire~OXF|Rutland~RUT|Shropshire~SAL|Somerset~SOM|South Humberside~SHM|South Yorkshire~SYK|Staffordshire~STS|Suffolk~SFK|Surrey~SRY|Tyne and Wear~TWR|Warwickshire~WAR|West Midlands~WMD|West Sussex~SXW|West Yorkshire~WYK|Wiltshire~WIL|Worcestershire~WOR|Antrim~ANT|Armagh~ARM|Belfast, City of~BLF|Down~DOW|Fermanagh~FER|Londonderry~LDY|Derry, City of~DRY|Tyrone~TYR|Aberdeen, City of~AN|Aberdeenshire~ABD|Angus (Forfarshire)~ANS|Argyll~AGB|Ayrshire~ARG|Banffshire~BAN|Berwickshire~BEW|Bute~BUT|Caithness~CAI|Clackmannanshire~CLK|Cromartyshire~COC|Dumfriesshire~DFS|Dunbartonshire (Dumbarton)~DNB|Dundee, City of~DD|East Lothian (Haddingtonshire)~ELN|Edinburgh, City of~EB|Fife~FIF|Glasgow, City of~GLA|Inverness-shire~INV|Kincardineshire~KCD|Kinross-shire~KRS|Kirkcudbrightshire~KKD|Lanarkshire~LKS|Midlothian (County of Edinburgh)~MLN|Moray (Elginshire)~MOR|Nairnshire~NAI|Orkney~OKI|Peeblesshire~PEE|Perthshire~PER|Renfrewshire~RFW|Ross and Cromarty~ROC|Ross-shire~ROS|Roxburghshire~ROX|Selkirkshire~SEL|Shetland (Zetland)~SHI|Stirlingshire~STI|Sutherland~SUT|West Lothian (Linlithgowshire)~WLN|Wigtownshire~WIG|Clwyd~CWD|Dyfed~DFD|Gwent~GNT|Gwynedd~GWN|Mid Glamorgan~MGM|Powys~POW|South Glamorgan~SGM|West Glamorgan~WGM"], ["United States", "US", "Alabama~AL|Alaska~AK|American Samoa~AS|Arizona~AZ|Arkansas~AR|California~CA|Colorado~CO|Connecticut~CT|Delaware~DE|District of Columbia~DC|Micronesia~FM|Florida~FL|Georgia~GA|Guam~GU|Hawaii~HI|Idaho~ID|Illinois~IL|Indiana~IN|Iowa~IA|Kansas~KS|Kentucky~KY|Louisiana~LA|Maine~ME|Marshall Islands~MH|Maryland~MD|Massachusetts~MA|Michigan~MI|Minnesota~MN|Mississippi~MS|Missouri~MO|Montana~MT|Nebraska~NE|Nevada~NV|New Hampshire~NH|New Jersey~NJ|New Mexico~NM|New York~NY|North Carolina~NC|North Dakota~ND|Northern Mariana Islands~MP|Ohio~OH|Oklahoma~OK|Oregon~OR|Palau~PW|Pennsylvania~PA|Puerto Rico~PR|Rhode Island~RI|South Carolina~SC|South Dakota~SD|Tennessee~TN|Texas~TX|Utah~UT|Vermont~VT|Virgin Islands~VI|Virginia~VA|Washington~WA|West Virginia~WV|Wisconsin~WI|Wyoming~WY|Armed Forces Americas~AA|Armed Forces Europe, Canada, Africa and Middle East~AE|Armed Forces Pacific~AP"], ["United States Minor Outlying Islands", "UM", "Baker Island~81|Howland Island~84|Jarvis Island~86|Johnston Atoll~67|Kingman Reef~89|Midway Islands~71|Navassa Island~76|Palmyra Atoll~95|Wake Island~79|Bajo Nuevo Bank~BN|Serranilla Bank~SB"], ["Uruguay", "UY", "Artigas~AR|Canelones~CA|Cerro Largo~CL|Colonia~CO|Durazno~DU|Flores~FS|Florida~FD|Lavalleja~LA|Maldonado~MA|Montevideo~MO|Paysandú~PA|Río Negro~RN|Rivera~RV|Rocha~RO|Salto~SA|San José~SJ|Soriano~SO|Tacuarembó~TA|Treinta y Tres~TT"], ["Uzbekistan", "UZ", "Toshkent shahri~TK|Andijon~AN|Buxoro~BU|Farg‘ona~FA|Jizzax~JI|Namangan~NG|Navoiy~NW|Qashqadaryo (Qarshi)~QA|Samarqand~SA|Sirdaryo (Guliston)~SI|Surxondaryo (Termiz)~SU|Toshkent wiloyati~TO|Xorazm (Urganch)~XO|Qoraqalpog‘iston Respublikasi (Nukus)~QR"], ["Vanuatu", "VU", "Malampa~MAP|Pénama~PAM|Sanma~SAM|Shéfa~SEE|Taféa~TAE|Torba~TOB"], ["Venezuela, Bolivarian Republic of", "VE", "Dependencias Federales~W|Distrito Federal~A|Amazonas~Z|Anzoátegui~B|Apure~C|Aragua~D|Barinas~E|Bolívar~F|Carabobo~G|Cojedes~H|Delta Amacuro~Y|Falcón~I|Guárico~J|Lara~K|Mérida~L|Miranda~M|Monagas~N|Nueva Esparta~O|Portuguesa~P|Sucre~R|Táchira~S|Trujillo~T|Vargas~X|Yaracuy~U|Zulia~V"], ["Vietnam", "VN", "Đồng Nai~39|Đồng Tháp~45|Gia Lai~30|Hà Giang~03|Hà Nam~63|Hà Tây~15|Hà Tĩnh~23|Hải Dương~61|Hậu Giang~73|Hòa Bình~14|Hưng Yên~66|Khánh Hòa~34|Kiên Giang~47|Kon Tum~28|Lai Châu~01|Lâm Đồng~35|Lạng Sơn~09|Lào Cai~02|Long An~41|Nam Định~67|Nghệ An~22|Ninh Bình~18|Ninh Thuận~36|Phú Thọ~68|Phú Yên~32|Quảng Bình~24|Quảng Nam~27|Quảng Ngãi~29|Quảng Ninh~13|Quảng Trị~25|Sóc Trăng~52|Sơn La~05|Tây Ninh~37|Thái Bình~20|Thái Nguyên~69|Thanh Hóa~21|Thừa Thiên–Huế~26|Tiền Giang~46|Trà Vinh~51|Tuyên Quang~07|Vĩnh Long~49|Vĩnh Phúc~70|Yên Bái~06|Cần Thơ~CT|Đà Nẵng~DN|Hà Nội~HN|Hải Phòng~HP|Hồ Chí Minh (Sài Gòn)~SG"], ["Virgin Islands, British", "VG", "Anegada~ANG|Jost Van Dyke~JVD|Tortola~TTA|Virgin Gorda~VGD"], ["Virgin Islands, U.S.", "VI", "St. Thomas~STH|St. John~SJO|St. Croix~SCR"], ["Wallis and Futuna", "WF", "Alo~ALO|Sigave~SIG|Wallis~WAL"], ["Western Sahara", "EH", "Es Smara~ESM|Boujdour~BOD|Laâyoune~LAA|Aousserd~AOU|Oued ed Dahab~OUD"], ["Yemen", "YE", "Abyān~AB|'Adan~AD|Aḑ Ḑāli'~DA|Al Bayḑā'~BA|Al Ḩudaydah~HU|Al Jawf~JA|Al Mahrah~MR|Al Maḩwīt~MW|'Amrān~AM|Dhamār~DH|Ḩaḑramawt~HD|Ḩajjah~HJ|Ibb~IB|Laḩij~LA|Ma'rib~MA|Raymah~RA|Şā‘dah~SD|Şan‘ā'~SN|Shabwah~SH|Tā‘izz~TA"], ["Zambia", "ZM", "Central~02|Copperbelt~08|Eastern~03|Luapula~04|Lusaka~09|Northern~05|North-Western~06|Southern~07|Western~01"], ["Zimbabwe", "ZW", "Bulawayo~BU|Harare~HA|Manicaland~MA|Mashonaland Central~MC|Mashonaland East~ME|Mashonaland West~MW|Masvingo~MV|Matabeleland North~MN|Matabeleland South~MS|Midlands~MI"]], a = function () { $(".crs-country").each(n) }, n = function () { var a = this; if ("true" !== a.getAttribute("data-crs-loaded")) { a.length = 0; var n = $(a).attr("data-default-option"), i = n || "Select country", e = a.getAttribute("data-show-default-option"); m = null === e || "true" === e; var r = $(a).attr("data-default-value"), o = $(a).attr("data-value"), l = 0; m && (this.options[0] = new Option(i, "")), k({ whitelist: a.getAttribute("data-whitelist"), blacklist: a.getAttribute("data-blacklist"), preferred: a.getAttribute("data-preferred"), preferredDelim: a.getAttribute("data-preferred-delim") }); for (var t = 0; t < M.length; t++) { var s = "shortcode" == o || "2-char" === o ? M[t][1] : M[t][0]; M[t][4] && (s = ""), a.options[a.length] = new Option(M[t][0], s), null != r && r === s && (l = t, m && l++) } this.selectedIndex = l; var u = $(a).attr("data-region-id"); if (u) { var d = $("#" + u)[0]; if (d) if (B(d), $(this).on("change", function () { b(a, d) }), r && 0 < a.selectedIndex) { b(a, d); var h = $(d).attr("data-default-value"), S = "shortcode" === d.getAttribute("data-value"); if (null !== h) { var A = m ? a.selectedIndex - 1 : a.selectedIndex, g = M[A][3]; c(d, g, h, S) } } else !1 === m && b(a, d); else console.error("Region dropdown DOM node with ID " + u + " not found."); a.setAttribute("data-crs-loaded", "true") } else console.error("Missing data-region-id on country-region-selector country field.") } }, B = function (a) { var n = $(a).attr("data-blank-option"), i = n || "-", e = a.getAttribute("data-show-default-option"); h = null === e || "true" === e, a.length = 0, h && (a.options[0] = new Option(i, ""), a.selectedIndex = 0) }, k = function (a) { var n = l, i = [], e = 0; if (a.whitelist) { var r = a.whitelist.split(","); for (e = 0; e < l.length; e++)-1 !== r.indexOf(l[e][1]) && i.push(l[e]); n = i } else if (a.blacklist) { var o = a.blacklist.split(","); for (e = 0; e < l.length; e++)-1 === o.indexOf(l[e][1]) && i.push(l[e]); n = i } a.preferred && (n = s(n, a.preferred, a.preferredDelim)), M = n, t() }, t = function () { for (var a = 0; a < M.length; a++) { for (var n = { hasShortcodes: /~/.test(M[a][2]), regions: [] }, i = M[a][2].split("|"), e = 0; e < i.length; e++) { var r = i[e].split("~"); n.regions.push([r[0], r[1]]) } M[a][3] = n } }, c = function (a, n, i, e) { for (var r = 0; r < n.regions.length; r++) { if ((e && n.hasShortcodes && n.regions[r][1] ? n.regions[r][1] : n.regions[r][0]) === i) { a.selectedIndex = h ? r + 1 : r; break } } }, b = function (a, n) { var i = m ? a.selectedIndex - 1 : a.selectedIndex, e = $(n).attr("data-default-option"), r = n.getAttribute("data-value"), o = e || "Select region"; if ("" === a.value) B(n); else { n.length = 0, h && (n.options[0] = new Option(o, "")); var l = M[i][3], t = "shortcode" === r && l.hasShortcodes, s = t ? 1 : 0; l.regions.sort(function (a, n) { var i = a[s].toLowerCase(), e = n[s].toLowerCase(); return i < e ? -1 : e < i ? 1 : 0 }); for (var u = 0; u < l.regions.length; u++) { var d = t ? l.regions[u][1] : l.regions[u][0]; n.options[n.length] = new Option(l.regions[u][0], d) } n.selectedIndex = 0 } }, s = function (a, n, i) { var e = n.split(",").reverse(), r = {}, o = !1, l = a.filter(function (a) { return -1 === e.indexOf(a[1]) || (r[a[1]] = a, !(o = !0)) }); o && i && l.unshift([i, "", "", {}, !0]); for (var t = 0; t < e.length; t++) { var s = e[t]; l.unshift(r[s]) } return l }; return $(a), { init: a } });
},{}],7:[function(require,module,exports){
var $ = require('jquery')
window.$ = window.jQuery = $
require('./jquery.crs.min')
require('./jQuery-zoom')
require('./parsley.min')

window.popper = require('./popper')
window.tippy = require('./tippy')
window.Splide = require('./splide')
require('./splide-grid')
window.intlTelInput = require('./intlTelInput')
window.zenscroll = require('./zenscroll')
window.fancybox = require('./fancybox.min')

/** -- Globals */
/** Constants / Variables / Utils / Ajax */
const constants = require('./modules/constants')
const variables = require('./modules/variables')
const utils = require('./modules/utils')
const ajax = require('./modules/ajax')
Object.assign(window, constants, variables, utils, ajax)

/** -- Append Elements */
/* Page Tips */
window.PageTip = require('./modules/dynamic/pageTip')
/* Backdrop */
window.Backdrop = require('./modules/dynamic/backdrop')
/* Page Confetti */
window.PageConfetti = require('./modules/dynamic/page-confetti')
/* Ask Modal */
window.AskModal = require('./modules/dynamic/ask-modal')
/* Loader Root */
window.rootLoader = require('./modules/dynamic/root-loader')
/* Sign Up price alerts */
window.priceModal = require('./modules/dynamic/price-modal')

/** -- Page Elements */
// Login
require('./modules/login')

/** Header / Footer
 * @type Objects
 */
window.header = require('./modules/elements/header')
window.footer = require('./modules/elements/footer')

/** Page Elements
 * @type Object
 */
window.pageEls = require('./modules/elements/page-elements')
window.pageReviews = require('./modules/elements/page-reviews')
window.heroSplide = require('./modules/elements/hero-splide')
window.pageAlerts = require('./modules/elements/page-alerts')
window.sirvCards = require('./modules/elements/sirv')

/** Modals
 * Currency / Cart / Menu / Mail / Quiz / Sign / Menu
 * @type Obejcts
 */
window.currencyModal = require('./modules/modals/currency-modal')
window.cartModal = require('./modules/modals/cart-modal')
window.bookModal = require('./modules/modals/book-modal')
window.mailModal = require('./modules/modals/mail-modal')
window.quizModal = require('./modules/modals/quiz-modal')
window.salesModal = require('./modules/modals/sales-modal')
const noticeModal = require('./modules/modals/notice-modal')
const Menu = require('./modules/modals/menu')
const AddCartModal = require('./modules/dynamic/add-cart-modal')

/** PG Filters/Select/Modal
 * @type Objects
 */
window.pgSelect = require('./modules/elements/pg-select')
window.pgModal = require('./modules/elements/pg-modal')


/** -- Pages */
const
  /* Loan App : /financing */
  LoanApp = require('./modules/pages/loan-app'),
  /* Job Apply : /apply-job */
  JobApp = require('./modules/pages/job-app'),
  /* Sell Watch : /sell-my-watch */
  SellWatch = require('./modules/pages/sell-watch'),
  /* Loose Diamonds : /loose-diamonds */
  LooseDiamonds = require('./modules/pages/loose-diamonds'),
  /* Homepage : /index */
  Homepage = require('./modules/pages/homepage'),
  ResultsPage = require('./modules/pages/results'),
  ProductPage = require('./modules/pages/product'),
  /* My Bag : /cart */
  myBag = require('./modules/pages/my-bag'),
  /* Account Profile : /account */
  account = require('./modules/pages/account-page'),
  /* Locations : /locations */
  locationPage = require('./modules/pages/location-page'),
  /* Sell Pages : /sell */
  sellPage = require('./modules/pages/sell-page'),
  /* Pass Reset : /pass-reset */
  passReset = require('./modules/pages/pass-reset'),
  /* Blog : /blog */
  blogPage = require('./modules/pages/blog-page'),
  /* Form Page : /form */
  formPage = require('./modules/pages/form-page'),
  /* Tag Preview : /tag */
  tagPreview = require('./modules/pages/tag-preview')
const sirvCards = require('./modules/elements/sirv')


/** -- Initialize Page Objects */
const
  pageObjectsArr = [
    header,
    cartModal,
    currencyModal,
    pgModal,
    footer,
    pageEls,
    myBag,
    account,
    locationPage,
    pageAlerts,
    sirvCards,
    sellPage,
    bookModal,
    passReset,
    pageReviews,
    blogPage,
    heroSplide,
    mailModal,
    quizModal,
    salesModal,
    formPage,
    tagPreview
  ]
const initPageObjects = () => {
  for (const obj of pageObjectsArr) {
    try {
      if (typeof obj.init === "function") {
        obj.init()
      } else {
        console.log(obj, 'No init function')
      }
    } catch (err) {
      console.error(`Error initializing ${obj}:`, err)
    }
  }
}


/** -- Init Page Objects */
document.addEventListener("DOMContentLoaded", function () {
  initPageObjects()
  window.pageTip = new PageTip()

  // Loan App
  const loanCaseHolder = document.querySelector('[data-id="loan-apply"]')
  if (loanCaseHolder) {
    window.loanApp = new LoanApp(loanCaseHolder)
  }

  // Job Apply
  const jobCaseHolder = document.querySelector('[data-id="job-apply"]')
  if (jobCaseHolder) {
    window.jobApp = new JobApp(jobCaseHolder)
  }

  // Form Page
  const form = document.querySelector('form#sell_my_watch')
  if (form) {
    window.sellMyWatch = new SellWatch()
  }

  // Loose Diamonds
  const looseDiamondsMain = document.querySelector('.loose_diamonds')
  if (looseDiamondsMain) {
    window.loose = new LooseDiamonds()
  }

  // Menu
  const menuElem = document.querySelector('.menu')
  if (menuElem) {
    window.menu = new Menu('.menu')
  }

  // Homepage
  new Homepage()

  // Results
  const resultsMain = document.querySelector('.main_results')
  if (resultsMain) {
    new ResultsPage()
  }

  const productMain = document.querySelector('.main_product')
  if (productMain) {
    new ProductPage()
  }

  // Notice modal
  window.noticeModal = new noticeModal()

  // Add to cart Modal
  window.addCartModal = new AddCartModal()
})
},{"./fancybox.min":3,"./intlTelInput":4,"./jQuery-zoom":5,"./jquery.crs.min":6,"./modules/ajax":8,"./modules/constants":9,"./modules/dynamic/add-cart-modal":10,"./modules/dynamic/ask-modal":11,"./modules/dynamic/backdrop":12,"./modules/dynamic/page-confetti":13,"./modules/dynamic/pageTip":14,"./modules/dynamic/price-modal":15,"./modules/dynamic/root-loader":16,"./modules/elements/footer":18,"./modules/elements/header":19,"./modules/elements/hero-splide":20,"./modules/elements/page-alerts":21,"./modules/elements/page-elements":22,"./modules/elements/page-reviews":23,"./modules/elements/pg-modal":24,"./modules/elements/pg-select":25,"./modules/elements/sirv":26,"./modules/login":27,"./modules/modals/book-modal":28,"./modules/modals/cart-modal":30,"./modules/modals/currency-modal":31,"./modules/modals/mail-modal":32,"./modules/modals/menu":33,"./modules/modals/notice-modal":34,"./modules/modals/quiz-modal":35,"./modules/modals/sales-modal":36,"./modules/pages/account-page":37,"./modules/pages/blog-page":38,"./modules/pages/form-page":39,"./modules/pages/homepage":40,"./modules/pages/job-app":41,"./modules/pages/loan-app":42,"./modules/pages/location-page":43,"./modules/pages/loose-diamonds":44,"./modules/pages/my-bag":45,"./modules/pages/pass-reset":46,"./modules/pages/product":47,"./modules/pages/results":48,"./modules/pages/sell-page":49,"./modules/pages/sell-watch":50,"./modules/pages/tag-preview":51,"./modules/utils":52,"./modules/variables":53,"./parsley.min":54,"./popper":55,"./splide":57,"./splide-grid":56,"./tippy":58,"./zenscroll":59,"jquery":2}],8:[function(require,module,exports){
function applyRedeemCode() {
  const value = $('#redeem_input').val();
  if (value != '') {
    $.ajax({
      url: '/json/redeem-promo-code',
      type: 'POST',
      data: { code: value },
      success: function (data) {
        var r = $.parseJSON(data);
        if (!r.error) {
          $('.checkout-redeem').show();
        } else {
          showMessage('error', 'Error', r.msg);
        }
      }
    });
  }
}

module.exports = {
  applyRedeemCode
}
},{}],9:[function(require,module,exports){
const constants = {
  IS_VISIBLE: "is-visible",
  IS_ACTIVE: "is-active",
  BUTTON_LOADING: "button_loading",
  IS_HIDDEN: 'is-hidden',
  IS_EXPANDED: 'is-expanded',
  IS_MINIMIZED: 'is-minimized',
  IS_COPIED: 'is-copied',
  IS_ERROR: 'is-error',
  IS_EMPTY: 'is-empty',
  __TRUE: '--true',
  __FALSE: '--false',
  __FADE: '--fade',
  __HALF: '--half',
  __SELECTED: '--selected',
  __LOADED: '--loaded',
  __HIDDEN: '--hidden',
  __VISIBLE: '--visible',
  __VALID: '--valid',
  __INVALID: '--invalid',
  __PENDING: '--pending',
  __LOCKED: '--locked',
  __ACTIVE: '--active',
  __EXPANDED: '--expanded',
  paceOptions: {
    ajax: true,
    document: true,
    elements: {
      selectors: ['main']
    }
  },
};

module.exports = constants;
},{}],10:[function(require,module,exports){
class AddCartModal {
  constructor() {
    this.elem = null
    this.nameElem = null
    this.priceElem = null
    this.salePriceElem = null
    this.src = null
    this.categoryElem = null
    this.heading = 'Item added to cart.'
  }

  _setProduct() {
    const name = document.querySelector('#item_name')
    const price = document.querySelector('#current_base_price')
    const salePrice = document.querySelector('.old_price')
    const category = document.querySelector('.side-row__category')
    const src = (() => {

      const gallery = [...document.querySelectorAll('#gallery_desktop .product__gallery')].find((el) => {
        if (window.getComputedStyle(el).display !== 'none') {
          return el
        }
      })
      const img = gallery.querySelector('.product__main-gallery img')
      if (!img) throw new Error('No image found')

      return img.src
    })()

    if (!name || !price || !src) {
      throw new Error('Missing elements : name, price, src')
    }

    this.nameElem = name
    this.priceElem = price
    this.salePriceElem = salePrice ? salePrice : null
    this.src = src
    this.categoryElem = category ? category : null
  }

  _renderItemHTML() {
    const name = this.nameElem.textContent
    const price = this.priceElem.textContent
    const salePrice = this.salePriceElem ? `<span class="cart-item-price_sale">${this.salePriceElem.textContent}</span></span>` : ''
    const category = this.categoryElem ? `<div class="cart-item__category">${this.categoryElem.textContent}</div>` : ''
    const src = this.src

    return `
    <div class="cart-item">
      <div class="cart-item__media">
        <img src="${src}">
      </div>
      <div class="cart-item__details">
      ${category}
      <h3 class="cart-item-name">${name}</h3>
      <div class="cart-item__price-row">
        <span class="cart-item-price">${price}</span>
        ${salePrice}
      </div>
      </div>
    </div>
    `
  }

  _renderHTML() {
    return `
    <div class="add-cart-modal__container">
      <div class="add-cart-modal__header">
        <h3>${this.heading}</h3>
        <button onclick="window.addCartModal.destroy()">
          <svg width="100%" height="100%" viewbox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 3L21 21" stroke="currentColor" stroke-width="3"></path>
            <path d="M21 3L3 21" stroke="currentColor" stroke-width="3"></path>
          </svg>
        </button>
      </div>
      ${this._renderItemHTML()}
      <div class="add-cart-modal__footer">
        <a href="javascript:void(0)" onclick="event.preventDefault(); window.addCartModal.destroy()" class="--sub">Back To Shopping</a>
        <a href="/cart">Go To Checkout</a>
      </div>
    </div>
    `
  }

  _createElement() {
    this._setProduct()

    this.elem = createElem('div', {
      className: 'add-cart-modal',
      innerHTML: this._renderHTML()
    })
  }

  show() {
    if (document.querySelector('.main_product')) {
      this._createElement()

      if (!this.elem) throw new Error('No element created')

      lockScroll()
      document.querySelector('header').appendChild(this.elem)
      this.elem.style.display = 'block'

      requestAnimationFrame(() => {
        this.elem.classList.add(__VISIBLE)
      })

      window.addCartModalBackdrop = new Backdrop({
        opacity: 0.7,
        zIndex: 90,
        callback: () => {
          this.destroy()
        }
      })
    }
  }

  destroy() {
    if (this.elem) {

      unlockScroll()
      this.elem.classList.remove(__VISIBLE)

      const backdrop = window.addCartModalBackdrop
      if (backdrop) {
        backdrop.hide(true)
        delete window.addCartModalBackdrop
      }

      setTimeout(() => {
        this.elem.remove()
        this._clear()
      }, getTransitionTime(this.elem))
    }
  }

  _clear() {
    this.elem = null
    this.nameElem = null
    this.priceElem = null
    this.salePriceElem = null
    this.src = null
    this.categoryElem = null
  }
}

module.exports = AddCartModal
},{}],11:[function(require,module,exports){
class AskModal {
  constructor(settings = {}) {
    this.heading = settings.heading || 'Are You Sure You Want To Exit?'
    this.subheading = settings.subheading || 'You will lose all unsaved progress.'
    this.exitText = settings.exitText || 'Exit'
    this.keepText = settings.keepText || 'Keep'
    this.exitCallback = settings.exitCallback
    this.keepCallback = this.destroy
  }

  get renderHTML() {
    return `
      <div data-evt="closeAskModal"></div>
      <div>
        <h4>${this.heading}</h4>
        <p>${this.subheading}</p>
        <div>
          <button>${this.exitText}</button>
          <button>${this.keepText}</button>
        </div>
      </div>
    `
  }

  create() {
    const modal = createElem('div', {
      className: 'ask-modal',
      innerHTML: this.renderHTML
    })
    const buttons = [...modal.querySelectorAll('button')]
    const closeEvt = [...modal.querySelectorAll('[data-evt="closeAskModal"]')]
    buttons[0].onclick = () => { this.destroy(); this.exitCallback() }
    buttons[1].onclick = () => { this.keepCallback() }
    for (const evt of closeEvt) {
      evt.onclick = () => { this.destroy() }
    }
    return modal
  }

  destroy() {
    unlockScroll()
    const modal = document.querySelector('.ask-modal')
    if (modal) {
      modal.remove()
    }
  }

  show() {
    lockScroll()
    const elem = this.create()
    document.body.appendChild(elem)
  }
}

module.exports = AskModal
},{}],12:[function(require,module,exports){
class Backdrop {
  constructor(settings = {}) {
    this.el = createElem('div', {
      className: 'page-backdrop',
    })
    this.callback = settings.callback || null
    this.zIndex = settings.zIndex || undefined
    this.background = settings.background || undefined
    this.half = settings.half || false
    this.opacity = settings.opacity || 1
    this.show()
    this.el.addEventListener('click', (e) => {
      if (e.target === this.el) {
        this.hide()
      }
    })
  }

  show() {
    document.body.appendChild(this.el)
    if (this.zIndex) {
      this.el.style.zIndex = this.zIndex
    }
    if (this.half) {
      this.el.classList.add(__HALF)
    }
    this.el.style.display = 'block'
    setTimeout(() => {
      this.el.style.opacity = this.opacity
    }, 1);
  }

  hide(ignoreCallback = false) {
    this.el.style.opacity = '0'
    setTimeout(() => {
      this.el.style.display = 'none'
      this.el.remove()
    }, getTransitionTime(this.el));

    if (this.callback && !ignoreCallback) {
      this.callback()
    }
  }
}

module.exports = Backdrop
},{}],13:[function(require,module,exports){
class PageConfetti {
  constructor() {
    this.el = null
    this.containerEl = null
    this.confettiFrequency = 3
    this.confettiInterval = 50
    this.timeToDestroy = 8000
    this.confettiColors = ['#0095c6', '#1ab8ec', '#8cdffa', '#d8f3fc']
    this.confettiAnimations = ['slow', 'medium', 'fast']
  }

  createHolder() {
    this.el = createElem('div', {
      className: 'confetti-holder'
    })
    document.body.appendChild(this.el)
  }

  setup() {
    const containerEl = createElem('div', {
      className: 'confetti-container'
    })
    this.el.appendChild(containerEl)
    this.containerEl = containerEl
  }

  render() {
    this.confettiInterval = setInterval(() => {
      const confettiEl = document.createElement('div')
      const confettiSize = Math.floor(Math.random() * 3) + 7 + 'px'
      const confettiBackground = this.confettiColors[Math.floor(Math.random() * this.confettiColors.length)]
      const confettiLeft = Math.floor(Math.random() * this.el.offsetWidth) + 'px'
      const confettiAnimation = this.confettiAnimations[Math.floor(Math.random() * this.confettiAnimations.length)]

      confettiEl.classList.add('confetti', 'confetti--animation-' + confettiAnimation)
      confettiEl.style.left = confettiLeft
      confettiEl.style.width = confettiSize
      confettiEl.style.height = confettiSize
      confettiEl.style.backgroundColor = confettiBackground

      confettiEl.removeTimeout = setTimeout(function () {
        confettiEl.parentNode.removeChild(confettiEl)
      }, 3000)

      this.containerEl.appendChild(confettiEl)
    }, this.confettiInterval)
  }

  destroy() {
    const el = this.el
    if (el) {
      el.style.opacity = '0'
      setTimeout(() => {
        document.body.removeChild(el)
      }, getTransitionTime(el));
    }
  }

  push(infinity = false) {
    this.createHolder()
    this.setup()
    this.render()
    if (!infinity) {
      setTimeout(() => {
        this.destroy()
      }, this.timeToDestroy);
    }
  }
}

module.exports = PageConfetti
},{}],14:[function(require,module,exports){
(function (global){(function (){
/**
 * Page Tips
 */
(function(global) {
  function PageTip() {
    this.tipElem = null;
    this.currentTarget = null;
    this.scrollHandler = this.handleScroll.bind(this); // Привязываем контекст и сохраняем ссылку на функцию
    this.handleHover();
  }

  PageTip.prototype.handleHover = function() {
    document.querySelectorAll('[data-tip]').forEach(elem => {
      elem.addEventListener('mouseenter', e => {
        this.createTip(elem);
        this.tipElem.textContent = elem.dataset.tip;
        this.setTipPosition(elem);

        // Добавляем обработчик события scroll
        window.addEventListener('scroll', this.scrollHandler);
      });

      elem.addEventListener('mouseleave', e => {
        this.destroyTip();

        // Убираем обработчик события scroll
        window.removeEventListener('scroll', this.scrollHandler);
      });
    });
  };

  PageTip.prototype.createTip = function(target) {
    if (!this.tipElem) {
      this.tipElem = document.createElement('div');
      this.tipElem.classList.add('page-tip');
      this.tipElem.style.position = 'absolute'; // Устанавливаем позиционирование на absolute
      this.tipElem.style.opacity = '0'; // Начальная непрозрачность
      this.tipElem.style.transition = 'opacity 0.3s ease, transform 0.3s ease'; // Переходы для анимации
      document.body.append(this.tipElem);

      if (target) {
        const extraClass = target.dataset.tipClass;
        if (extraClass) {
          this.tipElem.classList.add(`--${extraClass}`);
        }
      }

      // Сохраняем текущий целевой элемент
      this.currentTarget = target;
    }
  };

  PageTip.prototype.setTipPosition = function(elem) {
    const rect = elem.getBoundingClientRect();
    const tipRect = this.tipElem.getBoundingClientRect();
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

    const elemHeight = elem.offsetHeight;
    const elemWidth = elem.offsetWidth;

    let topPosition = rect.top + scrollTop - tipRect.height - 4;
    let leftPosition = rect.left + scrollLeft + (elemWidth / 2) - (tipRect.width / 2);

    // Сбрасываем классы
    this.tipElem.classList.remove('--top', '--bottom', '--left', '--right');

    // Определяем, сверху или снизу отображать подсказку
    let isBelow = false;
    if (topPosition < scrollTop + 100) { // Учитываем позицию прокрутки
      topPosition = rect.top + scrollTop + elemHeight + 4;
      this.tipElem.classList.add('--bottom');
      isBelow = true;
    } else {
      this.tipElem.classList.add('--top');
    }

    if (leftPosition < 0) {
      leftPosition = rect.left + scrollLeft;
      this.tipElem.classList.add('--left');
    }

    this.tipElem.style.top = `${topPosition}px`;
    this.tipElem.style.left = `${leftPosition}px`;

    // Устанавливаем начальные стили для анимации
    if (isBelow) {
      this.tipElem.style.transform = 'translateY(8px)';
    } else {
      this.tipElem.style.transform = 'translateY(-8px)';
    }

    // Используем requestAnimationFrame для обеспечения правильного применения стилей
    requestAnimationFrame(() => {
      this.tipElem.style.opacity = '1';
      this.tipElem.style.transform = 'translateY(0px)';
    });
  };

  PageTip.prototype.handleScroll = function() {
    this.destroyTip();

    // Убираем обработчик события scroll
    window.removeEventListener('scroll', this.scrollHandler);
  };

  PageTip.prototype.destroyTip = function() {
    if (this.tipElem) {
      this.tipElem.remove();
      this.tipElem = null;
      this.currentTarget = null;
    }
  };

  // Экспортируем класс PageTip
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = PageTip;
  } else {
    global.PageTip = PageTip;
  }
})(typeof window !== "undefined" ? window : global);

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],15:[function(require,module,exports){
const Backdrop = require("./backdrop")

class PriceModal {
  constructor(card, id) {
    if (!card) {
      console.warn('Missing card')
      return
    }

    this.card = card
    this.id = id
    this.name = undefined
    this.imgSrc = undefined
    this.elem = undefined
    this.input = undefined
    this.closeArr = []

    this.setup()
    this.show()
  }

  signup() {
    this.reset()

    const email = this.input.value
    const reg = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/

    if (!reg.test(String(email).toLowerCase())) {
      this.error('Invalid email address')
      return
    }

    this.elem.classList.add('--loading')

    const reset = this.reset.bind(this)
    const error = this.error.bind(this)
    const destroy = this.destroy.bind(this)

    const success = () => {
      const elem = this.elem

      setTimeout(() => {
        elem.classList.remove('--loading')
        setTimeout(() => {
          destroy()
        }, getTransitionTime(elem));
      }, 2000);
    }

    $.ajax({
      url: '/json/signup-price',
      type: 'POST',
      data: { id: this.id, email: email },
      success: function (data) {
        if (!data.error) {
          success()
        }
      },
      error: function () {
        reset()
        error('Something went wrong')
      }
    })
  }

  error(msg) {
    this.elem.classList.add('--error')
    this.elem.querySelector('.price-modal__error').textContent = msg
  }

  reset() {
    this.elem.classList.remove('--error')
    this.elem.classList.remove('--loading')
  }

  setup() {
    const nameElem = this.card.querySelector('.product-card__name')
    const imgElem = this.card.querySelector('.product-card__img')

    if (!nameElem || !imgElem) {
      console.warn('Missing name element or img')
      return
    }

    this.name = nameElem.textContent
    this.imgSrc = imgElem.getAttribute('src')
  }

  get renderHTML() {
    return `
			<div class="price-modal__header">
				<h2>Sign up for price alerts</h2>
				<p>We'll send you an email if price is changed.</p>
			</div>
			<div class="price-modal__item">
				<img src="${this.imgSrc}" alt="">
				<div><h3>${this.name}</h3></div>
			</div>
			<div class="price-modal__main">
				<input type="text" placeholder="Your Email Address...">
        <div class="price-modal__error">Something went wrong</div>
				<div class="price-modal__footer">
					<button class="--sub">Close</button>
					<button onclick="window.signupPrice()">Submit</button>
				</div>
			</div>
    `
  }

  create() {
    const modal = createElem('div', {
      className: 'price-modal',
      innerHTML: this.renderHTML
    })
    return modal
  }

  destroy() {
    unlockScroll()
    this.elem.classList.remove(__VISIBLE)

    const backdrop = window.priceModalBackdrop
    if (backdrop) {
      backdrop.hide(true)
    }

    setTimeout(() => {
      this.elem.remove()
      window.priceModalBackdrop = undefined
      window.signPriceModal = undefined
    }, getTransitionTime(this.elem));
  }

  show() {
    lockScroll()
    this.elem = this.create()
    this.input = this.elem.querySelector('input')
    document.body.appendChild(this.elem)
    this.input.focus()
    this.closeArr.push(this.elem.querySelector('.--sub'))

    for (const elem of this.closeArr) {
      elem.addEventListener('click', () => {
        this.destroy()
      })
    }

    this.input.addEventListener('input', () => {
      this.reset()

      if (this.input.value) {
        this.elem.classList.add('--unlocked')
      } else {
        this.elem.classList.remove('--unlocked')
      }
    })

    requestAnimationFrame(() => {
      this.elem.classList.add(__VISIBLE)
      window.priceModalBackdrop = new Backdrop({
        half: true,
        callback: () => {
          this.destroy()
        }
      })
    })
  }
}

module.exports = PriceModal
},{"./backdrop":12}],16:[function(require,module,exports){
const rootLoader = new Object({
  class: 'root_loader',
  renderHTML: () => { return `<div class=${rootLoader.class}></div>` },
  isExist: () => { return $(document).find(`.${rootLoader.class}`).length ? true : false },

  push: function (noLock = false) {
    if (!noLock) { lockScroll() }
    if (!this.isExist()) { $body.append(rootLoader.renderHTML()) }
  },
  remove: function (noUnlock = false) {
    if (!noUnlock) unlockScroll();
    if (this.isExist()) { $(document).find(`.${rootLoader.class}`).remove() }
  }
})

module.exports = rootLoader
},{}],17:[function(require,module,exports){
class ZoomGallery {
  constructor(mediaArr) {
    this.elem = null
    this.mediaArr = mediaArr
    this.init()
  }

  // Render HTML
  _renderMediaHTML() {
    let html = ''
    for (const media of this.mediaArr) {
      const clone = media.cloneNode(true)
      clone.removeAttribute('style')
      clone.className = 'product-media'

      html += clone.outerHTML
    }
    return html
  }
  _renderInnerHTML() {
    const name = document.querySelector('#item_name')
    return `
    <div class="zoom2__wrapper">
      <div class="zoom2__scroller">
        <div class="zoom2__header">
          <h4>${name.textContent}</h4>
          <button data-zoom-close class="zoom2__close-btn"></button>
        </div>
        ${this._renderMediaHTML()}
      </div>
      <div data-zoom-close class="zoom2__footer">
        <span>Get Back</span>
      </div>
    </div>
    `
  }
  _create() {
    this.elem = document.createElement('div')
    this.elem.className = 'zoom2'
    this.elem.innerHTML = this._renderInnerHTML()
    document.body.append(this.elem)
  }

  // Methods
  hide() {
    if (this.elem) {
      unlockScroll()
      this.elem.classList.remove(__VISIBLE)
      setTimeout(() => {
        this.elem.style.display = 'none'
        this.destroy()
      }, getTransitionTime(this.elem))
    }
  }
  open() {
    if (!this.elem) throw new Error('No element created Zoom2 ZoomGallery')

    lockScroll()
    this.elem.style.display = 'block'
    requestAnimationFrame(() => {
      this.elem.classList.add(__VISIBLE)
    })
  }

  // Events
  _bindInnerEvents() {
    if (this.elem) {
      const closeArr = [...this.elem.querySelectorAll('[data-zoom-close]')];
      closeArr.forEach((closeElem) => {
        closeElem.addEventListener('click', this.hide.bind(this));
      });
    }
  }

  // Init
  init() {
    this._create()
    this._bindInnerEvents()
    this.open()
  }
  destroy() {
    if (this.elem) {
      this.elem.remove()
      this.elem = null
    }
  }
}

module.exports = ZoomGallery
},{}],18:[function(require,module,exports){
const footer = new Object({
  bindEvents: function() {
    if (window.innerWidth < 480) {
      const evtArr = [...document.querySelectorAll('.footer__col-head')]
      for (const elem of evtArr) {
        const col = elem.closest('.footer__col')
        if (!col) return

        if (!col.classList.contains('.--static')) {
          elem.addEventListener('click', () => {
            col.classList.toggle('--open')
          })
        }
      }
    }
  },
  init: function () {
    this.bindEvents()
  }
})

module.exports = footer
},{}],19:[function(require,module,exports){
const header = {
  init: function () {
    this.renderDOM();
    this.bindEvents();
    this.setDropdowns()
  },
  renderDOM: function () {
    // Login Dropdown
    this.loginBtn = $('[data-evt="toggleAccountDropdown"]');
    this.loginDropdown = $(".login-dropdown");

    // Search
    this.searchBtn = $('[data-evt="toggleSearch"]');
    this.searchBlock = $(".header-search");

    this.loginLink = $('.login-nav__link')
  },
  bindEvents: function () {
    this.loginBtn.on('mouseover mouseleave', function (evt) {
      let dd = header.loginDropdown
      if (dd.length) {
        switch (evt.type) {
          case 'mouseover':
            dd.css({ display: 'block', opacity: 1 })
            break;
          case 'mouseleave':
            dd.css({ display: 'none', opacity: 0 })
            break;
        }
      }
    })
    this.loginLink.click(function (e) {
      e.stopPropagation()
    })

    this.searchBtn.click(() => {
      let el = header.searchBlock;

      function hideSearch() {
        el.removeClass(IS_VISIBLE);
        unlockScroll();
      }

      if (el.hasClass(IS_VISIBLE)) {
        hideSearch()
        if (window.searchBackdrop) {
          window.searchBackdrop.hide();
        }
      } else {
        lockScroll();
        el.addClass(IS_VISIBLE);
        el.find("input").focus();

        window.searchBackdrop = new Backdrop({
          half: true,
          zIndex: (getZIndex(document.querySelector('header')) - 1),
          callback: hideSearch
        })
      }
    });
  },
  setDropdowns: function (...args) {
    args = Array.from(document.querySelectorAll('.header__sub-link'))

    if (args.length !== 0 && args) {

      const dd = document.querySelector('.nav-drop')
      const cont = [...document.querySelectorAll('.nav-drop__content')]
      const subLink = [...document.querySelectorAll('.nav-drop_more')]
      const IS_ACTIVE = 'is-active'

      let hideDelayTime, showDelayTime

      if (dd && cont && subLink) {
        const pos = (el) => {
          return {
            top: el.getBoundingClientRect().top + el.offsetHeight,
            left: el.getBoundingClientRect().left + (el.offsetWidth / 2) - (dd.offsetWidth / 2)
          }
        }

        const fn = {
          initial: () => {
            dd.style.top = `${pos(args[0]).top}px`
            dd.style.left = `${pos(args[0]).left}px`
          },
          hide: () => {
            dd.style.opacity = 0
            dd.style.display = 'none'
            args.forEach(el => el.classList.remove(IS_ACTIVE))
          },
          show: (el) => {
            args.forEach(el => el.classList.remove(IS_ACTIVE))
            el.classList.add(IS_ACTIVE)
            dd.style.display = 'block'
            dd.style.top = `${pos(el).top}px`
            dd.style.left = `${pos(el).left}px`
            dd.style.opacity = 1
          },
          switchContent: (attr) => {
            cont.forEach(el => el.style.display = 'none')
            cont.filter(el => el.id == `dd_${attr}`).forEach(el => el.style.display = 'block')
          }
        }

        const { initial: setInitial, hide: hide, show: show, switchContent: switchContent } = fn

        for (let i = 0; i < subLink.length; i++) {
          const el = subLink[i],
            content = el.querySelector('.nav-drop__sub')
          el.onmouseover = () => { content.style.display = 'block' }
          el.onmouseleave = () => { content.style.display = 'none' }
        }

        dd.onmouseover = (e) => {
          if (hideDelayTime) window.clearTimeout(hideDelayTime)
        }

        dd.onmouseleave = (e) => {
          window.clearTimeout(showDelayTime)
          hideDelayTime = window.setTimeout(() => {
            hide()
          }, 150);
        }


        args.forEach((el) => {
          el.onmouseover = (e) => {
            const attr = el.dataset.dropdown
            if (attr) {
              window.clearTimeout(hideDelayTime)
              showDelayTime = window.setTimeout(() => {
                switchContent(attr)
                show(el)
              }, 200);
            }
          }

          el.onmouseleave = (e) => {
            window.clearTimeout(showDelayTime)
            hideDelayTime = window.setTimeout(() => {
              hide()
            }, 150);
          }
        })

        window.onscroll = () => {
          window.clearTimeout(showDelayTime)
          hide(); setInitial()
        }

        setInitial()
      }
    }
  }
}

module.exports = header
},{}],20:[function(require,module,exports){
const heroSplide = {
  init: function () {
    try {
      this.initSplide()
    } catch (err) {
      console.log(err.message)
    }
  },
  initSplide: function () {
    const heroSplide = [...document.querySelectorAll('.hero_splide')]
    if (heroSplide.length !== 0) {
      heroSplide.forEach((slide) => {
        let slider = new Splide(slide, {
          type: "slider",
          perPage: 4,
          perMove: 2,
          autoplay: 0,
          gap: "12px",
          arrows: 1,
          pagination: 0,
          speed: 750,
          breakpoints: {
            991: { perPage: 2.5, },
            767: { perPage: 2, perMove: 1 },
            478: { perPage: 1.4, perMove: 1, gap: 8 }
          }
        })
        slider.mount()
      })
    }
  }
}

module.exports = heroSplide
},{}],21:[function(require,module,exports){
const pageAlerts = {
  classes: {
    fullWidth: 'page-alert_backdrop',
    error: 'page-alert_error',
    warning: 'page-alert_warning',
    info: 'page-alert_info',
    visible: 'is-visible'
  },
  init: function () {
    this.cacheDOM()
    this.bindEvents()
    // this.fullWidth()
  },
  cacheDOM: function () {
    this.container = $('.page-alert')
    this.title = $('.page-alert-title')
    this.subtitle = $('.page-alert-text')
    this.close = $('[data-evt="hidePageAlert"]')
  },
  bindEvents: function () {
    this.close.click(this.hideAlert.bind(this))
    clearTimeout(alertTimer)
  },
  fullWidth: function () {
    this.container.addClass(this.classes.fullWidth)
  },
  showAlert: function (errorType = function () { pageAlerts.resetAlert() }, title, text, hideTime = 2500) {
    clearTimeout(alertTimer)
    this.resetAlert();

    this.container.addClass(this.classes.visible).addClass(errorType)
    this.changeMsg(title, text)
    alertTimer = window.setTimeout(function () {
      pageAlerts.hideAlert()
    }, hideTime)
  },
  hideAlert: function () {
    this.container.removeClass(this.classes.visible)
  },
  changeMsg: function (title, text) {
    this.title.html(title)
    this.subtitle.html(text)
  },
  resetAlert: function () {
    this.container.removeClass(function () {
      let i = pageAlerts.classes
      return `${i.warning} ${i.info} ${i.error}`
    })
  }
}

module.exports = pageAlerts
},{}],22:[function(require,module,exports){
const pageEls = new Object({
  init: function () {
    Object.values(this.attachEvent).forEach((target) => {
      if (typeof target === 'function') {
        try {
          target()
        } catch (err) {
          console.error(err)
        }
      }
    })
  },
  attachEvent: {
    // Floating Whatsapp Button
    observeFloatWhatsapp() {
      const elem = document.querySelector('.wa-float')
      const triggerElem = document.querySelector('.footer')
      if (!elem || !triggerElem) return

      let offset = 120
      let observer = null

      const callback = (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            elem.classList.add(__HIDDEN)
          } else {
            elem.classList.remove(__HIDDEN)
          }
        })
      }

      observer = new IntersectionObserver(callback, {
        root: null,
        rootMargin: `0px 0px -${offset}px 0px`,
        threshold: 0
      })

      observer.observe(triggerElem)
    },
    // Copy Elements
    copyEvents: () => {
      const copyArr = [...document.querySelectorAll('[data-evt-copy]')]
      if (copyArr.length) {
        for (const btn of copyArr) {
          btn.addEventListener('click', () => {
            const textToCopy = btn.dataset.evtCopy
            if (textToCopy) {
              navigator.clipboard.writeText(textToCopy)
            }
          })
        }
      }
    },
    // Track Order
    trackOrderSwitch: () => {
      const arr = document.querySelectorAll('input[name="track_with"]')
      if (arr.length) {

        function toggleInput(value) {
          const elements = {
            phone: document.querySelector('#form_track_order .iti'),
            email: document.querySelector('#input_track_email')
          }

          if (!elements.phone || !elements.email) {
            console.error('phone or email not found')
            return
          }

          if (elements[value]) {
            Object.keys(elements).forEach(key => {
              elements[key].style.display = key === value ? 'block' : 'none'
            })
          } else {
            console.error(`Invalid value: ${value}`)
          }
        }

        arr.forEach((input) => {
          input.addEventListener('change', () => {
            toggleInput(input.value)
          })
        })
      }
    },
    resetTrackOrderForm: () => {
      const elem = document.querySelector('[data-evt="reset_track_form"]')
      if (elem) {
        elem.addEventListener('click', (e) => {
          e.preventDefault()
          const form = document.querySelector('#form_track_order')
          if (!form) {
            console.error('form not found')
            return
          }

          form.reset()
        })
      }
    },
    // Other
    filterDropdown: () => {
      let dropdownEls = Array.from($('.filter-dropdown'))

      for (let i = 0; i < dropdownEls.length; i++) {
        const el = dropdownEls[i];
        $(el).hover(function () {
          let thisCurrent = $(this).find('.filter-dropdown__current'),
            list = $(this).find('.filter-dropdown__list'),
            scrollContainer = list.find('> div'),
            buttons = Array.from(scrollContainer.find('> div')),
            main = $(this).find('.filter-dropdown__main')

          const scrollH = scrollContainer[0].scrollHeight

          if (list.height() == 0) {
            list.css({ height: `${scrollH}px` })
            main.addClass(IS_ACTIVE)
          } else {
            list.css({ height: '0px' })
            main.removeClass(IS_ACTIVE)
          }

          $.each(buttons, function (i) {
            buttons[i].onclick = () => {
              let sibs = $(buttons[i]).siblings()
              sibs.removeClass(IS_ACTIVE)
              buttons[i].classList.add(IS_ACTIVE)

              let val = $(buttons[i]).html()
              thisCurrent.html(val)
            }
          })
        })
      }
    },
    trackingDateUpdate: () => {
      const dates = [...document.querySelectorAll('[data-track="updated_date"]')]
      const nowDate = new Date()

      if (dates.length) {
        const day = nowDate.getDate()
        const month = nowDate.toLocaleDateString('en-US', { month: 'short' })
        const year = nowDate.getFullYear()
        let hours = nowDate.getHours()
        const minutes = nowDate.getMinutes().toString().padStart(2, '0')
        const ampm = hours >= 12 ? 'PM' : 'AM'
        hours = hours % 12 || 12

        for (const date of dates) {
          date.innerHTML = `${day} ${month}, ${year}, ${hours}:${minutes} ${ampm}`
        }
      }
    },
    pageFilters: () => {
      let filterRows = Array.from($('.filter-row'))
      for (let i = 0; i < filterRows.length; i++) {
        const el = $(filterRows[i]),
          header = el.find('.filter-row__header'),
          body = el.find('.filter-row__body'),
          container = el.find('.filter-row__container'),
          icon = header.find('svg')

        header.click(() => {
          let currentBodyHeight = body.height()
          if (currentBodyHeight !== 0) {
            body.css({ height: `${currentBodyHeight}px` })
            setTimeout(() => {
              body.css({ height: 0 })
              container.css({ transform: 'translateY(-24px)', opacity: 0 })
              icon.css({ transform: 'rotate(0deg)' })
            }, 1);
          } else {
            let scrollH = container[0].scrollHeight
            body.css({ height: scrollH })
            container.css({ transform: 'translateY(0px)', opacity: 1 })
            icon.css({ transform: 'rotate(180deg)' })
          }
        })
      }
    },
    faqLists: () => {
      const headArr = [...document.querySelectorAll('.faq-head')]
      let liArr = []
      for (const faqHead of headArr) {
        const li = faqHead.closest('li')
        const body = faqHead.nextElementSibling
        if (li && body) {
          liArr.push(li)
          li.show = () => {
            li.classList.add(__ACTIVE)
            const scrollHeight = body.scrollHeight
            body.style.height = `${scrollHeight}px`
            setTimeout(() => {
              body.style.height = 'auto'
            }, 1);
          }
          li.hide = () => {
            li.classList.remove(__ACTIVE)
            body.style.height = 0
          }

          faqHead.onclick = () => {
            console.log(body)
            if (body.offsetHeight !== 0) {
              li.hide()
            } else {
              li.show()
            }
          }

          // Transform letters
          const h6 = faqHead.querySelector('h6')
          if (h6) {
            const capitalized = h6.textContent.toLowerCase().replace(/(\b)(\w)/g, (match, p1, p2) => p2.toUpperCase())
            h6.textContent = capitalized
          }

          // Reveal first
          if (liArr[0] === li) li.show()
        }
      }
    },
    listings: () => {
      const listings = [...document.querySelectorAll('.listing-set')]
      for (const listing of listings) {
        const buttonArray = [...listing.querySelectorAll('.listing-btn:not(.--disabled)')]
        buttonArray.forEach((btn) => {
          btn.addEventListener('click', () => {
            btn.classList.add(IS_ACTIVE)
            buttonArray.forEach((arrBtn) => {
              if (arrBtn != btn) arrBtn.classList.remove(IS_ACTIVE)
            })
          })
        })
      }
    },
    removeZeroSubheading: () => {
      const arr = [...document.querySelectorAll('.results__subheading')]
      for (const subheading of arr) {
        if (subheading.innerHTML.length < 1) {
          subheading.remove()
        }
      }
    },
    initTelInput: () => {
      let telInputArr = Array.from($('[data-input="tel"]'));

      for (var i = 0; i < telInputArr.length; i++) {
        iti = intlTelInput(telInputArr[i], {
          initialCountry: "auto",
          preferredCountries: ["us", "gb", "br", "cn", "es", "it"],
          autoPlaceholder: "aggressive",
          useFullscreenPopup: true,
          utilsScript:
            "/assets/public-2020/js/plugins/phone/utils.js",
          geoIpLookup: function (callback) {
            fetch("https://ipinfo.io/json", {
              cache: "reload",
            })
              .then((response) => {
                if (response.ok) {
                  return response.json();
                }
                throw new Error("Failed: " + response.status);
              })
              .then((ipjson) => {
                callback(ipjson.country);
              })
              .catch((e) => {
                callback("us");
              });
          },
        });
      }
    },
    initCustomUploads: () => {
      this.arr = [...document.querySelectorAll('[data-custom-upload]')]

      const renderOutputFile = (file, imgSrc = '') => {
        let imgElem = imgSrc ? `<div class="--filled" style="background-image: url(${imgSrc})"></div>` : `<div></div>`
        return `
        <div class="custom-upload__file">
          <div>
            ${imgElem}
            <span data-custom-name>${file.name}</span>
          </div>
          <div>
            <div data-evt="custom_upload_remove" class="--remove"></div>
          </div>
        </div>
        `
      }
      const bindBoxEvents = (box, input) => {
        box.ondragover = (e) => {
          e.preventDefault(); box.classList.add(__ACTIVE)
        }
        box.ondragleave = (e) => {
          e.preventDefault(); box.classList.remove(__ACTIVE)
        }
        box.addEventListener('drop', (e) => {
          e.preventDefault()
          box.classList.remove(__ACTIVE)
          const files = e.dataTransfer.files
          const newDataTransfer = new DataTransfer()

          for (const file of files) {
            newDataTransfer.items.add(file)
          }
          input.files = newDataTransfer.files
          input.dispatchEvent(new Event('change', { 'bubbles': true }))
        })
        box.addEventListener('click', (e) => {
          input.click()
        })
      }
      const setIndexes = (upload) => {
        const files = [...upload.querySelectorAll('.custom-upload__file')]
        for (let i = 0; i < files.length; i++) {
          files[i].dataset.customIndex = i
        }
      }
      const processFiles = (files, upload) => {
        const output = upload.querySelector('.custom-upload__files')
        const currentFiles = [...upload.querySelectorAll('.custom-upload__file')]

        for (const file of currentFiles) {
          file.remove()
        }

        for (const file of files) {
          const fileIsImage = file.type.match('image.*')
          if (fileIsImage) {
            let reader = new FileReader()
            reader.onload = (e) => {
              output.insertAdjacentHTML('beforeend', renderOutputFile(file, e.target.result))
            }
            reader.readAsDataURL(file)
          } else {
            output.insertAdjacentHTML('beforeend', renderOutputFile(file))
          }
        }
        setIndexes(upload)
      }

      for (const upload of this.arr) {
        const box = upload.querySelector('.custom-upload__box')
        const input = upload.querySelector('input')

        if (box) {
          bindBoxEvents(box, input)
        }

        input.addEventListener('change', (e) => {
          const files = e.target.files
          processFiles(files, upload)
        })
      }

      document.addEventListener('click', (e) => {
        const target = e.target
        if (e.target.closest('[data-evt="custom_upload_remove"]')) {
          const upload = target.closest('[data-custom-upload]')
          if (!upload) throw new Error('data-custom-upload not found')
          const input = upload.querySelector('input[type="file"]')
          if (!input) throw new Error('input[type="file"] not found')
          const nameEl = e.target.closest('.custom-upload__file').querySelector('*[data-custom-name]')
          if (!nameEl) throw new Error('data-custom-name not found')

          const name = nameEl.innerHTML
          const newDataTransfer = new DataTransfer()
          const { files } = input

          for (let i = 0; i < files.length; i++) {
            if (files[i].name !== name) {
              newDataTransfer.items.add(files[i])
            }
          }

          if (newDataTransfer.items.length === 0) {
            input.value = ''
          } else {
            input.files = newDataTransfer.files
          }

          input.dispatchEvent(new Event('change', { 'bubbles': true }))
        }
      })
    },
    attachPayModal: () => {
      let evtOpenLater = $('[data-evt="payModalLater"]'),
        evtOpenCrypto = $('[data-evt="payModalCrypto"]'),
        evtClose = $('[data-evt="closePayModal"]'),
        crypto = $('#payModalCrypto'),
        later = $('#payModalLater'),
        modal = $('.pay-modal')

      const openModal = () => {
        lockScroll()
        modal.show()
        setTimeout(() => {
          modal.css({ opacity: 1 })
        }, 1);
      }

      const closeModal = () => {
        unlockScroll()
        modal.css({ opacity: 0 })
        setTimeout(() => {
          modal.hide()
        }, getTransitionTime(modal));
      }

      evtOpenLater.add(evtOpenCrypto).click(function () {
        openModal()
        crypto.add(later).hide()
        if ($(this).is(evtOpenCrypto)) {
          crypto.show()
        }
        if ($(this).is(evtOpenLater)) {
          later.show()
        }
      })

      evtClose.click(function () {
        closeModal()
      })
    },
    attachToggleInputs: function () {
      const arr = [...document.querySelectorAll('[data-input-toggle]')]
      for (const input of arr) {
        const btn = input.parentNode.querySelector('button') || input.parentNode.querySelector('input[type="submit"]')
        if (btn) {
          input.addEventListener('input', () => {
            const value = input.value
            if (value) {
              btn.disabled = false
              return
            }
            btn.disabled = true
            return
          })

          input.addEventListener('keydown', (e) => {
            const keyIsEnter = e.key === 'Enter'
            if (keyIsEnter) {
              e.preventDefault()
              btn.click()
            }
          })

          btn.addEventListener('click', () => {
            const value = input.value
            input.value = ''
            input.dispatchEvent(new Event('input'))
          })
        }
      }
    },
    initProductZoom: () => {
      const isDesktop = window.innerWidth > 991
      window.removeSlider = (target) => {
        unlockScroll()
        const slider = target.closest('.zoom_slider'); slider.css({ opacity: 0 })
        setTimeout(() => { slider.hide() }, 400);
      }

      const setDesktopZoom = () => {
        [...document.querySelectorAll('.product-media-img')].reduce((acc, el) => {
          if (el && el !== null) {
            if (!/(placeholder|store|pay)/gi.test(el.getAttribute('src'))) {
              acc.push($(el).parent('.product-media__inner-wrap'))
            }
          }
          return acc
        }, []).forEach((el) => {
          $(el).zoom({ magnify: 1.9, on: 'click' })
          $(el).on('mouseleave', function () { $(document).trigger('click') })
        })
      }

      const setMobileZoom = () => {
        const sliders = [...document.querySelectorAll('.product-slider')] // Get all existing sliders

        sliders.forEach((slider, index) => {
          const button = $('<button/>', { class: `product__zoom-btn zoom_btn${index}` }); button.appendTo($(slider)) // Create & append zoom button
          const renderNewSlider = (slider, index) => { // Get HTML new zoom slider
            let mediaArr = [...slider.querySelectorAll('img')].reduce((acc, img) => {
              const src = img.getAttribute('src')
              if (!acc.includes(src) && !/(placeholder|store|pay)/gi.test(src)) { acc.push(src) }
              return acc
            }, []).sort()

            this.renderMedia = () => {
              return mediaArr.reduce((acc, src) => {
                acc += `<div class="splide__slide"><img src="${src}"></div>`
                return acc
              }, '')
            }

            return `
            <div class="zoom_slider zsl${index}">
              <div>
                <div class="zoom_slider_logo"><img src="${String.raw`\themes\default\frontend\oct-2023/assets/logo.svg`}"></div>
                <button class="zoom_slider-close" onclick="removeSlider($(this))"></button>
                <div class="zoom-sl${index} splide">
                  <div class="splide__track">
                    <div class="splide__list">
                    ${this.renderMedia()}
                    </div>
                  </div>
                  <div class="splide__arrows">
                    <div class="splide__arrow--prev"></div>
                    <div class="splide__arrow--next"></div>
                  </div>
                </div>
              </div>
            </div>`
          }
          const appendNewSlider = (html) => { $body.append(html) } // Append Zoom Slider
          const initNewSlider = (index) => { // Splide Initialization
            this.settings = {
              type: "loop",
              perPage: 1,
              perMove: 1,
              autoplay: 0,
              gap: "12px",
              arrows: 1,
              pagination: 0,
              speed: 800,
              drag: false,
              dragAngleThreshold: 0
            }
            const zoomSlider = new Splide(`.zoom-sl${index}`, this.settings);
            zoomSlider.mount()
          }
          const initZoom = (index) => { // Initialize jQuery zoom for the new slider
            let slides = [...document.querySelector(`.zoom_slider.zsl${index}`).querySelectorAll('.splide__slide')]
            slides.forEach((slide) => {
              $(slide).zoom({
                magnify: 1.4,
                onZoomIn: function () {
                  $(this).closest('.splide').css('border-color', '#e6eaec')
                },
                onZoomOut: function () {
                  $(this).closest('.splide').css('border-color', '#0095c6')
                }
              })
            })
          }
          const showNewSlider = (index) => {
            let localSlider = $(`.zoom_slider.zsl${index}`)
            if (localSlider) { localSlider.show(); lockScroll(); setTimeout(() => { localSlider.css({ opacity: 1 }) }, 1); }
          }
          const openSlider = (index) => {
            let slider = $(`.zoom_slider.zsl${index}`)
            if (slider) { slider.show(); lockScroll(); setTimeout(() => { slider.css({ opacity: 1 }) }, 1); }
          }

          button.click(() => {
            const localSlider = document.querySelector(`.zoom_slider.zsl${index}`)
            if (!localSlider) {
              appendNewSlider(renderNewSlider(slider, index))
              initNewSlider(index)
              initZoom(index)
              showNewSlider(index)
            } else {
              openSlider(index)
            }
          })
        })
      }

      const setZoom = () => {
        $(document).ready(function () {
          if (document.querySelector('.main_product_zoom') == null) {
            if (isDesktop && $('.main_product').length) { setDesktopZoom() } else {
              setMobileZoom()
            }
          }
        })
      }

      return setZoom()
    },
    initTestProductZoom: () => {
      let zoomOpenCount = 0

      const setZoom = () => {
        const
          srcIsValid = (src) => {
            return !/(placeholder|store|pay)/gi.test(src)
          },
          filterMedia = (arr) => {
            return arr.reduce((acc, media) => {
              const
                img = media.querySelector('img'),
                thumbAncestor = media.closest('.product-slider_thumbnails'),
                zoomAncestor = media.closest('.zoom-modal')

              if (img && img !== null && thumbAncestor == null && zoomAncestor == null) {
                const src = img.getAttribute('src')
                if (srcIsValid(src)) { acc.push(media) }
              }
              return acc
            }, [])
          },
          getSrcArr = (arr) => {
            return arr.reduce((acc, media) => {
              const img = media.querySelector('img')
              if (img !== null) {
                if (img.hasAttribute('src')) {
                  const src = img.getAttribute('src')
                  if (srcIsValid(src) && !acc.includes(src)) { acc.push(src) }
                }
              }
              return acc
            }, [])
          },
          renderSlidesHTML = (srcArr) => {
            return srcArr.reduce((acc, src) => {
              acc += `<div style="cursor: zoom-in" class="zoom-modal__slide splide__slide"><img loading="eager" alt="" src="${src}"></div>`
              return acc
            }, '')
          },
          renderSplideHTML = (slidesHTML) => {
            let productTitle = $('.product__item-title').html(),
              price = $('.product__item-price').eq(-1).html()
            return `
          <div class="zoom-modal splide">
            <button data-evt="closeZoomModal" class="zoom-modal__close-btn"></button>
            <div class="zoom-modal__holder">
              <div class="splide__arrows">
                <div class="splide__arrow--prev"></div>
                <div class="splide__arrow--next"></div>
              </div>
              <div class="zoom-modal__header">
                <img src="${String.raw`\themes\default\frontend\oct-2023/assets/logo.svg`}" loading="lazy" alt="">
                <img style="display: none" src="${String.raw`./assets/logo.svg`}" loading="lazy" alt="">
              </div>
              <div class="zoom-modal__footer">
                <h1 class="zoom-modal__name">${productTitle}</h1>
                <a href="javascript:void(0)" data-evt="closeZoomModal" class="zoom-modal__buy-btn" onclick="addToCart()">Add To Cart<span>${price} USD</span></a>
              </div>
              <div class="zoom-modal__slider">
                <div class="splide__track">
                  <div class="splide__list">
                    ${slidesHTML}
                  </div>
                </div>
              </div>
            </div>
          </div>
          `
          },
          initZoomSlider = (indexToGo = 0) => {
            const
              settings = {
                type: "loop",
                perPage: 1,
                perMove: 1,
                autoplay: 0,
                gap: "12px",
                arrows: 1,
                pagination: 0,
                speed: 800,
                drag: false,
                dragAngleThreshold: 0
              },
              slider = document.querySelector('.zoom-modal')
            if (slider !== null) {
              const zoomSlider = new Splide('.zoom-modal', settings);
              zoomSlider.mount()
              zoomSlider.go(indexToGo)
            }
          },
          initPressZoom = (slider) => {
            const slides = [...slider.querySelectorAll('.splide__slide')],
              zoomValue = window.innerWidth > 479 ? 2.2 : 1.6
            slides.forEach((slide) => {
              $(slide).zoom({
                magnify: zoomValue,
                on: 'grab',
                onZoomIn: function () {
                  $('.zoom-modal .splide__arrows').css({ opacity: 0 })
                  $('.zoom-hint').css({ opacity: 0 })
                },
                onZoomOut: function () {
                  $('.zoom-modal .splide__arrows').css({ opacity: 1 })
                }
              })
            })
          }

        const mediaArr = filterMedia([...document.querySelectorAll('.product-media')])

        mediaArr.forEach((el) => {
          el.onclick = () => {
            lockScroll()
            try {
              const
                sibSrcArr = getSrcArr(filterMedia([...el.parentNode.closest('div').querySelectorAll('.product-media')])),
                splideHTML = renderSplideHTML(renderSlidesHTML(sibSrcArr))

              $body.append(splideHTML)
              initZoomSlider(sibSrcArr.indexOf(el.querySelector('img').getAttribute('src')))

              let zoomModal = document.querySelector('.zoom-modal'),
                holder = zoomModal.querySelector('.zoom-modal__holder')
              initPressZoom(zoomModal)

              let zoomHint = $('<\div>', { class: 'zoom-hint' })

              setTimeout(() => {
                zoomModal.style.opacity = 1
                if (zoomOpenCount <= 1) { $(holder).append(zoomHint); setTimeout(() => { zoomHint.css({ opacity: 1 }) }, 500) }
              }, 1);

              zoomModal.addEventListener('mousedown', () => {
                zoomHint.css({ opacity: 0 });
                setTimeout(() => {
                  zoomHint.remove()
                }, 450)
              })
              document.onkeydown = (e) => {
                e = e || window.event
                let isEsc = false
                if ('key' in e) {
                  isEsc = (e.key === "Escape" || e.key === "Esc");
                } else {
                  isEsc = (e.keyCode === 27);
                }
                if (isEsc) {
                  e.preventDefault()
                  unlockScroll()
                  let modal = $('.zoom-modal')
                  if (modal.length) {
                    modal.css({ opacity: 0 })
                    setTimeout(() => {
                      modal.remove()
                    }, getTransitionTime(modal));
                  }
                }
              }
              zoomOpenCount++
            } catch {
              throw new Error('JS : Init Product Zoom Error')
            }
          }
        })

        $(document).on('click', '[data-evt="closeZoomModal"]', function () {
          unlockScroll()
          let modal = $('.zoom-modal')
          if (modal.length) {
            modal.css({ opacity: 0 })
            setTimeout(() => {
              modal.remove()
            }, getTransitionTime(modal));
          }
        })
      }

      if (document.querySelector('.main_product_zoom') !== null) { setZoom() }
    },
    attachStickyScroll: () => {
      const bar = $('.filter-sidebar'), overlay = $('.filter-sidebar__overlay')
      if (bar.length && overlay.length) {
        const els = bar.find('.filter-row')
        $.each(els, function (i) {
          els[i].onclick = () => {
            let cont = $(this).find('.filter-row__container')
            setTimeout(() => {
              let currentHeight = bar.height()
              let scrollHeight = bar[0].scrollHeight
              if ((currentHeight - scrollHeight) <= -5) {
                overlay.css({ opacity: 1 })
              } else {
                overlay.css({ opacity: 0 })
              }
            }, getTransitionTime(cont));
          }
        })
        bar[0].addEventListener('scroll', function (e) {
          if (this.scrollTop + this.clientHeight >= this.scrollHeight) {
            overlay.css({ opacity: 0 })
          } else { overlay.css({ opacity: 1 }) }
        })
      }
    },
    attachCheckoutCopy: () => {
      const btnArr = [...document.querySelectorAll('.crypto-how-btn'), ...document.querySelectorAll('.copy-address-btn')]
      if (btnArr.length) {
        btnArr.forEach((btn) => {
          btn.onclick = () => {
            if (!window.getSelection().toString()) {
              let details = btn.closest('.checkout-form__radio-details')
              if (details !== null) {
                let address = details.querySelector('.copy-address-btn__typo').innerHTML
                async function copyAddress() {
                  try {
                    await navigator.clipboard.writeText(address);
                    details.classList.add(IS_COPIED)
                    setTimeout(() => {
                      details.classList.remove(IS_COPIED)
                    }, 1300);
                  } catch (err) {
                    details.classList.remove(IS_COPIED, IS_ERROR)
                    setTimeout(() => {
                      details.classList.remove(IS_COPIED, IS_ERROR)
                    }, 2100);
                  }
                }
                copyAddress()
              }
            }
          }
        })
      }
    },
    adjustStickyEls: () => {
      const elsArr = [...document.querySelectorAll('.filter-sidebar.to-stick'), ...document.querySelectorAll('.sticky-filters')]
      const header = document.querySelector('.header')

      if (elsArr.length && header) {
        function adjust() {
          let headerHeight = parseInt(window.getComputedStyle(header).getPropertyValue('height'))
          elsArr.forEach((el) => {
            let topValue = $(window).width() > 991 ? headerHeight + 24 : headerHeight
            Object.assign(el.style, { top: `${topValue}px` })
          })
        }
        ['load', 'resize'].forEach((event) => { window.addEventListener(event, () => { adjust() }) })
      }
    },
    bindCardFav: () => {
      const buttons = document.querySelectorAll('.card-item-fav')
      buttons.forEach(btn => btn.onclick = () => {
        if (btn.classList.contains(IS_ACTIVE)) {
          btn.classList.remove(IS_ACTIVE)
        } else {
          btn.classList.add(IS_ACTIVE)
        }
      })
    },
    observeSmartPictures: () => {
      const arr = [...document.querySelectorAll('.smart-picture')]
      for (const el of arr) {
        const img = el.querySelector('img')
        if (!img) {
          el.classList.add(__LOADED)
        } else {
          if (img.complete || img.src.length === 0) {
            el.classList.add(__LOADED)
          } else {
            img.addEventListener('load', () => {
              el.classList.add(__LOADED)
            })
          }
        }
      }
    }
  }
})

module.exports = pageEls
},{}],23:[function(require,module,exports){
const pageReviews = {
  init: function () {
    if (document.querySelector('.page-reviews.splide') !== null) {
      this.initSplide()
    }
  },
  initSplide: function () {
    try {
      let main = new Splide('.page-reviews', {
        type: "slider",
        perPage: 3.4,
        perMove: 1,
        autoplay: 0,
        pauseOnHover: 1,
        pauseOnFocus: 1,
        gap: 12,
        arrows: 1,
        pagination: 1,
        speed: 500,
        breakpoints: {
          991: {
            perPage: 2.2
          },
          620: {
            perPage: 1.3
          }
        }
      })
      main.mount()
    } catch {
      console.log('Page Review SPLIDE ERR')
    }
  }
}

module.exports = pageReviews
},{}],24:[function(require,module,exports){
const pgModal = new Object({
  initialized: undefined,
  init: function () {
    this.renderDOM();
    this.bindEvents();
    Object.values(this.initFn).forEach((target) => {
      if (typeof target === "function") target();
    });
    this.intialized = true;
  },

  renderDOM: function () {
    // Root
    this.modal = $(".pg-modal");
    this.container = $(".pg-modal__container");
    this.backdrop = $(".pg-modal__backdrop");
    this.close = $('[data-evt="closePgModal"]');

    // Sections
    this.section = $(".pg-section");
    this.row = $(".pg-row");
    this.scrollContainer = $(".pg-modal__overscroll");
    this.sectionBracelets = this.section.filter("#pgBracelets");
    this.sectionDiamonds = this.section.filter("#pgDiamonds");
    this.sectionRings = this.section.filter("#pgRings");
    this.sectionNecklaces = this.section.filter("#pgNecklaces");

    // Controls
    this.switchBtn = $(".pg-switch-btn");

    // Select Tabs
    this.selectArr = Array.from($(".pg-select"));
    this.selectBtn = $(".pg-select-btn");
  },
  bindEvents: function () {
    this.close.click(function () {
      pgModal.fn.closeModal();
    });
  },

  fn: {
    openModal: function (target) {
      lockScroll();
      pgModal.modal.show();
      setTimeout(() => {
        pgModal.backdrop.css({ opacity: 1 });
        pgModal.container.removeClass("is-hidden");
      }, 1);
      let att = $(target).attr("data-pg-open");
      pgModal.section.hide();
      switch (att) {
        case "diamonds":
          pgModal.sectionDiamonds.show();
          break;
        case "rings":
          pgModal.sectionRings.show();
          break;
        case "bracelets":
          pgModal.sectionBracelets.show();
          break;
        case "necklaces":
          pgModal.sectionNecklaces.show();
          break;
        default:
          pgModal.section[0].show();
          break;
      }
      pgModal.scrollContainer[0].scrollTop = 0;
      pgSelect.attachControls(pgModal.selectArr, pgModal.selectBtn);
    },
    closeModal: function () {
      unlockScroll();
      pgModal.backdrop.css({ opacity: 0 });
      pgModal.container.addClass("is-hidden");
      setTimeout(() => {
        pgModal.modal.hide();
      }, 475);
    },
    setMobile: function () {
      if ($(window).width() < 480) {
        let arr = Array.from(pgModal.section);
        for (let i = 0; i < arr.length; i++) {
          let nArr = Array.from($(arr[i]).find(pgModal.row));
          $.each(nArr, function (i) {
            if (i > 0) {
              $(nArr[i]).hide();
            }
          });
        }
      }
    },
    attachSectionControls: function () {
      pgModal.section.each(function () {
        let btnArr = [...$(this).find(pgModal.switchBtn)];
        let rowArr = [...$(this).find(pgModal.row)];
        $.each(btnArr, function (i) {
          btnArr[i].onclick = () => {
            $.each(rowArr, function (i) {
              $(rowArr[i]).hide();
            });
            $.each(btnArr, function (i) {
              $(btnArr[i]).removeClass("is-active");
            });
            $(this).addClass("is-active");
            $(rowArr[i]).show();
          };
        });
      });
    },
  },

  initFn: {
    setInitial: () => {
      pgModal.fn.closeModal();
      pgModal.fn.setMobile();
      pgModal.fn.attachSectionControls();
    },
  },
})

module.exports = pgModal
},{}],25:[function(require,module,exports){
const pgSelect = {
  initalized: undefined,
  init: function () {
    this.renderDOM();
    this.initalized = true;
  },
  getAttrDOM: function (att) {
    return $(`[data-pg-set="${att}"]`);
  },
  renderDOM: function () {
    // Shape
    this.shapeImg = this.getAttrDOM("shapeImg");
    this.shapeTitle = this.getAttrDOM("shapeTitle");
    this.shapeDescription = this.getAttrDOM("shapeDescription");

    // Color
    this.colorImg = this.getAttrDOM("colorImg");
    this.colorTitle = this.getAttrDOM("colorTitle");
    this.colorDescription = this.getAttrDOM("colorDescription");

    // Clarity
    this.clarityImg = this.getAttrDOM("clarityImg");
    this.clartyTitle = this.getAttrDOM("clarityTitle");
    this.clarityDescription = this.getAttrDOM("clarityDescription");

    // Ring Size
    this.currentSize = this.getAttrDOM("currentSize");
    this.circSize = this.getAttrDOM("circSize");
    this.dSize = this.getAttrDOM("dSize");
    this.euSize = this.getAttrDOM("euSize");
    this.ukSize = this.getAttrDOM("ukSize");
  },
  attachControls: function (sArr, sBtn) {
    if (!this.initalized) {
      pgSelect.init();
    }
    let selectArr = sArr,
      selectBtn = sBtn;
    for (let i = 0; i < selectArr.length; i++) {
      let thisAttr = selectArr[i].getAttribute("data-pg-select"),
        btnArr = Array.from($(selectArr[i]).find(selectBtn));

      function setPgSelectEvent() {
        let dataSet;
        switch (thisAttr) {
          case "shape":
            dataSet = pgSelect.shape;
            break;
          case "color":
            dataSet = pgSelect.color;
            break;
          case "clarity":
            dataSet = pgSelect.clarity;
            break;
          case "ring-size":
            dataSet = pgSelect.ringSize;
            break;
        }
        return { dataSet };
      }

      $.each(btnArr, function (i) {
        btnArr[i].onclick = () => {
          setPgSelectEvent().dataSet.changeDetails(i);
          $.each(btnArr, function (i) {
            btnArr[i].classList.remove("is-active");
          });
          $(this).addClass("is-active");
        };
      });
    }
  },
  shape: {
    changeDetails: function (index) {
      pgSelect.shapeImg.attr("src", pgSelect.data.shape[index].url);
      pgSelect.shapeTitle.html(pgSelect.data.shape[index].title);
      pgSelect.shapeDescription.html(pgSelect.data.shape[index].description);
    },
  },
  color: {
    changeDetails: function (index) {
      pgSelect.colorImg.attr("src", pgSelect.data.color[index].url);
      pgSelect.colorTitle.html(pgSelect.data.color[index].title);
      pgSelect.colorDescription.html(pgSelect.data.color[index].description);
    },
  },
  clarity: {
    changeDetails: function (index) {
      pgSelect.clarityImg.attr("src", pgSelect.data.clarity[index].url);
      pgSelect.clartyTitle.html(pgSelect.data.clarity[index].title);
      pgSelect.clarityDescription.html(
        pgSelect.data.clarity[index].description
      );
    },
  },
  ringSize: {
    changeDetails: function (index) {
      pgSelect.currentSize.html(pgSelect.data.ringSize[index].us);
      pgSelect.circSize.html(pgSelect.data.ringSize[index].circ);
      pgSelect.dSize.html(pgSelect.data.ringSize[index].diameter);
      pgSelect.euSize.html(pgSelect.data.ringSize[index].europe);
      pgSelect.ukSize.html(pgSelect.data.ringSize[index].uk);
    },
  },
  data: {
    shape: [
      {
        url: "https://i.ibb.co/ZBmcG0f/dmg-shape-round.png",
        title: "Round",
        description:
          "A classic and timeless shape, the round diamond is known for its brilliant sparkle and perfect symmetry.",
      },
      {
        url: "https://i.ibb.co/rdNkYyp/dmg-shape-priness.png",
        title: "Princess",
        description:
          "A square-shaped diamond with sharp corners and exceptional brilliance, known for its modern and clean lines.",
      },
      {
        url: "https://i.ibb.co/271bsCZ/dmg-shape-oval.png",
        title: "Oval",
        description:
          "A modified brilliant cut diamond with an elongated shape, known for its brilliance and ability to create the illusion of longer, slender fingers.",
      },
      {
        url: "https://i.ibb.co/qyQnV1f/dmg-shape-pear.png",
        title: "Pear",
        description:
          "An elegant combination of a round and marquise shape, sometimes called a teardrop, offering a unique and graceful appearance.",
      },
      {
        url: "https://i.ibb.co/NVdgJtv/dmg-shape-emerald.png",
        title: "Emerald",
        description:
          "A rectangular shape with stepped facets, highlighting the diamonds clarity and showcasing a timeless and sophisticated look.",
      },
    ],
    color: [
      {
        url: "https://i.ibb.co/MDnYmGh/dmg-color-near.png",
        title: "K - Last Grade",
        description:
          "The color may be visible to the unaided eye. Diamonds with a K-color grade can be a smart choice, offering excellent value for money.",
      },
      {
        url: "https://i.ibb.co/MDnYmGh/dmg-color-near.png",
        title: "J - Last Grade",
        description:
          'Color in diamonds graded as "near-colorless" may be slightly visible to the naked eye, especially in fancy shapes or diamonds larger than 1 carat.',
      },
      {
        url: "https://i.ibb.co/JkK4B3C/dmg-color-slight.png",
        title: "I - Slightly Detectable",
        description:
          "Upon close examination, the color may be barely noticeable, but it still provides exceptional value.",
      },
      {
        url: "https://i.ibb.co/J2JhPM4/dmg-color-clear.png",
        title: "H - Near Colorless",
        description:
          'The "near-colorless" grade of CA exhibits noticeable color only when compared to much higher color grades, offering excellent value.',
      },
      {
        url: "https://i.ibb.co/J2JhPM4/dmg-color-clear.png",
        title: "G - Almost Colorless",
        description:
          'This grade is the highest level of "near-colorless" and may show some color in comparison to the even higher "colorless" grades, but it offers excellent value.',
      },
      {
        url: "https://i.ibb.co/J2JhPM4/dmg-color-clear.png",
        title: "F - Colorless",
        description:
          'The "colorless" grade is most valued when placed in platinum or white gold, with a faint color that can be identified by a skilled gemologist.',
      },
      {
        url: "https://i.ibb.co/J2JhPM4/dmg-color-clear.png",
        title: "E - Colorless",
        description:
          'This grade, best showcased in platinum or white gold, is so "colorless" that even trained eyes would struggle to detect traces of color.',
      },
    ],
    clarity: [
      {
        url: "https://i.ibb.co/Gp8pKwK/clarity-i3.png",
        title: "I1, I2, I3 - Included",
        description:
          "Diamonds in this clarity range have inclusions that are easily visible under 10x magnification and may also be visible to the naked eye. These diamonds may have reduced brilliance and sparkle due to their inclusions.",
      },
      {
        url: "https://i.ibb.co/ZHBvJz9/clarity-si1-si2.png",
        title: "SI1 & SI2 - Slightly Included",
        description:
          "These grades have noticeable inclusions under 10x magnification, some of which might be visible to the naked eye. SI diamonds generally offer good value as they have inclusions that might not significantly affect the appearance of the diamond.",
      },
      {
        url: "https://i.ibb.co/27xG7GC/clarity-vs1-vs2.png",
        title: "VS1 & VS2 - Very Slightly Included",
        description:
          "These grades have minor inclusions that are visible under 10x magnification but are considered relatively small and not easily noticeable to the naked eye.",
      },
      {
        url: "https://i.ibb.co/d61wnL9/clarity-vvs1-vvs2.png",
        title: "VVS1 & VVS2 - Very, Very Slightly Included",
        description:
          "These grades indicate that inclusions are extremely difficult to see even under 10x magnification. VVS diamonds may have minor inclusions that are barely visible to a skilled grader.",
      },
      {
        url: "https://i.ibb.co/WKsqs99/clarity-fl-if.png",
        title: "FL & IF - Flawless",
        description:
          "These are the highest clarity grades. Flawless diamonds have no visible inclusions or blemishes under 10x magnification, even by a skilled grader. Internally Flawless diamonds have no internal inclusions but may have minor surface blemishes.",
      },
    ],
    ringSize: [
      { us: 4, europe: "47", uk: "H 1/2", diameter: "14.9", circ: "46.8" },
      { us: 4.5, europe: "48", uk: "I 1/2", diameter: "15.3", circ: "48" },
      { us: 5, europe: "49", uk: "J 1/2", diameter: "15.7", circ: "49.3" },
      { us: 5.5, europe: "51", uk: "K 1/2", diameter: "16.1", circ: "50.6" },
      { us: 6, europe: "52", uk: "L 1/2", diameter: "16.5", circ: "51.9" },
      { us: 6.5, europe: "53", uk: "M 1/2", diameter: "16.9", circ: "53.1" },
      { us: 7, europe: "54", uk: "N 1/2", diameter: "17.3", circ: "54.4" },
      { us: 7.5, europe: "55", uk: "O 1/2", diameter: "17.7", circ: "55.7" },
      { us: 8, europe: "57", uk: "P 1/2", diameter: "18.1", circ: "57.0" },
      { us: 8.5, europe: "58", uk: "Q 1/2", diameter: "18.5", circ: "58.3" },
      { us: 9, europe: "59", uk: "R 1/2", diameter: "19.0", circ: "59.5" },
      { us: 9.5, europe: "61", uk: "S 1/2", diameter: "19.4", circ: "60.8" },
      { us: 10, europe: "62", uk: "T 1/2", diameter: "19.8", circ: "62.1" },
      { us: 10.5, europe: "63", uk: "U 1/2", diameter: "20.2", circ: "63.4" },
      { us: 11, europe: "64", uk: "V 1/2", diameter: "20.6", circ: "64.6" },
      { us: 11.5, europe: "66", uk: "W 1/2", diameter: "21.0", circ: "65.9" },
      { us: 12, europe: "67", uk: "X 1/2", diameter: "21.4", circ: "67.2" },
      { us: 12.5, europe: "68", uk: "Z 1/2", diameter: "21.8", circ: "68.5" },
    ],
  },
}

module.exports = pgSelect
},{}],26:[function(require,module,exports){
window.sirvTimer = null
const sirvCards = {
  visibleClass: 'is-visible',
  init: function () {
    this.cacheDOM()
    this.bindEvents()
  },
  cacheDOM: function () {
    this.cards = $('.product-card')
  },
  bindEvents: function () {
    if (this.cards) {
      this.cards.on('mouseenter mouseleave touchstart touchend', function (e) {
        switch (e.type) {

          case 'touchstart':
            sirvCards.toggleSirv($(this), 1)
            break;

          case 'touchend':
            sirvCards.toggleSirv($(this), 0)
            break;
          case 'mouseenter':
            sirvCards.toggleSirv($(this), 1)
            break;
          case 'mouseleave':
            sirvCards.toggleSirv($(this), 0)
            break;
        }
      })
    }
  },
  toggleSirv: function ($this, state) {
    let sirv = $this.find('.product-picture_sirv')
    if (sirv.length !== 0) {
      let id = sirv.find('.Sirv').attr('id')
      if (state !== 0) {
        sirv.show()
        setTimeout(() => {
          sirv.addClass(this.visibleClass)
        }, 1);
        Sirv.instance(id).play()
      } else {
        Sirv.instance(id).pause()
        sirv.removeClass(this.visibleClass)
        sirvTimer = window.setTimeout(function () {
          sirv.hide()
        }, 300)
      }
    }
  }
}

module.exports = sirvCards
},{}],27:[function(require,module,exports){
function initValidators() {
  $(".needs-validation").parsley({
    errorClass: 'is-invalid text-danger',
    successClass: 'is-valid',
    errorsWrapper: '<div class="invalid-feedback"></div>',
    errorTemplate: '<span></span>',
    trigger: 'change'
  });
}

function resetBtnStates(el) {
  el.removeClass('is-successful');
  el.removeClass('is-failed');
}

function showAlternativeBtnText(el, msg, css_class) {
  var original_msg = $(el).html();
  resetBtnStates($(el));
  $(el).addClass(css_class).html(msg);
  setTimeout(function () {
    resetBtnStates($(el));
    $(el).html(original_msg);
  }, 4000);
}

function resetSignMessage() {
  const el = document.querySelector('.sign-modal__message')
  if (el) {
    el.classList.remove('is-successful')
    el.classList.remove('is-failed')
    el.style.display = 'none'
    el.innerHTML = ''
  }
}

function showSignMessage(msg, css_class) {
  const el = document.querySelector('.sign-modal__message')
  if (el) {
    var original_msg = el.innerHTML
    resetSignMessage()
    el.classList.add(css_class)
    el.style.display = 'flex'
    el.innerHTML = msg
    setTimeout(function () {
      resetSignMessage()
      el.innerHTML = original_msg
    }, 4000);
  }
}

window.Parsley.on('form:submit', function () {
  //console.log("submit form");
  var form = $(this.$element[0]);
  var url = form.attr('action');
  var btn = form.find(".js-loading-btn");
  $.ajax({
    type: "POST",
    url: url,
    data: form.serialize(), // serializes the form's elements.
    success: function (data) {
      var r = $.parseJSON(data);
      if (!r.error) {
        //show success state on button and return message in r.msg
        showSignMessage(r.msg, 'is-successful');
        window.setTimeout(function () {
          if (r.link != undefined && r.link != '') {
            window.location.href = r.link;
          } else {
            window.location.reload();
          }
        }, 3000);
      } else {
        //show failed state on button and return message in r.msg
        showSignMessage(r.msg, 'is-failed');
      }
    }
  });
  return false;
});

class SignModal {
  constructor(rootEl) {
    this.rootEl = rootEl
    this.adjustEl = rootEl.querySelector('.sign-modal__adjust')
    this.backdrop = rootEl.querySelector('.sign-modal__backdrop')
    this.container = rootEl.querySelector('.sign-modal__container')
    this.formsArr = [...rootEl.querySelectorAll('form')]
    this.evtOpenArr = document.querySelectorAll('[data-evt="openSignModal"]')
    this.evtCloseArr = document.querySelectorAll('[data-evt="closeSignModal"]')
    this.evtJsToggleSign = document.querySelectorAll('.js-toggle-sign')
    this.contentArr = [...rootEl.querySelectorAll('[data-sign-content]')]
    this.evtSwitchContentArr = rootEl.querySelectorAll('[data-sign-switch]')
    this.evtTogglePassword = [...rootEl.querySelectorAll('[data-evt="togglePassword"]')]
    this.loader = rootEl.querySelector('.sign-modal__loader')
    this.jsSubmitArr = [...rootEl.querySelectorAll('.js-submit')]
    this.otpArr = [...this.rootEl.querySelectorAll('input.--otp')]
    this.locked = false
    this.opened = true
    this.activeContent = undefined
  }

  /**
   * Getters
   */
  get getActiveContent() {
    return this.contentArr.find(e => window.getComputedStyle(e).display !== 'none')
  }

  /**
   * Utils
   */
  lockModal() {
    this.rootEl.classList.add(__LOCKED)
    this.locked = true
  }
  unlockModal() {
    this.rootEl.classList.remove(__LOCKED)
    this.locked = false
  }

  /**
   * Methods
   */
  switch(contentType) {
    let section = this.contentArr.find(e => e.dataset.signContent === contentType) || this.contentArr[0]
    let activeSection = this.contentArr.find((el) => {
      let displayProperty = window.getComputedStyle(el).display
      return displayProperty !== 'none'
    })
    if (!section) throw new Error(`Expected to find section with data-sign-content=${contentType}`)
    if (activeSection == section) return
    if (contentType == 'otp') {
      this.otpArr.forEach((el) => {
        el.value = ''
      })
    }

    this.activeContent = section
    this.lockModal()
    const currentHeight = this.adjustEl.offsetHeight
    this.adjustEl.style.opacity = 0
    this.adjustEl.style.height = `${currentHeight}px`
    setTimeout(() => {
      this.contentArr.forEach(e => e.style.display = 'none')
      section.style.display = 'flex'
      const newHeight = section.scrollHeight
      this.adjustEl.style.height = `${newHeight}px`

      setTimeout(() => {
        this.adjustEl.style.opacity = '1'
        this.unlockModal()
      }, 5)
      setTimeout(() => {
        this.adjustEl.style.height = 'auto'
      }, getTransitionTime(this.adjustEl));
    }, getTransitionTime(this.adjustEl));
  }
  toggle() {
    if (this.opened) {
      this.close()
    } else {
      this.open()
    }
  }
  open() {
    if (!this.opened) {
      if (window.menu) {
        if (window.menu.state) {
          window.menu.state = false
        }
      }
      const content = this.contentArr.find(e => e.dataset.signContent == 'sms') || this.contentArr[0]
      this.opened = true
      this.rootEl.style.display = 'block'
      this.adjustEl.style.height = 'auto'
      this.contentArr.forEach(e => e.style.display = 'none')
      content.style.display = 'flex'
      // content.querySelector('input').focus()
      lockScroll()
      const show = () => {
        this.backdrop.style.opacity = 1
        this.container.classList.remove(IS_HIDDEN)
      }
      setTimeout(show, 1)
    }
  }
  close() {
    if (this.opened) {
      this.opened = false
      this.backdrop.style.opacity = 0
      this.container.classList.add(IS_HIDDEN)
      unlockScroll()
      setTimeout(() => {
        this.rootEl.style.display = 'none'
      }, getTransitionTime(this.backdrop))
    }
  }
  startLoading() {
    if (this.loader && !this.locked) {
      this.unlockModal()
      this.loader.style.display = 'flex'
      setTimeout(() => { this.loader.style.opacity = '1' }, 10)
    }
  }
  stopLoading() {
    if (this.loader) {
      this.loader.style.opacity = '0'
      setTimeout(() => {
        this.loader.style.display = 'none'
        this.locked = false
      }, getTransitionTime(this.loader))
    }
  }

  /**
   * Bind Events
   */
  bindToggleVisiblity() {
    // Open
    for (const el of this.evtOpenArr) {
      el.addEventListener('click', (e) => {
        e.preventDefault()
        this.toggle()
      })
    }
    // Close
    for (const el of this.evtCloseArr) {
      el.addEventListener('click', (e) => {
        e.preventDefault()
        this.close()
      })
    }
    // Toggle
    for (const el of this.evtJsToggleSign) {
      el.addEventListener('click', (e) => {
        e.preventDefault()
        this.toggle()
        const contentName = el.dataset.signSwitch
        if (contentName) {
          this.switch(contentName)
        }
      })
    }
  }
  bindSwitchContent() {
    for (const el of this.evtSwitchContentArr) {
      el.addEventListener('click', (e) => {
        e.preventDefault()
        const contentName = el.dataset.signSwitch
        this.switch(contentName)
      })
    }
  }
  bindOTPInput() {
    const inputs = this.otpArr
    for (const input of inputs) {
      input.addEventListener('paste', (e) => {
        const data = e.clipboardData.getData('text');
        const value = data.split("");
        if (value.length === inputs.length) {
          inputs.forEach((input, index) => (input.value = value[index]));
        }
      })
      input.addEventListener('input', (e) => {
        const value = e.target.value
        if (value.length > 1) {
          e.target.value = value.replace(/./g, '')
        }
        if (value.match(/\D/g)) {
          e.target.value = ''
        }
        if (value.length > 0) {
          const nextInput = e.target.nextElementSibling
          const valueIsDigit = value.match(/\d/g)
          if (nextInput && valueIsDigit) {
            nextInput.focus()
          }
        }
      })
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Backspace') {
          e.target.value = ''
          const prevInput = e.target.previousElementSibling
          if (prevInput) {
            prevInput.focus()
          }
        }
        if (e.key === 'ArrowLeft') {
          const prevInput = e.target.previousElementSibling
          if (prevInput) {
            prevInput.focus()
          }
        } else if (e.key === 'ArrowRight') {
          const nextInput = e.target.nextElementSibling
          if (nextInput) {
            nextInput.focus()
          }
        }
      })
    }
  }
  bindTogglePassword() {
    for (const btn of this.evtTogglePassword) {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        const input = btn.parentNode.querySelector('input')
        if (input) {
          const type = input.getAttribute('type') === 'password' ? 'text' : 'password'
          const svgShow = btn.querySelector('.svg_pass_show')
          const svgHide = btn.querySelector('.svg_pass_hide')

          input.type = type
          if (svgShow && svgHide) {
            if (type === 'text') {
              svgShow.style.display = 'none'
              svgHide.style.display = 'inline'
            } else {
              svgShow.style.display = 'inline'
              svgHide.style.display = 'none'
            }
          }
        }
      })
    }
  }
  bindSubmit() {
    this.formsArr.forEach((form, index) => {
      form.addEventListener('submit', () => {
        if ($(form).parsley().isValid()) {
          this.startLoading()
        }
      })
    })
  }
  bindKeyPress() {
    document.addEventListener('keypress', (e) => {
      const isEnter = e.key === 'Enter' || e.keyCode === 13

      if (isEnter && this.opened) {
        e.preventDefault()
        const activeSection = this.getActiveContent
        if (activeSection) {
          activeSection.querySelector('.js-submit').click()
        }
      }
    })
  }

  /**
   * Initialize
   */
  initialSetup() {
    this.rootEl.style.display = 'none'
    this.close()
    this.switch('phone_register')
  }
  init() {
    if (this.rootEl) {
      this.bindToggleVisiblity()
      this.bindSwitchContent()
      this.bindOTPInput()
      this.bindTogglePassword()
      this.bindSubmit()
      this.initialSetup()
      this.bindKeyPress()
    }
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const modal = document.querySelector('.sign-modal')
  if (modal) {
    window.signModal = new SignModal(modal)
    window.signModal.init()
    initValidators()
  }
})

$(document).ready(function () {
  $('#btn_confirm_otp').on('click', function () {
    confirmLoginOtp();
  });
  $('#resend-otp-btn').on('click', function () {
    resendOtp();
  });
  $('#frm_login_otp').on('submit', function (e) {
    var phoneField = document.querySelector('#phone_input_Login');
    var iti = window.intlTelInputGlobals.getInstance(phoneField);
    e.preventDefault();
    var fullPhone = iti.getNumber();
    var countryCode = '+' + iti.getSelectedCountryData().dialCode;
    var phone = fullPhone.replace(countryCode, '');
    var btn = $(e.target).find(".js-loading-btn");
    $('#otp_phone').val(phone);
    $('#otp_country').val(countryCode);
    $.ajax({
      url: '/send-otp',
      type: 'POST',
      data: { country_code: countryCode, phone_number: phone },
      success: function (data) {
        var r = $.parseJSON(data);
        var MsgClass = (r.error) ? 'is-failed' : 'is-successful';
        showSignMessage(r.msg, MsgClass);
        if (!r.error) {
          $('.sign-modal__phone-span').html(fullPhone);
          window.signModal.switch('otp');
        }
      }

    });
  });
});

function confirmLoginOtp() {
  var otp = $('#otp_1').val() + $('#otp_2').val() + $('#otp_3').val() + $('#otp_4').val();
  var phone = $('#otp_phone').val();
  var countryCode = $('#otp_country').val();
  var btn = '#btn_confirm_otp';


  if (otp != '' && otp.length == 4) {
    window.signModal.startLoading();
    $.ajax({
      url: '/confirm-otp',
      type: 'POST',
      data: { country_code: countryCode, phone_number: phone, otp_code: otp },
      success: function (data) {
        var r = $.parseJSON(data);
        var MsgClass = (r.error) ? 'is-failed' : 'is-successful';
        window.signModal.stopLoading();
        showSignMessage(r.msg, MsgClass);
        if (!r.error) {
          window.location.reload();
        }
      }
    });
  } else {
    showSignMessage('Enter 4 digits OTP', 'is-failed');
  }
}

function resendOtp() {
  var phone = $('#otp_phone').val();
  var countryCode = $('#otp_country').val();
  var btn = '#resend-otp-btn';
  window.signModal.startLoading();
  $.ajax({
    url: '/resend-otp',
    type: 'POST',
    data: { country_code: countryCode, phone_number: phone },
    success: function (data) {
      var r = $.parseJSON(data);
      var MsgClass = (r.error) ? 'is-failed' : 'is-successful';
      window.signModal.stopLoading();
      showSignMessage(r.msg, MsgClass);
    }
  })
}
},{}],28:[function(require,module,exports){
const bookModal = {
  step: 1,
  apptData: {},

  root: document.querySelector('.book-sell'),
  backdrop: document.querySelector('.book-sell__backdrop'),
  container: document.querySelector('.book-sell__container'),

  evtNextStep: $('[data-evt="bookModalNext"]'),
  evtBackStep: $('[data-evt="bookModalBack"]'),
  evtToggle: $('[data-evt="toggleBookModal"]'),

  sectionDate: $('#bookSectionDate'),
  sectionPersonal: $('#bookSectionPersonal'),
  sectionConfirm: $('#bookSectionConfirm'),

  inputName: document.getElementById('bookFullName'),
  inputEmail: document.getElementById('bookEmail'),
  inputPhone: document.getElementById('bookPhone'),
  inputArr: [this.inputName, this.inputEmail, this.inputPhone],

  confirmName: document.getElementById('bookConfirmName'),
  confirmEmail: document.getElementById('bookConfirmEmail'),
  confirmPhone: document.getElementById('bookConfirmPhone'),
  confirmDate: document.getElementById('bookConfirmDate'),
  confirmTime: document.getElementById('bookConfirmTime'),

  init: function () {
    if (this.root !== null) {
      this.dateTime.init()
      this.attachEvents()
    }
  },

  close: function () {
    unlockScroll()
    this.container.style.transform = 'translateX(100%)'
    this.backdrop.style.opacity = 0
    setTimeout(() => {
      this.root.style.display = 'none'
    }, getTransitionTime(this.container));
  },
  open: function () {
    if (!$('.book-sell__date-box').length) { bookModal.dateTime.appendBoxes(bookModal.dateTime.getDates(true)) }
    lockScroll()
    this.root.style.display = 'block'
    setTimeout(() => {
      this.container.style.transform = 'translateX(0%)'
      this.backdrop.style.opacity = 1
    }, 1);
  },
  toggle: function () {
    if (window.getComputedStyle(this.root).getPropertyValue('display') !== 'none') {
      this.close()
    } else {
      this.open()
    }
  },
  attachEvents: function () {
    this.evtToggle.click(function () {
      bookModal.toggle()
    })
    this.evtNextStep.click(function () {
      switch (bookModal.step) {
        case 1:
          if (bookModal.apptData.date) {
            bookModal.step = 2
            bookModal.sectionDate.hide()
            bookModal.sectionPersonal.show()
            bookModal.observer()
          }
          break;
        case 2:
          if (bookModal.inputName.value && bookModal.inputEmail.value && bookModal.inputPhone.value) {
            bookModal.step = 3
            bookModal.sectionPersonal.hide()
            bookModal.sectionConfirm.show()
            bookModal.apptData.name = bookModal.inputName.value
            bookModal.apptData.email = bookModal.inputEmail.value
            bookModal.apptData.phone = bookModal.inputPhone.value
            bookModal.apptData.url = window.location.href;
            bookModal.observer()
          }
          break;
        case 3:
          bookModal.apptData.date_day = $('#bookConfirmDate').text();
          bookModal.apptData.time = $('#bookConfirmTime').text();
          //alert(JSON.stringify(bookModal.apptData)) // change later
          $.ajax({
            url: '/json/book-appointment',
            type: 'POST',
            data: { json: JSON.stringify(bookModal.apptData) },
            success: function (data) {
              bookModal.close()
              setTimeout(() => {
                bookModal.reset()
              }, getTransitionTime(bookModal.container));
            }
          });

          break;
      }
    })
    this.evtBackStep.click(function () {
      switch (bookModal.step) {
        case 1:
          bookModal.close()
          break;
        case 2:
          --bookModal.step
          bookModal.observer()
          bookModal.sectionPersonal.hide()
          bookModal.sectionDate.show()
          break;
        case 3:
          --bookModal.step
          bookModal.observer()
          bookModal.sectionConfirm.hide()
          bookModal.sectionPersonal.show()
          break;
      }
    })
    const attachInputObesrver = () => {
      let arr = [bookModal.inputName, bookModal.inputEmail, bookModal.inputPhone]
      arr.forEach((el) => { el.oninput = () => { bookModal.observer() } })
    }
    attachInputObesrver()
  },

  dateTime: {
    intervals: [[11, 0o0, 0o0], [13, 30, 0o0], [15, 30, 0o0], [16, 0o0, 0o0], [16, 30, 0o0]],
    daysPerView: 3,
    holder: document.getElementById('bookSellDates'),

    init: function () {
      this.attachEvents()
      this.appendBoxes(this.getDates(true))
    },
    renderHTML: (date) => {
      const weekday = date.toLocaleDateString('en-US', { weekday: 'long' }), day = date.getDate(), month = date.toLocaleDateString('en-US', { month: 'short' }), time = date.toLocaleTimeString('en-US', { hour: 'numeric', hour12: true, minute: 'numeric' })

      let ifPast = new Date() > date ? ' disabled' : ''
      let dayTime = date.getDay() == 6 ? 'Closed' : date.getDay() == 0 ? 'Closed' : time
      let isWeekend = date.getDay() == 6 ? ' is-closed' : date.getDay() == 0 ? ' is-closed' : ''

      return `
      <div class="book-sell__date-box${isWeekend}" data-time="${String(date)}"${ifPast}>
        <span>${weekday}, ${day}${getOrdinalTxt(day)} ${month}</span>
        <span>${dayTime}</span>
      </div>
      `
    },
    appendBoxes: function (arr) {
      arr.forEach((el) => this.holder.insertAdjacentHTML('beforeend', el))
    },
    getDates: function (isNext) {
      let daysArr = [], initial = 0
      let arr = [...document.querySelectorAll('.book-sell__date-box')]
      let initialDate

      if (arr.length == 0) {
        initialDate = new Date()
      } else {
        if (isNext == true) {
          initialDate = new Date(arr[arr.length - 1].getAttribute('data-time'))
        } else {
          initialDate = new Date(arr[0].getAttribute('data-time'))
        }
      }

      if (arr.length !== 0) {
        arr.forEach(el => el.remove());
        if (isNext == true) {
          initialDate.setDate(initialDate.getDate() + 1)
        } else { initialDate.setDate(initialDate.getDate() - 1) }
      }

      while (initial !== this.daysPerView) {
        let dayDate = new Date(initialDate)
        if (isNext == true) { daysArr.push(new Date(dayDate.setDate(initialDate.getDate() + initial))) } else {
          daysArr.push(new Date(dayDate.setDate(initialDate.getDate() - initial)))
        }
        ++initial
      }

      let ints = isNext == true ? this.intervals : this.intervals.slice().reverse()

      let htmlArr = daysArr.reduce((acc, date) => {
        ints.forEach((interval) => {
          let thisDate = new Date(date)
          thisDate.setHours(...interval)
          acc.push(this.renderHTML(thisDate))
        })
        return acc
      }, [])

      if (isNext == true) { return htmlArr } else { return htmlArr.reverse() }
    },
    attachEvents: function () {
      $('[data-switch-time]').click(function () {
        let attr = $(this).attr('data-switch-time')
        switch (attr) {
          case 'next':
            bookModal.dateTime.appendBoxes(bookModal.dateTime.getDates(true))
            break;
          case 'prev':
            if ([...document.querySelectorAll('.book-sell__date-box')][0])
              bookModal.dateTime.appendBoxes(bookModal.dateTime.getDates(false))
            break;
        }
      }),
        $(document).on('click', '.book-sell__date-box', function () {
          $(this).toggleClass(IS_ACTIVE).siblings().removeClass(IS_ACTIVE)
          bookModal.observer()
        })
    }
  },

  observer: function () {
    switch (this.step) {
      case 1:
        let activeDate = $('.book-sell__date-box').filter(`.${IS_ACTIVE}`)
        if (activeDate.length) {
          this.apptData.date = new Date(activeDate.attr('data-time'))
          this.evtNextStep.attr('disabled', false)
        } else {
          delete this.apptData.date
          this.evtNextStep.attr('disabled', true)
        }
        break;
      case 2:
        if (this.inputName.value && this.inputEmail.value && this.inputPhone.value && this.apptData.date) {
          this.evtNextStep.attr('disabled', false)
        } else {
          this.evtNextStep.attr('disabled', true)
        }
        break;
      case 3:
        this.confirmName.innerHTML = this.apptData.name
        this.confirmEmail.innerHTML = this.apptData.email
        this.confirmPhone.innerHTML = this.apptData.phone
        this.confirmDate.innerHTML = `${this.apptData.date.getDate()}${getOrdinalTxt(this.apptData.date.getDate())} ${this.apptData.date.toLocaleDateString('en-US', { month: 'long' })}`
        this.confirmTime.innerHTML = this.apptData.date.toLocaleTimeString('en-US', { hour: 'numeric', hour12: true, minute: 'numeric' })
        break;
    }
  },
  reset: function () {
    bookModal.step = 1
    let inputArr = [this.inputName, this.inputEmail, this.inputPhone]
    inputArr.forEach((el) => { el.value = '' })
    $('.book-sell__date-box').removeClass(IS_ACTIVE)
    bookModal.sectionConfirm.hide()
    bookModal.sectionPersonal.hide()
    bookModal.sectionDate.show()
    Object.values(bookModal.apptData).forEach((el) => {
      delete el
    })
    $('.book-sell__date-box').remove()
    bookModal.observer()
  }
}

module.exports = bookModal
},{}],29:[function(require,module,exports){
class CareModal {
  constructor() {
    this.elem = document.querySelector('.care-modal')
    this.openArr = [...document.querySelectorAll('[data-care-open]')]
    this.closeArr = [...document.querySelectorAll('[data-care-close]')]
    this.contentArr = [...document.querySelectorAll('[data-care-content]')]
    this.activeSection = undefined
    this.opened = false
    this.init()
  }
  init() {
    this.bindEvents()
    this.setSoapOverlay()
  }

  // Utils
  reset() {
    this.contentArr.forEach(e => e.style.display = 'none')
    this.contentArr[0].style.display = 'block'
  }

  // Events
  bindEvents() {
    // Open
    for (const elem of this.openArr) {
      elem.addEventListener('click', () => {
        this.switchContent(elem.dataset.careOpen)
        this.show()
      })
    }
    // Hide
    for (const elem of this.closeArr) {
      elem.addEventListener('click', () => {
        this.hide()
      })
    }
    document.addEventListener('click', (e) => {
      const target = e.target
      if (this.opened && !target.closest('.care-modal') && !target.closest('[data-care-open]')) {
        this.hide()
      }
    })
  }

  // Toggle view
  hide() {
    if (window.careBackdrop) {
      window.careBackdrop.hide(true)
    }

    this.opened = false
    unlockScroll()
    this.elem.classList.remove(__VISIBLE)
    setTimeout(() => {
      this.elem.style.display = 'none'
      this.reset()
    }, getTransitionTime(this.elem));
  }
  show() {

    window.careBackdrop = new window.Backdrop({
      half: true,
      callback: () => {
        this.hide()
      }
    })

    this.opened = true
    lockScroll()
    this.elem.style.display = 'block'

    if (this.activeSection) {
      const body = this.activeSection.querySelector('.care-modal__body')
      if (body) {
        body.scrollTop = 0
      }
    }

    requestAnimationFrame(() => {
      this.elem.classList.add(__VISIBLE)
    })
  }
  switchContent(type) {
    const sectionToShow = this.contentArr.find(e => e.dataset.careContent === type) || this.contentArr[0]
    this.activeSection = sectionToShow

    this.contentArr.forEach(e => e.style.display = 'none')
    sectionToShow.style.display = 'block'
  }

  // Animation Background
  setSoapOverlay() {
    const isMobile = () => {
      return window.innerWidth < 992
    }

    var canvas = document.querySelector('#soap_overlay');
    var ctx = canvas.getContext('2d');
    var bubbles = [];
    var bubbleCount = isMobile() ? 20 : 35;
    var bubbleSpeed = isMobile() ? 1.6 : 2.2;
    var popLines = 6;
    var popDistance = 10;
    var strokeColor = '#fffffff8';

    // Переменные для размеров пузырьков
    var minBubbleSize = 4; // Минимальный размер пузырька
    var maxBubbleSize = isMobile() ? 28 : 46; // Максимальный размер пузырька
    var randomBubbleSize = true; // true для случайных размеров, false для фиксированного размера

    // Переменные для контроля прозрачности пузырьков (от 0 до 1)
    var bubbleOpacity = 1;    // Максимальная прозрачность пузырьков
    var minimalOpacity = 1;   // Минимальная прозрачность пузырьков
    var randomOpacity = false;   // true для случайной прозрачности, false для фиксированной

    // Переменная для процента пузырьков, которые будут лопаться сами по себе
    var popPercentage = 98; // Процент пузырьков, которые будут лопаться (от 0 до 100)

    // Переменная для управления плавным исчезновением пузырьков
    var fadeOut = true; // true для включения эффекта плавного исчезновения, false для отключения

    // Функция для установки размеров canvas
    function setCanvasSize() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }

    // Устанавливаем размеры canvas при загрузке страницы
    setCanvasSize();

    // --------------
    // Цикл анимации
    // --------------

    function animate() {

      // Очистка Canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Рисуем пузырьки
      ctx.beginPath();
      for (var i = 0; i < bubbles.length; i++) {
        bubbles[i].position.x = Math.sin(bubbles[i].count / bubbles[i].distanceBetweenWaves) * 50 + bubbles[i].xOff;
        bubbles[i].position.y = bubbles[i].count;
        bubbles[i].render();

        if (bubbles[i].count < 0 - bubbles[i].radius) {
          bubbles[i].count = canvas.height + bubbles[i].yOff;
          bubbles[i].resetProperties();
        } else {
          bubbles[i].count -= bubbleSpeed;
        }

        // Логика автономного лопания пузырька
        if (!bubbles[i].popping && bubbles[i].shouldPop()) {
          bubbles[i].initiatePop();
        }
      }

      window.requestAnimationFrame(animate);
    }

    window.requestAnimationFrame(animate);

    // ------------------
    // Конструктор пузырька
    // ------------------

    var createBubble = function () {
      this.position = { x: 0, y: 0 };
      this.radius = getBubbleRadius();
      this.xOff = Math.random() * canvas.width - this.radius;
      this.yOff = Math.random() * canvas.height;
      this.distanceBetweenWaves = 50 + Math.random() * 40;
      this.count = canvas.height + this.yOff;
      this.color = strokeColor;
      this.lines = [];
      this.popping = false;
      this.maxRotation = 140;
      this.rotation = Math.floor(Math.random() * (this.maxRotation * 2)) - this.maxRotation;
      this.rotationDirection = 'forward';
      this.opacity = getBubbleOpacity(); // Устанавливаем начальную прозрачность

      // Добавляем линии для анимации лопания
      for (var i = 0; i < popLines; i++) {
        var tempLine = new createLine();
        tempLine.bubble = this;
        tempLine.index = i;

        this.lines.push(tempLine);
      }

      // Флаг, указывающий, должен ли пузырек лопнуть
      this.willPop = Math.random() < popPercentage / 100;
      // Точка, в которой пузырек лопнет (случайная позиция по Y)
      this.popPoint = Math.random() * canvas.height;

      this.resetProperties = function () {
        this.radius = getBubbleRadius();
        this.xOff = Math.random() * canvas.width - this.radius;
        this.yOff = Math.random() * canvas.height;
        this.distanceBetweenWaves = 50 + Math.random() * 40;
        this.popping = false;
        this.willPop = Math.random() < popPercentage / 100;
        this.popPoint = Math.random() * canvas.height;
        this.opacity = getBubbleOpacity(); // Сбрасываем прозрачность

        // Сбрасываем состояния линий
        for (var i = 0; i < this.lines.length; i++) {
          this.lines[i].resetValues();
        }
      }

      // Проверяем, должен ли пузырек лопнуть в текущей позиции
      this.shouldPop = function () {
        return this.willPop && this.position.y <= this.popPoint;
      }

      // Инициализируем процесс лопания
      this.initiatePop = function () {
        this.popping = true;
        for (var a = 0; a < this.lines.length; a++) {
          this.lines[a].popping = true;
        }
      }

      // Рендеринг пузырька
      this.render = function () {
        if (this.rotationDirection === 'forward') {
          if (this.rotation < this.maxRotation) {
            this.rotation++;
          } else {
            this.rotationDirection = 'backward';
          }
        } else {
          if (this.rotation > -this.maxRotation) {
            this.rotation--;
          } else {
            this.rotationDirection = 'forward';
          }
        }

        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        ctx.rotate(this.rotation * Math.PI / 180);

        // Обновляем прозрачность, если включен эффект fadeOut
        if (fadeOut && !this.popping) {
          var distanceRemaining = this.position.y + this.radius;
          var totalDistance = canvas.height + this.radius;
          var fadeOpacity = this.opacity * (distanceRemaining / totalDistance);
          ctx.globalAlpha = fadeOpacity < 0 ? 0 : fadeOpacity; // Обеспечиваем, что прозрачность не отрицательная
        } else {
          ctx.globalAlpha = this.opacity;
        }

        if (!this.popping) {
          // Рисуем внешний контур пузырька
          ctx.beginPath();
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 1;
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2, false);
          ctx.stroke();

          // Рисуем блик
          ctx.beginPath();
          var gradient = ctx.createRadialGradient(-this.radius / 3, -this.radius / 3, 0, -this.radius / 3, -this.radius / 3, this.radius);
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
          gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = gradient;
          ctx.arc(-this.radius / 3, -this.radius / 3, this.radius, 0, Math.PI * 2, false);
          ctx.fill();
        }

        ctx.restore();
        ctx.globalAlpha = 1; // Сбрасываем прозрачность для других элементов

        // Рисуем линии при лопании
        for (var a = 0; a < this.lines.length; a++) {
          if (this.lines[a].popping) {
            if (this.lines[a].lineLength < popDistance && !this.lines[a].inversePop) {
              this.lines[a].popDistance += 0.06;
            } else {
              if (this.lines[a].popDistance >= 0) {
                this.lines[a].inversePop = true;
                this.lines[a].popDistanceReturn += 1;
                this.lines[a].popDistance -= 0.03;
              } else {
                this.lines[a].resetValues();
                this.resetProperties();
                // Перезапускаем пузырек после лопания
                this.count = canvas.height + this.yOff;
              }
            }

            this.lines[a].updateValues();
            this.lines[a].render();
          }
        }
      }
    }

    // Функция для определения радиуса пузырька
    function getBubbleRadius() {
      if (randomBubbleSize) {
        // Случайный размер между минимальным и максимальным
        return minBubbleSize + Math.random() * (maxBubbleSize - minBubbleSize);
      } else {
        // Фиксированный размер (среднее значение между минимальным и максимальным)
        return (minBubbleSize + maxBubbleSize) / 2;
      }
    }

    // Функция для определения прозрачности пузырька
    function getBubbleOpacity() {
      if (randomOpacity) {
        // Случайная прозрачность между минимальной и максимальной
        return minimalOpacity + Math.random() * (bubbleOpacity - minimalOpacity);
      } else {
        // Фиксированная прозрачность
        return bubbleOpacity;
      }
    }

    // ----------------
    // Создаем пузырьки
    // ----------------

    for (var i = 0; i < bubbleCount; i++) {
      var tempBubble = new createBubble();

      bubbles.push(tempBubble);
    }

    // ----------------
    // Конструктор линии
    // ----------------

    function createLine() {
      this.lineLength = 0;
      this.popDistance = 0;
      this.popDistanceReturn = 0;
      this.inversePop = false;
      this.popping = false;

      this.resetValues = function () {
        this.lineLength = 0;
        this.popDistance = 0;
        this.popDistanceReturn = 0;
        this.inversePop = false;
        this.popping = false;

        this.updateValues();
      }

      this.updateValues = function () {
        this.x = this.bubble.position.x + (this.bubble.radius + this.popDistanceReturn) * Math.cos(2 * Math.PI * this.index / this.bubble.lines.length);
        this.y = this.bubble.position.y + (this.bubble.radius + this.popDistanceReturn) * Math.sin(2 * Math.PI * this.index / this.bubble.lines.length);
        this.lineLength = this.bubble.radius * this.popDistance;
        this.endX = this.lineLength;
        this.endY = this.lineLength;
      }

      this.render = function () {
        this.updateValues();

        ctx.beginPath();
        ctx.strokeStyle = this.bubble.color;
        ctx.lineWidth = 2;
        ctx.moveTo(this.x, this.y);
        if (this.x < this.bubble.position.x) {
          this.endX = this.lineLength * -1;
        }
        if (this.y < this.bubble.position.y) {
          this.endY = this.lineLength * -1;
        }
        if (this.y === this.bubble.position.y) {
          this.endY = 0;
        }
        if (this.x === this.bubble.position.x) {
          this.endX = 0;
        }
        ctx.lineTo(this.x + this.endX, this.y + this.endY);
        ctx.stroke();
      };
    }

    // ---------------
    // Обработчики событий
    // ---------------

    // Функция для обновления размеров canvas при изменении размера окна
    window.addEventListener('resize', function () {
      setCanvasSize();
    });
  }
}

module.exports = CareModal
},{}],30:[function(require,module,exports){
const cartModal = new Object({
  init: function () {
    this.renderDOM()
    this.bindToggle()
  },
  renderDOM: function () {
    this._ = $(".cart-modal");
    this.backdrop = this._.find(".cart-modal__backdrop");
    this.container = this._.find(".cart-modal__container");
    this.evtToggle = getEvtDOM("toggleCart");
  },
  bindToggle: function () {
    $(document).on('click', '[data-evt="toggleCart"]', function () {
      let el = $(".cart-modal")
      if (el.length) {
        let container = $(".cart-modal__container"),
          backdrop = $(".cart-modal__backdrop")
        if (elemDisplayed(el)) {
          unlockScroll();
          Object.assign(backdrop[0].style, { opacity: 0 });
          Object.assign(container[0].style, { transform: "translateX(100%)" });
          setTimeout(() => {
            el.hide();
          }, getTransitionTime(container));
        } else {
          lockScroll();
          el.show();
          setTimeout(() => {
            Object.assign(backdrop[0].style, { opacity: 1 });
            Object.assign(container[0].style, { transform: "translateX(0%)" });
          }, 1);
        }
      }
    })
  },
  toggle: function () {
    let el = cartModal._;
    if (el.length) {
      if (elemDisplayed(el)) {
        cartModal.close();
      } else {
        cartModal.open();
      }
    }
  },
  open: function () {
    lockScroll();
    this._.show();
    setTimeout(() => {
      Object.assign(this.backdrop[0].style, { opacity: 1 });
      Object.assign(this.container[0].style, { transform: "translateX(0%)" });
    }, 1);
  },
  close: function () {
    unlockScroll();
    Object.assign(this.backdrop[0].style, { opacity: 0 });
    Object.assign(this.container[0].style, { transform: "translateX(100%)" });
    setTimeout(() => {
      this._.hide();
    }, getTransitionTime(cartModal.container));
  },
})

module.exports = cartModal
},{}],31:[function(require,module,exports){
const currencyModal = new Object({
  init: function () {
    this.renderDOM();
    this.bindEvents();
  },
  renderDOM: function () {
    this._ = $(".cur-modal");
    this.backdrop = this._.find(".cur-modal__backdrop");
    this.container = this._.find(".cur-modal__container");
    this.evtToggle = getEvtDOM("toggleCurrency");
    this.input = this._.find("input");
  },
  bindEvents: function () {
    if (currencyModal.evtToggle.length) {
      $.each(currencyModal.evtToggle, (i) => {
        currencyModal.evtToggle[i].onclick = () => {
          currencyModal.toggle();
        };
      });
    }

    if (currencyModal.input.length) {
      currencyModal.input.on("keyup", function () {
        currencyModal.intraSearch($(this));
      });
    }
  },
  toggle: function () {
    this.input.val("").trigger("keyup");
    let modal = currencyModal._;
    if (modal.length) {
      if (elemDisplayed(modal)) {
        currencyModal.close();
      } else {
        currencyModal.open();
      }
    }
  },
  open: function () {
    lockScroll();
    this._.show();
    setTimeout(() => {
      this.backdrop.css({ opacity: 1 });
      this.container.css({ transform: "translateX(0%)" });
    }, 1);
  },
  close: function () {
    unlockScroll();
    this.backdrop.css({ opacity: 0 });
    this.container.css({ transform: "translateX(100%)" });
    setTimeout(() => {
      this._.hide();
    }, getTransitionTime(currencyModal.backdrop));
  },
  intraSearch: function (input) {
    let val = input.val().toLowerCase(),
      arr = [...$(".cur-item")];
    $.each(arr, function (index) {
      let txt = $(arr[index]).find(".cur-item__name").text().toLowerCase();
      if (~txt.indexOf(val)) {
        $(arr[index]).show();
      } else {
        $(arr[index]).hide();
      }
    });
  },
})

module.exports = currencyModal
},{}],32:[function(require,module,exports){
const mailModal = new Object({
  init: function () {
    this.renderDOM()
    if (this.modal.length) {
      this.bindEvents()
    }
  },
  renderDOM: function () {
    this.modal = $('.mail-modal')
    this.backdrop = $('.mail-modal__backdrop')
    this.container = $('.mail-modal__container')
    this.evtClose = $('[data-mail-modal="close"]')
  },
  bindEvents: function () {
    this.evtClose.on('click', function () { mailModal.close() })
  },
  open: function () {
    lockScroll()
    this.modal.show()
    this.modal.find('input').focus()
    setTimeout(() => {
      this.modal.addClass(__ACTIVE)
    }, 5);
  },
  close: function () {
    unlockScroll()
    this.modal.removeClass(__ACTIVE)
    setTimeout(() => {
      this.modal.hide()
    }, getTransitionTime(this.container));
  }
})

module.exports = mailModal
},{}],33:[function(require,module,exports){
class Menu {
  constructor(rootSelector = '.menu') {
    this._state = false
    this.overState = false
    this.rootEl = document.querySelector(rootSelector)

    if (!this.rootEl) {
      return
    }

    this.contentList = this.rootEl.querySelector('.menu__content-list')
    this.overList = this.rootEl.querySelector('.menu__over-list')
    this.subListArr = [...this.rootEl.querySelectorAll('[data-menu-list]')]
    this.activeListName = this.rootEl.querySelector('#activeListName')

    this.init()
  }

  get state() {
    return this._state
  }

  set state(value) {
    this._state = value
    if (this._state) {
      this.open(true)
    } else {
      this.close(true)
    }
  }

  open(fromSetter = false) {
    if (!fromSetter) {
      this._state = true
    }

    this.rootEl.style.display = 'block'
    setTimeout(() => {
      lockScroll()
      this.rootEl.classList.add(__ACTIVE)
      window.menuBackdrop = new Backdrop({
        half: true,
        callback: () => { this.close() }
      })
    }, 5);
  }

  close(fromSetter = false) {
    if (!fromSetter) {
      this._state = false
    }

    if (window.menuBackdrop) {
      window.menuBackdrop.hide(true)
    }

    unlockScroll()
    this.rootEl.classList.remove(__ACTIVE)

    if (this.overState) {
      this.closeOverList()
    }

    setTimeout(() => {
      this.contentList.scrollTop = 0
      this.rootEl.style.display = 'none'
    }, getTransitionTime(this.rootEl));
  }

  toggle() {
    this.state = !this.state
  }

  openOverList() {
    if (!this.overState) {
      this.overState = true
      this.overList.style.display = 'block'
      this.overList.scrollTop = 0
      this.rootEl.classList.add('--over-active')
      setTimeout(() => {
        this.contentList.classList.add(__HIDDEN)
        this.overList.classList.add(__VISIBLE)
      }, 5);
    }
  }

  closeOverList() {
    if (this.overState) {
      this.overState = false
      this.contentList.classList.remove(__HIDDEN)
      this.overList.classList.remove(__VISIBLE)
      this.rootEl.classList.remove('--over-active')
      this.contentList.scrollTop = 0

      setTimeout(() => {
        this.overList.style.display = 'none'
      }, getTransitionTime(this.overList));

      if (this.activeListName) {
        this.activeListName.innerHTML = this.activeListName.dataset.title || 'Explore Icebox'
      }
    }
  }

  goToNavList(name, item = undefined) {
    if (name) {
      const list = this.subListArr.find(el => el.dataset.menuList === name)
      if (!list) throw new Error('data-menu-list not found')

      this.subListArr.forEach((el) => {
        if (el !== list) {
          el.style.display = 'none'
        } else {
          el.style.display = 'block'
        }
      })
      if (this.activeListName && item) {
        this.activeListName.innerHTML = item.querySelectorAll('span')[0].innerHTML
      }
      this.openOverList()
    }
  }

  reset() {
    this.state = false
    this.overState = false
    this.contentList.scrolTop = 0
    this.overList.scrollTop = 0
  }

  // Events
  bindEvents() {
    const evtNavArr = [...document.querySelectorAll('[data-menu-nav]')]
    evtNavArr.forEach((item) => {
      item.onclick = () => {
        if (this.state && !this.overState) {
          const listName = item.dataset.menuNav
          this.goToNavList(listName, item)
        }
      }
    })

    const evtToggleMenuArr = [...document.querySelectorAll('[data-evt="toggleMenu"]')]
    evtToggleMenuArr.forEach((el) => {
      el.addEventListener('click', () => {
        this.open()
      })
    })
  }

  init() {
    this.reset()
    this.bindEvents()
  }
}

module.exports = Menu
},{}],34:[function(require,module,exports){
class NoticeModal {
  constructor() {
    this.init();
    this.elem = null;
    this.text = null;

    this.show = this.show.bind(this);
    this.hide = this.hide.bind(this);
    this._bindPullDown = this._bindPullDown.bind(this);
    this._unbindPullDown = this._unbindPullDown.bind(this);
  }

  init() {
    this._bindDocumentClick();
  }

  // Events
  _bindDocumentClick() {
    document.addEventListener('click', (e) => {
      const elem = e.target.closest('[data-notice]');
      if (!elem) return;

      const text = elem.getAttribute('data-notice');
      if (!text) return;

      this.create(text);
      this.show();
    });
  }

  // Bind Pull-Down Gesture
  _bindPullDown() {
    if (!this.elem) return;

    let startY = 0;
    let currentY = 0;
    let isDragging = false;
    let isMoving = false;

    const modal = this.elem;
    const transition = window.getComputedStyle(modal).transition;

    // Touch Start
    const onTouchStart = (e) => {
      const touch = e.touches[0];
      startY = touch.clientY;
      isDragging = true;
      isMoving = false;
      modal.style.transition = 'none';
    };

    // Touch Move
    const onTouchMove = (e) => {
      if (!isDragging) return;

      currentY = e.touches[0].clientY;
      let diffY = currentY - startY;

      if (diffY > 0) {
        isMoving = true;
        e.preventDefault()
        modal.style.transform = `translateY(${diffY}px)`;
      }
    };

    // Touch End
    const onTouchEnd = () => {
      if (!isDragging) return;
      isDragging = false;

      if (isMoving) {
        let diffY = currentY - startY;
        let hideOffset = modal.offsetHeight * 0.2;
        modal.style.transition = 'transform 0.3s ease';

        if (diffY > hideOffset) {
          modal.style.transform = `translateY(100%)`
          this.hide()
        } else {
          modal.style.transform = `translateY(0%)`;
          modal.removeAttribute('style');
        }
      }
    };

    this._pullDownHandlers = {
      onTouchStart,
      onTouchMove,
      onTouchEnd,
    };

    modal.addEventListener('touchstart', onTouchStart, { passive: false });
    modal.addEventListener('touchmove', onTouchMove, { passive: false });
    modal.addEventListener('touchend', onTouchEnd);
  }

  // Unbind Pull-Down Gesture
  _unbindPullDown() {
    if (!this.elem || !this._pullDownHandlers) return;

    const { onTouchStart, onTouchMove, onTouchEnd } = this._pullDownHandlers;

    this.elem.removeEventListener('touchstart', onTouchStart);
    this.elem.removeEventListener('touchmove', onTouchMove);
    this.elem.removeEventListener('touchend', onTouchEnd);

    this._pullDownHandlers = null;
  }

  // Show & Hide
  show() {
    if (this.elem) {
      lockScroll()

      this.elem.style.display = 'flex';

      requestAnimationFrame(() => {
        this.elem.classList.add(__VISIBLE);
        this._bindPullDown()

        window.noticeBackdrop = new window.Backdrop({
          half: true,
          callback: this.hide
        });
      });
    }
  }

  hide() {
    if (this.elem) {
      unlockScroll()

      this.elem.classList.remove(__VISIBLE);
      const backdrop = window.noticeBackdrop;

      if (backdrop) {
        backdrop.hide(true);
      }

      setTimeout(() => {
        if (this.elem) {
          this.elem.style.display = 'none';
          this.destroy()
        }
        this._unbindPullDown()
      }, getTransitionTime(this.elem))
    }
  }

  // Create & Destroy
  create(text = "Something went wrong...") {
    const modal = document.createElement('div');
    modal.className = 'notice-modal';
    modal.innerHTML = `<div class="notice-modal__typo">${text}</div>`;

    this.elem = modal;
    this.text = text;
    document.body.append(modal);
  }

  destroy() {
    if (this.elem) {
      this.elem.remove();
      this.elem = null;
      this.text = null;
    }
  }
}

module.exports = NoticeModal;

},{}],35:[function(require,module,exports){
const quizModal = {
  currentStep: undefined,
  isFinished: undefined,
  pollLength: undefined,
  maxStep: undefined,
  isInitialized: undefined,
  init: function () {
    this.renderDOM()
    this.setInitial()
    this.bindEvents()
  },
  renderDOM: function () {
    this.modal = $('.quiz-modal')
    this.container = this.modal.find('.quiz-container')
    this.backdrop = this.modal.find('.quiz-modal__backdrop')
    this.heightContainer = this.modal.find('.quiz-container-height')
    this.poll = this.modal.find('.quiz-poll')
    this.pollArr = [...this.poll]
    this.answers = this.modal.find('.quiz-answer')
    this.fullStepText = this.modal.find('.quiz-step-text')
    this.currentStepText = this.modal.find('.quiz-current-step')
    this.maxStepText = this.modal.find('.quiz-max-step')
    this.bar = this.modal.find('.quiz-bar')
    this.evtGoNext = $('[data-evt="quizGoNext"]')
    this.evtOpen = $('[data-evt="openQuizModal"]')
    this.closeBtn = $('[data-evt="closeQuizModal"]')
  },
  bindEvents: function () {
    this.evtGoNext.click(function () {
      quizModal.goNextStep()
    })
    this.closeBtn.click(function () {
      quizModal.close()
    })
    this.evtOpen.click(function () {
      quizModal.open()
    })
  },
  setInitial: function () {
    this.currentStep = 1, this.isFinished = false, this.pollLength = this.pollArr.length, this.maxStep = this.pollLength
    if (this.pollLength !== 0 && this.pollLength !== undefined && this.isInitialized !== true) {
      this.isInitialized = true
      quizModal.currentStepText.html(quizModal.currentStep)
      quizModal.maxStepText.html(quizModal.maxStep)
      this.modal.find('input[type="radio"]').prop('checked', false); this.evtGoNext.html('Next')
      // Object.assign(this.heightContainer[0].style, { height: `${this.getObjectScrollHeight(this.pollArr[0])}` })
      Object.assign(this.bar[0].style, { width: `${(100 / this.pollLength)}%` })
    } else {
      return false
    }
  },
  // utils
  getObjectScrollHeight: function (obj) {
    if (obj instanceof jQuery) {
      return `${obj[0].scrollHeight}px`
    } else {
      return `${obj.scrollHeight}px`
    }
  },
  noEmptyAnswers: function () {
    let parent = $(quizModal.pollArr[(quizModal.currentStep - 1)]),
      checkedRadio = parent.find('input[type="radio"]:checked'),
      answers = parent.find(quizModal.answers)
    if (checkedRadio.length == 0) {
      answers.css({ opacity: '0.3' }); setTimeout(() => { answers.css({ opacity: 1 }) }, 375);
    } else {
      return true
    }
  },
  goNextStep() {
    if (quizModal.currentStep !== quizModal.maxStep) {
      if (quizModal.noEmptyAnswers()) {
        Object.assign(quizModal.pollArr[(quizModal.currentStep - 1)].style, { opacity: 0 })
        Object.assign(quizModal.bar[0].style, { width: `${(100 / quizModal.pollLength) * (quizModal.currentStep + 1)}%` })
        $.each(quizModal.pollArr, function (i) {
          Object.assign(quizModal.pollArr[i].style, { transform: `translateX(-${(quizModal.currentStep * 100)}%)` })
        })
        Object.assign(quizModal.heightContainer[0].style, { height: `${quizModal.pollArr[quizModal.currentStep].scrollHeight}px` })
        ++quizModal.currentStep
        quizModal.currentStepText.html(quizModal.currentStep)
        if (quizModal.currentStep == quizModal.maxStep) {
          quizModal.evtGoNext.html('Show Results')
        }
      }
    } else {
      if (quizModal.noEmptyAnswers()) {
        Object.assign(quizModal.heightContainer[0].style, { height: '0px' })
        Object.assign(quizModal.bar[0].style, { width: '5%' })
        $.each(quizModal.pollArr, function (i) {
          Object.assign(quizModal.pollArr[i].style, { transform: `translateX(-${(quizModal.currentStep * 100)}%)` })
        })
        Object.assign(quizModal.pollArr[(quizModal.currentStep - 1)].style, { opacity: 0 })
        quizModal.evtGoNext.prop('disabled', true)
        quizModal.fullStepText.text('FINDING WATCHES')
        $('.quiz-close-btn').remove()
        quizModal.isFinished = true
        setTimeout(() => {
          quizModal.bar.animate({ width: '100%' }, 3000, function () { quizModal.close() })
        }, 600);
      }
    }
  },
  open: function () {
    lockScroll()
    quizModal.modal.show()
    Object.assign(this.heightContainer[0].style, { height: `${this.getObjectScrollHeight(this.pollArr[quizModal.currentStep - 1])}` })
    setTimeout(() => {
      Object.assign(quizModal.backdrop[0].style, { opacity: 1 })
      Object.assign(quizModal.container[0].style, { transform: 'translateY(0px)', opacity: 1 })
    }, 1);
  },
  close: function () {
    unlockScroll()
    let timeToHide = (parseFloat(window.getComputedStyle(quizModal.backdrop[0]).transitionDuration) * 1000)
    Object.assign(quizModal.backdrop[0].style, { opacity: 0 })
    Object.assign(quizModal.container[0].style, { transform: 'translateY(32px)', opacity: 0 })
    setTimeout(() => {
      quizModal.modal.hide()
    }, timeToHide);
  }
}

module.exports = quizModal
},{}],36:[function(require,module,exports){
const salesModal = {
  init: function () {
    this.renderDOM()
    if (this.modal.length) {
      this.bindEvents()
    }
  },
  renderDOM: function () {
    this.modal = $('.sale-history-modal')
    this.container = $('.sale-history__container')
    this.evtClose = $('[data-evt="closeSalesModal"]')
  },
  bindEvents: function () {
    this.evtClose.click(function () {
      salesModal.close()
    })
  },
  open: function () {
    window.addEventListener('keydown', function (evt) {
      if (evt.key === 'Escape') {
        evt.preventDefault()
        salesModal.close()
      }
    }, { once: true })
    lockScroll()
    this.modal.show()
    setTimeout(() => {
      this.modal.css({ 'background-color': "rgba(13, 16, 26, .7)" })
      this.container.css({ 'transform': 'translateX(0%)' })
    }, 1);
  },
  close: function () {
    unlockScroll()
    this.modal.css({ 'background-color': "rgba(13, 16, 26, 0)" })
    this.container.css({ 'transform': 'translateX(100%)' })
    setTimeout(() => {
      this.modal.hide()
    }, getTransitionTime(this.modal));
  }
}

module.exports = salesModal
},{}],37:[function(require,module,exports){
const account = new Object({
  init: function () {
    Object.values(this.attachEvents).forEach((fn) => {
      if (fn !== undefined && typeof fn == 'function') fn();
    })
  },
  attachEvents: {
    editAddress: function () {
      const evtEditAddress = Array.from($('[data-edit="address"]'))
      for (let i = 0; i < evtEditAddress.length; i++) {
        const el = evtEditAddress[i];

        $(el).click(function () {
          let details = $(this).closest('.profile-card').find('.profile-card__details'),
            form = details.filter('.form')
          if (elemDisplayed(form)) {
            details.hide().not(form).show()
          } else {
            details.show().not(form).hide()
          }
        })

      }
    },
    toggleInvoiceHeight: function () {
      const invoiceArr = [...document.querySelectorAll('.order__invoice')]
      for (const invoice of invoiceArr) {
        const header = invoice.querySelector('.order__invoice-header')
        const body = invoice.querySelector('.order__invoice-body')

        header.onclick = () => {
          const toClose = invoice.classList.contains(__ACTIVE)
          if (toClose) {
            invoice.classList.remove(__ACTIVE)
            body.style.height = `80px`
          } else {
            invoice.classList.add(__ACTIVE)
            const scrollHeight = body.scrollHeight
            body.style.height = `${scrollHeight}px`
          }
        }
      }
    }
  }
})

module.exports = account
},{}],38:[function(require,module,exports){
const blogPage = {
  init: function () {
    Object.values(this.initFn).forEach((fn) => {
      if (typeof fn === 'function') {
        try { fn() }
        catch { console.log('blog JS ERR') }
      }
    })
  },
  initFn: {
    attachCommentSubmit: () => {
      const commentArea = document.querySelector('[data-article="commentArea"]')
      const commentSubmit = document.querySelector('[data-article="commentSubmit"]')
      const holder = document.querySelector('.article__comments-wrap')

      if (commentArea !== null && commentSubmit !== null) {
        const submit = () => {
          const
            val = commentArea.value
          if (val.length !== 0) {
            const
              user = 'Guets',
              date = new Date().toLocaleDateString('en-us', { year: "numeric", month: "short", day: "numeric" }),
              html = `
              <div class="article-comment"><span>${user}</span><span>${val}</span><span>${date}</span></div>
              `

            holder.insertAdjacentHTML("beforeend", html)
            commentArea.value = ''
          }
        }

        commentSubmit.onclick = () => {
          submit()
        }

        commentArea.onkeydown = (e) => {
          const isEnter = e.key === 'Enter' || e.keyCode === 13
          if (isEnter) {
            e.preventDefault()
            submit()
          }
        }
      }
    },
    createProgressBar: () => {
      const readContent = document.querySelector('.article__read-content')
      if (!readContent) return
      let y = 0
      let fullHeight = (readContent.getBoundingClientRect().bottom + 120) - (window.innerHeight * 0.7)
      const calculatePercentage = (number, total) => {
        return (number / total) * 100
      }
      const setElementWidthPercent = (el, percent) => {
        el.style.width = `${percent}%`
      }

      const
        bar = document.createElement('div'),
        progress = document.createElement('div')

      bar.className = 'blog-progress'
      bar.appendChild(progress)

      document.body.appendChild(bar)

      window.onscroll = () => {
        y = window.scrollY
        let f = calculatePercentage(y, fullHeight)
        setElementWidthPercent(progress, f)
      }
    },
    setReadingTime: () => {
      const
        readContent = document.querySelector('.article__read-content'),
        timeEl = document.querySelector('.read-time')
      if (!readContent || !timeEl) return

      const
        wordsPerMinute = 200,
        textContent = readContent.textContent,
        wordCount = textContent.split(/\s/g).length,
        readingTime = Math.ceil(wordCount / wordsPerMinute)


      timeEl.textContent = `${readingTime} min reading`
    },
    attachScroll: () => {
      return
      const img = document.querySelector('.article-top-cover img')
      if (img !== null) {
        let max = img.offsetHeight + 100
        window.onscroll = () => {
          let y = window.scrollY
          if (max > y) {
            let f = 1 - (y * 100 / max * 0.01)
            img.style.marginTop = `-${y * 0.08}px`
            img.style.opacity = f
          }
        }
      }
    }
  }
}

module.exports = blogPage
},{}],39:[function(require,module,exports){
const formPage = new Object({
  uploadedImages: [],
  init: function () {
    if (document.querySelector('.main_formpage')) {
      this.bindEvents()
      // this.imgUpload()
      this.attachImagesUploader()
      this.attachWatchesUpload()
    }
  },
  bindEvents: function () {
    $('.formpage__upload-btn').click(function () {
      if ($('#image_upload').length) { $('#image_upload').trigger('click') }
    })
    // $('#formpage_form').on('submit', function (e) {
    //   e.preventDefault();
    //   formPage.submitAjax();
    // });
  },
  submitAjax: function () { },
  attachImagesUploader: () => {
    const uploadLabel = document.querySelector('#formpage_img-uploader'),
      uploadInput = document.querySelector('#image_upload'),
      imagesWrap = $('.formpage__images-thumbnails')

    // Setting drag&drop event
    if (uploadLabel !== null) {
      uploadLabel.ondragover = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.add(IS_ACTIVE)
      }
      uploadLabel.ondragleave = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.remove(IS_ACTIVE)
      }
      uploadLabel.ondrop = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.remove(IS_ACTIVE)
        $('#image_upload').prop('files', evt.dataTransfer.files);
        const files = [], items = [...evt.dataTransfer.items]
        items.forEach((item, i) => {
          if (item.kind === 'file') {
            files.push(item.getAsFile())
          }
        })
        if (files.length) {
          $('.formpage__images-thumbnails').empty()
        }
        processFiles([...files])
      }
    }

    // Setting manual files upload
    if (uploadInput !== null) {
      uploadInput.onchange = (evt) => {
        const files = [...evt.target.files]
        $('.formpage__images-thumbnails').empty()
        processFiles(files)
      }
    }

    function processFiles(files) {
      if (files.length) {
        files.forEach((file, i) => {
          if (!file.type.match('image.*')) { return }

          let getIndex = () => {
            return $('.formpage__upload').length + 1
          }

          let reader = new FileReader()
          reader.onload = function (e) {
            let html =
              `
               <div class="formpage__upload" data-img-id="${getIndex()}">
                 <div class="formpage__input-boxes">
                   <div>
                     <input value="1" name="visible_image_${i}" id="image_${i + 1}" type="checkbox" checked>
                     <label for="image_${getIndex()}"></label>
                   </div>
                 </div>
                   <div data-name="${file.name}" style="background-image: url(${e.target.result})" class="formpage__upload-bg">
                 </div>
               </div>
             `
            imagesWrap.append(html)
          }
          reader.readAsDataURL(file)
        })
      }
    }

    // Setting checkbox toggle on appended images
    $body.on('click', ".formpage__upload-bg", function () {
      lockScroll()
      let html =
        `
      <div class="formpage-zoom">
        <div data-evt="closeFormpageZoom"></div>
        <div data-block="formpageZoom"></div>
      </div>
      `
      $body.append(html)
      $('[data-block="formpageZoom"]').attr('style', $(this).attr('style'))
    });
    $body.on('click', '[data-evt="closeFormpageZoom"]', function () {
      unlockScroll()
      $('.formpage-zoom').remove()
    })
  },
  attachWatchesUpload: () => {
    const container = document.querySelector('#watches_upload_label'),
      input = document.querySelector('#watches_upload')

    container.addEventListener("dragover", (e) => {
      e.preventDefault()
    }, false)

    container.addEventListener("dragenter", () => {
      container.classList.add(__ACTIVE)
    })

    container.addEventListener("dragleave", () => {
      container.classList.remove(__ACTIVE)
    })

    container.addEventListener("drop", (e) => {
      e.preventDefault()
      container.classList.remove(__ACTIVE)
      input.files = e.dataTransfer.files
    })
  }
})

module.exports = formPage
},{}],40:[function(require,module,exports){
class Homepage {
  constructor() {
    this.init()
  }

  // Splides
  initCategoriesSplide() {
    const categoriesElem = document.querySelector('.home-categories-splide')
    if (categoriesElem) {
      let slider = new Splide(categoriesElem, {
        type: "loop",
        perPage: 7,
        perMove: 2,
        autoplay: 0,
        gap: "8px",
        arrows: 1,
        pagination: 0,
        speed: 750,
        breakpoints: {
          1680: { perPage: 6, },
          1120: { perPage: 5, },
          767: { perPage: 3, perMove: 2 },
          600: { perPage: 2, gap: 6 }
        }
      })
      slider.mount()
    }
  }

  initSplide() {
    const splideArr = [...document.querySelectorAll('.home-splide')]
    if (splideArr.length) {
      splideArr.forEach((elem) => {
        let slider = new Splide(elem, {
          type: "loop",
          perPage: 5,
          perMove: 1,
          autoplay: 0,
          gap: "8px",
          arrows: 1,
          pagination: 0,
          speed: 750,
          breakpoints: {
            1980: {
              perPage: 5
            },
            1680: {
              perPage: 4
            },
            991: {
              perPage: 4,
              perMove: 1,
            },
            767: {
              grid: {
                rows: 2,
                cols: 3,
                gap: { row: "24px", col: "8px" }
              }
            },
            478: {
              grid: {
                rows: 2,
                cols: 2
              },
            },
          },
        })
        slider.mount(window.splide.Extensions);
      })
    }
  }

  init() {
    this.initCategoriesSplide()
    this.initSplide()
  }
}

module.exports = Homepage
},{}],41:[function(require,module,exports){
class JobApp {
  constructor(holder, settings = {}) {
    this.holder = holder
    this.filesHolder = this.holder.querySelector('#job_files_upload')
    this.sections = [...this.holder.querySelectorAll('[data-loan-section]')]
    this.content = this.holder.querySelector('.loan-case__content')
    this.scroller = this.holder.querySelector('.loan-scroller')
    this.footer = this.holder.querySelector('.loan-case__footer')
    this.btnGroup = this.holder.querySelector('.loan-case__btn-group')
    this.evtGo = [...this.holder.querySelectorAll('[data-loan-evt="go"]')]
    this.evtToggle = [...this.holder.querySelectorAll('[data-loan-evt="toggle"]')]
    this.evtSubmit = [...this.holder.querySelectorAll('[data-loan-evt="submit"]')]
    this.evtBack = [...this.holder.querySelectorAll('[data-loan-evt="back"]')]
    this.bar = this.holder.querySelector('.loan-bar')
    this.bar_progress = this.holder.querySelector('.loan-bar__progress')
    this.flow = this.holder.querySelector('.loan-flow')
    this.finish = this.holder.querySelector('.loan-finish')
    this.maxSteps = undefined
    this.currentStep = undefined
    this.stepsLeft = undefined
    this.endReached = undefined
    this.atStart = undefined
    this.sliding = false
    this.data = {}
    this.settings = {
      scrollSpeed: settings.scrollSpeed || 600,
      easing: settings.easing || 'cubic-bezier(.39, .575, .565, 1)',
    }
    if (this.holder) {
      this.init()
    }
  }

  /**
   * Utils
   */
  get getLeftSteps() {
    return this.steps - this.currentStep
  }
  get getActiveSection() {
    return this.sections[this.currentStep]
  }
  get getActiveInput() {
    const section = this.getActiveSection
    if (section && section.contains(document.activeElement)) {
      if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') {
        return document.activeElement
      }
    } else {
      return undefined
    }
  }
  get getLoaderHTML() {
    return `
                            <div>
                                <div>
                                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewBox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
                                        <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"></path>
                                        <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0C22.32,8.481,24.301,9.057,26.013,10.047z"></path>
                                        <animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatCount="indefinite"></animateTransform>
                                    </svg>
                                </div>
                            </div>
    `
  }
  createElem(tagName, options) {
    const { className, id, innerHTML, style, attributes, toAppend } = options
    const elem = document.createElement(tagName)
    if (className) elem.className = className;
    if (id) elem.id = id;
    if (innerHTML) elem.innerHTML = innerHTML;
    if (style) {
      for (const key in options.style) { elem.style[key] = options.style[key] }
    }
    if (attributes) {
      for (const key in options.attributes) { elem.setAttribute(key, options.attributes[key]) }
    }
    if (toAppend) {
      for (const child of toArray(toAppend)) { elem.appendChild(child) }
    }
    return elem
  }
  toArray(target) {
    return Array.isArray(target) ? target : [target]
  }
  loadingOn(timeToRemove) {
    if (this.holder.querySelector('.loan-case-loader')) return
    const loader = createElem('div', {
      className: 'loan-case-loader',
      innerHTML: this.getLoaderHTML
    })
    this.holder.appendChild(loader)
    setTimeout(() => {
      this.holder.classList.add(__LOCKED)
      if (timeToRemove) {
        setTimeout(() => {
          this.holder.classList.remove(__LOCKED)
          setTimeout(() => {
            loader.remove()
          }, 350);
        }, timeToRemove);
      }
    }, 1);
  }
  loadingOff() {
    this.holder.classList.remove(__LOCKED)
    const loader = this.holder.querySelector('.loan-case-loader')
    if (loader) {
      setTimeout(() => {
        loader.remove()
      }, 350);
    }
  }
  showInputError(input, text) {
    const err = document.querySelector('.loan-input-error') ? document.querySelector('.loan-input-error') : createElem('div', {
      className: 'loan-input-error',
      innerHTML: text
    })
    if (input) {
      input.classList.add(__INVALID)
    }
    this.footer.prepend(err)
  }
  clearErrors() {
    const activeSection = this.getActiveSection
    const inputs = [...activeSection.querySelectorAll('input'), ...activeSection.querySelectorAll('select')]
    inputs.forEach(input => input.classList.remove(__INVALID))
    const err = this.holder.querySelector('.loan-input-error')
    if (err) err.remove()
  }
  observeBar() {
    const prevSections = this.sections.slice(0, this.currentStep).length
    const progress = (prevSections + 1) / this.steps * 100
    this.bar_progress.style.width = `${progress}%`
  }
  clearAllFields() {
    const inputs = [...this.holder.querySelectorAll('input:not([type="checkbox"])')]
    const selects = [...this.holder.querySelectorAll('select')]
    const checkboxes = [...this.holder.querySelectorAll('input[type="checkbox"]')]
    const fullArr = [...inputs, ...selects, ...checkboxes]

    inputs.forEach(input => input.value = '')
    selects.forEach(select => select.selectedIndex = 0)
    checkboxes.forEach((checkbox) => { checkbox.checked = false })
    fullArr.forEach(elem => elem.dispatchEvent(new Event('change')))
  }

  /**
   * Main
   */
  save() {
    $('#job_application_form').submit();
  }
  finishMessage() {
    this.loadingOn(1000)
    setTimeout(() => {
      this.flow.style.opacity = 0
      let currentHeight = this.holder.offsetHeight
      this.holder.style.height = `${currentHeight}px`
      setTimeout(() => {
        this.finish.style.display = 'block'
        let scrollH = this.finish.scrollHeight
        this.holder.style.height = `${scrollH}px`
        setTimeout(() => {
          this.finish.style.opacity = 1
          window.scrollTo(0, 0)
          const confetti = new PageConfetti()
          confetti.push(false)
        }, 10);
      }, getTransitionTime(this.flow) + 10)
    }, 800);
  }
  slide(section) {
    section.style.display = 'flex'
    const height = section.scrollHeight
    const pxToTransform = this.sections.slice(0, this.currentStep).reduce((acc, el) => acc + el.scrollHeight, 0)
    this.content.style.height = `${height}px`
    this.scroller.style.transform = `translateY(-${pxToTransform}px)`
    this.sections.forEach(e => e.classList.remove(IS_ACTIVE))
    section.classList.add(IS_ACTIVE)
    setTimeout(() => {
      this.sliding = false
    }, getTransitionTime(this.scroller));
  }
  go(toStep) {
    if (this.holder.classList.contains(__LOCKED)) return
    const inputs = [...this.holder.querySelectorAll('input'), ...this.holder.querySelectorAll('select')]
    const step = toStep || this.currentStep || 0
    const nextStep = step + 1
    const nextSection = this.sections[nextStep]

    if (!this.sections[nextStep + 1]) {
      this.evtGo.forEach((btn) => {
        btn.innerHTML = 'Submit'
      })
    }

    if (nextSection) {
      this.sliding = true
      inputs.forEach(input => input.blur())
      this.loadingOn()
      setTimeout(() => {
        this.currentStep = nextStep
        this.slide(nextSection)
        this.loadingOff()
        this.observeBar()
      }, 600);
    } else {
      this.save()
      this.finishMessage()
    }
  }
  back(toStep) {
    if (this.holder.classList.contains(__LOCKED)) return
    this.clearErrors()
    const step = toStep || this.currentStep || 0
    const prevStep = step - 1
    const prevSection = this.sections[prevStep]
    if (prevSection) {
      this.evtGo.forEach((btn) => {
        btn.innerHTML = 'Next'
      })
      this.currentStep = prevStep
      this.slide(prevSection)
    } else {
      this.toggle()
    }
  }
  validate(section) {
    const requiredTextInputs = [...section.querySelectorAll('input[type="text"][required]:not(.--disabled'), ...section.querySelectorAll('input[type="email"][required]')]
    const emptyInputs = requiredTextInputs.filter(input => !input.value)
    const numberInputs = section.querySelectorAll('input[data-validate="number"]')
    const selectInputs = section.querySelectorAll('select[required]')
    const emailInputs = section.querySelectorAll('input[data-validate="email"]')
    const zipInputs = section.querySelectorAll('input[data-validate="zip_code"]')
    const fileInputs = section.querySelectorAll('input[required][type="file"]')
    const sectionID = section.dataset.loanSection

    if (requiredTextInputs.some(input => input.classList.contains(__INVALID))) return false

    if (selectInputs.length) {
      for (const select of selectInputs) {
        if (!select.value) {
          this.showInputError(select, 'Please select an option')
          return false
        }
      }
    }
    if (numberInputs.length) {
      const value = numberInputs[0].value
      const regex = /^\+\d{1}\s\(\d{3}\)\s\d{3}\-\d{4}$/
      if (!regex.test(value)) {
        this.showInputError(numberInputs[0], 'Please enter a valid phone number')
        return false
      }
    }
    if (emailInputs.length) {
      const value = emailInputs[0].value
      const regex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/
      if (!regex.test(value)) {
        this.showInputError(emailInputs[0], 'Please enter a valid email')
        return false
      }
    }
    if (zipInputs.length) {
      const value = zipInputs[0].value
      const regex = /^\d{5}$/
      if (!regex.test(value)) {
        this.showInputError(zipInputs[0], 'Please enter a valid zip code')
        return false
      }
    }
    if (emptyInputs.length) {
      this.showInputError(emptyInputs[0], 'This field is required')
      return false
    }
    if (fileInputs.length) {
      for (const input of fileInputs) {
        if (!input.files[0]) {
          console.log(input.files)
          this.showInputError(null, 'Please upload a file')
          return false
        }
      }
    }
    this.clearErrors()
    return true
  }
  adjustActiveSectionHeight() {
    const activeSection = this.getActiveSection
    if (activeSection) {
      const height = activeSection.scrollHeight
      this.content.style.height = `${height}px`
    }
  }
  toggle() {
    const body = document.querySelector('body')
    const headerNav = document.querySelector('.header__sub-nav')
    const welcome = document.querySelector('.subpage__welcome')
    const footerMain = document.querySelector('.footer__wrapper > .wrapper')
    const loanWelcome = document.querySelector('.loan-welcome')
    const heading = document.querySelector('.loan-case__heading')
    const backGroup = document.querySelector('.loan-case__back-group')
    const CASE_CLASS = 'loan_case'
    const elements = [headerNav, welcome, footerMain, loanWelcome]

    const hideElement = (el) => {
      const curHeight = el.scrollHeight
      el.style.height = `${curHeight}px`
      setTimeout(() => {
        el.style.overflow = 'hidden'
        el.style.height = '0px'
      }, 1);
    }
    const showElement = (el) => {
      const curHeight = window.getComputedStyle(el).getPropertyValue('height')
      const scrollHeight = el.scrollHeight
      el.style.height = `${curHeight}`
      setTimeout(() => {
        el.style.overflow = 'visible'
        el.style.height = `${scrollHeight}px`
      }, 1)
    }

    const hideLoan = () => {
      body.classList.remove(CASE_CLASS)
      for (const element of elements) {
        if (element) showElement(element)
      }

      this.scroller.style.display = 'none'
      this.content.style.height = `0px`

      if (backGroup) {
        backGroup.style.height = `0px`
      }

      if (heading) {
        heading.innerHTML = 'Welcome To the Icebox Max Approval Financing Form'
        heading.classList.remove('--big')
      }

      this.clearErrors()
      this.back(1)
      this.clearAllFields()
    }
    const showLoan = () => {
      body.classList.add('loan_case')
      for (const element of elements) {
        if (element) hideElement(element)
      }

      this.scroller.style.display = 'flex'
      this.content.style.height = `${this.sections[0].scrollHeight}px`

      if (backGroup) {
        backGroup.style.height = `${backGroup.scrollHeight}px`
      }

      if (heading) {
        heading.innerHTML = 'Job Application'
        heading.classList.add('--big')
      }
    }

    if (body.classList.contains(CASE_CLASS)) {
      const askModal = new AskModal({
        heading: 'Are You Sure You Want To Exit Financing App?',
        subheading: 'You will lose all the progress. Keep filling out the form and get approved as soon as possible!',
        exitText: 'Exit',
        keepText: 'Keep Filling',
        exitCallback: hideLoan,
      })
      askModal.show()
    } else {
      showLoan()
    }
  }
  tabPress() {
    if (!this.sliding) {
      const activeInput = this.getActiveInput
      if (!activeInput) {
        const section = this.getActiveSection
        const inputArray = [...section.querySelectorAll('input:not(.--disabled), select:not(.--disabled)')]
        if (inputArray.length) {
          let inputToFocus
          const invalidInputs = inputArray.filter(input => input.classList.contains('--invalid'))
          if (invalidInputs.length) {
            inputToFocus = invalidInputs[0]
          } else {
            const emptyInputs = inputArray.filter(input => !input.value && input.value !== 0)
            if (emptyInputs.length) {
              inputToFocus = emptyInputs[0]
            } else {
              inputToFocus = inputArray[0]
            }
          }
          inputToFocus.focus()
        }
      } else {
        const activeInputWrap = activeInput.parentNode.closest('.loan-input-wrap')
        const nextInputWrap = activeInputWrap.nextElementSibling
        if (nextInputWrap) {
          const nextInput = nextInputWrap.querySelector('input, select')
          if (nextInput) {
            nextInput.focus()
          }
        } else {
          const firstInputWrap = this.getActiveSection.querySelector('.loan-input-wrap')
          const firstInput = firstInputWrap.querySelector('input, select')
          if (firstInput) {
            firstInput.focus()
          }
        }
      }
    }
  }

  /**
   * Bind Events
   */
  bindStepEvt() {
    this.evtGo.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        const section = this.getActiveSection
        if (this.validate(section)) this.go()
      })
    })
    this.evtBack.forEach((btn) => {
      btn.addEventListener('click', () => {
        this.back()
      })
    })
    this.evtSubmit.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        this.evtGo[0].click()
      })
    })
    this.evtToggle.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        this.toggle()
      })
    })

  }
  bindInputEvents() {
    const inputs = [...this.holder.querySelectorAll('input')]
    const selects = [...this.holder.querySelectorAll('select')]
    const noWebsiteCheckbox = this.holder.querySelector('#loan_employer_website')
    const inputWebsiteEmployer = this.holder.querySelector('#loan_employer_website')

    document.addEventListener('keydown', (e) => {
      const isTab = e.key === 'Tab'
      if (isTab) {
        if (document.body.classList.contains('loan_case')) {
          e.preventDefault()
          this.tabPress()
        }
      }
    })

    inputs.forEach((input) => {
      input.addEventListener('focus', () => {
        this.clearErrors()
        const parent = input.parentNode.closest('.loan-input-wrap')
        if (parent) {
          parent.classList.add('--focused')
        }
      })
      input.addEventListener('blur', () => {
        const parent = input.parentNode.closest('.loan-input-wrap')
        if (parent) {
          parent.classList.remove('--focused')
        }
      })
      input.addEventListener('keydown', (e) => {
        this.clearErrors()
        const isEnter = e.key === 'Enter'
        const isTab = e.key === 'Tab'
        if (isEnter) {
          this.evtGo[0].click()
        }
      })
    })
    selects.forEach((select) => {
      select.addEventListener('change', () => {
        this.clearErrors()
      })
    })
  }
  bindSSNInput() {
    const inputs = this.holder.querySelectorAll('input[data-format="ssn"]')
    for (const input of inputs) {
      input.addEventListener('input', (e) => {
        const value = e.target.value
        let newValue = ''
        for (let i = 0; i < value.length; i++) {
          const char = value.charAt(i)
          if (char.match(/^[0-9]$/) && newValue.length < 9) {
            newValue += char
          }
        }
        e.target.value = newValue
      })
      input.addEventListener('blur', (e) => {
        const value = e.target.value
        if (value) {
          let newValue = value.replace(/([^0-9])/g, '')
          newValue = newValue.slice(0, 3) + '—' + newValue.slice(3, 5) + '—' + newValue.slice(5)
          e.target.value = newValue
        }
      })
      input.addEventListener('focus', (e) => {
        e.target.value = e.target.value.replace(/([^0-9])/g, '')
      })
    }
  }
  bindNumberInput() {
    const inputs = this.holder.querySelectorAll('input[data-validate="number"]')
    for (const input of inputs) {
      let keyCode;
      function mask(event) {
        event.keyCode && (keyCode = event.keyCode);
        let pos = this.selectionStart;
        if (pos < 3) event.preventDefault()
        let matrix = "+1 (___) ___-____",
          i = 0,
          def = matrix.replace(/\D/g, ""),
          val = this.value.replace(/\D/g, ""),
          newValue = matrix.replace(/[_\d]/g, function (a) {
            return i < val.length ? val.charAt(i++) || def.charAt(i) : a;
          });
        i = newValue.indexOf("_");
        if (i != -1) {
          i < 5 && (i = 3);
          newValue = newValue.slice(0, i);
        }
        let reg = matrix.substr(0, this.value.length).replace(/_+/g,
          function (a) {
            return "\\d{1," + a.length + "}";
          }).replace(/[+()]/g, "\\$&");
        reg = new RegExp("^" + reg + "$");
        if (!reg.test(this.value) || this.value.length < 5 || keyCode > 47 && keyCode < 58) this.value = newValue;
        if (event.type == "blur" && this.value.length < 5) this.value = "";
      }

      input.addEventListener("input", mask, false);
      input.addEventListener("focus", mask, false);
      input.addEventListener("blur", mask, false);
      input.addEventListener("keydown", mask, false);
      input.addEventListener('mouseup', event => {
        event.preventDefault()
        if (input.value.length < 4) {
          input.setSelectionRange(4, 4)
        } else {
          input.setSelectionRange(input.value.length, input.value.length)
        }
      })
    }
  }
  bindResumeUpload() {
    const input = document.querySelector('#job_resume')
    const box = document.querySelector('[data-loan="files_upload"]')
    const holder = this.filesHolder
    // if (!input || !box || !holder) throw new Error('JS : Bind ID Upload : Input or Box or Holder not found')

    if (input && box && holder) {

      function processFiles(files) {
        const allowedExtensions = ['pdf', 'docx', 'doc']
        for (const file of files) {
          const name = file.name.toLowerCase()
          const extension = name.split('.').pop()
          if (allowedExtensions.includes(extension)) {
            console.log(file)
          }
        }
      }

      box.onclick = () => {
        this.clearErrors()
        input.click()
      }
      input.onchange = (e) => {
        processFiles(e.target.files)
      }
      box.ondragover = (e) => {
        this.clearErrors()
        e.preventDefault()
        box.classList.add(IS_ACTIVE)
      }
      box.ondragleave = (e) => {
        this.clearErrors()
        e.preventDefault()
        box.classList.remove(IS_ACTIVE)
      }
      box.ondrop = (e) => {
        this.clearErrors()
        e.preventDefault()
        box.classList.remove(IS_ACTIVE)
      }
    }
  }
  bindDualSelect() {
    const dualArr = this.holder.querySelectorAll('[data-loan-evt="dual_select"]')
    for (const dual of dualArr) {
      const input = dual.querySelector('input:not([type="checkbox"])')
      const checkbox = dual.querySelector('input[type="checkbox"]')
      if (input && checkbox) {
        checkbox.onchange = () => {
          let isChecked = checkbox.checked
          if (isChecked) {
            input.classList.add('--disabled')
            input.setAttribute('disabled', 'disabled')
            if (input.type !== 'range') {
              input.value = ''
            }
          } else {
            input.removeAttribute('disabled')
            input.classList.remove('--disabled')
          }
        }
      }
    }

    const rangeOutputArr = [...this.holder.querySelectorAll('.custom-range__output')]
    for (const input of rangeOutputArr) {
      const parent = input.closest('[data-loan-evt="dual_select"]')
      if (parent) {
        const rangeInput = parent.querySelector('input[type="range"]')
        if (rangeInput) {
          const maxValue = rangeInput.max
          const minValue = rangeInput.min

          input.addEventListener('input', (e) => {
            e.target.value = e.target.value.replace(/[^0-9]/g, '')
          })

          input.addEventListener('blur', (e) => {
            e.target.value = Math.max(Math.min(e.target.value, maxValue), minValue)
            rangeInput.value = e.target.value
            rangeInput.dispatchEvent(new Event('input'))
          })
        }
      }
    }
  }
  bindFormatting() {
    const currencyArr = document.querySelectorAll('[data-format="currency"]')
    for (const input of currencyArr) {
      input.addEventListener('blur', () => {
        const val = input.value
        if (val.length) {
          input.value = formatAsCurrency(val)
        }
      })
    }
  }

  /**
   * Initial
   */
  setInitialVar() {
    this.steps = this.sections.length
    if (!this.steps) throw new Error('No Loan Sections Found')
    this.currentStep = 0
    this.stepsLeft = this.steps
    this.endReached = false
    this.atTheStart = true
  }
  setInitialLayout() {
    const firstSection = this.sections[0]
    const height = firstSection.scrollHeight
    this.content.style.height = `${height}px`
    this.content.style.transition = `all ${this.settings.scrollSpeed}ms ${this.settings.easing}`
    this.scroller.style.transition = `all ${this.settings.scrollSpeed}ms ${this.settings.easing}`
    // this.sections.forEach(section => section.style.display = 'flex')
  }
  init() {
    this.setInitialLayout()
    this.setInitialVar()
    this.bindStepEvt()
    this.bindInputEvents()
    this.bindNumberInput()
    this.bindSSNInput()
    this.bindResumeUpload()
    this.bindDualSelect()
    this.bindFormatting()
  }
}

module.exports = JobApp
},{}],42:[function(require,module,exports){
class LoanApp {
  constructor(holder, settings = {}) {
    this.holder = holder
    this.filesHolder = this.holder.querySelector('#loan_files_upload')
    this.sections = [...this.holder.querySelectorAll('[data-loan-section]')]
    this.content = this.holder.querySelector('.loan-case__content')
    this.scroller = this.holder.querySelector('.loan-scroller')
    this.footer = this.holder.querySelector('.loan-case__footer')
    this.btnGroup = this.holder.querySelector('.loan-case__btn-group')
    this.evtGo = [...this.holder.querySelectorAll('[data-loan-evt="go"]')]
    this.evtToggle = [...this.holder.querySelectorAll('[data-loan-evt="toggle"]')]
    this.evtSubmit = [...this.holder.querySelectorAll('[data-loan-evt="submit"]')]
    this.evtBack = [...this.holder.querySelectorAll('[data-loan-evt="back"]')]
    this.bar = this.holder.querySelector('.loan-bar')
    this.bar_progress = this.holder.querySelector('.loan-bar__progress')
    this.flow = this.holder.querySelector('.loan-flow')
    this.finish = this.holder.querySelector('.loan-finish')
    this.maxSteps = undefined
    this.currentStep = undefined
    this.stepsLeft = undefined
    this.endReached = undefined
    this.atStart = undefined
    this.sliding = false
    this.data = {}
    this.settings = {
      scrollSpeed: settings.scrollSpeed || 600,
      easing: settings.easing || 'cubic-bezier(.39, .575, .565, 1)',
    }
    if (this.holder) {
      this.init()
    }
  }

  /**
   * Utils
   */
  get getLeftSteps() {
    return this.steps - this.currentStep
  }
  get getActiveSection() {
    return this.sections[this.currentStep]
  }
  get getActiveInput() {
    const section = this.getActiveSection
    if (section && section.contains(document.activeElement)) {
      if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') {
        return document.activeElement
      }
    } else {
      return undefined
    }
  }
  get getLoaderHTML() {
    return `
                            <div>
                                <div>
                                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewBox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
                                        <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"></path>
                                        <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0C22.32,8.481,24.301,9.057,26.013,10.047z"></path>
                                        <animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatCount="indefinite"></animateTransform>
                                    </svg>
                                </div>
                            </div>
    `
  }
  createElem(tagName, options) {
    const { className, id, innerHTML, style, attributes, toAppend } = options
    const elem = document.createElement(tagName)
    if (className) elem.className = className;
    if (id) elem.id = id;
    if (innerHTML) elem.innerHTML = innerHTML;
    if (style) {
      for (const key in options.style) { elem.style[key] = options.style[key] }
    }
    if (attributes) {
      for (const key in options.attributes) { elem.setAttribute(key, options.attributes[key]) }
    }
    if (toAppend) {
      for (const child of toArray(toAppend)) { elem.appendChild(child) }
    }
    return elem
  }
  toArray(target) {
    return Array.isArray(target) ? target : [target]
  }
  loadingOn(timeToRemove) {
    if (this.holder.querySelector('.loan-case-loader')) return
    const loader = createElem('div', {
      className: 'loan-case-loader',
      innerHTML: this.getLoaderHTML
    })
    this.holder.appendChild(loader)
    setTimeout(() => {
      this.holder.classList.add(__LOCKED)
      if (timeToRemove) {
        setTimeout(() => {
          this.holder.classList.remove(__LOCKED)
          setTimeout(() => {
            loader.remove()
          }, 350);
        }, timeToRemove);
      }
    }, 1);
  }
  loadingOff() {
    this.holder.classList.remove(__LOCKED)
    const loader = this.holder.querySelector('.loan-case-loader')
    if (loader) {
      setTimeout(() => {
        loader.remove()
      }, 350);
    }
  }
  showInputError(input, text) {
    const err = document.querySelector('.loan-input-error') ? document.querySelector('.loan-input-error') : createElem('div', {
      className: 'loan-input-error',
      innerHTML: text
    })
    input.classList.add(__INVALID)
    this.footer.prepend(err)
  }
  clearErrors() {
    const activeSection = this.getActiveSection
    const inputs = [...activeSection.querySelectorAll('input'), ...activeSection.querySelectorAll('select')]
    inputs.forEach(input => input.classList.remove(__INVALID))
    const err = this.holder.querySelector('.loan-input-error')
    if (err) err.remove()
  }
  observeBar() {
    const prevSections = this.sections.slice(0, this.currentStep).length
    const progress = (prevSections + 1) / this.steps * 100
    this.bar_progress.style.width = `${progress}%`
  }
  clearAllFields() {
    const inputs = [...this.holder.querySelectorAll('input:not([type="checkbox"])')]
    const selects = [...this.holder.querySelectorAll('select')]
    const checkboxes = [...this.holder.querySelectorAll('input[type="checkbox"]')]
    const fullArr = [...inputs, ...selects, ...checkboxes]

    inputs.forEach(input => input.value = '')
    selects.forEach(select => select.selectedIndex = 0)
    checkboxes.forEach((checkbox) => { checkbox.checked = false })
    fullArr.forEach(elem => elem.dispatchEvent(new Event('change')))
  }

  /**
   * Main
   */
  save() {
    $('#loan_form').submit();
  }
  finishMessage() {
    this.loadingOn(1000)
    setTimeout(() => {
      this.flow.style.opacity = 0
      let currentHeight = this.holder.offsetHeight
      this.holder.style.height = `${currentHeight}px`
      setTimeout(() => {
        this.finish.style.display = 'block'
        let scrollH = this.finish.scrollHeight
        this.holder.style.height = `${scrollH}px`
        setTimeout(() => {
          this.finish.style.opacity = 1
          window.scrollTo(0, 0)
          const confetti = new PageConfetti()
          confetti.push(false)
        }, 10);
      }, getTransitionTime(this.flow) + 10)
    }, 800);
  }
  slide(section) {
    section.style.display = 'flex'
    const height = section.scrollHeight
    const pxToTransform = this.sections.slice(0, this.currentStep).reduce((acc, el) => acc + el.scrollHeight, 0)
    this.content.style.height = `${height}px`
    this.scroller.style.transform = `translateY(-${pxToTransform}px)`
    this.sections.forEach(e => e.classList.remove(IS_ACTIVE))
    section.classList.add(IS_ACTIVE)
    setTimeout(() => {
      this.sliding = false
    }, getTransitionTime(this.scroller));
  }
  go(toStep) {
    if (this.holder.classList.contains(__LOCKED)) return
    const inputs = [...this.holder.querySelectorAll('input'), ...this.holder.querySelectorAll('select')]
    const step = toStep || this.currentStep || 0
    const nextStep = step + 1
    const nextSection = this.sections[nextStep]

    if (!this.sections[nextStep + 1]) {
      this.evtGo.forEach((btn) => {
        btn.innerHTML = 'Submit'
      })
    }

    if (nextSection) {
      this.sliding = true
      inputs.forEach(input => input.blur())
      this.loadingOn()
      setTimeout(() => {
        this.currentStep = nextStep
        this.slide(nextSection)
        this.loadingOff()
        this.observeBar()
      }, 600);
    } else {
      this.save()
      this.finishMessage()
    }
  }
  back(toStep) {
    if (this.holder.classList.contains(__LOCKED)) return
    this.clearErrors()
    const step = toStep || this.currentStep || 0
    const prevStep = step - 1
    const prevSection = this.sections[prevStep]
    if (prevSection) {
      this.evtGo.forEach((btn) => {
        btn.innerHTML = 'Next'
      })
      this.currentStep = prevStep
      this.slide(prevSection)
    }
  }
  validate(section) {
    const requiredTextInputs = [...section.querySelectorAll('input[type="text"][required]:not(.--disabled'), ...section.querySelectorAll('input[type="email"][required]')]
    const emptyInputs = requiredTextInputs.filter(input => !input.value)
    const numberInputs = section.querySelectorAll('input[data-validate="number"]')
    const selectInputs = section.querySelectorAll('select[required]')
    const emailInputs = section.querySelectorAll('input[data-validate="email"]')
    const zipInputs = section.querySelectorAll('input[data-validate="zip_code"]')
    const sectionID = section.dataset.loanSection

    if (requiredTextInputs.some(input => input.classList.contains(__INVALID))) return false
    if (numberInputs.length) {
      const value = numberInputs[0].value
      const regex = /^\+\d{1}\s\(\d{3}\)\s\d{3}\-\d{4}$/
      if (!regex.test(value)) {
        this.showInputError(numberInputs[0], 'Please enter a valid phone number')
        return false
      }
    }
    if (emailInputs.length) {
      const value = emailInputs[0].value
      const regex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/
      if (!regex.test(value)) {
        this.showInputError(emailInputs[0], 'Please enter a valid email')
        return false
      }
    }
    if (zipInputs.length) {
      const value = zipInputs[0].value
      const regex = /^\d{5}$/
      if (!regex.test(value)) {
        this.showInputError(zipInputs[0], 'Please enter a valid zip code')
        return false
      }
    }
    if (emptyInputs.length) {
      this.showInputError(emptyInputs[0], 'This field is required')
      return false
    }
    if (selectInputs.length) {
      for (const select of selectInputs) {
        if (!select.value) {
          this.showInputError(select, 'Please select an option')
          return false
        }
      }
    }
    return true
  }
  adjustActiveSectionHeight() {
    const activeSection = this.getActiveSection
    if (activeSection) {
      const height = activeSection.scrollHeight
      this.content.style.height = `${height}px`
    }
  }
  toggle() {
    const body = document.querySelector('body')
    const headerNav = document.querySelector('.header__sub-nav')
    const welcome = document.querySelector('.subpage__welcome')
    const footerMain = document.querySelector('.footer__wrapper > .wrapper')
    const loanWelcome = document.querySelector('.loan-welcome')
    const heading = document.querySelector('.loan-case__heading')
    const backGroup = document.querySelector('.loan-case__back-group')
    const CASE_CLASS = 'loan_case'
    const elements = [headerNav, welcome, footerMain, loanWelcome]

    const hideElement = (el) => {
      const curHeight = el.scrollHeight
      el.style.height = `${curHeight}px`
      setTimeout(() => {
        el.style.overflow = 'hidden'
        el.style.height = '0px'
      }, 1);
    }
    const showElement = (el) => {
      const curHeight = window.getComputedStyle(el).getPropertyValue('height')
      const scrollHeight = el.scrollHeight
      el.style.height = `${curHeight}`
      setTimeout(() => {
        el.style.overflow = 'visible'
        el.style.height = `${scrollHeight}px`
      }, 1)
    }

    const hideLoan = () => {
      body.classList.remove(CASE_CLASS)
      for (const element of elements) {
        if (element) showElement(element)
      }

      this.scroller.style.display = 'none'
      this.content.style.height = `0px`

      if (backGroup) {
        backGroup.style.height = `0px`
      }

      if (heading) {
        heading.innerHTML = 'Welcome To the Icebox Max Approval Financing Form'
        heading.classList.remove('--big')
      }

      this.clearErrors()
      this.back(1)
      this.clearAllFields()
    }
    const showLoan = () => {
      body.classList.add('loan_case')
      for (const element of elements) {
        if (element) hideElement(element)
      }

      this.scroller.style.display = 'flex'
      this.content.style.height = `${this.sections[0].scrollHeight}px`

      if (backGroup) {
        backGroup.style.height = `${backGroup.scrollHeight}px`
      }

      if (heading) {
        heading.innerHTML = 'Financing Application'
        heading.classList.add('--big')
      }
    }

    if (body.classList.contains(CASE_CLASS)) {
      const askModal = new AskModal({
        heading: 'Are You Sure You Want To Exit Financing App?',
        subheading: 'You will lose all the progress. Keep filling out the form and get approved as soon as possible!',
        exitText: 'Exit',
        keepText: 'Keep Filling',
        exitCallback: hideLoan,
      })
      askModal.show()
    } else {
      showLoan()
    }
  }
  tabPress() {
    if (!this.sliding) {
      const activeInput = this.getActiveInput
      if (!activeInput) {
        const section = this.getActiveSection
        const inputArray = [...section.querySelectorAll('input:not(.--disabled), select:not(.--disabled)')]
        if (inputArray.length) {
          let inputToFocus
          const invalidInputs = inputArray.filter(input => input.classList.contains('--invalid'))
          if (invalidInputs.length) {
            inputToFocus = invalidInputs[0]
          } else {
            const emptyInputs = inputArray.filter(input => !input.value && input.value !== 0)
            if (emptyInputs.length) {
              inputToFocus = emptyInputs[0]
            } else {
              inputToFocus = inputArray[0]
            }
          }
          inputToFocus.focus()
        }
      } else {
        const activeInputWrap = activeInput.parentNode.closest('.loan-input-wrap')
        const nextInputWrap = activeInputWrap.nextElementSibling
        if (nextInputWrap) {
          const nextInput = nextInputWrap.querySelector('input, select')
          if (nextInput) {
            nextInput.focus()
          }
        } else {
          const firstInputWrap = this.getActiveSection.querySelector('.loan-input-wrap')
          const firstInput = firstInputWrap.querySelector('input, select')
          if (firstInput) {
            firstInput.focus()
          }
        }
      }
    }
  }

  /**
   * Bind Events
   */
  bindStepEvt() {
    this.evtGo.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        const section = this.getActiveSection
        if (this.validate(section)) this.go()
      })
    })
    this.evtBack.forEach((btn) => {
      btn.addEventListener('click', () => {
        this.back()
      })
    })
    this.evtSubmit.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        this.evtGo[0].click()
      })
    })
    this.evtToggle.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        this.toggle()
      })
    })

  }
  bindInputEvents() {
    const inputs = [...this.holder.querySelectorAll('input')]
    const selects = [...this.holder.querySelectorAll('select')]
    const noWebsiteCheckbox = this.holder.querySelector('#loan_employer_website')
    const inputWebsiteEmployer = this.holder.querySelector('#loan_employer_website')

    document.addEventListener('keydown', (e) => {
      const isTab = e.key === 'Tab'
      if (isTab) {
        if (document.body.classList.contains('loan_case')) {
          e.preventDefault()
          this.tabPress()
        }
      }
    })

    inputs.forEach((input) => {
      input.addEventListener('focus', () => {
        this.clearErrors()
        const parent = input.parentNode.closest('.loan-input-wrap')
        if (parent) {
          parent.classList.add('--focused')
        }
      })
      input.addEventListener('blur', () => {
        const parent = input.parentNode.closest('.loan-input-wrap')
        if (parent) {
          parent.classList.remove('--focused')
        }
      })
      input.addEventListener('keydown', (e) => {
        this.clearErrors()
        const isEnter = e.key === 'Enter'
        const isTab = e.key === 'Tab'
        if (isEnter) {
          this.evtGo[0].click()
        }
      })
    })
    selects.forEach((select) => {
      select.addEventListener('change', () => {
        this.clearErrors()
      })
    })
  }
  bindSSNInput() {
    const inputs = this.holder.querySelectorAll('input[data-format="ssn"]')
    for (const input of inputs) {
      input.addEventListener('input', (e) => {
        const value = e.target.value
        let newValue = ''
        for (let i = 0; i < value.length; i++) {
          const char = value.charAt(i)
          if (char.match(/^[0-9]$/) && newValue.length < 9) {
            newValue += char
          }
        }
        e.target.value = newValue
      })
      input.addEventListener('blur', (e) => {
        const value = e.target.value
        if (value) {
          let newValue = value.replace(/([^0-9])/g, '')
          newValue = newValue.slice(0, 3) + '—' + newValue.slice(3, 5) + '—' + newValue.slice(5)
          e.target.value = newValue
        }
      })
      input.addEventListener('focus', (e) => {
        e.target.value = e.target.value.replace(/([^0-9])/g, '')
      })
    }
  }
  bindNumberInput() {
    const inputs = this.holder.querySelectorAll('input[data-validate="number"]')
    for (const input of inputs) {
      let keyCode;
      function mask(event) {
        event.keyCode && (keyCode = event.keyCode);
        let pos = this.selectionStart;
        if (pos < 3) event.preventDefault()
        let matrix = "+1 (___) ___-____",
          i = 0,
          def = matrix.replace(/\D/g, ""),
          val = this.value.replace(/\D/g, ""),
          newValue = matrix.replace(/[_\d]/g, function (a) {
            return i < val.length ? val.charAt(i++) || def.charAt(i) : a;
          });
        i = newValue.indexOf("_");
        if (i != -1) {
          i < 5 && (i = 3);
          newValue = newValue.slice(0, i);
        }
        let reg = matrix.substr(0, this.value.length).replace(/_+/g,
          function (a) {
            return "\\d{1," + a.length + "}";
          }).replace(/[+()]/g, "\\$&");
        reg = new RegExp("^" + reg + "$");
        if (!reg.test(this.value) || this.value.length < 5 || keyCode > 47 && keyCode < 58) this.value = newValue;
        if (event.type == "blur" && this.value.length < 5) this.value = "";
      }

      input.addEventListener("input", mask, false);
      input.addEventListener("focus", mask, false);
      input.addEventListener("blur", mask, false);
      input.addEventListener("keydown", mask, false);
      input.addEventListener('mouseup', event => {
        event.preventDefault()
        if (input.value.length < 4) {
          input.setSelectionRange(4, 4)
        } else {
          input.setSelectionRange(input.value.length, input.value.length)
        }
      })
    }
  }
  bindIDUpload() {
    const input = document.querySelector('#loan_id')
    const box = document.querySelector('[data-loan="files_upload"]')
    const holder = this.filesHolder
    // if (!input || !box || !holder) throw new Error('JS : Bind ID Upload : Input or Box or Holder not found')

    if (input && box && holder) {
      function processFiles(files) {
        if (!files) throw new Error('No files selected')
        files = [...files]
        if (!files.length) return
        for (const file of files) {
          if (!file.type.match('image.*')) continue
          const images = holder.querySelectorAll('img')
          for (const image of images) {
            image.remove()
          }
          let reader = new FileReader()
          reader.onload = (e) => {
            appendImage(e.target.result)
          }
          reader.readAsDataURL(file)
        }
      }

      function appendImage(imgURL) {
        const img = createElem('img', {
          style: {
            'background-image': `url(${imgURL})`
          },
        })
        holder.append(img)
      }

      box.onclick = () => { input.click() }
      input.onchange = (e) => {
        processFiles(e.target.files)
        // input.value = ''
        setTimeout(() => {
          this.adjustActiveSectionHeight()
        }, 10);
      }
      box.ondragover = (e) => {
        e.preventDefault()
        box.classList.add(IS_ACTIVE)
      }
      box.ondragleave = (e) => {
        e.preventDefault()
        box.classList.remove(IS_ACTIVE)
      }
      box.ondrop = (e) => {
        e.preventDefault()
        box.classList.remove(IS_ACTIVE)
        processFiles(e.dataTransfer.files)
      }
    }
  }
  bindDualSelect() {
    const dualArr = this.holder.querySelectorAll('[data-loan-evt="dual_select"]')
    for (const dual of dualArr) {
      const input = dual.querySelector('input:not([type="checkbox"])')
      const checkbox = dual.querySelector('input[type="checkbox"]')
      if (input && checkbox) {
        checkbox.onchange = () => {
          let isChecked = checkbox.checked
          if (isChecked) {
            input.classList.add('--disabled')
            input.setAttribute('disabled', 'disabled')
            if (input.type !== 'range') {
              input.value = ''
            }
          } else {
            input.removeAttribute('disabled')
            input.classList.remove('--disabled')
          }
        }
      }
    }

    const rangeOutputArr = [...this.holder.querySelectorAll('.custom-range__output')]
    for (const input of rangeOutputArr) {
      const parent = input.closest('[data-loan-evt="dual_select"]')
      if (parent) {
        const rangeInput = parent.querySelector('input[type="range"]')
        if (rangeInput) {
          const maxValue = rangeInput.max
          const minValue = rangeInput.min

          input.addEventListener('input', (e) => {
            e.target.value = e.target.value.replace(/[^0-9]/g, '')
          })

          input.addEventListener('blur', (e) => {
            e.target.value = Math.max(Math.min(e.target.value, maxValue), minValue)
            rangeInput.value = e.target.value
            rangeInput.dispatchEvent(new Event('input'))
          })
        }
      }
    }
  }
  bindFormatting() {
    const currencyArr = document.querySelectorAll('[data-format="currency"]')
    for (const input of currencyArr) {
      input.addEventListener('blur', () => {
        const val = input.value
        if (val.length) {
          input.value = formatAsCurrency(val)
        }
      })
    }
  }

  /**
   * Initial
   */
  setInitialVar() {
    this.steps = this.sections.length
    if (!this.steps) throw new Error('No Loan Sections Found')
    this.currentStep = 0
    this.stepsLeft = this.steps
    this.endReached = false
    this.atTheStart = true
  }
  setInitialLayout() {
    const firstSection = this.sections[0]
    const height = firstSection.scrollHeight
    this.content.style.height = `${height}px`
    this.content.style.transition = `all ${this.settings.scrollSpeed}ms ${this.settings.easing}`
    this.scroller.style.transition = `all ${this.settings.scrollSpeed}ms ${this.settings.easing}`
    // this.sections.forEach(section => section.style.display = 'flex')
  }
  init() {
    this.setInitialLayout()
    this.setInitialVar()
    this.bindStepEvt()
    this.bindInputEvents()
    this.bindNumberInput()
    this.bindSSNInput()
    this.bindIDUpload()
    this.bindDualSelect()
    this.bindFormatting()
  }
}

module.exports = LoanApp
},{}],43:[function(require,module,exports){
const locationPage = new Object({
  init: function () {
    Object.values(this.attachEvents).forEach((fn) => {
      if (fn !== undefined && typeof fn == 'function') fn();
    })
  },
  attachEvents: {
    toggleStoresVisibility: function () {
      let headArr = [...$('.store-row__head')]
      $.each(headArr, function (i) {
        $(headArr[i]).click(function () {
          let rows = $('.store-row'),
            thisRow = $(this).closest(rows)
          if (elemDisplayed(thisRow.find('.store-row__body'))) {
            return false
          } else {
            rows.find('.store-row__body').show()
            rows.not(thisRow).find('.store-row__body').hide()
          }
        })
      })
    }
  }
})

module.exports = locationPage
},{}],44:[function(require,module,exports){
class LooseDiamonds {
  constructor() {
    this.main = document.querySelector('.loose_diamonds')
    this.resultsContainer = document.querySelector('.loose__results')
    this.viewBtnArr = [...document.querySelectorAll('.loose__view-btn')]
    this.looseSelectArr = [...document.querySelectorAll('.loose-select')]
    this.dmBtnArr = [...document.querySelectorAll('.dm-filter-btn')]
    this.sortModalActive = false
    if (this.main) {
      this.init()
    }
  }

  // Methods
  listView() {
    this.main.classList.add('--list')
  }
  gridView() {
    this.main.classList.remove('--list')
  }
  observeFilters() {
    for (const select of this.looseSelectArr) {
      const btnArr = [...select.querySelectorAll('.loose-filter-btn')]
      const inputArr = [...select.querySelectorAll('input[type="text"]')]

      const someIsChecked = btnArr.some(el => el.classList.contains(__ACTIVE))
      const someIsValue = inputArr.some(el => el.value.length > 0)

      if (someIsChecked || someIsValue) {
        select.classList.add(__SELECTED)
      } else {
        select.classList.remove(__SELECTED)
      }
    }
  }
  resetFilters() {
    for (const select of this.looseSelectArr) {
      const btnArr = [...select.querySelectorAll('.loose-filter-btn')]
      const inputArr = [...select.querySelectorAll('input[type="text"]')]

      btnArr.forEach(el => el.classList.remove(__ACTIVE))
      inputArr.forEach(el => el.value = '')

      select.classList.remove(__SELECTED)
    }
  }
  openSortModal() {
    const sortModal = document.querySelector('.sort-modal')
    const closeCallback = () => { this.closeSortModal(true) }
    if (sortModal) {
      window.looseSortBackdrop = new Backdrop({
        half: true,
        callback: closeCallback
      })
      lockScroll()
      sortModal.style.display = 'block'
      setTimeout(() => {
        sortModal.classList.add(__ACTIVE)
      }, 5);
    }
  }
  closeSortModal(cond = false) {
    const sortModal = document.querySelector('.sort-modal')
    if (sortModal) {
      unlockScroll()
      sortModal.classList.remove(__ACTIVE)
      setTimeout(() => {
        sortModal.style.display = 'none'
      }, getTransitionTime(sortModal));
      if (!cond) {
        const backdrop = window.looseSortBackdrop
        if (backdrop) {
          backdrop.hide()
        }
      }

      const rowArr = [...document.querySelectorAll('.sort-modal-row')]
      for (const row of rowArr) {
        row.querySelector('.sort-modal-row__body').style.height = 0
      }
    }
  }
  applyFilters() {
    this.closeSortModal()
  }
  hideAdmin(target) {
    if (target) {
      const item = target.closest('.dm-item')
      const adminBar = item.querySelector('.dm-item__admin')
      if (adminBar) {
        adminBar.style.display = 'none'
      }
    }
  }

  // Bind Events
  bindLooseSelects() {
    for (const select of this.looseSelectArr) {
      const btn = select.querySelector('.loose-select__btn')
      const drop = select.querySelector('.loose-select__drop')
      if (btn && drop) {
        btn.addEventListener('click', () => {
          if (select.classList.contains(__ACTIVE)) {
            select.classList.remove(__ACTIVE)
          } else {
            this.looseSelectArr.forEach(el => el.classList.remove(__ACTIVE))
            select.classList.add(__ACTIVE)
          }
        })
      }
    }

    window.addEventListener('scroll', () => {
      if (this.looseSelectArr.some(el => el.classList.contains(__ACTIVE))) {
        this.looseSelectArr.forEach(el => el.classList.remove(__ACTIVE))
      }
    })

    document.addEventListener('click', (e) => {
      const target = e.target
      if (!target.closest('.loose-select')) {
        this.looseSelectArr.forEach(el => el.classList.remove(__ACTIVE))
      }
    })
  }
  bindFilterBtnGroup() {
    const groupArr = [...document.querySelectorAll('[data-filter-group]')]
    for (const group of groupArr) {
      const btnArr = [...group.querySelectorAll('.loose-filter-btn')]
      for (const btn of btnArr) {
        btn.addEventListener('click', () => {
          btn.classList.toggle(__ACTIVE)
          this.observeFilters()
        })
      }
    }

    for (const select of this.looseSelectArr) {
      const inputArr = [...select.querySelectorAll('input[type="text"]')]
      for (const input of inputArr) {
        input.addEventListener('input', () => {
          this.observeFilters()
        })
      }
    }
  }
  bindDmSelectClick() {
    const fade = (except = undefined) => {
      this.dmBtnArr.forEach(el => {
        if (el !== except && !el.classList.contains(__ACTIVE)) {
          el.classList.add(__FADE)
        }
      })
    }

    const reset = () => {
      this.dmBtnArr.forEach(el => {
        el.classList.remove(__ACTIVE)
        el.classList.remove(__FADE)
      })
    }

    for (const btn of this.dmBtnArr) {
      btn.addEventListener('click', () => {
        const someFaded = this.dmBtnArr.some(el => el.classList.contains(__FADE))
        const targetActive = btn.classList.contains(__ACTIVE)
        const targetFaded = btn.classList.contains(__FADE)
        const target = btn

        if (targetActive) {
          target.classList.remove(__ACTIVE)
          if (this.dmBtnArr.some(el => el.classList.contains(__ACTIVE))) {
            target.classList.add(__FADE)
          } else {
            reset()
          }
        } else {
          target.classList.add(__ACTIVE)
          target.classList.remove(__FADE)
          fade(target)
        }

      })
    }
  }
  bindSortModalEvents() {
    const modal = document.querySelector('.sort-modal')
    if (modal) {
      const rowArr = [...modal.querySelectorAll('.sort-modal-row')]
      for (const row of rowArr) {
        const head = row.querySelector('.sort-modal-row__head')
        const body = row.querySelector('.sort-modal-row__body')

        if (head && body) {
          head.addEventListener('click', () => {
            if (body.clientHeight > 0) {
              row.classList.remove(__ACTIVE)
              body.style.height = 0
            } else {
              rowArr.forEach((r) => {
                if (r !== row) {
                  r.classList.remove(__ACTIVE)
                  r.querySelector('.sort-modal-row__body').style.height = 0
                }
              })
              row.classList.add(__ACTIVE)
              const content = body.querySelector('.sort-modal-row__content')
              body.style.height = `${content.scrollHeight + 1}px`
            }
          })
        }
      }
    }
  }

  init() {
    this.bindLooseSelects()
    this.bindFilterBtnGroup()
    this.bindDmSelectClick()
    this.observeFilters()
    this.bindSortModalEvents()
  }
}

module.exports = LooseDiamonds
},{}],45:[function(require,module,exports){
const myBag = new Object({
  init: function () {
    Object.values(this.attachEvents).forEach((fn) => {
      if (fn !== undefined && typeof fn == 'function') fn();
    })
  },
  attachEvents: {
    formatSummaryPrice: function () {
      const lines = [...document.querySelectorAll('.summary-price')]
      for (const line of lines) {
        const span = line.querySelector('span:last-child')
        if (span) {
          const text = span.innerText
          let num = Number(text.replace(/[^0-9.-]/g, ''))
          if (num !== 0) {
            num = num.toFixed(2)
            num = num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            span.innerText = `$ ${num}`
          }
        }
      }
    },
    setSalePercentValues: function () {
      const cards = [...document.querySelectorAll('.mybag-card')]
      for (const card of cards) {
        const newPrice = card.querySelector('.card-price_new')
        const oldPrice = card.querySelector('.card-price_old')
        const saleElem = card.querySelector('.mybag-card-sale')
        if (newPrice && oldPrice && saleElem) {
          const newPriceNum = Number(newPrice.innerText.replace(/[^0-9]/g, ''))
          const oldPriceNum = Number(oldPrice.innerText.replace(/[^0-9]/g, ''))
          let sale = ((oldPriceNum - newPriceNum) / oldPriceNum) * 100
          sale = Math.round(sale / 10) * 10;
          if (sale % 10 >= 5) {
            sale = Math.ceil(sale / 10) * 10;
          } else {
            sale = Math.floor(sale / 10) * 10;
          }
          saleElem.innerText = `${sale}% OFF`
        }
      }
    },
    setCapitalizeCheckoutBtn: function () {
      const btnArr = [...document.querySelectorAll('.checkout__main-btn')]
      for (const btn of btnArr) {
        const text = btn.innerText.split(' ').reduce((acc, el) => {
          acc.push(el.charAt(0).toUpperCase() + el.slice(1).toLowerCase())
          return acc
        }, [])
        btn.innerText = text.join(' ')
      }
    }

  }
})

module.exports = myBag
},{}],46:[function(require,module,exports){
const passReset = {
  IS_EMPTY: 'is-empty',
  IS_DISABLED: 'is-disabled',
  init: function () {
    if ($('.pass-reset-page').length) {
      this.renderDOM()
      this.bindEvents()
    }
  },
  renderDOM: function () {
    this.form = $('#passResetForm')
    this.submitBtn = $('#passResetSubmit')
    this.inputArr = [...this.form.find('input[type="password"]')]
    this.error = $('.pass-reset-error')
    this.loader = $('.pass-reset-loader')
    this.main = $('.pass-reset__main')
    this.result = $('.pass-reset__result')
  },
  bindEvents: function () {
    // submit click
    $.each(this.submitBtn, function (i) {
      passReset.submitBtn[i].onclick = (e) => {
        e.preventDefault()
        passReset.form.submit()
      }
    })
    // input events
    $.each(this.inputArr, function (i) {
      passReset.inputArr[i].oninput = () => {
        let arr = passReset.inputArr
        let pass1 = arr[0].value, pass2 = arr[1].value
        if (pass2.length == 0) {
          passReset.hideError()
        } else {
          if (pass1.length !== pass2.length) { passReset.showError('Different password length') }
          else {
            passReset.hideError(); if (pass1 === pass2) { passReset.successError() }
            else { passReset.showError("Passwords don't match") }
          }
        }
      }
    })
    // form submit
    this.form[0].onsubmit = (e) => {
      e.preventDefault()
      if (passReset.formValid()) {
        Object.assign(passReset.submitBtn[0].style, { color: 'transparent', height: '14px', 'border-radius': '50px' })
        passReset.form.addClass(passReset.IS_DISABLED)
        passReset.hideError()
        passReset.loader[0].animate({ width: '100%' }, { duration: 3000, fill: 'forwards' }).onfinish = () => {
          const formData = new FormData(e.target), obj = {}
          formData.forEach((value, key) => (obj[key] = value))
          Object.assign(passReset.main[0].style, { opacity: 0 }); Object.assign(passReset.result[0].style, { opacity: 0 })
          setTimeout(() => {
            passReset.main.hide()
            passReset.result.show()
            setTimeout(() => {
              Object.assign(passReset.result[0].style, { opacity: 1 })
            }, 5);
          }, 401);
          // alert(JSON.stringify(obj))
        }
      }
    }
  },
  formValid: function () {
    let arr = passReset.inputArr
    arr.forEach(el => el.classList.remove(passReset.IS_EMPTY))

    if (arr.length !== 0) {
      let emptyInput = arr.filter(el => el.value.length == 0)

      if (emptyInput.length !== 0) {
        $.each(emptyInput, function (i) {
          emptyInput[i].classList.add(passReset.IS_EMPTY)
          setTimeout(() => {
            emptyInput[i].classList.remove(passReset.IS_EMPTY)
          }, 400);
        })
      } else {
        let pass1 = arr[0].value, pass2 = arr[1].value
        if (pass1 === pass2) {
          return true
        } else {
          return false
        }
      }

    }
  },
  showError: function (text = 'Something went wrong...') {
    this.error.html(text)
    Object.assign(this.error[0].style, { color: '#c02942', opacity: 1, transform: 'translateX(-50%) translateY(0px)' })
  },
  hideError: function () {
    Object.assign(this.error[0].style, { color: '#c02942', opacity: 0, transform: 'translateX(-50%) translateY(14px)' })
  },
  successError: function (text = 'Passwords match!') {
    this.error.html(text)
    Object.assign(this.error[0].style, { color: '#088d7b', opacity: 1, transform: 'translateX(-50%) translateY(0px)' })
  }
}

module.exports = passReset
},{}],47:[function(require,module,exports){
const ZoomGallery = require('../dynamic/zoom-gallery')

class ProductPage {
  constructor() {
    this.optionsArr = [...document.querySelectorAll('.product__item-option:not(.--static)')]
    this.optionsRow = document.querySelector('.side-row__options')
    this.colorPickArr = [...document.querySelectorAll('.color-pick')]
    this.toggleRowArr = [...document.querySelectorAll('.toggle-row')]
    this.description = document.querySelector('#product_description')
    this.galleryDesktopArr = [...document.querySelector('#gallery_desktop').querySelectorAll('.product__gallery')]
    this.galleryMobileArr = [...document.querySelector('#gallery_mobile').querySelectorAll('.product__gallery')]

    this.optionModal = document.querySelector('.option-modal')
    this.optionModalContent = document.querySelector('.option-modal__content')
    this.optionModalNextElem = document.querySelector('[data-option-modal-next]')
    this.optionModalName = document.querySelector('[data-option-modal-name]')
    this.evtNextOption = document.querySelector('[data-evt="optionModalNext"]')
    this.evtCloseOptionModalArr = document.querySelectorAll('[data-evt="optionModalClose"]')
    this.favBtn = document.querySelector('.product__add-fav')
    this.activeOptionIndex = undefined

    this.fixedBar = document.querySelector('.fixed-bar')
    this.fixedBarTrigger = document.querySelector('.side-row__payments')

    this.galleryZoomInstance = null

    this.init()
  }

  init() {
    if (window.innerWidth > 991) {
      this.bindOptionToggleDesktop()
    } else {
      this.bindOptionToggleMobile()
      this.bindOptionModalEvents()
      this.bindPullDown()
    }
    this.setActiveOptionsText()
    this.bindOptionButtonClick()
    this.bindOptionButtonClickInputValue()
    // this.bindColorPick()
    this.bindToggleRow()
    this.bindToggleFav()
    this.setupDescription()
    this.setupSplide()
    this.setupGallery()
    this.observeFixedBar()
    this.positionFixedBar()
    this.setFixedBarMedia()
    this.formatPrice()
    this.bindGalleryZoom()

    setTimeout(() => {
      this.formatPrice()
    }, 2000);
  }

  // Gallery
  setupDesktopGallery() {
    for (const gallery of this.galleryDesktopArr) {
      const thumbs = [...gallery.querySelector('.product__thumb-gallery').querySelectorAll('.product-media')]
      const media = [...gallery.querySelector('.product__main-gallery').querySelectorAll('.product-media')]

      if (thumbs.length && media.length) {
        thumbs.forEach((thumb, index) => {
          thumb.addEventListener('click', () => {
            media.forEach(el => el.style.display = 'none')
            media[index].style.display = 'block'
          })
        })
      }
    }
  }
  setupMobileGallery() {
    for (const gallery of this.galleryMobileArr) {
      const mainSplide = gallery.querySelector('.product__main-gallery.splide')
      const thumbsSplide = gallery.querySelector('.product__thumb-gallery.splide')

      if (mainSplide && thumbsSplide) {
        const main = new Splide(mainSplide, {
          type: "loop",
          perPage: 1,
          perMove: 1,
          gap: 8,
          arrows: false,
          pagination: false,
          speed: 750,
          breakpoints: {
            991: {
              perPage: 2
            },
            767: {
              perPage: 1.5
            },
            479: {
              perPage: 1
            }
          }
        })

        const thumbs = new Splide(thumbsSplide, {
          rewind: true,
          pagination: false,
          arrows: false,
          cover: true,
          isNavigation: true,
          fixedWidth: 38,
          gap: 4
        })
        main.sync(thumbs)
        main.mount()
        thumbs.mount()
      }
    }
  }
  setupGallery() {
    if (window.innerWidth > 991) {
      this.setupDesktopGallery()
    } else {
      this.setupMobileGallery()
    }
  }

  // Methods
  setActiveOptionsText() {
    for (const option of this.optionsArr) {
      const holder = option.querySelector('.product-option__head-right')
      const activeBtn = option.querySelector('.option-btn.is-active') || option.querySelector('.option-btn.active')

      if (holder && activeBtn) {

        const textContent = activeBtn.textContent

        if (textContent.length) {
          const selectedElem = createElem('div', {
            className: 'product-option-current',
            innerHTML: textContent
          })

          holder.prepend(selectedElem)
        }
      }
    }
  }
  setActiveColor(color) {
    const currentElem = document.querySelector('[data-current-color]')
    if (currentElem) {
      currentElem.innerHTML = color
    }
  }
  setActiveColorPickElem(elem) {
    this.colorPickArr.forEach((pick) => {
      if (pick === elem) {
        pick.classList.add('--active')
      } else {
        pick.classList.remove('--active')
      }
    })
  }
  setupDescription() {
    if (this.description) {
      const textContent = this.description.textContent

      const extractLastParagraph = () => {
        let elements = this.description.querySelectorAll('p, div, li')
        let holder = document.querySelector('#itemDetails')

        if (holder) {
          for (let element of elements) {
            if (
              element.textContent.trim().startsWith("These pieces are handcrafted and")
              ||
              element.textContent.trim().startsWith("This piece is handcrafted and")
            ) {
              holder.appendChild(element);
              element.classList.add('product__more-typo')
              break
            }
          }
        }
      }
      extractLastParagraph()
    }
  }
  setupSplide() {
    const splideArr = [...document.querySelectorAll('.more-row__splide')]
    for (const el of splideArr) {
      let main = new Splide(el, {
        type: "loop",
        perPage: 4,
        perMove: 1,
        autoplay: 0,
        gap: "8px",
        arrows: 1,
        pagination: 0,
        speed: 750,
        breakpoints: {
          1980: {
            perPage: 5,
            perMove: 1,
          },
          1680: {
            perPage: 4,
            perMove: 1,
          },
          1120: {
            perPage: 4,
            perMove: 1,
          },
          991: {
            perPage: 4,
            perMove: 1,
          },
          767: {
            grid: {
              rows: 2,
              cols: 3,
              gap: { row: "10px", col: "8px" },
            },
          },
          478: {
            grid: {
              rows: 2,
              cols: 2,
              gap: { row: "24px", col: "8px" },
            },
          },
        },
      }).mount(window.splide.Extensions)
    }
  }

  // Option Modal
  revertOptions() {
    const body = this.optionModal.querySelector('.product-option__body')
    const guideBtn = this.optionModal.querySelector('.option-guide-btn')
    const emptyOption = this.optionsArr.find(option => !option.querySelector('.product-option__body'))
    const input = this.optionModal.querySelector('input[type="hidden"]')


    if (body && emptyOption) {
      if (guideBtn) {
        body.append(guideBtn)
      }
      if (input) {
        emptyOption.append(input)
      }
      emptyOption.append(body)
    }
  }
  appendOption(option = this.optionsArr[0]) {
    this.revertOptions()
    if (option) {
      const optionName = option.querySelector('.product-option-name')
      const currentIndex = this.optionsArr.indexOf(option)
      this.activeOptionIndex = currentIndex
      const nextOption = this.optionsArr[currentIndex + 1] || this.optionsArr[0]
      const nextOptionName = nextOption.querySelector('.product-option-name')
      const body = option.querySelector('.product-option__body')
      const input = option.querySelector('input[type="hidden"]')

      const guideBtn = option.querySelector('.option-guide-btn')
      const modalWrapper = this.optionModal.querySelector('.option-modal__wrapper')

      if (body) {
        this.optionModalName.innerHTML = optionName.textContent
        this.optionModalNextElem.innerHTML = nextOptionName.textContent
        this.optionModalContent.appendChild(body)

        if (input) {
          this.optionModalContent.appendChild(input)
        }

        if (guideBtn && modalWrapper) {
          modalWrapper.append(guideBtn)
        }
      }
    }
  }
  bindOptionModalEvents() {
    this.evtNextOption.addEventListener('click', () => {
      this.appendOption(this.optionsArr[this.activeOptionIndex + 1] || this.optionsArr[0])
    })
    this.evtCloseOptionModalArr.forEach((elem) => {
      elem.addEventListener('click', () => {
        this.closeOptionModal()
      })
    })
  }
  bindOptionToggleMobile() {
    for (const option of this.optionsArr) {
      const head = option.querySelector('.product-option__head')
      const body = option.querySelector('.product-option__body')

      if (head && body) {
        head.addEventListener('click', () => {
          this.appendOption(option)
          this.showOptionModal()
        })
      }
    }
  }
  showOptionModal() {
    lockScroll()
    window.optionModalBackdrop = new Backdrop({
      half: true,
      callback: () => { this.closeOptionModal() }
    })
    this.optionModal.classList.add('--visible')
  }
  closeOptionModal() {
    unlockScroll()
    this.optionModal.classList.remove('--visible')
    setTimeout(() => {
      this.optionModal.removeAttribute('style')
      this.revertOptions()
    }, getTransitionTime(this.optionModal));
    if (window.optionModalBackdrop) {
      window.optionModalBackdrop.hide(true)
    }
  }
  bindPullDown() {
    let startY = 0;
    let currentY = 0;
    let isDragging = false;
    let isMovingRoot = false;
    const rootEl = this.optionModal;
    const scroller = document.querySelector('.option-modal__content')
    const handler = document.querySelector('.option-modal__header')
    const transition = 'all 0.4s cubic-bezier(0.39, 0.575, 0.565, 1)'

    rootEl.addEventListener('touchstart', (e) => {
      const target = e.target;

      const isOnHandler = handler.contains(target) || target === handler;

      startY = e.touches[0].clientY;
      isDragging = true;
      isMovingRoot = false;

      this.isOnHandler = isOnHandler;
    }, { passive: false });

    rootEl.addEventListener('touchmove', (e) => {
      if (!isDragging) return;

      currentY = e.touches[0].clientY;
      let diffY = currentY - startY;

      rootEl.style.transition = 'none';

      if (diffY > 0) {
        if (this.isOnHandler) {
          if (!isMovingRoot) {
            isMovingRoot = true;
          }
          if (e.cancelable) {
            e.preventDefault();
          }
          rootEl.style.transform = `translateY(${diffY}px)`;
        } else {
          if (scroller.scrollTop === 0) {
            if (!isMovingRoot) {
              isMovingRoot = true;
            }
            if (e.cancelable) {
              e.preventDefault();
            }
            rootEl.style.transform = `translateY(${diffY}px)`;
          }
        }
      }
    }, { passive: false });

    rootEl.addEventListener('touchend', () => {
      if (!isDragging) return;
      isDragging = false;

      if (isMovingRoot) {
        let diffY = currentY - startY;
        let hideOffset = rootEl.offsetHeight * 0.3;
        rootEl.style.transition = transition;

        if (diffY > hideOffset) {
          this.closeOptionModal();
          rootEl.style.transform = `translateY(100%)`;
        } else {
          rootEl.removeAttribute('style');
        }
      }
    });
  }

  // Methods - Options
  hideAllOptions(exclude = null) {
    this.optionsArr.forEach(option => {
      if (option !== exclude) {
        this.hideOption(option)
      } else {
        this.showOption(option)
      }
    })
    if (exclude == null) {
      this.optionsRow.classList.remove('--active')
    }
  }
  showOption(option) {
    option.classList.add('--active')
  }
  hideOption(option) {
    option.classList.remove('--active')
  }

  // Price
  formatPrice() {
    const priceArr = [...document.querySelectorAll('.product__item-price')]

    for (const elem of priceArr) {
      const text = elem.textContent
      const containsDollar = text.includes('$')
      const parentBar = elem.closest('.fixed-bar')

      if (containsDollar && !parentBar) {
        const price = text.replace('$', '')
        elem.innerHTML = `<span class="dollar-symbol">$</span>${price.replace(/\s/g, '')}`
      }
    }
  }

  // Bind Events
  bindOptionToggleDesktop() {
    for (const option of this.optionsArr) {
      const head = option.querySelector('.product-option__head')
      const btnArr = [...option.querySelectorAll('.option-btn')]
      if (head) {
        head.addEventListener('click', () => {
          return
          if (option.classList.contains('--active')) {
            this.hideOption(option)
          } else {
            this.hideAllOptions(option)
            this.showOption(option)
          }
        })
        this.showOption(option)
      }
      // this.showOption(option)
    }

    // document.addEventListener('click', (e) => {
    //   const target = e.target
    //   if (!target.closest('.product__item-option')) {
    //     this.hideAllOptions()
    //   }
    // })
  }
  bindOptionButtonClick() {
    for (const option of this.optionsArr) {
      const btnArr = [...option.querySelectorAll('.option-btn')]
      const selectedElem = option.querySelector('.product-option-current')

      if (btnArr.length) {
        for (const btn of btnArr) {
          btn.addEventListener('click', () => {
            if (!btn.classList.contains('disabled')) {
              const textContent = btn.textContent.trim()
              if (textContent.length) {
                if (selectedElem) {
                  selectedElem.innerHTML = textContent
                }
              }

              btnArr.forEach(el => el.classList.remove(IS_ACTIVE))
              btn.classList.add(IS_ACTIVE)
            }
          })
        }
      }
    }
  }
  bindOptionButtonClickInputValue() {
    const btnArr = [...document.querySelectorAll('.option-btn')]
    for (const btn of btnArr) {
      btn.addEventListener('click', () => {
        const value = btn.dataset.value
        if (!value) throw new Error('data-value attribute is required')

        const parent = btn.closest('.product__item-option') || btn.closest('.option-modal__content')
        if (!parent) throw new Error('parent element is required')

        const input = parent.querySelector('.custom-fields-fetch')
        if (!input) throw new Error('custom-fields-fetch element is required')


        input.value = value
        const event = new Event('change', { bubbles: true })
        input.dispatchEvent(event)
        this.closeOptionModal()
      })
    }
  }
  bindColorPick() {
    this.colorPickArr.forEach((btn) => {
      btn.addEventListener('click', () => {
        const attr = btn.dataset.color
        if (attr) {
          this.setActiveColor(attr)
          this.setActiveColorPickElem(btn)

          if (this.fixedBar) {
            this.fixedBar.classList.remove('--filled')
          }
        }
      })
    })
  }
  bindToggleRow() {
    this.toggleRowArr.forEach((row) => {
      const head = row.querySelector('.toggle-row__head')
      const body = row.querySelector('.toggle-row__body')
      const wrapper = row.querySelector('.toggle-row__wrapper')

      if (head && body && wrapper) {
        head.addEventListener('click', () => {
          const scrollHeight = wrapper.scrollHeight
          const isActive = body.offsetHeight > 0 && row.classList.contains('--active')

          if (isActive) {
            body.style.height = `0px`
            row.classList.remove('--active')
          } else {
            body.style.height = `${scrollHeight}px`
            row.classList.add('--active')
          }
        })
      }
    })
  }
  bindToggleFav() {
    if (this.favBtn) {
      this.favBtn.addEventListener('click', () => {
        this.favBtn.classList.toggle('is-active')
      })
    }
  }
  bindGalleryZoom() {
    const galleryArr = [...document.querySelectorAll('#gallery_mobile .product__main-gallery')]
    for (const gallery of galleryArr) {
      gallery.addEventListener('click', (event) => {
        const mediaClicked = event.target.closest('.product-media')
        if (window.innerWidth < 480 && mediaClicked) {

          if (this.galleryZoomInstance) {
            this.galleryZoomInstance.destroy()
            this.galleryZoomInstance = null
          }

          const list = gallery.querySelector('.splide__list')
          if (list) {
            const mediaArr = [...list.querySelectorAll('.product-media:not(.splide__slide--clone)')]
            this.galleryZoomInstance = new ZoomGallery(mediaArr)
          }
        }
      })
    }
  }

  // Fixed Bar
  positionFixedBar() {
    const header = document.querySelector('header')
    if (header && this.fixedBar && this.fixedBarTrigger) {
      this.fixedBar.style.display = 'block'

      const update = () => {
        if (window.innerWidth > 991) {
          this.fixedBar.style.zIndex = -1
          this.fixedBar.style.position = 'absolute'
          this.fixedBar.style.top = '100%'
          if (!header.contains(this.fixedBar)) {
            header.appendChild(this.fixedBar)
          }
        } else {
          const headerZIndex = window.getComputedStyle(header).getPropertyValue('z-index')
          this.fixedBar.style.zIndex = parseInt(headerZIndex, 10) - 1
          this.fixedBar.style.top = 'auto'
          this.fixedBar.style.position = 'fixed'
          if (!document.body.contains(this.fixedBar)) {
            document.body.appendChild(this.fixedBar)
          }
        }
      }

      window.addEventListener('resize', update)
      update()
    }
  }
  observeFixedBar() {
    const triggerElem = this.fixedBarTrigger;
    const bar = this.fixedBar;
    let header = document.querySelector('header');

    if (triggerElem && bar) {
      let headerOffset = header ? header.offsetHeight : 0;
      let observer = null;

      const updateObserver = () => {
        headerOffset = header ? header.offsetHeight : 0;

        if (observer) {
          observer.disconnect();
        }

        const observerCallback = (entries) => {
          entries.forEach(entry => {
            if (!entry.isIntersecting && entry.boundingClientRect.top < 0) {
              bar.classList.add(__VISIBLE);
              this.setFixedBarMedia();
            } else {
              bar.classList.remove(__VISIBLE);
            }
          });
        };

        observer = new IntersectionObserver(observerCallback, {
          root: null,
          rootMargin: `-${headerOffset}px 0px 0px 0px`,
          threshold: 0
        });

        observer.observe(triggerElem);
      };

      updateObserver();

      window.addEventListener('resize', updateObserver);
    }
  }
  setFixedBarMedia() {
    if (this.fixedBar) {

      if (!this.fixedBar.querySelector('img')) {
        this.fixedBar.classList.remove('--filled')
      }

      const visibleGallery = [...document.querySelectorAll('.product__gallery')].find((el) => {
        return window.getComputedStyle(el).getPropertyValue('display') !== 'none'
      })

      if (visibleGallery) {
        const mainGallery = visibleGallery.querySelector('.product__main-gallery')
        const fixedBarMedia = document.querySelector('.fixed-bar__media')

        if (mainGallery && fixedBarMedia) {
          const image = mainGallery.querySelector('img')
          const fixedBarImage = fixedBarMedia.querySelector('img')

          if (image) {
            if (!fixedBarImage) {
              const newImg = document.createElement('img')
              newImg.src = image.src
              fixedBarMedia.appendChild(newImg)
            } else {
              fixedBarImage.src = image.src
            }

            this.fixedBar.classList.add('--filled')
          }
        }
      }
    }
  }
}

module.exports = ProductPage
},{"../dynamic/zoom-gallery":17}],48:[function(require,module,exports){
const CareModal = require('../modals/care-modal')

class ResultsPage {
  constructor() {
    this.rootEl = document.querySelector('.main_results');
    this.filterBoxArr = [...document.querySelectorAll('.page-filter-box')];
    this.filterModal = document.querySelector('.filter-modal');
    this.cardsGrid = document.querySelector('.cards-grid');
    this.filterModalActive = false;
    this.filters = {};
    this.careModalInstance = null
    this.init();
  }

  // Methods
  showFilterModal() {
    lockScroll();
    window.filterModalBackdrop = new Backdrop({
      half: true,
      callback: () => { this.hideFilterModal(); }
    });

    this.filterModal.style.display = "flex";
    setTimeout(() => {
      this.filterModal.style.transform = "translateY(0)";
    }, 3);
  }

  hideFilterModal() {
    unlockScroll();
    if (window.filterModalBackdrop) {
      window.filterModalBackdrop.hide(true);
    }
    this.filterModal.style.transform = "translateY(100%)";
    setTimeout(() => {
      this.filterModal.style.display = "none";
    }, getTransitionTime(this.filterModal));
  }

  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout)
        func(...args)
      }
      clearTimeout(timeout)
      timeout = setTimeout(later, wait)
    };
  }


  observeFilters() {
    for (const filter in this.filters) {
      if (this.filters.hasOwnProperty(filter)) {
        const { btnArr, list } = this.filters[filter];

        const radios = [...list.querySelectorAll('input[type="radio"]')];
        const checkboxes = [...list.querySelectorAll('input[type="checkbox"]')];
        const links = [...list.querySelectorAll('a')];

        const isFilled = radios.some(radio => radio.checked) ||
          checkboxes.some(checkbox => checkbox.checked) ||
          links.some(link => link.classList.contains('is-active'));

        btnArr.forEach(btn => btn.classList.toggle('--filled', isFilled));
      }
    }
  }

  // Desktop
  setupDesktopFilters() {
    this.filterBoxArr.forEach((box, index) => {
      const btn = box.querySelector('.page-filter-btn');
      const drop = box.querySelector('.page-filter-drop');
      const optionsArr = drop.querySelector('a') ? [...drop.querySelectorAll('a')] : [...drop.querySelectorAll('label')];

      if (optionsArr.length) {
        this.filters[index] = { btnArr: [btn], list: drop };

        optionsArr.forEach(option => {
          option.addEventListener('change', () => {
            this.observeFilters()

            const input = option.querySelector('input');
            if (input) {
              if (input.type === 'radio') {
                box.classList.remove('--focused');
              }
            }
          });
        });
      }

      btn.addEventListener('click', () => {
        const isFocused = box.classList.contains('--focused');
        this.filterBoxArr.forEach(el => el.classList.remove('--focused'));
        if (!isFocused) box.classList.add('--focused');
      });
    });

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.page-filter-box')) {
        this.filterBoxArr.forEach(box => box.classList.remove('--focused'));
      }
    });
  }

  // Mobile
  setupMobileFilters() {
    const filterList = document.querySelector('.filter-modal__filter-list');
    const optionsHolder = document.querySelector('.filter-modal__options');
    let filterBtnArr = [];
    let listsArr = [];

    this.filterBoxArr.forEach((filter, index) => {
      const btn = filter.querySelector('.page-filter-btn');
      const drop = filter.querySelector('.page-filter-drop');
      const optionsArr = drop.querySelector('a') ? [...drop.querySelectorAll('a')] : [...drop.querySelectorAll('label')];

      if (!optionsArr.length) return;

      optionsArr.forEach(option => {
        option.addEventListener('change', () => this.observeFilters());
      });

      const displayName = this.getFilterDisplayName(btn, filter);
      const filterModalButton = this.createFilterButton(displayName);
      const list = this.createFilterList(optionsArr);

      filterList.appendChild(filterModalButton);
      optionsHolder.appendChild(list);

      filterBtnArr.push(filterModalButton);
      listsArr.push(list);

      this.setupFilterModalButtonBehavior(filterModalButton, list, filterBtnArr, listsArr);
      this.setupFilterObject(index, btn, filterModalButton, list);
      this.bindFilterButtonClick(btn, filterModalButton, list, filterBtnArr, listsArr);
    });
  }

  getFilterDisplayName(btn, filter) {
    const filterId = filter.id ? filter.id : null;
    const btnSpan = btn.querySelector('span');
    const rawName = (filterId && btnSpan) ? btnSpan.innerText.toLowerCase() : 'Sort By';
    return (rawName.includes('subcategories') || rawName.includes('subcategory')) ? 'Subcategories' :
      (rawName.includes('price') || rawName.includes('price range')) ? 'Price' : rawName;
  }

  createFilterButton(displayName) {
    return createElem('button', {
      className: 'filter-modal__filter-btn',
      innerHTML: `<span>${displayName}</span>`
    });
  }

  createFilterList(optionsArr) {
    const list = createElem('div', {
      className: 'filter-modal__options-list',
      style: { display: 'none' }
    });
    optionsArr.forEach(el => list.appendChild(el));
    return list;
  }

  setupFilterModalButtonBehavior(filterModalButton, list, filterBtnArr, listsArr) {
    filterModalButton.addEventListener('click', () => {
      filterBtnArr.forEach(btn => btn.classList.toggle('--active', btn === filterModalButton));
      listsArr.forEach(l => l.style.display = (l === list) ? 'block' : 'none');
    });
  }

  setupFilterObject(index, btn, filterModalButton, list) {
    this.filters[index] = { btnArr: [btn, filterModalButton], list: list };
  }

  bindFilterButtonClick(btn, filterModalButton, list, filterBtnArr, listsArr) {
    btn.addEventListener('click', () => {
      this.showFilterModal();
      filterBtnArr.forEach(btn => btn.classList.remove('--active'));
      listsArr.forEach(l => l.style.display = 'none');
      filterModalButton.classList.add('--active');
      list.style.display = 'block';
    });
  }

  unwrapFilters() {
    const groups = [...document.querySelectorAll('.page-filters__group')];
    groups.forEach(group => {
      while (group.firstChild) {
        group.parentNode.insertBefore(group.firstChild, group);
      }
      group.remove();
    });
  }

  bindTouchEvents() {
    let startY = 0;
    let currentY = 0;
    let isDragging = false;

    const container = this.filterModal;
    const handler = this.filterModal.querySelector('.filter-modal__header');

    handler.addEventListener('touchstart', (e) => {
      startY = e.touches[0].clientY;
      isDragging = true;
      container.style.transition = 'none';
    });

    handler.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      currentY = e.touches[0].clientY;
      let diffY = currentY - startY;

      if (diffY > 0) {
        container.style.transform = `translateY(${diffY}px)`;
      }
    });

    handler.addEventListener('touchend', () => {
      if (!isDragging) return;
      isDragging = false;

      let diffY = currentY - startY;
      let hideOffset = container.offsetHeight * 0.5;
      container.style.transition = 'all .35s ease';

      if (diffY > hideOffset) {
        this.hideFilterModal();
      } else {
        container.style.transform = `translateY(0%)`;
      }
    });
  }

  bindClickEvents() {
    const closeArr = [...document.querySelectorAll('[data-evt="closeFilterModal"]')];
    closeArr.forEach(close => {
      close.addEventListener('click', () => this.hideFilterModal());
    });
  }

  formatGoldChainsSubheading() {
    const subheading = document.querySelector('.results__subheading')
    if (subheading) {
      const text = 'Welcome to our collection of fine 14k solid gold chains, where luxury meets affordability'
      if (subheading.innerHTML.includes(text)) {
        const sentences = subheading.innerHTML.split('.').filter(sentence => sentence.trim() !== '')
        if (sentences[0] === text) {
          subheading.innerHTML = `
          <strong>${text}.</strong>
          ${sentences.slice(1).join('. ')}
          `
        }
      }
    }
  }

  setStickyBar() {
    const bar = document.querySelector('.page-filters');
    if (!bar) return;

    let topOffset = 0;

    const topBanner = document.querySelector('.top-banner');
    const header = document.querySelector('.header');

    if (topBanner) {
      if (window.getComputedStyle(topBanner).position === 'sticky') {
        const bannerHeight = topBanner.offsetHeight;
        if (bannerHeight > 0) {
          topOffset += bannerHeight;
        }
      }
    }

    if (header) {
      topOffset += header.offsetHeight;
    }

    if (topOffset > 0) {
      bar.style.position = 'sticky';
      bar.style.top = `${topOffset}px`;
    }
  }

  adjustStickyBarOnResize() {
    window.addEventListener('resize', this.debounce(() => {
      this.setStickyBar();
    }, 100))
  }

  formatFilterTitles() {
    const arr = [...document.querySelectorAll('.page-filter-btn')]
    for (const btn of arr) {
      const span = btn.querySelector('span:first-child')
      if (span) {
        const rawName = span.innerText.toLowerCase()
        const name = (rawName.includes('subcategories') || rawName.includes('subcategory')) ? 'Subcategories' :
          (rawName.includes('price') || rawName.includes('price range')) ? 'Price' : rawName;

        if (name.toLowerCase() !== rawName.toLowerCase()) {
          span.innerText = name
        }
      }
    }
  }

  // View
  switchView(mode) {
    if (!this.cardsGrid) return

    const isLess = mode === 'less'
    this.cardsGrid.classList.add('--hidden')

    setTimeout(() => {
      this.cardsGrid.classList.toggle('--less', isLess)
      setTimeout(() => {
        this.cardsGrid.classList.remove('--hidden')
      }, 100)
    }, getTransitionTime(this.cardsGrid))
  }

  bindViewSwitch() {
    const buttons = {
      more: document.querySelector('[data-results-evt="viewMore"]'),
      less: document.querySelector('[data-results-evt="viewLess"]')
    };

    const toggleView = (activeBtn, inactiveBtn, mode) => {
      if (!activeBtn.classList.contains('is-active')) {
        activeBtn.classList.add('is-active');
        inactiveBtn.classList.remove('is-active');
        this.switchView(mode);
      }
    };

    if (buttons.more && buttons.less) {
      buttons.more.addEventListener('click', () => toggleView(buttons.more, buttons.less, 'more'));
      buttons.less.addEventListener('click', () => toggleView(buttons.less, buttons.more, 'less'));
    }
  }

  // Other
  bindCareModal() {
    if (document.querySelector('.care-modal')) {
      this.careModalInstance = new CareModal()
    }
  }

  init() {
    if (window.innerWidth > 991) {
      this.setupDesktopFilters();
    } else {
      this.setupMobileFilters();
      this.unwrapFilters();
      this.bindTouchEvents();
      this.bindClickEvents();
    }
    this.observeFilters();
    this.formatGoldChainsSubheading()
    this.setStickyBar()
    this.adjustStickyBarOnResize()
    this.formatFilterTitles()
    this.bindViewSwitch()
    this.bindCareModal()
  }
}

module.exports = ResultsPage;
},{"../modals/care-modal":29}],49:[function(require,module,exports){
const sellPage = {
  faqItems: [...document.querySelectorAll('.sell-faq-item')],
  init: function () {
    if (this.faqItems.length) {
      this.attachFaq()
      $('.sell-faq-item__main').eq(0).trigger('click')
    }
  },
  attachFaq: function () {
    this.faqItems.forEach((el, index) => {
      $(el).click(function () {
        let main = $(this).find('.sell-faq-item__main'),
          p = $(this).find('p'), svg = $(this).find('svg')
        if (main.height() == 0) {
          $(this).addClass(IS_ACTIVE)
          main.css({ height: `${p[0].scrollHeight}px` })
          svg.css({ transform: 'rotate(180deg)' })
        } else {
          $(this).removeClass(IS_ACTIVE)
          main.css({ height: `0px` })
          svg.css({ transform: 'rotate(0deg)' })
        }
      })
    })
  }
}

module.exports = sellPage
},{}],50:[function(require,module,exports){
class SellWatch {
  constructor() {
    this.form = document.querySelector('form#sell_my_watch')
    if (!this.form) {
      return
    }
    this.sectionsArr = [...document.querySelectorAll('[data-ask-section]')]
    this.progressBar = document.querySelector('.ask-page__progress-bar')
    this.currentStepElem = document.querySelector('[data-step-current]')
    this.countStepElem = document.querySelector('[data-step-count]')
    this.contentContainer = document.querySelector('.ask-page__quiz-content')
    this.adjustContainer = document.querySelector('.ask-page__quiz-adjust')

    this.focusedEl = undefined
    this.watchBrand = {
      name: undefined
    }
    this.uploadInput = this.form.querySelector('input[type="file"]')
    this.regExp = {
      rolex: /\brolex\b/i,
      audemars: /\baudemars\b/i,
      richard: /\brichard\b/i,
      patek: /\bpatek\b/i,
      cartier: /\bcartier\b/i,
      breitling: /\bbreitling\b/i
    }

    this.locked = false
    this.steps = this.sectionsArr.length
    this.currentStep = 1
    this.activeSection = this.sectionsArr[0]
    this.endReached = false
    this.atTheStart = true
    this.init()
  }

  /**
   * Getters
   */
  get getActiveSection() {
    return this.activeSection
  }
  get getCurrentStep() {
    return this.currentStep
  }
  get getFocusedEl() {
    return this.focusedEl
  }

  /**
   * Methods
   */
  toggleSectionStatus(section, condition) {
    if (condition === false) {
      section.classList.remove(__VALID)
    } else {
      section.classList.add(__VALID)
    }
    const btn = [...section.querySelectorAll('[data-sell-evt="next"]')]
    btn.forEach(btn => btn.disabled = !condition)
  }
  validateSection(section) {
    section = this.getActiveSection

    const
      requiredArr = [...section.querySelectorAll('[required]:not([disabled])')],
      radioArr = [...section.querySelectorAll('input[type="radio"]:not([disabled])')],
      checkboxArr = [...section.querySelectorAll('input[type="checkbox"]:not([disabled])')],
      inputArr = [...section.querySelectorAll('input:not([type="checkbox"]):not([type="radio"])')],
      selectArr = [...section.querySelectorAll('select[required]')],
      phoneArr = [...section.querySelectorAll('[data-validate="phone"]')],
      fileArr = [...section.querySelectorAll('input[type="file"]')]

    const radioArrByName = Array.from(
      new Set(radioArr.map(radio => radio.name)),
      name => radioArr.filter(radio => radio.name === name)
    )

    if (requiredArr.some(input => !input.value)) {
      this.toggleSectionStatus(section, false)
      return false
    }

    for (const radioGroup of radioArrByName) {
      if (radioGroup.every(radio => !radio.checked)) {
        this.toggleSectionStatus(section, false)
        return false
      }
    }

    if (checkboxArr.length && checkboxArr.every(checkbox => !checkbox.checked)) {
      this.toggleSectionStatus(section, false)
      return false
    }

    if (phoneArr.length) {
      for (const input of phoneArr) {
        const value = input.value
        const valueDigits = value.replace(/\D/g, '').length
        const regex = /^\+\d{1}\s\(\d{3}\)\s\d{3}\-\d{4}$/
        if (!regex.test(value) && valueDigits < 11) {
          this.toggleSectionStatus(section, false)
          return false
        }
      }
    }

    for (const fileInput of fileArr) {
      const files = fileInput.files
      if (!files.length) {
        this.toggleSectionStatus(section, false)
        return false
      }
    }

    this.toggleSectionStatus(section, true)
    return true
  }
  arrangeModels(string) {
    const
      inputArr = [...this.form.querySelectorAll('input[type="radio"][name="model"]')],
      groupInputArr = inputArr.filter(input => input.dataset.group),
      filteredArr = groupInputArr.filter(input => { return string.toLowerCase().includes(input.dataset.group) }),
      modelGrid = this.form.querySelector('[data-sell-grid="model"]'),
      modelInput = this.form.querySelector('input#watch_model'),
      modelInputParent = modelInput.closest('.survey-box__named-grid')

    inputArr.forEach(input => input.checked = false)
    // inputArr.forEach(input => input.dispatchEvent(new Event('change')))
    modelInput.value = ''
    modelInput.dispatchEvent(new Event('input'))

    if (!filteredArr.length) {
      modelGrid.style.display = 'none'
      modelInputParent.style.display = 'flex'
      modelInput.disabled = false
      inputArr.forEach(input => {
        input.disabled = true
        input.checked = false
        // input.dispatchEvent(new Event('change'))
      })
    } else {
      modelGrid.style.display = 'flex'
      modelInputParent.style.display = 'none'
      modelInput.disabled = true
      inputArr.forEach(input => {
        const label = input.closest('label')
        input.disabled = false
        input.checked = false
        if (!filteredArr.includes(input) && input.value !== 'Other') {
          if (input.value) {
            label.style.display = 'none'
          }
        } else {
          label.style.display = 'block'
        }
        // input.dispatchEvent(new Event('change'))
      })
    }
  }

  /**
   * Utils
   */
  observeStepsElements() {
    this.currentStepElem.innerHTML = this.currentStep
  }
  observeBarElements() {
    const elements = this.progressBar.querySelectorAll('span')
    elements.forEach((element, index) => {
      if (index < this.currentStep) {
        element.classList.add(__ACTIVE)
      } else {
        element.classList.remove(__ACTIVE)
      }
    })
  }
  scrollToForm() {
    if (this.form) {
      const headerHeight = parseInt(window.getComputedStyle(document.querySelector('header')).getPropertyValue('height'))
      const boundTop = this.form.getBoundingClientRect().top
      if ((boundTop - headerHeight) < -30) {
        const distance = (window.scrollY + this.form.getBoundingClientRect().top) - (headerHeight + 70)
        zenscroll.toY(distance)
      }
    }
  }
  dispatchFocusEvent(elem) {
    if (elem) {
      const tag = elem.tagName
      switch (tag) {
        case 'INPUT' || 'TEXTAREA':
          const type = elem.type
          if (type === 'radio' || type === 'checkbox') {
            elem.click()
          } else {
            if (type === 'file') {
              elem.click()
            } else {
              elem.focus()
            }
          }
          break;
        case 'SELECT':
          elem.focus()
          break;
        default:
          elem.dispatchEvent(new Event('focus'))
          break;
      }
    }
  }

  /**
   * Events
   */
  slide(section, activeSection, number) {
    const sectionIndex = this.sectionsArr.indexOf(section)
    const activeSectionIndex = this.sectionsArr.indexOf(activeSection)

    let fromTranslate = 'translateY(24px)'
    let toTranslate = 'translateY(-24px)'

    if (activeSectionIndex > sectionIndex) {
      fromTranslate = 'translateY(-24px)'
      toTranslate = 'translateY(24px)'

      const inputs = [...activeSection.querySelectorAll('input')]
    }

    this.locked = true
    activeSection.style.opacity = 0
    activeSection.style.pointerEvents = 'none'
    activeSection.style.transform = toTranslate
    section.style.opacity = 0
    section.style.pointerEvents = 'none'
    section.style.transform = fromTranslate
    setTimeout(() => {
      activeSection.style.display = 'none'
      activeSection.classList.remove(__ACTIVE)
      section.style.display = 'flex'
      section.classList.add(__ACTIVE)
      setTimeout(() => {
        section.style.opacity = 1
        section.style.transform = 'translateY(0px)'
        section.style.pointerEvents = 'auto'

        this.locked = false
        this.activeSection = section
        this.currentStep = number
        this.observeStepsElements()
        this.observeBarElements()

        if (section === this.sectionsArr[this.sectionsArr.length - 1]) {
          this.form.submit()
        }
      }, 30)
    }, getTransitionTime(activeSection))
  }
  finish() {
    const confetti = new PageConfetti()
    confetti.push()
  }
  go(number) {
    if (!this.locked) {
      const section = this.sectionsArr[number - 1]
      const activeSection = this.getActiveSection

      if (!section) {
        const error = number < 1 ? 'Section number cannot be less than 1' : 'Section number cannot be greater than ' + this.sectionsArr.length
        throw new Error(error)
      }
      if (!activeSection) {
        throw new Error('No active section')
      }

      if (section !== activeSection) {
        this.slide(section, activeSection, number)
        this.scrollToForm()
        this.focusedEl = undefined
      }
    }
  }


  /**
   * Bind Events
   */
  bindToggleStepsControls() {
    for (const section of this.sectionsArr) {
      const inputs = [...section.querySelectorAll('input, select')]
      inputs.forEach((input) => {
        const isCheckboxOrRadio = input.type === 'checkbox' || input.type === 'radio' || input.type === 'file'
        if (isCheckboxOrRadio) {
          input.addEventListener('change', (e) => {
            this.validateSection(section)
          })
        } else {
          input.addEventListener('input', (e) => {
            this.validateSection(section)
          })
        }
      })
    }
  }
  bindDualSelect() {
    const dualArr = [...this.form.querySelectorAll('input[data-dual]')]
    for (const input of dualArr) {
      const
        name = input.name,
        dualName = input.dataset.dual,
        nameInputArr = [...this.form.querySelectorAll(`input[name="${name}"]`)],
        holder = this.form.querySelector(`div[data-dual="${dualName}"]`)

      if (holder) {
        const select = holder.querySelector('select, input')
        if (select) {
          nameInputArr.forEach((nameInput) => {
            nameInput.addEventListener('change', () => {
              if (input.checked) {
                select.disabled = false
                holder.style.display = 'flex'
              } else {
                select.disabled = true
                holder.style.display = 'none'
              }
            })
          })
        }
      }
    }
  }
  bindBrandSelect() {
    const brandSelectArr = [...this.form.querySelectorAll('*[name="brand"]')]
    const elsToName = [...this.form.querySelectorAll('[data-sell-brand]')]
    for (const input of brandSelectArr) {
      input.addEventListener('change', (e) => {
        if (input.disabled) return
        const value = input.value
        if (value && value.toLowerCase() !== 'other') {
          this.watchBrand.name = value
          elsToName.forEach(el => el.innerHTML = this.watchBrand.name)
        } else {
          this.watchBrand.name = undefined
          elsToName.forEach(el => el.innerHTML = 'your brand')
        }

        // Setup models
        this.arrangeModels(value)
      })
    }
  }
  bindPhoneInput() {
    const inputs = [...this.form.querySelectorAll('input[data-validate="phone"]')]
    for (const input of inputs) {
      let keyCode;
      function mask(event) {
        event.keyCode && (keyCode = event.keyCode);
        let pos = this.selectionStart;
        if (pos < 3) event.preventDefault()
        let matrix = "+1 (___) ___-____",
          i = 0,
          def = matrix.replace(/\D/g, ""),
          val = this.value.replace(/\D/g, ""),
          newValue = matrix.replace(/[_\d]/g, function (a) {
            return i < val.length ? val.charAt(i++) || def.charAt(i) : a;
          });
        i = newValue.indexOf("_");
        if (i != -1) {
          i < 5 && (i = 3);
          newValue = newValue.slice(0, i);
        }
        let reg = matrix.substr(0, this.value.length).replace(/_+/g,
          function (a) {
            return "\\d{1," + a.length + "}";
          }).replace(/[+()]/g, "\\$&");
        reg = new RegExp("^" + reg + "$");
        if (!reg.test(this.value) || this.value.length < 5 || keyCode > 47 && keyCode < 58) this.value = newValue;
        if (event.type == "blur" && this.value.length < 5) this.value = "";
      }

      input.addEventListener("input", mask, false);
      input.addEventListener("focus", mask, false);
      input.addEventListener("blur", mask, false);
      input.addEventListener("keydown", mask, false);
      input.addEventListener('mouseup', event => {
        event.preventDefault()
        if (input.value.length < 4) {
          input.setSelectionRange(4, 4)
        } else {
          input.setSelectionRange(input.value.length, input.value.length)
        }
      })
    }
  }
  bindCurrencyInput() {
    const inputArr = [...this.form.querySelectorAll('input[data-format="currency"]')]
    for (const input of inputArr) {
      input.addEventListener('blur', () => {
        if (input.value) {
          input.value = formatAsCurrency(input.value)
        }
      })
    }
  }
  bindHandlers() {
    const nextArr = [...this.form.querySelectorAll('[data-sell-evt="next"]')]
    const backArr = [...this.form.querySelectorAll('[data-sell-evt="back"]')]

    for (const btn of nextArr) {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        if (!btn.disabled) {
          this.go(this.getCurrentStep + 1)
        }
      })
    }

    for (const btn of backArr) {
      btn.addEventListener('click', (e) => {
        e.preventDefault()
        if (!btn.disabled) {
          this.go(this.getCurrentStep - 1)
        }
      })
    }
  }
  bindSetFocusedElement() {
    const inputs = [...this.form.querySelectorAll('input, select, textarea')]
    for (const input of inputs) {
      input.addEventListener('change', () => { this.focusedEl = input })
      input.addEventListener('focus', () => { this.focusedEl = input })
    }
  }
  bindKeyEvents() {
    document.addEventListener('keydown', (e) => {
      if (this.locked) return
      if (!this.getActiveSection) return

      const section = this.getActiveSection
      const key = e.key
      const keyIsTab = key === 'Tab'
      const keyIsEnter = key === 'Enter'
      const isBackspace = key === 'Backspace'

      if (isBackspace) {
        if (!document.activeElement || !document.activeElement.contains(section)) return
        const btn = section.querySelector('[data-sell-evt="back"]')
        if (btn && !btn.disabled) {
          e.preventDefault()
          btn.click()
        }
      }

      if (keyIsEnter) {
        const btn = section.querySelector('[data-sell-evt="next"]')
        if (btn) {
          e.preventDefault()
          if (!btn.disabled) {
            btn.click()
          }
        }
      }

      if (keyIsTab) {
        e.preventDefault()
        const focusedEl = this.getFocusedEl
        const inputs = [...section.querySelectorAll('input, select, textarea')].filter((input) => {
          if (!input.disabled) {
            const selectBox = input.parentNode.closest('.survey-select')
            if (selectBox) {
              if (selectBox.style.display !== 'none') {
                return input
              }
            } else {
              return input
            }
          }
        }).sort((a, b) => a.compareDocumentPosition(b) - 2)
        let elem

        if (!focusedEl) {
          elem = inputs[0]
        } else {
          const elemWithinSection = inputs.includes(focusedEl)
          if (elemWithinSection) {
            const nextElem = inputs[inputs.indexOf(focusedEl) + 1]
            if (nextElem) {
              elem = nextElem
            } else {
              elem = inputs[0]
            }
          } else {
            elem = inputs[0]
          }
        }

        this.dispatchFocusEvent(elem)
      }
    })
  }
  bindSubmit() {
    $(this.form).on('submit', function (e) {
      e.preventDefault();
      var form = $(this);
      var formData = new FormData(this);
      var actionUrl = form.attr('action');
      $.ajax({
        url: actionUrl,
        type: 'POST',
        data: formData,
        cache: false,
        contentType: false,
        processData: false,
        success: function (data) {
          var r = $.parseJSON(data);
          if (!r.error) {
            this.finish()
          } else {
            //show error message 
            alert(r.msg);
          }
        }
      })
    });
  }

  /**
   * Setup
   */
  setupBar() {
    if (this.progressBar) {
      let html = ''
      this.sectionsArr.forEach((section, index) => {
        html += `<span data-bar-id="${index}"></span>`
      })
      this.progressBar.innerHTML = html
    }
    if (this.currentStepElem && this.countStepElem) {
      this.currentStepElem.innerHTML = 1
      this.countStepElem.innerHTML = this.sectionsArr.length
    }
  }
  setup() {
    this.setupBar()
    this.go(1)
    this.observeStepsElements()
    this.observeBarElements()
    this.bindHandlers()
  }


  /**
   * Initialize
   */
  init() {
    if (this.form) {
      this.bindDualSelect()
      this.bindToggleStepsControls()
      this.bindBrandSelect()
      this.bindPhoneInput()
      this.bindCurrencyInput()
      this.bindSetFocusedElement()
      this.bindKeyEvents()
      this.bindSubmit()
      this.setup()
    }
  }
}

module.exports = SellWatch
},{}],51:[function(require,module,exports){
const tagPreview = {
  init: function () {
    try {
      if (document.querySelector('.main_print-tag') !== null) {
        this.resetOutput()
        this.attachInput()
        this.attachImageUploader()
        this.attachPreviewControls()
      }
    } catch {
      console.log('TAG PREVIEW ERR')
    }
  },
  resetOutput: function () {
    const outputHolder = document.querySelector('.tag-preview__output'),
      outputImage = document.querySelector('.tag-preview__pic')
    outputHolder.innerHTML = ''
    outputHolder.classList.add(IS_EMPTY)
    outputImage.classList.add(IS_EMPTY)
  },
  attachInput: function () {
    const outputObj = new Object(),
      inputs = [...document.querySelectorAll('input[type="text"].formpage__input')],
      outputHolder = document.querySelector('.tag-preview__output'),
      updateOutput = () => {
        let filled = 0, html = ``
        for (const key in outputObj) {
          if (outputObj.hasOwnProperty(key)) {
            const obj = outputObj[key]
            if (obj.value.length !== 0) {
              ++filled
              html += `
                <div id="${obj.id}" class="tag-output-row">
                  <span>${obj.title}</span>
                  <span>${obj.value}</span>
                </div>
                `
            }
          }
        }
        if (filled !== 0) {
          outputHolder.innerHTML = html
          outputHolder.classList.remove(IS_EMPTY)
        } else {
          outputHolder.innerHTML = ''
          outputHolder.classList.add(IS_EMPTY)
        }
      }

    inputs.forEach((input, index) => {
      outputObj[index] = {
        id: input.id,
        value: '',
        title: input.closest('.formpage__input-box').querySelector('label').innerHTML
      }

      input.oninput = () => {
        outputObj[index].value = input.value || ''
        updateOutput()
      }
      input.onkeydown = (e) => {
        const
          isEnter = e.key === 'Enter' || e.keyCode === 13,
          isBackscape = e.key === 'Backspace' || e.key === 'Delete',
          isEsc = e.key === 'Escape' || e.key === 'Esc',
          isUp = e.key === 'ArrowUp',
          isDown = e.key === 'ArrowDown',
          next = inputs[index + 1],
          prev = inputs[index - 1]

        if (isEnter || isDown) {
          if (next !== undefined) { next.focus() }
        }
        if (isBackscape) {
          if (input.value.length == 0 && prev !== undefined) { prev.focus() }
        }
        if (isEsc) {
          e.preventDefault(); input.blur()
        }
        if (isUp) {
          if (prev !== undefined) { prev.focus() }
        }
      }
      ['focus', 'blur'].forEach((ev) => {
        if (window.innerWidth <= 479) {
          const label = input.closest('.formpage__input-box').querySelector('label')
          input.addEventListener(ev, function () {
            switch (ev) {
              case 'focus':
                label.style.opacity = 0
                break;
              case 'blur':
                if (input.value.length !== 0) { label.style.opacity = 0 } else {
                  label.style.opacity = 0.5
                }
                break;
            }
          })
        }
      })

    })
  },
  attachImageUploader: function () {
    const uploadLabel = document.querySelector('#printTag_uploader'),
      uploadInput = document.querySelector('#image_upload_tag'),
      imgPreview = document.querySelector('.tag-preview__pic')

    // DRAG & DROP
    if (uploadLabel !== null) {
      uploadLabel.ondragover = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.add(IS_ACTIVE)
      }
      uploadLabel.ondragleave = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.remove(IS_ACTIVE)
      }
      uploadLabel.ondrop = (evt) => {
        evt.preventDefault()
        uploadLabel.classList.remove(IS_ACTIVE)
        $('#image_upload_tag').prop('files', evt.dataTransfer.files);
        const files = [...evt.dataTransfer.items],
          file = files.find((item) => { if (item.kind === 'file') { return item } })
        processImage(file.getAsFile())
      }

      // MANUAL
      if (uploadInput !== null) {
        uploadInput.onchange = (evt) => {
          const file = [...evt.target.files][0]
          processImage(file)
          uploadInput.value = ''
        }
      }

      // PROCESS IMAGE
      function processImage(file) {
        if (file) {
          let reader = new FileReader()
          reader.onload = (e) => {
            imgPreview.classList.remove(IS_EMPTY)
            imgPreview.style.backgroundImage = `url(${e.target.result})`
          }
          reader.readAsDataURL(file)
        }
      }

    }
  },
  attachPreviewControls: function () {
    const modal = document.querySelector('.tag-preview-modal')
    if (modal !== null) {
      const holder = document.querySelector('.tag-preview-modal__wrapper')
      const toggle = () => {
        let displayed = window.getComputedStyle(modal).getPropertyValue('display') !== 'none'
        if (displayed) {
          unlockScroll()
          const preview = holder.querySelector('.formpage__tag-preview')
          if (preview !== null) { preview.remove() }
          modal.style.display = 'none'
        } else {
          lockScroll()
          const preview = document.querySelector('.formpage__tag-preview')
          holder.appendChild(preview.cloneNode(true))
          modal.style.display = 'block'
        }
      }

      document.addEventListener('click', function (e) {
        const target = e.target
        if (target.getAttribute('data-evt') == 'togglePrintTagPreview') {
          toggle()
        }
      })
    }
  }
}

module.exports = tagPreview
},{}],52:[function(require,module,exports){
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function lockScroll() {
  setTimeout(function () {
    if (!document.body.hasAttribute("ib-scroll-lock")) {
      let o = window.pageYOffset || document.documentElement.scrollTop;
      document.body.setAttribute("ib-scroll-lock", o),
        (document.body.style.overflow = "hidden"),
        (document.body.style.position = "fixed"),
        (document.body.style.top = "-" + o + "px"),
        (document.body.style.left = "0"),
        (document.body.style.width = "100%");
    }
  }, 1);
}
function unlockScroll() {
  if (document.body.hasAttribute("ib-scroll-lock")) {
    let o = document.body.getAttribute("ib-scroll-lock");
    document.body.removeAttribute("ib-scroll-lock"),
      (document.body.style.overflow = ""),
      (document.body.style.position = ""),
      (document.body.style.top = ""),
      (document.body.style.left = ""),
      (document.body.style.width = ""),
      window.scroll(0, o);
  }
}
function elemDisplayed(elem) {
  if (!elem) return false
  let target = elem instanceof jQuery ? elem.get(0) : elem
  return window.getComputedStyle(target).getPropertyValue('display') !== 'none'
}
function createElem(tagName, options) {
  const { className, id, innerHTML, style, attributes, toAppend } = options
  const elem = document.createElement(tagName)
  if (className) elem.className = className;
  if (id) elem.id = id;
  if (innerHTML) elem.innerHTML = innerHTML;
  if (style) {
    for (const key in options.style) { elem.style[key] = options.style[key] }
  }
  if (attributes) {
    for (const key in options.attributes) { elem.setAttribute(key, options.attributes[key]) }
  }
  if (toAppend) {
    for (const child of toArray(toAppend)) { elem.appendChild(child) }
  }
  return elem
}
function removeClasses(elem, ...classes) {
  for (const cls of classes) {
    elem.classList.remove(cls)
  }
}
function addClasses(elem, ...classes) {
  for (const cls of classes) {
    elem.classList.add(cls)
  }
}
function formatAsCurrency(string) {
  string = typeof string === 'string' ? string : string.toString()
  const number = parseFloat(string.replace(/,/g, ''))
  const parts = number.toFixed(2).split('.')
  const digits = parts[0]
  const decimal = parts[1]
  const integer = digits.replace(/\B(?=(\d{3})+(?!\d))/g, ',')
  return `${integer}.${decimal}`
}
function getEvtDOM(attr) {
  return $(`[data-evt="${attr}"]`);
}
function getTransitionTime(elem) {
  let el = elem instanceof jQuery ? elem[0] : elem;
  return parseFloat(window.getComputedStyle(el).transitionDuration) * 1000;
}
function getOrdinalTxt(n) {
  return n % 10 == 1 && n % 100 != 11 ? 'st' : n % 10 == 2 && n % 100 != 12 ? 'nd' : n % 10 == 3 && n % 100 != 13 ? 'rd' : 'th'
}
function getZIndex(elem) {
  return parseInt(window.getComputedStyle(elem).getPropertyValue('z-index'))
}
function toggleAdminBar() {
  let bar = document.querySelector('.iba-toolbar')
  if (bar && bar !== null) {
    if (bar.classList.contains(IS_MINIMIZED)) {
      bar.classList.remove(IS_MINIMIZED)
    } else {
      bar.classList.add(IS_MINIMIZED)
    }
  }
}
function isEmail(email) {
  var regex = /^([a-zA-Z0-9_.+-])+\@(([a-zA-Z0-9-])+\.)+([a-zA-Z0-9]{2,4})+$/;
  return regex.test(email);
}
function saveCartEmail() {
  var email = $('#cart_email').val();
  if (email != '' && isEmail(email)) {
    $.ajax({
      type: "POST",
      url: '/json/cart-email',
      data: { email_address: email },
      success: function (data) {
        klaviyo.identify({ '$email': email });
        mailModal.close();
        showMessage('success', 'Thank you', 'Item was added to your cart.');
        $('.cart_trigger').click();
      }
    });
  } else {
    showMessage('error', 'Error', 'Please enter a valid email address !');
  }
}
function showMessage(type, title, msg) {
  var alert_type = (type === 'success') ? pageAlerts.classes.info : pageAlerts.classes.error;
  pageAlerts.showAlert(alert_type, title, msg);
}

function debounce(func, wait) {
  let timeout
  return function (...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

function showSkeleton() {
  document.body.classList.add('--skeleton')
}

function hideSkeleton() {
  document.body.classList.remove('--skeleton')
}

function openPriceModal(target, id) {
  const card = target.closest('.product-card')
  if (!card) return

  window.signPriceModal = new window.priceModal(card, id)
}

function signupPrice() {
  if (!window.signPriceModal) {
    console.warn('No price modal found')
    return
  }

  window.signPriceModal.signup()
}

/**
 * Countdown timer
 * Example of usage : 
 *    createTimer({
      daySelector: '#sale_timer_days',
      hourSelector: '#sale_timer_hours',
      minuteSelector: '#sale_timer_minutes',
      secondSelector: '#sale_timer_seconds',
      date: '2024-11-30 10:00:00'
    })
 */

function createTimer(settings = {}) {
  let { daySelector, hourSelector, minuteSelector, secondSelector, date } = settings

  const dayElem = daySelector ? [...document.querySelectorAll(daySelector)] : null
  const hourElem = hourSelector ? [...document.querySelectorAll(hourSelector)] : null
  const minuteElem = minuteSelector ? [...document.querySelectorAll(minuteSelector)] : null
  const secondElem = secondSelector ? [...document.querySelectorAll(secondSelector)] : null
  const endDate = new Date(date)
  let timer

  if (!dayElem && !hourElem && !minuteElem && !secondElem) {
    return
  }

  if (isNaN(endDate)) {
    console.error('Incorrect date format passed to createTimer.')
    return
  }

  const pad = (num) => num.toString().padStart(2, '0')

  timer = setInterval(function () {
    updateTimer()
  }, 1000)

  function updateTimer() {
    const now = new Date().getTime()
    let diff = endDate - now

    if (diff <= 0) {
      diff = 0
      clearInterval(timer)
    }

    const days = Math.floor(diff / (1000 * 60 * 60 * 24))
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60))
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60))
    const seconds = Math.floor((diff % (1000 * 60)) / 1000)
    
    for (const elem of dayElem) {
      if (elem !== null) {
        elem.textContent = pad(days)
      }
    }
    
    for (const elem of hourElem) {
      if (elem !== null) {
        elem.textContent = pad(hours)
      }
    }
    
    for (const elem of minuteElem) {
      if (elem !== null) {
        elem.textContent = pad(minutes)
      }
    }
    
    for (const elem of secondElem) {
      if (elem !== null) {
        elem.textContent = pad(seconds)
      }
    }
  }
}

module.exports = {
  toArray,
  lockScroll,
  unlockScroll,
  elemDisplayed,
  createElem,
  removeClasses,
  addClasses,
  formatAsCurrency,
  getEvtDOM,
  getTransitionTime,
  getOrdinalTxt,
  getZIndex,
  toggleAdminBar,
  isEmail,
  saveCartEmail,
  showMessage,
  debounce,
  showSkeleton,
  hideSkeleton,
  openPriceModal,
  signupPrice,
  createTimer
}
},{}],53:[function(require,module,exports){
let variables = {
  UPLOADED_BLOG_IMG: null,
  alertTimer: null,
  sirvTimer: null
}

module.exports = variables;
},{}],54:[function(require,module,exports){
(function (global){(function (){
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("jquery")) : "function" == typeof define && define.amd ? define(["jquery"], e) : (t = t || self).parsley = e(t.jQuery) }(this, function (h) { "use strict"; function n(t) { return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function l() { return (l = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r]) } return t }).apply(this, arguments) } function o(t, e) { return function (t) { if (Array.isArray(t)) return t }(t) || function (t, e) { if (!(Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t))) return; var i = [], r = !0, n = !1, s = void 0; try { for (var a, o = t[Symbol.iterator](); !(r = (a = o.next()).done) && (i.push(a.value), !e || i.length !== e); r = !0); } catch (t) { n = !0, s = t } finally { try { r || null == o.return || o.return() } finally { if (n) throw s } } return i }(t, e) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance") }() } function u(t) { return function (t) { if (Array.isArray(t)) { for (var e = 0, i = new Array(t.length); e < t.length; e++)i[e] = t[e]; return i } }(t) || function (t) { if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) return Array.from(t) }(t) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance") }() } var t = 1, e = {}, d = { attr: function (t, e, i) { var r, n, s, a = new RegExp("^" + e, "i"); if (void 0 === i) i = {}; else for (r in i) i.hasOwnProperty(r) && delete i[r]; if (!t) return i; for (r = (s = t.attributes).length; r--;)(n = s[r]) && n.specified && a.test(n.name) && (i[this.camelize(n.name.slice(e.length))] = this.deserializeValue(n.value)); return i }, checkAttr: function (t, e, i) { return t.hasAttribute(e + i) }, setAttr: function (t, e, i, r) { t.setAttribute(this.dasherize(e + i), String(r)) }, getType: function (t) { return t.getAttribute("type") || "text" }, generateID: function () { return "" + t++ }, deserializeValue: function (e) { var t; try { return e ? "true" == e || "false" != e && ("null" == e ? null : isNaN(t = Number(e)) ? /^[\[\{]/.test(e) ? JSON.parse(e) : e : t) : e } catch (t) { return e } }, camelize: function (t) { return t.replace(/-+(.)?/g, function (t, e) { return e ? e.toUpperCase() : "" }) }, dasherize: function (t) { return t.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/_/g, "-").toLowerCase() }, warn: function () { var t; window.console && "function" == typeof window.console.warn && (t = window.console).warn.apply(t, arguments) }, warnOnce: function (t) { e[t] || (e[t] = !0, this.warn.apply(this, arguments)) }, _resetWarnings: function () { e = {} }, trimString: function (t) { return t.replace(/^\s+|\s+$/g, "") }, parse: { date: function (t) { var e = t.match(/^(\d{4,})-(\d\d)-(\d\d)$/); if (!e) return null; var i = o(e.map(function (t) { return parseInt(t, 10) }), 4), r = (i[0], i[1]), n = i[2], s = i[3], a = new Date(r, n - 1, s); return a.getFullYear() !== r || a.getMonth() + 1 !== n || a.getDate() !== s ? null : a }, string: function (t) { return t }, integer: function (t) { return isNaN(t) ? null : parseInt(t, 10) }, number: function (t) { if (isNaN(t)) throw null; return parseFloat(t) }, boolean: function (t) { return !/^\s*false\s*$/i.test(t) }, object: function (t) { return d.deserializeValue(t) }, regexp: function (t) { var e = ""; return t = /^\/.*\/(?:[gimy]*)$/.test(t) ? (e = t.replace(/.*\/([gimy]*)$/, "$1"), t.replace(new RegExp("^/(.*?)/" + e + "$"), "$1")) : "^" + t + "$", new RegExp(t, e) } }, parseRequirement: function (t, e) { var i = this.parse[t || "string"]; if (!i) throw 'Unknown requirement specification: "' + t + '"'; var r = i(e); if (null === r) throw "Requirement is not a ".concat(t, ': "').concat(e, '"'); return r }, namespaceEvents: function (t, e) { return (t = this.trimString(t || "").split(/\s+/))[0] ? h.map(t, function (t) { return "".concat(t, ".").concat(e) }).join(" ") : "" }, difference: function (t, i) { var r = []; return h.each(t, function (t, e) { -1 == i.indexOf(e) && r.push(e) }), r }, all: function (t) { return h.when.apply(h, u(t).concat([42, 42])) }, objectCreate: Object.create || function (t) { if (1 < arguments.length) throw Error("Second argument not supported"); if ("object" != n(t)) throw TypeError("Argument must be an object"); i.prototype = t; var e = new i; return i.prototype = null, e }, _SubmitSelector: 'input[type="submit"], button:submit' }; function i() { } function r() { this.__id__ = d.generateID() } var s = { namespace: "data-parsley-", inputs: "input, textarea, select", excluded: "input[type=button], input[type=submit], input[type=reset], input[type=hidden]", priorityEnabled: !0, multiple: null, group: null, uiEnabled: !0, validationThreshold: 3, focus: "first", trigger: !1, triggerAfterFailure: "input", errorClass: "parsley-error", successClass: "parsley-success", classHandler: function () { }, errorsContainer: function () { }, errorsWrapper: '<ul class="parsley-errors-list"></ul>', errorTemplate: "<li></li>" }; r.prototype = { asyncSupport: !0, _pipeAccordingToValidationResult: function () { function t() { var t = h.Deferred(); return !0 !== e.validationResult && t.reject(), t.resolve().promise() } var e = this; return [t, t] }, actualizeOptions: function () { return d.attr(this.element, this.options.namespace, this.domOptions), this.parent && this.parent.actualizeOptions && this.parent.actualizeOptions(), this }, _resetOptions: function (t) { for (var e in this.domOptions = d.objectCreate(this.parent.options), this.options = d.objectCreate(this.domOptions), t) t.hasOwnProperty(e) && (this.options[e] = t[e]); this.actualizeOptions() }, _listeners: null, on: function (t, e) { return this._listeners = this._listeners || {}, (this._listeners[t] = this._listeners[t] || []).push(e), this }, subscribe: function (t, e) { h.listenTo(this, t.toLowerCase(), e) }, off: function (t, e) { var i = this._listeners && this._listeners[t]; if (i) if (e) for (var r = i.length; r--;)i[r] === e && i.splice(r, 1); else delete this._listeners[t]; return this }, unsubscribe: function (t) { h.unsubscribeTo(this, t.toLowerCase()) }, trigger: function (t, e, i) { e = e || this; var r, n = this._listeners && this._listeners[t]; if (n) for (var s = n.length; s--;)if (!1 === (r = n[s].call(e, e, i))) return r; return !this.parent || this.parent.trigger(t, e, i) }, asyncIsValid: function (t, e) { return d.warnOnce("asyncIsValid is deprecated; please use whenValid instead"), this.whenValid({ group: t, force: e }) }, _findRelated: function () { return this.options.multiple ? h(this.parent.element.querySelectorAll("[".concat(this.options.namespace, 'multiple="').concat(this.options.multiple, '"]'))) : this.$element } }; function c(t) { h.extend(!0, this, t) } c.prototype = { validate: function (t, e) { if (this.fn) return 3 < arguments.length && (e = [].slice.call(arguments, 1, -1)), this.fn(t, e); if (Array.isArray(t)) { if (!this.validateMultiple) throw "Validator `" + this.name + "` does not handle multiple values"; return this.validateMultiple.apply(this, arguments) } var i = arguments[arguments.length - 1]; if (this.validateDate && i._isDateInput()) return arguments[0] = d.parse.date(arguments[0]), null !== arguments[0] && this.validateDate.apply(this, arguments); if (this.validateNumber) return !t || !isNaN(t) && (arguments[0] = parseFloat(arguments[0]), this.validateNumber.apply(this, arguments)); if (this.validateString) return this.validateString.apply(this, arguments); throw "Validator `" + this.name + "` only handles multiple values" }, parseRequirements: function (t, e) { if ("string" != typeof t) return Array.isArray(t) ? t : [t]; var i = this.requirementType; if (Array.isArray(i)) { for (var r = function (t, e) { var i = t.match(/^\s*\[(.*)\]\s*$/); if (!i) throw 'Requirement is not an array: "' + t + '"'; var r = i[1].split(",").map(d.trimString); if (r.length !== e) throw "Requirement has " + r.length + " values when " + e + " are needed"; return r }(t, i.length), n = 0; n < r.length; n++)r[n] = d.parseRequirement(i[n], r[n]); return r } return h.isPlainObject(i) ? function (t, e, i) { var r = null, n = {}; for (var s in t) if (s) { var a = i(s); "string" == typeof a && (a = d.parseRequirement(t[s], a)), n[s] = a } else r = d.parseRequirement(t[s], e); return [r, n] }(i, t, e) : [d.parseRequirement(i, t)] }, requirementType: "string", priority: 2 }; function a(t, e) { this.__class__ = "ValidatorRegistry", this.locale = "en", this.init(t || {}, e || {}) } var p = { email: /^((([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))$/, number: /^-?(\d*\.)?\d+(e[-+]?\d+)?$/i, integer: /^-?\d+$/, digits: /^\d+$/, alphanum: /^\w+$/i, date: { test: function (t) { return null !== d.parse.date(t) } }, url: new RegExp("^(?:(?:https?|ftp)://)?(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-zA-Z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:/\\S*)?$") }; p.range = p.number; function f(t) { var e = ("" + t).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/); return e ? Math.max(0, (e[1] ? e[1].length : 0) - (e[2] ? +e[2] : 0)) : 0 } function m(s, a) { return function (t) { for (var e = arguments.length, i = new Array(1 < e ? e - 1 : 0), r = 1; r < e; r++)i[r - 1] = arguments[r]; return i.pop(), a.apply(void 0, [t].concat(u((n = s, i.map(d.parse[n]))))); var n } } function g(t) { return { validateDate: m("date", t), validateNumber: m("number", t), requirementType: t.length <= 2 ? "string" : ["string", "string"], priority: 30 } } a.prototype = { init: function (t, e) { for (var i in this.catalog = e, this.validators = l({}, this.validators), t) this.addValidator(i, t[i].fn, t[i].priority); window.Parsley.trigger("parsley:validator:init") }, setLocale: function (t) { if (void 0 === this.catalog[t]) throw new Error(t + " is not available in the catalog"); return this.locale = t, this }, addCatalog: function (t, e, i) { return "object" === n(e) && (this.catalog[t] = e), !0 === i ? this.setLocale(t) : this }, addMessage: function (t, e, i) { return void 0 === this.catalog[t] && (this.catalog[t] = {}), this.catalog[t][e] = i, this }, addMessages: function (t, e) { for (var i in e) this.addMessage(t, i, e[i]); return this }, addValidator: function (t, e, i) { if (this.validators[t]) d.warn('Validator "' + t + '" is already defined.'); else if (s.hasOwnProperty(t)) return void d.warn('"' + t + '" is a restricted keyword and is not a valid validator name.'); return this._setValidator.apply(this, arguments) }, hasValidator: function (t) { return !!this.validators[t] }, updateValidator: function (t, e, i) { return this.validators[t] ? this._setValidator.apply(this, arguments) : (d.warn('Validator "' + t + '" is not already defined.'), this.addValidator.apply(this, arguments)) }, removeValidator: function (t) { return this.validators[t] || d.warn('Validator "' + t + '" is not defined.'), delete this.validators[t], this }, _setValidator: function (t, e, i) { for (var r in "object" !== n(e) && (e = { fn: e, priority: i }), e.validate || (e = new c(e)), (this.validators[t] = e).messages || {}) this.addMessage(r, t, e.messages[r]); return this }, getErrorMessage: function (t) { var e; "type" === t.name ? e = (this.catalog[this.locale][t.name] || {})[t.requirements] : e = this.formatMessage(this.catalog[this.locale][t.name], t.requirements); return e || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage }, formatMessage: function (t, e) { if ("object" !== n(e)) return "string" == typeof t ? t.replace(/%s/i, e) : ""; for (var i in e) t = this.formatMessage(t, e[i]); return t }, validators: { notblank: { validateString: function (t) { return /\S/.test(t) }, priority: 2 }, required: { validateMultiple: function (t) { return 0 < t.length }, validateString: function (t) { return /\S/.test(t) }, priority: 512 }, type: { validateString: function (t, e, i) { var r = 2 < arguments.length && void 0 !== i ? i : {}, n = r.step, s = void 0 === n ? "any" : n, a = r.base, o = void 0 === a ? 0 : a, l = p[e]; if (!l) throw new Error("validator type `" + e + "` is not supported"); if (!t) return !0; if (!l.test(t)) return !1; if ("number" === e && !/^any$/i.test(s || "")) { var u = Number(t), d = Math.max(f(s), f(o)); if (f(u) > d) return !1; var h = function (t) { return Math.round(t * Math.pow(10, d)) }; if ((h(u) - h(o)) % h(s) != 0) return !1 } return !0 }, requirementType: { "": "string", step: "string", base: "number" }, priority: 256 }, pattern: { validateString: function (t, e) { return !t || e.test(t) }, requirementType: "regexp", priority: 64 }, minlength: { validateString: function (t, e) { return !t || t.length >= e }, requirementType: "integer", priority: 30 }, maxlength: { validateString: function (t, e) { return t.length <= e }, requirementType: "integer", priority: 30 }, length: { validateString: function (t, e, i) { return !t || t.length >= e && t.length <= i }, requirementType: ["integer", "integer"], priority: 30 }, mincheck: { validateMultiple: function (t, e) { return t.length >= e }, requirementType: "integer", priority: 30 }, maxcheck: { validateMultiple: function (t, e) { return t.length <= e }, requirementType: "integer", priority: 30 }, check: { validateMultiple: function (t, e, i) { return t.length >= e && t.length <= i }, requirementType: ["integer", "integer"], priority: 30 }, min: g(function (t, e) { return e <= t }), max: g(function (t, e) { return t <= e }), range: g(function (t, e, i) { return e <= t && t <= i }), equalto: { validateString: function (t, e) { if (!t) return !0; var i = h(e); return i.length ? t === i.val() : t === e }, priority: 256 }, euvatin: { validateString: function (t) { if (!t) return !0; return /^[A-Z][A-Z][A-Za-z0-9 -]{2,}$/.test(t) }, priority: 30 } } }; var v = {}; v.Form = { _actualizeTriggers: function () { var e = this; this.$element.on("submit.Parsley", function (t) { e.onSubmitValidate(t) }), this.$element.on("click.Parsley", d._SubmitSelector, function (t) { e.onSubmitButton(t) }), !1 !== this.options.uiEnabled && this.element.setAttribute("novalidate", "") }, focus: function () { if (!(this._focusedField = null) === this.validationResult || "none" === this.options.focus) return null; for (var t = 0; t < this.fields.length; t++) { var e = this.fields[t]; if (!0 !== e.validationResult && 0 < e.validationResult.length && void 0 === e.options.noFocus && (this._focusedField = e.$element, "first" === this.options.focus)) break } return null === this._focusedField ? null : this._focusedField.focus() }, _destroyUI: function () { this.$element.off(".Parsley") } }, v.Field = { _reflowUI: function () { if (this._buildUI(), this._ui) { var t = function t(e, i, r) { for (var n = [], s = [], a = 0; a < e.length; a++) { for (var o = !1, l = 0; l < i.length; l++)if (e[a].assert.name === i[l].assert.name) { o = !0; break } o ? s.push(e[a]) : n.push(e[a]) } return { kept: s, added: n, removed: r ? [] : t(i, e, !0).added } }(this.validationResult, this._ui.lastValidationResult); this._ui.lastValidationResult = this.validationResult, this._manageStatusClass(), this._manageErrorsMessages(t), this._actualizeTriggers(), !t.kept.length && !t.added.length || this._failedOnce || (this._failedOnce = !0, this._actualizeTriggers()) } }, getErrorsMessages: function () { if (!0 === this.validationResult) return []; for (var t = [], e = 0; e < this.validationResult.length; e++)t.push(this.validationResult[e].errorMessage || this._getErrorMessage(this.validationResult[e].assert)); return t }, addError: function (t, e) { var i = 1 < arguments.length && void 0 !== e ? e : {}, r = i.message, n = i.assert, s = i.updateClass, a = void 0 === s || s; this._buildUI(), this._addError(t, { message: r, assert: n }), a && this._errorClass() }, updateError: function (t, e) { var i = 1 < arguments.length && void 0 !== e ? e : {}, r = i.message, n = i.assert, s = i.updateClass, a = void 0 === s || s; this._buildUI(), this._updateError(t, { message: r, assert: n }), a && this._errorClass() }, removeError: function (t, e) { var i = (1 < arguments.length && void 0 !== e ? e : {}).updateClass, r = void 0 === i || i; this._buildUI(), this._removeError(t), r && this._manageStatusClass() }, _manageStatusClass: function () { this.hasConstraints() && this.needsValidation() && !0 === this.validationResult ? this._successClass() : 0 < this.validationResult.length ? this._errorClass() : this._resetClass() }, _manageErrorsMessages: function (t) { if (void 0 === this.options.errorsMessagesDisabled) { if (void 0 !== this.options.errorMessage) return t.added.length || t.kept.length ? (this._insertErrorWrapper(), 0 === this._ui.$errorsWrapper.find(".parsley-custom-error-message").length && this._ui.$errorsWrapper.append(h(this.options.errorTemplate).addClass("parsley-custom-error-message")), this._ui.$errorClassHandler.attr("aria-describedby", this._ui.errorsWrapperId), this._ui.$errorsWrapper.addClass("filled").attr("aria-hidden", "false").find(".parsley-custom-error-message").html(this.options.errorMessage)) : (this._ui.$errorClassHandler.removeAttr("aria-describedby"), this._ui.$errorsWrapper.removeClass("filled").attr("aria-hidden", "true").find(".parsley-custom-error-message").remove()); for (var e = 0; e < t.removed.length; e++)this._removeError(t.removed[e].assert.name); for (e = 0; e < t.added.length; e++)this._addError(t.added[e].assert.name, { message: t.added[e].errorMessage, assert: t.added[e].assert }); for (e = 0; e < t.kept.length; e++)this._updateError(t.kept[e].assert.name, { message: t.kept[e].errorMessage, assert: t.kept[e].assert }) } }, _addError: function (t, e) { var i = e.message, r = e.assert; this._insertErrorWrapper(), this._ui.$errorClassHandler.attr("aria-describedby", this._ui.errorsWrapperId), this._ui.$errorsWrapper.addClass("filled").attr("aria-hidden", "false").append(h(this.options.errorTemplate).addClass("parsley-" + t).html(i || this._getErrorMessage(r))) }, _updateError: function (t, e) { var i = e.message, r = e.assert; this._ui.$errorsWrapper.addClass("filled").find(".parsley-" + t).html(i || this._getErrorMessage(r)) }, _removeError: function (t) { this._ui.$errorClassHandler.removeAttr("aria-describedby"), this._ui.$errorsWrapper.removeClass("filled").attr("aria-hidden", "true").find(".parsley-" + t).remove() }, _getErrorMessage: function (t) { var e = t.name + "Message"; return void 0 !== this.options[e] ? window.Parsley.formatMessage(this.options[e], t.requirements) : window.Parsley.getErrorMessage(t) }, _buildUI: function () { if (!this._ui && !1 !== this.options.uiEnabled) { var t = {}; this.element.setAttribute(this.options.namespace + "id", this.__id__), t.$errorClassHandler = this._manageClassHandler(), t.errorsWrapperId = "parsley-id-" + (this.options.multiple ? "multiple-" + this.options.multiple : this.__id__), t.$errorsWrapper = h(this.options.errorsWrapper).attr("id", t.errorsWrapperId), t.lastValidationResult = [], t.validationInformationVisible = !1, this._ui = t } }, _manageClassHandler: function () { if ("string" == typeof this.options.classHandler && h(this.options.classHandler).length) return h(this.options.classHandler); var t = this.options.classHandler; if ("string" == typeof this.options.classHandler && "function" == typeof window[this.options.classHandler] && (t = window[this.options.classHandler]), "function" == typeof t) { var e = t.call(this, this); if (void 0 !== e && e.length) return e } else { if ("object" === n(t) && t instanceof jQuery && t.length) return t; t && d.warn("The class handler `" + t + "` does not exist in DOM nor as a global JS function") } return this._inputHolder() }, _inputHolder: function () { return this.options.multiple && "SELECT" !== this.element.nodeName ? this.$element.parent() : this.$element }, _insertErrorWrapper: function () { var t = this.options.errorsContainer; if (0 !== this._ui.$errorsWrapper.parent().length) return this._ui.$errorsWrapper.parent(); if ("string" == typeof t) { if (h(t).length) return h(t).append(this._ui.$errorsWrapper); "function" == typeof window[t] ? t = window[t] : d.warn("The errors container `" + t + "` does not exist in DOM nor as a global JS function") } return "function" == typeof t && (t = t.call(this, this)), "object" === n(t) && t.length ? t.append(this._ui.$errorsWrapper) : this._inputHolder().after(this._ui.$errorsWrapper) }, _actualizeTriggers: function () { var t, e = this, i = this._findRelated(); i.off(".Parsley"), this._failedOnce ? i.on(d.namespaceEvents(this.options.triggerAfterFailure, "Parsley"), function () { e._validateIfNeeded() }) : (t = d.namespaceEvents(this.options.trigger, "Parsley")) && i.on(t, function (t) { e._validateIfNeeded(t) }) }, _validateIfNeeded: function (t) { var e = this; t && /key|input/.test(t.type) && (!this._ui || !this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold || (this.options.debounce ? (window.clearTimeout(this._debounced), this._debounced = window.setTimeout(function () { return e.validate() }, this.options.debounce)) : this.validate()) }, _resetUI: function () { this._failedOnce = !1, this._actualizeTriggers(), void 0 !== this._ui && (this._ui.$errorsWrapper.removeClass("filled").children().remove(), this._resetClass(), this._ui.lastValidationResult = [], this._ui.validationInformationVisible = !1) }, _destroyUI: function () { this._resetUI(), void 0 !== this._ui && this._ui.$errorsWrapper.remove(), delete this._ui }, _successClass: function () { this._ui.validationInformationVisible = !0, this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass) }, _errorClass: function () { this._ui.validationInformationVisible = !0, this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass) }, _resetClass: function () { this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass) } }; function y(t, e, i) { this.__class__ = "Form", this.element = t, this.$element = h(t), this.domOptions = e, this.options = i, this.parent = window.Parsley, this.fields = [], this.validationResult = null } var _ = { pending: null, resolved: !0, rejected: !1 }; y.prototype = { onSubmitValidate: function (t) { var e = this; if (!0 !== t.parsley) { var i = this._submitSource || this.$element.find(d._SubmitSelector)[0]; if (this._submitSource = null, this.$element.find(".parsley-synthetic-submit-button").prop("disabled", !0), !i || null === i.getAttribute("formnovalidate")) { window.Parsley._remoteCache = {}; var r = this.whenValidate({ event: t }); "resolved" === r.state() && !1 !== this._trigger("submit") || (t.stopImmediatePropagation(), t.preventDefault(), "pending" === r.state() && r.done(function () { e._submit(i) })) } } }, onSubmitButton: function (t) { this._submitSource = t.currentTarget }, _submit: function (t) { if (!1 !== this._trigger("submit")) { if (t) { var e = this.$element.find(".parsley-synthetic-submit-button").prop("disabled", !1); 0 === e.length && (e = h('<input class="parsley-synthetic-submit-button" type="hidden">').appendTo(this.$element)), e.attr({ name: t.getAttribute("name"), value: t.getAttribute("value") }) } this.$element.trigger(l(h.Event("submit"), { parsley: !0 })) } }, validate: function (t) { if (1 <= arguments.length && !h.isPlainObject(t)) { d.warnOnce("Calling validate on a parsley form without passing arguments as an object is deprecated."); var e = Array.prototype.slice.call(arguments); t = { group: e[0], force: e[1], event: e[2] } } return _[this.whenValidate(t).state()] }, whenValidate: function (t) { var e, i = this, r = 0 < arguments.length && void 0 !== t ? t : {}, n = r.group, s = r.force, a = r.event; (this.submitEvent = a) && (this.submitEvent = l({}, a, { preventDefault: function () { d.warnOnce("Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`"), i.validationResult = !1 } })), this.validationResult = !0, this._trigger("validate"), this._refreshFields(); var o = this._withoutReactualizingFormOptions(function () { return h.map(i.fields, function (t) { return t.whenValidate({ force: s, group: n }) }) }); return (e = d.all(o).done(function () { i._trigger("success") }).fail(function () { i.validationResult = !1, i.focus(), i._trigger("error") }).always(function () { i._trigger("validated") })).pipe.apply(e, u(this._pipeAccordingToValidationResult())) }, isValid: function (t) { if (1 <= arguments.length && !h.isPlainObject(t)) { d.warnOnce("Calling isValid on a parsley form without passing arguments as an object is deprecated."); var e = Array.prototype.slice.call(arguments); t = { group: e[0], force: e[1] } } return _[this.whenValid(t).state()] }, whenValid: function (t) { var e = this, i = 0 < arguments.length && void 0 !== t ? t : {}, r = i.group, n = i.force; this._refreshFields(); var s = this._withoutReactualizingFormOptions(function () { return h.map(e.fields, function (t) { return t.whenValid({ group: r, force: n }) }) }); return d.all(s) }, refresh: function () { return this._refreshFields(), this }, reset: function () { for (var t = 0; t < this.fields.length; t++)this.fields[t].reset(); this._trigger("reset") }, destroy: function () { this._destroyUI(); for (var t = 0; t < this.fields.length; t++)this.fields[t].destroy(); this.$element.removeData("Parsley"), this._trigger("destroy") }, _refreshFields: function () { return this.actualizeOptions()._bindFields() }, _bindFields: function () { var n = this, t = this.fields; return this.fields = [], this.fieldsMappedById = {}, this._withoutReactualizingFormOptions(function () { n.$element.find(n.options.inputs).not(n.options.excluded).not("[".concat(n.options.namespace, "excluded=true]")).each(function (t, e) { var i = new window.Parsley.Factory(e, {}, n); if ("Field" === i.__class__ || "FieldMultiple" === i.__class__) { var r = i.__class__ + "-" + i.__id__; void 0 === n.fieldsMappedById[r] && (n.fieldsMappedById[r] = i, n.fields.push(i)) } }), h.each(d.difference(t, n.fields), function (t, e) { e.reset() }) }), this }, _withoutReactualizingFormOptions: function (t) { var e = this.actualizeOptions; this.actualizeOptions = function () { return this }; var i = t(); return this.actualizeOptions = e, i }, _trigger: function (t) { return this.trigger("form:" + t) } }; function b(t, e, i, r, n) { var s = window.Parsley._validatorRegistry.validators[e], a = new c(s); l(this, { validator: a, name: e, requirements: i, priority: r = r || t.options[e + "Priority"] || a.priority, isDomConstraint: n = !0 === n }), this._parseRequirements(t.options) } function w(t, e, i, r) { this.__class__ = "Field", this.element = t, this.$element = h(t), void 0 !== r && (this.parent = r), this.options = i, this.domOptions = e, this.constraints = [], this.constraintsByName = {}, this.validationResult = !0, this._bindConstraints() } var F = { pending: null, resolved: !0, rejected: !(b.prototype = { validate: function (t, e) { var i; return (i = this.validator).validate.apply(i, [t].concat(u(this.requirementList), [e])) }, _parseRequirements: function (i) { var r = this; this.requirementList = this.validator.parseRequirements(this.requirements, function (t) { return i[r.name + ((e = t)[0].toUpperCase() + e.slice(1))]; var e }) } }) }; w.prototype = { validate: function (t) { 1 <= arguments.length && !h.isPlainObject(t) && (d.warnOnce("Calling validate on a parsley field without passing arguments as an object is deprecated."), t = { options: t }); var e = this.whenValidate(t); if (!e) return !0; switch (e.state()) { case "pending": return null; case "resolved": return !0; case "rejected": return this.validationResult } }, whenValidate: function (t) { var e, i = this, r = 0 < arguments.length && void 0 !== t ? t : {}, n = r.force, s = r.group; if (this.refresh(), !s || this._isInGroup(s)) return this.value = this.getValue(), this._trigger("validate"), (e = this.whenValid({ force: n, value: this.value, _refreshed: !0 }).always(function () { i._reflowUI() }).done(function () { i._trigger("success") }).fail(function () { i._trigger("error") }).always(function () { i._trigger("validated") })).pipe.apply(e, u(this._pipeAccordingToValidationResult())) }, hasConstraints: function () { return 0 !== this.constraints.length }, needsValidation: function (t) { return void 0 === t && (t = this.getValue()), !(!t.length && !this._isRequired() && void 0 === this.options.validateIfEmpty) }, _isInGroup: function (t) { return Array.isArray(this.options.group) ? -1 !== h.inArray(t, this.options.group) : this.options.group === t }, isValid: function (t) { if (1 <= arguments.length && !h.isPlainObject(t)) { d.warnOnce("Calling isValid on a parsley field without passing arguments as an object is deprecated."); var e = Array.prototype.slice.call(arguments); t = { force: e[0], value: e[1] } } var i = this.whenValid(t); return !i || F[i.state()] }, whenValid: function (t) { var r = this, e = 0 < arguments.length && void 0 !== t ? t : {}, i = e.force, n = void 0 !== i && i, s = e.value, a = e.group; if (e._refreshed || this.refresh(), !a || this._isInGroup(a)) { if (this.validationResult = !0, !this.hasConstraints()) return h.when(); if (null == s && (s = this.getValue()), !this.needsValidation(s) && !0 !== n) return h.when(); var o = this._getGroupedConstraints(), l = []; return h.each(o, function (t, e) { var i = d.all(h.map(e, function (t) { return r._validateConstraint(s, t) })); if (l.push(i), "rejected" === i.state()) return !1 }), d.all(l) } }, _validateConstraint: function (t, e) { var i = this, r = e.validate(t, this); return !1 === r && (r = h.Deferred().reject()), d.all([r]).fail(function (t) { i.validationResult instanceof Array || (i.validationResult = []), i.validationResult.push({ assert: e, errorMessage: "string" == typeof t && t }) }) }, getValue: function () { var t; return null == (t = "function" == typeof this.options.value ? this.options.value(this) : void 0 !== this.options.value ? this.options.value : this.$element.val()) ? "" : this._handleWhitespace(t) }, reset: function () { return this._resetUI(), this._trigger("reset") }, destroy: function () { this._destroyUI(), this.$element.removeData("Parsley"), this.$element.removeData("FieldMultiple"), this._trigger("destroy") }, refresh: function () { return this._refreshConstraints(), this }, _refreshConstraints: function () { return this.actualizeOptions()._bindConstraints() }, refreshConstraints: function () { return d.warnOnce("Parsley's refreshConstraints is deprecated. Please use refresh"), this.refresh() }, addConstraint: function (t, e, i, r) { if (window.Parsley._validatorRegistry.validators[t]) { var n = new b(this, t, e, i, r); "undefined" !== this.constraintsByName[n.name] && this.removeConstraint(n.name), this.constraints.push(n), this.constraintsByName[n.name] = n } return this }, removeConstraint: function (t) { for (var e = 0; e < this.constraints.length; e++)if (t === this.constraints[e].name) { this.constraints.splice(e, 1); break } return delete this.constraintsByName[t], this }, updateConstraint: function (t, e, i) { return this.removeConstraint(t).addConstraint(t, e, i) }, _bindConstraints: function () { for (var t = [], e = {}, i = 0; i < this.constraints.length; i++)!1 === this.constraints[i].isDomConstraint && (t.push(this.constraints[i]), e[this.constraints[i].name] = this.constraints[i]); for (var r in this.constraints = t, this.constraintsByName = e, this.options) this.addConstraint(r, this.options[r], void 0, !0); return this._bindHtml5Constraints() }, _bindHtml5Constraints: function () { null !== this.element.getAttribute("required") && this.addConstraint("required", !0, void 0, !0), null !== this.element.getAttribute("pattern") && this.addConstraint("pattern", this.element.getAttribute("pattern"), void 0, !0); var t = this.element.getAttribute("min"), e = this.element.getAttribute("max"); null !== t && null !== e ? this.addConstraint("range", [t, e], void 0, !0) : null !== t ? this.addConstraint("min", t, void 0, !0) : null !== e && this.addConstraint("max", e, void 0, !0), null !== this.element.getAttribute("minlength") && null !== this.element.getAttribute("maxlength") ? this.addConstraint("length", [this.element.getAttribute("minlength"), this.element.getAttribute("maxlength")], void 0, !0) : null !== this.element.getAttribute("minlength") ? this.addConstraint("minlength", this.element.getAttribute("minlength"), void 0, !0) : null !== this.element.getAttribute("maxlength") && this.addConstraint("maxlength", this.element.getAttribute("maxlength"), void 0, !0); var i = d.getType(this.element); return "number" === i ? this.addConstraint("type", ["number", { step: this.element.getAttribute("step") || "1", base: t || this.element.getAttribute("value") }], void 0, !0) : /^(email|url|range|date)$/i.test(i) ? this.addConstraint("type", i, void 0, !0) : this }, _isRequired: function () { return void 0 !== this.constraintsByName.required && !1 !== this.constraintsByName.required.requirements }, _trigger: function (t) { return this.trigger("field:" + t) }, _handleWhitespace: function (t) { return !0 === this.options.trimValue && d.warnOnce('data-parsley-trim-value="true" is deprecated, please use data-parsley-whitespace="trim"'), "squish" === this.options.whitespace && (t = t.replace(/\s{2,}/g, " ")), "trim" !== this.options.whitespace && "squish" !== this.options.whitespace && !0 !== this.options.trimValue || (t = d.trimString(t)), t }, _isDateInput: function () { var t = this.constraintsByName.type; return t && "date" === t.requirements }, _getGroupedConstraints: function () { if (!1 === this.options.priorityEnabled) return [this.constraints]; for (var t = [], e = {}, i = 0; i < this.constraints.length; i++) { var r = this.constraints[i].priority; e[r] || t.push(e[r] = []), e[r].push(this.constraints[i]) } return t.sort(function (t, e) { return e[0].priority - t[0].priority }), t } }; function C() { this.__class__ = "FieldMultiple" } C.prototype = { addElement: function (t) { return this.$elements.push(t), this }, _refreshConstraints: function () { var t; if (this.constraints = [], "SELECT" === this.element.nodeName) return this.actualizeOptions()._bindConstraints(), this; for (var e = 0; e < this.$elements.length; e++)if (h("html").has(this.$elements[e]).length) { t = this.$elements[e].data("FieldMultiple")._refreshConstraints().constraints; for (var i = 0; i < t.length; i++)this.addConstraint(t[i].name, t[i].requirements, t[i].priority, t[i].isDomConstraint) } else this.$elements.splice(e, 1); return this }, getValue: function () { if ("function" == typeof this.options.value) return this.options.value(this); if (void 0 !== this.options.value) return this.options.value; if ("INPUT" === this.element.nodeName) { var t = d.getType(this.element); if ("radio" === t) return this._findRelated().filter(":checked").val() || ""; if ("checkbox" === t) { var e = []; return this._findRelated().filter(":checked").each(function () { e.push(h(this).val()) }), e } } return "SELECT" === this.element.nodeName && null === this.$element.val() ? [] : this.$element.val() }, _init: function () { return this.$elements = [this.$element], this } }; function A(t, e, i) { this.element = t, this.$element = h(t); var r = this.$element.data("Parsley"); if (r) return void 0 !== i && r.parent === window.Parsley && (r.parent = i, r._resetOptions(r.options)), "object" === n(e) && l(r.options, e), r; if (!this.$element.length) throw new Error("You must bind Parsley on an existing element."); if (void 0 !== i && "Form" !== i.__class__) throw new Error("Parent instance must be a Form instance"); return this.parent = i || window.Parsley, this.init(e) } A.prototype = { init: function (t) { return this.__class__ = "Parsley", this.__version__ = "2.9.2", this.__id__ = d.generateID(), this._resetOptions(t), "FORM" === this.element.nodeName || d.checkAttr(this.element, this.options.namespace, "validate") && !this.$element.is(this.options.inputs) ? this.bind("parsleyForm") : this.isMultiple() ? this.handleMultiple() : this.bind("parsleyField") }, isMultiple: function () { var t = d.getType(this.element); return "radio" === t || "checkbox" === t || "SELECT" === this.element.nodeName && null !== this.element.getAttribute("multiple") }, handleMultiple: function () { var t, e, r = this; if (this.options.multiple = this.options.multiple || (t = this.element.getAttribute("name")) || this.element.getAttribute("id"), "SELECT" === this.element.nodeName && null !== this.element.getAttribute("multiple")) return this.options.multiple = this.options.multiple || this.__id__, this.bind("parsleyFieldMultiple"); if (!this.options.multiple) return d.warn("To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.", this.$element), this; this.options.multiple = this.options.multiple.replace(/(:|\.|\[|\]|\{|\}|\$)/g, ""), t && h('input[name="' + t + '"]').each(function (t, e) { var i = d.getType(e); "radio" !== i && "checkbox" !== i || e.setAttribute(r.options.namespace + "multiple", r.options.multiple) }); for (var i = this._findRelated(), n = 0; n < i.length; n++)if (void 0 !== (e = h(i.get(n)).data("Parsley"))) { this.$element.data("FieldMultiple") || e.addElement(this.$element); break } return this.bind("parsleyField", !0), e || this.bind("parsleyFieldMultiple") }, bind: function (t, e) { var i; switch (t) { case "parsleyForm": i = h.extend(new y(this.element, this.domOptions, this.options), new r, window.ParsleyExtend)._bindFields(); break; case "parsleyField": i = h.extend(new w(this.element, this.domOptions, this.options, this.parent), new r, window.ParsleyExtend); break; case "parsleyFieldMultiple": i = h.extend(new w(this.element, this.domOptions, this.options, this.parent), new C, new r, window.ParsleyExtend)._init(); break; default: throw new Error(t + "is not a supported Parsley type") }return this.options.multiple && d.setAttr(this.element, this.options.namespace, "multiple", this.options.multiple), void 0 !== e ? this.$element.data("FieldMultiple", i) : (this.$element.data("Parsley", i), i._actualizeTriggers(), i._trigger("init")), i } }; var E = h.fn.jquery.split("."); if (parseInt(E[0]) <= 1 && parseInt(E[1]) < 8) throw "The loaded version of jQuery is too old. Please upgrade to 1.8.x or better."; E.forEach || d.warn("Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim"); var x = l(new r, { element: document, $element: h(document), actualizeOptions: null, _resetOptions: null, Factory: A, version: "2.9.2" }); l(w.prototype, v.Field, r.prototype), l(y.prototype, v.Form, r.prototype), l(A.prototype, r.prototype), h.fn.parsley = h.fn.psly = function (t) { if (1 < this.length) { var e = []; return this.each(function () { e.push(h(this).parsley(t)) }), e } if (0 != this.length) return new A(this[0], t) }, void 0 === window.ParsleyExtend && (window.ParsleyExtend = {}), x.options = l(d.objectCreate(s), window.ParsleyConfig), window.ParsleyConfig = x.options, window.Parsley = window.psly = x, x.Utils = d, window.ParsleyUtils = {}, h.each(d, function (t, e) { "function" == typeof e && (window.ParsleyUtils[t] = function () { return d.warnOnce("Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead."), d[t].apply(d, arguments) }) }); var $ = window.Parsley._validatorRegistry = new a(window.ParsleyConfig.validators, window.ParsleyConfig.i18n); window.ParsleyValidator = {}, h.each("setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator hasValidator".split(" "), function (t, e) { window.Parsley[e] = function () { return $[e].apply($, arguments) }, window.ParsleyValidator[e] = function () { var t; return d.warnOnce("Accessing the method '".concat(e, "' through Validator is deprecated. Simply call 'window.Parsley.").concat(e, "(...)'")), (t = window.Parsley)[e].apply(t, arguments) } }), window.Parsley.UI = v, window.ParsleyUI = { removeError: function (t, e, i) { var r = !0 !== i; return d.warnOnce("Accessing UI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method."), t.removeError(e, { updateClass: r }) }, getErrorsMessages: function (t) { return d.warnOnce("Accessing UI is deprecated. Call 'getErrorsMessages' on the instance directly."), t.getErrorsMessages() } }, h.each("addError updateError".split(" "), function (t, a) { window.ParsleyUI[a] = function (t, e, i, r, n) { var s = !0 !== n; return d.warnOnce("Accessing UI is deprecated. Call '".concat(a, "' on the instance directly. Please comment in issue 1073 as to your need to call this method.")), t[a](e, { message: i, assert: r, updateClass: s }) } }), !1 !== window.ParsleyConfig.autoBind && h(function () { h("[data-parsley-validate]").length && h("[data-parsley-validate]").parsley() }); function V() { d.warnOnce("Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley") } var P = h({}); function O(e, i) { return e.parsleyAdaptedCallback || (e.parsleyAdaptedCallback = function () { var t = Array.prototype.slice.call(arguments, 0); t.unshift(this), e.apply(i || P, t) }), e.parsleyAdaptedCallback } var T = "parsley:"; function M(t) { return 0 === t.lastIndexOf(T, 0) ? t.substr(T.length) : t } return h.listen = function (t, e) { var i; if (V(), "object" === n(arguments[1]) && "function" == typeof arguments[2] && (i = arguments[1], e = arguments[2]), "function" != typeof e) throw new Error("Wrong parameters"); window.Parsley.on(M(t), O(e, i)) }, h.listenTo = function (t, e, i) { if (V(), !(t instanceof w || t instanceof y)) throw new Error("Must give Parsley instance"); if ("string" != typeof e || "function" != typeof i) throw new Error("Wrong parameters"); t.on(M(e), O(i)) }, h.unsubscribe = function (t, e) { if (V(), "string" != typeof t || "function" != typeof e) throw new Error("Wrong arguments"); window.Parsley.off(M(t), e.parsleyAdaptedCallback) }, h.unsubscribeTo = function (t, e) { if (V(), !(t instanceof w || t instanceof y)) throw new Error("Must give Parsley instance"); t.off(M(e)) }, h.unsubscribeAll = function (e) { V(), window.Parsley.off(M(e)), h("form,input,textarea,select").each(function () { var t = h(this).data("Parsley"); t && t.off(M(e)) }) }, h.emit = function (t, e) { V(); var i = e instanceof w || e instanceof y, r = Array.prototype.slice.call(arguments, i ? 2 : 1); r.unshift(M(t)), i || (e = window.Parsley), e.trigger.apply(e, u(r)) }, h.extend(!0, x, { asyncValidators: { default: { fn: function (t) { return 200 <= t.status && t.status < 300 }, url: !1 }, reverse: { fn: function (t) { return t.status < 200 || 300 <= t.status }, url: !1 } }, addAsyncValidator: function (t, e, i, r) { return x.asyncValidators[t] = { fn: e, url: i || !1, options: r || {} }, this } }), x.addValidator("remote", { requirementType: { "": "string", validator: "string", reverse: "boolean", options: "object" }, validateString: function (t, e, i, r) { var n, s, a = {}, o = i.validator || (!0 === i.reverse ? "reverse" : "default"); if (void 0 === x.asyncValidators[o]) throw new Error("Calling an undefined async validator: `" + o + "`"); -1 < (e = x.asyncValidators[o].url || e).indexOf("{value}") ? e = e.replace("{value}", encodeURIComponent(t)) : a[r.element.getAttribute("name") || r.element.getAttribute("id")] = t; var l = h.extend(!0, i.options || {}, x.asyncValidators[o].options); n = h.extend(!0, {}, { url: e, data: a, type: "GET" }, l), r.trigger("field:ajaxoptions", r, n), s = h.param(n), void 0 === x._remoteCache && (x._remoteCache = {}); function u() { var t = x.asyncValidators[o].fn.call(r, d, e, i); return t = t || h.Deferred().reject(), h.when(t) } var d = x._remoteCache[s] = x._remoteCache[s] || h.ajax(n); return d.then(u, u) }, priority: -1 }), x.on("form:submit", function () { x._remoteCache = {} }), r.prototype.addAsyncValidator = function () { return d.warnOnce("Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`"), x.addAsyncValidator.apply(x, arguments) }, x.addMessages("en", { defaultMessage: "This value seems to be invalid.", type: { email: "This value should be a valid email.", url: "This value should be a valid url.", number: "This value should be a valid number.", integer: "This value should be a valid integer.", digits: "This value should be digits.", alphanum: "This value should be alphanumeric." }, notblank: "This value should not be blank.", required: "This value is required.", pattern: "This value seems to be invalid.", min: "This value should be greater than or equal to %s.", max: "This value should be lower than or equal to %s.", range: "This value should be between %s and %s.", minlength: "This value is too short. It should have %s characters or more.", maxlength: "This value is too long. It should have %s characters or fewer.", length: "This value length is invalid. It should be between %s and %s characters long.", mincheck: "You must select at least %s choices.", maxcheck: "You must select %s choices or fewer.", check: "You must select between %s and %s choices.", equalto: "This value should be the same.", euvatin: "It's not a valid VAT Identification Number." }), x.setLocale("en"), (new function () { var r = this, n = window || global; l(this, { isNativeEvent: function (t) { return t.originalEvent && !1 !== t.originalEvent.isTrusted }, fakeInputEvent: function (t) { r.isNativeEvent(t) && h(t.target).trigger("input") }, misbehaves: function (t) { r.isNativeEvent(t) && (r.behavesOk(t), h(document).on("change.inputevent", t.data.selector, r.fakeInputEvent), r.fakeInputEvent(t)) }, behavesOk: function (t) { r.isNativeEvent(t) && h(document).off("input.inputevent", t.data.selector, r.behavesOk).off("change.inputevent", t.data.selector, r.misbehaves) }, install: function () { if (!n.inputEventPatched) { n.inputEventPatched = "0.0.3"; for (var t = 0, e = ["select", 'input[type="checkbox"]', 'input[type="radio"]', 'input[type="file"]']; t < e.length; t++) { var i = e[t]; h(document).on("input.inputevent", i, { selector: i }, r.behavesOk).on("change.inputevent", i, { selector: i }, r.misbehaves) } } }, uninstall: function () { delete n.inputEventPatched, h(document).off(".inputevent") } }) }).install(), x });

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"jquery":2}],55:[function(require,module,exports){
/**
 * @popperjs/core v2.11.8 - MIT License
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Popper={})}(this,(function(e){"use strict";function t(e){if(null==e)return window;if("[object Window]"!==e.toString()){var t=e.ownerDocument;return t&&t.defaultView||window}return e}function n(e){return e instanceof t(e).Element||e instanceof Element}function r(e){return e instanceof t(e).HTMLElement||e instanceof HTMLElement}function o(e){return"undefined"!=typeof ShadowRoot&&(e instanceof t(e).ShadowRoot||e instanceof ShadowRoot)}var i=Math.max,a=Math.min,s=Math.round;function f(){var e=navigator.userAgentData;return null!=e&&e.brands&&Array.isArray(e.brands)?e.brands.map((function(e){return e.brand+"/"+e.version})).join(" "):navigator.userAgent}function c(){return!/^((?!chrome|android).)*safari/i.test(f())}function p(e,o,i){void 0===o&&(o=!1),void 0===i&&(i=!1);var a=e.getBoundingClientRect(),f=1,p=1;o&&r(e)&&(f=e.offsetWidth>0&&s(a.width)/e.offsetWidth||1,p=e.offsetHeight>0&&s(a.height)/e.offsetHeight||1);var u=(n(e)?t(e):window).visualViewport,l=!c()&&i,d=(a.left+(l&&u?u.offsetLeft:0))/f,h=(a.top+(l&&u?u.offsetTop:0))/p,m=a.width/f,v=a.height/p;return{width:m,height:v,top:h,right:d+m,bottom:h+v,left:d,x:d,y:h}}function u(e){var n=t(e);return{scrollLeft:n.pageXOffset,scrollTop:n.pageYOffset}}function l(e){return e?(e.nodeName||"").toLowerCase():null}function d(e){return((n(e)?e.ownerDocument:e.document)||window.document).documentElement}function h(e){return p(d(e)).left+u(e).scrollLeft}function m(e){return t(e).getComputedStyle(e)}function v(e){var t=m(e),n=t.overflow,r=t.overflowX,o=t.overflowY;return/auto|scroll|overlay|hidden/.test(n+o+r)}function y(e,n,o){void 0===o&&(o=!1);var i,a,f=r(n),c=r(n)&&function(e){var t=e.getBoundingClientRect(),n=s(t.width)/e.offsetWidth||1,r=s(t.height)/e.offsetHeight||1;return 1!==n||1!==r}(n),m=d(n),y=p(e,c,o),g={scrollLeft:0,scrollTop:0},b={x:0,y:0};return(f||!f&&!o)&&(("body"!==l(n)||v(m))&&(g=(i=n)!==t(i)&&r(i)?{scrollLeft:(a=i).scrollLeft,scrollTop:a.scrollTop}:u(i)),r(n)?((b=p(n,!0)).x+=n.clientLeft,b.y+=n.clientTop):m&&(b.x=h(m))),{x:y.left+g.scrollLeft-b.x,y:y.top+g.scrollTop-b.y,width:y.width,height:y.height}}function g(e){var t=p(e),n=e.offsetWidth,r=e.offsetHeight;return Math.abs(t.width-n)<=1&&(n=t.width),Math.abs(t.height-r)<=1&&(r=t.height),{x:e.offsetLeft,y:e.offsetTop,width:n,height:r}}function b(e){return"html"===l(e)?e:e.assignedSlot||e.parentNode||(o(e)?e.host:null)||d(e)}function x(e){return["html","body","#document"].indexOf(l(e))>=0?e.ownerDocument.body:r(e)&&v(e)?e:x(b(e))}function w(e,n){var r;void 0===n&&(n=[]);var o=x(e),i=o===(null==(r=e.ownerDocument)?void 0:r.body),a=t(o),s=i?[a].concat(a.visualViewport||[],v(o)?o:[]):o,f=n.concat(s);return i?f:f.concat(w(b(s)))}function O(e){return["table","td","th"].indexOf(l(e))>=0}function j(e){return r(e)&&"fixed"!==m(e).position?e.offsetParent:null}function E(e){for(var n=t(e),i=j(e);i&&O(i)&&"static"===m(i).position;)i=j(i);return i&&("html"===l(i)||"body"===l(i)&&"static"===m(i).position)?n:i||function(e){var t=/firefox/i.test(f());if(/Trident/i.test(f())&&r(e)&&"fixed"===m(e).position)return null;var n=b(e);for(o(n)&&(n=n.host);r(n)&&["html","body"].indexOf(l(n))<0;){var i=m(n);if("none"!==i.transform||"none"!==i.perspective||"paint"===i.contain||-1!==["transform","perspective"].indexOf(i.willChange)||t&&"filter"===i.willChange||t&&i.filter&&"none"!==i.filter)return n;n=n.parentNode}return null}(e)||n}var D="top",A="bottom",L="right",P="left",M="auto",k=[D,A,L,P],W="start",B="end",H="viewport",T="popper",R=k.reduce((function(e,t){return e.concat([t+"-"+W,t+"-"+B])}),[]),S=[].concat(k,[M]).reduce((function(e,t){return e.concat([t,t+"-"+W,t+"-"+B])}),[]),V=["beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite"];function q(e){var t=new Map,n=new Set,r=[];function o(e){n.add(e.name),[].concat(e.requires||[],e.requiresIfExists||[]).forEach((function(e){if(!n.has(e)){var r=t.get(e);r&&o(r)}})),r.push(e)}return e.forEach((function(e){t.set(e.name,e)})),e.forEach((function(e){n.has(e.name)||o(e)})),r}function C(e,t){var n=t.getRootNode&&t.getRootNode();if(e.contains(t))return!0;if(n&&o(n)){var r=t;do{if(r&&e.isSameNode(r))return!0;r=r.parentNode||r.host}while(r)}return!1}function N(e){return Object.assign({},e,{left:e.x,top:e.y,right:e.x+e.width,bottom:e.y+e.height})}function I(e,r,o){return r===H?N(function(e,n){var r=t(e),o=d(e),i=r.visualViewport,a=o.clientWidth,s=o.clientHeight,f=0,p=0;if(i){a=i.width,s=i.height;var u=c();(u||!u&&"fixed"===n)&&(f=i.offsetLeft,p=i.offsetTop)}return{width:a,height:s,x:f+h(e),y:p}}(e,o)):n(r)?function(e,t){var n=p(e,!1,"fixed"===t);return n.top=n.top+e.clientTop,n.left=n.left+e.clientLeft,n.bottom=n.top+e.clientHeight,n.right=n.left+e.clientWidth,n.width=e.clientWidth,n.height=e.clientHeight,n.x=n.left,n.y=n.top,n}(r,o):N(function(e){var t,n=d(e),r=u(e),o=null==(t=e.ownerDocument)?void 0:t.body,a=i(n.scrollWidth,n.clientWidth,o?o.scrollWidth:0,o?o.clientWidth:0),s=i(n.scrollHeight,n.clientHeight,o?o.scrollHeight:0,o?o.clientHeight:0),f=-r.scrollLeft+h(e),c=-r.scrollTop;return"rtl"===m(o||n).direction&&(f+=i(n.clientWidth,o?o.clientWidth:0)-a),{width:a,height:s,x:f,y:c}}(d(e)))}function _(e,t,o,s){var f="clippingParents"===t?function(e){var t=w(b(e)),o=["absolute","fixed"].indexOf(m(e).position)>=0&&r(e)?E(e):e;return n(o)?t.filter((function(e){return n(e)&&C(e,o)&&"body"!==l(e)})):[]}(e):[].concat(t),c=[].concat(f,[o]),p=c[0],u=c.reduce((function(t,n){var r=I(e,n,s);return t.top=i(r.top,t.top),t.right=a(r.right,t.right),t.bottom=a(r.bottom,t.bottom),t.left=i(r.left,t.left),t}),I(e,p,s));return u.width=u.right-u.left,u.height=u.bottom-u.top,u.x=u.left,u.y=u.top,u}function F(e){return e.split("-")[0]}function U(e){return e.split("-")[1]}function z(e){return["top","bottom"].indexOf(e)>=0?"x":"y"}function X(e){var t,n=e.reference,r=e.element,o=e.placement,i=o?F(o):null,a=o?U(o):null,s=n.x+n.width/2-r.width/2,f=n.y+n.height/2-r.height/2;switch(i){case D:t={x:s,y:n.y-r.height};break;case A:t={x:s,y:n.y+n.height};break;case L:t={x:n.x+n.width,y:f};break;case P:t={x:n.x-r.width,y:f};break;default:t={x:n.x,y:n.y}}var c=i?z(i):null;if(null!=c){var p="y"===c?"height":"width";switch(a){case W:t[c]=t[c]-(n[p]/2-r[p]/2);break;case B:t[c]=t[c]+(n[p]/2-r[p]/2)}}return t}function Y(e){return Object.assign({},{top:0,right:0,bottom:0,left:0},e)}function G(e,t){return t.reduce((function(t,n){return t[n]=e,t}),{})}function J(e,t){void 0===t&&(t={});var r=t,o=r.placement,i=void 0===o?e.placement:o,a=r.strategy,s=void 0===a?e.strategy:a,f=r.boundary,c=void 0===f?"clippingParents":f,u=r.rootBoundary,l=void 0===u?H:u,h=r.elementContext,m=void 0===h?T:h,v=r.altBoundary,y=void 0!==v&&v,g=r.padding,b=void 0===g?0:g,x=Y("number"!=typeof b?b:G(b,k)),w=m===T?"reference":T,O=e.rects.popper,j=e.elements[y?w:m],E=_(n(j)?j:j.contextElement||d(e.elements.popper),c,l,s),P=p(e.elements.reference),M=X({reference:P,element:O,strategy:"absolute",placement:i}),W=N(Object.assign({},O,M)),B=m===T?W:P,R={top:E.top-B.top+x.top,bottom:B.bottom-E.bottom+x.bottom,left:E.left-B.left+x.left,right:B.right-E.right+x.right},S=e.modifiersData.offset;if(m===T&&S){var V=S[i];Object.keys(R).forEach((function(e){var t=[L,A].indexOf(e)>=0?1:-1,n=[D,A].indexOf(e)>=0?"y":"x";R[e]+=V[n]*t}))}return R}var K={placement:"bottom",modifiers:[],strategy:"absolute"};function Q(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return!t.some((function(e){return!(e&&"function"==typeof e.getBoundingClientRect)}))}function Z(e){void 0===e&&(e={});var t=e,r=t.defaultModifiers,o=void 0===r?[]:r,i=t.defaultOptions,a=void 0===i?K:i;return function(e,t,r){void 0===r&&(r=a);var i,s,f={placement:"bottom",orderedModifiers:[],options:Object.assign({},K,a),modifiersData:{},elements:{reference:e,popper:t},attributes:{},styles:{}},c=[],p=!1,u={state:f,setOptions:function(r){var i="function"==typeof r?r(f.options):r;l(),f.options=Object.assign({},a,f.options,i),f.scrollParents={reference:n(e)?w(e):e.contextElement?w(e.contextElement):[],popper:w(t)};var s,p,d=function(e){var t=q(e);return V.reduce((function(e,n){return e.concat(t.filter((function(e){return e.phase===n})))}),[])}((s=[].concat(o,f.options.modifiers),p=s.reduce((function(e,t){var n=e[t.name];return e[t.name]=n?Object.assign({},n,t,{options:Object.assign({},n.options,t.options),data:Object.assign({},n.data,t.data)}):t,e}),{}),Object.keys(p).map((function(e){return p[e]}))));return f.orderedModifiers=d.filter((function(e){return e.enabled})),f.orderedModifiers.forEach((function(e){var t=e.name,n=e.options,r=void 0===n?{}:n,o=e.effect;if("function"==typeof o){var i=o({state:f,name:t,instance:u,options:r}),a=function(){};c.push(i||a)}})),u.update()},forceUpdate:function(){if(!p){var e=f.elements,t=e.reference,n=e.popper;if(Q(t,n)){f.rects={reference:y(t,E(n),"fixed"===f.options.strategy),popper:g(n)},f.reset=!1,f.placement=f.options.placement,f.orderedModifiers.forEach((function(e){return f.modifiersData[e.name]=Object.assign({},e.data)}));for(var r=0;r<f.orderedModifiers.length;r++)if(!0!==f.reset){var o=f.orderedModifiers[r],i=o.fn,a=o.options,s=void 0===a?{}:a,c=o.name;"function"==typeof i&&(f=i({state:f,options:s,name:c,instance:u})||f)}else f.reset=!1,r=-1}}},update:(i=function(){return new Promise((function(e){u.forceUpdate(),e(f)}))},function(){return s||(s=new Promise((function(e){Promise.resolve().then((function(){s=void 0,e(i())}))}))),s}),destroy:function(){l(),p=!0}};if(!Q(e,t))return u;function l(){c.forEach((function(e){return e()})),c=[]}return u.setOptions(r).then((function(e){!p&&r.onFirstUpdate&&r.onFirstUpdate(e)})),u}}var $={passive:!0};var ee={name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(e){var n=e.state,r=e.instance,o=e.options,i=o.scroll,a=void 0===i||i,s=o.resize,f=void 0===s||s,c=t(n.elements.popper),p=[].concat(n.scrollParents.reference,n.scrollParents.popper);return a&&p.forEach((function(e){e.addEventListener("scroll",r.update,$)})),f&&c.addEventListener("resize",r.update,$),function(){a&&p.forEach((function(e){e.removeEventListener("scroll",r.update,$)})),f&&c.removeEventListener("resize",r.update,$)}},data:{}};var te={name:"popperOffsets",enabled:!0,phase:"read",fn:function(e){var t=e.state,n=e.name;t.modifiersData[n]=X({reference:t.rects.reference,element:t.rects.popper,strategy:"absolute",placement:t.placement})},data:{}},ne={top:"auto",right:"auto",bottom:"auto",left:"auto"};function re(e){var n,r=e.popper,o=e.popperRect,i=e.placement,a=e.variation,f=e.offsets,c=e.position,p=e.gpuAcceleration,u=e.adaptive,l=e.roundOffsets,h=e.isFixed,v=f.x,y=void 0===v?0:v,g=f.y,b=void 0===g?0:g,x="function"==typeof l?l({x:y,y:b}):{x:y,y:b};y=x.x,b=x.y;var w=f.hasOwnProperty("x"),O=f.hasOwnProperty("y"),j=P,M=D,k=window;if(u){var W=E(r),H="clientHeight",T="clientWidth";if(W===t(r)&&"static"!==m(W=d(r)).position&&"absolute"===c&&(H="scrollHeight",T="scrollWidth"),W=W,i===D||(i===P||i===L)&&a===B)M=A,b-=(h&&W===k&&k.visualViewport?k.visualViewport.height:W[H])-o.height,b*=p?1:-1;if(i===P||(i===D||i===A)&&a===B)j=L,y-=(h&&W===k&&k.visualViewport?k.visualViewport.width:W[T])-o.width,y*=p?1:-1}var R,S=Object.assign({position:c},u&&ne),V=!0===l?function(e,t){var n=e.x,r=e.y,o=t.devicePixelRatio||1;return{x:s(n*o)/o||0,y:s(r*o)/o||0}}({x:y,y:b},t(r)):{x:y,y:b};return y=V.x,b=V.y,p?Object.assign({},S,((R={})[M]=O?"0":"",R[j]=w?"0":"",R.transform=(k.devicePixelRatio||1)<=1?"translate("+y+"px, "+b+"px)":"translate3d("+y+"px, "+b+"px, 0)",R)):Object.assign({},S,((n={})[M]=O?b+"px":"",n[j]=w?y+"px":"",n.transform="",n))}var oe={name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(e){var t=e.state,n=e.options,r=n.gpuAcceleration,o=void 0===r||r,i=n.adaptive,a=void 0===i||i,s=n.roundOffsets,f=void 0===s||s,c={placement:F(t.placement),variation:U(t.placement),popper:t.elements.popper,popperRect:t.rects.popper,gpuAcceleration:o,isFixed:"fixed"===t.options.strategy};null!=t.modifiersData.popperOffsets&&(t.styles.popper=Object.assign({},t.styles.popper,re(Object.assign({},c,{offsets:t.modifiersData.popperOffsets,position:t.options.strategy,adaptive:a,roundOffsets:f})))),null!=t.modifiersData.arrow&&(t.styles.arrow=Object.assign({},t.styles.arrow,re(Object.assign({},c,{offsets:t.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:f})))),t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-placement":t.placement})},data:{}};var ie={name:"applyStyles",enabled:!0,phase:"write",fn:function(e){var t=e.state;Object.keys(t.elements).forEach((function(e){var n=t.styles[e]||{},o=t.attributes[e]||{},i=t.elements[e];r(i)&&l(i)&&(Object.assign(i.style,n),Object.keys(o).forEach((function(e){var t=o[e];!1===t?i.removeAttribute(e):i.setAttribute(e,!0===t?"":t)})))}))},effect:function(e){var t=e.state,n={popper:{position:t.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(t.elements.popper.style,n.popper),t.styles=n,t.elements.arrow&&Object.assign(t.elements.arrow.style,n.arrow),function(){Object.keys(t.elements).forEach((function(e){var o=t.elements[e],i=t.attributes[e]||{},a=Object.keys(t.styles.hasOwnProperty(e)?t.styles[e]:n[e]).reduce((function(e,t){return e[t]="",e}),{});r(o)&&l(o)&&(Object.assign(o.style,a),Object.keys(i).forEach((function(e){o.removeAttribute(e)})))}))}},requires:["computeStyles"]};var ae={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(e){var t=e.state,n=e.options,r=e.name,o=n.offset,i=void 0===o?[0,0]:o,a=S.reduce((function(e,n){return e[n]=function(e,t,n){var r=F(e),o=[P,D].indexOf(r)>=0?-1:1,i="function"==typeof n?n(Object.assign({},t,{placement:e})):n,a=i[0],s=i[1];return a=a||0,s=(s||0)*o,[P,L].indexOf(r)>=0?{x:s,y:a}:{x:a,y:s}}(n,t.rects,i),e}),{}),s=a[t.placement],f=s.x,c=s.y;null!=t.modifiersData.popperOffsets&&(t.modifiersData.popperOffsets.x+=f,t.modifiersData.popperOffsets.y+=c),t.modifiersData[r]=a}},se={left:"right",right:"left",bottom:"top",top:"bottom"};function fe(e){return e.replace(/left|right|bottom|top/g,(function(e){return se[e]}))}var ce={start:"end",end:"start"};function pe(e){return e.replace(/start|end/g,(function(e){return ce[e]}))}function ue(e,t){void 0===t&&(t={});var n=t,r=n.placement,o=n.boundary,i=n.rootBoundary,a=n.padding,s=n.flipVariations,f=n.allowedAutoPlacements,c=void 0===f?S:f,p=U(r),u=p?s?R:R.filter((function(e){return U(e)===p})):k,l=u.filter((function(e){return c.indexOf(e)>=0}));0===l.length&&(l=u);var d=l.reduce((function(t,n){return t[n]=J(e,{placement:n,boundary:o,rootBoundary:i,padding:a})[F(n)],t}),{});return Object.keys(d).sort((function(e,t){return d[e]-d[t]}))}var le={name:"flip",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name;if(!t.modifiersData[r]._skip){for(var o=n.mainAxis,i=void 0===o||o,a=n.altAxis,s=void 0===a||a,f=n.fallbackPlacements,c=n.padding,p=n.boundary,u=n.rootBoundary,l=n.altBoundary,d=n.flipVariations,h=void 0===d||d,m=n.allowedAutoPlacements,v=t.options.placement,y=F(v),g=f||(y===v||!h?[fe(v)]:function(e){if(F(e)===M)return[];var t=fe(e);return[pe(e),t,pe(t)]}(v)),b=[v].concat(g).reduce((function(e,n){return e.concat(F(n)===M?ue(t,{placement:n,boundary:p,rootBoundary:u,padding:c,flipVariations:h,allowedAutoPlacements:m}):n)}),[]),x=t.rects.reference,w=t.rects.popper,O=new Map,j=!0,E=b[0],k=0;k<b.length;k++){var B=b[k],H=F(B),T=U(B)===W,R=[D,A].indexOf(H)>=0,S=R?"width":"height",V=J(t,{placement:B,boundary:p,rootBoundary:u,altBoundary:l,padding:c}),q=R?T?L:P:T?A:D;x[S]>w[S]&&(q=fe(q));var C=fe(q),N=[];if(i&&N.push(V[H]<=0),s&&N.push(V[q]<=0,V[C]<=0),N.every((function(e){return e}))){E=B,j=!1;break}O.set(B,N)}if(j)for(var I=function(e){var t=b.find((function(t){var n=O.get(t);if(n)return n.slice(0,e).every((function(e){return e}))}));if(t)return E=t,"break"},_=h?3:1;_>0;_--){if("break"===I(_))break}t.placement!==E&&(t.modifiersData[r]._skip=!0,t.placement=E,t.reset=!0)}},requiresIfExists:["offset"],data:{_skip:!1}};function de(e,t,n){return i(e,a(t,n))}var he={name:"preventOverflow",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name,o=n.mainAxis,s=void 0===o||o,f=n.altAxis,c=void 0!==f&&f,p=n.boundary,u=n.rootBoundary,l=n.altBoundary,d=n.padding,h=n.tether,m=void 0===h||h,v=n.tetherOffset,y=void 0===v?0:v,b=J(t,{boundary:p,rootBoundary:u,padding:d,altBoundary:l}),x=F(t.placement),w=U(t.placement),O=!w,j=z(x),M="x"===j?"y":"x",k=t.modifiersData.popperOffsets,B=t.rects.reference,H=t.rects.popper,T="function"==typeof y?y(Object.assign({},t.rects,{placement:t.placement})):y,R="number"==typeof T?{mainAxis:T,altAxis:T}:Object.assign({mainAxis:0,altAxis:0},T),S=t.modifiersData.offset?t.modifiersData.offset[t.placement]:null,V={x:0,y:0};if(k){if(s){var q,C="y"===j?D:P,N="y"===j?A:L,I="y"===j?"height":"width",_=k[j],X=_+b[C],Y=_-b[N],G=m?-H[I]/2:0,K=w===W?B[I]:H[I],Q=w===W?-H[I]:-B[I],Z=t.elements.arrow,$=m&&Z?g(Z):{width:0,height:0},ee=t.modifiersData["arrow#persistent"]?t.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},te=ee[C],ne=ee[N],re=de(0,B[I],$[I]),oe=O?B[I]/2-G-re-te-R.mainAxis:K-re-te-R.mainAxis,ie=O?-B[I]/2+G+re+ne+R.mainAxis:Q+re+ne+R.mainAxis,ae=t.elements.arrow&&E(t.elements.arrow),se=ae?"y"===j?ae.clientTop||0:ae.clientLeft||0:0,fe=null!=(q=null==S?void 0:S[j])?q:0,ce=_+ie-fe,pe=de(m?a(X,_+oe-fe-se):X,_,m?i(Y,ce):Y);k[j]=pe,V[j]=pe-_}if(c){var ue,le="x"===j?D:P,he="x"===j?A:L,me=k[M],ve="y"===M?"height":"width",ye=me+b[le],ge=me-b[he],be=-1!==[D,P].indexOf(x),xe=null!=(ue=null==S?void 0:S[M])?ue:0,we=be?ye:me-B[ve]-H[ve]-xe+R.altAxis,Oe=be?me+B[ve]+H[ve]-xe-R.altAxis:ge,je=m&&be?function(e,t,n){var r=de(e,t,n);return r>n?n:r}(we,me,Oe):de(m?we:ye,me,m?Oe:ge);k[M]=je,V[M]=je-me}t.modifiersData[r]=V}},requiresIfExists:["offset"]};var me={name:"arrow",enabled:!0,phase:"main",fn:function(e){var t,n=e.state,r=e.name,o=e.options,i=n.elements.arrow,a=n.modifiersData.popperOffsets,s=F(n.placement),f=z(s),c=[P,L].indexOf(s)>=0?"height":"width";if(i&&a){var p=function(e,t){return Y("number"!=typeof(e="function"==typeof e?e(Object.assign({},t.rects,{placement:t.placement})):e)?e:G(e,k))}(o.padding,n),u=g(i),l="y"===f?D:P,d="y"===f?A:L,h=n.rects.reference[c]+n.rects.reference[f]-a[f]-n.rects.popper[c],m=a[f]-n.rects.reference[f],v=E(i),y=v?"y"===f?v.clientHeight||0:v.clientWidth||0:0,b=h/2-m/2,x=p[l],w=y-u[c]-p[d],O=y/2-u[c]/2+b,j=de(x,O,w),M=f;n.modifiersData[r]=((t={})[M]=j,t.centerOffset=j-O,t)}},effect:function(e){var t=e.state,n=e.options.element,r=void 0===n?"[data-popper-arrow]":n;null!=r&&("string"!=typeof r||(r=t.elements.popper.querySelector(r)))&&C(t.elements.popper,r)&&(t.elements.arrow=r)},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function ve(e,t,n){return void 0===n&&(n={x:0,y:0}),{top:e.top-t.height-n.y,right:e.right-t.width+n.x,bottom:e.bottom-t.height+n.y,left:e.left-t.width-n.x}}function ye(e){return[D,L,A,P].some((function(t){return e[t]>=0}))}var ge={name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(e){var t=e.state,n=e.name,r=t.rects.reference,o=t.rects.popper,i=t.modifiersData.preventOverflow,a=J(t,{elementContext:"reference"}),s=J(t,{altBoundary:!0}),f=ve(a,r),c=ve(s,o,i),p=ye(f),u=ye(c);t.modifiersData[n]={referenceClippingOffsets:f,popperEscapeOffsets:c,isReferenceHidden:p,hasPopperEscaped:u},t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-reference-hidden":p,"data-popper-escaped":u})}},be=Z({defaultModifiers:[ee,te,oe,ie]}),xe=[ee,te,oe,ie,ae,le,he,me,ge],we=Z({defaultModifiers:xe});e.applyStyles=ie,e.arrow=me,e.computeStyles=oe,e.createPopper=we,e.createPopperLite=be,e.defaultModifiers=xe,e.detectOverflow=J,e.eventListeners=ee,e.flip=le,e.hide=ge,e.offset=ae,e.popperGenerator=Z,e.popperOffsets=te,e.preventOverflow=he,Object.defineProperty(e,"__esModule",{value:!0})}));

},{}],56:[function(require,module,exports){
/*!
 * @splidejs/splide-extension-grid
 * Version  : 0.4.1
 * License  : MIT
 * Copyright: 2022 Naotoshi Fujita
*/(function(O){typeof define=="function"&&define.amd?define(O):O()})(function(){"use strict";function O(n){n.length=0}function S(n,t,i){return Array.prototype.slice.call(n,t,i)}function T(n){return n.bind.apply(n,[null].concat(S(arguments,1)))}function V(n,t){return typeof t===n}var Q=Array.isArray;T(V,"function"),T(V,"string"),T(V,"undefined");function X(n){return Q(n)?n:[n]}function Z(n,t){X(n).forEach(t)}var hn=Object.keys;function En(n,t,i){if(n){var r=hn(n);r=i?r.reverse():r;for(var f=0;f<r.length;f++){var a=r[f];if(a!=="__proto__"&&t(n[a],a)===!1)break}}return n}function gn(n){return S(arguments,1).forEach(function(t){En(t,function(i,r){n[r]=t[r]})}),n}var j="splide";function mn(){var n=[];function t(u,c,l,v){f(u,c,function(d,g,m){var _="addEventListener"in d,C=_?d.removeEventListener.bind(d,g,l,v):d.removeListener.bind(d,l);_?d.addEventListener(g,l,v):d.addListener(l),n.push([d,g,m,l,C])})}function i(u,c,l){f(u,c,function(v,d,g){n=n.filter(function(m){return m[0]===v&&m[1]===d&&m[2]===g&&(!l||m[3]===l)?(m[4](),!1):!0})})}function r(u,c,l){var v,d=!0;return typeof CustomEvent=="function"?v=new CustomEvent(c,{bubbles:d,detail:l}):(v=document.createEvent("CustomEvent"),v.initCustomEvent(c,d,!1,l)),u.dispatchEvent(v),v}function f(u,c,l){Z(u,function(v){v&&Z(c,function(d){d.split(" ").forEach(function(g){var m=g.split(".");l(v,m[0],m[1])})})})}function a(){n.forEach(function(u){u[4]()}),O(n)}return{bind:t,unbind:i,dispatch:r,destroy:a}}var pn="visible",yn="hidden",H="refresh",wn="updated",_n="destroy";function k(n){var t=n?n.event.bus:document.createDocumentFragment(),i=mn();function r(a,u){i.bind(t,X(a).join(" "),function(c){u.apply(u,Q(c.detail)?c.detail:[])})}function f(a){i.dispatch(t,a,S(arguments,1))}return n&&n.event.on(_n,i.destroy),gn(i,{bus:t,on:r,off:T(i.unbind,t),emit:f})}var Cn=j,$=j+"__slide",An=$+"__container";function nn(n){n.length=0}function I(n,t,i){return Array.prototype.slice.call(n,t,i)}function B(n){return n.bind.apply(n,[null].concat(I(arguments,1)))}function N(n,t){return typeof t===n}function bn(n){return!P(n)&&N("object",n)}var F=Array.isArray;B(N,"function");var G=B(N,"string"),Ln=B(N,"undefined");function P(n){return n===null}function Dn(n){return n instanceof HTMLElement}function U(n){return F(n)?n:[n]}function A(n,t){U(n).forEach(t)}function tn(n,t){return n.push.apply(n,U(t)),n}function rn(n,t,i){n&&A(t,function(r){r&&n.classList[i?"add":"remove"](r)})}function q(n,t){rn(n,G(t)?t.split(" "):t,!0)}function R(n,t){A(t,n.appendChild.bind(n))}function On(n,t){return Dn(n)&&(n.msMatchesSelector||n.matches).call(n,t)}function Tn(n,t){var i=n?I(n.children):[];return t?i.filter(function(r){return On(r,t)}):i}function on(n,t){return t?Tn(n,t)[0]:n.firstElementChild}var en=Object.keys;function un(n,t,i){if(n){var r=en(n);r=i?r.reverse():r;for(var f=0;f<r.length;f++){var a=r[f];if(a!=="__proto__"&&t(n[a],a)===!1)break}}return n}function $n(n){return I(arguments,1).forEach(function(t){un(t,function(i,r){n[r]=t[r]})}),n}function In(n,t){U(t||en(n)).forEach(function(i){delete n[i]})}function J(n,t){A(n,function(i){A(t,function(r){i&&i.removeAttribute(r)})})}function K(n,t,i){bn(t)?un(t,function(r,f){K(n,f,r)}):A(n,function(r){P(i)||i===""?J(r,t):r.setAttribute(t,String(i))})}function fn(n,t,i){var r=document.createElement(n);return t&&(G(t)?q(r,t):K(r,t)),i&&R(i,r),r}function p(n,t,i){if(Ln(i))return getComputedStyle(n)[t];P(i)||(n.style[t]=""+i)}function Nn(n,t){return n&&n.classList.contains(t)}function Rn(n){A(n,function(t){t&&t.parentNode&&t.parentNode.removeChild(t)})}function an(n,t){return t?I(n.querySelectorAll(t)):[]}function cn(n,t){rn(n,t,!1)}function x(n){return G(n)?n:n?n+"px":""}var xn="splide";function Mn(n,t){if(!n)throw new Error("["+xn+"] "+(t||""))}var Sn=Math.min,Un=Math.max,qn=Math.floor,Jn=Math.ceil,Kn=Math.abs;function Vn(n){return n<10?"0"+n:""+n}var sn=$+"__row",z=$+"--col",Hn={rows:1,cols:1,dimensions:[],gap:{}};function Bn(n){function t(){var f=n.rows,a=n.cols,u=n.dimensions;return F(u)&&u.length?u:[[f,a]]}function i(f){var a=t();return a[Sn(f,a.length-1)]}function r(f){for(var a=t(),u,c,l=0,v=0;v<a.length;v++){var d=a[v];if(u=d[0]||1,c=d[1]||1,l+=u*c,f<l)break}return Mn(u&&c,"Invalid dimension"),[u,c]}return{get:i,getAt:r}}function Fn(n,t,i){var r=k(n),f=r.on,a=r.destroy,u=n.Components,c=n.options,l=u.Direction.resolve,v=u.Slides.forEach;function d(){m(),c.slideFocus&&(f(pn,W),f(yn,Y))}function g(){v(function(e){var s=e.slide;D(s,!1),M(s).forEach(function(o){J(o,"style")}),b(s).forEach(function(o){L(o,!0),J(o,"style")})}),a()}function m(){v(function(e){var s=e.slide,o=i.get(e.isClone?e.slideIndex:e.index),h=o[0],E=o[1];_(h,s),C(E,s),b(e.slide).forEach(function(y,w){y.id=e.slide.id+"-col"+Vn(w+1),n.options.cover&&L(y)})})}function _(e,s){var o=t.gap.row,h="calc("+100/e+"%"+(o?" - "+x(o)+" * "+(e-1)/e:"")+")";M(s).forEach(function(E,y,w){p(E,"height",h),p(E,"display","flex"),p(E,"margin","0 0 "+x(o)+" 0"),p(E,"padding",0),y===w.length-1&&p(E,"marginBottom",0)})}function C(e,s){var o=t.gap.col,h="calc("+100/e+"%"+(o?" - "+x(o)+" * "+(e-1)/e:"")+")";b(s).forEach(function(E,y,w){p(E,"width",h),y!==w.length-1&&p(E,l("marginRight"),x(o))})}function L(e,s){var o=on(e,"."+An),h=on(o||e,"img");h&&h.src&&(p(o||e,"background",s?"":'center/cover no-repeat url("'+h.src+'")'),p(h,"display",s?"":"none"))}function M(e){return an(e,"."+sn)}function b(e){return an(e,"."+z)}function D(e,s){b(e).forEach(function(o){K(o,"tabindex",s?0:null)})}function W(e){D(e.slide,!0)}function Y(e){D(e.slide,!1)}return{mount:d,destroy:g}}function Gn(n,t,i){var r=k(n),f=r.on,a=r.off,u=t.Elements,c={},l=Bn(c),v=Fn(n,c,l),d=Cn+"--grid",g=[];function m(){_(),f(wn,_)}function _(){In(c),$n(c,Hn,i.grid||{}),Y()?(C(),tn(g,u.slides),q(n.root,d),R(u.list,b()),a(H),f(H,M),L()):e()&&(C(),L())}function C(){if(e()){var s=u.slides;v.destroy(),g.forEach(function(o){cn(o,z),R(u.list,o)}),Rn(s),cn(n.root,d),nn(s),tn(s,g),nn(g),a(H)}}function L(){n.refresh()}function M(){e()&&v.mount()}function b(){var s=[],o=0,h=0,E,y;return g.forEach(function(w,Pn){var dn=l.getAt(Pn),vn=dn[0],ln=dn[1];h||(o||(E=fn(w.tagName,$),s.push(E)),y=D(vn,w,E)),W(ln,w,y),++h>=ln&&(h=0,o=++o>=vn?0:o)}),s}function D(s,o,h){var E=o.tagName.toLowerCase()==="li"?"ul":"div";return fn(E,sn,h)}function W(s,o,h){return q(o,z),R(h,o),o}function Y(){if(i.grid){var s=c.rows,o=c.cols,h=c.dimensions;return s>1||o>1||F(h)&&h.length>0}return!1}function e(){return Nn(n.root,d)}return{mount:m,destroy:C}}typeof window<"u"&&(window.splide=window.splide||{},window.splide.Extensions=window.splide.Extensions||{},window.splide.Extensions.Grid=Gn)});

},{}],57:[function(require,module,exports){
function r(n,t){for(var i=0;i<t.length;i++){var r=t[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function Jt(n,t,i){t&&r(n.prototype,t),i&&r(n,i),Object.defineProperty(n,"prototype",{writable:!1})}
/*!
 * Splide.js
 * Version  : 4.1.4
 * License  : MIT
 * Copyright: 2022 Naotoshi Fujita
 */
var n,t;n=this,t=function(){"use strict";var v="(prefers-reduced-motion: reduce)",G=4,rn=5,r={CREATED:1,MOUNTED:2,IDLE:3,MOVING:G,SCROLLING:rn,DRAGGING:6,DESTROYED:7};function D(n){n.length=0}function o(n,t,i){return Array.prototype.slice.call(n,t,i)}function R(n){return n.bind.apply(n,[null].concat(o(arguments,1)))}function on(){}var p=setTimeout;function h(n){return requestAnimationFrame(n)}function u(n,t){return typeof t===n}function un(n){return!c(n)&&u("object",n)}var e=Array.isArray,x=R(u,"function"),C=R(u,"string"),en=R(u,"undefined");function c(n){return null===n}function m(n){try{return n instanceof(n.ownerDocument.defaultView||window).HTMLElement}catch(n){return!1}}function y(n){return e(n)?n:[n]}function g(n,t){y(n).forEach(t)}function b(n,t){return-1<n.indexOf(t)}function k(n,t){return n.push.apply(n,y(t)),n}function A(t,n,i){t&&g(n,function(n){n&&t.classList[i?"add":"remove"](n)})}function M(n,t){A(n,C(t)?t.split(" "):t,!0)}function L(n,t){g(t,n.appendChild.bind(n))}function O(n,i){g(n,function(n){var t=(i||n).parentNode;t&&t.insertBefore(n,i)})}function cn(n,t){return m(n)&&(n.msMatchesSelector||n.matches).call(n,t)}function S(n,t){n=n?o(n.children):[];return t?n.filter(function(n){return cn(n,t)}):n}function fn(n,t){return t?S(n,t)[0]:n.firstElementChild}var E=Object.keys;function w(t,i,n){t&&(n?E(t).reverse():E(t)).forEach(function(n){"__proto__"!==n&&i(t[n],n)})}function an(r){return o(arguments,1).forEach(function(i){w(i,function(n,t){r[t]=i[t]})}),r}function d(i){return o(arguments,1).forEach(function(n){w(n,function(n,t){e(n)?i[t]=n.slice():un(n)?i[t]=d({},un(i[t])?i[t]:{},n):i[t]=n})}),i}function sn(t,n){g(n||E(t),function(n){delete t[n]})}function P(n,i){g(n,function(t){g(i,function(n){t&&t.removeAttribute(n)})})}function I(i,t,r){un(t)?w(t,function(n,t){I(i,t,n)}):g(i,function(n){c(r)||""===r?P(n,t):n.setAttribute(t,String(r))})}function j(n,t,i){n=document.createElement(n);return t&&(C(t)?M:I)(n,t),i&&L(i,n),n}function _(n,t,i){if(en(i))return getComputedStyle(n)[t];c(i)||(n.style[t]=""+i)}function ln(n,t){_(n,"display",t)}function dn(n){n.setActive&&n.setActive()||n.focus({preventScroll:!0})}function z(n,t){return n.getAttribute(t)}function vn(n,t){return n&&n.classList.contains(t)}function N(n){return n.getBoundingClientRect()}function T(n){g(n,function(n){n&&n.parentNode&&n.parentNode.removeChild(n)})}function hn(n){return fn((new DOMParser).parseFromString(n,"text/html").body)}function F(n,t){n.preventDefault(),t&&(n.stopPropagation(),n.stopImmediatePropagation())}function pn(n,t){return n&&n.querySelector(t)}function gn(n,t){return t?o(n.querySelectorAll(t)):[]}function X(n,t){A(n,t,!1)}function mn(n){return n.timeStamp}function W(n){return C(n)?n:n?n+"px":""}var yn="splide",f="data-"+yn;function bn(n,t){if(!n)throw new Error("["+yn+"] "+(t||""))}var Y=Math.min,wn=Math.max,xn=Math.floor,kn=Math.ceil,U=Math.abs;function Sn(n,t,i){return U(n-t)<i}function En(n,t,i,r){var o=Y(t,i),t=wn(t,i);return r?o<n&&n<t:o<=n&&n<=t}function q(n,t,i){var r=Y(t,i),t=wn(t,i);return Y(wn(r,n),t)}function Ln(n){return(0<n)-(n<0)}function On(t,n){return g(n,function(n){t=t.replace("%s",""+n)}),t}function An(n){return n<10?"0"+n:""+n}var _n={};function zn(){var c=[];function i(n,i,r){g(n,function(t){t&&g(i,function(n){n.split(" ").forEach(function(n){n=n.split(".");r(t,n[0],n[1])})})})}return{bind:function(n,t,u,e){i(n,t,function(n,t,i){var r="addEventListener"in n,o=r?n.removeEventListener.bind(n,t,u,e):n.removeListener.bind(n,u);r?n.addEventListener(t,u,e):n.addListener(u),c.push([n,t,i,u,o])})},unbind:function(n,t,o){i(n,t,function(t,i,r){c=c.filter(function(n){return!!(n[0]!==t||n[1]!==i||n[2]!==r||o&&n[3]!==o)||(n[4](),!1)})})},dispatch:function(n,t,i){var r;return"function"==typeof CustomEvent?r=new CustomEvent(t,{bubbles:!0,detail:i}):(r=document.createEvent("CustomEvent")).initCustomEvent(t,!0,!1,i),n.dispatchEvent(r),r},destroy:function(){c.forEach(function(n){n[4]()}),D(c)}}}var B="mounted",H="move",Dn="moved",Mn="click",Pn="active",In="inactive",Rn="visible",Cn="hidden",J="refresh",K="updated",jn="resize",Nn="resized",Tn="scroll",V="scrolled",a="destroy",Gn="navigation:mounted",Fn="autoplay:play",Xn="autoplay:pause",Wn="lazyload:loaded",Yn="sk",Un="sh";function Q(n){var i=n?n.event.bus:document.createDocumentFragment(),r=zn();return n&&n.event.on(a,r.destroy),an(r,{bus:i,on:function(n,t){r.bind(i,y(n).join(" "),function(n){t.apply(t,e(n.detail)?n.detail:[])})},off:R(r.unbind,i),emit:function(n){r.dispatch(i,n,o(arguments,1))}})}function qn(t,n,i,r){var o,u,e=Date.now,c=0,f=!0,a=0;function s(){if(!f){if(c=t?Y((e()-o)/t,1):1,i&&i(c),1<=c&&(n(),o=e(),r&&++a>=r))return l();u=h(s)}}function l(){f=!0}function d(){u&&cancelAnimationFrame(u),f=!(u=c=0)}return{start:function(n){n||d(),o=e()-(n?c*t:0),f=!1,u=h(s)},rewind:function(){o=e(),c=0,i&&i(c)},pause:l,cancel:d,set:function(n){t=n},isPaused:function(){return f}}}function s(n){var t=n;return{set:function(n){t=n},is:function(n){return b(y(n),t)}}}var n="Arrow",Bn=n+"Left",Hn=n+"Right",t=n+"Up",n=n+"Down",Jn="ttb",l={width:["height"],left:["top","right"],right:["bottom","left"],x:["y"],X:["Y"],Y:["X"],ArrowLeft:[t,Hn],ArrowRight:[n,Bn]};var Z="role",$="tabindex",i="aria-",Kn=i+"controls",Vn=i+"current",Qn=i+"selected",nn=i+"label",Zn=i+"labelledby",$n=i+"hidden",nt=i+"orientation",tt=i+"roledescription",it=i+"live",rt=i+"busy",ot=i+"atomic",ut=[Z,$,"disabled",Kn,Vn,nn,Zn,$n,nt,tt],i=yn+"__",et=yn,ct=i+"track",ft=i+"list",at=i+"slide",st=at+"--clone",lt=at+"__container",dt=i+"arrows",vt=i+"arrow",ht=vt+"--prev",pt=vt+"--next",gt=i+"pagination",mt=gt+"__page",yt=i+"progress"+"__bar",bt=i+"toggle",wt=i+"sr",tn="is-active",xt="is-prev",kt="is-next",St="is-visible",Et="is-loading",Lt="is-focus-in",Ot="is-overflow",At=[tn,St,xt,kt,Et,Lt,Ot];var _t="touchstart mousedown",zt="touchmove mousemove",Dt="touchend touchcancel mouseup click";var Mt="slide",Pt="loop",It="fade";function Rt(o,r,t,u){var e,n=Q(o),i=n.on,c=n.emit,f=n.bind,a=o.Components,s=o.root,l=o.options,d=l.isNavigation,v=l.updateOnMove,h=l.i18n,p=l.pagination,g=l.slideFocus,m=a.Direction.resolve,y=z(u,"style"),b=z(u,nn),w=-1<t,x=fn(u,"."+lt);function k(){var n=o.splides.map(function(n){n=n.splide.Components.Slides.getAt(r);return n?n.slide.id:""}).join(" ");I(u,nn,On(h.slideX,(w?t:r)+1)),I(u,Kn,n),I(u,Z,g?"button":""),g&&P(u,tt)}function S(){e||E()}function E(){var n,t,i;e||(n=o.index,(i=L())!==vn(u,tn)&&(A(u,tn,i),I(u,Vn,d&&i||""),c(i?Pn:In,O)),i=function(){if(o.is(It))return L();var n=N(a.Elements.track),t=N(u),i=m("left",!0),r=m("right",!0);return xn(n[i])<=kn(t[i])&&xn(t[r])<=kn(n[r])}(),t=!i&&(!L()||w),o.state.is([G,rn])||I(u,$n,t||""),I(gn(u,l.focusableNodes||""),$,t?-1:""),g&&I(u,$,t?-1:0),i!==vn(u,St)&&(A(u,St,i),c(i?Rn:Cn,O)),i||document.activeElement!==u||(t=a.Slides.getAt(o.index))&&dn(t.slide),A(u,xt,r===n-1),A(u,kt,r===n+1))}function L(){var n=o.index;return n===r||l.cloneStatus&&n===t}var O={index:r,slideIndex:t,slide:u,container:x,isClone:w,mount:function(){w||(u.id=s.id+"-slide"+An(r+1),I(u,Z,p?"tabpanel":"group"),I(u,tt,h.slide),I(u,nn,b||On(h.slideLabel,[r+1,o.length]))),f(u,"click",R(c,Mn,O)),f(u,"keydown",R(c,Yn,O)),i([Dn,Un,V],E),i(Gn,k),v&&i(H,S)},destroy:function(){e=!0,n.destroy(),X(u,At),P(u,ut),I(u,"style",y),I(u,nn,b||"")},update:E,style:function(n,t,i){_(i&&x||u,n,t)},isWithin:function(n,t){return n=U(n-r),(n=w||!l.rewind&&!o.is(Pt)?n:Y(n,o.length-n))<=t}};return O}var Ct=f+"-interval";var jt={passive:!1,capture:!0};var Nt={Spacebar:" ",Right:Hn,Left:Bn,Up:t,Down:n};function Tt(n){return n=C(n)?n:n.key,Nt[n]||n}var Gt="keydown";var Ft=f+"-lazy",Xt=Ft+"-srcset",Wt="["+Ft+"], ["+Xt+"]";var Yt=[" ","Enter"];var Ut=Object.freeze({__proto__:null,Media:function(r,n,o){var u=r.state,t=o.breakpoints||{},e=o.reducedMotion||{},i=zn(),c=[];function f(n){n&&i.destroy()}function a(n,t){t=matchMedia(t);i.bind(t,"change",s),c.push([n,t])}function s(){var n=u.is(7),t=o.direction,i=c.reduce(function(n,t){return d(n,t[1].matches?t[0]:{})},{});sn(o),l(i),o.destroy?r.destroy("completely"===o.destroy):n?(f(!0),r.mount()):t!==o.direction&&r.refresh()}function l(n,t,i){d(o,n),t&&d(Object.getPrototypeOf(o),n),!i&&u.is(1)||r.emit(K,o)}return{setup:function(){var i="min"===o.mediaQuery;E(t).sort(function(n,t){return i?+n-+t:+t-+n}).forEach(function(n){a(t[n],"("+(i?"min":"max")+"-width:"+n+"px)")}),a(e,v),s()},destroy:f,reduce:function(n){matchMedia(v).matches&&(n?d(o,e):sn(o,E(e)))},set:l}},Direction:function(n,t,o){return{resolve:function(n,t,i){var r="rtl"!==(i=i||o.direction)||t?i===Jn?0:-1:1;return l[n]&&l[n][r]||n.replace(/width|left|right/i,function(n,t){n=l[n.toLowerCase()][r]||n;return 0<t?n.charAt(0).toUpperCase()+n.slice(1):n})},orient:function(n){return n*("rtl"===o.direction?1:-1)}}},Elements:function(n,t,i){var r,o,u,e=Q(n),c=e.on,f=e.bind,a=n.root,s=i.i18n,l={},d=[],v=[],h=[];function p(){r=y("."+ct),o=fn(r,"."+ft),bn(r&&o,"A track/list element is missing."),k(d,S(o,"."+at+":not(."+st+")")),w({arrows:dt,pagination:gt,prev:ht,next:pt,bar:yt,toggle:bt},function(n,t){l[t]=y("."+n)}),an(l,{root:a,track:r,list:o,slides:d});var n=a.id||function(n){return""+n+An(_n[n]=(_n[n]||0)+1)}(yn),t=i.role;a.id=n,r.id=r.id||n+"-track",o.id=o.id||n+"-list",!z(a,Z)&&"SECTION"!==a.tagName&&t&&I(a,Z,t),I(a,tt,s.carousel),I(o,Z,"presentation"),m()}function g(n){var t=ut.concat("style");D(d),X(a,v),X(r,h),P([r,o],t),P(a,n?t:["style",tt])}function m(){X(a,v),X(r,h),v=b(et),h=b(ct),M(a,v),M(r,h),I(a,nn,i.label),I(a,Zn,i.labelledby)}function y(n){n=pn(a,n);return n&&function(n,t){if(x(n.closest))return n.closest(t);for(var i=n;i&&1===i.nodeType&&!cn(i,t);)i=i.parentElement;return i}(n,"."+et)===a?n:void 0}function b(n){return[n+"--"+i.type,n+"--"+i.direction,i.drag&&n+"--draggable",i.isNavigation&&n+"--nav",n===et&&tn]}return an(l,{setup:p,mount:function(){c(J,g),c(J,p),c(K,m),f(document,_t+" keydown",function(n){u="keydown"===n.type},{capture:!0}),f(a,"focusin",function(){A(a,Lt,!!u)})},destroy:g})},Slides:function(r,o,u){var n=Q(r),t=n.on,e=n.emit,c=n.bind,f=(n=o.Elements).slides,a=n.list,s=[];function i(){f.forEach(function(n,t){d(n,t,-1)})}function l(){h(function(n){n.destroy()}),D(s)}function d(n,t,i){t=Rt(r,t,i,n);t.mount(),s.push(t),s.sort(function(n,t){return n.index-t.index})}function v(n){return n?p(function(n){return!n.isClone}):s}function h(n,t){v(t).forEach(n)}function p(t){return s.filter(x(t)?t:function(n){return C(t)?cn(n.slide,t):b(y(t),n.index)})}return{mount:function(){i(),t(J,l),t(J,i)},destroy:l,update:function(){h(function(n){n.update()})},register:d,get:v,getIn:function(n){var t=o.Controller,i=t.toIndex(n),r=t.hasFocus()?1:u.perPage;return p(function(n){return En(n.index,i,i+r-1)})},getAt:function(n){return p(n)[0]},add:function(n,o){g(n,function(n){var t,i,r;m(n=C(n)?hn(n):n)&&((t=f[o])?O(n,t):L(a,n),M(n,u.classes.slide),t=n,i=R(e,jn),t=gn(t,"img"),(r=t.length)?t.forEach(function(n){c(n,"load error",function(){--r||i()})}):i())}),e(J)},remove:function(n){T(p(n).map(function(n){return n.slide})),e(J)},forEach:h,filter:p,style:function(t,i,r){h(function(n){n.style(t,i,r)})},getLength:function(n){return(n?f:s).length},isEnough:function(){return s.length>u.perPage}}},Layout:function(t,n,i){var r,o,u,e=(a=Q(t)).on,c=a.bind,f=a.emit,a=n.Slides,s=n.Direction.resolve,l=(n=n.Elements).root,d=n.track,v=n.list,h=a.getAt,p=a.style;function g(){r=i.direction===Jn,_(l,"maxWidth",W(i.width)),_(d,s("paddingLeft"),y(!1)),_(d,s("paddingRight"),y(!0)),m(!0)}function m(n){var t=N(l);!n&&o.width===t.width&&o.height===t.height||(_(d,"height",function(){var n="";r&&(bn(n=b(),"height or heightRatio is missing."),n="calc("+n+" - "+y(!1)+" - "+y(!0)+")");return n}()),p(s("marginRight"),W(i.gap)),p("width",i.autoWidth?null:W(i.fixedWidth)||(r?"":w())),p("height",W(i.fixedHeight)||(r?i.autoHeight?null:w():b()),!0),o=t,f(Nn),u!==(u=O())&&(A(l,Ot,u),f("overflow",u)))}function y(n){var t=i.padding,n=s(n?"right":"left");return t&&W(t[n]||(un(t)?0:t))||"0px"}function b(){return W(i.height||N(v).width*i.heightRatio)}function w(){var n=W(i.gap);return"calc((100%"+(n&&" + "+n)+")/"+(i.perPage||1)+(n&&" - "+n)+")"}function x(){return N(v)[s("width")]}function k(n,t){n=h(n||0);return n?N(n.slide)[s("width")]+(t?0:L()):0}function S(n,t){var i,n=h(n);return n?(n=N(n.slide)[s("right")],i=N(v)[s("left")],U(n-i)+(t?0:L())):0}function E(n){return S(t.length-1)-S(0)+k(0,n)}function L(){var n=h(0);return n&&parseFloat(_(n.slide,s("marginRight")))||0}function O(){return t.is(It)||E(!0)>x()}return{mount:function(){var n,t,i;g(),c(window,"resize load",(n=R(f,jn),i=qn(t||0,n,null,1),function(){i.isPaused()&&i.start()})),e([K,J],g),e(jn,m)},resize:m,listSize:x,slideSize:k,sliderSize:E,totalSize:S,getPadding:function(n){return parseFloat(_(d,s("padding"+(n?"Right":"Left"))))||0},isOverflow:O}},Clones:function(c,i,f){var t,r=Q(c),n=r.on,a=i.Elements,s=i.Slides,o=i.Direction.resolve,l=[];function u(){if(n(J,d),n([K,jn],v),t=h()){var o=t,u=s.get().slice(),e=u.length;if(e){for(;u.length<o;)k(u,u);k(u.slice(-o),u.slice(0,o)).forEach(function(n,t){var i=t<o,r=function(n,t){n=n.cloneNode(!0);return M(n,f.classes.clone),n.id=c.root.id+"-clone"+An(t+1),n}(n.slide,t);i?O(r,u[0].slide):L(a.list,r),k(l,r),s.register(r,t-o+(i?0:e),n.index)})}i.Layout.resize(!0)}}function d(){e(),u()}function e(){T(l),D(l),r.destroy()}function v(){var n=h();t!==n&&(t<n||!n)&&r.emit(J)}function h(){var n,t=f.clones;return c.is(Pt)?en(t)&&(t=(n=f[o("fixedWidth")]&&i.Layout.slideSize(0))&&kn(N(a.track)[o("width")]/n)||f[o("autoWidth")]&&c.length||2*f.perPage):t=0,t}return{mount:u,destroy:e}},Move:function(r,c,o){var e,n=Q(r),t=n.on,f=n.emit,a=r.state.set,u=(n=c.Layout).slideSize,i=n.getPadding,s=n.totalSize,l=n.listSize,d=n.sliderSize,v=(n=c.Direction).resolve,h=n.orient,p=(n=c.Elements).list,g=n.track;function m(){c.Controller.isBusy()||(c.Scroll.cancel(),y(r.index),c.Slides.update())}function y(n){b(S(n,!0))}function b(n,t){r.is(It)||(t=t?n:function(n){{var t,i;r.is(Pt)&&(t=k(n),i=t>c.Controller.getEnd(),(t<0||i)&&(n=w(n,i)))}return n}(n),_(p,"transform","translate"+v("X")+"("+t+"px)"),n!==t&&f(Un))}function w(n,t){var i=n-L(t),r=d();return n-=h(r*(kn(U(i)/r)||1))*(t?1:-1)}function x(){b(E(),!0),e.cancel()}function k(n){for(var t=c.Slides.get(),i=0,r=1/0,o=0;o<t.length;o++){var u=t[o].index,e=U(S(u,!0)-n);if(!(e<=r))break;r=e,i=u}return i}function S(n,t){var i=h(s(n-1)-(n=n,"center"===(i=o.focus)?(l()-u(n,!0))/2:+i*u(n)||0));return t?(n=i,n=o.trimSpace&&r.is(Mt)?q(n,0,h(d(!0)-l())):n):i}function E(){var n=v("left");return N(p)[n]-N(g)[n]+h(i(!1))}function L(n){return S(n?c.Controller.getEnd():0,!!o.trimSpace)}return{mount:function(){e=c.Transition,t([B,Nn,K,J],m)},move:function(n,t,i,r){var o,u;n!==t&&(o=i<n,u=h(w(E(),o)),o?0<=u:u<=p[v("scrollWidth")]-N(g)[v("width")])&&(x(),b(w(E(),i<n),!0)),a(G),f(H,t,i,n),e.start(t,function(){a(3),f(Dn,t,i,n),r&&r()})},jump:y,translate:b,shift:w,cancel:x,toIndex:k,toPosition:S,getPosition:E,getLimit:L,exceededLimit:function(n,t){t=en(t)?E():t;var i=!0!==n&&h(t)<h(L(!1)),n=!1!==n&&h(t)>h(L(!0));return i||n},reposition:m}},Controller:function(o,u,e){var c,f,a,s,n=Q(o),t=n.on,i=n.emit,l=u.Move,d=l.getPosition,r=l.getLimit,v=l.toPosition,h=(n=u.Slides).isEnough,p=n.getLength,g=e.omitEnd,m=o.is(Pt),y=o.is(Mt),b=R(L,!1),w=R(L,!0),x=e.start||0,k=x;function S(){f=p(!0),a=e.perMove,s=e.perPage,c=_();var n=q(x,0,g?c:f-1);n!==x&&(x=n,l.reposition())}function E(){c!==_()&&i("ei")}function L(n,t){var i=a||(P()?1:s),i=O(x+i*(n?-1:1),x,!(a||P()));return-1===i&&y&&!Sn(d(),r(!n),1)?n?0:c:t?i:A(i)}function O(n,t,i){var r;return h()||P()?((r=function(n){if(y&&"move"===e.trimSpace&&n!==x)for(var t=d();t===v(n,!0)&&En(n,0,o.length-1,!e.rewind);)n<x?--n:++n;return n}(n))!==n&&(t=n,n=r,i=!1),n<0||c<n?n=a||!En(0,n,t,!0)&&!En(c,t,n,!0)?m?i?n<0?-(f%s||s):f:n:e.rewind?n<0?c:0:-1:z(D(n)):i&&n!==t&&(n=z(D(t)+(n<t?-1:1)))):n=-1,n}function A(n){return m?(n+f)%f||0:n}function _(){for(var n=f-(P()||m&&a?1:s);g&&0<n--;)if(v(f-1,!0)!==v(n,!0)){n++;break}return q(n,0,f-1)}function z(n){return q(P()?n:s*n,0,c)}function D(n){return P()?Y(n,c):xn((c<=n?f-1:n)/s)}function M(n){n!==x&&(k=x,x=n)}function P(){return!en(e.focus)||e.isNavigation}function I(){return o.state.is([G,rn])&&!!e.waitForTransition}return{mount:function(){S(),t([K,J,"ei"],S),t(Nn,E)},go:function(n,t,i){var r;I()||-1<(r=A(n=function(n){var t=x;{var i,r;C(n)?(r=n.match(/([+\-<>])(\d+)?/)||[],i=r[1],r=r[2],"+"===i||"-"===i?t=O(x+ +(""+i+(+r||1)),x):">"===i?t=r?z(+r):b(!0):"<"===i&&(t=w(!0))):t=m?n:q(n,0,c)}return t}(n)))&&(t||r!==x)&&(M(r),l.move(n,r,k,i))},scroll:function(n,t,i,r){u.Scroll.scroll(n,t,i,function(){var n=A(l.toIndex(d()));M(g?Y(n,c):n),r&&r()})},getNext:b,getPrev:w,getAdjacent:L,getEnd:_,setIndex:M,getIndex:function(n){return n?k:x},toIndex:z,toPage:D,toDest:function(n){return n=l.toIndex(n),y?q(n,0,c):n},hasFocus:P,isBusy:I}},Arrows:function(o,n,t){var i,r,u=Q(o),e=u.on,c=u.bind,f=u.emit,a=t.classes,s=t.i18n,l=n.Elements,d=n.Controller,v=l.arrows,h=l.track,p=v,g=l.prev,m=l.next,y={};function b(){var n=t.arrows;!n||g&&m||(p=v||j("div",a.arrows),g=S(!0),m=S(!1),i=!0,L(p,[g,m]),v||O(p,h)),g&&m&&(an(y,{prev:g,next:m}),ln(p,n?"":"none"),M(p,r=dt+"--"+t.direction),n&&(e([B,Dn,J,V,"ei"],E),c(m,"click",R(k,">")),c(g,"click",R(k,"<")),E(),I([g,m],Kn,h.id),f("arrows:mounted",g,m))),e(K,w)}function w(){x(),b()}function x(){u.destroy(),X(p,r),i?(T(v?[g,m]:p),g=m=null):P([g,m],ut)}function k(n){d.go(n,!0)}function S(n){return hn('<button class="'+a.arrow+" "+(n?a.prev:a.next)+'" type="button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40" width="40" height="40" focusable="false"><path d="'+(t.arrowPath||"m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z")+'" />')}function E(){var n,t,i,r;g&&m&&(r=o.index,n=d.getPrev(),t=d.getNext(),i=-1<n&&r<n?s.last:s.prev,r=-1<t&&t<r?s.first:s.next,g.disabled=n<0,m.disabled=t<0,I(g,nn,i),I(m,nn,r),f("arrows:updated",g,m,n,t))}return{arrows:y,mount:b,destroy:x,update:E}},Autoplay:function(n,t,i){var r,o,u=Q(n),e=u.on,c=u.bind,f=u.emit,a=qn(i.interval,n.go.bind(n,">"),function(n){var t=l.bar;t&&_(t,"width",100*n+"%"),f("autoplay:playing",n)}),s=a.isPaused,l=t.Elements,d=(u=t.Elements).root,v=u.toggle,h=i.autoplay,p="pause"===h;function g(){s()&&t.Slides.isEnough()&&(a.start(!i.resetProgress),o=r=p=!1,b(),f(Fn))}function m(n){p=!!(n=void 0===n?!0:n),b(),s()||(a.pause(),f(Xn))}function y(){p||(r||o?m(!1):g())}function b(){v&&(A(v,tn,!p),I(v,nn,i.i18n[p?"play":"pause"]))}function w(n){n=t.Slides.getAt(n);a.set(n&&+z(n.slide,Ct)||i.interval)}return{mount:function(){h&&(i.pauseOnHover&&c(d,"mouseenter mouseleave",function(n){r="mouseenter"===n.type,y()}),i.pauseOnFocus&&c(d,"focusin focusout",function(n){o="focusin"===n.type,y()}),v&&c(v,"click",function(){p?g():m(!0)}),e([H,Tn,J],a.rewind),e(H,w),v&&I(v,Kn,l.track.id),p||g(),b())},destroy:a.cancel,play:g,pause:m,isPaused:s}},Cover:function(n,t,i){var r=Q(n).on;function o(i){t.Slides.forEach(function(n){var t=fn(n.container||n.slide,"img");t&&t.src&&u(i,t,n)})}function u(n,t,i){i.style("background",n?'center/cover no-repeat url("'+t.src+'")':"",!0),ln(t,n?"none":"")}return{mount:function(){i.cover&&(r(Wn,R(u,!0)),r([B,K,J],R(o,!0)))},destroy:R(o,!1)}},Scroll:function(n,c,u){var f,a,t=Q(n),i=t.on,s=t.emit,l=n.state.set,d=c.Move,v=d.getPosition,e=d.getLimit,h=d.exceededLimit,p=d.translate,g=n.is(Mt),m=1;function y(n,t,i,r,o){var u,e=v(),i=(x(),!i||g&&h()||(i=c.Layout.sliderSize(),u=Ln(n)*i*xn(U(n)/i)||0,n=d.toPosition(c.Controller.toDest(n%i))+u),Sn(e,n,1));m=1,t=i?0:t||wn(U(n-e)/1.5,800),a=r,f=qn(t,b,R(w,e,n,o),1),l(rn),s(Tn),f.start()}function b(){l(3),a&&a(),s(V)}function w(n,t,i,r){var o=v(),r=(n+(t-n)*(t=r,(n=u.easingFunc)?n(t):1-Math.pow(1-t,4))-o)*m;p(o+r),g&&!i&&h()&&(m*=.6,U(r)<10&&y(e(h(!0)),600,!1,a,!0))}function x(){f&&f.cancel()}function r(){f&&!f.isPaused()&&(x(),b())}return{mount:function(){i(H,x),i([K,J],r)},destroy:x,scroll:y,cancel:r}},Drag:function(e,o,c){var f,t,u,a,s,l,d,v,n=Q(e),i=n.on,h=n.emit,p=n.bind,g=n.unbind,m=e.state,y=o.Move,b=o.Scroll,w=o.Controller,x=o.Elements.track,k=o.Media.reduce,r=(n=o.Direction).resolve,S=n.orient,E=y.getPosition,L=y.exceededLimit,O=!1;function j(){var n=c.drag;C(!n),a="free"===n}function N(n){var t,i,r;l=!1,d||(t=R(n),i=n.target,r=c.noDrag,cn(i,"."+mt+", ."+vt)||r&&cn(i,r)||!t&&n.button||(w.isBusy()?F(n,!0):(v=t?x:window,s=m.is([G,rn]),u=null,p(v,zt,A,jt),p(v,Dt,_,jt),y.cancel(),b.cancel(),z(n))))}function A(n){var t,i,r,o,u;m.is(6)||(m.set(6),h("drag")),n.cancelable&&(s?(y.translate(f+D(n)/(O&&e.is(Mt)?5:1)),u=200<M(n),t=O!==(O=L()),(u||t)&&z(n),l=!0,h("dragging"),F(n)):U(D(u=n))>U(D(u,!0))&&(t=n,i=c.dragMinThreshold,r=un(i),o=r&&i.mouse||0,r=(r?i.touch:+i)||10,s=U(D(t))>(R(t)?r:o),F(n)))}function _(n){var t,i,r;m.is(6)&&(m.set(3),h("dragged")),s&&(i=function(n){return E()+Ln(n)*Y(U(n)*(c.flickPower||600),a?1/0:o.Layout.listSize()*(c.flickMaxPages||1))}(t=function(n){if(e.is(Pt)||!O){var t=M(n);if(t&&t<200)return D(n)/t}return 0}(t=n)),r=c.rewind&&c.rewindByDrag,k(!1),a?w.scroll(i,0,c.snap):e.is(It)?w.go(S(Ln(t))<0?r?"<":"-":r?">":"+"):e.is(Mt)&&O&&r?w.go(L(!0)?">":"<"):w.go(w.toDest(i),!0),k(!0),F(n)),g(v,zt,A),g(v,Dt,_),s=!1}function T(n){!d&&l&&F(n,!0)}function z(n){u=t,t=n,f=E()}function D(n,t){return I(n,t)-I(P(n),t)}function M(n){return mn(n)-mn(P(n))}function P(n){return t===n&&u||t}function I(n,t){return(R(n)?n.changedTouches[0]:n)["page"+r(t?"Y":"X")]}function R(n){return"undefined"!=typeof TouchEvent&&n instanceof TouchEvent}function C(n){d=n}return{mount:function(){p(x,zt,on,jt),p(x,Dt,on,jt),p(x,_t,N,jt),p(x,"click",T,{capture:!0}),p(x,"dragstart",F),i([B,K],j)},disable:C,isDragging:function(){return s}}},Keyboard:function(t,n,i){var r,o,u=Q(t),e=u.on,c=u.bind,f=u.unbind,a=t.root,s=n.Direction.resolve;function l(){var n=i.keyboard;n&&(r="global"===n?window:a,c(r,Gt,h))}function d(){f(r,Gt)}function v(){var n=o;o=!0,p(function(){o=n})}function h(n){o||((n=Tt(n))===s(Bn)?t.go("<"):n===s(Hn)&&t.go(">"))}return{mount:function(){l(),e(K,d),e(K,l),e(H,v)},destroy:d,disable:function(n){o=n}}},LazyLoad:function(i,n,o){var t=Q(i),r=t.on,u=t.off,e=t.bind,c=t.emit,f="sequential"===o.lazyLoad,a=[Dn,V],s=[];function l(){D(s),n.Slides.forEach(function(r){gn(r.slide,Wt).forEach(function(n){var t=z(n,Ft),i=z(n,Xt);t===n.src&&i===n.srcset||(t=o.classes.spinner,t=fn(i=n.parentElement,"."+t)||j("span",t,i),s.push([n,r,t]),n.src||ln(n,"none"))})}),(f?p:(u(a),r(a,d),d))()}function d(){(s=s.filter(function(n){var t=o.perPage*((o.preloadPages||1)+1)-1;return!n[1].isWithin(i.index,t)||v(n)})).length||u(a)}function v(n){var t=n[0];M(n[1].slide,Et),e(t,"load error",R(h,n)),I(t,"src",z(t,Ft)),I(t,"srcset",z(t,Xt)),P(t,Ft),P(t,Xt)}function h(n,t){var i=n[0],r=n[1];X(r.slide,Et),"error"!==t.type&&(T(n[2]),ln(i,""),c(Wn,i,r),c(jn)),f&&p()}function p(){s.length&&v(s.shift())}return{mount:function(){o.lazyLoad&&(l(),r(J,l))},destroy:R(D,s),check:d}},Pagination:function(l,n,d){var v,h,t=Q(l),p=t.on,g=t.emit,m=t.bind,y=n.Slides,b=n.Elements,w=n.Controller,x=w.hasFocus,r=w.getIndex,e=w.go,c=n.Direction.resolve,k=b.pagination,S=[];function E(){v&&(T(k?o(v.children):v),X(v,h),D(S),v=null),t.destroy()}function L(n){e(">"+n,!0)}function O(n,t){var i=S.length,r=Tt(t),o=A(),u=-1,o=(r===c(Hn,!1,o)?u=++n%i:r===c(Bn,!1,o)?u=(--n+i)%i:"Home"===r?u=0:"End"===r&&(u=i-1),S[u]);o&&(dn(o.button),e(">"+u),F(t,!0))}function A(){return d.paginationDirection||d.direction}function _(n){return S[w.toPage(n)]}function z(){var n,t=_(r(!0)),i=_(r());t&&(X(n=t.button,tn),P(n,Qn),I(n,$,-1)),i&&(M(n=i.button,tn),I(n,Qn,!0),I(n,$,"")),g("pagination:updated",{list:v,items:S},t,i)}return{items:S,mount:function n(){E(),p([K,J,"ei"],n);var t=d.pagination;if(k&&ln(k,t?"":"none"),t){p([H,Tn,V],z);var t=l.length,i=d.classes,r=d.i18n,o=d.perPage,u=x()?w.getEnd()+1:kn(t/o);M(v=k||j("ul",i.pagination,b.track.parentElement),h=gt+"--"+A()),I(v,Z,"tablist"),I(v,nn,r.select),I(v,nt,A()===Jn?"vertical":"");for(var e=0;e<u;e++){var c=j("li",null,v),f=j("button",{class:i.page,type:"button"},c),a=y.getIn(e).map(function(n){return n.slide.id}),s=!x()&&1<o?r.pageX:r.slideX;m(f,"click",R(L,e)),d.paginationKeyboard&&m(f,"keydown",R(O,e)),I(c,Z,"presentation"),I(f,Z,"tab"),I(f,Kn,a.join(" ")),I(f,nn,On(s,e+1)),I(f,$,-1),S.push({li:c,button:f,page:e})}z(),g("pagination:mounted",{list:v,items:S},_(l.index))}},destroy:E,getAt:_,update:z}},Sync:function(i,n,t){var r=t.isNavigation,o=t.slideFocus,u=[];function e(){var n,t;i.splides.forEach(function(n){n.isParent||(f(i,n.splide),f(n.splide,i))}),r&&(n=Q(i),(t=n.on)(Mn,s),t(Yn,l),t([B,K],a),u.push(n),n.emit(Gn,i.splides))}function c(){u.forEach(function(n){n.destroy()}),D(u)}function f(n,r){n=Q(n);n.on(H,function(n,t,i){r.go(r.is(Pt)?i:n)}),u.push(n)}function a(){I(n.Elements.list,nt,t.direction===Jn?"vertical":"")}function s(n){i.go(n.index)}function l(n,t){b(Yt,Tt(t))&&(s(n),F(t))}return{setup:R(n.Media.set,{slideFocus:en(o)?r:o},!0),mount:e,destroy:c,remount:function(){c(),e()}}},Wheel:function(e,c,f){var n=Q(e).bind,a=0;function t(n){var t,i,r,o,u;n.cancelable&&(t=(u=n.deltaY)<0,i=mn(n),r=f.wheelMinThreshold||0,o=f.wheelSleep||0,U(u)>r&&o<i-a&&(e.go(t?"<":">"),a=i),u=t,f.releaseWheel&&!e.state.is(G)&&-1===c.Controller.getAdjacent(u)||F(n))}return{mount:function(){f.wheel&&n(c.Elements.track,"wheel",t,jt)}}},Live:function(n,t,i){var r=Q(n).on,o=t.Elements.track,u=i.live&&!i.isNavigation,e=j("span",wt),c=qn(90,R(f,!1));function f(n){I(o,rt,n),n?(L(o,e),c.start()):(T(e),c.cancel())}function a(n){u&&I(o,it,n?"off":"polite")}return{mount:function(){u&&(a(!t.Autoplay.isPaused()),I(o,ot,!0),e.textContent="…",r(Fn,R(a,!0)),r(Xn,R(a,!1)),r([Dn,V],R(f,!0)))},disable:a,destroy:function(){P(o,[it,ot,rt]),T(e)}}}}),qt={type:"slide",role:"region",speed:400,perPage:1,cloneStatus:!0,arrows:!0,pagination:!0,paginationKeyboard:!0,interval:5e3,pauseOnHover:!0,pauseOnFocus:!0,resetProgress:!0,easing:"cubic-bezier(0.25, 1, 0.5, 1)",drag:!0,direction:"ltr",trimSpace:!0,focusableNodes:"a, button, textarea, input, select, iframe",live:!0,classes:{slide:at,clone:st,arrows:dt,arrow:vt,prev:ht,next:pt,pagination:gt,page:mt,spinner:i+"spinner"},i18n:{prev:"Previous slide",next:"Next slide",first:"Go to first slide",last:"Go to last slide",slideX:"Go to slide %s",pageX:"Go to page %s",play:"Start autoplay",pause:"Pause autoplay",carousel:"carousel",slide:"slide",select:"Select a slide to show",slideLabel:"%s of %s"},reducedMotion:{speed:0,rewindSpeed:0,autoplay:"pause"}};function Bt(n,t,i){var r=t.Slides;function o(){r.forEach(function(n){n.style("transform","translateX(-"+100*n.index+"%)")})}return{mount:function(){Q(n).on([B,J],o)},start:function(n,t){r.style("transition","opacity "+i.speed+"ms "+i.easing),p(t)},cancel:on}}function Ht(u,n,e){var c,f=n.Move,a=n.Controller,s=n.Scroll,t=n.Elements.list,l=R(_,t,"transition");function i(){l(""),s.cancel()}return{mount:function(){Q(u).bind(t,"transitionend",function(n){n.target===t&&c&&(i(),c())})},start:function(n,t){var i=f.toPosition(n,!0),r=f.getPosition(),o=function(n){var t=e.rewindSpeed;if(u.is(Mt)&&t){var i=a.getIndex(!0),r=a.getEnd();if(0===i&&r<=n||r<=i&&0===n)return t}return e.speed}(n);1<=U(i-r)&&1<=o?e.useScroll?s.scroll(i,o,!1,t):(l("transform "+o+"ms "+e.easing),f.translate(i,!0),c=t):(f.jump(n),t())},cancel:i}}t=function(){function i(n,t){this.event=Q(),this.Components={},this.state=s(1),this.splides=[],this.n={},this.t={};n=C(n)?pn(document,n):n;bn(n,n+" is invalid."),t=d({label:z(this.root=n,nn)||"",labelledby:z(n,Zn)||""},qt,i.defaults,t||{});try{d(t,JSON.parse(z(n,f)))}catch(n){bn(!1,"Invalid JSON")}this.n=Object.create(d({},t))}var n=i.prototype;return n.mount=function(n,t){var i=this,r=this.state,o=this.Components;return bn(r.is([1,7]),"Already mounted!"),r.set(1),this.i=o,this.r=t||this.r||(this.is(It)?Bt:Ht),this.t=n||this.t,w(an({},Ut,this.t,{Transition:this.r}),function(n,t){n=n(i,o,i.n);(o[t]=n).setup&&n.setup()}),w(o,function(n){n.mount&&n.mount()}),this.emit(B),M(this.root,"is-initialized"),r.set(3),this.emit("ready"),this},n.sync=function(n){return this.splides.push({splide:n}),n.splides.push({splide:this,isParent:!0}),this.state.is(3)&&(this.i.Sync.remount(),n.Components.Sync.remount()),this},n.go=function(n){return this.i.Controller.go(n),this},n.on=function(n,t){return this.event.on(n,t),this},n.off=function(n){return this.event.off(n),this},n.emit=function(n){var t;return(t=this.event).emit.apply(t,[n].concat(o(arguments,1))),this},n.add=function(n,t){return this.i.Slides.add(n,t),this},n.remove=function(n){return this.i.Slides.remove(n),this},n.is=function(n){return this.n.type===n},n.refresh=function(){return this.emit(J),this},n.destroy=function(t){void 0===t&&(t=!0);var n=this.event,i=this.state;return i.is(1)?Q(this).on("ready",this.destroy.bind(this,t)):(w(this.i,function(n){n.destroy&&n.destroy(t)},!0),n.emit(a),n.destroy(),t&&D(this.splides),i.set(7)),this},Jt(i,[{key:"options",get:function(){return this.n},set:function(n){this.i.Media.set(n,!0,!0)}},{key:"length",get:function(){return this.i.Slides.getLength(!0)}},{key:"index",get:function(){return this.i.Controller.getIndex()}}]),i}();return t.defaults={},t.STATES=r,t},"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(n="undefined"!=typeof globalThis?globalThis:n||self).Splide=t();

},{}],58:[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("@popperjs/core")):"function"==typeof define&&define.amd?define(["@popperjs/core"],e):(t=t||self).tippy=e(t.Popper)}(this,(function(t){"use strict";var e="undefined"!=typeof window&&"undefined"!=typeof document,n=!!e&&!!window.msCrypto,r={passive:!0,capture:!0},o=function(){return document.body};function i(t,e,n){if(Array.isArray(t)){var r=t[e];return null==r?Array.isArray(n)?n[e]:n:r}return t}function a(t,e){var n={}.toString.call(t);return 0===n.indexOf("[object")&&n.indexOf(e+"]")>-1}function s(t,e){return"function"==typeof t?t.apply(void 0,e):t}function u(t,e){return 0===e?t:function(r){clearTimeout(n),n=setTimeout((function(){t(r)}),e)};var n}function p(t,e){var n=Object.assign({},t);return e.forEach((function(t){delete n[t]})),n}function c(t){return[].concat(t)}function f(t,e){-1===t.indexOf(e)&&t.push(e)}function l(t){return t.split("-")[0]}function d(t){return[].slice.call(t)}function v(t){return Object.keys(t).reduce((function(e,n){return void 0!==t[n]&&(e[n]=t[n]),e}),{})}function m(){return document.createElement("div")}function g(t){return["Element","Fragment"].some((function(e){return a(t,e)}))}function h(t){return a(t,"MouseEvent")}function b(t){return!(!t||!t._tippy||t._tippy.reference!==t)}function y(t){return g(t)?[t]:function(t){return a(t,"NodeList")}(t)?d(t):Array.isArray(t)?t:d(document.querySelectorAll(t))}function w(t,e){t.forEach((function(t){t&&(t.style.transitionDuration=e+"ms")}))}function x(t,e){t.forEach((function(t){t&&t.setAttribute("data-state",e)}))}function E(t){var e,n=c(t)[0];return null!=n&&null!=(e=n.ownerDocument)&&e.body?n.ownerDocument:document}function O(t,e,n){var r=e+"EventListener";["transitionend","webkitTransitionEnd"].forEach((function(e){t[r](e,n)}))}function C(t,e){for(var n=e;n;){var r;if(t.contains(n))return!0;n=null==n.getRootNode||null==(r=n.getRootNode())?void 0:r.host}return!1}var T={isTouch:!1},A=0;function L(){T.isTouch||(T.isTouch=!0,window.performance&&document.addEventListener("mousemove",D))}function D(){var t=performance.now();t-A<20&&(T.isTouch=!1,document.removeEventListener("mousemove",D)),A=t}function k(){var t=document.activeElement;if(b(t)){var e=t._tippy;t.blur&&!e.state.isVisible&&t.blur()}}var R=Object.assign({appendTo:o,aria:{content:"auto",expanded:"auto"},delay:0,duration:[300,250],getReferenceClientRect:null,hideOnClick:!0,ignoreAttributes:!1,interactive:!1,interactiveBorder:2,interactiveDebounce:0,moveTransition:"",offset:[0,10],onAfterUpdate:function(){},onBeforeUpdate:function(){},onCreate:function(){},onDestroy:function(){},onHidden:function(){},onHide:function(){},onMount:function(){},onShow:function(){},onShown:function(){},onTrigger:function(){},onUntrigger:function(){},onClickOutside:function(){},placement:"top",plugins:[],popperOptions:{},render:null,showOnCreate:!1,touch:!0,trigger:"mouseenter focus",triggerTarget:null},{animateFill:!1,followCursor:!1,inlinePositioning:!1,sticky:!1},{allowHTML:!1,animation:"fade",arrow:!0,content:"",inertia:!1,maxWidth:350,role:"tooltip",theme:"",zIndex:9999}),P=Object.keys(R);function j(t){var e=(t.plugins||[]).reduce((function(e,n){var r,o=n.name,i=n.defaultValue;o&&(e[o]=void 0!==t[o]?t[o]:null!=(r=R[o])?r:i);return e}),{});return Object.assign({},t,e)}function M(t,e){var n=Object.assign({},e,{content:s(e.content,[t])},e.ignoreAttributes?{}:function(t,e){return(e?Object.keys(j(Object.assign({},R,{plugins:e}))):P).reduce((function(e,n){var r=(t.getAttribute("data-tippy-"+n)||"").trim();if(!r)return e;if("content"===n)e[n]=r;else try{e[n]=JSON.parse(r)}catch(t){e[n]=r}return e}),{})}(t,e.plugins));return n.aria=Object.assign({},R.aria,n.aria),n.aria={expanded:"auto"===n.aria.expanded?e.interactive:n.aria.expanded,content:"auto"===n.aria.content?e.interactive?null:"describedby":n.aria.content},n}function V(t,e){t.innerHTML=e}function I(t){var e=m();return!0===t?e.className="tippy-arrow":(e.className="tippy-svg-arrow",g(t)?e.appendChild(t):V(e,t)),e}function S(t,e){g(e.content)?(V(t,""),t.appendChild(e.content)):"function"!=typeof e.content&&(e.allowHTML?V(t,e.content):t.textContent=e.content)}function B(t){var e=t.firstElementChild,n=d(e.children);return{box:e,content:n.find((function(t){return t.classList.contains("tippy-content")})),arrow:n.find((function(t){return t.classList.contains("tippy-arrow")||t.classList.contains("tippy-svg-arrow")})),backdrop:n.find((function(t){return t.classList.contains("tippy-backdrop")}))}}function N(t){var e=m(),n=m();n.className="tippy-box",n.setAttribute("data-state","hidden"),n.setAttribute("tabindex","-1");var r=m();function o(n,r){var o=B(e),i=o.box,a=o.content,s=o.arrow;r.theme?i.setAttribute("data-theme",r.theme):i.removeAttribute("data-theme"),"string"==typeof r.animation?i.setAttribute("data-animation",r.animation):i.removeAttribute("data-animation"),r.inertia?i.setAttribute("data-inertia",""):i.removeAttribute("data-inertia"),i.style.maxWidth="number"==typeof r.maxWidth?r.maxWidth+"px":r.maxWidth,r.role?i.setAttribute("role",r.role):i.removeAttribute("role"),n.content===r.content&&n.allowHTML===r.allowHTML||S(a,t.props),r.arrow?s?n.arrow!==r.arrow&&(i.removeChild(s),i.appendChild(I(r.arrow))):i.appendChild(I(r.arrow)):s&&i.removeChild(s)}return r.className="tippy-content",r.setAttribute("data-state","hidden"),S(r,t.props),e.appendChild(n),n.appendChild(r),o(t.props,t.props),{popper:e,onUpdate:o}}N.$$tippy=!0;var H=1,U=[],_=[];function z(e,a){var p,g,b,y,A,L,D,k,P=M(e,Object.assign({},R,j(v(a)))),V=!1,I=!1,S=!1,N=!1,z=[],F=u(wt,P.interactiveDebounce),W=H++,X=(k=P.plugins).filter((function(t,e){return k.indexOf(t)===e})),Y={id:W,reference:e,popper:m(),popperInstance:null,props:P,state:{isEnabled:!0,isVisible:!1,isDestroyed:!1,isMounted:!1,isShown:!1},plugins:X,clearDelayTimeouts:function(){clearTimeout(p),clearTimeout(g),cancelAnimationFrame(b)},setProps:function(t){if(Y.state.isDestroyed)return;at("onBeforeUpdate",[Y,t]),bt();var n=Y.props,r=M(e,Object.assign({},n,v(t),{ignoreAttributes:!0}));Y.props=r,ht(),n.interactiveDebounce!==r.interactiveDebounce&&(pt(),F=u(wt,r.interactiveDebounce));n.triggerTarget&&!r.triggerTarget?c(n.triggerTarget).forEach((function(t){t.removeAttribute("aria-expanded")})):r.triggerTarget&&e.removeAttribute("aria-expanded");ut(),it(),J&&J(n,r);Y.popperInstance&&(Ct(),At().forEach((function(t){requestAnimationFrame(t._tippy.popperInstance.forceUpdate)})));at("onAfterUpdate",[Y,t])},setContent:function(t){Y.setProps({content:t})},show:function(){var t=Y.state.isVisible,e=Y.state.isDestroyed,n=!Y.state.isEnabled,r=T.isTouch&&!Y.props.touch,a=i(Y.props.duration,0,R.duration);if(t||e||n||r)return;if(et().hasAttribute("disabled"))return;if(at("onShow",[Y],!1),!1===Y.props.onShow(Y))return;Y.state.isVisible=!0,tt()&&($.style.visibility="visible");it(),dt(),Y.state.isMounted||($.style.transition="none");if(tt()){var u=rt(),p=u.box,c=u.content;w([p,c],0)}L=function(){var t;if(Y.state.isVisible&&!N){if(N=!0,$.offsetHeight,$.style.transition=Y.props.moveTransition,tt()&&Y.props.animation){var e=rt(),n=e.box,r=e.content;w([n,r],a),x([n,r],"visible")}st(),ut(),f(_,Y),null==(t=Y.popperInstance)||t.forceUpdate(),at("onMount",[Y]),Y.props.animation&&tt()&&function(t,e){mt(t,e)}(a,(function(){Y.state.isShown=!0,at("onShown",[Y])}))}},function(){var t,e=Y.props.appendTo,n=et();t=Y.props.interactive&&e===o||"parent"===e?n.parentNode:s(e,[n]);t.contains($)||t.appendChild($);Y.state.isMounted=!0,Ct()}()},hide:function(){var t=!Y.state.isVisible,e=Y.state.isDestroyed,n=!Y.state.isEnabled,r=i(Y.props.duration,1,R.duration);if(t||e||n)return;if(at("onHide",[Y],!1),!1===Y.props.onHide(Y))return;Y.state.isVisible=!1,Y.state.isShown=!1,N=!1,V=!1,tt()&&($.style.visibility="hidden");if(pt(),vt(),it(!0),tt()){var o=rt(),a=o.box,s=o.content;Y.props.animation&&(w([a,s],r),x([a,s],"hidden"))}st(),ut(),Y.props.animation?tt()&&function(t,e){mt(t,(function(){!Y.state.isVisible&&$.parentNode&&$.parentNode.contains($)&&e()}))}(r,Y.unmount):Y.unmount()},hideWithInteractivity:function(t){nt().addEventListener("mousemove",F),f(U,F),F(t)},enable:function(){Y.state.isEnabled=!0},disable:function(){Y.hide(),Y.state.isEnabled=!1},unmount:function(){Y.state.isVisible&&Y.hide();if(!Y.state.isMounted)return;Tt(),At().forEach((function(t){t._tippy.unmount()})),$.parentNode&&$.parentNode.removeChild($);_=_.filter((function(t){return t!==Y})),Y.state.isMounted=!1,at("onHidden",[Y])},destroy:function(){if(Y.state.isDestroyed)return;Y.clearDelayTimeouts(),Y.unmount(),bt(),delete e._tippy,Y.state.isDestroyed=!0,at("onDestroy",[Y])}};if(!P.render)return Y;var q=P.render(Y),$=q.popper,J=q.onUpdate;$.setAttribute("data-tippy-root",""),$.id="tippy-"+Y.id,Y.popper=$,e._tippy=Y,$._tippy=Y;var G=X.map((function(t){return t.fn(Y)})),K=e.hasAttribute("aria-expanded");return ht(),ut(),it(),at("onCreate",[Y]),P.showOnCreate&&Lt(),$.addEventListener("mouseenter",(function(){Y.props.interactive&&Y.state.isVisible&&Y.clearDelayTimeouts()})),$.addEventListener("mouseleave",(function(){Y.props.interactive&&Y.props.trigger.indexOf("mouseenter")>=0&&nt().addEventListener("mousemove",F)})),Y;function Q(){var t=Y.props.touch;return Array.isArray(t)?t:[t,0]}function Z(){return"hold"===Q()[0]}function tt(){var t;return!(null==(t=Y.props.render)||!t.$$tippy)}function et(){return D||e}function nt(){var t=et().parentNode;return t?E(t):document}function rt(){return B($)}function ot(t){return Y.state.isMounted&&!Y.state.isVisible||T.isTouch||y&&"focus"===y.type?0:i(Y.props.delay,t?0:1,R.delay)}function it(t){void 0===t&&(t=!1),$.style.pointerEvents=Y.props.interactive&&!t?"":"none",$.style.zIndex=""+Y.props.zIndex}function at(t,e,n){var r;(void 0===n&&(n=!0),G.forEach((function(n){n[t]&&n[t].apply(n,e)})),n)&&(r=Y.props)[t].apply(r,e)}function st(){var t=Y.props.aria;if(t.content){var n="aria-"+t.content,r=$.id;c(Y.props.triggerTarget||e).forEach((function(t){var e=t.getAttribute(n);if(Y.state.isVisible)t.setAttribute(n,e?e+" "+r:r);else{var o=e&&e.replace(r,"").trim();o?t.setAttribute(n,o):t.removeAttribute(n)}}))}}function ut(){!K&&Y.props.aria.expanded&&c(Y.props.triggerTarget||e).forEach((function(t){Y.props.interactive?t.setAttribute("aria-expanded",Y.state.isVisible&&t===et()?"true":"false"):t.removeAttribute("aria-expanded")}))}function pt(){nt().removeEventListener("mousemove",F),U=U.filter((function(t){return t!==F}))}function ct(t){if(!T.isTouch||!S&&"mousedown"!==t.type){var n=t.composedPath&&t.composedPath()[0]||t.target;if(!Y.props.interactive||!C($,n)){if(c(Y.props.triggerTarget||e).some((function(t){return C(t,n)}))){if(T.isTouch)return;if(Y.state.isVisible&&Y.props.trigger.indexOf("click")>=0)return}else at("onClickOutside",[Y,t]);!0===Y.props.hideOnClick&&(Y.clearDelayTimeouts(),Y.hide(),I=!0,setTimeout((function(){I=!1})),Y.state.isMounted||vt())}}}function ft(){S=!0}function lt(){S=!1}function dt(){var t=nt();t.addEventListener("mousedown",ct,!0),t.addEventListener("touchend",ct,r),t.addEventListener("touchstart",lt,r),t.addEventListener("touchmove",ft,r)}function vt(){var t=nt();t.removeEventListener("mousedown",ct,!0),t.removeEventListener("touchend",ct,r),t.removeEventListener("touchstart",lt,r),t.removeEventListener("touchmove",ft,r)}function mt(t,e){var n=rt().box;function r(t){t.target===n&&(O(n,"remove",r),e())}if(0===t)return e();O(n,"remove",A),O(n,"add",r),A=r}function gt(t,n,r){void 0===r&&(r=!1),c(Y.props.triggerTarget||e).forEach((function(e){e.addEventListener(t,n,r),z.push({node:e,eventType:t,handler:n,options:r})}))}function ht(){var t;Z()&&(gt("touchstart",yt,{passive:!0}),gt("touchend",xt,{passive:!0})),(t=Y.props.trigger,t.split(/\s+/).filter(Boolean)).forEach((function(t){if("manual"!==t)switch(gt(t,yt),t){case"mouseenter":gt("mouseleave",xt);break;case"focus":gt(n?"focusout":"blur",Et);break;case"focusin":gt("focusout",Et)}}))}function bt(){z.forEach((function(t){var e=t.node,n=t.eventType,r=t.handler,o=t.options;e.removeEventListener(n,r,o)})),z=[]}function yt(t){var e,n=!1;if(Y.state.isEnabled&&!Ot(t)&&!I){var r="focus"===(null==(e=y)?void 0:e.type);y=t,D=t.currentTarget,ut(),!Y.state.isVisible&&h(t)&&U.forEach((function(e){return e(t)})),"click"===t.type&&(Y.props.trigger.indexOf("mouseenter")<0||V)&&!1!==Y.props.hideOnClick&&Y.state.isVisible?n=!0:Lt(t),"click"===t.type&&(V=!n),n&&!r&&Dt(t)}}function wt(t){var e=t.target,n=et().contains(e)||$.contains(e);"mousemove"===t.type&&n||function(t,e){var n=e.clientX,r=e.clientY;return t.every((function(t){var e=t.popperRect,o=t.popperState,i=t.props.interactiveBorder,a=l(o.placement),s=o.modifiersData.offset;if(!s)return!0;var u="bottom"===a?s.top.y:0,p="top"===a?s.bottom.y:0,c="right"===a?s.left.x:0,f="left"===a?s.right.x:0,d=e.top-r+u>i,v=r-e.bottom-p>i,m=e.left-n+c>i,g=n-e.right-f>i;return d||v||m||g}))}(At().concat($).map((function(t){var e,n=null==(e=t._tippy.popperInstance)?void 0:e.state;return n?{popperRect:t.getBoundingClientRect(),popperState:n,props:P}:null})).filter(Boolean),t)&&(pt(),Dt(t))}function xt(t){Ot(t)||Y.props.trigger.indexOf("click")>=0&&V||(Y.props.interactive?Y.hideWithInteractivity(t):Dt(t))}function Et(t){Y.props.trigger.indexOf("focusin")<0&&t.target!==et()||Y.props.interactive&&t.relatedTarget&&$.contains(t.relatedTarget)||Dt(t)}function Ot(t){return!!T.isTouch&&Z()!==t.type.indexOf("touch")>=0}function Ct(){Tt();var n=Y.props,r=n.popperOptions,o=n.placement,i=n.offset,a=n.getReferenceClientRect,s=n.moveTransition,u=tt()?B($).arrow:null,p=a?{getBoundingClientRect:a,contextElement:a.contextElement||et()}:e,c=[{name:"offset",options:{offset:i}},{name:"preventOverflow",options:{padding:{top:2,bottom:2,left:5,right:5}}},{name:"flip",options:{padding:5}},{name:"computeStyles",options:{adaptive:!s}},{name:"$$tippy",enabled:!0,phase:"beforeWrite",requires:["computeStyles"],fn:function(t){var e=t.state;if(tt()){var n=rt().box;["placement","reference-hidden","escaped"].forEach((function(t){"placement"===t?n.setAttribute("data-placement",e.placement):e.attributes.popper["data-popper-"+t]?n.setAttribute("data-"+t,""):n.removeAttribute("data-"+t)})),e.attributes.popper={}}}}];tt()&&u&&c.push({name:"arrow",options:{element:u,padding:3}}),c.push.apply(c,(null==r?void 0:r.modifiers)||[]),Y.popperInstance=t.createPopper(p,$,Object.assign({},r,{placement:o,onFirstUpdate:L,modifiers:c}))}function Tt(){Y.popperInstance&&(Y.popperInstance.destroy(),Y.popperInstance=null)}function At(){return d($.querySelectorAll("[data-tippy-root]"))}function Lt(t){Y.clearDelayTimeouts(),t&&at("onTrigger",[Y,t]),dt();var e=ot(!0),n=Q(),r=n[0],o=n[1];T.isTouch&&"hold"===r&&o&&(e=o),e?p=setTimeout((function(){Y.show()}),e):Y.show()}function Dt(t){if(Y.clearDelayTimeouts(),at("onUntrigger",[Y,t]),Y.state.isVisible){if(!(Y.props.trigger.indexOf("mouseenter")>=0&&Y.props.trigger.indexOf("click")>=0&&["mouseleave","mousemove"].indexOf(t.type)>=0&&V)){var e=ot(!1);e?g=setTimeout((function(){Y.state.isVisible&&Y.hide()}),e):b=requestAnimationFrame((function(){Y.hide()}))}}else vt()}}function F(t,e){void 0===e&&(e={});var n=R.plugins.concat(e.plugins||[]);document.addEventListener("touchstart",L,r),window.addEventListener("blur",k);var o=Object.assign({},e,{plugins:n}),i=y(t).reduce((function(t,e){var n=e&&z(e,o);return n&&t.push(n),t}),[]);return g(t)?i[0]:i}F.defaultProps=R,F.setDefaultProps=function(t){Object.keys(t).forEach((function(e){R[e]=t[e]}))},F.currentInput=T;var W=Object.assign({},t.applyStyles,{effect:function(t){var e=t.state,n={popper:{position:e.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};Object.assign(e.elements.popper.style,n.popper),e.styles=n,e.elements.arrow&&Object.assign(e.elements.arrow.style,n.arrow)}}),X={mouseover:"mouseenter",focusin:"focus",click:"click"};var Y={name:"animateFill",defaultValue:!1,fn:function(t){var e;if(null==(e=t.props.render)||!e.$$tippy)return{};var n=B(t.popper),r=n.box,o=n.content,i=t.props.animateFill?function(){var t=m();return t.className="tippy-backdrop",x([t],"hidden"),t}():null;return{onCreate:function(){i&&(r.insertBefore(i,r.firstElementChild),r.setAttribute("data-animatefill",""),r.style.overflow="hidden",t.setProps({arrow:!1,animation:"shift-away"}))},onMount:function(){if(i){var t=r.style.transitionDuration,e=Number(t.replace("ms",""));o.style.transitionDelay=Math.round(e/10)+"ms",i.style.transitionDuration=t,x([i],"visible")}},onShow:function(){i&&(i.style.transitionDuration="0ms")},onHide:function(){i&&x([i],"hidden")}}}};var q={clientX:0,clientY:0},$=[];function J(t){var e=t.clientX,n=t.clientY;q={clientX:e,clientY:n}}var G={name:"followCursor",defaultValue:!1,fn:function(t){var e=t.reference,n=E(t.props.triggerTarget||e),r=!1,o=!1,i=!0,a=t.props;function s(){return"initial"===t.props.followCursor&&t.state.isVisible}function u(){n.addEventListener("mousemove",f)}function p(){n.removeEventListener("mousemove",f)}function c(){r=!0,t.setProps({getReferenceClientRect:null}),r=!1}function f(n){var r=!n.target||e.contains(n.target),o=t.props.followCursor,i=n.clientX,a=n.clientY,s=e.getBoundingClientRect(),u=i-s.left,p=a-s.top;!r&&t.props.interactive||t.setProps({getReferenceClientRect:function(){var t=e.getBoundingClientRect(),n=i,r=a;"initial"===o&&(n=t.left+u,r=t.top+p);var s="horizontal"===o?t.top:r,c="vertical"===o?t.right:n,f="horizontal"===o?t.bottom:r,l="vertical"===o?t.left:n;return{width:c-l,height:f-s,top:s,right:c,bottom:f,left:l}}})}function l(){t.props.followCursor&&($.push({instance:t,doc:n}),function(t){t.addEventListener("mousemove",J)}(n))}function d(){0===($=$.filter((function(e){return e.instance!==t}))).filter((function(t){return t.doc===n})).length&&function(t){t.removeEventListener("mousemove",J)}(n)}return{onCreate:l,onDestroy:d,onBeforeUpdate:function(){a=t.props},onAfterUpdate:function(e,n){var i=n.followCursor;r||void 0!==i&&a.followCursor!==i&&(d(),i?(l(),!t.state.isMounted||o||s()||u()):(p(),c()))},onMount:function(){t.props.followCursor&&!o&&(i&&(f(q),i=!1),s()||u())},onTrigger:function(t,e){h(e)&&(q={clientX:e.clientX,clientY:e.clientY}),o="focus"===e.type},onHidden:function(){t.props.followCursor&&(c(),p(),i=!0)}}}};var K={name:"inlinePositioning",defaultValue:!1,fn:function(t){var e,n=t.reference;var r=-1,o=!1,i=[],a={name:"tippyInlinePositioning",enabled:!0,phase:"afterWrite",fn:function(o){var a=o.state;t.props.inlinePositioning&&(-1!==i.indexOf(a.placement)&&(i=[]),e!==a.placement&&-1===i.indexOf(a.placement)&&(i.push(a.placement),t.setProps({getReferenceClientRect:function(){return function(t){return function(t,e,n,r){if(n.length<2||null===t)return e;if(2===n.length&&r>=0&&n[0].left>n[1].right)return n[r]||e;switch(t){case"top":case"bottom":var o=n[0],i=n[n.length-1],a="top"===t,s=o.top,u=i.bottom,p=a?o.left:i.left,c=a?o.right:i.right;return{top:s,bottom:u,left:p,right:c,width:c-p,height:u-s};case"left":case"right":var f=Math.min.apply(Math,n.map((function(t){return t.left}))),l=Math.max.apply(Math,n.map((function(t){return t.right}))),d=n.filter((function(e){return"left"===t?e.left===f:e.right===l})),v=d[0].top,m=d[d.length-1].bottom;return{top:v,bottom:m,left:f,right:l,width:l-f,height:m-v};default:return e}}(l(t),n.getBoundingClientRect(),d(n.getClientRects()),r)}(a.placement)}})),e=a.placement)}};function s(){var e;o||(e=function(t,e){var n;return{popperOptions:Object.assign({},t.popperOptions,{modifiers:[].concat(((null==(n=t.popperOptions)?void 0:n.modifiers)||[]).filter((function(t){return t.name!==e.name})),[e])})}}(t.props,a),o=!0,t.setProps(e),o=!1)}return{onCreate:s,onAfterUpdate:s,onTrigger:function(e,n){if(h(n)){var o=d(t.reference.getClientRects()),i=o.find((function(t){return t.left-2<=n.clientX&&t.right+2>=n.clientX&&t.top-2<=n.clientY&&t.bottom+2>=n.clientY})),a=o.indexOf(i);r=a>-1?a:r}},onHidden:function(){r=-1}}}};var Q={name:"sticky",defaultValue:!1,fn:function(t){var e=t.reference,n=t.popper;function r(e){return!0===t.props.sticky||t.props.sticky===e}var o=null,i=null;function a(){var s=r("reference")?(t.popperInstance?t.popperInstance.state.elements.reference:e).getBoundingClientRect():null,u=r("popper")?n.getBoundingClientRect():null;(s&&Z(o,s)||u&&Z(i,u))&&t.popperInstance&&t.popperInstance.update(),o=s,i=u,t.state.isMounted&&requestAnimationFrame(a)}return{onMount:function(){t.props.sticky&&a()}}}};function Z(t,e){return!t||!e||(t.top!==e.top||t.right!==e.right||t.bottom!==e.bottom||t.left!==e.left)}return e&&function(t){var e=document.createElement("style");e.textContent=t,e.setAttribute("data-tippy-stylesheet","");var n=document.head,r=document.querySelector("head>style,head>link");r?n.insertBefore(e,r):n.appendChild(e)}('.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:"";position:absolute;border-color:transparent;border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}'),F.setDefaultProps({plugins:[Y,G,K,Q],render:N}),F.createSingleton=function(t,e){var n;void 0===e&&(e={});var r,o=t,i=[],a=[],s=e.overrides,u=[],f=!1;function l(){a=o.map((function(t){return c(t.props.triggerTarget||t.reference)})).reduce((function(t,e){return t.concat(e)}),[])}function d(){i=o.map((function(t){return t.reference}))}function v(t){o.forEach((function(e){t?e.enable():e.disable()}))}function g(t){return o.map((function(e){var n=e.setProps;return e.setProps=function(o){n(o),e.reference===r&&t.setProps(o)},function(){e.setProps=n}}))}function h(t,e){var n=a.indexOf(e);if(e!==r){r=e;var u=(s||[]).concat("content").reduce((function(t,e){return t[e]=o[n].props[e],t}),{});t.setProps(Object.assign({},u,{getReferenceClientRect:"function"==typeof u.getReferenceClientRect?u.getReferenceClientRect:function(){var t;return null==(t=i[n])?void 0:t.getBoundingClientRect()}}))}}v(!1),d(),l();var b={fn:function(){return{onDestroy:function(){v(!0)},onHidden:function(){r=null},onClickOutside:function(t){t.props.showOnCreate&&!f&&(f=!0,r=null)},onShow:function(t){t.props.showOnCreate&&!f&&(f=!0,h(t,i[0]))},onTrigger:function(t,e){h(t,e.currentTarget)}}}},y=F(m(),Object.assign({},p(e,["overrides"]),{plugins:[b].concat(e.plugins||[]),triggerTarget:a,popperOptions:Object.assign({},e.popperOptions,{modifiers:[].concat((null==(n=e.popperOptions)?void 0:n.modifiers)||[],[W])})})),w=y.show;y.show=function(t){if(w(),!r&&null==t)return h(y,i[0]);if(!r||null!=t){if("number"==typeof t)return i[t]&&h(y,i[t]);if(o.indexOf(t)>=0){var e=t.reference;return h(y,e)}return i.indexOf(t)>=0?h(y,t):void 0}},y.showNext=function(){var t=i[0];if(!r)return y.show(0);var e=i.indexOf(r);y.show(i[e+1]||t)},y.showPrevious=function(){var t=i[i.length-1];if(!r)return y.show(t);var e=i.indexOf(r),n=i[e-1]||t;y.show(n)};var x=y.setProps;return y.setProps=function(t){s=t.overrides||s,x(t)},y.setInstances=function(t){v(!0),u.forEach((function(t){return t()})),o=t,v(!1),d(),l(),u=g(y),y.setProps({triggerTarget:a})},u=g(y),y},F.delegate=function(t,e){var n=[],o=[],i=!1,a=e.target,s=p(e,["target"]),u=Object.assign({},s,{trigger:"manual",touch:!1}),f=Object.assign({touch:R.touch},s,{showOnCreate:!0}),l=F(t,u);function d(t){if(t.target&&!i){var n=t.target.closest(a);if(n){var r=n.getAttribute("data-tippy-trigger")||e.trigger||R.trigger;if(!n._tippy&&!("touchstart"===t.type&&"boolean"==typeof f.touch||"touchstart"!==t.type&&r.indexOf(X[t.type])<0)){var s=F(n,f);s&&(o=o.concat(s))}}}}function v(t,e,r,o){void 0===o&&(o=!1),t.addEventListener(e,r,o),n.push({node:t,eventType:e,handler:r,options:o})}return c(l).forEach((function(t){var e=t.destroy,a=t.enable,s=t.disable;t.destroy=function(t){void 0===t&&(t=!0),t&&o.forEach((function(t){t.destroy()})),o=[],n.forEach((function(t){var e=t.node,n=t.eventType,r=t.handler,o=t.options;e.removeEventListener(n,r,o)})),n=[],e()},t.enable=function(){a(),o.forEach((function(t){return t.enable()})),i=!1},t.disable=function(){s(),o.forEach((function(t){return t.disable()})),i=!0},function(t){var e=t.reference;v(e,"touchstart",d,r),v(e,"mouseover",d),v(e,"focusin",d),v(e,"click",d)}(t)})),l},F.hideAll=function(t){var e=void 0===t?{}:t,n=e.exclude,r=e.duration;_.forEach((function(t){var e=!1;if(n&&(e=b(n)?t.reference===n:t.popper===n.popper),!e){var o=t.props.duration;t.setProps({duration:r}),t.hide(),t.state.isDestroyed||t.setProps({duration:o})}}))},F.roundArrow='<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>',F}));

},{"@popperjs/core":1}],59:[function(require,module,exports){
(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    define([], factory())
  } else if (typeof module === "object" && module.exports) {
    module.exports = factory()
  } else {
    (function install() {
      // To make sure Zenscroll can be referenced from the header, before `body` is available
      if (document && document.body) {
        root.zenscroll = factory()
      } else {
        // retry 9ms later
        setTimeout(install, 9)
      }
    })()
  }
}(this, function () {
  "use strict"


  // Detect if the browser already supports native smooth scrolling (e.g., Firefox 36+ and Chrome 49+) and it is enabled:
  var isNativeSmoothScrollEnabledOn = function (elem) {
    return elem && "getComputedStyle" in window &&
      window.getComputedStyle(elem)["scroll-behavior"] === "smooth"
  }


  // Exit if it’s not a browser environment:
  if (typeof window === "undefined" || !("document" in window)) {
    return {}
  }


  var makeScroller = function (container, defaultDuration, edgeOffset) {

    // Use defaults if not provided
    defaultDuration = defaultDuration || 999 //ms
    if (!edgeOffset && edgeOffset !== 0) {
      // When scrolling, this amount of distance is kept from the edges of the container:
      edgeOffset = 9 //px
    }

    // Handling the life-cycle of the scroller
    var scrollTimeoutId
    var setScrollTimeoutId = function (newValue) {
      scrollTimeoutId = newValue
    }

    /**
     * Stop the current smooth scroll operation immediately
     */
    var stopScroll = function () {
      clearTimeout(scrollTimeoutId)
      setScrollTimeoutId(0)
    }

    var getTopWithEdgeOffset = function (elem) {
      return Math.max(0, container.getTopOf(elem) - edgeOffset)
    }

    /**
     * Scrolls to a specific vertical position in the document.
     *
     * @param {targetY} The vertical position within the document.
     * @param {duration} Optionally the duration of the scroll operation.
     *        If not provided the default duration is used.
     * @param {onDone} An optional callback function to be invoked once the scroll finished.
     */
    var scrollToY = function (targetY, duration, onDone) {
      stopScroll()
      if (duration === 0 || (duration && duration < 0) || isNativeSmoothScrollEnabledOn(container.body)) {
        container.toY(targetY)
        if (onDone) {
          onDone()
        }
      } else {
        var startY = container.getY()
        var distance = Math.max(0, targetY) - startY
        var startTime = new Date().getTime()
        duration = duration || Math.min(Math.abs(distance), defaultDuration);
        (function loopScroll() {
          setScrollTimeoutId(setTimeout(function () {
            // Calculate percentage:
            var p = Math.min(1, (new Date().getTime() - startTime) / duration)
            // Calculate the absolute vertical position:
            var y = Math.max(0, Math.floor(startY + distance * (p < 0.5 ? 2 * p * p : p * (4 - p * 2) - 1)))
            container.toY(y)
            if (p < 1 && (container.getHeight() + y) < container.body.scrollHeight) {
              loopScroll()
            } else {
              setTimeout(stopScroll, 99) // with cooldown time
              if (onDone) {
                onDone()
              }
            }
          }, 9))
        })()
      }
    }

    /**
     * Scrolls to the top of a specific element.
     *
     * @param {elem} The element to scroll to.
     * @param {duration} Optionally the duration of the scroll operation.
     * @param {onDone} An optional callback function to be invoked once the scroll finished.
     */
    var scrollToElem = function (elem, duration, onDone) {
      scrollToY(getTopWithEdgeOffset(elem), duration, onDone)
    }

    /**
     * Scrolls an element into view if necessary.
     *
     * @param {elem} The element.
     * @param {duration} Optionally the duration of the scroll operation.
     * @param {onDone} An optional callback function to be invoked once the scroll finished.
     */
    var scrollIntoView = function (elem, duration, onDone) {
      var elemHeight = elem.getBoundingClientRect().height
      var elemBottom = container.getTopOf(elem) + elemHeight
      var containerHeight = container.getHeight()
      var y = container.getY()
      var containerBottom = y + containerHeight
      if (getTopWithEdgeOffset(elem) < y || (elemHeight + edgeOffset) > containerHeight) {
        // Element is clipped at top or is higher than screen.
        scrollToElem(elem, duration, onDone)
      } else if ((elemBottom + edgeOffset) > containerBottom) {
        // Element is clipped at the bottom.
        scrollToY(elemBottom - containerHeight + edgeOffset, duration, onDone)
      } else if (onDone) {
        onDone()
      }
    }

    /**
     * Scrolls to the center of an element.
     *
     * @param {elem} The element.
     * @param {duration} Optionally the duration of the scroll operation.
     * @param {offset} Optionally the offset of the top of the element from the center of the screen.
     *        A value of 0 is ignored.
     * @param {onDone} An optional callback function to be invoked once the scroll finished.
     */
    var scrollToCenterOf = function (elem, duration, offset, onDone) {
      scrollToY(Math.max(0, container.getTopOf(elem) - container.getHeight() / 2 + (offset || elem.getBoundingClientRect().height / 2)), duration, onDone)
    }

    /**
     * Changes default settings for this scroller.
     *
     * @param {newDefaultDuration} Optionally a new value for default duration, used for each scroll method by default.
     *        Ignored if null or undefined.
     * @param {newEdgeOffset} Optionally a new value for the edge offset, used by each scroll method by default. Ignored if null or undefined.
     * @returns An object with the current values.
     */
    var setup = function (newDefaultDuration, newEdgeOffset) {
      if (newDefaultDuration === 0 || newDefaultDuration) {
        defaultDuration = newDefaultDuration
      }
      if (newEdgeOffset === 0 || newEdgeOffset) {
        edgeOffset = newEdgeOffset
      }
      return {
        defaultDuration: defaultDuration,
        edgeOffset: edgeOffset
      }
    }

    return {
      setup: setup,
      to: scrollToElem,
      toY: scrollToY,
      intoView: scrollIntoView,
      center: scrollToCenterOf,
      stop: stopScroll,
      moving: function () { return !!scrollTimeoutId },
      getY: container.getY,
      getTopOf: container.getTopOf
    }

  }


  var docElem = document.documentElement
  var getDocY = function () { return window.scrollY || docElem.scrollTop }

  // Create a scroller for the document:
  var zenscroll = makeScroller({
    body: document.scrollingElement || document.body,
    toY: function (y) { window.scrollTo(0, y) },
    getY: getDocY,
    getHeight: function () { return window.innerHeight || docElem.clientHeight },
    getTopOf: function (elem) { return elem.getBoundingClientRect().top + getDocY() - docElem.offsetTop }
  })


  /**
   * Creates a scroller from the provided container element (e.g., a DIV)
   *
   * @param {scrollContainer} The vertical position within the document.
   * @param {defaultDuration} Optionally a value for default duration, used for each scroll method by default.
   *        Ignored if 0 or null or undefined.
   * @param {edgeOffset} Optionally a value for the edge offset, used by each scroll method by default. 
   *        Ignored if null or undefined.
   * @returns A scroller object, similar to `zenscroll` but controlling the provided element.
   */
  zenscroll.createScroller = function (scrollContainer, defaultDuration, edgeOffset) {
    return makeScroller({
      body: scrollContainer,
      toY: function (y) { scrollContainer.scrollTop = y },
      getY: function () { return scrollContainer.scrollTop },
      getHeight: function () { return Math.min(scrollContainer.clientHeight, window.innerHeight || docElem.clientHeight) },
      getTopOf: function (elem) { return elem.offsetTop }
    }, defaultDuration, edgeOffset)
  }


  // Automatic link-smoothing on achors
  // Exclude IE8- or when native is enabled or Zenscroll auto- is disabled
  if ("addEventListener" in window && !window.noZensmooth && !isNativeSmoothScrollEnabledOn(document.body)) {

    var isHistorySupported = "history" in window && "pushState" in history
    var isScrollRestorationSupported = isHistorySupported && "scrollRestoration" in history

    // On first load & refresh make sure the browser restores the position first
    if (isScrollRestorationSupported) {
      history.scrollRestoration = "auto"
    }

    window.addEventListener("load", function () {

      if (isScrollRestorationSupported) {
        // Set it to manual
        setTimeout(function () { history.scrollRestoration = "manual" }, 9)
        window.addEventListener("popstate", function (event) {
          if (event.state && "zenscrollY" in event.state) {
            zenscroll.toY(event.state.zenscrollY)
          }
        }, false)
      }

      // Add edge offset on first load if necessary
      // This may not work on IE (or older computer?) as it requires more timeout, around 100 ms
      if (window.location.hash) {
        setTimeout(function () {
          // Adjustment is only needed if there is an edge offset:
          var edgeOffset = zenscroll.setup().edgeOffset
          if (edgeOffset) {
            var targetElem = document.getElementById(window.location.href.split("#")[1])
            if (targetElem) {
              var targetY = Math.max(0, zenscroll.getTopOf(targetElem) - edgeOffset)
              var diff = zenscroll.getY() - targetY
              // Only do the adjustment if the browser is very close to the element:
              if (0 <= diff && diff < 9) {
                window.scrollTo(0, targetY)
              }
            }
          }
        }, 9)
      }

    }, false)

    // Handling clicks on anchors
    var RE_noZensmooth = new RegExp("(^|\\s)noZensmooth(\\s|$)")
    window.addEventListener("click", function (event) {
      var anchor = event.target
      while (anchor && anchor.tagName !== "A") {
        anchor = anchor.parentNode
      }
      // Let the browser handle the click if it wasn't with the primary button, or with some modifier keys:
      if (!anchor || event.which !== 1 || event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {
        return
      }
      // Save the current scrolling position so it can be used for scroll restoration:
      if (isScrollRestorationSupported) {
        var historyState = history.state && typeof history.state === "object" ? history.state : {}
        historyState.zenscrollY = zenscroll.getY()
        try {
          history.replaceState(historyState, "")
        } catch (e) {
          // Avoid the Chrome Security exception on file protocol, e.g., file://index.html
        }
      }
      // Find the referenced ID:
      var href = anchor.getAttribute("href") || ""
      if (href.indexOf("#") === 0 && !RE_noZensmooth.test(anchor.className)) {
        var targetY = 0
        var targetElem = document.getElementById(href.substring(1))
        if (href !== "#") {
          if (!targetElem) {
            // Let the browser handle the click if the target ID is not found.
            return
          }
          targetY = zenscroll.getTopOf(targetElem)
        }
        event.preventDefault()
        // By default trigger the browser's `hashchange` event...
        var onDone = function () { window.location = href }
        // ...unless there is an edge offset specified
        var edgeOffset = zenscroll.setup().edgeOffset
        if (edgeOffset) {
          targetY = Math.max(0, targetY - edgeOffset)
          if (isHistorySupported) {
            onDone = function () { history.pushState({}, "", href) }
          }
        }
        zenscroll.toY(targetY, null, onDone)
      }
    }, false)

  }


  return zenscroll
}));
},{}]},{},[7])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvZGlzdC9janMvcG9wcGVyLmpzIiwibm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsInNyYy9qcy9mYW5jeWJveC5taW4uanMiLCJzcmMvanMvaW50bFRlbElucHV0LmpzIiwic3JjL2pzL2pRdWVyeS16b29tLmpzIiwic3JjL2pzL2pxdWVyeS5jcnMubWluLmpzIiwic3JjL2pzL21haW4uanMiLCJzcmMvanMvbW9kdWxlcy9hamF4LmpzIiwic3JjL2pzL21vZHVsZXMvY29uc3RhbnRzLmpzIiwic3JjL2pzL21vZHVsZXMvZHluYW1pYy9hZGQtY2FydC1tb2RhbC5qcyIsInNyYy9qcy9tb2R1bGVzL2R5bmFtaWMvYXNrLW1vZGFsLmpzIiwic3JjL2pzL21vZHVsZXMvZHluYW1pYy9iYWNrZHJvcC5qcyIsInNyYy9qcy9tb2R1bGVzL2R5bmFtaWMvcGFnZS1jb25mZXR0aS5qcyIsInNyYy9qcy9tb2R1bGVzL2R5bmFtaWMvcGFnZVRpcC5qcyIsInNyYy9qcy9tb2R1bGVzL2R5bmFtaWMvcHJpY2UtbW9kYWwuanMiLCJzcmMvanMvbW9kdWxlcy9keW5hbWljL3Jvb3QtbG9hZGVyLmpzIiwic3JjL2pzL21vZHVsZXMvZHluYW1pYy96b29tLWdhbGxlcnkuanMiLCJzcmMvanMvbW9kdWxlcy9lbGVtZW50cy9mb290ZXIuanMiLCJzcmMvanMvbW9kdWxlcy9lbGVtZW50cy9oZWFkZXIuanMiLCJzcmMvanMvbW9kdWxlcy9lbGVtZW50cy9oZXJvLXNwbGlkZS5qcyIsInNyYy9qcy9tb2R1bGVzL2VsZW1lbnRzL3BhZ2UtYWxlcnRzLmpzIiwic3JjL2pzL21vZHVsZXMvZWxlbWVudHMvcGFnZS1lbGVtZW50cy5qcyIsInNyYy9qcy9tb2R1bGVzL2VsZW1lbnRzL3BhZ2UtcmV2aWV3cy5qcyIsInNyYy9qcy9tb2R1bGVzL2VsZW1lbnRzL3BnLW1vZGFsLmpzIiwic3JjL2pzL21vZHVsZXMvZWxlbWVudHMvcGctc2VsZWN0LmpzIiwic3JjL2pzL21vZHVsZXMvZWxlbWVudHMvc2lydi5qcyIsInNyYy9qcy9tb2R1bGVzL2xvZ2luLmpzIiwic3JjL2pzL21vZHVsZXMvbW9kYWxzL2Jvb2stbW9kYWwuanMiLCJzcmMvanMvbW9kdWxlcy9tb2RhbHMvY2FyZS1tb2RhbC5qcyIsInNyYy9qcy9tb2R1bGVzL21vZGFscy9jYXJ0LW1vZGFsLmpzIiwic3JjL2pzL21vZHVsZXMvbW9kYWxzL2N1cnJlbmN5LW1vZGFsLmpzIiwic3JjL2pzL21vZHVsZXMvbW9kYWxzL21haWwtbW9kYWwuanMiLCJzcmMvanMvbW9kdWxlcy9tb2RhbHMvbWVudS5qcyIsInNyYy9qcy9tb2R1bGVzL21vZGFscy9ub3RpY2UtbW9kYWwuanMiLCJzcmMvanMvbW9kdWxlcy9tb2RhbHMvcXVpei1tb2RhbC5qcyIsInNyYy9qcy9tb2R1bGVzL21vZGFscy9zYWxlcy1tb2RhbC5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2FjY291bnQtcGFnZS5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2Jsb2ctcGFnZS5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2Zvcm0tcGFnZS5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2hvbWVwYWdlLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvam9iLWFwcC5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2xvYW4tYXBwLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvbG9jYXRpb24tcGFnZS5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL2xvb3NlLWRpYW1vbmRzLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvbXktYmFnLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvcGFzcy1yZXNldC5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL3Byb2R1Y3QuanMiLCJzcmMvanMvbW9kdWxlcy9wYWdlcy9yZXN1bHRzLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvc2VsbC1wYWdlLmpzIiwic3JjL2pzL21vZHVsZXMvcGFnZXMvc2VsbC13YXRjaC5qcyIsInNyYy9qcy9tb2R1bGVzL3BhZ2VzL3RhZy1wcmV2aWV3LmpzIiwic3JjL2pzL21vZHVsZXMvdXRpbHMuanMiLCJzcmMvanMvbW9kdWxlcy92YXJpYWJsZXMuanMiLCJzcmMvanMvcGFyc2xleS5taW4uanMiLCJzcmMvanMvcG9wcGVyLmpzIiwic3JjL2pzL3NwbGlkZS1ncmlkLmpzIiwic3JjL2pzL3NwbGlkZS5qcyIsInNyYy9qcy90aXBweS5qcyIsInNyYy9qcy96ZW5zY3JvbGwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNTlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25yQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBOzs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKipcbiAqIEBwb3BwZXJqcy9jb3JlIHYyLjExLjggLSBNSVQgTGljZW5zZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIElFIDExIGhhcyBubyBTaGFkb3dSb290XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5cbmZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICB2YXIgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG5cbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cblxuZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59XG5cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cblxuZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHZhciBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXG5cbiAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgLSBoZWlnaHQpIDw9IDEpIHtcbiAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59XG5cbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5mdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufVxuXG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn1cblxudmFyIHRvcCA9ICd0b3AnO1xudmFyIGJvdHRvbSA9ICdib3R0b20nO1xudmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbnZhciBsZWZ0ID0gJ2xlZnQnO1xudmFyIGF1dG8gPSAnYXV0byc7XG52YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbnZhciBzdGFydCA9ICdzdGFydCc7XG52YXIgZW5kID0gJ2VuZCc7XG52YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG52YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xudmFyIHBvcHBlciA9ICdwb3BwZXInO1xudmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xudmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbnZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbnZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xudmFyIHJlYWQgPSAncmVhZCc7XG52YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbnZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xudmFyIG1haW4gPSAnbWFpbic7XG52YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxudmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbnZhciB3cml0ZSA9ICd3cml0ZSc7XG52YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbnZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTtcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn1cblxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBmYWxzZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5cbmZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRzdHJhdGVneSA9IF9vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgc3RyYXRlZ3kgPSBfb3B0aW9ucyRzdHJhdGVneSA9PT0gdm9pZCAwID8gc3RhdGUuc3RyYXRlZ3kgOiBfb3B0aW9ucyRzdHJhdGVneSxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgICAgIF9yZWYkb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZi5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0JDIoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBldmVudExpc3RlbmVycyA9IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCQyLFxuICBkYXRhOiB7fVxufTtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgcG9wcGVyT2Zmc2V0cyQxID0ge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTtcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmLCB3aW4pIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuICB2YXIgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgIHk6IHJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9LCBnZXRXaW5kb3cocG9wcGVyKSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgY29tcHV0ZVN0eWxlcyQxID0ge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07XG5cbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdCQxKF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgYXBwbHlTdHlsZXMkMSA9IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QkMSxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59O1xuXG5mdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIG9mZnNldCQxID0ge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59O1xuXG52YXIgaGFzaCQxID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2gkMVttYXRjaGVkXTtcbiAgfSk7XG59XG5cbnZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBwbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzJDEgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XG4gIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMkMS5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMkMTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBmbGlwJDEgPSB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5cbmZ1bmN0aW9uIHdpdGhpbihtaW4kMSwgdmFsdWUsIG1heCQxKSB7XG4gIHJldHVybiBtYXgobWluJDEsIG1pbih2YWx1ZSwgbWF4JDEpKTtcbn1cbmZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluJDEgPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCQxID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1pbihtaW4kMSwgdGV0aGVyTWluKSA6IG1pbiQxLCBvZmZzZXQsIHRldGhlciA/IG1heChtYXgkMSwgdGV0aGVyTWF4KSA6IG1heCQxKTtcbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkMjtcblxuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xuXG4gICAgdmFyIF90ZXRoZXJNaW4gPSBpc09yaWdpblNpZGUgPyBfbWluIDogX29mZnNldCAtIHJlZmVyZW5jZVJlY3RbX2xlbl0gLSBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcblxuICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgcHJldmVudE92ZXJmbG93JDEgPSB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59O1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgYXJyb3ckMSA9IHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGFycm93LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgaGlkZSQxID0ge1xuICBuYW1lOiAnaGlkZScsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG4gIGZuOiBoaWRlXG59O1xuXG52YXIgZGVmYXVsdE1vZGlmaWVycyQxID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzJDEsIGNvbXB1dGVTdHlsZXMkMSwgYXBwbHlTdHlsZXMkMV07XG52YXIgY3JlYXRlUG9wcGVyJDEgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVycyQxXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cyQxLCBjb21wdXRlU3R5bGVzJDEsIGFwcGx5U3R5bGVzJDEsIG9mZnNldCQxLCBmbGlwJDEsIHByZXZlbnRPdmVyZmxvdyQxLCBhcnJvdyQxLCBoaWRlJDFdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnRzLmFwcGx5U3R5bGVzID0gYXBwbHlTdHlsZXMkMTtcbmV4cG9ydHMuYXJyb3cgPSBhcnJvdyQxO1xuZXhwb3J0cy5jb21wdXRlU3R5bGVzID0gY29tcHV0ZVN0eWxlcyQxO1xuZXhwb3J0cy5jcmVhdGVQb3BwZXIgPSBjcmVhdGVQb3BwZXI7XG5leHBvcnRzLmNyZWF0ZVBvcHBlckxpdGUgPSBjcmVhdGVQb3BwZXIkMTtcbmV4cG9ydHMuZGVmYXVsdE1vZGlmaWVycyA9IGRlZmF1bHRNb2RpZmllcnM7XG5leHBvcnRzLmRldGVjdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3c7XG5leHBvcnRzLmV2ZW50TGlzdGVuZXJzID0gZXZlbnRMaXN0ZW5lcnM7XG5leHBvcnRzLmZsaXAgPSBmbGlwJDE7XG5leHBvcnRzLmhpZGUgPSBoaWRlJDE7XG5leHBvcnRzLm9mZnNldCA9IG9mZnNldCQxO1xuZXhwb3J0cy5wb3BwZXJHZW5lcmF0b3IgPSBwb3BwZXJHZW5lcmF0b3I7XG5leHBvcnRzLnBvcHBlck9mZnNldHMgPSBwb3BwZXJPZmZzZXRzJDE7XG5leHBvcnRzLnByZXZlbnRPdmVyZmxvdyA9IHByZXZlbnRPdmVyZmxvdyQxO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLmpzLm1hcFxuIiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjcuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMy0wOC0yOFQxMzozN1pcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgdHJhYy0xNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGZsYXQgPSBhcnIuZmxhdCA/IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5mbGF0LmNhbGwoIGFycmF5ICk7XG59IDogZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmNvbmNhdC5hcHBseSggW10sIGFycmF5ICk7XG59O1xuXG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG5cdFx0Ly8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG5cdFx0Ly8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cblx0XHQvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG5cdFx0Ly8gU3VwcG9ydDogUXRXZWIgPD0zLjguNSwgV2ViS2l0IDw9NTM0LjM0LCB3a2h0bWx0b3BkZiB0b29sIDw9MC4xMi41XG5cdFx0Ly8gUGx1cyBmb3Igb2xkIFdlYktpdCwgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIGNvbGxlY3Rpb25zXG5cdFx0Ly8gKGUuZy4sIGB0eXBlb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIikgPT09IFwiZnVuY3Rpb25cImApLiAoZ2gtNDc1Nilcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCIgJiZcblx0XHRcdHR5cGVvZiBvYmouaXRlbSAhPT0gXCJmdW5jdGlvblwiO1xuXHR9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXIgdmVyc2lvbiA9IFwiMy43LjFcIixcblxuXHRyaHRtbFN1ZmZpeCA9IC9IVE1MJC9pLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXZlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICggaSArIDEgKSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0b2RkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIHByb3ZpZGVkIGNvbnRleHQ7IGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBvbmVcblx0Ly8gaWYgbm90IHNwZWNpZmllZC5cblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMsIGRvYyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXG5cdC8vIFJldHJpZXZlIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuXHR0ZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbm9kZSxcblx0XHRcdHJldCA9IFwiXCIsXG5cdFx0XHRpID0gMCxcblx0XHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdGlmICggIW5vZGVUeXBlICkge1xuXG5cdFx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBlbGVtWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRcdHJldCArPSBqUXVlcnkudGV4dCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH1cblx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnRFbGVtZW50LnRleHRDb250ZW50O1xuXHRcdH1cblx0XHRpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0aXNYTUxEb2M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lc3BhY2UgPSBlbGVtICYmIGVsZW0ubmFtZXNwYWNlVVJJLFxuXHRcdFx0ZG9jRWxlbSA9IGVsZW0gJiYgKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIEFzc3VtZSBIVE1MIHdoZW4gZG9jdW1lbnRFbGVtZW50IGRvZXNuJ3QgeWV0IGV4aXN0LCBzdWNoIGFzIGluc2lkZVxuXHRcdC8vIGRvY3VtZW50IGZyYWdtZW50cy5cblx0XHRyZXR1cm4gIXJodG1sU3VmZml4LnRlc3QoIG5hbWVzcGFjZSB8fCBkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUgfHwgXCJIVE1MXCIgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBmbGF0KCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHRcdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuXHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufVxudmFyIHBvcCA9IGFyci5wb3A7XG5cblxudmFyIHNvcnQgPSBhcnIuc29ydDtcblxuXG52YXIgc3BsaWNlID0gYXJyLnNwbGljZTtcblxuXG52YXIgd2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIjtcblxuXG52YXIgcnRyaW1DU1MgPSBuZXcgUmVnRXhwKFxuXHRcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLFxuXHRcImdcIlxuKTtcblxuXG5cblxuLy8gTm90ZTogYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxualF1ZXJ5LmNvbnRhaW5zID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdHZhciBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblxuXHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0XHQvLyBJRSBkb2Vzbid0IGhhdmUgYGNvbnRhaW5zYCBvbiBTVkcuXG5cdFx0YS5jb250YWlucyA/XG5cdFx0XHRhLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0KSApO1xufTtcblxuXG5cblxuLy8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cbi8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xudmFyIHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXHg4MC1cXHVGRkZGXFx3LV0vZztcblxuZnVuY3Rpb24gZmNzc2VzY2FwZSggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHR9XG5cblx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdH1cblxuXHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdHJldHVybiBcIlxcXFxcIiArIGNoO1xufVxuXG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKCBzZWwgKyBcIlwiICkucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuXG5cblxudmFyIHByZWZlcnJlZERvYyA9IGRvY3VtZW50LFxuXHRwdXNoTmF0aXZlID0gcHVzaDtcblxuKCBmdW5jdGlvbigpIHtcblxudmFyIGksXG5cdEV4cHIsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXHRwdXNoID0gcHVzaE5hdGl2ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdGRvY3VtZW50LFxuXHRkb2N1bWVudEVsZW1lbnQsXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdG1hdGNoZXMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0galF1ZXJ5LmV4cGFuZG8sXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8XCIgK1xuXHRcdFwibG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpZGVudC10b2tlbi1kaWFncmFtXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJsZWFkaW5nQ29tYmluYXRvciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0SUQ6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRDTEFTUzogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRUQUc6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRBVFRSOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRQU0VVRE86IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdENISUxEOiBuZXcgUmVnRXhwKFxuXHRcdFx0XCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICtcblx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICtcblx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdGJvb2w6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0bmVlZHNDb250ZXh0OiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCI/fFxcXFxcXFxcKFteXFxcXHJcXFxcblxcXFxmXSlcIiwgXCJnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIGVzY2FwZSwgbm9uSGV4ICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlLnNsaWNlKCAxICkgLSAweDEwMDAwO1xuXG5cdFx0aWYgKCBub25IZXggKSB7XG5cblx0XHRcdC8vIFN0cmlwIHRoZSBiYWNrc2xhc2ggcHJlZml4IGZyb20gYSBub24taGV4IGVzY2FwZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIG5vbkhleDtcblx0XHR9XG5cblx0XHQvLyBSZXBsYWNlIGEgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlIHdpdGggdGhlIGVuY29kZWQgVW5pY29kZSBjb2RlIHBvaW50XG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMStcblx0XHQvLyBGb3IgdmFsdWVzIG91dHNpZGUgdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoQk1QKSwgbWFudWFsbHkgY29uc3RydWN0IGFcblx0XHQvLyBzdXJyb2dhdGUgcGFpclxuXHRcdHJldHVybiBoaWdoIDwgMCA/XG5cdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXM7IHNlZSBgc2V0RG9jdW1lbnRgLlxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRS9FZGdlLlxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgbm9kZU5hbWUoIGVsZW0sIFwiZmllbGRzZXRcIiApO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcbi8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM5M1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KCBhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApICksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7XG5cdFx0YXBwbHk6IGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hOYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbCggZWxzICkgKTtcblx0XHR9LFxuXHRcdGNhbGw6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0XHRwdXNoTmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApICk7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBmaW5kKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKCBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKCBtID0gbWF0Y2hbIDEgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRwdXNoLmNhbGwoIHJlc3VsdHMsIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoIGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSAmJlxuXHRcdFx0XHRcdFx0XHRmaW5kLmNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRwdXNoLmNhbGwoIHJlc3VsdHMsIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDIgXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKCBtID0gbWF0Y2hbIDMgXSApICYmIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggIW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoICFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cblx0XHRcdFx0Ly8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuXHRcdFx0XHQvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxuXHRcdFx0XHQvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXG5cdFx0XHRcdC8vIFRoZSB0ZWNobmlxdWUgaGFzIHRvIGJlIHVzZWQgYXMgd2VsbCB3aGVuIGEgbGVhZGluZyBjb21iaW5hdG9yIGlzIHVzZWRcblx0XHRcdFx0Ly8gYXMgc3VjaCBzZWxlY3RvcnMgYXJlIG5vdCByZWNvZ25pemVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwuXG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggcmRlc2NlbmQudGVzdCggc2VsZWN0b3IgKSB8fCBybGVhZGluZ0NvbWJpbmF0b3IudGVzdCggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gV2UgY2FuIHVzZSA6c2NvcGUgaW5zdGVhZCBvZiB0aGUgSUQgaGFjayBpZiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdC8vIHN1cHBvcnRzIGl0ICYgaWYgd2UncmUgbm90IGNoYW5naW5nIHRoZSBjb250ZXh0LlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW5cblx0XHRcdFx0XHQvLyBzdHJpY3QtY29tcGFyaW5nIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICE9IGNvbnRleHQgfHwgIXN1cHBvcnQuc2NvcGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0XHRpZiAoICggbmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApICkgKSB7XG5cdFx0XHRcdFx0XHRcdG5pZCA9IGpRdWVyeS5lc2NhcGVTZWxlY3RvciggbmlkICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAoIG5pZCA9IGV4cGFuZG8gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzWyBpIF0gPSAoIG5pZCA/IFwiI1wiICsgbmlkIDogXCI6c2NvcGVcIiApICsgXCIgXCIgK1xuXHRcdFx0XHRcdFx0XHR0b1NlbGVjdG9yKCBncm91cHNbIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXNcblx0XHQvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2lzc3Vlcy8xNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoIGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUgKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBqUXVlcnkgc2VsZWN0b3IgbW9kdWxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblxuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApIHx8IG5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICkgKSAmJlxuXHRcdFx0ZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExK1xuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0aW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoIGogPSBtYXRjaEluZGV4ZXNbIGkgXSApIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFsgaiBdID0gISggbWF0Y2hlc1sgaiBdID0gc2VlZFsgaiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIGpRdWVyeSBzZWxlY3RvciBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW25vZGVdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIHNldERvY3VtZW50KCBub2RlICkge1xuXHR2YXIgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIGRvYyA9PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhalF1ZXJ5LmlzWE1MRG9jKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IGlPUyA3IG9ubHksIElFIDkgLSAxMStcblx0Ly8gT2xkZXIgYnJvd3NlcnMgZGlkbid0IHN1cHBvcnQgdW5wcmVmaXhlZCBgbWF0Y2hlc2AuXG5cdG1hdGNoZXMgPSBkb2N1bWVudEVsZW1lbnQubWF0Y2hlcyB8fFxuXHRcdGRvY3VtZW50RWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2N1bWVudEVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3I7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnNcblx0Ly8gKHNlZSB0cmFjLTEzOTM2KS5cblx0Ly8gTGltaXQgdGhlIGZpeCB0byBJRSAmIEVkZ2UgTGVnYWN5OyBkZXNwaXRlIEVkZ2UgMTUrIGltcGxlbWVudGluZyBgbWF0Y2hlc2AsXG5cdC8vIGFsbCBJRSA5KyBhbmQgRWRnZSBMZWdhY3kgdmVyc2lvbnMgaW1wbGVtZW50IGBtc01hdGNoZXNTZWxlY3RvcmAgYXMgd2VsbC5cblx0aWYgKCBkb2N1bWVudEVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IgJiZcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0cHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG5cdFx0KCBzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyApICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGpRdWVyeS5leHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHxcblx0XHRcdCFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggalF1ZXJ5LmV4cGFuZG8gKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUuXG5cdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRyZXR1cm4gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gSUUvRWRnZSBkb24ndCBzdXBwb3J0IHRoZSA6c2NvcGUgcHNldWRvLWNsYXNzLlxuXHRzdXBwb3J0LnNjb3BlID0gYXNzZXJ0KCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggXCI6c2NvcGVcIiApO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogQ2hyb21lIDEwNSAtIDExMSBvbmx5LCBTYWZhcmkgMTUuNCAtIDE2LjMgb25seVxuXHQvLyBNYWtlIHN1cmUgdGhlIGA6aGFzKClgIGFyZ3VtZW50IGlzIHBhcnNlZCB1bmZvcmdpdmluZ2x5LlxuXHQvLyBXZSBpbmNsdWRlIGAqYCBpbiB0aGUgdGVzdCB0byBkZXRlY3QgYnVnZ3kgaW1wbGVtZW50YXRpb25zIHRoYXQgYXJlXG5cdC8vIF9zZWxlY3RpdmVseV8gZm9yZ2l2aW5nIChzcGVjaWZpY2FsbHkgd2hlbiB0aGUgbGlzdCBpbmNsdWRlcyBhdCBsZWFzdFxuXHQvLyBvbmUgdmFsaWQgc2VsZWN0b3IpLlxuXHQvLyBOb3RlIHRoYXQgd2UgdHJlYXQgY29tcGxldGUgbGFjayBvZiBzdXBwb3J0IGZvciBgOmhhcygpYCBhcyBpZiBpdCB3ZXJlXG5cdC8vIHNwZWMtY29tcGxpYW50IHN1cHBvcnQsIHdoaWNoIGlzIGZpbmUgYmVjYXVzZSB1c2Ugb2YgYDpoYXMoKWAgaW4gc3VjaFxuXHQvLyBlbnZpcm9ubWVudHMgd2lsbCBmYWlsIGluIHRoZSBxU0EgcGF0aCBhbmQgZmFsbCBiYWNrIHRvIGpRdWVyeSB0cmF2ZXJzYWxcblx0Ly8gYW55d2F5LlxuXHRzdXBwb3J0LmNzc0hhcyA9IGFzc2VydCggZnVuY3Rpb24oKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIFwiOmhhcygqLDpqcWZha2UpXCIgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlci5JRCA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kLklEID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlci5JRCA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmQuSUQgPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZC5UQUcgPSBmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZC5DTEFTUyA9IGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHRcdHZhciBpbnB1dDtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPVxuXHRcdFx0XCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBkaXNhYmxlZD0nZGlzYWJsZWQnPlwiICtcblx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdC8vIFN1cHBvcnQ6IGlPUyA8PTcgLSA4IG9ubHlcblx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5IGluIHNvbWUgWE1MIGRvY3VtZW50c1xuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW3NlbGVjdGVkXVwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgPD03IC0gOCBvbmx5XG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIn49XCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgOCBvbmx5XG5cdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLiMuK1srfl1cIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTEwNSssIEZpcmVmb3ggPD0xMDQrLCBTYWZhcmkgPD0xNS40K1xuXHRcdC8vIEluIHNvbWUgb2YgdGhlIGRvY3VtZW50IGtpbmRzLCB0aGVzZSBzZWxlY3RvcnMgd291bGRuJ3Qgd29yayBuYXRpdmVseS5cblx0XHQvLyBUaGlzIGlzIHByb2JhYmx5IE9LIGJ1dCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2Ugd2FudCB0byBtYWludGFpblxuXHRcdC8vIGhhbmRsaW5nIHRoZW0gdGhyb3VnaCBqUXVlcnkgdHJhdmVyc2FsIGluIGpRdWVyeSAzLnguXG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCI6Y2hlY2tlZFwiICkubGVuZ3RoICkge1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmNoZWNrZWRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MTA1KywgRmlyZWZveCA8PTEwNCssIFNhZmFyaSA8PTE1LjQrXG5cdFx0Ly8gSW4gc29tZSBvZiB0aGUgZG9jdW1lbnQga2luZHMsIHRoZXNlIHNlbGVjdG9ycyB3b3VsZG4ndCB3b3JrIG5hdGl2ZWx5LlxuXHRcdC8vIFRoaXMgaXMgcHJvYmFibHkgT0sgYnV0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3ZSB3YW50IHRvIG1haW50YWluXG5cdFx0Ly8gaGFuZGxpbmcgdGhlbSB0aHJvdWdoIGpRdWVyeSB0cmF2ZXJzYWwgaW4galF1ZXJ5IDMueC5cblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCI6ZGlzYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRSAxMS9FZGdlIGRvbid0IGZpbmQgZWxlbWVudHMgb24gYSBgW25hbWU9JyddYCBxdWVyeSBpbiBzb21lIGNhc2VzLlxuXHRcdC8vIEFkZGluZyBhIHRlbXBvcmFyeSBhdHRyaWJ1dGUgdG8gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgc2VsZWN0aW9uIHdvcmtzXG5cdFx0Ly8gYXJvdW5kIHRoZSBpc3N1ZS5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBJRSAxMCAmIG9sZGVyIGRvbid0IHNlZW0gdG8gaGF2ZSB0aGUgaXNzdWUuXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIlwiICk7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT0nJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqbmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKj1cIiArXG5cdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdH1cblx0fSApO1xuXG5cdGlmICggIXN1cHBvcnQuY3NzSGFzICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDEwNSAtIDExMCssIFNhZmFyaSAxNS40IC0gMTYuMytcblx0XHQvLyBPdXIgcmVndWxhciBgdHJ5LWNhdGNoYCBtZWNoYW5pc20gZmFpbHMgdG8gZGV0ZWN0IG5hdGl2ZWx5LXVuc3VwcG9ydGVkXG5cdFx0Ly8gcHNldWRvLWNsYXNzZXMgaW5zaWRlIGA6aGFzKClgIChzdWNoIGFzIGA6aGFzKDpjb250YWlucyhcIkZvb1wiKSlgKVxuXHRcdC8vIGluIGJyb3dzZXJzIHRoYXQgcGFyc2UgdGhlIGA6aGFzKClgIGFyZ3VtZW50IGFzIGEgZm9yZ2l2aW5nIHNlbGVjdG9yIGxpc3QuXG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL3NlbGVjdG9ycy8jcmVsYXRpb25hbCBub3cgcmVxdWlyZXMgdGhlIGFyZ3VtZW50XG5cdFx0Ly8gdG8gYmUgcGFyc2VkIHVuZm9yZ2l2aW5nbHksIGJ1dCBicm93c2VycyBoYXZlIG5vdCB5ZXQgZnVsbHkgYWRqdXN0ZWQuXG5cdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmhhc1wiICk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKCBcInxcIiApICk7XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCAhc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlICkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRmaW5kLmNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGEgKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGZpbmQuY29udGFpbnMoIHByZWZlcnJlZERvYywgYiApICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBhICkgLSBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59XG5cbmZpbmQubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIGZpbmQoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5maW5kLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHRzZXREb2N1bWVudCggZWxlbSApO1xuXG5cdGlmICggZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZpbmQoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5maW5kLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuXG5maW5kLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIHRyYWMtMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRpZiAoIHZhbCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcbn07XG5cbmZpbmQuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0Ly9cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCtcblx0Ly8gVGVzdGluZyBmb3IgZGV0ZWN0aW5nIGR1cGxpY2F0ZXMgaXMgdW5wcmVkaWN0YWJsZSBzbyBpbnN0ZWFkIGFzc3VtZSB3ZSBjYW4ndFxuXHQvLyBkZXBlbmQgb24gZHVwbGljYXRlIGRldGVjdGlvbiBpbiBhbGwgYnJvd3NlcnMgd2l0aG91dCBhIHN0YWJsZSBzb3J0LlxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5zb3J0U3RhYmxlO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHNsaWNlLmNhbGwoIHJlc3VsdHMsIDAgKTtcblx0c29ydC5jYWxsKCByZXN1bHRzLCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHNwbGljZS5jYWxsKCByZXN1bHRzLCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbmpRdWVyeS5mbi51bmlxdWVTb3J0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LnVuaXF1ZVNvcnQoIHNsaWNlLmFwcGx5KCB0aGlzICkgKSApO1xufTtcblxuRXhwciA9IGpRdWVyeS5leHByID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdEFUVFI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFsgMyBdID0gKCBtYXRjaFsgMyBdIHx8IG1hdGNoWyA0IF0gfHwgbWF0Y2hbIDUgXSB8fCBcIlwiIClcblx0XHRcdFx0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbIDIgXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFsgMyBdID0gXCIgXCIgKyBtYXRjaFsgMyBdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRDSElMRDogZnVuY3Rpb24oIG1hdGNoICkge1xuXG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMSBdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0XHRmaW5kLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFsgNCBdID0gKyggbWF0Y2hbIDQgXSA/XG5cdFx0XHRcdFx0bWF0Y2hbIDUgXSArICggbWF0Y2hbIDYgXSB8fCAxICkgOlxuXHRcdFx0XHRcdDIgKiAoIG1hdGNoWyAzIF0gPT09IFwiZXZlblwiIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRtYXRjaFsgNSBdID0gKyggKCBtYXRjaFsgNyBdICsgbWF0Y2hbIDggXSApIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRmaW5kLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0UFNFVURPOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFsgNiBdICYmIG1hdGNoWyAyIF07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByLkNISUxELnRlc3QoIG1hdGNoWyAwIF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSBtYXRjaFsgNCBdIHx8IG1hdGNoWyA1IF0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdCggZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkgKSAmJlxuXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoIGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCApICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRUQUc6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIGV4cGVjdGVkTm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBlbGVtLCBleHBlY3RlZE5vZGVOYW1lICk7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdENMQVNTOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQoIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICtcblx0XHRcdFx0XHRcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkgKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoXG5cdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcblx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8XG5cdFx0XHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdEFUVFI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBmaW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCI9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCA9PT0gY2hlY2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCIhPVwiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQgIT09IGNoZWNrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiXj1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCIqPVwiICkge1xuXHRcdFx0XHRcdHJldHVybiBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiJD1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwifj1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiIClcblx0XHRcdFx0XHRcdC5pbmRleE9mKCBjaGVjayApID4gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvcGVyYXRvciA9PT0gXCJ8PVwiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Q0hJTEQ6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBfYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBub2RlWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlTmFtZSggbm9kZSwgbmFtZSApIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gcGFyZW50WyBleHBhbmRvIF0gfHwgKCBwYXJlbnRbIGV4cGFuZG8gXSA9IHt9ICk7XG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gb3V0ZXJDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGVOYW1lKCBub2RlLCBuYW1lICkgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0UFNFVURPOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblxuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0ZmluZC5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIGpRdWVyeSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZi5jYWxsKCBzZWVkLCBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblxuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdG5vdDogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW1DU1MsIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpIF0gPSAhKCBtYXRjaGVzWyBpIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0Ly8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9pc3N1ZXMvMjk5KVxuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRoYXM6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZmluZCggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRjb250YWluczogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgalF1ZXJ5LnRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRsYW5nOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KCBsYW5nIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0ZmluZC5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcInhtbDpsYW5nXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXCJsYW5nXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKCBlbGVtID0gZWxlbS5wYXJlbnROb2RlICkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHR0YXJnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdHJvb3Q6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50RWxlbWVudDtcblx0XHR9LFxuXG5cdFx0Zm9jdXM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiZcblx0XHRcdFx0ZG9jdW1lbnQuaGFzRm9jdXMoKSAmJlxuXHRcdFx0XHQhISggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCApO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRlbmFibGVkOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRkaXNhYmxlZDogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdGNoZWNrZWQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0cmV0dXJuICggbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICYmICEhZWxlbS5jaGVja2VkICkgfHxcblx0XHRcdFx0KCBub2RlTmFtZSggZWxlbSwgXCJvcHRpb25cIiApICYmICEhZWxlbS5zZWxlY3RlZCApO1xuXHRcdH0sXG5cblx0XHRzZWxlY3RlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTErXG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcblx0XHRcdC8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byB0cmVhdCB0aGUgZGVmYXVsdCBvcHRpb24gYXNcblx0XHRcdC8vIHNlbGVjdGVkIHdoZW4gaW4gYW4gb3B0Z3JvdXAuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0ZW1wdHk6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3MuZW1wdHkoIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdGhlYWRlcjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdGlucHV0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0YnV0dG9uOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8XG5cdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICk7XG5cdFx0fSxcblxuXHRcdHRleHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICYmIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8MTAgb25seVxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyXG5cdFx0XHRcdC8vIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoICggYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICkgPT0gbnVsbCB8fFxuXHRcdFx0XHRcdGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdGZpcnN0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9ICksXG5cblx0XHRsYXN0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0gKSxcblxuXHRcdGVxOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9ICksXG5cblx0XHRldmVuOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0b2RkOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0bHQ6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0aWYgKCBhcmd1bWVudCA8IDAgKSB7XG5cdFx0XHRcdGkgPSBhcmd1bWVudCArIGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAoIGFyZ3VtZW50ID4gbGVuZ3RoICkge1xuXHRcdFx0XHRpID0gbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IGFyZ3VtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0Z3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3MubnRoID0gRXhwci5wc2V1ZG9zLmVxO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbmZ1bmN0aW9uIHRva2VuaXplKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKCBtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWyAwIF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKCB0b2tlbnMgPSBbXSApICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoICggbWF0Y2ggPSBybGVhZGluZ0NvbWJpbmF0b3IuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbIDAgXS5yZXBsYWNlKCBydHJpbUNTUywgXCIgXCIgKVxuXHRcdFx0fSApO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KCBtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSApICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRpZiAoIHBhcnNlT25seSApIHtcblx0XHRyZXR1cm4gc29GYXIubGVuZ3RoO1xuXHR9XG5cblx0cmV0dXJuIHNvRmFyID9cblx0XHRmaW5kLmVycm9yKCBzZWxlY3RvciApIDpcblxuXHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn1cblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1sgaSBdLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKCBlbGVtWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgbm9kZU5hbWUoIGVsZW0sIHNraXAgKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAoIG9sZENhY2hlID0gb3V0ZXJDYWNoZVsga2V5IF0gKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoIG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAoIG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzWyBpIF0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbIDAgXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRmaW5kKCBzZWxlY3RvciwgY29udGV4dHNbIGkgXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLCBtYXRjaGVyT3V0LFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8XG5cdFx0XHRcdG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLFxuXHRcdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXM7XG5cblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyXG5cdFx0XHQvLyBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0bWF0Y2hlck91dCA9IHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRyZXN1bHRzO1xuXG5cdFx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXJJbjtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICggZWxlbSA9IHRlbXBbIGkgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKCBtYXRjaGVySW5bIGkgXSA9IGVsZW0gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAoIG1hdGNoZXJPdXQgPSBbXSApLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSAmJlxuXHRcdFx0XHRcdFx0KCB0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YuY2FsbCggc2VlZCwgZWxlbSApIDogcHJlTWFwWyBpIF0gKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkWyB0ZW1wIF0gPSAhKCByZXN1bHRzWyB0ZW1wIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAwIF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVsgXCIgXCIgXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdCggY2hlY2tDb250ZXh0ID0gY29udGV4dCApLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50XG5cdFx0XHQvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2lzc3Vlcy8yOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGkgXS50eXBlIF0gKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKCBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlciApIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zWyBpIF0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbIGkgXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGogXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3RvcihcblxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKVxuXHRcdFx0XHRcdFx0XHQuY29uY2F0KCB7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSApXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbUNTUywgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAoIHRva2VucyA9IHRva2Vucy5zbGljZSggaiApICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kLlRBRyggXCIqXCIsIG91dGVybW9zdCApLFxuXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoIGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xICksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBpT1MgPD03IC0gOSBvbmx5XG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmdcblx0XHRcdC8vIGVsZW1lbnRzIGJ5IGlkLiAoc2VlIHRyYWMtMTQxNDIpXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cHVzaC5jYWxsKCByZXN1bHRzLCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblxuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0gKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IHNldE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISggdW5tYXRjaGVkWyBpIF0gfHwgc2V0TWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFsgaSBdID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5mdW5jdGlvbiBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblxuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFsgaSBdICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3Rvcixcblx0XHRcdG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufVxuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggalF1ZXJ5J3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBqUXVlcnkgc2VsZWN0b3IgY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbmZ1bmN0aW9uIHNlbGVjdCggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKCBzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yICkgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKCB0b2tlbiA9IHRva2Vuc1sgMCBdICkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAxIF0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmQuSUQoXG5cdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRjb250ZXh0XG5cdFx0XHQpIHx8IFtdIClbIDAgXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHIubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zWyBpIF07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKCB0eXBlID0gdG9rZW4udHlwZSApIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoIGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSApICkge1xuXG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoICggc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1sgMCBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWyAwIF0udHlwZSApICYmXG5cdFx0XHRcdFx0XHR0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpICkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIC0gNC4xK1xuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoIFwiXCIgKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKCBcIlwiICkgPT09IGV4cGFuZG87XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCAtIDQuMStcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKSApICYgMTtcbn0gKTtcblxualF1ZXJ5LmZpbmQgPSBmaW5kO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlID0galF1ZXJ5LnVuaXF1ZVNvcnQ7XG5cbi8vIFRoZXNlIGhhdmUgYWx3YXlzIGJlZW4gcHJpdmF0ZSwgYnV0IHRoZXkgdXNlZCB0byBiZSBkb2N1bWVudGVkIGFzIHBhcnQgb2Zcbi8vIFNpenpsZSBzbyBsZXQncyBtYWludGFpbiB0aGVtIGZvciBub3cgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHB1cnBvc2VzLlxuZmluZC5jb21waWxlID0gY29tcGlsZTtcbmZpbmQuc2VsZWN0ID0gc2VsZWN0O1xuZmluZC5zZXREb2N1bWVudCA9IHNldERvY3VtZW50O1xuZmluZC50b2tlbml6ZSA9IHRva2VuaXplO1xuXG5maW5kLmVzY2FwZSA9IGpRdWVyeS5lc2NhcGVTZWxlY3RvcjtcbmZpbmQuZ2V0VGV4dCA9IGpRdWVyeS50ZXh0O1xuZmluZC5pc1hNTCA9IGpRdWVyeS5pc1hNTERvYztcbmZpbmQuc2VsZWN0b3JzID0galF1ZXJ5LmV4cHI7XG5maW5kLnN1cHBvcnQgPSBqUXVlcnkuc3VwcG9ydDtcbmZpbmQudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWVTb3J0O1xuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxufSApKCk7XG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKHRyYWMtOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKHRyYWMtMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIGpRdWVyeSNmaW5kXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGlmICggZWxlbS5jb250ZW50RG9jdW1lbnQgIT0gbnVsbCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMStcblx0XHRcdC8vIDxvYmplY3Q+IGVsZW1lbnRzIHdpdGggbm8gYGRhdGFgIGF0dHJpYnV0ZSBoYXMgYW4gb2JqZWN0XG5cdFx0XHQvLyBgY29udGVudERvY3VtZW50YCB3aXRoIGEgYG51bGxgIHByb3RvdHlwZS5cblx0XHRcdGdldFByb3RvKCBlbGVtLmNvbnRlbnREb2N1bWVudCApICkge1xuXG5cdFx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG5cdFx0Ly8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG5cdFx0Ly8gZG9uJ3Qgc3VwcG9ydCBpdC5cblx0XHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcblx0XHRcdGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIF9pLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MuZXJyb3IgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgZXJyb3IsIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0RXJyb3JIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5lcnJvciA9IGpRdWVyeS5EZWZlcnJlZC5nZXRFcnJvckhvb2soKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBkZXByZWNhdGVkIGFsaWFzIG9mIHRoZSBhYm92ZS4gV2hpbGUgdGhlIG5hbWUgc3VnZ2VzdHNcblx0XHRcdFx0XHRcdFx0XHQvLyByZXR1cm5pbmcgdGhlIHN0YWNrLCBub3QgYW4gZXJyb3IgaW5zdGFuY2UsIGpRdWVyeSBqdXN0IHBhc3Nlc1xuXHRcdFx0XHRcdFx0XHRcdC8vIGl0IGRpcmVjdGx5IHRvIGBjb25zb2xlLndhcm5gIHNvIGJvdGggd2lsbCB3b3JrOyBhbiBpbnN0YW5jZVxuXHRcdFx0XHRcdFx0XHRcdC8vIGp1c3QgYmV0dGVyIGNvb3BlcmF0ZXMgd2l0aCBzb3VyY2UgbWFwcy5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5lcnJvciA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBwcmltYXJ5IERlZmVycmVkXG5cdFx0XHRwcmltYXJ5ID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdHByaW1hcnkucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIHByaW1hcnkuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgcHJpbWFyeS5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBwcmltYXJ5LnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBwcmltYXJ5LnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIHByaW1hcnkucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByaW1hcnkucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG4vLyBJZiBgalF1ZXJ5LkRlZmVycmVkLmdldEVycm9ySG9va2AgaXMgZGVmaW5lZCwgYGFzeW5jRXJyb3JgIGlzIGFuIGVycm9yXG4vLyBjYXB0dXJlZCBiZWZvcmUgdGhlIGFzeW5jIGJhcnJpZXIgdG8gZ2V0IHRoZSBvcmlnaW5hbCBlcnJvciBjYXVzZVxuLy8gd2hpY2ggbWF5IG90aGVyd2lzZSBiZSBoaWRkZW4uXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgYXN5bmNFcnJvciApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsXG5cdFx0XHRlcnJvci5zdGFjaywgYXN5bmNFcnJvciApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgdHJhYy02NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBfa2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBfYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKHRyYWMtOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlIHRyYWMtODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKHRyYWMtMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG5cdHZhciBpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0XHR9LFxuXHRcdGNvbXBvc2VkID0geyBjb21wb3NlZDogdHJ1ZSB9O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCssIGlPUyAxMC4wIC0gMTAuMiBvbmx5XG5cdC8vIENoZWNrIGF0dGFjaG1lbnQgYWNyb3NzIHNoYWRvdyBET00gYm91bmRhcmllcyB3aGVuIHBvc3NpYmxlIChnaC0zNTA0KVxuXHQvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcblx0Ly8gRWFybHkgaU9TIDEwIHZlcnNpb25zIHN1cHBvcnQgYGF0dGFjaFNoYWRvd2AgYnV0IG5vdCBgZ2V0Um9vdE5vZGVgLFxuXHQvLyBsZWFkaW5nIHRvIGVycm9ycy4gV2UgbmVlZCB0byBjaGVjayBmb3IgYGdldFJvb3ROb2RlYC5cblx0aWYgKCBkb2N1bWVudEVsZW1lbnQuZ2V0Um9vdE5vZGUgKSB7XG5cdFx0aXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRSb290Tm9kZSggY29tcG9zZWQgKSA9PT0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdH07XG5cdH1cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpc0F0dGFjaGVkKCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9IGVsZW0ubm9kZVR5cGUgJiZcblx0XHRcdCggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKHRyYWMtMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICh0cmFjLTE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gSUUgPD05IHJlcGxhY2VzIDxvcHRpb24+IHRhZ3Mgd2l0aCB0aGVpciBjb250ZW50cyB3aGVuIGluc2VydGVkIG91dHNpZGUgb2Zcblx0Ly8gdGhlIHNlbGVjdCBlbGVtZW50LlxuXHRkaXYuaW5uZXJIVE1MID0gXCI8b3B0aW9uPjwvb3B0aW9uPlwiO1xuXHRzdXBwb3J0Lm9wdGlvbiA9ICEhZGl2Lmxhc3RDaGlsZDtcbn0gKSgpO1xuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICh0cmFjLTEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5pZiAoICFzdXBwb3J0Lm9wdGlvbiApIHtcblx0d3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uID0gWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdO1xufVxuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAodHJhYy0xNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKHRyYWMtMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGF0dGFjaGVkID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBhdHRhY2hlZCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxudmFyIHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gT25seSBhdHRhY2ggZXZlbnRzIHRvIG9iamVjdHMgdGhhdCBhY2NlcHQgZGF0YVxuXHRcdGlmICggIWFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSBPYmplY3QuY3JlYXRlKCBudWxsICk7XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cblx0XHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApLFxuXG5cdFx0XHRoYW5kbGVycyA9IChcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHQpWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICh0cmFjLTEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAodHJhYy02OTExLCB0cmFjLTgxNjUsIHRyYWMtMTEzODIsIHRyYWMtMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAodHJhYy0xMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBpc1NldHVwICkge1xuXG5cdC8vIE1pc3NpbmcgYGlzU2V0dXBgIGluZGljYXRlcyBhIHRyaWdnZXIgY2FsbCwgd2hpY2ggbXVzdCBmb3JjZSBzZXR1cCB0aHJvdWdoIGpRdWVyeS5ldmVudC5hZGRcblx0aWYgKCAhaXNTZXR1cCApIHtcblx0XHRpZiAoIGRhdGFQcml2LmdldCggZWwsIHR5cGUgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHJldHVyblRydWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVnaXN0ZXIgdGhlIGNvbnRyb2xsZXIgYXMgYSBzcGVjaWFsIHVuaXZlcnNhbCBoYW5kbGVyIGZvciBhbGwgZXZlbnQgbmFtZXNwYWNlc1xuXHRkYXRhUHJpdi5zZXQoIGVsLCB0eXBlLCBmYWxzZSApO1xuXHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwge1xuXHRcdG5hbWVzcGFjZTogZmFsc2UsXG5cdFx0aGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJlc3VsdCxcblx0XHRcdFx0c2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XG5cblx0XHRcdFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcblx0XHRcdFx0aWYgKCAhc2F2ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdHRoaXNbIHR5cGUgXSgpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcblxuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmdcblx0XHRcdFx0Ly8gdGhlIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZCApIHtcblxuXHRcdFx0XHQvLyAuLi5hbmQgY2FwdHVyZSB0aGUgcmVzdWx0XG5cdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cdFx0XHRcdFx0c2F2ZWRbIDAgXSxcblx0XHRcdFx0XHRzYXZlZC5zbGljZSggMSApLFxuXHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnQgYnkgYWxsIGpRdWVyeSBoYW5kbGVycyB3aGlsZSBhbGxvd2luZ1xuXHRcdFx0XHQvLyBuYXRpdmUgaGFuZGxlcnMgb24gdGhlIHNhbWUgZWxlbWVudCB0byBydW4uIE9uIHRhcmdldCwgdGhpcyBpcyBhY2hpZXZlZFxuXHRcdFx0XHQvLyBieSBzdG9wcGluZyBpbW1lZGlhdGUgcHJvcGFnYXRpb24ganVzdCBvbiB0aGUgalF1ZXJ5IGV2ZW50LiBIb3dldmVyLFxuXHRcdFx0XHQvLyB0aGUgbmF0aXZlIGV2ZW50IGlzIHJlLXdyYXBwZWQgYnkgYSBqUXVlcnkgb25lIG9uIGVhY2ggbGV2ZWwgb2YgdGhlXG5cdFx0XHRcdC8vIHByb3BhZ2F0aW9uIHNvIHRoZSBvbmx5IHdheSB0byBzdG9wIGl0IGZvciBqUXVlcnkgaXMgdG8gc3RvcCBpdCBmb3Jcblx0XHRcdFx0Ly8gZXZlcnlvbmUgdmlhIG5hdGl2ZSBgc3RvcFByb3BhZ2F0aW9uKClgLiBUaGlzIGlzIG5vdCBhIHByb2JsZW0gZm9yXG5cdFx0XHRcdC8vIGZvY3VzL2JsdXIgd2hpY2ggZG9uJ3QgYnViYmxlLCBidXQgaXQgZG9lcyBhbHNvIHN0b3AgY2xpY2sgb24gY2hlY2tib3hlc1xuXHRcdFx0XHQvLyBhbmQgcmFkaW9zLiBXZSBhY2NlcHQgdGhpcyBsaW1pdGF0aW9uLlxuXHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0ZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKHRyYWMtNTA0LCB0cmFjLTEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y29kZTogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cdHdoaWNoOiB0cnVlXG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuXG5cdGZ1bmN0aW9uIGZvY3VzTWFwcGVkSGFuZGxlciggbmF0aXZlRXZlbnQgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGZvY3VzaW4vZm9jdXNvdXQgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50c1xuXHRcdFx0Ly8gZm9jdXMvYmx1ci4gVGhpcyBpcyBiZWNhdXNlIHRoZSBmb3JtZXIgYXJlIHN5bmNocm9ub3VzIGluIElFIHdoaWxlIHRoZSBsYXR0ZXJcblx0XHRcdC8vIGFyZSBhc3luYy4gSW4gb3RoZXIgYnJvd3NlcnMsIGFsbCB0aG9zZSBoYW5kbGVycyBhcmUgaW52b2tlZCBzeW5jaHJvbm91c2x5LlxuXG5cdFx0XHQvLyBgaGFuZGxlYCBmcm9tIHByaXZhdGUgZGF0YSB3b3VsZCBhbHJlYWR5IHdyYXAgdGhlIGV2ZW50LCBidXQgd2UgbmVlZFxuXHRcdFx0Ly8gdG8gY2hhbmdlIHRoZSBgdHlwZWAgaGVyZS5cblx0XHRcdHZhciBoYW5kbGUgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiaGFuZGxlXCIgKSxcblx0XHRcdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXHRcdFx0ZXZlbnQudHlwZSA9IG5hdGl2ZUV2ZW50LnR5cGUgPT09IFwiZm9jdXNpblwiID8gXCJmb2N1c1wiIDogXCJibHVyXCI7XG5cdFx0XHRldmVudC5pc1NpbXVsYXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIEZpcnN0LCBoYW5kbGUgZm9jdXNpbi9mb2N1c291dFxuXHRcdFx0aGFuZGxlKCBuYXRpdmVFdmVudCApO1xuXG5cdFx0XHQvLyAuLi50aGVuLCBoYW5kbGUgZm9jdXMvYmx1clxuXHRcdFx0Ly9cblx0XHRcdC8vIGZvY3VzL2JsdXIgZG9uJ3QgYnViYmxlIHdoaWxlIGZvY3VzaW4vZm9jdXNvdXQgZG87IHNpbXVsYXRlIHRoZSBmb3JtZXIgYnkgb25seVxuXHRcdFx0Ly8gaW52b2tpbmcgdGhlIGhhbmRsZXIgYXQgdGhlIGxvd2VyIGxldmVsLlxuXHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQgKSB7XG5cblx0XHRcdFx0Ly8gVGhlIHNldHVwIHBhcnQgY2FsbHMgYGxldmVyYWdlTmF0aXZlYCwgd2hpY2gsIGluIHR1cm4sIGNhbGxzXG5cdFx0XHRcdC8vIGBqUXVlcnkuZXZlbnQuYWRkYCwgc28gZXZlbnQgaGFuZGxlIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gc2V0XG5cdFx0XHRcdC8vIGJ5IHRoaXMgcG9pbnQuXG5cdFx0XHRcdGhhbmRsZSggZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3Igbm9uLUlFIGJyb3dzZXJzLCBhdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50XG5cdFx0XHQvLyB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXQuXG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGRlbGVnYXRlVHlwZSwgbmF0aXZlRXZlbnQudGFyZ2V0LFxuXHRcdFx0XHRqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApICk7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSA9IHtcblxuXHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0dmFyIGF0dGFjaGVzO1xuXG5cdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIHRydWUgKTtcblxuXHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHRcdFx0XHQvLyBXZSB1c2UgdGhlIHNhbWUgbmF0aXZlIGhhbmRsZXIgZm9yIGZvY3VzaW4gJiBmb2N1cyAoYW5kIGZvY3Vzb3V0ICYgYmx1cilcblx0XHRcdFx0Ly8gc28gd2UgbmVlZCB0byBjb29yZGluYXRlIHNldHVwICYgdGVhcmRvd24gcGFydHMgYmV0d2VlbiB0aG9zZSBldmVudHMuXG5cdFx0XHRcdC8vIFVzZSBgZGVsZWdhdGVUeXBlYCBhcyB0aGUga2V5IGFzIGB0eXBlYCBpcyBhbHJlYWR5IHVzZWQgYnkgYGxldmVyYWdlTmF0aXZlYC5cblx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIGRlbGVnYXRlVHlwZSApO1xuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBkZWxlZ2F0ZVR5cGUsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXR0YWNoZXM7XG5cblx0XHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlICkge1xuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggdGhpcywgZGVsZWdhdGVUeXBlICkgLSAxO1xuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCB0aGlzLCBkZWxlZ2F0ZVR5cGUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIGRlbGVnYXRlVHlwZSwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gaW5kaWNhdGUgc3RhbmRhcmQgdGVhcmRvd24gc2hvdWxkIGJlIGFwcGxpZWRcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBTdXBwcmVzcyBuYXRpdmUgZm9jdXMgb3IgYmx1ciBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlXG5cdFx0Ly8gYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGV2ZW50LnRhcmdldCwgdHlwZSApO1xuXHRcdH0sXG5cblx0XHRkZWxlZ2F0ZVR5cGU6IGRlbGVnYXRlVHlwZVxuXHR9O1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuXHQvLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG5cdC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG5cdC8vXG5cdC8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuXHQvLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcblx0Ly8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG5cdC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5cdC8vXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0Ly8gVG8gcHJlc2VydmUgcmVsYXRpdmUgZm9jdXNpbi9mb2N1cyAmIGZvY3Vzb3V0L2JsdXIgZXZlbnQgb3JkZXIgZ3VhcmFudGVlZCBvbiB0aGUgMy54IGJyYW5jaCxcblx0Ly8gYXR0YWNoIGEgc2luZ2xlIGhhbmRsZXIgZm9yIGJvdGggZXZlbnRzIGluIElFLlxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZGVsZWdhdGVUeXBlIF0gPSB7XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xuXHRcdFx0Ly8gKHZpYSBgdGhpcy5kb2N1bWVudGApICYgZG9jdW1lbnQgKHZpYSBgdGhpc2ApLlxuXHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdGRhdGFIb2xkZXIgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgPyB0aGlzIDogZG9jLFxuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0XHRcdC8vIFdlIHVzZSB0aGUgc2FtZSBuYXRpdmUgaGFuZGxlciBmb3IgZm9jdXNpbiAmIGZvY3VzIChhbmQgZm9jdXNvdXQgJiBibHVyKVxuXHRcdFx0Ly8gc28gd2UgbmVlZCB0byBjb29yZGluYXRlIHNldHVwICYgdGVhcmRvd24gcGFydHMgYmV0d2VlbiB0aG9zZSBldmVudHMuXG5cdFx0XHQvLyBVc2UgYGRlbGVnYXRlVHlwZWAgYXMgdGhlIGtleSBhcyBgdHlwZWAgaXMgYWxyZWFkeSB1c2VkIGJ5IGBsZXZlcmFnZU5hdGl2ZWAuXG5cdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCBkZWxlZ2F0ZVR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBmb2N1c01hcHBlZEhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZGF0YVByaXYuc2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdH0sXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdGRhdGFIb2xkZXIgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgPyB0aGlzIDogZG9jLFxuXHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmdldCggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlICkgLSAxO1xuXG5cdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0aWYgKCBkb2N1bWVudC5kb2N1bWVudE1vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCBkZWxlZ2F0ZVR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBmb2N1c01hcHBlZEhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUsIGF0dGFjaGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8IVxcW0NEQVRBXFxbfFxcXVxcXT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuZ2V0KCBzcmMgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZGVzdCwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGZsYXQoIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAodHJhYy04MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZS1lbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSwgZG9jICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVW53cmFwIGEgQ0RBVEEgc2VjdGlvbiBjb250YWluaW5nIHNjcmlwdCBjb250ZW50cy4gVGhpcyBzaG91bGRuJ3QgYmVcblx0XHRcdFx0XHRcdFx0Ly8gbmVlZGVkIGFzIGluIFhNTCBkb2N1bWVudHMgdGhleSdyZSBhbHJlYWR5IG5vdCB2aXNpYmxlIHdoZW5cblx0XHRcdFx0XHRcdFx0Ly8gaW5zcGVjdGluZyBlbGVtZW50IGNvbnRlbnRzIGFuZCBpbiBIVE1MIGRvY3VtZW50cyB0aGV5IGhhdmUgbm9cblx0XHRcdFx0XHRcdFx0Ly8gbWVhbmluZyBidXQgd2UncmUgcHJlc2VydmluZyB0aGF0IGxvZ2ljIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIGJlIHJlbW92ZWQgY29tcGxldGVseSBpbiA0LjAuIFNlZSBnaC00OTA0LlxuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IGpRdWVyeSNmaW5kIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6XG5cdFx0XHQvLyBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciByY3VzdG9tUHJvcCA9IC9eLS0vO1xuXG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICh0cmFjLTE1MDk4LCB0cmFjLTE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAodHJhYy04OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcblx0XHR9LFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG5cdFx0Ly8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG5cdFx0Ly8gQmVoYXZpb3IgaW4gSUUgOSBpcyBtb3JlIHN1YnRsZSB0aGFuIGluIG5ld2VyIHZlcnNpb25zICYgaXQgcGFzc2VzXG5cdFx0Ly8gc29tZSB2ZXJzaW9ucyBvZiB0aGlzIHRlc3Q7IG1ha2Ugc3VyZSBub3QgdG8gbWFrZSBpdCBwYXNzIHRoZXJlIVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA3MCtcblx0XHQvLyBPbmx5IEZpcmVmb3ggaW5jbHVkZXMgYm9yZGVyIHdpZHRoc1xuXHRcdC8vIGluIGNvbXB1dGVkIGRpbWVuc2lvbnMuIChnaC00NTI5KVxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0YWJsZSwgdHIsIHRyQ2hpbGQsIHRyU3R5bGU7XG5cdFx0XHRpZiAoIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0YWJsZVwiICk7XG5cdFx0XHRcdHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0clwiICk7XG5cdFx0XHRcdHRyQ2hpbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0XHRcdFx0dGFibGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGVcIjtcblx0XHRcdFx0dHIuc3R5bGUuY3NzVGV4dCA9IFwiYm94LXNpemluZzpjb250ZW50LWJveDtib3JkZXI6MXB4IHNvbGlkXCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDg2K1xuXHRcdFx0XHQvLyBIZWlnaHQgc2V0IHRocm91Z2ggY3NzVGV4dCBkb2VzIG5vdCBnZXQgYXBwbGllZC5cblx0XHRcdFx0Ly8gQ29tcHV0ZWQgaGVpZ2h0IHRoZW4gY29tZXMgYmFjayBhcyAwLlxuXHRcdFx0XHR0ci5zdHlsZS5oZWlnaHQgPSBcIjFweFwiO1xuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmhlaWdodCA9IFwiOXB4XCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA4IENocm9tZSA4Nitcblx0XHRcdFx0Ly8gSW4gb3VyIGJvZHlCYWNrZ3JvdW5kLmh0bWwgaWZyYW1lLFxuXHRcdFx0XHQvLyBkaXNwbGF5IGZvciBhbGwgZGl2IGVsZW1lbnRzIGlzIHNldCB0byBcImlubGluZVwiLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYSBwcm9ibGVtIG9ubHkgaW4gQW5kcm9pZCA4IENocm9tZSA4Ni5cblx0XHRcdFx0Ly8gRW5zdXJpbmcgdGhlIGRpdiBpcyBgZGlzcGxheTogYmxvY2tgXG5cdFx0XHRcdC8vIGdldHMgYXJvdW5kIHRoaXMgaXNzdWUuXG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnRcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRhYmxlIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyQ2hpbGQgKTtcblxuXHRcdFx0XHR0clN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIHRyICk7XG5cdFx0XHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID0gKCBwYXJzZUludCggdHJTdHlsZS5oZWlnaHQsIDEwICkgK1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0clN0eWxlLmJvcmRlclRvcFdpZHRoLCAxMCApICtcblx0XHRcdFx0XHRwYXJzZUludCggdHJTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCwgMTAgKSApID09PSB0ci5vZmZzZXRIZWlnaHQ7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgdHJhYy0xMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoZ2gtMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdC8vIElFIG9ubHkgc3VwcG9ydHMgYFwiZmxvYXRcImAgaW4gYGdldFByb3BlcnR5VmFsdWVgOyBpbiBjb21wdXRlZCBzdHlsZXNcblx0XHQvLyBpdCdzIG9ubHkgYXZhaWxhYmxlIGFzIGBcImNzc0Zsb2F0XCJgLiBXZSBubyBsb25nZXIgbW9kaWZ5IHByb3BlcnRpZXNcblx0XHQvLyBzZW50IHRvIGAuY3NzKClgIGFwYXJ0IGZyb20gY2FtZWxDYXNpbmcsIHNvIHdlIG5lZWQgdG8gY2hlY2sgYm90aC5cblx0XHQvLyBOb3JtYWxseSwgdGhpcyB3b3VsZCBjcmVhdGUgZGlmZmVyZW5jZSBpbiBiZWhhdmlvcjogaWZcblx0XHQvLyBgZ2V0UHJvcGVydHlWYWx1ZWAgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcsIHRoZSB2YWx1ZSByZXR1cm5lZFxuXHRcdC8vIGJ5IGAuY3NzKClgIHdvdWxkIGJlIGB1bmRlZmluZWRgLiBUaGlzIGlzIHVzdWFsbHkgdGhlIGNhc2UgZm9yXG5cdFx0Ly8gZGlzY29ubmVjdGVkIGVsZW1lbnRzLiBIb3dldmVyLCBpbiBJRSBldmVuIGRpc2Nvbm5lY3RlZCBlbGVtZW50c1xuXHRcdC8vIHdpdGggbm8gc3R5bGVzIHJldHVybiBgXCJub25lXCJgIGZvciBgZ2V0UHJvcGVydHlWYWx1ZSggXCJmbG9hdFwiIClgXG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIGlzQ3VzdG9tUHJvcCAmJiByZXQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMTA1KywgQ2hyb21lIDw9MTA1K1xuXHRcdFx0Ly8gU3BlYyByZXF1aXJlcyB0cmltbWluZyB3aGl0ZXNwYWNlIGZvciBjdXN0b20gcHJvcGVydGllcyAoZ2gtNDkyNikuXG5cdFx0XHQvLyBGaXJlZm94IG9ubHkgdHJpbXMgbGVhZGluZyB3aGl0ZXNwYWNlLiBDaHJvbWUganVzdCBjb2xsYXBzZXNcblx0XHRcdC8vIGJvdGggbGVhZGluZyAmIHRyYWlsaW5nIHdoaXRlc3BhY2UgdG8gYSBzaW5nbGUgc3BhY2UuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gRmFsbCBiYWNrIHRvIGB1bmRlZmluZWRgIGlmIGVtcHR5IHN0cmluZyByZXR1cm5lZC5cblx0XHRcdC8vIFRoaXMgY29sbGFwc2VzIGEgbWlzc2luZyBkZWZpbml0aW9uIHdpdGggcHJvcGVydHkgZGVmaW5lZFxuXHRcdFx0Ly8gYW5kIHNldCB0byBhbiBlbXB0eSBzdHJpbmcgYnV0IHRoZXJlJ3Mgbm8gc3RhbmRhcmQgQVBJXG5cdFx0XHQvLyBhbGxvd2luZyB1cyB0byBkaWZmZXJlbnRpYXRlIHRoZW0gd2l0aG91dCBhIHBlcmZvcm1hbmNlIHBlbmFsdHlcblx0XHRcdC8vIGFuZCByZXR1cm5pbmcgYHVuZGVmaW5lZGAgYWxpZ25zIHdpdGggb2xkZXIgalF1ZXJ5LlxuXHRcdFx0Ly9cblx0XHRcdC8vIHJ0cmltQ1NTIHRyZWF0cyBVKzAwMEQgQ0FSUklBR0UgUkVUVVJOIGFuZCBVKzAwMEMgRk9STSBGRUVEXG5cdFx0XHQvLyBhcyB3aGl0ZXNwYWNlIHdoaWxlIENTUyBkb2VzIG5vdCwgYnV0IHRoaXMgaXMgbm90IGEgcHJvYmxlbVxuXHRcdFx0Ly8gYmVjYXVzZSBDU1MgcHJlcHJvY2Vzc2luZyByZXBsYWNlcyB0aGVtIHdpdGggVSswMDBBIExJTkUgRkVFRFxuXHRcdFx0Ly8gKHdoaWNoICppcyogQ1NTIHdoaXRlc3BhY2UpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpbnB1dC1wcmVwcm9jZXNzaW5nXG5cdFx0XHRyZXQgPSByZXQucmVwbGFjZSggcnRyaW1DU1MsIFwiJDFcIiApIHx8IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBfZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXHRcdGV4dHJhID0gMCxcblx0XHRkZWx0YSA9IDAsXG5cdFx0bWFyZ2luRGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdC8vIENvdW50IG1hcmdpbiBkZWx0YSBzZXBhcmF0ZWx5IHRvIG9ubHkgYWRkIGl0IGFmdGVyIHNjcm9sbCBndXR0ZXIgYWRqdXN0bWVudC5cblx0XHQvLyBUaGlzIGlzIG5lZWRlZCB0byBtYWtlIG5lZ2F0aXZlIG1hcmdpbnMgd29yayB3aXRoIGBvdXRlckhlaWdodCggdHJ1ZSApYCAoZ2gtMzk4MikuXG5cdFx0aWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRtYXJnaW5EZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuXHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdGlmICggYm94ID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cblx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdGNvbXB1dGVkVmFsIC1cblx0XHRcdGRlbHRhIC1cblx0XHRcdGV4dHJhIC1cblx0XHRcdDAuNVxuXG5cdFx0Ly8gSWYgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIHVua25vd24sIHRoZW4gd2UgY2FuJ3QgZGV0ZXJtaW5lIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXJcblx0XHQvLyBVc2UgYW4gZXhwbGljaXQgemVybyB0byBhdm9pZCBOYU4gKGdoLTM5NjQpXG5cdFx0KSApIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGEgKyBtYXJnaW5EZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gVXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3Igd2hlbiBib3ggc2l6aW5nIGlzIHVucmVsaWFibGUuXG5cdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveC5cblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxuXHRcdCFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoIGVsZW0sIFwidHJcIiApIHx8XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0XHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdFx0dmFsID09PSBcImF1dG9cIiB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdFx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApICYmXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSAmIGNvbm5lY3RlZFxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG5cdFx0YXNwZWN0UmF0aW86IHRydWUsXG5cdFx0Ym9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcblx0XHRjb2x1bW5Db3VudDogdHJ1ZSxcblx0XHRmbGV4R3JvdzogdHJ1ZSxcblx0XHRmbGV4U2hyaW5rOiB0cnVlLFxuXHRcdGZvbnRXZWlnaHQ6IHRydWUsXG5cdFx0Z3JpZEFyZWE6IHRydWUsXG5cdFx0Z3JpZENvbHVtbjogdHJ1ZSxcblx0XHRncmlkQ29sdW1uRW5kOiB0cnVlLFxuXHRcdGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcblx0XHRncmlkUm93OiB0cnVlLFxuXHRcdGdyaWRSb3dFbmQ6IHRydWUsXG5cdFx0Z3JpZFJvd1N0YXJ0OiB0cnVlLFxuXHRcdGxpbmVIZWlnaHQ6IHRydWUsXG5cdFx0b3BhY2l0eTogdHJ1ZSxcblx0XHRvcmRlcjogdHJ1ZSxcblx0XHRvcnBoYW5zOiB0cnVlLFxuXHRcdHNjYWxlOiB0cnVlLFxuXHRcdHdpZG93czogdHJ1ZSxcblx0XHR6SW5kZXg6IHRydWUsXG5cdFx0em9vbTogdHJ1ZSxcblxuXHRcdC8vIFNWRy1yZWxhdGVkXG5cdFx0ZmlsbE9wYWNpdHk6IHRydWUsXG5cdFx0Zmxvb2RPcGFjaXR5OiB0cnVlLFxuXHRcdHN0b3BPcGFjaXR5OiB0cnVlLFxuXHRcdHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG5cdFx0c3Ryb2tlT3BhY2l0eTogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAodHJhYy03MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgdHJhYy05MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKHRyYWMtNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBfaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0XHRcdC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcblx0XHRcdFx0Ly8gdG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdy5cblx0XHRcdFx0c2Nyb2xsYm94U2l6ZUJ1Z2d5ID0gIXN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpICYmXG5cdFx0XHRcdFx0c3R5bGVzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXG5cblx0XHRcdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtMzk5MSlcblx0XHRcdFx0Ym94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgP1xuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0MDtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuXHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzY3JvbGxib3hTaXplQnVnZ3kgKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICh0cmFjLTEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsICh0cmFjLTEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NOYW1lcywgY3VyLCBjdXJWYWx1ZSwgY2xhc3NOYW1lLCBpLCBmaW5hbFZhbHVlO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzTmFtZXMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0Y3VyID0gdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXNzTmFtZSArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NOYW1lcywgY3VyLCBjdXJWYWx1ZSwgY2xhc3NOYW1lLCBpLCBmaW5hbFZhbHVlO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc05hbWVzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCB0aGlzICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgY2xhc3NOYW1lcywgY2xhc3NOYW1lLCBpLCBzZWxmLFxuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpIF07XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAodHJhYy0xNDY4NiwgdHJhYy0xNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKHRyYWMtMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSB7IGd1aWQ6IERhdGUubm93KCkgfTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCBwYXJzZXJFcnJvckVsZW07XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHt9XG5cblx0cGFyc2VyRXJyb3JFbGVtID0geG1sICYmIHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiIClbIDAgXTtcblx0aWYgKCAheG1sIHx8IHBhcnNlckVycm9yRWxlbSApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgKFxuXHRcdFx0cGFyc2VyRXJyb3JFbGVtID9cblx0XHRcdFx0alF1ZXJ5Lm1hcCggcGFyc2VyRXJyb3JFbGVtLmNoaWxkTm9kZXMsIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWwudGV4dENvbnRlbnQ7XG5cdFx0XHRcdH0gKS5qb2luKCBcIlxcblwiICkgOlxuXHRcdFx0XHRkYXRhXG5cdFx0KSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICh0cmFjLTk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICh0cmFjLTk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKHRyYWMtNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKS5tYXAoIGZ1bmN0aW9uKCBfaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gdHJhYy03NjUzLCB0cmFjLTgxMjUsIHRyYWMtODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAodHJhYy0xMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cbm9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyB0cmFjLTk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdID1cblx0XHRcdFx0XHRcdFx0XHRcdCggcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdIHx8IFtdIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmNvbmNhdCggbWF0Y2hbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaC5qb2luKCBcIiwgXCIgKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICh0cmFjLTEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0IHRyYWMtMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICh0cmFjLTE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gdHJhYy05NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZS5ndWlkKysgKSArXG5cdFx0XHRcdFx0dW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVzZSBhIG5vb3AgY29udmVydGVyIGZvciBtaXNzaW5nIHNjcmlwdCBidXQgbm90IGlmIGpzb25wXG5cdFx0XHRpZiAoICFpc1N1Y2Nlc3MgJiZcblx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIFwic2NyaXB0XCIsIHMuZGF0YVR5cGVzICkgPiAtMSAmJlxuXHRcdFx0XHRqUXVlcnkuaW5BcnJheSggXCJqc29uXCIsIHMuZGF0YVR5cGVzICkgPCAwICkge1xuXHRcdFx0XHRzLmNvbnZlcnRlcnNbIFwidGV4dCBzY3JpcHRcIiBdID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggX2ksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHR2YXIgaTtcblx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0aWYgKCBpLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCIgKSB7XG5cdFx0XHRzLmNvbnRlbnRUeXBlID0gcy5oZWFkZXJzWyBpIF0gfHwgXCJcIjtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsLCBvcHRpb25zLCBkb2MgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICh0cmFjLTExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cblx0XHQvLyBPbmx5IGV2YWx1YXRlIHRoZSByZXNwb25zZSBpZiBpdCBpcyBzdWNjZXNzZnVsIChnaC00MTI2KVxuXHRcdC8vIGRhdGFGaWx0ZXIgaXMgbm90IGludm9rZWQgZm9yIGZhaWx1cmUgcmVzcG9uc2VzLCBzbyB1c2luZyBpdCBpbnN0ZWFkXG5cdFx0Ly8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG5cdFx0Y29udmVydGVyczoge1xuXHRcdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbigpIHt9XG5cdFx0fSxcblx0XHRkYXRhRmlsdGVyOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggcmVzcG9uc2UsIG9wdGlvbnMsIGRvYyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyB0cmFjLTE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSB0cmFjLTg2MDUsIHRyYWMtMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vIHRyYWMtMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gb3IgZm9yY2VkLWJ5LWF0dHJzIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcblx0XHRcdFx0XHQuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG5cdFx0XHRcdFx0LnByb3AoIHsgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LCBzcmM6IHMudXJsIH0gKVxuXHRcdFx0XHRcdC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZS5ndWlkKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBfaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCgge1xuXHRcdHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsXG5cdFx0Y29udGVudDogdHlwZSxcblx0XHRcIlwiOiBcIm91dGVyXCIgKyBuYW1lXG5cdH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIF9pLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fSxcblxuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXNcblx0XHRcdC5vbiggXCJtb3VzZWVudGVyXCIsIGZuT3ZlciApXG5cdFx0XHQub24oIFwibW91c2VsZWF2ZVwiLCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaChcblx0KCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblxuXHRcdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblx0fVxuKTtcblxuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG4vLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcbi8vIFJlcXVpcmUgdGhhdCB0aGUgXCJ3aGl0ZXNwYWNlIHJ1blwiIHN0YXJ0cyBmcm9tIGEgbm9uLXdoaXRlc3BhY2Vcbi8vIHRvIGF2b2lkIE8oTl4yKSBiZWhhdmlvciB3aGVuIHRoZSBlbmdpbmUgd291bGQgdHJ5IG1hdGNoaW5nIFwiXFxzKyRcIiBhdCBlYWNoIHNwYWNlIHBvc2l0aW9uLlxudmFyIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8KFteXFxzXFx1RkVGRlxceEEwXSlbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cbmpRdWVyeS50cmltID0gZnVuY3Rpb24oIHRleHQgKSB7XG5cdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFwiXCIgOlxuXHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICk7XG59O1xuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICh0cmFjLTcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICh0cmFjLTEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBmYW5jeUJveCB2My41Ljdcbi8vXG4vLyBMaWNlbnNlZCBHUEx2MyBmb3Igb3BlbiBzb3VyY2UgdXNlXG4vLyBvciBmYW5jeUJveCBDb21tZXJjaWFsIExpY2Vuc2UgZm9yIGNvbW1lcmNpYWwgdXNlXG4vL1xuLy8gaHR0cDovL2ZhbmN5YXBwcy5jb20vZmFuY3lib3gvXG4vLyBDb3B5cmlnaHQgMjAxOSBmYW5jeUFwcHNcbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuIWZ1bmN0aW9uKHQsZSxuLG8pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkodCxlKXt2YXIgbyxpLGEscz1bXSxyPTA7dCYmdC5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KHQucHJldmVudERlZmF1bHQoKSxlPWV8fHt9LHQmJnQuZGF0YSYmKGU9aCh0LmRhdGEub3B0aW9ucyxlKSksbz1lLiR0YXJnZXR8fG4odC5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKFwiYmx1clwiKSwoYT1uLmZhbmN5Ym94LmdldEluc3RhbmNlKCkpJiZhLiR0cmlnZ2VyJiZhLiR0cmlnZ2VyLmlzKG8pfHwoZS5zZWxlY3Rvcj9zPW4oZS5zZWxlY3Rvcik6KGk9by5hdHRyKFwiZGF0YS1mYW5jeWJveFwiKXx8XCJcIixpPyhzPXQuZGF0YT90LmRhdGEuaXRlbXM6W10scz1zLmxlbmd0aD9zLmZpbHRlcignW2RhdGEtZmFuY3lib3g9XCInK2krJ1wiXScpOm4oJ1tkYXRhLWZhbmN5Ym94PVwiJytpKydcIl0nKSk6cz1bb10pLHI9bihzKS5pbmRleChvKSxyPDAmJihyPTApLGE9bi5mYW5jeWJveC5vcGVuKHMsZSxyKSxhLiR0cmlnZ2VyPW8pKX1pZih0LmNvbnNvbGU9dC5jb25zb2xlfHx7aW5mbzpmdW5jdGlvbih0KXt9fSxuKXtpZihuLmZuLmZhbmN5Ym94KXJldHVybiB2b2lkIGNvbnNvbGUuaW5mbyhcImZhbmN5Qm94IGFscmVhZHkgaW5pdGlhbGl6ZWRcIik7dmFyIGE9e2Nsb3NlRXhpc3Rpbmc6ITEsbG9vcDohMSxndXR0ZXI6NTAsa2V5Ym9hcmQ6ITAscHJldmVudENhcHRpb25PdmVybGFwOiEwLGFycm93czohMCxpbmZvYmFyOiEwLHNtYWxsQnRuOlwiYXV0b1wiLHRvb2xiYXI6XCJhdXRvXCIsYnV0dG9uczpbXCJ6b29tXCIsXCJzbGlkZVNob3dcIixcInRodW1ic1wiLFwiY2xvc2VcIl0saWRsZVRpbWU6Myxwcm90ZWN0OiExLG1vZGFsOiExLGltYWdlOntwcmVsb2FkOiExfSxhamF4OntzZXR0aW5nczp7ZGF0YTp7ZmFuY3lib3g6ITB9fX0saWZyYW1lOnt0cGw6JzxpZnJhbWUgaWQ9XCJmYW5jeWJveC1mcmFtZXtybmR9XCIgbmFtZT1cImZhbmN5Ym94LWZyYW1le3JuZH1cIiBjbGFzcz1cImZhbmN5Ym94LWlmcmFtZVwiIGFsbG93ZnVsbHNjcmVlbj1cImFsbG93ZnVsbHNjcmVlblwiIGFsbG93PVwiYXV0b3BsYXk7IGZ1bGxzY3JlZW5cIiBzcmM9XCJcIj48L2lmcmFtZT4nLHByZWxvYWQ6ITAsY3NzOnt9LGF0dHI6e3Njcm9sbGluZzpcImF1dG9cIn19LHZpZGVvOnt0cGw6Jzx2aWRlbyBjbGFzcz1cImZhbmN5Ym94LXZpZGVvXCIgY29udHJvbHMgY29udHJvbHNMaXN0PVwibm9kb3dubG9hZFwiIHBvc3Rlcj1cInt7cG9zdGVyfX1cIj48c291cmNlIHNyYz1cInt7c3JjfX1cIiB0eXBlPVwie3tmb3JtYXR9fVwiIC8+U29ycnksIHlvdXIgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCBlbWJlZGRlZCB2aWRlb3MsIDxhIGhyZWY9XCJ7e3NyY319XCI+ZG93bmxvYWQ8L2E+IGFuZCB3YXRjaCB3aXRoIHlvdXIgZmF2b3JpdGUgdmlkZW8gcGxheWVyITwvdmlkZW8+Jyxmb3JtYXQ6XCJcIixhdXRvU3RhcnQ6ITB9LGRlZmF1bHRUeXBlOlwiaW1hZ2VcIixhbmltYXRpb25FZmZlY3Q6XCJ6b29tXCIsYW5pbWF0aW9uRHVyYXRpb246MzY2LHpvb21PcGFjaXR5OlwiYXV0b1wiLHRyYW5zaXRpb25FZmZlY3Q6XCJmYWRlXCIsdHJhbnNpdGlvbkR1cmF0aW9uOjM2NixzbGlkZUNsYXNzOlwiXCIsYmFzZUNsYXNzOlwiXCIsYmFzZVRwbDonPGRpdiBjbGFzcz1cImZhbmN5Ym94LWNvbnRhaW5lclwiIHJvbGU9XCJkaWFsb2dcIiB0YWJpbmRleD1cIi0xXCI+PGRpdiBjbGFzcz1cImZhbmN5Ym94LWJnXCI+PC9kaXY+PGRpdiBjbGFzcz1cImZhbmN5Ym94LWlubmVyXCI+PGRpdiBjbGFzcz1cImZhbmN5Ym94LWluZm9iYXJcIj48c3BhbiBkYXRhLWZhbmN5Ym94LWluZGV4Pjwvc3Bhbj4mbmJzcDsvJm5ic3A7PHNwYW4gZGF0YS1mYW5jeWJveC1jb3VudD48L3NwYW4+PC9kaXY+PGRpdiBjbGFzcz1cImZhbmN5Ym94LXRvb2xiYXJcIj57e2J1dHRvbnN9fTwvZGl2PjxkaXYgY2xhc3M9XCJmYW5jeWJveC1uYXZpZ2F0aW9uXCI+e3thcnJvd3N9fTwvZGl2PjxkaXYgY2xhc3M9XCJmYW5jeWJveC1zdGFnZVwiPjwvZGl2PjxkaXYgY2xhc3M9XCJmYW5jeWJveC1jYXB0aW9uXCI+PGRpdiBjbGFzcz1cImZhbmN5Ym94LWNhcHRpb25fX2JvZHlcIj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj4nLHNwaW5uZXJUcGw6JzxkaXYgY2xhc3M9XCJmYW5jeWJveC1sb2FkaW5nXCI+PC9kaXY+JyxlcnJvclRwbDonPGRpdiBjbGFzcz1cImZhbmN5Ym94LWVycm9yXCI+PHA+e3tFUlJPUn19PC9wPjwvZGl2PicsYnRuVHBsOntkb3dubG9hZDonPGEgZG93bmxvYWQgZGF0YS1mYW5jeWJveC1kb3dubG9hZCBjbGFzcz1cImZhbmN5Ym94LWJ1dHRvbiBmYW5jeWJveC1idXR0b24tLWRvd25sb2FkXCIgdGl0bGU9XCJ7e0RPV05MT0FEfX1cIiBocmVmPVwiamF2YXNjcmlwdDo7XCI+PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMTguNjIgMTcuMDlWMTlINS4zOHYtMS45MXptLTIuOTctNi45NkwxNyAxMS40NWwtNSA0Ljg3LTUtNC44NyAxLjM2LTEuMzIgMi42OCAyLjY0VjVoMS45MnY3Ljc3elwiLz48L3N2Zz48L2E+Jyx6b29tOic8YnV0dG9uIGRhdGEtZmFuY3lib3gtem9vbSBjbGFzcz1cImZhbmN5Ym94LWJ1dHRvbiBmYW5jeWJveC1idXR0b24tLXpvb21cIiB0aXRsZT1cInt7Wk9PTX19XCI+PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMTguNyAxNy4zbC0zLTNhNS45IDUuOSAwIDAgMC0uNi03LjYgNS45IDUuOSAwIDAgMC04LjQgMCA1LjkgNS45IDAgMCAwIDAgOC40IDUuOSA1LjkgMCAwIDAgNy43LjdsMyAzYTEgMSAwIDAgMCAxLjMgMGMuNC0uNS40LTEgMC0xLjV6TTguMSAxMy44YTQgNCAwIDAgMSAwLTUuNyA0IDQgMCAwIDEgNS43IDAgNCA0IDAgMCAxIDAgNS43IDQgNCAwIDAgMS01LjcgMHpcIi8+PC9zdmc+PC9idXR0b24+JyxjbG9zZTonPGJ1dHRvbiBkYXRhLWZhbmN5Ym94LWNsb3NlIGNsYXNzPVwiZmFuY3lib3gtYnV0dG9uIGZhbmN5Ym94LWJ1dHRvbi0tY2xvc2VcIiB0aXRsZT1cInt7Q0xPU0V9fVwiPjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTEyIDEwLjZMNi42IDUuMiA1LjIgNi42bDUuNCA1LjQtNS40IDUuNCAxLjQgMS40IDUuNC01LjQgNS40IDUuNCAxLjQtMS40LTUuNC01LjQgNS40LTUuNC0xLjQtMS40LTUuNCA1LjR6XCIvPjwvc3ZnPjwvYnV0dG9uPicsYXJyb3dMZWZ0Oic8YnV0dG9uIGRhdGEtZmFuY3lib3gtcHJldiBjbGFzcz1cImZhbmN5Ym94LWJ1dHRvbiBmYW5jeWJveC1idXR0b24tLWFycm93X2xlZnRcIiB0aXRsZT1cInt7UFJFVn19XCI+PGRpdj48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xMS4yOCAxNS43bC0xLjM0IDEuMzdMNSAxMmw0Ljk0LTUuMDcgMS4zNCAxLjM4LTIuNjggMi43MkgxOXYxLjk0SDguNnpcIi8+PC9zdmc+PC9kaXY+PC9idXR0b24+JyxhcnJvd1JpZ2h0Oic8YnV0dG9uIGRhdGEtZmFuY3lib3gtbmV4dCBjbGFzcz1cImZhbmN5Ym94LWJ1dHRvbiBmYW5jeWJveC1idXR0b24tLWFycm93X3JpZ2h0XCIgdGl0bGU9XCJ7e05FWFR9fVwiPjxkaXY+PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMTUuNCAxMi45N2wtMi42OCAyLjcyIDEuMzQgMS4zOEwxOSAxMmwtNC45NC01LjA3LTEuMzQgMS4zOCAyLjY4IDIuNzJINXYxLjk0elwiLz48L3N2Zz48L2Rpdj48L2J1dHRvbj4nLHNtYWxsQnRuOic8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLWZhbmN5Ym94LWNsb3NlIGNsYXNzPVwiZmFuY3lib3gtYnV0dG9uIGZhbmN5Ym94LWNsb3NlLXNtYWxsXCIgdGl0bGU9XCJ7e0NMT1NFfX1cIj48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2ZXJzaW9uPVwiMVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTEzIDEybDUtNS0xLTEtNSA1LTUtNS0xIDEgNSA1LTUgNSAxIDEgNS01IDUgNSAxLTF6XCIvPjwvc3ZnPjwvYnV0dG9uPid9LHBhcmVudEVsOlwiYm9keVwiLGhpZGVTY3JvbGxiYXI6ITAsYXV0b0ZvY3VzOiEwLGJhY2tGb2N1czohMCx0cmFwRm9jdXM6ITAsZnVsbFNjcmVlbjp7YXV0b1N0YXJ0OiExfSx0b3VjaDp7dmVydGljYWw6ITAsbW9tZW50dW06ITB9LGhhc2g6bnVsbCxtZWRpYTp7fSxzbGlkZVNob3c6e2F1dG9TdGFydDohMSxzcGVlZDozZTN9LHRodW1iczp7YXV0b1N0YXJ0OiExLGhpZGVPbkNsb3NlOiEwLHBhcmVudEVsOlwiLmZhbmN5Ym94LWNvbnRhaW5lclwiLGF4aXM6XCJ5XCJ9LHdoZWVsOlwiYXV0b1wiLG9uSW5pdDpuLm5vb3AsYmVmb3JlTG9hZDpuLm5vb3AsYWZ0ZXJMb2FkOm4ubm9vcCxiZWZvcmVTaG93Om4ubm9vcCxhZnRlclNob3c6bi5ub29wLGJlZm9yZUNsb3NlOm4ubm9vcCxhZnRlckNsb3NlOm4ubm9vcCxvbkFjdGl2YXRlOm4ubm9vcCxvbkRlYWN0aXZhdGU6bi5ub29wLGNsaWNrQ29udGVudDpmdW5jdGlvbih0LGUpe3JldHVyblwiaW1hZ2VcIj09PXQudHlwZSYmXCJ6b29tXCJ9LGNsaWNrU2xpZGU6XCJjbG9zZVwiLGNsaWNrT3V0c2lkZTpcImNsb3NlXCIsZGJsY2xpY2tDb250ZW50OiExLGRibGNsaWNrU2xpZGU6ITEsZGJsY2xpY2tPdXRzaWRlOiExLG1vYmlsZTp7cHJldmVudENhcHRpb25PdmVybGFwOiExLGlkbGVUaW1lOiExLGNsaWNrQ29udGVudDpmdW5jdGlvbih0LGUpe3JldHVyblwiaW1hZ2VcIj09PXQudHlwZSYmXCJ0b2dnbGVDb250cm9sc1wifSxjbGlja1NsaWRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJpbWFnZVwiPT09dC50eXBlP1widG9nZ2xlQ29udHJvbHNcIjpcImNsb3NlXCJ9LGRibGNsaWNrQ29udGVudDpmdW5jdGlvbih0LGUpe3JldHVyblwiaW1hZ2VcIj09PXQudHlwZSYmXCJ6b29tXCJ9LGRibGNsaWNrU2xpZGU6ZnVuY3Rpb24odCxlKXtyZXR1cm5cImltYWdlXCI9PT10LnR5cGUmJlwiem9vbVwifX0sbGFuZzpcImVuXCIsaTE4bjp7ZW46e0NMT1NFOlwiQ2xvc2VcIixORVhUOlwiTmV4dFwiLFBSRVY6XCJQcmV2aW91c1wiLEVSUk9SOlwiVGhlIHJlcXVlc3RlZCBjb250ZW50IGNhbm5vdCBiZSBsb2FkZWQuIDxici8+IFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCIsUExBWV9TVEFSVDpcIlN0YXJ0IHNsaWRlc2hvd1wiLFBMQVlfU1RPUDpcIlBhdXNlIHNsaWRlc2hvd1wiLEZVTExfU0NSRUVOOlwiRnVsbCBzY3JlZW5cIixUSFVNQlM6XCJUaHVtYm5haWxzXCIsRE9XTkxPQUQ6XCJEb3dubG9hZFwiLFNIQVJFOlwiU2hhcmVcIixaT09NOlwiWm9vbVwifSxkZTp7Q0xPU0U6XCJTY2hsaWUmc3psaWc7ZW5cIixORVhUOlwiV2VpdGVyXCIsUFJFVjpcIlp1ciZ1dW1sO2NrXCIsRVJST1I6XCJEaWUgYW5nZWZvcmRlcnRlbiBEYXRlbiBrb25udGVuIG5pY2h0IGdlbGFkZW4gd2VyZGVuLiA8YnIvPiBCaXR0ZSB2ZXJzdWNoZW4gU2llIGVzIHNwJmF1bWw7dGVyIG5vY2htYWwuXCIsUExBWV9TVEFSVDpcIkRpYXNjaGF1IHN0YXJ0ZW5cIixQTEFZX1NUT1A6XCJEaWFzY2hhdSBiZWVuZGVuXCIsRlVMTF9TQ1JFRU46XCJWb2xsYmlsZFwiLFRIVU1CUzpcIlZvcnNjaGF1YmlsZGVyXCIsRE9XTkxPQUQ6XCJIZXJ1bnRlcmxhZGVuXCIsU0hBUkU6XCJUZWlsZW5cIixaT09NOlwiVmVyZ3Imb3VtbDsmc3psaWc7ZXJuXCJ9fX0scz1uKHQpLHI9bihlKSxjPTAsbD1mdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5oYXNPd25Qcm9wZXJ0eSYmdCBpbnN0YW5jZW9mIG59LGQ9ZnVuY3Rpb24oKXtyZXR1cm4gdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHQud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx0Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8dC5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbihlKXtyZXR1cm4gdC5zZXRUaW1lb3V0KGUsMWUzLzYwKX19KCksdT1mdW5jdGlvbigpe3JldHVybiB0LmNhbmNlbEFuaW1hdGlvbkZyYW1lfHx0LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lfHx0Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lfHx0Lm9DYW5jZWxBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24oZSl7dC5jbGVhclRpbWVvdXQoZSl9fSgpLGY9ZnVuY3Rpb24oKXt2YXIgdCxuPWUuY3JlYXRlRWxlbWVudChcImZha2VlbGVtZW50XCIpLG89e3RyYW5zaXRpb246XCJ0cmFuc2l0aW9uZW5kXCIsT1RyYW5zaXRpb246XCJvVHJhbnNpdGlvbkVuZFwiLE1velRyYW5zaXRpb246XCJ0cmFuc2l0aW9uZW5kXCIsV2Via2l0VHJhbnNpdGlvbjpcIndlYmtpdFRyYW5zaXRpb25FbmRcIn07Zm9yKHQgaW4gbylpZih2b2lkIDAhPT1uLnN0eWxlW3RdKXJldHVybiBvW3RdO3JldHVyblwidHJhbnNpdGlvbmVuZFwifSgpLHA9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQubGVuZ3RoJiZ0WzBdLm9mZnNldEhlaWdodH0saD1mdW5jdGlvbih0LGUpe3ZhciBvPW4uZXh0ZW5kKCEwLHt9LHQsZSk7cmV0dXJuIG4uZWFjaChlLGZ1bmN0aW9uKHQsZSl7bi5pc0FycmF5KGUpJiYob1t0XT1lKX0pLG99LGc9ZnVuY3Rpb24odCl7dmFyIG8saTtyZXR1cm4hKCF0fHx0Lm93bmVyRG9jdW1lbnQhPT1lKSYmKG4oXCIuZmFuY3lib3gtY29udGFpbmVyXCIpLmNzcyhcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpLG89e3g6dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0K3Qub2Zmc2V0V2lkdGgvMix5OnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wK3Qub2Zmc2V0SGVpZ2h0LzJ9LGk9ZS5lbGVtZW50RnJvbVBvaW50KG8ueCxvLnkpPT09dCxuKFwiLmZhbmN5Ym94LWNvbnRhaW5lclwiKS5jc3MoXCJwb2ludGVyLWV2ZW50c1wiLFwiXCIpLGkpfSxiPWZ1bmN0aW9uKHQsZSxvKXt2YXIgaT10aGlzO2kub3B0cz1oKHtpbmRleDpvfSxuLmZhbmN5Ym94LmRlZmF1bHRzKSxuLmlzUGxhaW5PYmplY3QoZSkmJihpLm9wdHM9aChpLm9wdHMsZSkpLG4uZmFuY3lib3guaXNNb2JpbGUmJihpLm9wdHM9aChpLm9wdHMsaS5vcHRzLm1vYmlsZSkpLGkuaWQ9aS5vcHRzLmlkfHwrK2MsaS5jdXJySW5kZXg9cGFyc2VJbnQoaS5vcHRzLmluZGV4LDEwKXx8MCxpLnByZXZJbmRleD1udWxsLGkucHJldlBvcz1udWxsLGkuY3VyclBvcz0wLGkuZmlyc3RSdW49ITAsaS5ncm91cD1bXSxpLnNsaWRlcz17fSxpLmFkZENvbnRlbnQodCksaS5ncm91cC5sZW5ndGgmJmkuaW5pdCgpfTtuLmV4dGVuZChiLnByb3RvdHlwZSx7aW5pdDpmdW5jdGlvbigpe3ZhciBvLGksYT10aGlzLHM9YS5ncm91cFthLmN1cnJJbmRleF0scj1zLm9wdHM7ci5jbG9zZUV4aXN0aW5nJiZuLmZhbmN5Ym94LmNsb3NlKCEwKSxuKFwiYm9keVwiKS5hZGRDbGFzcyhcImZhbmN5Ym94LWFjdGl2ZVwiKSwhbi5mYW5jeWJveC5nZXRJbnN0YW5jZSgpJiYhMSE9PXIuaGlkZVNjcm9sbGJhciYmIW4uZmFuY3lib3guaXNNb2JpbGUmJmUuYm9keS5zY3JvbGxIZWlnaHQ+dC5pbm5lckhlaWdodCYmKG4oXCJoZWFkXCIpLmFwcGVuZCgnPHN0eWxlIGlkPVwiZmFuY3lib3gtc3R5bGUtbm9zY3JvbGxcIiB0eXBlPVwidGV4dC9jc3NcIj4uY29tcGVuc2F0ZS1mb3Itc2Nyb2xsYmFye21hcmdpbi1yaWdodDonKyh0LmlubmVyV2lkdGgtZS5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpK1wicHg7fTwvc3R5bGU+XCIpLG4oXCJib2R5XCIpLmFkZENsYXNzKFwiY29tcGVuc2F0ZS1mb3Itc2Nyb2xsYmFyXCIpKSxpPVwiXCIsbi5lYWNoKHIuYnV0dG9ucyxmdW5jdGlvbih0LGUpe2krPXIuYnRuVHBsW2VdfHxcIlwifSksbz1uKGEudHJhbnNsYXRlKGEsci5iYXNlVHBsLnJlcGxhY2UoXCJ7e2J1dHRvbnN9fVwiLGkpLnJlcGxhY2UoXCJ7e2Fycm93c319XCIsci5idG5UcGwuYXJyb3dMZWZ0K3IuYnRuVHBsLmFycm93UmlnaHQpKSkuYXR0cihcImlkXCIsXCJmYW5jeWJveC1jb250YWluZXItXCIrYS5pZCkuYWRkQ2xhc3Moci5iYXNlQ2xhc3MpLmRhdGEoXCJGYW5jeUJveFwiLGEpLmFwcGVuZFRvKHIucGFyZW50RWwpLGEuJHJlZnM9e2NvbnRhaW5lcjpvfSxbXCJiZ1wiLFwiaW5uZXJcIixcImluZm9iYXJcIixcInRvb2xiYXJcIixcInN0YWdlXCIsXCJjYXB0aW9uXCIsXCJuYXZpZ2F0aW9uXCJdLmZvckVhY2goZnVuY3Rpb24odCl7YS4kcmVmc1t0XT1vLmZpbmQoXCIuZmFuY3lib3gtXCIrdCl9KSxhLnRyaWdnZXIoXCJvbkluaXRcIiksYS5hY3RpdmF0ZSgpLGEuanVtcFRvKGEuY3VyckluZGV4KX0sdHJhbnNsYXRlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5vcHRzLmkxOG5bdC5vcHRzLmxhbmddfHx0Lm9wdHMuaTE4bi5lbjtyZXR1cm4gZS5yZXBsYWNlKC9cXHtcXHsoXFx3KylcXH1cXH0vZyxmdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1uW2VdP3Q6bltlXX0pfSxhZGRDb250ZW50OmZ1bmN0aW9uKHQpe3ZhciBlLG89dGhpcyxpPW4ubWFrZUFycmF5KHQpO24uZWFjaChpLGZ1bmN0aW9uKHQsZSl7dmFyIGksYSxzLHIsYyxsPXt9LGQ9e307bi5pc1BsYWluT2JqZWN0KGUpPyhsPWUsZD1lLm9wdHN8fGUpOlwib2JqZWN0XCI9PT1uLnR5cGUoZSkmJm4oZSkubGVuZ3RoPyhpPW4oZSksZD1pLmRhdGEoKXx8e30sZD1uLmV4dGVuZCghMCx7fSxkLGQub3B0aW9ucyksZC4kb3JpZz1pLGwuc3JjPW8ub3B0cy5zcmN8fGQuc3JjfHxpLmF0dHIoXCJocmVmXCIpLGwudHlwZXx8bC5zcmN8fChsLnR5cGU9XCJpbmxpbmVcIixsLnNyYz1lKSk6bD17dHlwZTpcImh0bWxcIixzcmM6ZStcIlwifSxsLm9wdHM9bi5leHRlbmQoITAse30sby5vcHRzLGQpLG4uaXNBcnJheShkLmJ1dHRvbnMpJiYobC5vcHRzLmJ1dHRvbnM9ZC5idXR0b25zKSxuLmZhbmN5Ym94LmlzTW9iaWxlJiZsLm9wdHMubW9iaWxlJiYobC5vcHRzPWgobC5vcHRzLGwub3B0cy5tb2JpbGUpKSxhPWwudHlwZXx8bC5vcHRzLnR5cGUscj1sLnNyY3x8XCJcIiwhYSYmciYmKChzPXIubWF0Y2goL1xcLihtcDR8bW92fG9ndnx3ZWJtKSgoXFw/fCMpLiopPyQvaSkpPyhhPVwidmlkZW9cIixsLm9wdHMudmlkZW8uZm9ybWF0fHwobC5vcHRzLnZpZGVvLmZvcm1hdD1cInZpZGVvL1wiKyhcIm9ndlwiPT09c1sxXT9cIm9nZ1wiOnNbMV0pKSk6ci5tYXRjaCgvKF5kYXRhOmltYWdlXFwvW2EtejAtOStcXC89XSosKXwoXFwuKGpwKGV8Z3xlZyl8Z2lmfHBuZ3xibXB8d2VicHxzdmd8aWNvKSgoXFw/fCMpLiopPyQpL2kpP2E9XCJpbWFnZVwiOnIubWF0Y2goL1xcLihwZGYpKChcXD98IykuKik/JC9pKT8oYT1cImlmcmFtZVwiLGw9bi5leHRlbmQoITAsbCx7Y29udGVudFR5cGU6XCJwZGZcIixvcHRzOntpZnJhbWU6e3ByZWxvYWQ6ITF9fX0pKTpcIiNcIj09PXIuY2hhckF0KDApJiYoYT1cImlubGluZVwiKSksYT9sLnR5cGU9YTpvLnRyaWdnZXIoXCJvYmplY3ROZWVkc1R5cGVcIixsKSxsLmNvbnRlbnRUeXBlfHwobC5jb250ZW50VHlwZT1uLmluQXJyYXkobC50eXBlLFtcImh0bWxcIixcImlubGluZVwiLFwiYWpheFwiXSk+LTE/XCJodG1sXCI6bC50eXBlKSxsLmluZGV4PW8uZ3JvdXAubGVuZ3RoLFwiYXV0b1wiPT1sLm9wdHMuc21hbGxCdG4mJihsLm9wdHMuc21hbGxCdG49bi5pbkFycmF5KGwudHlwZSxbXCJodG1sXCIsXCJpbmxpbmVcIixcImFqYXhcIl0pPi0xKSxcImF1dG9cIj09PWwub3B0cy50b29sYmFyJiYobC5vcHRzLnRvb2xiYXI9IWwub3B0cy5zbWFsbEJ0biksbC4kdGh1bWI9bC5vcHRzLiR0aHVtYnx8bnVsbCxsLm9wdHMuJHRyaWdnZXImJmwuaW5kZXg9PT1vLm9wdHMuaW5kZXgmJihsLiR0aHVtYj1sLm9wdHMuJHRyaWdnZXIuZmluZChcImltZzpmaXJzdFwiKSxsLiR0aHVtYi5sZW5ndGgmJihsLm9wdHMuJG9yaWc9bC5vcHRzLiR0cmlnZ2VyKSksbC4kdGh1bWImJmwuJHRodW1iLmxlbmd0aHx8IWwub3B0cy4kb3JpZ3x8KGwuJHRodW1iPWwub3B0cy4kb3JpZy5maW5kKFwiaW1nOmZpcnN0XCIpKSxsLiR0aHVtYiYmIWwuJHRodW1iLmxlbmd0aCYmKGwuJHRodW1iPW51bGwpLGwudGh1bWI9bC5vcHRzLnRodW1ifHwobC4kdGh1bWI/bC4kdGh1bWJbMF0uc3JjOm51bGwpLFwiZnVuY3Rpb25cIj09PW4udHlwZShsLm9wdHMuY2FwdGlvbikmJihsLm9wdHMuY2FwdGlvbj1sLm9wdHMuY2FwdGlvbi5hcHBseShlLFtvLGxdKSksXCJmdW5jdGlvblwiPT09bi50eXBlKG8ub3B0cy5jYXB0aW9uKSYmKGwub3B0cy5jYXB0aW9uPW8ub3B0cy5jYXB0aW9uLmFwcGx5KGUsW28sbF0pKSxsLm9wdHMuY2FwdGlvbiBpbnN0YW5jZW9mIG58fChsLm9wdHMuY2FwdGlvbj12b2lkIDA9PT1sLm9wdHMuY2FwdGlvbj9cIlwiOmwub3B0cy5jYXB0aW9uK1wiXCIpLFwiYWpheFwiPT09bC50eXBlJiYoYz1yLnNwbGl0KC9cXHMrLywyKSxjLmxlbmd0aD4xJiYobC5zcmM9Yy5zaGlmdCgpLGwub3B0cy5maWx0ZXI9Yy5zaGlmdCgpKSksbC5vcHRzLm1vZGFsJiYobC5vcHRzPW4uZXh0ZW5kKCEwLGwub3B0cyx7dHJhcEZvY3VzOiEwLGluZm9iYXI6MCx0b29sYmFyOjAsc21hbGxCdG46MCxrZXlib2FyZDowLHNsaWRlU2hvdzowLGZ1bGxTY3JlZW46MCx0aHVtYnM6MCx0b3VjaDowLGNsaWNrQ29udGVudDohMSxjbGlja1NsaWRlOiExLGNsaWNrT3V0c2lkZTohMSxkYmxjbGlja0NvbnRlbnQ6ITEsZGJsY2xpY2tTbGlkZTohMSxkYmxjbGlja091dHNpZGU6ITF9KSksby5ncm91cC5wdXNoKGwpfSksT2JqZWN0LmtleXMoby5zbGlkZXMpLmxlbmd0aCYmKG8udXBkYXRlQ29udHJvbHMoKSwoZT1vLlRodW1icykmJmUuaXNBY3RpdmUmJihlLmNyZWF0ZSgpLGUuZm9jdXMoKSkpfSxhZGRFdmVudHM6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2UucmVtb3ZlRXZlbnRzKCksZS4kcmVmcy5jb250YWluZXIub24oXCJjbGljay5mYi1jbG9zZVwiLFwiW2RhdGEtZmFuY3lib3gtY2xvc2VdXCIsZnVuY3Rpb24odCl7dC5zdG9wUHJvcGFnYXRpb24oKSx0LnByZXZlbnREZWZhdWx0KCksZS5jbG9zZSh0KX0pLm9uKFwidG91Y2hzdGFydC5mYi1wcmV2IGNsaWNrLmZiLXByZXZcIixcIltkYXRhLWZhbmN5Ym94LXByZXZdXCIsZnVuY3Rpb24odCl7dC5zdG9wUHJvcGFnYXRpb24oKSx0LnByZXZlbnREZWZhdWx0KCksZS5wcmV2aW91cygpfSkub24oXCJ0b3VjaHN0YXJ0LmZiLW5leHQgY2xpY2suZmItbmV4dFwiLFwiW2RhdGEtZmFuY3lib3gtbmV4dF1cIixmdW5jdGlvbih0KXt0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSxlLm5leHQoKX0pLm9uKFwiY2xpY2suZmJcIixcIltkYXRhLWZhbmN5Ym94LXpvb21dXCIsZnVuY3Rpb24odCl7ZVtlLmlzU2NhbGVkRG93bigpP1wic2NhbGVUb0FjdHVhbFwiOlwic2NhbGVUb0ZpdFwiXSgpfSkscy5vbihcIm9yaWVudGF0aW9uY2hhbmdlLmZiIHJlc2l6ZS5mYlwiLGZ1bmN0aW9uKHQpe3QmJnQub3JpZ2luYWxFdmVudCYmXCJyZXNpemVcIj09PXQub3JpZ2luYWxFdmVudC50eXBlPyhlLnJlcXVlc3RJZCYmdShlLnJlcXVlc3RJZCksZS5yZXF1ZXN0SWQ9ZChmdW5jdGlvbigpe2UudXBkYXRlKHQpfSkpOihlLmN1cnJlbnQmJlwiaWZyYW1lXCI9PT1lLmN1cnJlbnQudHlwZSYmZS4kcmVmcy5zdGFnZS5oaWRlKCksc2V0VGltZW91dChmdW5jdGlvbigpe2UuJHJlZnMuc3RhZ2Uuc2hvdygpLGUudXBkYXRlKHQpfSxuLmZhbmN5Ym94LmlzTW9iaWxlPzYwMDoyNTApKX0pLHIub24oXCJrZXlkb3duLmZiXCIsZnVuY3Rpb24odCl7dmFyIG89bi5mYW5jeWJveD9uLmZhbmN5Ym94LmdldEluc3RhbmNlKCk6bnVsbCxpPW8uY3VycmVudCxhPXQua2V5Q29kZXx8dC53aGljaDtpZig5PT1hKXJldHVybiB2b2lkKGkub3B0cy50cmFwRm9jdXMmJmUuZm9jdXModCkpO2lmKCEoIWkub3B0cy5rZXlib2FyZHx8dC5jdHJsS2V5fHx0LmFsdEtleXx8dC5zaGlmdEtleXx8bih0LnRhcmdldCkuaXMoXCJpbnB1dCx0ZXh0YXJlYSx2aWRlbyxhdWRpbyxzZWxlY3RcIikpKXJldHVybiA4PT09YXx8Mjc9PT1hPyh0LnByZXZlbnREZWZhdWx0KCksdm9pZCBlLmNsb3NlKHQpKTozNz09PWF8fDM4PT09YT8odC5wcmV2ZW50RGVmYXVsdCgpLHZvaWQgZS5wcmV2aW91cygpKTozOT09PWF8fDQwPT09YT8odC5wcmV2ZW50RGVmYXVsdCgpLHZvaWQgZS5uZXh0KCkpOnZvaWQgZS50cmlnZ2VyKFwiYWZ0ZXJLZXlkb3duXCIsdCxhKX0pLGUuZ3JvdXBbZS5jdXJySW5kZXhdLm9wdHMuaWRsZVRpbWUmJihlLmlkbGVTZWNvbmRzQ291bnRlcj0wLHIub24oXCJtb3VzZW1vdmUuZmItaWRsZSBtb3VzZWxlYXZlLmZiLWlkbGUgbW91c2Vkb3duLmZiLWlkbGUgdG91Y2hzdGFydC5mYi1pZGxlIHRvdWNobW92ZS5mYi1pZGxlIHNjcm9sbC5mYi1pZGxlIGtleWRvd24uZmItaWRsZVwiLGZ1bmN0aW9uKHQpe2UuaWRsZVNlY29uZHNDb3VudGVyPTAsZS5pc0lkbGUmJmUuc2hvd0NvbnRyb2xzKCksZS5pc0lkbGU9ITF9KSxlLmlkbGVJbnRlcnZhbD10LnNldEludGVydmFsKGZ1bmN0aW9uKCl7KytlLmlkbGVTZWNvbmRzQ291bnRlcj49ZS5ncm91cFtlLmN1cnJJbmRleF0ub3B0cy5pZGxlVGltZSYmIWUuaXNEcmFnZ2luZyYmKGUuaXNJZGxlPSEwLGUuaWRsZVNlY29uZHNDb3VudGVyPTAsZS5oaWRlQ29udHJvbHMoKSl9LDFlMykpfSxyZW1vdmVFdmVudHM6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3Mub2ZmKFwib3JpZW50YXRpb25jaGFuZ2UuZmIgcmVzaXplLmZiXCIpLHIub2ZmKFwia2V5ZG93bi5mYiAuZmItaWRsZVwiKSx0aGlzLiRyZWZzLmNvbnRhaW5lci5vZmYoXCIuZmItY2xvc2UgLmZiLXByZXYgLmZiLW5leHRcIiksZS5pZGxlSW50ZXJ2YWwmJih0LmNsZWFySW50ZXJ2YWwoZS5pZGxlSW50ZXJ2YWwpLGUuaWRsZUludGVydmFsPW51bGwpfSxwcmV2aW91czpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5qdW1wVG8odGhpcy5jdXJyUG9zLTEsdCl9LG5leHQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuanVtcFRvKHRoaXMuY3VyclBvcysxLHQpfSxqdW1wVG86ZnVuY3Rpb24odCxlKXt2YXIgbyxpLGEscyxyLGMsbCxkLHUsZj10aGlzLGg9Zi5ncm91cC5sZW5ndGg7aWYoIShmLmlzRHJhZ2dpbmd8fGYuaXNDbG9zaW5nfHxmLmlzQW5pbWF0aW5nJiZmLmZpcnN0UnVuKSl7aWYodD1wYXJzZUludCh0LDEwKSwhKGE9Zi5jdXJyZW50P2YuY3VycmVudC5vcHRzLmxvb3A6Zi5vcHRzLmxvb3ApJiYodDwwfHx0Pj1oKSlyZXR1cm4hMTtpZihvPWYuZmlyc3RSdW49IU9iamVjdC5rZXlzKGYuc2xpZGVzKS5sZW5ndGgscj1mLmN1cnJlbnQsZi5wcmV2SW5kZXg9Zi5jdXJySW5kZXgsZi5wcmV2UG9zPWYuY3VyclBvcyxzPWYuY3JlYXRlU2xpZGUodCksaD4xJiYoKGF8fHMuaW5kZXg8aC0xKSYmZi5jcmVhdGVTbGlkZSh0KzEpLChhfHxzLmluZGV4PjApJiZmLmNyZWF0ZVNsaWRlKHQtMSkpLGYuY3VycmVudD1zLGYuY3VyckluZGV4PXMuaW5kZXgsZi5jdXJyUG9zPXMucG9zLGYudHJpZ2dlcihcImJlZm9yZVNob3dcIixvKSxmLnVwZGF0ZUNvbnRyb2xzKCkscy5mb3JjZWREdXJhdGlvbj12b2lkIDAsbi5pc051bWVyaWMoZSk/cy5mb3JjZWREdXJhdGlvbj1lOmU9cy5vcHRzW28/XCJhbmltYXRpb25EdXJhdGlvblwiOlwidHJhbnNpdGlvbkR1cmF0aW9uXCJdLGU9cGFyc2VJbnQoZSwxMCksaT1mLmlzTW92ZWQocykscy4kc2xpZGUuYWRkQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tY3VycmVudFwiKSxvKXJldHVybiBzLm9wdHMuYW5pbWF0aW9uRWZmZWN0JiZlJiZmLiRyZWZzLmNvbnRhaW5lci5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsZStcIm1zXCIpLGYuJHJlZnMuY29udGFpbmVyLmFkZENsYXNzKFwiZmFuY3lib3gtaXMtb3BlblwiKS50cmlnZ2VyKFwiZm9jdXNcIiksZi5sb2FkU2xpZGUocyksdm9pZCBmLnByZWxvYWQoXCJpbWFnZVwiKTtjPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKHIuJHNsaWRlKSxsPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKGYuJHJlZnMuc3RhZ2UpLG4uZWFjaChmLnNsaWRlcyxmdW5jdGlvbih0LGUpe24uZmFuY3lib3guc3RvcChlLiRzbGlkZSwhMCl9KSxyLnBvcyE9PXMucG9zJiYoci5pc0NvbXBsZXRlPSExKSxyLiRzbGlkZS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1jb21wbGV0ZSBmYW5jeWJveC1zbGlkZS0tY3VycmVudFwiKSxpPyh1PWMubGVmdC0oci5wb3MqYy53aWR0aCtyLnBvcypyLm9wdHMuZ3V0dGVyKSxuLmVhY2goZi5zbGlkZXMsZnVuY3Rpb24odCxvKXtvLiRzbGlkZS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWFuaW1hdGVkXCIpLnJlbW92ZUNsYXNzKGZ1bmN0aW9uKHQsZSl7cmV0dXJuKGUubWF0Y2goLyhefFxccylmYW5jeWJveC1meC1cXFMrL2cpfHxbXSkuam9pbihcIiBcIil9KTt2YXIgaT1vLnBvcypjLndpZHRoK28ucG9zKm8ub3B0cy5ndXR0ZXI7bi5mYW5jeWJveC5zZXRUcmFuc2xhdGUoby4kc2xpZGUse3RvcDowLGxlZnQ6aS1sLmxlZnQrdX0pLG8ucG9zIT09cy5wb3MmJm8uJHNsaWRlLmFkZENsYXNzKFwiZmFuY3lib3gtc2xpZGUtLVwiKyhvLnBvcz5zLnBvcz9cIm5leHRcIjpcInByZXZpb3VzXCIpKSxwKG8uJHNsaWRlKSxuLmZhbmN5Ym94LmFuaW1hdGUoby4kc2xpZGUse3RvcDowLGxlZnQ6KG8ucG9zLXMucG9zKSpjLndpZHRoKyhvLnBvcy1zLnBvcykqby5vcHRzLmd1dHRlcn0sZSxmdW5jdGlvbigpe28uJHNsaWRlLmNzcyh7dHJhbnNmb3JtOlwiXCIsb3BhY2l0eTpcIlwifSkucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tbmV4dCBmYW5jeWJveC1zbGlkZS0tcHJldmlvdXNcIiksby5wb3M9PT1mLmN1cnJQb3MmJmYuY29tcGxldGUoKX0pfSkpOmUmJnMub3B0cy50cmFuc2l0aW9uRWZmZWN0JiYoZD1cImZhbmN5Ym94LWFuaW1hdGVkIGZhbmN5Ym94LWZ4LVwiK3Mub3B0cy50cmFuc2l0aW9uRWZmZWN0LHIuJHNsaWRlLmFkZENsYXNzKFwiZmFuY3lib3gtc2xpZGUtLVwiKyhyLnBvcz5zLnBvcz9cIm5leHRcIjpcInByZXZpb3VzXCIpKSxuLmZhbmN5Ym94LmFuaW1hdGUoci4kc2xpZGUsZCxlLGZ1bmN0aW9uKCl7ci4kc2xpZGUucmVtb3ZlQ2xhc3MoZCkucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tbmV4dCBmYW5jeWJveC1zbGlkZS0tcHJldmlvdXNcIil9LCExKSkscy5pc0xvYWRlZD9mLnJldmVhbENvbnRlbnQocyk6Zi5sb2FkU2xpZGUocyksZi5wcmVsb2FkKFwiaW1hZ2VcIil9fSxjcmVhdGVTbGlkZTpmdW5jdGlvbih0KXt2YXIgZSxvLGk9dGhpcztyZXR1cm4gbz10JWkuZ3JvdXAubGVuZ3RoLG89bzwwP2kuZ3JvdXAubGVuZ3RoK286bywhaS5zbGlkZXNbdF0mJmkuZ3JvdXBbb10mJihlPW4oJzxkaXYgY2xhc3M9XCJmYW5jeWJveC1zbGlkZVwiPjwvZGl2PicpLmFwcGVuZFRvKGkuJHJlZnMuc3RhZ2UpLGkuc2xpZGVzW3RdPW4uZXh0ZW5kKCEwLHt9LGkuZ3JvdXBbb10se3Bvczp0LCRzbGlkZTplLGlzTG9hZGVkOiExfSksaS51cGRhdGVTbGlkZShpLnNsaWRlc1t0XSkpLGkuc2xpZGVzW3RdfSxzY2FsZVRvQWN0dWFsOmZ1bmN0aW9uKHQsZSxvKXt2YXIgaSxhLHMscixjLGw9dGhpcyxkPWwuY3VycmVudCx1PWQuJGNvbnRlbnQsZj1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShkLiRzbGlkZSkud2lkdGgscD1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShkLiRzbGlkZSkuaGVpZ2h0LGg9ZC53aWR0aCxnPWQuaGVpZ2h0O2wuaXNBbmltYXRpbmd8fGwuaXNNb3ZlZCgpfHwhdXx8XCJpbWFnZVwiIT1kLnR5cGV8fCFkLmlzTG9hZGVkfHxkLmhhc0Vycm9yfHwobC5pc0FuaW1hdGluZz0hMCxuLmZhbmN5Ym94LnN0b3AodSksdD12b2lkIDA9PT10Py41KmY6dCxlPXZvaWQgMD09PWU/LjUqcDplLGk9bi5mYW5jeWJveC5nZXRUcmFuc2xhdGUodSksaS50b3AtPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKGQuJHNsaWRlKS50b3AsaS5sZWZ0LT1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShkLiRzbGlkZSkubGVmdCxyPWgvaS53aWR0aCxjPWcvaS5oZWlnaHQsYT0uNSpmLS41Kmgscz0uNSpwLS41KmcsaD5mJiYoYT1pLmxlZnQqci0odCpyLXQpLGE+MCYmKGE9MCksYTxmLWgmJihhPWYtaCkpLGc+cCYmKHM9aS50b3AqYy0oZSpjLWUpLHM+MCYmKHM9MCksczxwLWcmJihzPXAtZykpLGwudXBkYXRlQ3Vyc29yKGgsZyksbi5mYW5jeWJveC5hbmltYXRlKHUse3RvcDpzLGxlZnQ6YSxzY2FsZVg6cixzY2FsZVk6Y30sb3x8MzY2LGZ1bmN0aW9uKCl7bC5pc0FuaW1hdGluZz0hMX0pLGwuU2xpZGVTaG93JiZsLlNsaWRlU2hvdy5pc0FjdGl2ZSYmbC5TbGlkZVNob3cuc3RvcCgpKX0sc2NhbGVUb0ZpdDpmdW5jdGlvbih0KXt2YXIgZSxvPXRoaXMsaT1vLmN1cnJlbnQsYT1pLiRjb250ZW50O28uaXNBbmltYXRpbmd8fG8uaXNNb3ZlZCgpfHwhYXx8XCJpbWFnZVwiIT1pLnR5cGV8fCFpLmlzTG9hZGVkfHxpLmhhc0Vycm9yfHwoby5pc0FuaW1hdGluZz0hMCxuLmZhbmN5Ym94LnN0b3AoYSksZT1vLmdldEZpdFBvcyhpKSxvLnVwZGF0ZUN1cnNvcihlLndpZHRoLGUuaGVpZ2h0KSxuLmZhbmN5Ym94LmFuaW1hdGUoYSx7dG9wOmUudG9wLGxlZnQ6ZS5sZWZ0LHNjYWxlWDplLndpZHRoL2Eud2lkdGgoKSxzY2FsZVk6ZS5oZWlnaHQvYS5oZWlnaHQoKX0sdHx8MzY2LGZ1bmN0aW9uKCl7by5pc0FuaW1hdGluZz0hMX0pKX0sZ2V0Rml0UG9zOmZ1bmN0aW9uKHQpe3ZhciBlLG8saSxhLHM9dGhpcyxyPXQuJGNvbnRlbnQsYz10LiRzbGlkZSxsPXQud2lkdGh8fHQub3B0cy53aWR0aCxkPXQuaGVpZ2h0fHx0Lm9wdHMuaGVpZ2h0LHU9e307cmV0dXJuISEodC5pc0xvYWRlZCYmciYmci5sZW5ndGgpJiYoZT1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShzLiRyZWZzLnN0YWdlKS53aWR0aCxvPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKHMuJHJlZnMuc3RhZ2UpLmhlaWdodCxlLT1wYXJzZUZsb2F0KGMuY3NzKFwicGFkZGluZ0xlZnRcIikpK3BhcnNlRmxvYXQoYy5jc3MoXCJwYWRkaW5nUmlnaHRcIikpK3BhcnNlRmxvYXQoci5jc3MoXCJtYXJnaW5MZWZ0XCIpKStwYXJzZUZsb2F0KHIuY3NzKFwibWFyZ2luUmlnaHRcIikpLG8tPXBhcnNlRmxvYXQoYy5jc3MoXCJwYWRkaW5nVG9wXCIpKStwYXJzZUZsb2F0KGMuY3NzKFwicGFkZGluZ0JvdHRvbVwiKSkrcGFyc2VGbG9hdChyLmNzcyhcIm1hcmdpblRvcFwiKSkrcGFyc2VGbG9hdChyLmNzcyhcIm1hcmdpbkJvdHRvbVwiKSksbCYmZHx8KGw9ZSxkPW8pLGk9TWF0aC5taW4oMSxlL2wsby9kKSxsKj1pLGQqPWksbD5lLS41JiYobD1lKSxkPm8tLjUmJihkPW8pLFwiaW1hZ2VcIj09PXQudHlwZT8odS50b3A9TWF0aC5mbG9vciguNSooby1kKSkrcGFyc2VGbG9hdChjLmNzcyhcInBhZGRpbmdUb3BcIikpLHUubGVmdD1NYXRoLmZsb29yKC41KihlLWwpKStwYXJzZUZsb2F0KGMuY3NzKFwicGFkZGluZ0xlZnRcIikpKTpcInZpZGVvXCI9PT10LmNvbnRlbnRUeXBlJiYoYT10Lm9wdHMud2lkdGgmJnQub3B0cy5oZWlnaHQ/bC9kOnQub3B0cy5yYXRpb3x8MTYvOSxkPmwvYT9kPWwvYTpsPmQqYSYmKGw9ZCphKSksdS53aWR0aD1sLHUuaGVpZ2h0PWQsdSl9LHVwZGF0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO24uZWFjaChlLnNsaWRlcyxmdW5jdGlvbihuLG8pe2UudXBkYXRlU2xpZGUobyx0KX0pfSx1cGRhdGVTbGlkZTpmdW5jdGlvbih0LGUpe3ZhciBvPXRoaXMsaT10JiZ0LiRjb250ZW50LGE9dC53aWR0aHx8dC5vcHRzLndpZHRoLHM9dC5oZWlnaHR8fHQub3B0cy5oZWlnaHQscj10LiRzbGlkZTtvLmFkanVzdENhcHRpb24odCksaSYmKGF8fHN8fFwidmlkZW9cIj09PXQuY29udGVudFR5cGUpJiYhdC5oYXNFcnJvciYmKG4uZmFuY3lib3guc3RvcChpKSxuLmZhbmN5Ym94LnNldFRyYW5zbGF0ZShpLG8uZ2V0Rml0UG9zKHQpKSx0LnBvcz09PW8uY3VyclBvcyYmKG8uaXNBbmltYXRpbmc9ITEsby51cGRhdGVDdXJzb3IoKSkpLG8uYWRqdXN0TGF5b3V0KHQpLHIubGVuZ3RoJiYoci50cmlnZ2VyKFwicmVmcmVzaFwiKSx0LnBvcz09PW8uY3VyclBvcyYmby4kcmVmcy50b29sYmFyLmFkZChvLiRyZWZzLm5hdmlnYXRpb24uZmluZChcIi5mYW5jeWJveC1idXR0b24tLWFycm93X3JpZ2h0XCIpKS50b2dnbGVDbGFzcyhcImNvbXBlbnNhdGUtZm9yLXNjcm9sbGJhclwiLHIuZ2V0KDApLnNjcm9sbEhlaWdodD5yLmdldCgwKS5jbGllbnRIZWlnaHQpKSxvLnRyaWdnZXIoXCJvblVwZGF0ZVwiLHQsZSl9LGNlbnRlclNsaWRlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbz1lLmN1cnJlbnQsaT1vLiRzbGlkZTshZS5pc0Nsb3NpbmcmJm8mJihpLnNpYmxpbmdzKCkuY3NzKHt0cmFuc2Zvcm06XCJcIixvcGFjaXR5OlwiXCJ9KSxpLnBhcmVudCgpLmNoaWxkcmVuKCkucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tcHJldmlvdXMgZmFuY3lib3gtc2xpZGUtLW5leHRcIiksbi5mYW5jeWJveC5hbmltYXRlKGkse3RvcDowLGxlZnQ6MCxvcGFjaXR5OjF9LHZvaWQgMD09PXQ/MDp0LGZ1bmN0aW9uKCl7aS5jc3Moe3RyYW5zZm9ybTpcIlwiLG9wYWNpdHk6XCJcIn0pLG8uaXNDb21wbGV0ZXx8ZS5jb21wbGV0ZSgpfSwhMSkpfSxpc01vdmVkOmZ1bmN0aW9uKHQpe3ZhciBlLG8saT10fHx0aGlzLmN1cnJlbnQ7cmV0dXJuISFpJiYobz1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZSh0aGlzLiRyZWZzLnN0YWdlKSxlPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKGkuJHNsaWRlKSwhaS4kc2xpZGUuaGFzQ2xhc3MoXCJmYW5jeWJveC1hbmltYXRlZFwiKSYmKE1hdGguYWJzKGUudG9wLW8udG9wKT4uNXx8TWF0aC5hYnMoZS5sZWZ0LW8ubGVmdCk+LjUpKX0sdXBkYXRlQ3Vyc29yOmZ1bmN0aW9uKHQsZSl7dmFyIG8saSxhPXRoaXMscz1hLmN1cnJlbnQscj1hLiRyZWZzLmNvbnRhaW5lcjtzJiYhYS5pc0Nsb3NpbmcmJmEuR3Vlc3R1cmVzJiYoci5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWlzLXpvb21hYmxlIGZhbmN5Ym94LWNhbi16b29tSW4gZmFuY3lib3gtY2FuLXpvb21PdXQgZmFuY3lib3gtY2FuLXN3aXBlIGZhbmN5Ym94LWNhbi1wYW5cIiksbz1hLmNhblBhbih0LGUpLGk9ISFvfHxhLmlzWm9vbWFibGUoKSxyLnRvZ2dsZUNsYXNzKFwiZmFuY3lib3gtaXMtem9vbWFibGVcIixpKSxuKFwiW2RhdGEtZmFuY3lib3gtem9vbV1cIikucHJvcChcImRpc2FibGVkXCIsIWkpLG8/ci5hZGRDbGFzcyhcImZhbmN5Ym94LWNhbi1wYW5cIik6aSYmKFwiem9vbVwiPT09cy5vcHRzLmNsaWNrQ29udGVudHx8bi5pc0Z1bmN0aW9uKHMub3B0cy5jbGlja0NvbnRlbnQpJiZcInpvb21cIj09cy5vcHRzLmNsaWNrQ29udGVudChzKSk/ci5hZGRDbGFzcyhcImZhbmN5Ym94LWNhbi16b29tSW5cIik6cy5vcHRzLnRvdWNoJiYocy5vcHRzLnRvdWNoLnZlcnRpY2FsfHxhLmdyb3VwLmxlbmd0aD4xKSYmXCJ2aWRlb1wiIT09cy5jb250ZW50VHlwZSYmci5hZGRDbGFzcyhcImZhbmN5Ym94LWNhbi1zd2lwZVwiKSl9LGlzWm9vbWFibGU6ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXMsbj1lLmN1cnJlbnQ7aWYobiYmIWUuaXNDbG9zaW5nJiZcImltYWdlXCI9PT1uLnR5cGUmJiFuLmhhc0Vycm9yKXtpZighbi5pc0xvYWRlZClyZXR1cm4hMDtpZigodD1lLmdldEZpdFBvcyhuKSkmJihuLndpZHRoPnQud2lkdGh8fG4uaGVpZ2h0PnQuaGVpZ2h0KSlyZXR1cm4hMH1yZXR1cm4hMX0saXNTY2FsZWREb3duOmZ1bmN0aW9uKHQsZSl7dmFyIG89dGhpcyxpPSExLGE9by5jdXJyZW50LHM9YS4kY29udGVudDtyZXR1cm4gdm9pZCAwIT09dCYmdm9pZCAwIT09ZT9pPXQ8YS53aWR0aCYmZTxhLmhlaWdodDpzJiYoaT1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShzKSxpPWkud2lkdGg8YS53aWR0aCYmaS5oZWlnaHQ8YS5oZWlnaHQpLGl9LGNhblBhbjpmdW5jdGlvbih0LGUpe3ZhciBvPXRoaXMsaT1vLmN1cnJlbnQsYT1udWxsLHM9ITE7cmV0dXJuXCJpbWFnZVwiPT09aS50eXBlJiYoaS5pc0NvbXBsZXRlfHx0JiZlKSYmIWkuaGFzRXJyb3ImJihzPW8uZ2V0Rml0UG9zKGkpLHZvaWQgMCE9PXQmJnZvaWQgMCE9PWU/YT17d2lkdGg6dCxoZWlnaHQ6ZX06aS5pc0NvbXBsZXRlJiYoYT1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShpLiRjb250ZW50KSksYSYmcyYmKHM9TWF0aC5hYnMoYS53aWR0aC1zLndpZHRoKT4xLjV8fE1hdGguYWJzKGEuaGVpZ2h0LXMuaGVpZ2h0KT4xLjUpKSxzfSxsb2FkU2xpZGU6ZnVuY3Rpb24odCl7dmFyIGUsbyxpLGE9dGhpcztpZighdC5pc0xvYWRpbmcmJiF0LmlzTG9hZGVkKXtpZih0LmlzTG9hZGluZz0hMCwhMT09PWEudHJpZ2dlcihcImJlZm9yZUxvYWRcIix0KSlyZXR1cm4gdC5pc0xvYWRpbmc9ITEsITE7c3dpdGNoKGU9dC50eXBlLG89dC4kc2xpZGUsby5vZmYoXCJyZWZyZXNoXCIpLnRyaWdnZXIoXCJvblJlc2V0XCIpLmFkZENsYXNzKHQub3B0cy5zbGlkZUNsYXNzKSxlKXtjYXNlXCJpbWFnZVwiOmEuc2V0SW1hZ2UodCk7YnJlYWs7Y2FzZVwiaWZyYW1lXCI6YS5zZXRJZnJhbWUodCk7YnJlYWs7Y2FzZVwiaHRtbFwiOmEuc2V0Q29udGVudCh0LHQuc3JjfHx0LmNvbnRlbnQpO2JyZWFrO2Nhc2VcInZpZGVvXCI6YS5zZXRDb250ZW50KHQsdC5vcHRzLnZpZGVvLnRwbC5yZXBsYWNlKC9cXHtcXHtzcmNcXH1cXH0vZ2ksdC5zcmMpLnJlcGxhY2UoXCJ7e2Zvcm1hdH19XCIsdC5vcHRzLnZpZGVvRm9ybWF0fHx0Lm9wdHMudmlkZW8uZm9ybWF0fHxcIlwiKS5yZXBsYWNlKFwie3twb3N0ZXJ9fVwiLHQudGh1bWJ8fFwiXCIpKTticmVhaztjYXNlXCJpbmxpbmVcIjpuKHQuc3JjKS5sZW5ndGg/YS5zZXRDb250ZW50KHQsbih0LnNyYykpOmEuc2V0RXJyb3IodCk7YnJlYWs7Y2FzZVwiYWpheFwiOmEuc2hvd0xvYWRpbmcodCksaT1uLmFqYXgobi5leHRlbmQoe30sdC5vcHRzLmFqYXguc2V0dGluZ3Mse3VybDp0LnNyYyxzdWNjZXNzOmZ1bmN0aW9uKGUsbil7XCJzdWNjZXNzXCI9PT1uJiZhLnNldENvbnRlbnQodCxlKX0sZXJyb3I6ZnVuY3Rpb24oZSxuKXtlJiZcImFib3J0XCIhPT1uJiZhLnNldEVycm9yKHQpfX0pKSxvLm9uZShcIm9uUmVzZXRcIixmdW5jdGlvbigpe2kuYWJvcnQoKX0pO2JyZWFrO2RlZmF1bHQ6YS5zZXRFcnJvcih0KX1yZXR1cm4hMH19LHNldEltYWdlOmZ1bmN0aW9uKHQpe3ZhciBvLGk9dGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGU9dC4kaW1hZ2U7aS5pc0Nsb3Npbmd8fCF0LmlzTG9hZGluZ3x8ZSYmZS5sZW5ndGgmJmVbMF0uY29tcGxldGV8fHQuaGFzRXJyb3J8fGkuc2hvd0xvYWRpbmcodCl9LDUwKSxpLmNoZWNrU3Jjc2V0KHQpLHQuJGNvbnRlbnQ9bignPGRpdiBjbGFzcz1cImZhbmN5Ym94LWNvbnRlbnRcIj48L2Rpdj4nKS5hZGRDbGFzcyhcImZhbmN5Ym94LWlzLWhpZGRlblwiKS5hcHBlbmRUbyh0LiRzbGlkZS5hZGRDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1pbWFnZVwiKSksITEhPT10Lm9wdHMucHJlbG9hZCYmdC5vcHRzLndpZHRoJiZ0Lm9wdHMuaGVpZ2h0JiZ0LnRodW1iJiYodC53aWR0aD10Lm9wdHMud2lkdGgsdC5oZWlnaHQ9dC5vcHRzLmhlaWdodCxvPWUuY3JlYXRlRWxlbWVudChcImltZ1wiKSxvLm9uZXJyb3I9ZnVuY3Rpb24oKXtuKHRoaXMpLnJlbW92ZSgpLHQuJGdob3N0PW51bGx9LG8ub25sb2FkPWZ1bmN0aW9uKCl7aS5hZnRlckxvYWQodCl9LHQuJGdob3N0PW4obykuYWRkQ2xhc3MoXCJmYW5jeWJveC1pbWFnZVwiKS5hcHBlbmRUbyh0LiRjb250ZW50KS5hdHRyKFwic3JjXCIsdC50aHVtYikpLGkuc2V0QmlnSW1hZ2UodCl9LGNoZWNrU3Jjc2V0OmZ1bmN0aW9uKGUpe3ZhciBuLG8saSxhLHM9ZS5vcHRzLnNyY3NldHx8ZS5vcHRzLmltYWdlLnNyY3NldDtpZihzKXtpPXQuZGV2aWNlUGl4ZWxSYXRpb3x8MSxhPXQuaW5uZXJXaWR0aCppLG89cy5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uKHQpe3ZhciBlPXt9O3JldHVybiB0LnRyaW0oKS5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24odCxuKXt2YXIgbz1wYXJzZUludCh0LnN1YnN0cmluZygwLHQubGVuZ3RoLTEpLDEwKTtpZigwPT09bilyZXR1cm4gZS51cmw9dDtvJiYoZS52YWx1ZT1vLGUucG9zdGZpeD10W3QubGVuZ3RoLTFdKX0pLGV9KSxvLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC52YWx1ZS1lLnZhbHVlfSk7Zm9yKHZhciByPTA7cjxvLmxlbmd0aDtyKyspe3ZhciBjPW9bcl07aWYoXCJ3XCI9PT1jLnBvc3RmaXgmJmMudmFsdWU+PWF8fFwieFwiPT09Yy5wb3N0Zml4JiZjLnZhbHVlPj1pKXtuPWM7YnJlYWt9fSFuJiZvLmxlbmd0aCYmKG49b1tvLmxlbmd0aC0xXSksbiYmKGUuc3JjPW4udXJsLGUud2lkdGgmJmUuaGVpZ2h0JiZcIndcIj09bi5wb3N0Zml4JiYoZS5oZWlnaHQ9ZS53aWR0aC9lLmhlaWdodCpuLnZhbHVlLGUud2lkdGg9bi52YWx1ZSksZS5vcHRzLnNyY3NldD1zKX19LHNldEJpZ0ltYWdlOmZ1bmN0aW9uKHQpe3ZhciBvPXRoaXMsaT1lLmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiksYT1uKGkpO3QuJGltYWdlPWEub25lKFwiZXJyb3JcIixmdW5jdGlvbigpe28uc2V0RXJyb3IodCl9KS5vbmUoXCJsb2FkXCIsZnVuY3Rpb24oKXt2YXIgZTt0LiRnaG9zdHx8KG8ucmVzb2x2ZUltYWdlU2xpZGVTaXplKHQsdGhpcy5uYXR1cmFsV2lkdGgsdGhpcy5uYXR1cmFsSGVpZ2h0KSxvLmFmdGVyTG9hZCh0KSksby5pc0Nsb3Npbmd8fCh0Lm9wdHMuc3Jjc2V0JiYoZT10Lm9wdHMuc2l6ZXMsZSYmXCJhdXRvXCIhPT1lfHwoZT0odC53aWR0aC90LmhlaWdodD4xJiZzLndpZHRoKCkvcy5oZWlnaHQoKT4xP1wiMTAwXCI6TWF0aC5yb3VuZCh0LndpZHRoL3QuaGVpZ2h0KjEwMCkpK1widndcIiksYS5hdHRyKFwic2l6ZXNcIixlKS5hdHRyKFwic3Jjc2V0XCIsdC5vcHRzLnNyY3NldCkpLHQuJGdob3N0JiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC4kZ2hvc3QmJiFvLmlzQ2xvc2luZyYmdC4kZ2hvc3QuaGlkZSgpfSxNYXRoLm1pbigzMDAsTWF0aC5tYXgoMWUzLHQuaGVpZ2h0LzE2MDApKSksby5oaWRlTG9hZGluZyh0KSl9KS5hZGRDbGFzcyhcImZhbmN5Ym94LWltYWdlXCIpLmF0dHIoXCJzcmNcIix0LnNyYykuYXBwZW5kVG8odC4kY29udGVudCksKGkuY29tcGxldGV8fFwiY29tcGxldGVcIj09aS5yZWFkeVN0YXRlKSYmYS5uYXR1cmFsV2lkdGgmJmEubmF0dXJhbEhlaWdodD9hLnRyaWdnZXIoXCJsb2FkXCIpOmkuZXJyb3ImJmEudHJpZ2dlcihcImVycm9yXCIpfSxyZXNvbHZlSW1hZ2VTbGlkZVNpemU6ZnVuY3Rpb24odCxlLG4pe3ZhciBvPXBhcnNlSW50KHQub3B0cy53aWR0aCwxMCksaT1wYXJzZUludCh0Lm9wdHMuaGVpZ2h0LDEwKTt0LndpZHRoPWUsdC5oZWlnaHQ9bixvPjAmJih0LndpZHRoPW8sdC5oZWlnaHQ9TWF0aC5mbG9vcihvKm4vZSkpLGk+MCYmKHQud2lkdGg9TWF0aC5mbG9vcihpKmUvbiksdC5oZWlnaHQ9aSl9LHNldElmcmFtZTpmdW5jdGlvbih0KXt2YXIgZSxvPXRoaXMsaT10Lm9wdHMuaWZyYW1lLGE9dC4kc2xpZGU7dC4kY29udGVudD1uKCc8ZGl2IGNsYXNzPVwiZmFuY3lib3gtY29udGVudCcrKGkucHJlbG9hZD9cIiBmYW5jeWJveC1pcy1oaWRkZW5cIjpcIlwiKSsnXCI+PC9kaXY+JykuY3NzKGkuY3NzKS5hcHBlbmRUbyhhKSxhLmFkZENsYXNzKFwiZmFuY3lib3gtc2xpZGUtLVwiK3QuY29udGVudFR5cGUpLHQuJGlmcmFtZT1lPW4oaS50cGwucmVwbGFjZSgvXFx7cm5kXFx9L2csKG5ldyBEYXRlKS5nZXRUaW1lKCkpKS5hdHRyKGkuYXR0cikuYXBwZW5kVG8odC4kY29udGVudCksaS5wcmVsb2FkPyhvLnNob3dMb2FkaW5nKHQpLGUub24oXCJsb2FkLmZiIGVycm9yLmZiXCIsZnVuY3Rpb24oZSl7dGhpcy5pc1JlYWR5PTEsdC4kc2xpZGUudHJpZ2dlcihcInJlZnJlc2hcIiksby5hZnRlckxvYWQodCl9KSxhLm9uKFwicmVmcmVzaC5mYlwiLGZ1bmN0aW9uKCl7dmFyIG4sbyxzPXQuJGNvbnRlbnQscj1pLmNzcy53aWR0aCxjPWkuY3NzLmhlaWdodDtpZigxPT09ZVswXS5pc1JlYWR5KXt0cnl7bj1lLmNvbnRlbnRzKCksbz1uLmZpbmQoXCJib2R5XCIpfWNhdGNoKHQpe31vJiZvLmxlbmd0aCYmby5jaGlsZHJlbigpLmxlbmd0aCYmKGEuY3NzKFwib3ZlcmZsb3dcIixcInZpc2libGVcIikscy5jc3Moe3dpZHRoOlwiMTAwJVwiLFwibWF4LXdpZHRoXCI6XCIxMDAlXCIsaGVpZ2h0OlwiOTk5OXB4XCJ9KSx2b2lkIDA9PT1yJiYocj1NYXRoLmNlaWwoTWF0aC5tYXgob1swXS5jbGllbnRXaWR0aCxvLm91dGVyV2lkdGgoITApKSkpLHMuY3NzKFwid2lkdGhcIixyfHxcIlwiKS5jc3MoXCJtYXgtd2lkdGhcIixcIlwiKSx2b2lkIDA9PT1jJiYoYz1NYXRoLmNlaWwoTWF0aC5tYXgob1swXS5jbGllbnRIZWlnaHQsby5vdXRlckhlaWdodCghMCkpKSkscy5jc3MoXCJoZWlnaHRcIixjfHxcIlwiKSxhLmNzcyhcIm92ZXJmbG93XCIsXCJhdXRvXCIpKSxzLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtaXMtaGlkZGVuXCIpfX0pKTpvLmFmdGVyTG9hZCh0KSxlLmF0dHIoXCJzcmNcIix0LnNyYyksYS5vbmUoXCJvblJlc2V0XCIsZnVuY3Rpb24oKXt0cnl7bih0aGlzKS5maW5kKFwiaWZyYW1lXCIpLmhpZGUoKS51bmJpbmQoKS5hdHRyKFwic3JjXCIsXCIvL2Fib3V0OmJsYW5rXCIpfWNhdGNoKHQpe31uKHRoaXMpLm9mZihcInJlZnJlc2guZmJcIikuZW1wdHkoKSx0LmlzTG9hZGVkPSExLHQuaXNSZXZlYWxlZD0hMX0pfSxzZXRDb250ZW50OmZ1bmN0aW9uKHQsZSl7dmFyIG89dGhpcztvLmlzQ2xvc2luZ3x8KG8uaGlkZUxvYWRpbmcodCksdC4kY29udGVudCYmbi5mYW5jeWJveC5zdG9wKHQuJGNvbnRlbnQpLHQuJHNsaWRlLmVtcHR5KCksbChlKSYmZS5wYXJlbnQoKS5sZW5ndGg/KChlLmhhc0NsYXNzKFwiZmFuY3lib3gtY29udGVudFwiKXx8ZS5wYXJlbnQoKS5oYXNDbGFzcyhcImZhbmN5Ym94LWNvbnRlbnRcIikpJiZlLnBhcmVudHMoXCIuZmFuY3lib3gtc2xpZGVcIikudHJpZ2dlcihcIm9uUmVzZXRcIiksdC4kcGxhY2Vob2xkZXI9bihcIjxkaXY+XCIpLmhpZGUoKS5pbnNlcnRBZnRlcihlKSxlLmNzcyhcImRpc3BsYXlcIixcImlubGluZS1ibG9ja1wiKSk6dC5oYXNFcnJvcnx8KFwic3RyaW5nXCI9PT1uLnR5cGUoZSkmJihlPW4oXCI8ZGl2PlwiKS5hcHBlbmQobi50cmltKGUpKS5jb250ZW50cygpKSx0Lm9wdHMuZmlsdGVyJiYoZT1uKFwiPGRpdj5cIikuaHRtbChlKS5maW5kKHQub3B0cy5maWx0ZXIpKSksdC4kc2xpZGUub25lKFwib25SZXNldFwiLGZ1bmN0aW9uKCl7bih0aGlzKS5maW5kKFwidmlkZW8sYXVkaW9cIikudHJpZ2dlcihcInBhdXNlXCIpLHQuJHBsYWNlaG9sZGVyJiYodC4kcGxhY2Vob2xkZXIuYWZ0ZXIoZS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWNvbnRlbnRcIikuaGlkZSgpKS5yZW1vdmUoKSx0LiRwbGFjZWhvbGRlcj1udWxsKSx0LiRzbWFsbEJ0biYmKHQuJHNtYWxsQnRuLnJlbW92ZSgpLHQuJHNtYWxsQnRuPW51bGwpLHQuaGFzRXJyb3J8fChuKHRoaXMpLmVtcHR5KCksdC5pc0xvYWRlZD0hMSx0LmlzUmV2ZWFsZWQ9ITEpfSksbihlKS5hcHBlbmRUbyh0LiRzbGlkZSksbihlKS5pcyhcInZpZGVvLGF1ZGlvXCIpJiYobihlKS5hZGRDbGFzcyhcImZhbmN5Ym94LXZpZGVvXCIpLG4oZSkud3JhcChcIjxkaXY+PC9kaXY+XCIpLHQuY29udGVudFR5cGU9XCJ2aWRlb1wiLHQub3B0cy53aWR0aD10Lm9wdHMud2lkdGh8fG4oZSkuYXR0cihcIndpZHRoXCIpLHQub3B0cy5oZWlnaHQ9dC5vcHRzLmhlaWdodHx8bihlKS5hdHRyKFwiaGVpZ2h0XCIpKSx0LiRjb250ZW50PXQuJHNsaWRlLmNoaWxkcmVuKCkuZmlsdGVyKFwiZGl2LGZvcm0sbWFpbix2aWRlbyxhdWRpbyxhcnRpY2xlLC5mYW5jeWJveC1jb250ZW50XCIpLmZpcnN0KCksdC4kY29udGVudC5zaWJsaW5ncygpLmhpZGUoKSx0LiRjb250ZW50Lmxlbmd0aHx8KHQuJGNvbnRlbnQ9dC4kc2xpZGUud3JhcElubmVyKFwiPGRpdj48L2Rpdj5cIikuY2hpbGRyZW4oKS5maXJzdCgpKSx0LiRjb250ZW50LmFkZENsYXNzKFwiZmFuY3lib3gtY29udGVudFwiKSx0LiRzbGlkZS5hZGRDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1cIit0LmNvbnRlbnRUeXBlKSxvLmFmdGVyTG9hZCh0KSl9LHNldEVycm9yOmZ1bmN0aW9uKHQpe3QuaGFzRXJyb3I9ITAsdC4kc2xpZGUudHJpZ2dlcihcIm9uUmVzZXRcIikucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tXCIrdC5jb250ZW50VHlwZSkuYWRkQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tZXJyb3JcIiksdC5jb250ZW50VHlwZT1cImh0bWxcIix0aGlzLnNldENvbnRlbnQodCx0aGlzLnRyYW5zbGF0ZSh0LHQub3B0cy5lcnJvclRwbCkpLHQucG9zPT09dGhpcy5jdXJyUG9zJiYodGhpcy5pc0FuaW1hdGluZz0hMSl9LHNob3dMb2FkaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7KHQ9dHx8ZS5jdXJyZW50KSYmIXQuJHNwaW5uZXImJih0LiRzcGlubmVyPW4oZS50cmFuc2xhdGUoZSxlLm9wdHMuc3Bpbm5lclRwbCkpLmFwcGVuZFRvKHQuJHNsaWRlKS5oaWRlKCkuZmFkZUluKFwiZmFzdFwiKSl9LGhpZGVMb2FkaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7KHQ9dHx8ZS5jdXJyZW50KSYmdC4kc3Bpbm5lciYmKHQuJHNwaW5uZXIuc3RvcCgpLnJlbW92ZSgpLGRlbGV0ZSB0LiRzcGlubmVyKX0sYWZ0ZXJMb2FkOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7ZS5pc0Nsb3Npbmd8fCh0LmlzTG9hZGluZz0hMSx0LmlzTG9hZGVkPSEwLGUudHJpZ2dlcihcImFmdGVyTG9hZFwiLHQpLGUuaGlkZUxvYWRpbmcodCksIXQub3B0cy5zbWFsbEJ0bnx8dC4kc21hbGxCdG4mJnQuJHNtYWxsQnRuLmxlbmd0aHx8KHQuJHNtYWxsQnRuPW4oZS50cmFuc2xhdGUodCx0Lm9wdHMuYnRuVHBsLnNtYWxsQnRuKSkuYXBwZW5kVG8odC4kY29udGVudCkpLHQub3B0cy5wcm90ZWN0JiZ0LiRjb250ZW50JiYhdC5oYXNFcnJvciYmKHQuJGNvbnRlbnQub24oXCJjb250ZXh0bWVudS5mYlwiLGZ1bmN0aW9uKHQpe3JldHVybiAyPT10LmJ1dHRvbiYmdC5wcmV2ZW50RGVmYXVsdCgpLCEwfSksXCJpbWFnZVwiPT09dC50eXBlJiZuKCc8ZGl2IGNsYXNzPVwiZmFuY3lib3gtc3BhY2ViYWxsXCI+PC9kaXY+JykuYXBwZW5kVG8odC4kY29udGVudCkpLGUuYWRqdXN0Q2FwdGlvbih0KSxlLmFkanVzdExheW91dCh0KSx0LnBvcz09PWUuY3VyclBvcyYmZS51cGRhdGVDdXJzb3IoKSxlLnJldmVhbENvbnRlbnQodCkpfSxhZGp1c3RDYXB0aW9uOmZ1bmN0aW9uKHQpe3ZhciBlLG49dGhpcyxvPXR8fG4uY3VycmVudCxpPW8ub3B0cy5jYXB0aW9uLGE9by5vcHRzLnByZXZlbnRDYXB0aW9uT3ZlcmxhcCxzPW4uJHJlZnMuY2FwdGlvbixyPSExO3MudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1jYXB0aW9uLS1zZXBhcmF0ZVwiLGEpLGEmJmkmJmkubGVuZ3RoJiYoby5wb3MhPT1uLmN1cnJQb3M/KGU9cy5jbG9uZSgpLmFwcGVuZFRvKHMucGFyZW50KCkpLGUuY2hpbGRyZW4oKS5lcSgwKS5lbXB0eSgpLmh0bWwoaSkscj1lLm91dGVySGVpZ2h0KCEwKSxlLmVtcHR5KCkucmVtb3ZlKCkpOm4uJGNhcHRpb24mJihyPW4uJGNhcHRpb24ub3V0ZXJIZWlnaHQoITApKSxvLiRzbGlkZS5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiLHJ8fFwiXCIpKX0sYWRqdXN0TGF5b3V0OmZ1bmN0aW9uKHQpe3ZhciBlLG4sbyxpLGE9dGhpcyxzPXR8fGEuY3VycmVudDtzLmlzTG9hZGVkJiYhMCE9PXMub3B0cy5kaXNhYmxlTGF5b3V0Rml4JiYocy4kY29udGVudC5jc3MoXCJtYXJnaW4tYm90dG9tXCIsXCJcIikscy4kY29udGVudC5vdXRlckhlaWdodCgpPnMuJHNsaWRlLmhlaWdodCgpKy41JiYobz1zLiRzbGlkZVswXS5zdHlsZVtcInBhZGRpbmctYm90dG9tXCJdLGk9cy4kc2xpZGUuY3NzKFwicGFkZGluZy1ib3R0b21cIikscGFyc2VGbG9hdChpKT4wJiYoZT1zLiRzbGlkZVswXS5zY3JvbGxIZWlnaHQscy4kc2xpZGUuY3NzKFwicGFkZGluZy1ib3R0b21cIiwwKSxNYXRoLmFicyhlLXMuJHNsaWRlWzBdLnNjcm9sbEhlaWdodCk8MSYmKG49aSkscy4kc2xpZGUuY3NzKFwicGFkZGluZy1ib3R0b21cIixvKSkpLHMuJGNvbnRlbnQuY3NzKFwibWFyZ2luLWJvdHRvbVwiLG4pKX0scmV2ZWFsQ29udGVudDpmdW5jdGlvbih0KXt2YXIgZSxvLGksYSxzPXRoaXMscj10LiRzbGlkZSxjPSExLGw9ITEsZD1zLmlzTW92ZWQodCksdT10LmlzUmV2ZWFsZWQ7cmV0dXJuIHQuaXNSZXZlYWxlZD0hMCxlPXQub3B0c1tzLmZpcnN0UnVuP1wiYW5pbWF0aW9uRWZmZWN0XCI6XCJ0cmFuc2l0aW9uRWZmZWN0XCJdLGk9dC5vcHRzW3MuZmlyc3RSdW4/XCJhbmltYXRpb25EdXJhdGlvblwiOlwidHJhbnNpdGlvbkR1cmF0aW9uXCJdLGk9cGFyc2VJbnQodm9pZCAwPT09dC5mb3JjZWREdXJhdGlvbj9pOnQuZm9yY2VkRHVyYXRpb24sMTApLCFkJiZ0LnBvcz09PXMuY3VyclBvcyYmaXx8KGU9ITEpLFwiem9vbVwiPT09ZSYmKHQucG9zPT09cy5jdXJyUG9zJiZpJiZcImltYWdlXCI9PT10LnR5cGUmJiF0Lmhhc0Vycm9yJiYobD1zLmdldFRodW1iUG9zKHQpKT9jPXMuZ2V0Rml0UG9zKHQpOmU9XCJmYWRlXCIpLFwiem9vbVwiPT09ZT8ocy5pc0FuaW1hdGluZz0hMCxjLnNjYWxlWD1jLndpZHRoL2wud2lkdGgsYy5zY2FsZVk9Yy5oZWlnaHQvbC5oZWlnaHQsYT10Lm9wdHMuem9vbU9wYWNpdHksXCJhdXRvXCI9PWEmJihhPU1hdGguYWJzKHQud2lkdGgvdC5oZWlnaHQtbC53aWR0aC9sLmhlaWdodCk+LjEpLGEmJihsLm9wYWNpdHk9LjEsYy5vcGFjaXR5PTEpLG4uZmFuY3lib3guc2V0VHJhbnNsYXRlKHQuJGNvbnRlbnQucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1pcy1oaWRkZW5cIiksbCkscCh0LiRjb250ZW50KSx2b2lkIG4uZmFuY3lib3guYW5pbWF0ZSh0LiRjb250ZW50LGMsaSxmdW5jdGlvbigpe3MuaXNBbmltYXRpbmc9ITEscy5jb21wbGV0ZSgpfSkpOihzLnVwZGF0ZVNsaWRlKHQpLGU/KG4uZmFuY3lib3guc3RvcChyKSxvPVwiZmFuY3lib3gtc2xpZGUtLVwiKyh0LnBvcz49cy5wcmV2UG9zP1wibmV4dFwiOlwicHJldmlvdXNcIikrXCIgZmFuY3lib3gtYW5pbWF0ZWQgZmFuY3lib3gtZngtXCIrZSxyLmFkZENsYXNzKG8pLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtc2xpZGUtLWN1cnJlbnRcIiksdC4kY29udGVudC5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWlzLWhpZGRlblwiKSxwKHIpLFwiaW1hZ2VcIiE9PXQudHlwZSYmdC4kY29udGVudC5oaWRlKCkuc2hvdygwKSx2b2lkIG4uZmFuY3lib3guYW5pbWF0ZShyLFwiZmFuY3lib3gtc2xpZGUtLWN1cnJlbnRcIixpLGZ1bmN0aW9uKCl7ci5yZW1vdmVDbGFzcyhvKS5jc3Moe3RyYW5zZm9ybTpcIlwiLG9wYWNpdHk6XCJcIn0pLHQucG9zPT09cy5jdXJyUG9zJiZzLmNvbXBsZXRlKCl9LCEwKSk6KHQuJGNvbnRlbnQucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1pcy1oaWRkZW5cIiksdXx8IWR8fFwiaW1hZ2VcIiE9PXQudHlwZXx8dC5oYXNFcnJvcnx8dC4kY29udGVudC5oaWRlKCkuZmFkZUluKFwiZmFzdFwiKSx2b2lkKHQucG9zPT09cy5jdXJyUG9zJiZzLmNvbXBsZXRlKCkpKSl9LGdldFRodW1iUG9zOmZ1bmN0aW9uKHQpe3ZhciBlLG8saSxhLHMscj0hMSxjPXQuJHRodW1iO3JldHVybiEoIWN8fCFnKGNbMF0pKSYmKGU9bi5mYW5jeWJveC5nZXRUcmFuc2xhdGUoYyksbz1wYXJzZUZsb2F0KGMuY3NzKFwiYm9yZGVyLXRvcC13aWR0aFwiKXx8MCksaT1wYXJzZUZsb2F0KGMuY3NzKFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCIpfHwwKSxhPXBhcnNlRmxvYXQoYy5jc3MoXCJib3JkZXItYm90dG9tLXdpZHRoXCIpfHwwKSxzPXBhcnNlRmxvYXQoYy5jc3MoXCJib3JkZXItbGVmdC13aWR0aFwiKXx8MCkscj17dG9wOmUudG9wK28sbGVmdDplLmxlZnQrcyx3aWR0aDplLndpZHRoLWktcyxoZWlnaHQ6ZS5oZWlnaHQtby1hLHNjYWxlWDoxLHNjYWxlWToxfSxlLndpZHRoPjAmJmUuaGVpZ2h0PjAmJnIpfSxjb21wbGV0ZTpmdW5jdGlvbigpe3ZhciB0LGU9dGhpcyxvPWUuY3VycmVudCxpPXt9OyFlLmlzTW92ZWQoKSYmby5pc0xvYWRlZCYmKG8uaXNDb21wbGV0ZXx8KG8uaXNDb21wbGV0ZT0hMCxvLiRzbGlkZS5zaWJsaW5ncygpLnRyaWdnZXIoXCJvblJlc2V0XCIpLGUucHJlbG9hZChcImlubGluZVwiKSxwKG8uJHNsaWRlKSxvLiRzbGlkZS5hZGRDbGFzcyhcImZhbmN5Ym94LXNsaWRlLS1jb21wbGV0ZVwiKSxuLmVhY2goZS5zbGlkZXMsZnVuY3Rpb24odCxvKXtvLnBvcz49ZS5jdXJyUG9zLTEmJm8ucG9zPD1lLmN1cnJQb3MrMT9pW28ucG9zXT1vOm8mJihuLmZhbmN5Ym94LnN0b3Aoby4kc2xpZGUpLG8uJHNsaWRlLm9mZigpLnJlbW92ZSgpKX0pLGUuc2xpZGVzPWkpLGUuaXNBbmltYXRpbmc9ITEsZS51cGRhdGVDdXJzb3IoKSxlLnRyaWdnZXIoXCJhZnRlclNob3dcIiksby5vcHRzLnZpZGVvLmF1dG9TdGFydCYmby4kc2xpZGUuZmluZChcInZpZGVvLGF1ZGlvXCIpLmZpbHRlcihcIjp2aXNpYmxlOmZpcnN0XCIpLnRyaWdnZXIoXCJwbGF5XCIpLm9uZShcImVuZGVkXCIsZnVuY3Rpb24oKXtEb2N1bWVudC5leGl0RnVsbHNjcmVlbj9Eb2N1bWVudC5leGl0RnVsbHNjcmVlbigpOnRoaXMud2Via2l0RXhpdEZ1bGxzY3JlZW4mJnRoaXMud2Via2l0RXhpdEZ1bGxzY3JlZW4oKSxlLm5leHQoKX0pLG8ub3B0cy5hdXRvRm9jdXMmJlwiaHRtbFwiPT09by5jb250ZW50VHlwZSYmKHQ9by4kY29udGVudC5maW5kKFwiaW5wdXRbYXV0b2ZvY3VzXTplbmFibGVkOnZpc2libGU6Zmlyc3RcIiksdC5sZW5ndGg/dC50cmlnZ2VyKFwiZm9jdXNcIik6ZS5mb2N1cyhudWxsLCEwKSksby4kc2xpZGUuc2Nyb2xsVG9wKDApLnNjcm9sbExlZnQoMCkpfSxwcmVsb2FkOmZ1bmN0aW9uKHQpe3ZhciBlLG4sbz10aGlzO28uZ3JvdXAubGVuZ3RoPDJ8fChuPW8uc2xpZGVzW28uY3VyclBvcysxXSxlPW8uc2xpZGVzW28uY3VyclBvcy0xXSxlJiZlLnR5cGU9PT10JiZvLmxvYWRTbGlkZShlKSxuJiZuLnR5cGU9PT10JiZvLmxvYWRTbGlkZShuKSl9LGZvY3VzOmZ1bmN0aW9uKHQsbyl7dmFyIGksYSxzPXRoaXMscj1bXCJhW2hyZWZdXCIsXCJhcmVhW2hyZWZdXCIsJ2lucHV0Om5vdChbZGlzYWJsZWRdKTpub3QoW3R5cGU9XCJoaWRkZW5cIl0pOm5vdChbYXJpYS1oaWRkZW5dKScsXCJzZWxlY3Q6bm90KFtkaXNhYmxlZF0pOm5vdChbYXJpYS1oaWRkZW5dKVwiLFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pOm5vdChbYXJpYS1oaWRkZW5dKVwiLFwiYnV0dG9uOm5vdChbZGlzYWJsZWRdKTpub3QoW2FyaWEtaGlkZGVuXSlcIixcImlmcmFtZVwiLFwib2JqZWN0XCIsXCJlbWJlZFwiLFwidmlkZW9cIixcImF1ZGlvXCIsXCJbY29udGVudGVkaXRhYmxlXVwiLCdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXhePVwiLVwiXSknXS5qb2luKFwiLFwiKTtzLmlzQ2xvc2luZ3x8KGk9IXQmJnMuY3VycmVudCYmcy5jdXJyZW50LmlzQ29tcGxldGU/cy5jdXJyZW50LiRzbGlkZS5maW5kKFwiKjp2aXNpYmxlXCIrKG8/XCI6bm90KC5mYW5jeWJveC1jbG9zZS1zbWFsbClcIjpcIlwiKSk6cy4kcmVmcy5jb250YWluZXIuZmluZChcIio6dmlzaWJsZVwiKSxpPWkuZmlsdGVyKHIpLmZpbHRlcihmdW5jdGlvbigpe3JldHVyblwiaGlkZGVuXCIhPT1uKHRoaXMpLmNzcyhcInZpc2liaWxpdHlcIikmJiFuKHRoaXMpLmhhc0NsYXNzKFwiZGlzYWJsZWRcIil9KSxpLmxlbmd0aD8oYT1pLmluZGV4KGUuYWN0aXZlRWxlbWVudCksdCYmdC5zaGlmdEtleT8oYTwwfHwwPT1hKSYmKHQucHJldmVudERlZmF1bHQoKSxpLmVxKGkubGVuZ3RoLTEpLnRyaWdnZXIoXCJmb2N1c1wiKSk6KGE8MHx8YT09aS5sZW5ndGgtMSkmJih0JiZ0LnByZXZlbnREZWZhdWx0KCksaS5lcSgwKS50cmlnZ2VyKFwiZm9jdXNcIikpKTpzLiRyZWZzLmNvbnRhaW5lci50cmlnZ2VyKFwiZm9jdXNcIikpfSxhY3RpdmF0ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7bihcIi5mYW5jeWJveC1jb250YWluZXJcIikuZWFjaChmdW5jdGlvbigpe3ZhciBlPW4odGhpcykuZGF0YShcIkZhbmN5Qm94XCIpO2UmJmUuaWQhPT10LmlkJiYhZS5pc0Nsb3NpbmcmJihlLnRyaWdnZXIoXCJvbkRlYWN0aXZhdGVcIiksZS5yZW1vdmVFdmVudHMoKSxlLmlzVmlzaWJsZT0hMSl9KSx0LmlzVmlzaWJsZT0hMCwodC5jdXJyZW50fHx0LmlzSWRsZSkmJih0LnVwZGF0ZSgpLHQudXBkYXRlQ29udHJvbHMoKSksdC50cmlnZ2VyKFwib25BY3RpdmF0ZVwiKSx0LmFkZEV2ZW50cygpfSxjbG9zZTpmdW5jdGlvbih0LGUpe3ZhciBvLGksYSxzLHIsYyxsLHU9dGhpcyxmPXUuY3VycmVudCxoPWZ1bmN0aW9uKCl7dS5jbGVhblVwKHQpfTtyZXR1cm4hdS5pc0Nsb3NpbmcmJih1LmlzQ2xvc2luZz0hMCwhMT09PXUudHJpZ2dlcihcImJlZm9yZUNsb3NlXCIsdCk/KHUuaXNDbG9zaW5nPSExLGQoZnVuY3Rpb24oKXt1LnVwZGF0ZSgpfSksITEpOih1LnJlbW92ZUV2ZW50cygpLGE9Zi4kY29udGVudCxvPWYub3B0cy5hbmltYXRpb25FZmZlY3QsaT1uLmlzTnVtZXJpYyhlKT9lOm8/Zi5vcHRzLmFuaW1hdGlvbkR1cmF0aW9uOjAsZi4kc2xpZGUucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tY29tcGxldGUgZmFuY3lib3gtc2xpZGUtLW5leHQgZmFuY3lib3gtc2xpZGUtLXByZXZpb3VzIGZhbmN5Ym94LWFuaW1hdGVkXCIpLCEwIT09dD9uLmZhbmN5Ym94LnN0b3AoZi4kc2xpZGUpOm89ITEsZi4kc2xpZGUuc2libGluZ3MoKS50cmlnZ2VyKFwib25SZXNldFwiKS5yZW1vdmUoKSxpJiZ1LiRyZWZzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LWlzLW9wZW5cIikuYWRkQ2xhc3MoXCJmYW5jeWJveC1pcy1jbG9zaW5nXCIpLmNzcyhcInRyYW5zaXRpb24tZHVyYXRpb25cIixpK1wibXNcIiksdS5oaWRlTG9hZGluZyhmKSx1LmhpZGVDb250cm9scyghMCksdS51cGRhdGVDdXJzb3IoKSxcInpvb21cIiE9PW98fGEmJmkmJlwiaW1hZ2VcIj09PWYudHlwZSYmIXUuaXNNb3ZlZCgpJiYhZi5oYXNFcnJvciYmKGw9dS5nZXRUaHVtYlBvcyhmKSl8fChvPVwiZmFkZVwiKSxcInpvb21cIj09PW8/KG4uZmFuY3lib3guc3RvcChhKSxzPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKGEpLGM9e3RvcDpzLnRvcCxsZWZ0OnMubGVmdCxzY2FsZVg6cy53aWR0aC9sLndpZHRoLHNjYWxlWTpzLmhlaWdodC9sLmhlaWdodCx3aWR0aDpsLndpZHRoLGhlaWdodDpsLmhlaWdodH0scj1mLm9wdHMuem9vbU9wYWNpdHksXG5cImF1dG9cIj09ciYmKHI9TWF0aC5hYnMoZi53aWR0aC9mLmhlaWdodC1sLndpZHRoL2wuaGVpZ2h0KT4uMSksciYmKGwub3BhY2l0eT0wKSxuLmZhbmN5Ym94LnNldFRyYW5zbGF0ZShhLGMpLHAoYSksbi5mYW5jeWJveC5hbmltYXRlKGEsbCxpLGgpLCEwKToobyYmaT9uLmZhbmN5Ym94LmFuaW1hdGUoZi4kc2xpZGUuYWRkQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tcHJldmlvdXNcIikucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1zbGlkZS0tY3VycmVudFwiKSxcImZhbmN5Ym94LWFuaW1hdGVkIGZhbmN5Ym94LWZ4LVwiK28saSxoKTohMD09PXQ/c2V0VGltZW91dChoLGkpOmgoKSwhMCkpKX0sY2xlYW5VcDpmdW5jdGlvbihlKXt2YXIgbyxpLGEscz10aGlzLHI9cy5jdXJyZW50Lm9wdHMuJG9yaWc7cy5jdXJyZW50LiRzbGlkZS50cmlnZ2VyKFwib25SZXNldFwiKSxzLiRyZWZzLmNvbnRhaW5lci5lbXB0eSgpLnJlbW92ZSgpLHMudHJpZ2dlcihcImFmdGVyQ2xvc2VcIixlKSxzLmN1cnJlbnQub3B0cy5iYWNrRm9jdXMmJihyJiZyLmxlbmd0aCYmci5pcyhcIjp2aXNpYmxlXCIpfHwocj1zLiR0cmlnZ2VyKSxyJiZyLmxlbmd0aCYmKGk9dC5zY3JvbGxYLGE9dC5zY3JvbGxZLHIudHJpZ2dlcihcImZvY3VzXCIpLG4oXCJodG1sLCBib2R5XCIpLnNjcm9sbFRvcChhKS5zY3JvbGxMZWZ0KGkpKSkscy5jdXJyZW50PW51bGwsbz1uLmZhbmN5Ym94LmdldEluc3RhbmNlKCksbz9vLmFjdGl2YXRlKCk6KG4oXCJib2R5XCIpLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtYWN0aXZlIGNvbXBlbnNhdGUtZm9yLXNjcm9sbGJhclwiKSxuKFwiI2ZhbmN5Ym94LXN0eWxlLW5vc2Nyb2xsXCIpLnJlbW92ZSgpKX0sdHJpZ2dlcjpmdW5jdGlvbih0LGUpe3ZhciBvLGk9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGE9dGhpcyxzPWUmJmUub3B0cz9lOmEuY3VycmVudDtpZihzP2kudW5zaGlmdChzKTpzPWEsaS51bnNoaWZ0KGEpLG4uaXNGdW5jdGlvbihzLm9wdHNbdF0pJiYobz1zLm9wdHNbdF0uYXBwbHkocyxpKSksITE9PT1vKXJldHVybiBvO1wiYWZ0ZXJDbG9zZVwiIT09dCYmYS4kcmVmcz9hLiRyZWZzLmNvbnRhaW5lci50cmlnZ2VyKHQrXCIuZmJcIixpKTpyLnRyaWdnZXIodCtcIi5mYlwiLGkpfSx1cGRhdGVDb250cm9sczpmdW5jdGlvbigpe3ZhciB0PXRoaXMsbz10LmN1cnJlbnQsaT1vLmluZGV4LGE9dC4kcmVmcy5jb250YWluZXIscz10LiRyZWZzLmNhcHRpb24scj1vLm9wdHMuY2FwdGlvbjtvLiRzbGlkZS50cmlnZ2VyKFwicmVmcmVzaFwiKSxyJiZyLmxlbmd0aD8odC4kY2FwdGlvbj1zLHMuY2hpbGRyZW4oKS5lcSgwKS5odG1sKHIpKTp0LiRjYXB0aW9uPW51bGwsdC5oYXNIaWRkZW5Db250cm9sc3x8dC5pc0lkbGV8fHQuc2hvd0NvbnRyb2xzKCksYS5maW5kKFwiW2RhdGEtZmFuY3lib3gtY291bnRdXCIpLmh0bWwodC5ncm91cC5sZW5ndGgpLGEuZmluZChcIltkYXRhLWZhbmN5Ym94LWluZGV4XVwiKS5odG1sKGkrMSksYS5maW5kKFwiW2RhdGEtZmFuY3lib3gtcHJldl1cIikucHJvcChcImRpc2FibGVkXCIsIW8ub3B0cy5sb29wJiZpPD0wKSxhLmZpbmQoXCJbZGF0YS1mYW5jeWJveC1uZXh0XVwiKS5wcm9wKFwiZGlzYWJsZWRcIiwhby5vcHRzLmxvb3AmJmk+PXQuZ3JvdXAubGVuZ3RoLTEpLFwiaW1hZ2VcIj09PW8udHlwZT9hLmZpbmQoXCJbZGF0YS1mYW5jeWJveC16b29tXVwiKS5zaG93KCkuZW5kKCkuZmluZChcIltkYXRhLWZhbmN5Ym94LWRvd25sb2FkXVwiKS5hdHRyKFwiaHJlZlwiLG8ub3B0cy5pbWFnZS5zcmN8fG8uc3JjKS5zaG93KCk6by5vcHRzLnRvb2xiYXImJmEuZmluZChcIltkYXRhLWZhbmN5Ym94LWRvd25sb2FkXSxbZGF0YS1mYW5jeWJveC16b29tXVwiKS5oaWRlKCksbihlLmFjdGl2ZUVsZW1lbnQpLmlzKFwiOmhpZGRlbixbZGlzYWJsZWRdXCIpJiZ0LiRyZWZzLmNvbnRhaW5lci50cmlnZ2VyKFwiZm9jdXNcIil9LGhpZGVDb250cm9sczpmdW5jdGlvbih0KXt2YXIgZT10aGlzLG49W1wiaW5mb2JhclwiLFwidG9vbGJhclwiLFwibmF2XCJdOyF0JiZlLmN1cnJlbnQub3B0cy5wcmV2ZW50Q2FwdGlvbk92ZXJsYXB8fG4ucHVzaChcImNhcHRpb25cIiksdGhpcy4kcmVmcy5jb250YWluZXIucmVtb3ZlQ2xhc3Mobi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJmYW5jeWJveC1zaG93LVwiK3R9KS5qb2luKFwiIFwiKSksdGhpcy5oYXNIaWRkZW5Db250cm9scz0hMH0sc2hvd0NvbnRyb2xzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuY3VycmVudD90LmN1cnJlbnQub3B0czp0Lm9wdHMsbj10LiRyZWZzLmNvbnRhaW5lcjt0Lmhhc0hpZGRlbkNvbnRyb2xzPSExLHQuaWRsZVNlY29uZHNDb3VudGVyPTAsbi50b2dnbGVDbGFzcyhcImZhbmN5Ym94LXNob3ctdG9vbGJhclwiLCEoIWUudG9vbGJhcnx8IWUuYnV0dG9ucykpLnRvZ2dsZUNsYXNzKFwiZmFuY3lib3gtc2hvdy1pbmZvYmFyXCIsISEoZS5pbmZvYmFyJiZ0Lmdyb3VwLmxlbmd0aD4xKSkudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1zaG93LWNhcHRpb25cIiwhIXQuJGNhcHRpb24pLnRvZ2dsZUNsYXNzKFwiZmFuY3lib3gtc2hvdy1uYXZcIiwhIShlLmFycm93cyYmdC5ncm91cC5sZW5ndGg+MSkpLnRvZ2dsZUNsYXNzKFwiZmFuY3lib3gtaXMtbW9kYWxcIiwhIWUubW9kYWwpfSx0b2dnbGVDb250cm9sczpmdW5jdGlvbigpe3RoaXMuaGFzSGlkZGVuQ29udHJvbHM/dGhpcy5zaG93Q29udHJvbHMoKTp0aGlzLmhpZGVDb250cm9scygpfX0pLG4uZmFuY3lib3g9e3ZlcnNpb246XCIzLjUuN1wiLGRlZmF1bHRzOmEsZ2V0SW5zdGFuY2U6ZnVuY3Rpb24odCl7dmFyIGU9bignLmZhbmN5Ym94LWNvbnRhaW5lcjpub3QoXCIuZmFuY3lib3gtaXMtY2xvc2luZ1wiKTpsYXN0JykuZGF0YShcIkZhbmN5Qm94XCIpLG89QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiBlIGluc3RhbmNlb2YgYiYmKFwic3RyaW5nXCI9PT1uLnR5cGUodCk/ZVt0XS5hcHBseShlLG8pOlwiZnVuY3Rpb25cIj09PW4udHlwZSh0KSYmdC5hcHBseShlLG8pLGUpfSxvcGVuOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gbmV3IGIodCxlLG4pfSxjbG9zZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldEluc3RhbmNlKCk7ZSYmKGUuY2xvc2UoKSwhMD09PXQmJnRoaXMuY2xvc2UodCkpfSxkZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5jbG9zZSghMCksci5hZGQoXCJib2R5XCIpLm9mZihcImNsaWNrLmZiLXN0YXJ0XCIsXCIqKlwiKX0saXNNb2JpbGU6L0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLHVzZTNkOmZ1bmN0aW9uKCl7dmFyIG49ZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3JldHVybiB0LmdldENvbXB1dGVkU3R5bGUmJnQuZ2V0Q29tcHV0ZWRTdHlsZShuKSYmdC5nZXRDb21wdXRlZFN0eWxlKG4pLmdldFByb3BlcnR5VmFsdWUoXCJ0cmFuc2Zvcm1cIikmJiEoZS5kb2N1bWVudE1vZGUmJmUuZG9jdW1lbnRNb2RlPDExKX0oKSxnZXRUcmFuc2xhdGU6ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuISghdHx8IXQubGVuZ3RoKSYmKGU9dFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx7dG9wOmUudG9wfHwwLGxlZnQ6ZS5sZWZ0fHwwLHdpZHRoOmUud2lkdGgsaGVpZ2h0OmUuaGVpZ2h0LG9wYWNpdHk6cGFyc2VGbG9hdCh0LmNzcyhcIm9wYWNpdHlcIikpfSl9LHNldFRyYW5zbGF0ZTpmdW5jdGlvbih0LGUpe3ZhciBuPVwiXCIsbz17fTtpZih0JiZlKXJldHVybiB2b2lkIDA9PT1lLmxlZnQmJnZvaWQgMD09PWUudG9wfHwobj0odm9pZCAwPT09ZS5sZWZ0P3QucG9zaXRpb24oKS5sZWZ0OmUubGVmdCkrXCJweCwgXCIrKHZvaWQgMD09PWUudG9wP3QucG9zaXRpb24oKS50b3A6ZS50b3ApK1wicHhcIixuPXRoaXMudXNlM2Q/XCJ0cmFuc2xhdGUzZChcIituK1wiLCAwcHgpXCI6XCJ0cmFuc2xhdGUoXCIrbitcIilcIiksdm9pZCAwIT09ZS5zY2FsZVgmJnZvaWQgMCE9PWUuc2NhbGVZP24rPVwiIHNjYWxlKFwiK2Uuc2NhbGVYK1wiLCBcIitlLnNjYWxlWStcIilcIjp2b2lkIDAhPT1lLnNjYWxlWCYmKG4rPVwiIHNjYWxlWChcIitlLnNjYWxlWCtcIilcIiksbi5sZW5ndGgmJihvLnRyYW5zZm9ybT1uKSx2b2lkIDAhPT1lLm9wYWNpdHkmJihvLm9wYWNpdHk9ZS5vcGFjaXR5KSx2b2lkIDAhPT1lLndpZHRoJiYoby53aWR0aD1lLndpZHRoKSx2b2lkIDAhPT1lLmhlaWdodCYmKG8uaGVpZ2h0PWUuaGVpZ2h0KSx0LmNzcyhvKX0sYW5pbWF0ZTpmdW5jdGlvbih0LGUsbyxpLGEpe3ZhciBzLHI9dGhpcztuLmlzRnVuY3Rpb24obykmJihpPW8sbz1udWxsKSxyLnN0b3AodCkscz1yLmdldFRyYW5zbGF0ZSh0KSx0Lm9uKGYsZnVuY3Rpb24oYyl7KCFjfHwhYy5vcmlnaW5hbEV2ZW50fHx0LmlzKGMub3JpZ2luYWxFdmVudC50YXJnZXQpJiZcInotaW5kZXhcIiE9Yy5vcmlnaW5hbEV2ZW50LnByb3BlcnR5TmFtZSkmJihyLnN0b3AodCksbi5pc051bWVyaWMobykmJnQuY3NzKFwidHJhbnNpdGlvbi1kdXJhdGlvblwiLFwiXCIpLG4uaXNQbGFpbk9iamVjdChlKT92b2lkIDAhPT1lLnNjYWxlWCYmdm9pZCAwIT09ZS5zY2FsZVkmJnIuc2V0VHJhbnNsYXRlKHQse3RvcDplLnRvcCxsZWZ0OmUubGVmdCx3aWR0aDpzLndpZHRoKmUuc2NhbGVYLGhlaWdodDpzLmhlaWdodCplLnNjYWxlWSxzY2FsZVg6MSxzY2FsZVk6MX0pOiEwIT09YSYmdC5yZW1vdmVDbGFzcyhlKSxuLmlzRnVuY3Rpb24oaSkmJmkoYykpfSksbi5pc051bWVyaWMobykmJnQuY3NzKFwidHJhbnNpdGlvbi1kdXJhdGlvblwiLG8rXCJtc1wiKSxuLmlzUGxhaW5PYmplY3QoZSk/KHZvaWQgMCE9PWUuc2NhbGVYJiZ2b2lkIDAhPT1lLnNjYWxlWSYmKGRlbGV0ZSBlLndpZHRoLGRlbGV0ZSBlLmhlaWdodCx0LnBhcmVudCgpLmhhc0NsYXNzKFwiZmFuY3lib3gtc2xpZGUtLWltYWdlXCIpJiZ0LnBhcmVudCgpLmFkZENsYXNzKFwiZmFuY3lib3gtaXMtc2NhbGluZ1wiKSksbi5mYW5jeWJveC5zZXRUcmFuc2xhdGUodCxlKSk6dC5hZGRDbGFzcyhlKSx0LmRhdGEoXCJ0aW1lclwiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0LnRyaWdnZXIoZil9LG8rMzMpKX0sc3RvcDpmdW5jdGlvbih0LGUpe3QmJnQubGVuZ3RoJiYoY2xlYXJUaW1lb3V0KHQuZGF0YShcInRpbWVyXCIpKSxlJiZ0LnRyaWdnZXIoZiksdC5vZmYoZikuY3NzKFwidHJhbnNpdGlvbi1kdXJhdGlvblwiLFwiXCIpLHQucGFyZW50KCkucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1pcy1zY2FsaW5nXCIpKX19LG4uZm4uZmFuY3lib3g9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHQ9dHx8e30sZT10LnNlbGVjdG9yfHwhMSxlP24oXCJib2R5XCIpLm9mZihcImNsaWNrLmZiLXN0YXJ0XCIsZSkub24oXCJjbGljay5mYi1zdGFydFwiLGUse29wdGlvbnM6dH0saSk6dGhpcy5vZmYoXCJjbGljay5mYi1zdGFydFwiKS5vbihcImNsaWNrLmZiLXN0YXJ0XCIse2l0ZW1zOnRoaXMsb3B0aW9uczp0fSxpKSx0aGlzfSxyLm9uKFwiY2xpY2suZmItc3RhcnRcIixcIltkYXRhLWZhbmN5Ym94XVwiLGkpLHIub24oXCJjbGljay5mYi1zdGFydFwiLFwiW2RhdGEtZmFuY3lib3gtdHJpZ2dlcl1cIixmdW5jdGlvbih0KXtuKCdbZGF0YS1mYW5jeWJveD1cIicrbih0aGlzKS5hdHRyKFwiZGF0YS1mYW5jeWJveC10cmlnZ2VyXCIpKydcIl0nKS5lcShuKHRoaXMpLmF0dHIoXCJkYXRhLWZhbmN5Ym94LWluZGV4XCIpfHwwKS50cmlnZ2VyKFwiY2xpY2suZmItc3RhcnRcIix7JHRyaWdnZXI6bih0aGlzKX0pfSksZnVuY3Rpb24oKXt2YXIgdD1udWxsO3Iub24oXCJtb3VzZWRvd24gbW91c2V1cCBmb2N1cyBibHVyXCIsXCIuZmFuY3lib3gtYnV0dG9uXCIsZnVuY3Rpb24oZSl7c3dpdGNoKGUudHlwZSl7Y2FzZVwibW91c2Vkb3duXCI6dD1uKHRoaXMpO2JyZWFrO2Nhc2VcIm1vdXNldXBcIjp0PW51bGw7YnJlYWs7Y2FzZVwiZm9jdXNpblwiOm4oXCIuZmFuY3lib3gtYnV0dG9uXCIpLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtZm9jdXNcIiksbih0aGlzKS5pcyh0KXx8bih0aGlzKS5pcyhcIltkaXNhYmxlZF1cIil8fG4odGhpcykuYWRkQ2xhc3MoXCJmYW5jeWJveC1mb2N1c1wiKTticmVhaztjYXNlXCJmb2N1c291dFwiOm4oXCIuZmFuY3lib3gtYnV0dG9uXCIpLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtZm9jdXNcIil9fSl9KCl9fSh3aW5kb3csZG9jdW1lbnQsalF1ZXJ5KSxmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjt2YXIgZT17eW91dHViZTp7bWF0Y2hlcjovKHlvdXR1YmVcXC5jb218eW91dHVcXC5iZXx5b3V0dWJlXFwtbm9jb29raWVcXC5jb20pXFwvKHdhdGNoXFw/KC4qJik/dj18dlxcL3x1XFwvfGVtYmVkXFwvPyk/KHZpZGVvc2VyaWVzXFw/bGlzdD0oLiopfFtcXHctXXsxMX18XFw/bGlzdFR5cGU9KC4qKSZsaXN0PSguKikpKC4qKS9pLHBhcmFtczp7YXV0b3BsYXk6MSxhdXRvaGlkZToxLGZzOjEscmVsOjAsaGQ6MSx3bW9kZTpcInRyYW5zcGFyZW50XCIsZW5hYmxlanNhcGk6MSxodG1sNToxfSxwYXJhbVBsYWNlOjgsdHlwZTpcImlmcmFtZVwiLHVybDpcImh0dHBzOi8vd3d3LnlvdXR1YmUtbm9jb29raWUuY29tL2VtYmVkLyQ0XCIsdGh1bWI6XCJodHRwczovL2ltZy55b3V0dWJlLmNvbS92aS8kNC9ocWRlZmF1bHQuanBnXCJ9LHZpbWVvOnttYXRjaGVyOi9eLit2aW1lby5jb21cXC8oLipcXC8pPyhbXFxkXSspKC4qKT8vLHBhcmFtczp7YXV0b3BsYXk6MSxoZDoxLHNob3dfdGl0bGU6MSxzaG93X2J5bGluZToxLHNob3dfcG9ydHJhaXQ6MCxmdWxsc2NyZWVuOjF9LHBhcmFtUGxhY2U6Myx0eXBlOlwiaWZyYW1lXCIsdXJsOlwiLy9wbGF5ZXIudmltZW8uY29tL3ZpZGVvLyQyXCJ9LGluc3RhZ3JhbTp7bWF0Y2hlcjovKGluc3RhZ3JcXC5hbXxpbnN0YWdyYW1cXC5jb20pXFwvcFxcLyhbYS16QS1aMC05X1xcLV0rKVxcLz8vaSx0eXBlOlwiaW1hZ2VcIix1cmw6XCIvLyQxL3AvJDIvbWVkaWEvP3NpemU9bFwifSxnbWFwX3BsYWNlOnttYXRjaGVyOi8obWFwc1xcLik/Z29vZ2xlXFwuKFthLXpdezIsM30oXFwuW2Etel17Mn0pPylcXC8oKChtYXBzXFwvKHBsYWNlXFwvKC4qKVxcLyk/XFxAKC4qKSwoXFxkKy4/XFxkKz8peikpfChcXD9sbD0pKSguKik/L2ksdHlwZTpcImlmcmFtZVwiLHVybDpmdW5jdGlvbih0KXtyZXR1cm5cIi8vbWFwcy5nb29nbGUuXCIrdFsyXStcIi8/bGw9XCIrKHRbOV0/dFs5XStcIiZ6PVwiK01hdGguZmxvb3IodFsxMF0pKyh0WzEyXT90WzEyXS5yZXBsYWNlKC9eXFwvLyxcIiZcIik6XCJcIik6dFsxMl0rXCJcIikucmVwbGFjZSgvXFw/LyxcIiZcIikrXCImb3V0cHV0PVwiKyh0WzEyXSYmdFsxMl0uaW5kZXhPZihcImxheWVyPWNcIik+MD9cInN2ZW1iZWRcIjpcImVtYmVkXCIpfX0sZ21hcF9zZWFyY2g6e21hdGNoZXI6LyhtYXBzXFwuKT9nb29nbGVcXC4oW2Etel17MiwzfShcXC5bYS16XXsyfSk/KVxcLyhtYXBzXFwvc2VhcmNoXFwvKSguKikvaSx0eXBlOlwiaWZyYW1lXCIsdXJsOmZ1bmN0aW9uKHQpe3JldHVyblwiLy9tYXBzLmdvb2dsZS5cIit0WzJdK1wiL21hcHM/cT1cIit0WzVdLnJlcGxhY2UoXCJxdWVyeT1cIixcInE9XCIpLnJlcGxhY2UoXCJhcGk9MVwiLFwiXCIpK1wiJm91dHB1dD1lbWJlZFwifX19LG49ZnVuY3Rpb24oZSxuLG8pe2lmKGUpcmV0dXJuIG89b3x8XCJcIixcIm9iamVjdFwiPT09dC50eXBlKG8pJiYobz10LnBhcmFtKG8sITApKSx0LmVhY2gobixmdW5jdGlvbih0LG4pe2U9ZS5yZXBsYWNlKFwiJFwiK3Qsbnx8XCJcIil9KSxvLmxlbmd0aCYmKGUrPShlLmluZGV4T2YoXCI/XCIpPjA/XCImXCI6XCI/XCIpK28pLGV9O3QoZG9jdW1lbnQpLm9uKFwib2JqZWN0TmVlZHNUeXBlLmZiXCIsZnVuY3Rpb24obyxpLGEpe3ZhciBzLHIsYyxsLGQsdSxmLHA9YS5zcmN8fFwiXCIsaD0hMTtzPXQuZXh0ZW5kKCEwLHt9LGUsYS5vcHRzLm1lZGlhKSx0LmVhY2gocyxmdW5jdGlvbihlLG8pe2lmKGM9cC5tYXRjaChvLm1hdGNoZXIpKXtpZihoPW8udHlwZSxmPWUsdT17fSxvLnBhcmFtUGxhY2UmJmNbby5wYXJhbVBsYWNlXSl7ZD1jW28ucGFyYW1QbGFjZV0sXCI/XCI9PWRbMF0mJihkPWQuc3Vic3RyaW5nKDEpKSxkPWQuc3BsaXQoXCImXCIpO2Zvcih2YXIgaT0wO2k8ZC5sZW5ndGg7KytpKXt2YXIgcz1kW2ldLnNwbGl0KFwiPVwiLDIpOzI9PXMubGVuZ3RoJiYodVtzWzBdXT1kZWNvZGVVUklDb21wb25lbnQoc1sxXS5yZXBsYWNlKC9cXCsvZyxcIiBcIikpKX19cmV0dXJuIGw9dC5leHRlbmQoITAse30sby5wYXJhbXMsYS5vcHRzW2VdLHUpLHA9XCJmdW5jdGlvblwiPT09dC50eXBlKG8udXJsKT9vLnVybC5jYWxsKHRoaXMsYyxsLGEpOm4oby51cmwsYyxsKSxyPVwiZnVuY3Rpb25cIj09PXQudHlwZShvLnRodW1iKT9vLnRodW1iLmNhbGwodGhpcyxjLGwsYSk6bihvLnRodW1iLGMpLFwieW91dHViZVwiPT09ZT9wPXAucmVwbGFjZSgvJnQ9KChcXGQrKW0pPyhcXGQrKXMvLGZ1bmN0aW9uKHQsZSxuLG8pe3JldHVyblwiJnN0YXJ0PVwiKygobj82MCpwYXJzZUludChuLDEwKTowKStwYXJzZUludChvLDEwKSl9KTpcInZpbWVvXCI9PT1lJiYocD1wLnJlcGxhY2UoXCImJTIzXCIsXCIjXCIpKSwhMX19KSxoPyhhLm9wdHMudGh1bWJ8fGEub3B0cy4kdGh1bWImJmEub3B0cy4kdGh1bWIubGVuZ3RofHwoYS5vcHRzLnRodW1iPXIpLFwiaWZyYW1lXCI9PT1oJiYoYS5vcHRzPXQuZXh0ZW5kKCEwLGEub3B0cyx7aWZyYW1lOntwcmVsb2FkOiExLGF0dHI6e3Njcm9sbGluZzpcIm5vXCJ9fX0pKSx0LmV4dGVuZChhLHt0eXBlOmgsc3JjOnAsb3JpZ1NyYzphLnNyYyxjb250ZW50U291cmNlOmYsY29udGVudFR5cGU6XCJpbWFnZVwiPT09aD9cImltYWdlXCI6XCJnbWFwX3BsYWNlXCI9PWZ8fFwiZ21hcF9zZWFyY2hcIj09Zj9cIm1hcFwiOlwidmlkZW9cIn0pKTpwJiYoYS50eXBlPWEub3B0cy5kZWZhdWx0VHlwZSl9KTt2YXIgbz17eW91dHViZTp7c3JjOlwiaHR0cHM6Ly93d3cueW91dHViZS5jb20vaWZyYW1lX2FwaVwiLGNsYXNzOlwiWVRcIixsb2FkaW5nOiExLGxvYWRlZDohMX0sdmltZW86e3NyYzpcImh0dHBzOi8vcGxheWVyLnZpbWVvLmNvbS9hcGkvcGxheWVyLmpzXCIsY2xhc3M6XCJWaW1lb1wiLGxvYWRpbmc6ITEsbG9hZGVkOiExfSxsb2FkOmZ1bmN0aW9uKHQpe3ZhciBlLG49dGhpcztpZih0aGlzW3RdLmxvYWRlZClyZXR1cm4gdm9pZCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bi5kb25lKHQpfSk7dGhpc1t0XS5sb2FkaW5nfHwodGhpc1t0XS5sb2FkaW5nPSEwLGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSxlLnR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIixlLnNyYz10aGlzW3RdLnNyYyxcInlvdXR1YmVcIj09PXQ/d2luZG93Lm9uWW91VHViZUlmcmFtZUFQSVJlYWR5PWZ1bmN0aW9uKCl7blt0XS5sb2FkZWQ9ITAsbi5kb25lKHQpfTplLm9ubG9hZD1mdW5jdGlvbigpe25bdF0ubG9hZGVkPSEwLG4uZG9uZSh0KX0sZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKSl9LGRvbmU6ZnVuY3Rpb24oZSl7dmFyIG4sbyxpO1wieW91dHViZVwiPT09ZSYmZGVsZXRlIHdpbmRvdy5vbllvdVR1YmVJZnJhbWVBUElSZWFkeSwobj10LmZhbmN5Ym94LmdldEluc3RhbmNlKCkpJiYobz1uLmN1cnJlbnQuJGNvbnRlbnQuZmluZChcImlmcmFtZVwiKSxcInlvdXR1YmVcIj09PWUmJnZvaWQgMCE9PVlUJiZZVD9pPW5ldyBZVC5QbGF5ZXIoby5hdHRyKFwiaWRcIikse2V2ZW50czp7b25TdGF0ZUNoYW5nZTpmdW5jdGlvbih0KXswPT10LmRhdGEmJm4ubmV4dCgpfX19KTpcInZpbWVvXCI9PT1lJiZ2b2lkIDAhPT1WaW1lbyYmVmltZW8mJihpPW5ldyBWaW1lby5QbGF5ZXIobyksaS5vbihcImVuZGVkXCIsZnVuY3Rpb24oKXtuLm5leHQoKX0pKSl9fTt0KGRvY3VtZW50KS5vbih7XCJhZnRlclNob3cuZmJcIjpmdW5jdGlvbih0LGUsbil7ZS5ncm91cC5sZW5ndGg+MSYmKFwieW91dHViZVwiPT09bi5jb250ZW50U291cmNlfHxcInZpbWVvXCI9PT1uLmNvbnRlbnRTb3VyY2UpJiZvLmxvYWQobi5jb250ZW50U291cmNlKX19KX0oalF1ZXJ5KSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89ZnVuY3Rpb24oKXtyZXR1cm4gdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHQud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx0Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8dC5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbihlKXtyZXR1cm4gdC5zZXRUaW1lb3V0KGUsMWUzLzYwKX19KCksaT1mdW5jdGlvbigpe3JldHVybiB0LmNhbmNlbEFuaW1hdGlvbkZyYW1lfHx0LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lfHx0Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lfHx0Lm9DYW5jZWxBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24oZSl7dC5jbGVhclRpbWVvdXQoZSl9fSgpLGE9ZnVuY3Rpb24oZSl7dmFyIG49W107ZT1lLm9yaWdpbmFsRXZlbnR8fGV8fHQuZSxlPWUudG91Y2hlcyYmZS50b3VjaGVzLmxlbmd0aD9lLnRvdWNoZXM6ZS5jaGFuZ2VkVG91Y2hlcyYmZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg/ZS5jaGFuZ2VkVG91Y2hlczpbZV07Zm9yKHZhciBvIGluIGUpZVtvXS5wYWdlWD9uLnB1c2goe3g6ZVtvXS5wYWdlWCx5OmVbb10ucGFnZVl9KTplW29dLmNsaWVudFgmJm4ucHVzaCh7eDplW29dLmNsaWVudFgseTplW29dLmNsaWVudFl9KTtyZXR1cm4gbn0scz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGUmJnQ/XCJ4XCI9PT1uP3QueC1lLng6XCJ5XCI9PT1uP3QueS1lLnk6TWF0aC5zcXJ0KE1hdGgucG93KHQueC1lLngsMikrTWF0aC5wb3codC55LWUueSwyKSk6MH0scj1mdW5jdGlvbih0KXtpZih0LmlzKCdhLGFyZWEsYnV0dG9uLFtyb2xlPVwiYnV0dG9uXCJdLGlucHV0LGxhYmVsLHNlbGVjdCxzdW1tYXJ5LHRleHRhcmVhLHZpZGVvLGF1ZGlvLGlmcmFtZScpfHxuLmlzRnVuY3Rpb24odC5nZXQoMCkub25jbGljayl8fHQuZGF0YShcInNlbGVjdGFibGVcIikpcmV0dXJuITA7Zm9yKHZhciBlPTAsbz10WzBdLmF0dHJpYnV0ZXMsaT1vLmxlbmd0aDtlPGk7ZSsrKWlmKFwiZGF0YS1mYW5jeWJveC1cIj09PW9bZV0ubm9kZU5hbWUuc3Vic3RyKDAsMTQpKXJldHVybiEwO3JldHVybiExfSxjPWZ1bmN0aW9uKGUpe3ZhciBuPXQuZ2V0Q29tcHV0ZWRTdHlsZShlKVtcIm92ZXJmbG93LXlcIl0sbz10LmdldENvbXB1dGVkU3R5bGUoZSlbXCJvdmVyZmxvdy14XCJdLGk9KFwic2Nyb2xsXCI9PT1ufHxcImF1dG9cIj09PW4pJiZlLnNjcm9sbEhlaWdodD5lLmNsaWVudEhlaWdodCxhPShcInNjcm9sbFwiPT09b3x8XCJhdXRvXCI9PT1vKSYmZS5zY3JvbGxXaWR0aD5lLmNsaWVudFdpZHRoO3JldHVybiBpfHxhfSxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0hMTs7KXtpZihlPWModC5nZXQoMCkpKWJyZWFrO2lmKHQ9dC5wYXJlbnQoKSwhdC5sZW5ndGh8fHQuaGFzQ2xhc3MoXCJmYW5jeWJveC1zdGFnZVwiKXx8dC5pcyhcImJvZHlcIikpYnJlYWt9cmV0dXJuIGV9LGQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztlLmluc3RhbmNlPXQsZS4kYmc9dC4kcmVmcy5iZyxlLiRzdGFnZT10LiRyZWZzLnN0YWdlLGUuJGNvbnRhaW5lcj10LiRyZWZzLmNvbnRhaW5lcixlLmRlc3Ryb3koKSxlLiRjb250YWluZXIub24oXCJ0b3VjaHN0YXJ0LmZiLnRvdWNoIG1vdXNlZG93bi5mYi50b3VjaFwiLG4ucHJveHkoZSxcIm9udG91Y2hzdGFydFwiKSl9O2QucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3QuJGNvbnRhaW5lci5vZmYoXCIuZmIudG91Y2hcIiksbihlKS5vZmYoXCIuZmIudG91Y2hcIiksdC5yZXF1ZXN0SWQmJihpKHQucmVxdWVzdElkKSx0LnJlcXVlc3RJZD1udWxsKSx0LnRhcHBlZCYmKGNsZWFyVGltZW91dCh0LnRhcHBlZCksdC50YXBwZWQ9bnVsbCl9LGQucHJvdG90eXBlLm9udG91Y2hzdGFydD1mdW5jdGlvbihvKXt2YXIgaT10aGlzLGM9bihvLnRhcmdldCksZD1pLmluc3RhbmNlLHU9ZC5jdXJyZW50LGY9dS4kc2xpZGUscD11LiRjb250ZW50LGg9XCJ0b3VjaHN0YXJ0XCI9PW8udHlwZTtpZihoJiZpLiRjb250YWluZXIub2ZmKFwibW91c2Vkb3duLmZiLnRvdWNoXCIpLCghby5vcmlnaW5hbEV2ZW50fHwyIT1vLm9yaWdpbmFsRXZlbnQuYnV0dG9uKSYmZi5sZW5ndGgmJmMubGVuZ3RoJiYhcihjKSYmIXIoYy5wYXJlbnQoKSkmJihjLmlzKFwiaW1nXCIpfHwhKG8ub3JpZ2luYWxFdmVudC5jbGllbnRYPmNbMF0uY2xpZW50V2lkdGgrYy5vZmZzZXQoKS5sZWZ0KSkpe2lmKCF1fHxkLmlzQW5pbWF0aW5nfHx1LiRzbGlkZS5oYXNDbGFzcyhcImZhbmN5Ym94LWFuaW1hdGVkXCIpKXJldHVybiBvLnN0b3BQcm9wYWdhdGlvbigpLHZvaWQgby5wcmV2ZW50RGVmYXVsdCgpO2kucmVhbFBvaW50cz1pLnN0YXJ0UG9pbnRzPWEobyksaS5zdGFydFBvaW50cy5sZW5ndGgmJih1LnRvdWNoJiZvLnN0b3BQcm9wYWdhdGlvbigpLGkuc3RhcnRFdmVudD1vLGkuY2FuVGFwPSEwLGkuJHRhcmdldD1jLGkuJGNvbnRlbnQ9cCxpLm9wdHM9dS5vcHRzLnRvdWNoLGkuaXNQYW5uaW5nPSExLGkuaXNTd2lwaW5nPSExLGkuaXNab29taW5nPSExLGkuaXNTY3JvbGxpbmc9ITEsaS5jYW5QYW49ZC5jYW5QYW4oKSxpLnN0YXJ0VGltZT0obmV3IERhdGUpLmdldFRpbWUoKSxpLmRpc3RhbmNlWD1pLmRpc3RhbmNlWT1pLmRpc3RhbmNlPTAsaS5jYW52YXNXaWR0aD1NYXRoLnJvdW5kKGZbMF0uY2xpZW50V2lkdGgpLGkuY2FudmFzSGVpZ2h0PU1hdGgucm91bmQoZlswXS5jbGllbnRIZWlnaHQpLGkuY29udGVudExhc3RQb3M9bnVsbCxpLmNvbnRlbnRTdGFydFBvcz1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShpLiRjb250ZW50KXx8e3RvcDowLGxlZnQ6MH0saS5zbGlkZXJTdGFydFBvcz1uLmZhbmN5Ym94LmdldFRyYW5zbGF0ZShmKSxpLnN0YWdlUG9zPW4uZmFuY3lib3guZ2V0VHJhbnNsYXRlKGQuJHJlZnMuc3RhZ2UpLGkuc2xpZGVyU3RhcnRQb3MudG9wLT1pLnN0YWdlUG9zLnRvcCxpLnNsaWRlclN0YXJ0UG9zLmxlZnQtPWkuc3RhZ2VQb3MubGVmdCxpLmNvbnRlbnRTdGFydFBvcy50b3AtPWkuc3RhZ2VQb3MudG9wLGkuY29udGVudFN0YXJ0UG9zLmxlZnQtPWkuc3RhZ2VQb3MubGVmdCxuKGUpLm9mZihcIi5mYi50b3VjaFwiKS5vbihoP1widG91Y2hlbmQuZmIudG91Y2ggdG91Y2hjYW5jZWwuZmIudG91Y2hcIjpcIm1vdXNldXAuZmIudG91Y2ggbW91c2VsZWF2ZS5mYi50b3VjaFwiLG4ucHJveHkoaSxcIm9udG91Y2hlbmRcIikpLm9uKGg/XCJ0b3VjaG1vdmUuZmIudG91Y2hcIjpcIm1vdXNlbW92ZS5mYi50b3VjaFwiLG4ucHJveHkoaSxcIm9udG91Y2htb3ZlXCIpKSxuLmZhbmN5Ym94LmlzTW9iaWxlJiZlLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixpLm9uc2Nyb2xsLCEwKSwoKGkub3B0c3x8aS5jYW5QYW4pJiYoYy5pcyhpLiRzdGFnZSl8fGkuJHN0YWdlLmZpbmQoYykubGVuZ3RoKXx8KGMuaXMoXCIuZmFuY3lib3gtaW1hZ2VcIikmJm8ucHJldmVudERlZmF1bHQoKSxuLmZhbmN5Ym94LmlzTW9iaWxlJiZjLnBhcmVudHMoXCIuZmFuY3lib3gtY2FwdGlvblwiKS5sZW5ndGgpKSYmKGkuaXNTY3JvbGxhYmxlPWwoYyl8fGwoYy5wYXJlbnQoKSksbi5mYW5jeWJveC5pc01vYmlsZSYmaS5pc1Njcm9sbGFibGV8fG8ucHJldmVudERlZmF1bHQoKSwoMT09PWkuc3RhcnRQb2ludHMubGVuZ3RofHx1Lmhhc0Vycm9yKSYmKGkuY2FuUGFuPyhuLmZhbmN5Ym94LnN0b3AoaS4kY29udGVudCksaS5pc1Bhbm5pbmc9ITApOmkuaXNTd2lwaW5nPSEwLGkuJGNvbnRhaW5lci5hZGRDbGFzcyhcImZhbmN5Ym94LWlzLWdyYWJiaW5nXCIpKSwyPT09aS5zdGFydFBvaW50cy5sZW5ndGgmJlwiaW1hZ2VcIj09PXUudHlwZSYmKHUuaXNMb2FkZWR8fHUuJGdob3N0KSYmKGkuY2FuVGFwPSExLGkuaXNTd2lwaW5nPSExLGkuaXNQYW5uaW5nPSExLGkuaXNab29taW5nPSEwLG4uZmFuY3lib3guc3RvcChpLiRjb250ZW50KSxpLmNlbnRlclBvaW50U3RhcnRYPS41KihpLnN0YXJ0UG9pbnRzWzBdLngraS5zdGFydFBvaW50c1sxXS54KS1uKHQpLnNjcm9sbExlZnQoKSxpLmNlbnRlclBvaW50U3RhcnRZPS41KihpLnN0YXJ0UG9pbnRzWzBdLnkraS5zdGFydFBvaW50c1sxXS55KS1uKHQpLnNjcm9sbFRvcCgpLGkucGVyY2VudGFnZU9mSW1hZ2VBdFBpbmNoUG9pbnRYPShpLmNlbnRlclBvaW50U3RhcnRYLWkuY29udGVudFN0YXJ0UG9zLmxlZnQpL2kuY29udGVudFN0YXJ0UG9zLndpZHRoLGkucGVyY2VudGFnZU9mSW1hZ2VBdFBpbmNoUG9pbnRZPShpLmNlbnRlclBvaW50U3RhcnRZLWkuY29udGVudFN0YXJ0UG9zLnRvcCkvaS5jb250ZW50U3RhcnRQb3MuaGVpZ2h0LGkuc3RhcnREaXN0YW5jZUJldHdlZW5GaW5nZXJzPXMoaS5zdGFydFBvaW50c1swXSxpLnN0YXJ0UG9pbnRzWzFdKSkpKX19LGQucHJvdG90eXBlLm9uc2Nyb2xsPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7bi5pc1Njcm9sbGluZz0hMCxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixuLm9uc2Nyb2xsLCEwKX0sZC5wcm90b3R5cGUub250b3VjaG1vdmU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gdm9pZCAwIT09dC5vcmlnaW5hbEV2ZW50LmJ1dHRvbnMmJjA9PT10Lm9yaWdpbmFsRXZlbnQuYnV0dG9ucz92b2lkIGUub250b3VjaGVuZCh0KTplLmlzU2Nyb2xsaW5nP3ZvaWQoZS5jYW5UYXA9ITEpOihlLm5ld1BvaW50cz1hKHQpLHZvaWQoKGUub3B0c3x8ZS5jYW5QYW4pJiZlLm5ld1BvaW50cy5sZW5ndGgmJmUubmV3UG9pbnRzLmxlbmd0aCYmKGUuaXNTd2lwaW5nJiYhMD09PWUuaXNTd2lwaW5nfHx0LnByZXZlbnREZWZhdWx0KCksZS5kaXN0YW5jZVg9cyhlLm5ld1BvaW50c1swXSxlLnN0YXJ0UG9pbnRzWzBdLFwieFwiKSxlLmRpc3RhbmNlWT1zKGUubmV3UG9pbnRzWzBdLGUuc3RhcnRQb2ludHNbMF0sXCJ5XCIpLGUuZGlzdGFuY2U9cyhlLm5ld1BvaW50c1swXSxlLnN0YXJ0UG9pbnRzWzBdKSxlLmRpc3RhbmNlPjAmJihlLmlzU3dpcGluZz9lLm9uU3dpcGUodCk6ZS5pc1Bhbm5pbmc/ZS5vblBhbigpOmUuaXNab29taW5nJiZlLm9uWm9vbSgpKSkpKX0sZC5wcm90b3R5cGUub25Td2lwZT1mdW5jdGlvbihlKXt2YXIgYSxzPXRoaXMscj1zLmluc3RhbmNlLGM9cy5pc1N3aXBpbmcsbD1zLnNsaWRlclN0YXJ0UG9zLmxlZnR8fDA7aWYoITAhPT1jKVwieFwiPT1jJiYocy5kaXN0YW5jZVg+MCYmKHMuaW5zdGFuY2UuZ3JvdXAubGVuZ3RoPDJ8fDA9PT1zLmluc3RhbmNlLmN1cnJlbnQuaW5kZXgmJiFzLmluc3RhbmNlLmN1cnJlbnQub3B0cy5sb29wKT9sKz1NYXRoLnBvdyhzLmRpc3RhbmNlWCwuOCk6cy5kaXN0YW5jZVg8MCYmKHMuaW5zdGFuY2UuZ3JvdXAubGVuZ3RoPDJ8fHMuaW5zdGFuY2UuY3VycmVudC5pbmRleD09PXMuaW5zdGFuY2UuZ3JvdXAubGVuZ3RoLTEmJiFzLmluc3RhbmNlLmN1cnJlbnQub3B0cy5sb29wKT9sLT1NYXRoLnBvdygtcy5kaXN0YW5jZVgsLjgpOmwrPXMuZGlzdGFuY2VYKSxzLnNsaWRlckxhc3RQb3M9e3RvcDpcInhcIj09Yz8wOnMuc2xpZGVyU3RhcnRQb3MudG9wK3MuZGlzdGFuY2VZLGxlZnQ6bH0scy5yZXF1ZXN0SWQmJihpKHMucmVxdWVzdElkKSxzLnJlcXVlc3RJZD1udWxsKSxzLnJlcXVlc3RJZD1vKGZ1bmN0aW9uKCl7cy5zbGlkZXJMYXN0UG9zJiYobi5lYWNoKHMuaW5zdGFuY2Uuc2xpZGVzLGZ1bmN0aW9uKHQsZSl7dmFyIG89ZS5wb3Mtcy5pbnN0YW5jZS5jdXJyUG9zO24uZmFuY3lib3guc2V0VHJhbnNsYXRlKGUuJHNsaWRlLHt0b3A6cy5zbGlkZXJMYXN0UG9zLnRvcCxsZWZ0OnMuc2xpZGVyTGFzdFBvcy5sZWZ0K28qcy5jYW52YXNXaWR0aCtvKmUub3B0cy5ndXR0ZXJ9KX0pLHMuJGNvbnRhaW5lci5hZGRDbGFzcyhcImZhbmN5Ym94LWlzLXNsaWRpbmdcIikpfSk7ZWxzZSBpZihNYXRoLmFicyhzLmRpc3RhbmNlKT4xMCl7aWYocy5jYW5UYXA9ITEsci5ncm91cC5sZW5ndGg8MiYmcy5vcHRzLnZlcnRpY2FsP3MuaXNTd2lwaW5nPVwieVwiOnIuaXNEcmFnZ2luZ3x8ITE9PT1zLm9wdHMudmVydGljYWx8fFwiYXV0b1wiPT09cy5vcHRzLnZlcnRpY2FsJiZuKHQpLndpZHRoKCk+ODAwP3MuaXNTd2lwaW5nPVwieFwiOihhPU1hdGguYWJzKDE4MCpNYXRoLmF0YW4yKHMuZGlzdGFuY2VZLHMuZGlzdGFuY2VYKS9NYXRoLlBJKSxzLmlzU3dpcGluZz1hPjQ1JiZhPDEzNT9cInlcIjpcInhcIiksXCJ5XCI9PT1zLmlzU3dpcGluZyYmbi5mYW5jeWJveC5pc01vYmlsZSYmcy5pc1Njcm9sbGFibGUpcmV0dXJuIHZvaWQocy5pc1Njcm9sbGluZz0hMCk7ci5pc0RyYWdnaW5nPXMuaXNTd2lwaW5nLHMuc3RhcnRQb2ludHM9cy5uZXdQb2ludHMsbi5lYWNoKHIuc2xpZGVzLGZ1bmN0aW9uKHQsZSl7dmFyIG8saTtuLmZhbmN5Ym94LnN0b3AoZS4kc2xpZGUpLG89bi5mYW5jeWJveC5nZXRUcmFuc2xhdGUoZS4kc2xpZGUpLGk9bi5mYW5jeWJveC5nZXRUcmFuc2xhdGUoci4kcmVmcy5zdGFnZSksZS4kc2xpZGUuY3NzKHt0cmFuc2Zvcm06XCJcIixvcGFjaXR5OlwiXCIsXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCI6XCJcIn0pLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtYW5pbWF0ZWRcIikucmVtb3ZlQ2xhc3MoZnVuY3Rpb24odCxlKXtyZXR1cm4oZS5tYXRjaCgvKF58XFxzKWZhbmN5Ym94LWZ4LVxcUysvZyl8fFtdKS5qb2luKFwiIFwiKX0pLGUucG9zPT09ci5jdXJyZW50LnBvcyYmKHMuc2xpZGVyU3RhcnRQb3MudG9wPW8udG9wLWkudG9wLHMuc2xpZGVyU3RhcnRQb3MubGVmdD1vLmxlZnQtaS5sZWZ0KSxuLmZhbmN5Ym94LnNldFRyYW5zbGF0ZShlLiRzbGlkZSx7dG9wOm8udG9wLWkudG9wLGxlZnQ6by5sZWZ0LWkubGVmdH0pfSksci5TbGlkZVNob3cmJnIuU2xpZGVTaG93LmlzQWN0aXZlJiZyLlNsaWRlU2hvdy5zdG9wKCl9fSxkLnByb3RvdHlwZS5vblBhbj1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYocyh0Lm5ld1BvaW50c1swXSx0LnJlYWxQb2ludHNbMF0pPChuLmZhbmN5Ym94LmlzTW9iaWxlPzEwOjUpKXJldHVybiB2b2lkKHQuc3RhcnRQb2ludHM9dC5uZXdQb2ludHMpO3QuY2FuVGFwPSExLHQuY29udGVudExhc3RQb3M9dC5saW1pdE1vdmVtZW50KCksdC5yZXF1ZXN0SWQmJmkodC5yZXF1ZXN0SWQpLHQucmVxdWVzdElkPW8oZnVuY3Rpb24oKXtuLmZhbmN5Ym94LnNldFRyYW5zbGF0ZSh0LiRjb250ZW50LHQuY29udGVudExhc3RQb3MpfSl9LGQucHJvdG90eXBlLmxpbWl0TW92ZW1lbnQ9ZnVuY3Rpb24oKXt2YXIgdCxlLG4sbyxpLGEscz10aGlzLHI9cy5jYW52YXNXaWR0aCxjPXMuY2FudmFzSGVpZ2h0LGw9cy5kaXN0YW5jZVgsZD1zLmRpc3RhbmNlWSx1PXMuY29udGVudFN0YXJ0UG9zLGY9dS5sZWZ0LHA9dS50b3AsaD11LndpZHRoLGc9dS5oZWlnaHQ7cmV0dXJuIGk9aD5yP2YrbDpmLGE9cCtkLHQ9TWF0aC5tYXgoMCwuNSpyLS41KmgpLGU9TWF0aC5tYXgoMCwuNSpjLS41KmcpLG49TWF0aC5taW4oci1oLC41KnItLjUqaCksbz1NYXRoLm1pbihjLWcsLjUqYy0uNSpnKSxsPjAmJmk+dCYmKGk9dC0xK01hdGgucG93KC10K2YrbCwuOCl8fDApLGw8MCYmaTxuJiYoaT1uKzEtTWF0aC5wb3cobi1mLWwsLjgpfHwwKSxkPjAmJmE+ZSYmKGE9ZS0xK01hdGgucG93KC1lK3ArZCwuOCl8fDApLGQ8MCYmYTxvJiYoYT1vKzEtTWF0aC5wb3coby1wLWQsLjgpfHwwKSx7dG9wOmEsbGVmdDppfX0sZC5wcm90b3R5cGUubGltaXRQb3NpdGlvbj1mdW5jdGlvbih0LGUsbixvKXt2YXIgaT10aGlzLGE9aS5jYW52YXNXaWR0aCxzPWkuY2FudmFzSGVpZ2h0O3JldHVybiBuPmE/KHQ9dD4wPzA6dCx0PXQ8YS1uP2Etbjp0KTp0PU1hdGgubWF4KDAsYS8yLW4vMiksbz5zPyhlPWU+MD8wOmUsZT1lPHMtbz9zLW86ZSk6ZT1NYXRoLm1heCgwLHMvMi1vLzIpLHt0b3A6ZSxsZWZ0OnR9fSxkLnByb3RvdHlwZS5vblpvb209ZnVuY3Rpb24oKXt2YXIgZT10aGlzLGE9ZS5jb250ZW50U3RhcnRQb3Mscj1hLndpZHRoLGM9YS5oZWlnaHQsbD1hLmxlZnQsZD1hLnRvcCx1PXMoZS5uZXdQb2ludHNbMF0sZS5uZXdQb2ludHNbMV0pLGY9dS9lLnN0YXJ0RGlzdGFuY2VCZXR3ZWVuRmluZ2VycyxwPU1hdGguZmxvb3IocipmKSxoPU1hdGguZmxvb3IoYypmKSxnPShyLXApKmUucGVyY2VudGFnZU9mSW1hZ2VBdFBpbmNoUG9pbnRYLGI9KGMtaCkqZS5wZXJjZW50YWdlT2ZJbWFnZUF0UGluY2hQb2ludFksbT0oZS5uZXdQb2ludHNbMF0ueCtlLm5ld1BvaW50c1sxXS54KS8yLW4odCkuc2Nyb2xsTGVmdCgpLHY9KGUubmV3UG9pbnRzWzBdLnkrZS5uZXdQb2ludHNbMV0ueSkvMi1uKHQpLnNjcm9sbFRvcCgpLHk9bS1lLmNlbnRlclBvaW50U3RhcnRYLHg9di1lLmNlbnRlclBvaW50U3RhcnRZLHc9bCsoZyt5KSwkPWQrKGIreCksUz17dG9wOiQsbGVmdDp3LHNjYWxlWDpmLHNjYWxlWTpmfTtlLmNhblRhcD0hMSxlLm5ld1dpZHRoPXAsZS5uZXdIZWlnaHQ9aCxlLmNvbnRlbnRMYXN0UG9zPVMsZS5yZXF1ZXN0SWQmJmkoZS5yZXF1ZXN0SWQpLGUucmVxdWVzdElkPW8oZnVuY3Rpb24oKXtuLmZhbmN5Ym94LnNldFRyYW5zbGF0ZShlLiRjb250ZW50LGUuY29udGVudExhc3RQb3MpfSl9LGQucHJvdG90eXBlLm9udG91Y2hlbmQ9ZnVuY3Rpb24odCl7dmFyIG89dGhpcyxzPW8uaXNTd2lwaW5nLHI9by5pc1Bhbm5pbmcsYz1vLmlzWm9vbWluZyxsPW8uaXNTY3JvbGxpbmc7aWYoby5lbmRQb2ludHM9YSh0KSxvLmRNcz1NYXRoLm1heCgobmV3IERhdGUpLmdldFRpbWUoKS1vLnN0YXJ0VGltZSwxKSxvLiRjb250YWluZXIucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1pcy1ncmFiYmluZ1wiKSxuKGUpLm9mZihcIi5mYi50b3VjaFwiKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixvLm9uc2Nyb2xsLCEwKSxvLnJlcXVlc3RJZCYmKGkoby5yZXF1ZXN0SWQpLG8ucmVxdWVzdElkPW51bGwpLG8uaXNTd2lwaW5nPSExLG8uaXNQYW5uaW5nPSExLG8uaXNab29taW5nPSExLG8uaXNTY3JvbGxpbmc9ITEsby5pbnN0YW5jZS5pc0RyYWdnaW5nPSExLG8uY2FuVGFwKXJldHVybiBvLm9uVGFwKHQpO28uc3BlZWQ9MTAwLG8udmVsb2NpdHlYPW8uZGlzdGFuY2VYL28uZE1zKi41LG8udmVsb2NpdHlZPW8uZGlzdGFuY2VZL28uZE1zKi41LHI/by5lbmRQYW5uaW5nKCk6Yz9vLmVuZFpvb21pbmcoKTpvLmVuZFN3aXBpbmcocyxsKX0sZC5wcm90b3R5cGUuZW5kU3dpcGluZz1mdW5jdGlvbih0LGUpe3ZhciBvPXRoaXMsaT0hMSxhPW8uaW5zdGFuY2UuZ3JvdXAubGVuZ3RoLHM9TWF0aC5hYnMoby5kaXN0YW5jZVgpLHI9XCJ4XCI9PXQmJmE+MSYmKG8uZE1zPjEzMCYmcz4xMHx8cz41MCk7by5zbGlkZXJMYXN0UG9zPW51bGwsXCJ5XCI9PXQmJiFlJiZNYXRoLmFicyhvLmRpc3RhbmNlWSk+NTA/KG4uZmFuY3lib3guYW5pbWF0ZShvLmluc3RhbmNlLmN1cnJlbnQuJHNsaWRlLHt0b3A6by5zbGlkZXJTdGFydFBvcy50b3Arby5kaXN0YW5jZVkrMTUwKm8udmVsb2NpdHlZLG9wYWNpdHk6MH0sMjAwKSxpPW8uaW5zdGFuY2UuY2xvc2UoITAsMjUwKSk6ciYmby5kaXN0YW5jZVg+MD9pPW8uaW5zdGFuY2UucHJldmlvdXMoMzAwKTpyJiZvLmRpc3RhbmNlWDwwJiYoaT1vLmluc3RhbmNlLm5leHQoMzAwKSksITEhPT1pfHxcInhcIiE9dCYmXCJ5XCIhPXR8fG8uaW5zdGFuY2UuY2VudGVyU2xpZGUoMjAwKSxvLiRjb250YWluZXIucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1pcy1zbGlkaW5nXCIpfSxkLnByb3RvdHlwZS5lbmRQYW5uaW5nPWZ1bmN0aW9uKCl7dmFyIHQsZSxvLGk9dGhpcztpLmNvbnRlbnRMYXN0UG9zJiYoITE9PT1pLm9wdHMubW9tZW50dW18fGkuZE1zPjM1MD8odD1pLmNvbnRlbnRMYXN0UG9zLmxlZnQsZT1pLmNvbnRlbnRMYXN0UG9zLnRvcCk6KHQ9aS5jb250ZW50TGFzdFBvcy5sZWZ0KzUwMCppLnZlbG9jaXR5WCxlPWkuY29udGVudExhc3RQb3MudG9wKzUwMCppLnZlbG9jaXR5WSksbz1pLmxpbWl0UG9zaXRpb24odCxlLGkuY29udGVudFN0YXJ0UG9zLndpZHRoLGkuY29udGVudFN0YXJ0UG9zLmhlaWdodCksby53aWR0aD1pLmNvbnRlbnRTdGFydFBvcy53aWR0aCxvLmhlaWdodD1pLmNvbnRlbnRTdGFydFBvcy5oZWlnaHQsbi5mYW5jeWJveC5hbmltYXRlKGkuJGNvbnRlbnQsbywzNjYpKX0sZC5wcm90b3R5cGUuZW5kWm9vbWluZz1mdW5jdGlvbigpe3ZhciB0LGUsbyxpLGE9dGhpcyxzPWEuaW5zdGFuY2UuY3VycmVudCxyPWEubmV3V2lkdGgsYz1hLm5ld0hlaWdodDthLmNvbnRlbnRMYXN0UG9zJiYodD1hLmNvbnRlbnRMYXN0UG9zLmxlZnQsZT1hLmNvbnRlbnRMYXN0UG9zLnRvcCxpPXt0b3A6ZSxsZWZ0OnQsd2lkdGg6cixoZWlnaHQ6YyxzY2FsZVg6MSxzY2FsZVk6MX0sbi5mYW5jeWJveC5zZXRUcmFuc2xhdGUoYS4kY29udGVudCxpKSxyPGEuY2FudmFzV2lkdGgmJmM8YS5jYW52YXNIZWlnaHQ/YS5pbnN0YW5jZS5zY2FsZVRvRml0KDE1MCk6cj5zLndpZHRofHxjPnMuaGVpZ2h0P2EuaW5zdGFuY2Uuc2NhbGVUb0FjdHVhbChhLmNlbnRlclBvaW50U3RhcnRYLGEuY2VudGVyUG9pbnRTdGFydFksMTUwKToobz1hLmxpbWl0UG9zaXRpb24odCxlLHIsYyksbi5mYW5jeWJveC5hbmltYXRlKGEuJGNvbnRlbnQsbywxNTApKSl9LGQucHJvdG90eXBlLm9uVGFwPWZ1bmN0aW9uKGUpe3ZhciBvLGk9dGhpcyxzPW4oZS50YXJnZXQpLHI9aS5pbnN0YW5jZSxjPXIuY3VycmVudCxsPWUmJmEoZSl8fGkuc3RhcnRQb2ludHMsZD1sWzBdP2xbMF0ueC1uKHQpLnNjcm9sbExlZnQoKS1pLnN0YWdlUG9zLmxlZnQ6MCx1PWxbMF0/bFswXS55LW4odCkuc2Nyb2xsVG9wKCktaS5zdGFnZVBvcy50b3A6MCxmPWZ1bmN0aW9uKHQpe3ZhciBvPWMub3B0c1t0XTtpZihuLmlzRnVuY3Rpb24obykmJihvPW8uYXBwbHkocixbYyxlXSkpLG8pc3dpdGNoKG8pe2Nhc2VcImNsb3NlXCI6ci5jbG9zZShpLnN0YXJ0RXZlbnQpO2JyZWFrO2Nhc2VcInRvZ2dsZUNvbnRyb2xzXCI6ci50b2dnbGVDb250cm9scygpO2JyZWFrO2Nhc2VcIm5leHRcIjpyLm5leHQoKTticmVhaztjYXNlXCJuZXh0T3JDbG9zZVwiOnIuZ3JvdXAubGVuZ3RoPjE/ci5uZXh0KCk6ci5jbG9zZShpLnN0YXJ0RXZlbnQpO2JyZWFrO2Nhc2VcInpvb21cIjpcImltYWdlXCI9PWMudHlwZSYmKGMuaXNMb2FkZWR8fGMuJGdob3N0KSYmKHIuY2FuUGFuKCk/ci5zY2FsZVRvRml0KCk6ci5pc1NjYWxlZERvd24oKT9yLnNjYWxlVG9BY3R1YWwoZCx1KTpyLmdyb3VwLmxlbmd0aDwyJiZyLmNsb3NlKGkuc3RhcnRFdmVudCkpfX07aWYoKCFlLm9yaWdpbmFsRXZlbnR8fDIhPWUub3JpZ2luYWxFdmVudC5idXR0b24pJiYocy5pcyhcImltZ1wiKXx8IShkPnNbMF0uY2xpZW50V2lkdGgrcy5vZmZzZXQoKS5sZWZ0KSkpe2lmKHMuaXMoXCIuZmFuY3lib3gtYmcsLmZhbmN5Ym94LWlubmVyLC5mYW5jeWJveC1vdXRlciwuZmFuY3lib3gtY29udGFpbmVyXCIpKW89XCJPdXRzaWRlXCI7ZWxzZSBpZihzLmlzKFwiLmZhbmN5Ym94LXNsaWRlXCIpKW89XCJTbGlkZVwiO2Vsc2V7aWYoIXIuY3VycmVudC4kY29udGVudHx8IXIuY3VycmVudC4kY29udGVudC5maW5kKHMpLmFkZEJhY2soKS5maWx0ZXIocykubGVuZ3RoKXJldHVybjtvPVwiQ29udGVudFwifWlmKGkudGFwcGVkKXtpZihjbGVhclRpbWVvdXQoaS50YXBwZWQpLGkudGFwcGVkPW51bGwsTWF0aC5hYnMoZC1pLnRhcFgpPjUwfHxNYXRoLmFicyh1LWkudGFwWSk+NTApcmV0dXJuIHRoaXM7ZihcImRibGNsaWNrXCIrbyl9ZWxzZSBpLnRhcFg9ZCxpLnRhcFk9dSxjLm9wdHNbXCJkYmxjbGlja1wiK29dJiZjLm9wdHNbXCJkYmxjbGlja1wiK29dIT09Yy5vcHRzW1wiY2xpY2tcIitvXT9pLnRhcHBlZD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aS50YXBwZWQ9bnVsbCxyLmlzQW5pbWF0aW5nfHxmKFwiY2xpY2tcIitvKX0sNTAwKTpmKFwiY2xpY2tcIitvKTtyZXR1cm4gdGhpc319LG4oZSkub24oXCJvbkFjdGl2YXRlLmZiXCIsZnVuY3Rpb24odCxlKXtlJiYhZS5HdWVzdHVyZXMmJihlLkd1ZXN0dXJlcz1uZXcgZChlKSl9KS5vbihcImJlZm9yZUNsb3NlLmZiXCIsZnVuY3Rpb24odCxlKXtlJiZlLkd1ZXN0dXJlcyYmZS5HdWVzdHVyZXMuZGVzdHJveSgpfSl9KHdpbmRvdyxkb2N1bWVudCxqUXVlcnkpLGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHRlbmQoITAsZS5mYW5jeWJveC5kZWZhdWx0cyx7YnRuVHBsOntzbGlkZVNob3c6JzxidXR0b24gZGF0YS1mYW5jeWJveC1wbGF5IGNsYXNzPVwiZmFuY3lib3gtYnV0dG9uIGZhbmN5Ym94LWJ1dHRvbi0tcGxheVwiIHRpdGxlPVwie3tQTEFZX1NUQVJUfX1cIj48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk02LjUgNS40djEzLjJsMTEtNi42elwiLz48L3N2Zz48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk04LjMzIDUuNzVoMi4ydjEyLjVoLTIuMlY1Ljc1em01LjE1IDBoMi4ydjEyLjVoLTIuMlY1Ljc1elwiLz48L3N2Zz48L2J1dHRvbj4nfSxzbGlkZVNob3c6e2F1dG9TdGFydDohMSxzcGVlZDozZTMscHJvZ3Jlc3M6ITB9fSk7dmFyIG49ZnVuY3Rpb24odCl7dGhpcy5pbnN0YW5jZT10LHRoaXMuaW5pdCgpfTtlLmV4dGVuZChuLnByb3RvdHlwZSx7dGltZXI6bnVsbCxpc0FjdGl2ZTohMSwkYnV0dG9uOm51bGwsaW5pdDpmdW5jdGlvbigpe3ZhciB0PXRoaXMsbj10Lmluc3RhbmNlLG89bi5ncm91cFtuLmN1cnJJbmRleF0ub3B0cy5zbGlkZVNob3c7dC4kYnV0dG9uPW4uJHJlZnMudG9vbGJhci5maW5kKFwiW2RhdGEtZmFuY3lib3gtcGxheV1cIikub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7dC50b2dnbGUoKX0pLG4uZ3JvdXAubGVuZ3RoPDJ8fCFvP3QuJGJ1dHRvbi5oaWRlKCk6by5wcm9ncmVzcyYmKHQuJHByb2dyZXNzPWUoJzxkaXYgY2xhc3M9XCJmYW5jeWJveC1wcm9ncmVzc1wiPjwvZGl2PicpLmFwcGVuZFRvKG4uJHJlZnMuaW5uZXIpKX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMsbz1uLmluc3RhbmNlLGk9by5jdXJyZW50O2kmJighMD09PXR8fGkub3B0cy5sb29wfHxvLmN1cnJJbmRleDxvLmdyb3VwLmxlbmd0aC0xKT9uLmlzQWN0aXZlJiZcInZpZGVvXCIhPT1pLmNvbnRlbnRUeXBlJiYobi4kcHJvZ3Jlc3MmJmUuZmFuY3lib3guYW5pbWF0ZShuLiRwcm9ncmVzcy5zaG93KCkse3NjYWxlWDoxfSxpLm9wdHMuc2xpZGVTaG93LnNwZWVkKSxuLnRpbWVyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtvLmN1cnJlbnQub3B0cy5sb29wfHxvLmN1cnJlbnQuaW5kZXghPW8uZ3JvdXAubGVuZ3RoLTE/by5uZXh0KCk6by5qdW1wVG8oMCl9LGkub3B0cy5zbGlkZVNob3cuc3BlZWQpKToobi5zdG9wKCksby5pZGxlU2Vjb25kc0NvdW50ZXI9MCxvLnNob3dDb250cm9scygpKX0sY2xlYXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2NsZWFyVGltZW91dCh0LnRpbWVyKSx0LnRpbWVyPW51bGwsdC4kcHJvZ3Jlc3MmJnQuJHByb2dyZXNzLnJlbW92ZUF0dHIoXCJzdHlsZVwiKS5oaWRlKCl9LHN0YXJ0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuaW5zdGFuY2UuY3VycmVudDtlJiYodC4kYnV0dG9uLmF0dHIoXCJ0aXRsZVwiLChlLm9wdHMuaTE4bltlLm9wdHMubGFuZ118fGUub3B0cy5pMThuLmVuKS5QTEFZX1NUT1ApLnJlbW92ZUNsYXNzKFwiZmFuY3lib3gtYnV0dG9uLS1wbGF5XCIpLmFkZENsYXNzKFwiZmFuY3lib3gtYnV0dG9uLS1wYXVzZVwiKSx0LmlzQWN0aXZlPSEwLGUuaXNDb21wbGV0ZSYmdC5zZXQoITApLHQuaW5zdGFuY2UudHJpZ2dlcihcIm9uU2xpZGVTaG93Q2hhbmdlXCIsITApKX0sc3RvcDpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10Lmluc3RhbmNlLmN1cnJlbnQ7dC5jbGVhcigpLHQuJGJ1dHRvbi5hdHRyKFwidGl0bGVcIiwoZS5vcHRzLmkxOG5bZS5vcHRzLmxhbmddfHxlLm9wdHMuaTE4bi5lbikuUExBWV9TVEFSVCkucmVtb3ZlQ2xhc3MoXCJmYW5jeWJveC1idXR0b24tLXBhdXNlXCIpLmFkZENsYXNzKFwiZmFuY3lib3gtYnV0dG9uLS1wbGF5XCIpLHQuaXNBY3RpdmU9ITEsdC5pbnN0YW5jZS50cmlnZ2VyKFwib25TbGlkZVNob3dDaGFuZ2VcIiwhMSksdC4kcHJvZ3Jlc3MmJnQuJHByb2dyZXNzLnJlbW92ZUF0dHIoXCJzdHlsZVwiKS5oaWRlKCl9LHRvZ2dsZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dC5pc0FjdGl2ZT90LnN0b3AoKTp0LnN0YXJ0KCl9fSksZSh0KS5vbih7XCJvbkluaXQuZmJcIjpmdW5jdGlvbih0LGUpe2UmJiFlLlNsaWRlU2hvdyYmKGUuU2xpZGVTaG93PW5ldyBuKGUpKX0sXCJiZWZvcmVTaG93LmZiXCI6ZnVuY3Rpb24odCxlLG4sbyl7dmFyIGk9ZSYmZS5TbGlkZVNob3c7bz9pJiZuLm9wdHMuc2xpZGVTaG93LmF1dG9TdGFydCYmaS5zdGFydCgpOmkmJmkuaXNBY3RpdmUmJmkuY2xlYXIoKX0sXCJhZnRlclNob3cuZmJcIjpmdW5jdGlvbih0LGUsbil7dmFyIG89ZSYmZS5TbGlkZVNob3c7byYmby5pc0FjdGl2ZSYmby5zZXQoKX0sXCJhZnRlcktleWRvd24uZmJcIjpmdW5jdGlvbihuLG8saSxhLHMpe3ZhciByPW8mJm8uU2xpZGVTaG93OyFyfHwhaS5vcHRzLnNsaWRlU2hvd3x8ODAhPT1zJiYzMiE9PXN8fGUodC5hY3RpdmVFbGVtZW50KS5pcyhcImJ1dHRvbixhLGlucHV0XCIpfHwoYS5wcmV2ZW50RGVmYXVsdCgpLHIudG9nZ2xlKCkpfSxcImJlZm9yZUNsb3NlLmZiIG9uRGVhY3RpdmF0ZS5mYlwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZSYmZS5TbGlkZVNob3c7biYmbi5zdG9wKCl9fSksZSh0KS5vbihcInZpc2liaWxpdHljaGFuZ2VcIixmdW5jdGlvbigpe3ZhciBuPWUuZmFuY3lib3guZ2V0SW5zdGFuY2UoKSxvPW4mJm4uU2xpZGVTaG93O28mJm8uaXNBY3RpdmUmJih0LmhpZGRlbj9vLmNsZWFyKCk6by5zZXQoKSl9KX0oZG9jdW1lbnQsalF1ZXJ5KSxmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO3ZhciBuPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtbXCJyZXF1ZXN0RnVsbHNjcmVlblwiLFwiZXhpdEZ1bGxzY3JlZW5cIixcImZ1bGxzY3JlZW5FbGVtZW50XCIsXCJmdWxsc2NyZWVuRW5hYmxlZFwiLFwiZnVsbHNjcmVlbmNoYW5nZVwiLFwiZnVsbHNjcmVlbmVycm9yXCJdLFtcIndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuXCIsXCJ3ZWJraXRFeGl0RnVsbHNjcmVlblwiLFwid2Via2l0RnVsbHNjcmVlbkVsZW1lbnRcIixcIndlYmtpdEZ1bGxzY3JlZW5FbmFibGVkXCIsXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsXCJ3ZWJraXRmdWxsc2NyZWVuZXJyb3JcIl0sW1wid2Via2l0UmVxdWVzdEZ1bGxTY3JlZW5cIixcIndlYmtpdENhbmNlbEZ1bGxTY3JlZW5cIixcIndlYmtpdEN1cnJlbnRGdWxsU2NyZWVuRWxlbWVudFwiLFwid2Via2l0Q2FuY2VsRnVsbFNjcmVlblwiLFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLFwid2Via2l0ZnVsbHNjcmVlbmVycm9yXCJdLFtcIm1velJlcXVlc3RGdWxsU2NyZWVuXCIsXCJtb3pDYW5jZWxGdWxsU2NyZWVuXCIsXCJtb3pGdWxsU2NyZWVuRWxlbWVudFwiLFwibW96RnVsbFNjcmVlbkVuYWJsZWRcIixcIm1vemZ1bGxzY3JlZW5jaGFuZ2VcIixcIm1vemZ1bGxzY3JlZW5lcnJvclwiXSxbXCJtc1JlcXVlc3RGdWxsc2NyZWVuXCIsXCJtc0V4aXRGdWxsc2NyZWVuXCIsXCJtc0Z1bGxzY3JlZW5FbGVtZW50XCIsXCJtc0Z1bGxzY3JlZW5FbmFibGVkXCIsXCJNU0Z1bGxzY3JlZW5DaGFuZ2VcIixcIk1TRnVsbHNjcmVlbkVycm9yXCJdXSxuPXt9LG89MDtvPGUubGVuZ3RoO28rKyl7dmFyIGk9ZVtvXTtpZihpJiZpWzFdaW4gdCl7Zm9yKHZhciBhPTA7YTxpLmxlbmd0aDthKyspbltlWzBdW2FdXT1pW2FdO3JldHVybiBufX1yZXR1cm4hMX0oKTtpZihuKXt2YXIgbz17cmVxdWVzdDpmdW5jdGlvbihlKXtlPWV8fHQuZG9jdW1lbnRFbGVtZW50LGVbbi5yZXF1ZXN0RnVsbHNjcmVlbl0oZS5BTExPV19LRVlCT0FSRF9JTlBVVCl9LGV4aXQ6ZnVuY3Rpb24oKXt0W24uZXhpdEZ1bGxzY3JlZW5dKCl9LHRvZ2dsZTpmdW5jdGlvbihlKXtlPWV8fHQuZG9jdW1lbnRFbGVtZW50LHRoaXMuaXNGdWxsc2NyZWVuKCk/dGhpcy5leGl0KCk6dGhpcy5yZXF1ZXN0KGUpfSxpc0Z1bGxzY3JlZW46ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbih0W24uZnVsbHNjcmVlbkVsZW1lbnRdKX0sZW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKHRbbi5mdWxsc2NyZWVuRW5hYmxlZF0pfX07ZS5leHRlbmQoITAsZS5mYW5jeWJveC5kZWZhdWx0cyx7YnRuVHBsOntmdWxsU2NyZWVuOic8YnV0dG9uIGRhdGEtZmFuY3lib3gtZnVsbHNjcmVlbiBjbGFzcz1cImZhbmN5Ym94LWJ1dHRvbiBmYW5jeWJveC1idXR0b24tLWZzZW50ZXJcIiB0aXRsZT1cInt7RlVMTF9TQ1JFRU59fVwiPjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTcgMTRINXY1aDV2LTJIN3YtM3ptLTItNGgyVjdoM1Y1SDV2NXptMTIgN2gtM3YyaDV2LTVoLTJ2M3pNMTQgNXYyaDN2M2gyVjVoLTV6XCIvPjwvc3ZnPjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTUgMTZoM3YzaDJ2LTVINXptMy04SDV2Mmg1VjVIOHptNiAxMWgydi0zaDN2LTJoLTV6bTItMTFWNWgtMnY1aDVWOHpcIi8+PC9zdmc+PC9idXR0b24+J30sZnVsbFNjcmVlbjp7YXV0b1N0YXJ0OiExfX0pLGUodCkub24obi5mdWxsc2NyZWVuY2hhbmdlLGZ1bmN0aW9uKCl7dmFyIHQ9by5pc0Z1bGxzY3JlZW4oKSxuPWUuZmFuY3lib3guZ2V0SW5zdGFuY2UoKTtuJiYobi5jdXJyZW50JiZcImltYWdlXCI9PT1uLmN1cnJlbnQudHlwZSYmbi5pc0FuaW1hdGluZyYmKG4uaXNBbmltYXRpbmc9ITEsbi51cGRhdGUoITAsITAsMCksbi5pc0NvbXBsZXRlfHxuLmNvbXBsZXRlKCkpLG4udHJpZ2dlcihcIm9uRnVsbHNjcmVlbkNoYW5nZVwiLHQpLG4uJHJlZnMuY29udGFpbmVyLnRvZ2dsZUNsYXNzKFwiZmFuY3lib3gtaXMtZnVsbHNjcmVlblwiLHQpLG4uJHJlZnMudG9vbGJhci5maW5kKFwiW2RhdGEtZmFuY3lib3gtZnVsbHNjcmVlbl1cIikudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1idXR0b24tLWZzZW50ZXJcIiwhdCkudG9nZ2xlQ2xhc3MoXCJmYW5jeWJveC1idXR0b24tLWZzZXhpdFwiLHQpKX0pfWUodCkub24oe1wib25Jbml0LmZiXCI6ZnVuY3Rpb24odCxlKXt2YXIgaTtpZighbilyZXR1cm4gdm9pZCBlLiRyZWZzLnRvb2xiYXIuZmluZChcIltkYXRhLWZhbmN5Ym94LWZ1bGxzY3JlZW5dXCIpLnJlbW92ZSgpO2UmJmUuZ3JvdXBbZS5jdXJySW5kZXhdLm9wdHMuZnVsbFNjcmVlbj8oaT1lLiRyZWZzLmNvbnRhaW5lcixpLm9uKFwiY2xpY2suZmItZnVsbHNjcmVlblwiLFwiW2RhdGEtZmFuY3lib3gtZnVsbHNjcmVlbl1cIixmdW5jdGlvbih0KXt0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSxvLnRvZ2dsZSgpfSksZS5vcHRzLmZ1bGxTY3JlZW4mJiEwPT09ZS5vcHRzLmZ1bGxTY3JlZW4uYXV0b1N0YXJ0JiZvLnJlcXVlc3QoKSxlLkZ1bGxTY3JlZW49byk6ZSYmZS4kcmVmcy50b29sYmFyLmZpbmQoXCJbZGF0YS1mYW5jeWJveC1mdWxsc2NyZWVuXVwiKS5oaWRlKCl9LFwiYWZ0ZXJLZXlkb3duLmZiXCI6ZnVuY3Rpb24odCxlLG4sbyxpKXtlJiZlLkZ1bGxTY3JlZW4mJjcwPT09aSYmKG8ucHJldmVudERlZmF1bHQoKSxlLkZ1bGxTY3JlZW4udG9nZ2xlKCkpfSxcImJlZm9yZUNsb3NlLmZiXCI6ZnVuY3Rpb24odCxlKXtlJiZlLkZ1bGxTY3JlZW4mJmUuJHJlZnMuY29udGFpbmVyLmhhc0NsYXNzKFwiZmFuY3lib3gtaXMtZnVsbHNjcmVlblwiKSYmby5leGl0KCl9fSl9KGRvY3VtZW50LGpRdWVyeSksZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1cImZhbmN5Ym94LXRodW1ic1wiO2UuZmFuY3lib3guZGVmYXVsdHM9ZS5leHRlbmQoITAse2J0blRwbDp7dGh1bWJzOic8YnV0dG9uIGRhdGEtZmFuY3lib3gtdGh1bWJzIGNsYXNzPVwiZmFuY3lib3gtYnV0dG9uIGZhbmN5Ym94LWJ1dHRvbi0tdGh1bWJzXCIgdGl0bGU9XCJ7e1RIVU1CU319XCI+PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMTQuNTkgMTQuNTloMy43NnYzLjc2aC0zLjc2di0zLjc2em0tNC40NyAwaDMuNzZ2My43NmgtMy43NnYtMy43NnptLTQuNDcgMGgzLjc2djMuNzZINS42NXYtMy43NnptOC45NC00LjQ3aDMuNzZ2My43NmgtMy43NnYtMy43NnptLTQuNDcgMGgzLjc2djMuNzZoLTMuNzZ2LTMuNzZ6bS00LjQ3IDBoMy43NnYzLjc2SDUuNjV2LTMuNzZ6bTguOTQtNC40N2gzLjc2djMuNzZoLTMuNzZWNS42NXptLTQuNDcgMGgzLjc2djMuNzZoLTMuNzZWNS42NXptLTQuNDcgMGgzLjc2djMuNzZINS42NVY1LjY1elwiLz48L3N2Zz48L2J1dHRvbj4nfSx0aHVtYnM6e2F1dG9TdGFydDohMSxoaWRlT25DbG9zZTohMCxwYXJlbnRFbDpcIi5mYW5jeWJveC1jb250YWluZXJcIixheGlzOlwieVwifX0sZS5mYW5jeWJveC5kZWZhdWx0cyk7dmFyIG89ZnVuY3Rpb24odCl7dGhpcy5pbml0KHQpfTtlLmV4dGVuZChvLnByb3RvdHlwZSx7JGJ1dHRvbjpudWxsLCRncmlkOm51bGwsJGxpc3Q6bnVsbCxpc1Zpc2libGU6ITEsaXNBY3RpdmU6ITEsaW5pdDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dC5ncm91cCxvPTA7ZS5pbnN0YW5jZT10LGUub3B0cz1uW3QuY3VyckluZGV4XS5vcHRzLnRodW1icyx0LlRodW1icz1lLGUuJGJ1dHRvbj10LiRyZWZzLnRvb2xiYXIuZmluZChcIltkYXRhLWZhbmN5Ym94LXRodW1ic11cIik7Zm9yKHZhciBpPTAsYT1uLmxlbmd0aDtpPGEmJihuW2ldLnRodW1iJiZvKyssIShvPjEpKTtpKyspO28+MSYmZS5vcHRzPyhlLiRidXR0b24ucmVtb3ZlQXR0cihcInN0eWxlXCIpLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe2UudG9nZ2xlKCl9KSxlLmlzQWN0aXZlPSEwKTplLiRidXR0b24uaGlkZSgpfSxjcmVhdGU6ZnVuY3Rpb24oKXt2YXIgdCxvPXRoaXMsaT1vLmluc3RhbmNlLGE9by5vcHRzLnBhcmVudEVsLHM9W107by4kZ3JpZHx8KG8uJGdyaWQ9ZSgnPGRpdiBjbGFzcz1cIicrbitcIiBcIituK1wiLVwiK28ub3B0cy5heGlzKydcIj48L2Rpdj4nKS5hcHBlbmRUbyhpLiRyZWZzLmNvbnRhaW5lci5maW5kKGEpLmFkZEJhY2soKS5maWx0ZXIoYSkpLG8uJGdyaWQub24oXCJjbGlja1wiLFwiYVwiLGZ1bmN0aW9uKCl7aS5qdW1wVG8oZSh0aGlzKS5hdHRyKFwiZGF0YS1pbmRleFwiKSl9KSksby4kbGlzdHx8KG8uJGxpc3Q9ZSgnPGRpdiBjbGFzcz1cIicrbisnX19saXN0XCI+JykuYXBwZW5kVG8oby4kZ3JpZCkpLGUuZWFjaChpLmdyb3VwLGZ1bmN0aW9uKGUsbil7dD1uLnRodW1iLHR8fFwiaW1hZ2VcIiE9PW4udHlwZXx8KHQ9bi5zcmMpLHMucHVzaCgnPGEgaHJlZj1cImphdmFzY3JpcHQ6O1wiIHRhYmluZGV4PVwiMFwiIGRhdGEtaW5kZXg9XCInK2UrJ1wiJysodCYmdC5sZW5ndGg/JyBzdHlsZT1cImJhY2tncm91bmQtaW1hZ2U6dXJsKCcrdCsnKVwiJzonY2xhc3M9XCJmYW5jeWJveC10aHVtYnMtbWlzc2luZ1wiJykrXCI+PC9hPlwiKX0pLG8uJGxpc3RbMF0uaW5uZXJIVE1MPXMuam9pbihcIlwiKSxcInhcIj09PW8ub3B0cy5heGlzJiZvLiRsaXN0LndpZHRoKHBhcnNlSW50KG8uJGdyaWQuY3NzKFwicGFkZGluZy1yaWdodFwiKSwxMCkraS5ncm91cC5sZW5ndGgqby4kbGlzdC5jaGlsZHJlbigpLmVxKDApLm91dGVyV2lkdGgoITApKX0sZm9jdXM6ZnVuY3Rpb24odCl7dmFyIGUsbixvPXRoaXMsaT1vLiRsaXN0LGE9by4kZ3JpZDtvLmluc3RhbmNlLmN1cnJlbnQmJihlPWkuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhcImZhbmN5Ym94LXRodW1icy1hY3RpdmVcIikuZmlsdGVyKCdbZGF0YS1pbmRleD1cIicrby5pbnN0YW5jZS5jdXJyZW50LmluZGV4KydcIl0nKS5hZGRDbGFzcyhcImZhbmN5Ym94LXRodW1icy1hY3RpdmVcIiksbj1lLnBvc2l0aW9uKCksXCJ5XCI9PT1vLm9wdHMuYXhpcyYmKG4udG9wPDB8fG4udG9wPmkuaGVpZ2h0KCktZS5vdXRlckhlaWdodCgpKT9pLnN0b3AoKS5hbmltYXRlKHtzY3JvbGxUb3A6aS5zY3JvbGxUb3AoKStuLnRvcH0sdCk6XCJ4XCI9PT1vLm9wdHMuYXhpcyYmKG4ubGVmdDxhLnNjcm9sbExlZnQoKXx8bi5sZWZ0PmEuc2Nyb2xsTGVmdCgpKyhhLndpZHRoKCktZS5vdXRlcldpZHRoKCkpKSYmaS5wYXJlbnQoKS5zdG9wKCkuYW5pbWF0ZSh7c2Nyb2xsTGVmdDpuLmxlZnR9LHQpKX0sdXBkYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0Lmluc3RhbmNlLiRyZWZzLmNvbnRhaW5lci50b2dnbGVDbGFzcyhcImZhbmN5Ym94LXNob3ctdGh1bWJzXCIsdGhpcy5pc1Zpc2libGUpLHQuaXNWaXNpYmxlPyh0LiRncmlkfHx0LmNyZWF0ZSgpLHQuaW5zdGFuY2UudHJpZ2dlcihcIm9uVGh1bWJzU2hvd1wiKSx0LmZvY3VzKDApKTp0LiRncmlkJiZ0Lmluc3RhbmNlLnRyaWdnZXIoXCJvblRodW1ic0hpZGVcIiksdC5pbnN0YW5jZS51cGRhdGUoKX0saGlkZTpmdW5jdGlvbigpe3RoaXMuaXNWaXNpYmxlPSExLHRoaXMudXBkYXRlKCl9LHNob3c6ZnVuY3Rpb24oKXt0aGlzLmlzVmlzaWJsZT0hMCx0aGlzLnVwZGF0ZSgpfSx0b2dnbGU6ZnVuY3Rpb24oKXt0aGlzLmlzVmlzaWJsZT0hdGhpcy5pc1Zpc2libGUsdGhpcy51cGRhdGUoKX19KSxlKHQpLm9uKHtcIm9uSW5pdC5mYlwiOmZ1bmN0aW9uKHQsZSl7dmFyIG47ZSYmIWUuVGh1bWJzJiYobj1uZXcgbyhlKSxuLmlzQWN0aXZlJiYhMD09PW4ub3B0cy5hdXRvU3RhcnQmJm4uc2hvdygpKX0sXCJiZWZvcmVTaG93LmZiXCI6ZnVuY3Rpb24odCxlLG4sbyl7dmFyIGk9ZSYmZS5UaHVtYnM7aSYmaS5pc1Zpc2libGUmJmkuZm9jdXMobz8wOjI1MCl9LFwiYWZ0ZXJLZXlkb3duLmZiXCI6ZnVuY3Rpb24odCxlLG4sbyxpKXt2YXIgYT1lJiZlLlRodW1iczthJiZhLmlzQWN0aXZlJiY3MT09PWkmJihvLnByZXZlbnREZWZhdWx0KCksYS50b2dnbGUoKSl9LFwiYmVmb3JlQ2xvc2UuZmJcIjpmdW5jdGlvbih0LGUpe3ZhciBuPWUmJmUuVGh1bWJzO24mJm4uaXNWaXNpYmxlJiYhMSE9PW4ub3B0cy5oaWRlT25DbG9zZSYmbi4kZ3JpZC5oaWRlKCl9fSl9KGRvY3VtZW50LGpRdWVyeSksZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKHQpe3ZhciBlPXtcIiZcIjpcIiZhbXA7XCIsXCI8XCI6XCImbHQ7XCIsXCI+XCI6XCImZ3Q7XCIsJ1wiJzpcIiZxdW90O1wiLFwiJ1wiOlwiJiMzOTtcIixcIi9cIjpcIiYjeDJGO1wiLFwiYFwiOlwiJiN4NjA7XCIsXCI9XCI6XCImI3gzRDtcIn07cmV0dXJuIFN0cmluZyh0KS5yZXBsYWNlKC9bJjw+XCInYD1cXC9dL2csZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19KX1lLmV4dGVuZCghMCxlLmZhbmN5Ym94LmRlZmF1bHRzLHtidG5UcGw6e3NoYXJlOic8YnV0dG9uIGRhdGEtZmFuY3lib3gtc2hhcmUgY2xhc3M9XCJmYW5jeWJveC1idXR0b24gZmFuY3lib3gtYnV0dG9uLS1zaGFyZVwiIHRpdGxlPVwie3tTSEFSRX19XCI+PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMi41NSAxOWMxLjQtOC40IDkuMS05LjggMTEuOS05LjhWNWw3IDctNyA2LjN2LTMuNWMtMi44IDAtMTAuNSAyLjEtMTEuOSA0LjJ6XCIvPjwvc3ZnPjwvYnV0dG9uPid9LHNoYXJlOnt1cmw6ZnVuY3Rpb24odCxlKXtyZXR1cm4hdC5jdXJyZW50SGFzaCYmXCJpbmxpbmVcIiE9PWUudHlwZSYmXCJodG1sXCIhPT1lLnR5cGUmJihlLm9yaWdTcmN8fGUuc3JjKXx8d2luZG93LmxvY2F0aW9ufSxcbnRwbDonPGRpdiBjbGFzcz1cImZhbmN5Ym94LXNoYXJlXCI+PGgxPnt7U0hBUkV9fTwvaDE+PHA+PGEgY2xhc3M9XCJmYW5jeWJveC1zaGFyZV9fYnV0dG9uIGZhbmN5Ym94LXNoYXJlX19idXR0b24tLWZiXCIgaHJlZj1cImh0dHBzOi8vd3d3LmZhY2Vib29rLmNvbS9zaGFyZXIvc2hhcmVyLnBocD91PXt7dXJsfX1cIj48c3ZnIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwibTI4NyA0NTZ2LTI5OWMwLTIxIDYtMzUgMzUtMzVoMzh2LTYzYy03LTEtMjktMy01NS0zLTU0IDAtOTEgMzMtOTEgOTR2MzA2bTE0My0yNTRoLTIwNXY3MmgxOTZcIiAvPjwvc3ZnPjxzcGFuPkZhY2Vib29rPC9zcGFuPjwvYT48YSBjbGFzcz1cImZhbmN5Ym94LXNoYXJlX19idXR0b24gZmFuY3lib3gtc2hhcmVfX2J1dHRvbi0tdHdcIiBocmVmPVwiaHR0cHM6Ly90d2l0dGVyLmNvbS9pbnRlbnQvdHdlZXQ/dXJsPXt7dXJsfX0mdGV4dD17e2Rlc2NyfX1cIj48c3ZnIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwibTQ1NiAxMzNjLTE0IDctMzEgMTEtNDcgMTMgMTctMTAgMzAtMjcgMzctNDYtMTUgMTAtMzQgMTYtNTIgMjAtNjEtNjItMTU3LTctMTQxIDc1LTY4LTMtMTI5LTM1LTE2OS04NS0yMiAzNy0xMSA4NiAyNiAxMDktMTMgMC0yNi00LTM3LTkgMCAzOSAyOCA3MiA2NSA4MC0xMiAzLTI1IDQtMzcgMiAxMCAzMyA0MSA1NyA3NyA1Ny00MiAzMC03NyAzOC0xMjIgMzQgMTcwIDExMSAzNzgtMzIgMzU5LTIwOCAxNi0xMSAzMC0yNSA0MS00MnpcIiAvPjwvc3ZnPjxzcGFuPlR3aXR0ZXI8L3NwYW4+PC9hPjxhIGNsYXNzPVwiZmFuY3lib3gtc2hhcmVfX2J1dHRvbiBmYW5jeWJveC1zaGFyZV9fYnV0dG9uLS1wdFwiIGhyZWY9XCJodHRwczovL3d3dy5waW50ZXJlc3QuY29tL3Bpbi9jcmVhdGUvYnV0dG9uLz91cmw9e3t1cmx9fSZkZXNjcmlwdGlvbj17e2Rlc2NyfX0mbWVkaWE9e3ttZWRpYX19XCI+PHN2ZyB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIm0yNjUgNTZjLTEwOSAwLTE2NCA3OC0xNjQgMTQ0IDAgMzkgMTUgNzQgNDcgODcgNSAyIDEwIDAgMTItNWw0LTE5YzItNiAxLTgtMy0xMy05LTExLTE1LTI1LTE1LTQ1IDAtNTggNDMtMTEwIDExMy0xMTAgNjIgMCA5NiAzOCA5NiA4OCAwIDY3LTMwIDEyMi03MyAxMjItMjQgMC00Mi0xOS0zNi00NCA2LTI5IDIwLTYwIDIwLTgxIDAtMTktMTAtMzUtMzEtMzUtMjUgMC00NCAyNi00NCA2MCAwIDIxIDcgMzYgNyAzNmwtMzAgMTI1Yy04IDM3LTEgODMgMCA4NyAwIDMgNCA0IDUgMiAyLTMgMzItMzkgNDItNzVsMTYtNjRjOCAxNiAzMSAyOSA1NiAyOSA3NCAwIDEyNC02NyAxMjQtMTU3IDAtNjktNTgtMTMyLTE0Ni0xMzJ6XCIgZmlsbD1cIiNmZmZcIi8+PC9zdmc+PHNwYW4+UGludGVyZXN0PC9zcGFuPjwvYT48L3A+PHA+PGlucHV0IGNsYXNzPVwiZmFuY3lib3gtc2hhcmVfX2lucHV0XCIgdHlwZT1cInRleHRcIiB2YWx1ZT1cInt7dXJsX3Jhd319XCIgb25jbGljaz1cInNlbGVjdCgpXCIgLz48L3A+PC9kaXY+J319KSxlKHQpLm9uKFwiY2xpY2tcIixcIltkYXRhLWZhbmN5Ym94LXNoYXJlXVwiLGZ1bmN0aW9uKCl7dmFyIHQsbyxpPWUuZmFuY3lib3guZ2V0SW5zdGFuY2UoKSxhPWkuY3VycmVudHx8bnVsbDthJiYoXCJmdW5jdGlvblwiPT09ZS50eXBlKGEub3B0cy5zaGFyZS51cmwpJiYodD1hLm9wdHMuc2hhcmUudXJsLmFwcGx5KGEsW2ksYV0pKSxvPWEub3B0cy5zaGFyZS50cGwucmVwbGFjZSgvXFx7XFx7bWVkaWFcXH1cXH0vZyxcImltYWdlXCI9PT1hLnR5cGU/ZW5jb2RlVVJJQ29tcG9uZW50KGEuc3JjKTpcIlwiKS5yZXBsYWNlKC9cXHtcXHt1cmxcXH1cXH0vZyxlbmNvZGVVUklDb21wb25lbnQodCkpLnJlcGxhY2UoL1xce1xce3VybF9yYXdcXH1cXH0vZyxuKHQpKS5yZXBsYWNlKC9cXHtcXHtkZXNjclxcfVxcfS9nLGkuJGNhcHRpb24/ZW5jb2RlVVJJQ29tcG9uZW50KGkuJGNhcHRpb24udGV4dCgpKTpcIlwiKSxlLmZhbmN5Ym94Lm9wZW4oe3NyYzppLnRyYW5zbGF0ZShpLG8pLHR5cGU6XCJodG1sXCIsb3B0czp7dG91Y2g6ITEsYW5pbWF0aW9uRWZmZWN0OiExLGFmdGVyTG9hZDpmdW5jdGlvbih0LGUpe2kuJHJlZnMuY29udGFpbmVyLm9uZShcImJlZm9yZUNsb3NlLmZiXCIsZnVuY3Rpb24oKXt0LmNsb3NlKG51bGwsMCl9KSxlLiRjb250ZW50LmZpbmQoXCIuZmFuY3lib3gtc2hhcmVfX2J1dHRvblwiKS5jbGljayhmdW5jdGlvbigpe3JldHVybiB3aW5kb3cub3Blbih0aGlzLmhyZWYsXCJTaGFyZVwiLFwid2lkdGg9NTUwLCBoZWlnaHQ9NDUwXCIpLCExfSl9LG1vYmlsZTp7YXV0b0ZvY3VzOiExfX19KSl9KX0oZG9jdW1lbnQsalF1ZXJ5KSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbygpe3ZhciBlPXQubG9jYXRpb24uaGFzaC5zdWJzdHIoMSksbj1lLnNwbGl0KFwiLVwiKSxvPW4ubGVuZ3RoPjEmJi9eXFwrP1xcZCskLy50ZXN0KG5bbi5sZW5ndGgtMV0pP3BhcnNlSW50KG4ucG9wKC0xKSwxMCl8fDE6MSxpPW4uam9pbihcIi1cIik7cmV0dXJue2hhc2g6ZSxpbmRleDpvPDE/MTpvLGdhbGxlcnk6aX19ZnVuY3Rpb24gaSh0KXtcIlwiIT09dC5nYWxsZXJ5JiZuKFwiW2RhdGEtZmFuY3lib3g9J1wiK24uZXNjYXBlU2VsZWN0b3IodC5nYWxsZXJ5KStcIiddXCIpLmVxKHQuaW5kZXgtMSkuZm9jdXMoKS50cmlnZ2VyKFwiY2xpY2suZmItc3RhcnRcIil9ZnVuY3Rpb24gYSh0KXt2YXIgZSxuO3JldHVybiEhdCYmKGU9dC5jdXJyZW50P3QuY3VycmVudC5vcHRzOnQub3B0cyxcIlwiIT09KG49ZS5oYXNofHwoZS4kb3JpZz9lLiRvcmlnLmRhdGEoXCJmYW5jeWJveFwiKXx8ZS4kb3JpZy5kYXRhKFwiZmFuY3lib3gtdHJpZ2dlclwiKTpcIlwiKSkmJm4pfW4uZXNjYXBlU2VsZWN0b3J8fChuLmVzY2FwZVNlbGVjdG9yPWZ1bmN0aW9uKHQpe3JldHVybih0K1wiXCIpLnJlcGxhY2UoLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFx4ODAtXFx1RkZGRlxcdy1dL2csZnVuY3Rpb24odCxlKXtyZXR1cm4gZT9cIlxcMFwiPT09dD9cIu+/vVwiOnQuc2xpY2UoMCwtMSkrXCJcXFxcXCIrdC5jaGFyQ29kZUF0KHQubGVuZ3RoLTEpLnRvU3RyaW5nKDE2KStcIiBcIjpcIlxcXFxcIit0fSl9KSxuKGZ1bmN0aW9uKCl7ITEhPT1uLmZhbmN5Ym94LmRlZmF1bHRzLmhhc2gmJihuKGUpLm9uKHtcIm9uSW5pdC5mYlwiOmZ1bmN0aW9uKHQsZSl7dmFyIG4saTshMSE9PWUuZ3JvdXBbZS5jdXJySW5kZXhdLm9wdHMuaGFzaCYmKG49bygpLChpPWEoZSkpJiZuLmdhbGxlcnkmJmk9PW4uZ2FsbGVyeSYmKGUuY3VyckluZGV4PW4uaW5kZXgtMSkpfSxcImJlZm9yZVNob3cuZmJcIjpmdW5jdGlvbihuLG8saSxzKXt2YXIgcjtpJiYhMSE9PWkub3B0cy5oYXNoJiYocj1hKG8pKSYmKG8uY3VycmVudEhhc2g9cisoby5ncm91cC5sZW5ndGg+MT9cIi1cIisoaS5pbmRleCsxKTpcIlwiKSx0LmxvY2F0aW9uLmhhc2ghPT1cIiNcIitvLmN1cnJlbnRIYXNoJiYocyYmIW8ub3JpZ0hhc2gmJihvLm9yaWdIYXNoPXQubG9jYXRpb24uaGFzaCksby5oYXNoVGltZXImJmNsZWFyVGltZW91dChvLmhhc2hUaW1lciksby5oYXNoVGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe1wicmVwbGFjZVN0YXRlXCJpbiB0Lmhpc3Rvcnk/KHQuaGlzdG9yeVtzP1wicHVzaFN0YXRlXCI6XCJyZXBsYWNlU3RhdGVcIl0oe30sZS50aXRsZSx0LmxvY2F0aW9uLnBhdGhuYW1lK3QubG9jYXRpb24uc2VhcmNoK1wiI1wiK28uY3VycmVudEhhc2gpLHMmJihvLmhhc0NyZWF0ZWRIaXN0b3J5PSEwKSk6dC5sb2NhdGlvbi5oYXNoPW8uY3VycmVudEhhc2gsby5oYXNoVGltZXI9bnVsbH0sMzAwKSkpfSxcImJlZm9yZUNsb3NlLmZiXCI6ZnVuY3Rpb24obixvLGkpe2kmJiExIT09aS5vcHRzLmhhc2gmJihjbGVhclRpbWVvdXQoby5oYXNoVGltZXIpLG8uY3VycmVudEhhc2gmJm8uaGFzQ3JlYXRlZEhpc3Rvcnk/dC5oaXN0b3J5LmJhY2soKTpvLmN1cnJlbnRIYXNoJiYoXCJyZXBsYWNlU3RhdGVcImluIHQuaGlzdG9yeT90Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LGUudGl0bGUsdC5sb2NhdGlvbi5wYXRobmFtZSt0LmxvY2F0aW9uLnNlYXJjaCsoby5vcmlnSGFzaHx8XCJcIikpOnQubG9jYXRpb24uaGFzaD1vLm9yaWdIYXNoKSxvLmN1cnJlbnRIYXNoPW51bGwpfX0pLG4odCkub24oXCJoYXNoY2hhbmdlLmZiXCIsZnVuY3Rpb24oKXt2YXIgdD1vKCksZT1udWxsO24uZWFjaChuKFwiLmZhbmN5Ym94LWNvbnRhaW5lclwiKS5nZXQoKS5yZXZlcnNlKCksZnVuY3Rpb24odCxvKXt2YXIgaT1uKG8pLmRhdGEoXCJGYW5jeUJveFwiKTtpZihpJiZpLmN1cnJlbnRIYXNoKXJldHVybiBlPWksITF9KSxlP2UuY3VycmVudEhhc2g9PT10LmdhbGxlcnkrXCItXCIrdC5pbmRleHx8MT09PXQuaW5kZXgmJmUuY3VycmVudEhhc2g9PXQuZ2FsbGVyeXx8KGUuY3VycmVudEhhc2g9bnVsbCxlLmNsb3NlKCkpOlwiXCIhPT10LmdhbGxlcnkmJmkodCl9KSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bi5mYW5jeWJveC5nZXRJbnN0YW5jZSgpfHxpKG8oKSl9LDUwKSl9KX0od2luZG93LGRvY3VtZW50LGpRdWVyeSksZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjt2YXIgbj0obmV3IERhdGUpLmdldFRpbWUoKTtlKHQpLm9uKHtcIm9uSW5pdC5mYlwiOmZ1bmN0aW9uKHQsZSxvKXtlLiRyZWZzLnN0YWdlLm9uKFwibW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbCB3aGVlbCBNb3pNb3VzZVBpeGVsU2Nyb2xsXCIsZnVuY3Rpb24odCl7dmFyIG89ZS5jdXJyZW50LGk9KG5ldyBEYXRlKS5nZXRUaW1lKCk7ZS5ncm91cC5sZW5ndGg8Mnx8ITE9PT1vLm9wdHMud2hlZWx8fFwiYXV0b1wiPT09by5vcHRzLndoZWVsJiZcImltYWdlXCIhPT1vLnR5cGV8fCh0LnByZXZlbnREZWZhdWx0KCksdC5zdG9wUHJvcGFnYXRpb24oKSxvLiRzbGlkZS5oYXNDbGFzcyhcImZhbmN5Ym94LWFuaW1hdGVkXCIpfHwodD10Lm9yaWdpbmFsRXZlbnR8fHQsaS1uPDI1MHx8KG49aSxlWygtdC5kZWx0YVl8fC10LmRlbHRhWHx8dC53aGVlbERlbHRhfHwtdC5kZXRhaWwpPDA/XCJuZXh0XCI6XCJwcmV2aW91c1wiXSgpKSkpfSl9fSl9KGRvY3VtZW50LGpRdWVyeSk7IiwiLypcbiAqIEludGVybmF0aW9uYWwgVGVsZXBob25lIElucHV0IHYxOC4yLjFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qYWNrb2Nuci9pbnRsLXRlbC1pbnB1dC5naXRcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cbiFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihhLGIsYyl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZChhLGIpe2lmKCEoYSBpbnN0YW5jZW9mIGIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gZShhLGIpe2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7YysrKXt2YXIgZD1iW2NdO2QuZW51bWVyYWJsZT1kLmVudW1lcmFibGV8fCExLGQuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGQmJihkLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxkLmtleSxkKX19ZnVuY3Rpb24gZihhLGIsYyl7cmV0dXJuIGImJmUoYS5wcm90b3R5cGUsYiksYyYmZShhLGMpLGF9Zm9yKHZhciBnPVtbXCJBZmdoYW5pc3RhbiAo4oCr2KfZgdi62KfZhtiz2KrYp9mG4oCs4oCOKVwiLFwiYWZcIixcIjkzXCJdLFtcIkFsYmFuaWEgKFNocWlww6tyaSlcIixcImFsXCIsXCIzNTVcIl0sW1wiQWxnZXJpYSAo4oCr2KfZhNis2LLYp9im2LHigKzigI4pXCIsXCJkelwiLFwiMjEzXCJdLFtcIkFtZXJpY2FuIFNhbW9hXCIsXCJhc1wiLFwiMVwiLDUsW1wiNjg0XCJdXSxbXCJBbmRvcnJhXCIsXCJhZFwiLFwiMzc2XCJdLFtcIkFuZ29sYVwiLFwiYW9cIixcIjI0NFwiXSxbXCJBbmd1aWxsYVwiLFwiYWlcIixcIjFcIiw2LFtcIjI2NFwiXV0sW1wiQW50aWd1YSBhbmQgQmFyYnVkYVwiLFwiYWdcIixcIjFcIiw3LFtcIjI2OFwiXV0sW1wiQXJnZW50aW5hXCIsXCJhclwiLFwiNTRcIl0sW1wiQXJtZW5pYSAo1YDVodW11aHVvdW/1aHVtilcIixcImFtXCIsXCIzNzRcIl0sW1wiQXJ1YmFcIixcImF3XCIsXCIyOTdcIl0sW1wiQXVzdHJhbGlhXCIsXCJhdVwiLFwiNjFcIiwwXSxbXCJBdXN0cmlhICjDlnN0ZXJyZWljaClcIixcImF0XCIsXCI0M1wiXSxbXCJBemVyYmFpamFuIChBesmZcmJheWNhbilcIixcImF6XCIsXCI5OTRcIl0sW1wiQmFoYW1hc1wiLFwiYnNcIixcIjFcIiw4LFtcIjI0MlwiXV0sW1wiQmFocmFpbiAo4oCr2KfZhNio2K3YsdmK2YbigKzigI4pXCIsXCJiaFwiLFwiOTczXCJdLFtcIkJhbmdsYWRlc2ggKOCmrOCmvuCmguCmsuCmvuCmpuCnh+CmtilcIixcImJkXCIsXCI4ODBcIl0sW1wiQmFyYmFkb3NcIixcImJiXCIsXCIxXCIsOSxbXCIyNDZcIl1dLFtcIkJlbGFydXMgKNCR0LXQu9Cw0YDRg9GB0YwpXCIsXCJieVwiLFwiMzc1XCJdLFtcIkJlbGdpdW0gKEJlbGdpw6spXCIsXCJiZVwiLFwiMzJcIl0sW1wiQmVsaXplXCIsXCJielwiLFwiNTAxXCJdLFtcIkJlbmluIChCw6luaW4pXCIsXCJialwiLFwiMjI5XCJdLFtcIkJlcm11ZGFcIixcImJtXCIsXCIxXCIsMTAsW1wiNDQxXCJdXSxbXCJCaHV0YW4gKOC9oOC9luC+suC9tOC9gilcIixcImJ0XCIsXCI5NzVcIl0sW1wiQm9saXZpYVwiLFwiYm9cIixcIjU5MVwiXSxbXCJCb3NuaWEgYW5kIEhlcnplZ292aW5hICjQkdC+0YHQvdCwINC4INCl0LXRgNGG0LXQs9C+0LLQuNC90LApXCIsXCJiYVwiLFwiMzg3XCJdLFtcIkJvdHN3YW5hXCIsXCJid1wiLFwiMjY3XCJdLFtcIkJyYXppbCAoQnJhc2lsKVwiLFwiYnJcIixcIjU1XCJdLFtcIkJyaXRpc2ggSW5kaWFuIE9jZWFuIFRlcnJpdG9yeVwiLFwiaW9cIixcIjI0NlwiXSxbXCJCcml0aXNoIFZpcmdpbiBJc2xhbmRzXCIsXCJ2Z1wiLFwiMVwiLDExLFtcIjI4NFwiXV0sW1wiQnJ1bmVpXCIsXCJiblwiLFwiNjczXCJdLFtcIkJ1bGdhcmlhICjQkdGK0LvQs9Cw0YDQuNGPKVwiLFwiYmdcIixcIjM1OVwiXSxbXCJCdXJraW5hIEZhc29cIixcImJmXCIsXCIyMjZcIl0sW1wiQnVydW5kaSAoVWJ1cnVuZGkpXCIsXCJiaVwiLFwiMjU3XCJdLFtcIkNhbWJvZGlhICjhnoDhnpjhn5LhnpbhnrvhnofhnrYpXCIsXCJraFwiLFwiODU1XCJdLFtcIkNhbWVyb29uIChDYW1lcm91bilcIixcImNtXCIsXCIyMzdcIl0sW1wiQ2FuYWRhXCIsXCJjYVwiLFwiMVwiLDEsW1wiMjA0XCIsXCIyMjZcIixcIjIzNlwiLFwiMjQ5XCIsXCIyNTBcIixcIjI4OVwiLFwiMzA2XCIsXCIzNDNcIixcIjM2NVwiLFwiMzg3XCIsXCI0MDNcIixcIjQxNlwiLFwiNDE4XCIsXCI0MzFcIixcIjQzN1wiLFwiNDM4XCIsXCI0NTBcIixcIjUwNlwiLFwiNTE0XCIsXCI1MTlcIixcIjU0OFwiLFwiNTc5XCIsXCI1ODFcIixcIjU4N1wiLFwiNjA0XCIsXCI2MTNcIixcIjYzOVwiLFwiNjQ3XCIsXCI2NzJcIixcIjcwNVwiLFwiNzA5XCIsXCI3NDJcIixcIjc3OFwiLFwiNzgwXCIsXCI3ODJcIixcIjgwN1wiLFwiODE5XCIsXCI4MjVcIixcIjg2N1wiLFwiODczXCIsXCI5MDJcIixcIjkwNVwiXV0sW1wiQ2FwZSBWZXJkZSAoS2FidSBWZXJkaSlcIixcImN2XCIsXCIyMzhcIl0sW1wiQ2FyaWJiZWFuIE5ldGhlcmxhbmRzXCIsXCJicVwiLFwiNTk5XCIsMSxbXCIzXCIsXCI0XCIsXCI3XCJdXSxbXCJDYXltYW4gSXNsYW5kc1wiLFwia3lcIixcIjFcIiwxMixbXCIzNDVcIl1dLFtcIkNlbnRyYWwgQWZyaWNhbiBSZXB1YmxpYyAoUsOpcHVibGlxdWUgY2VudHJhZnJpY2FpbmUpXCIsXCJjZlwiLFwiMjM2XCJdLFtcIkNoYWQgKFRjaGFkKVwiLFwidGRcIixcIjIzNVwiXSxbXCJDaGlsZVwiLFwiY2xcIixcIjU2XCJdLFtcIkNoaW5hICjkuK3lm70pXCIsXCJjblwiLFwiODZcIl0sW1wiQ2hyaXN0bWFzIElzbGFuZFwiLFwiY3hcIixcIjYxXCIsMl0sW1wiQ29jb3MgKEtlZWxpbmcpIElzbGFuZHNcIixcImNjXCIsXCI2MVwiLDFdLFtcIkNvbG9tYmlhXCIsXCJjb1wiLFwiNTdcIl0sW1wiQ29tb3JvcyAo4oCr2KzYstixINin2YTZgtmF2LHigKzigI4pXCIsXCJrbVwiLFwiMjY5XCJdLFtcIkNvbmdvIChEUkMpIChKYW1odXJpIHlhIEtpZGVtb2tyYXNpYSB5YSBLb25nbylcIixcImNkXCIsXCIyNDNcIl0sW1wiQ29uZ28gKFJlcHVibGljKSAoQ29uZ28tQnJhenphdmlsbGUpXCIsXCJjZ1wiLFwiMjQyXCJdLFtcIkNvb2sgSXNsYW5kc1wiLFwiY2tcIixcIjY4MlwiXSxbXCJDb3N0YSBSaWNhXCIsXCJjclwiLFwiNTA2XCJdLFtcIkPDtHRlIGTigJlJdm9pcmVcIixcImNpXCIsXCIyMjVcIl0sW1wiQ3JvYXRpYSAoSHJ2YXRza2EpXCIsXCJoclwiLFwiMzg1XCJdLFtcIkN1YmFcIixcImN1XCIsXCI1M1wiXSxbXCJDdXJhw6dhb1wiLFwiY3dcIixcIjU5OVwiLDBdLFtcIkN5cHJ1cyAozprPjc+Az4HOv8+CKVwiLFwiY3lcIixcIjM1N1wiXSxbXCJDemVjaCBSZXB1YmxpYyAoxIxlc2vDoSByZXB1Ymxpa2EpXCIsXCJjelwiLFwiNDIwXCJdLFtcIkRlbm1hcmsgKERhbm1hcmspXCIsXCJka1wiLFwiNDVcIl0sW1wiRGppYm91dGlcIixcImRqXCIsXCIyNTNcIl0sW1wiRG9taW5pY2FcIixcImRtXCIsXCIxXCIsMTMsW1wiNzY3XCJdXSxbXCJEb21pbmljYW4gUmVwdWJsaWMgKFJlcMO6YmxpY2EgRG9taW5pY2FuYSlcIixcImRvXCIsXCIxXCIsMixbXCI4MDlcIixcIjgyOVwiLFwiODQ5XCJdXSxbXCJFY3VhZG9yXCIsXCJlY1wiLFwiNTkzXCJdLFtcIkVneXB0ICjigKvZhdi12LHigKzigI4pXCIsXCJlZ1wiLFwiMjBcIl0sW1wiRWwgU2FsdmFkb3JcIixcInN2XCIsXCI1MDNcIl0sW1wiRXF1YXRvcmlhbCBHdWluZWEgKEd1aW5lYSBFY3VhdG9yaWFsKVwiLFwiZ3FcIixcIjI0MFwiXSxbXCJFcml0cmVhXCIsXCJlclwiLFwiMjkxXCJdLFtcIkVzdG9uaWEgKEVlc3RpKVwiLFwiZWVcIixcIjM3MlwiXSxbXCJFdGhpb3BpYVwiLFwiZXRcIixcIjI1MVwiXSxbXCJGYWxrbGFuZCBJc2xhbmRzIChJc2xhcyBNYWx2aW5hcylcIixcImZrXCIsXCI1MDBcIl0sW1wiRmFyb2UgSXNsYW5kcyAoRsO4cm95YXIpXCIsXCJmb1wiLFwiMjk4XCJdLFtcIkZpamlcIixcImZqXCIsXCI2NzlcIl0sW1wiRmlubGFuZCAoU3VvbWkpXCIsXCJmaVwiLFwiMzU4XCIsMF0sW1wiRnJhbmNlXCIsXCJmclwiLFwiMzNcIl0sW1wiRnJlbmNoIEd1aWFuYSAoR3V5YW5lIGZyYW7Dp2Fpc2UpXCIsXCJnZlwiLFwiNTk0XCJdLFtcIkZyZW5jaCBQb2x5bmVzaWEgKFBvbHluw6lzaWUgZnJhbsOnYWlzZSlcIixcInBmXCIsXCI2ODlcIl0sW1wiR2Fib25cIixcImdhXCIsXCIyNDFcIl0sW1wiR2FtYmlhXCIsXCJnbVwiLFwiMjIwXCJdLFtcIkdlb3JnaWEgKOGDoeGDkOGDpeGDkOGDoOGDl+GDleGDlOGDmuGDnSlcIixcImdlXCIsXCI5OTVcIl0sW1wiR2VybWFueSAoRGV1dHNjaGxhbmQpXCIsXCJkZVwiLFwiNDlcIl0sW1wiR2hhbmEgKEdhYW5hKVwiLFwiZ2hcIixcIjIzM1wiXSxbXCJHaWJyYWx0YXJcIixcImdpXCIsXCIzNTBcIl0sW1wiR3JlZWNlICjOlc67zrvOrM60zrEpXCIsXCJnclwiLFwiMzBcIl0sW1wiR3JlZW5sYW5kIChLYWxhYWxsaXQgTnVuYWF0KVwiLFwiZ2xcIixcIjI5OVwiXSxbXCJHcmVuYWRhXCIsXCJnZFwiLFwiMVwiLDE0LFtcIjQ3M1wiXV0sW1wiR3VhZGVsb3VwZVwiLFwiZ3BcIixcIjU5MFwiLDBdLFtcIkd1YW1cIixcImd1XCIsXCIxXCIsMTUsW1wiNjcxXCJdXSxbXCJHdWF0ZW1hbGFcIixcImd0XCIsXCI1MDJcIl0sW1wiR3Vlcm5zZXlcIixcImdnXCIsXCI0NFwiLDEsW1wiMTQ4MVwiLFwiNzc4MVwiLFwiNzgzOVwiLFwiNzkxMVwiXV0sW1wiR3VpbmVhIChHdWluw6llKVwiLFwiZ25cIixcIjIyNFwiXSxbXCJHdWluZWEtQmlzc2F1IChHdWluw6kgQmlzc2F1KVwiLFwiZ3dcIixcIjI0NVwiXSxbXCJHdXlhbmFcIixcImd5XCIsXCI1OTJcIl0sW1wiSGFpdGlcIixcImh0XCIsXCI1MDlcIl0sW1wiSG9uZHVyYXNcIixcImhuXCIsXCI1MDRcIl0sW1wiSG9uZyBLb25nICjpppnmuK8pXCIsXCJoa1wiLFwiODUyXCJdLFtcIkh1bmdhcnkgKE1hZ3lhcm9yc3rDoWcpXCIsXCJodVwiLFwiMzZcIl0sW1wiSWNlbGFuZCAow41zbGFuZClcIixcImlzXCIsXCIzNTRcIl0sW1wiSW5kaWEgKOCkreCkvuCksOCkpClcIixcImluXCIsXCI5MVwiXSxbXCJJbmRvbmVzaWFcIixcImlkXCIsXCI2MlwiXSxbXCJJcmFuICjigKvYp9uM2LHYp9mG4oCs4oCOKVwiLFwiaXJcIixcIjk4XCJdLFtcIklyYXEgKOKAq9in2YTYudix2KfZguKArOKAjilcIixcImlxXCIsXCI5NjRcIl0sW1wiSXJlbGFuZFwiLFwiaWVcIixcIjM1M1wiXSxbXCJJc2xlIG9mIE1hblwiLFwiaW1cIixcIjQ0XCIsMixbXCIxNjI0XCIsXCI3NDU3NlwiLFwiNzUyNFwiLFwiNzkyNFwiLFwiNzYyNFwiXV0sW1wiSXNyYWVsICjigKvXmdep16jXkNec4oCs4oCOKVwiLFwiaWxcIixcIjk3MlwiXSxbXCJJdGFseSAoSXRhbGlhKVwiLFwiaXRcIixcIjM5XCIsMF0sW1wiSmFtYWljYVwiLFwiam1cIixcIjFcIiw0LFtcIjg3NlwiLFwiNjU4XCJdXSxbXCJKYXBhbiAo5pel5pysKVwiLFwianBcIixcIjgxXCJdLFtcIkplcnNleVwiLFwiamVcIixcIjQ0XCIsMyxbXCIxNTM0XCIsXCI3NTA5XCIsXCI3NzAwXCIsXCI3Nzk3XCIsXCI3ODI5XCIsXCI3OTM3XCJdXSxbXCJKb3JkYW4gKOKAq9in2YTYo9ix2K/ZhuKArOKAjilcIixcImpvXCIsXCI5NjJcIl0sW1wiS2F6YWtoc3RhbiAo0JrQsNC30LDRhdGB0YLQsNC9KVwiLFwia3pcIixcIjdcIiwxLFtcIjMzXCIsXCI3XCJdXSxbXCJLZW55YVwiLFwia2VcIixcIjI1NFwiXSxbXCJLaXJpYmF0aVwiLFwia2lcIixcIjY4NlwiXSxbXCJLb3Nvdm9cIixcInhrXCIsXCIzODNcIl0sW1wiS3V3YWl0ICjigKvYp9mE2YPZiNmK2KrigKzigI4pXCIsXCJrd1wiLFwiOTY1XCJdLFtcIkt5cmd5enN0YW4gKNCa0YvRgNCz0YvQt9GB0YLQsNC9KVwiLFwia2dcIixcIjk5NlwiXSxbXCJMYW9zICjguqXgurLguqcpXCIsXCJsYVwiLFwiODU2XCJdLFtcIkxhdHZpYSAoTGF0dmlqYSlcIixcImx2XCIsXCIzNzFcIl0sW1wiTGViYW5vbiAo4oCr2YTYqNmG2KfZhuKArOKAjilcIixcImxiXCIsXCI5NjFcIl0sW1wiTGVzb3Rob1wiLFwibHNcIixcIjI2NlwiXSxbXCJMaWJlcmlhXCIsXCJsclwiLFwiMjMxXCJdLFtcIkxpYnlhICjigKvZhNmK2KjZitin4oCs4oCOKVwiLFwibHlcIixcIjIxOFwiXSxbXCJMaWVjaHRlbnN0ZWluXCIsXCJsaVwiLFwiNDIzXCJdLFtcIkxpdGh1YW5pYSAoTGlldHV2YSlcIixcImx0XCIsXCIzNzBcIl0sW1wiTHV4ZW1ib3VyZ1wiLFwibHVcIixcIjM1MlwiXSxbXCJNYWNhdSAo5r6z6ZaAKVwiLFwibW9cIixcIjg1M1wiXSxbXCJNYWNlZG9uaWEgKEZZUk9NKSAo0JzQsNC60LXQtNC+0L3QuNGY0LApXCIsXCJta1wiLFwiMzg5XCJdLFtcIk1hZGFnYXNjYXIgKE1hZGFnYXNpa2FyYSlcIixcIm1nXCIsXCIyNjFcIl0sW1wiTWFsYXdpXCIsXCJtd1wiLFwiMjY1XCJdLFtcIk1hbGF5c2lhXCIsXCJteVwiLFwiNjBcIl0sW1wiTWFsZGl2ZXNcIixcIm12XCIsXCI5NjBcIl0sW1wiTWFsaVwiLFwibWxcIixcIjIyM1wiXSxbXCJNYWx0YVwiLFwibXRcIixcIjM1NlwiXSxbXCJNYXJzaGFsbCBJc2xhbmRzXCIsXCJtaFwiLFwiNjkyXCJdLFtcIk1hcnRpbmlxdWVcIixcIm1xXCIsXCI1OTZcIl0sW1wiTWF1cml0YW5pYSAo4oCr2YXZiNix2YrYqtin2YbZitin4oCs4oCOKVwiLFwibXJcIixcIjIyMlwiXSxbXCJNYXVyaXRpdXMgKE1vcmlzKVwiLFwibXVcIixcIjIzMFwiXSxbXCJNYXlvdHRlXCIsXCJ5dFwiLFwiMjYyXCIsMSxbXCIyNjlcIixcIjYzOVwiXV0sW1wiTWV4aWNvIChNw6l4aWNvKVwiLFwibXhcIixcIjUyXCJdLFtcIk1pY3JvbmVzaWFcIixcImZtXCIsXCI2OTFcIl0sW1wiTW9sZG92YSAoUmVwdWJsaWNhIE1vbGRvdmEpXCIsXCJtZFwiLFwiMzczXCJdLFtcIk1vbmFjb1wiLFwibWNcIixcIjM3N1wiXSxbXCJNb25nb2xpYSAo0JzQvtC90LPQvtC7KVwiLFwibW5cIixcIjk3NlwiXSxbXCJNb250ZW5lZ3JvIChDcm5hIEdvcmEpXCIsXCJtZVwiLFwiMzgyXCJdLFtcIk1vbnRzZXJyYXRcIixcIm1zXCIsXCIxXCIsMTYsW1wiNjY0XCJdXSxbXCJNb3JvY2NvICjigKvYp9mE2YXYutix2KjigKzigI4pXCIsXCJtYVwiLFwiMjEyXCIsMF0sW1wiTW96YW1iaXF1ZSAoTW/Dp2FtYmlxdWUpXCIsXCJtelwiLFwiMjU4XCJdLFtcIk15YW5tYXIgKEJ1cm1hKSAo4YCZ4YC84YCU4YC64YCZ4YCsKVwiLFwibW1cIixcIjk1XCJdLFtcIk5hbWliaWEgKE5hbWliacOrKVwiLFwibmFcIixcIjI2NFwiXSxbXCJOYXVydVwiLFwibnJcIixcIjY3NFwiXSxbXCJOZXBhbCAo4KSo4KWH4KSq4KS+4KSyKVwiLFwibnBcIixcIjk3N1wiXSxbXCJOZXRoZXJsYW5kcyAoTmVkZXJsYW5kKVwiLFwibmxcIixcIjMxXCJdLFtcIk5ldyBDYWxlZG9uaWEgKE5vdXZlbGxlLUNhbMOpZG9uaWUpXCIsXCJuY1wiLFwiNjg3XCJdLFtcIk5ldyBaZWFsYW5kXCIsXCJuelwiLFwiNjRcIl0sW1wiTmljYXJhZ3VhXCIsXCJuaVwiLFwiNTA1XCJdLFtcIk5pZ2VyIChOaWphcilcIixcIm5lXCIsXCIyMjdcIl0sW1wiTmlnZXJpYVwiLFwibmdcIixcIjIzNFwiXSxbXCJOaXVlXCIsXCJudVwiLFwiNjgzXCJdLFtcIk5vcmZvbGsgSXNsYW5kXCIsXCJuZlwiLFwiNjcyXCJdLFtcIk5vcnRoIEtvcmVhICjsobDshKAg66+87KO87KO87J2YIOyduOuvvCDqs7XtmZTqta0pXCIsXCJrcFwiLFwiODUwXCJdLFtcIk5vcnRoZXJuIE1hcmlhbmEgSXNsYW5kc1wiLFwibXBcIixcIjFcIiwxNyxbXCI2NzBcIl1dLFtcIk5vcndheSAoTm9yZ2UpXCIsXCJub1wiLFwiNDdcIiwwXSxbXCJPbWFuICjigKvYudmP2YXYp9mG4oCs4oCOKVwiLFwib21cIixcIjk2OFwiXSxbXCJQYWtpc3RhbiAo4oCr2b7Yp9qp2LPYqtin2YbigKzigI4pXCIsXCJwa1wiLFwiOTJcIl0sW1wiUGFsYXVcIixcInB3XCIsXCI2ODBcIl0sW1wiUGFsZXN0aW5lICjigKvZgdmE2LPYt9mK2YbigKzigI4pXCIsXCJwc1wiLFwiOTcwXCJdLFtcIlBhbmFtYSAoUGFuYW3DoSlcIixcInBhXCIsXCI1MDdcIl0sW1wiUGFwdWEgTmV3IEd1aW5lYVwiLFwicGdcIixcIjY3NVwiXSxbXCJQYXJhZ3VheVwiLFwicHlcIixcIjU5NVwiXSxbXCJQZXJ1IChQZXLDuilcIixcInBlXCIsXCI1MVwiXSxbXCJQaGlsaXBwaW5lc1wiLFwicGhcIixcIjYzXCJdLFtcIlBvbGFuZCAoUG9sc2thKVwiLFwicGxcIixcIjQ4XCJdLFtcIlBvcnR1Z2FsXCIsXCJwdFwiLFwiMzUxXCJdLFtcIlB1ZXJ0byBSaWNvXCIsXCJwclwiLFwiMVwiLDMsW1wiNzg3XCIsXCI5MzlcIl1dLFtcIlFhdGFyICjigKvZgti32LHigKzigI4pXCIsXCJxYVwiLFwiOTc0XCJdLFtcIlLDqXVuaW9uIChMYSBSw6l1bmlvbilcIixcInJlXCIsXCIyNjJcIiwwXSxbXCJSb21hbmlhIChSb23Dom5pYSlcIixcInJvXCIsXCI0MFwiXSxbXCJSdXNzaWEgKNCg0L7RgdGB0LjRjylcIixcInJ1XCIsXCI3XCIsMF0sW1wiUndhbmRhXCIsXCJyd1wiLFwiMjUwXCJdLFtcIlNhaW50IEJhcnRow6lsZW15XCIsXCJibFwiLFwiNTkwXCIsMV0sW1wiU2FpbnQgSGVsZW5hXCIsXCJzaFwiLFwiMjkwXCJdLFtcIlNhaW50IEtpdHRzIGFuZCBOZXZpc1wiLFwia25cIixcIjFcIiwxOCxbXCI4NjlcIl1dLFtcIlNhaW50IEx1Y2lhXCIsXCJsY1wiLFwiMVwiLDE5LFtcIjc1OFwiXV0sW1wiU2FpbnQgTWFydGluIChTYWludC1NYXJ0aW4gKHBhcnRpZSBmcmFuw6dhaXNlKSlcIixcIm1mXCIsXCI1OTBcIiwyXSxbXCJTYWludCBQaWVycmUgYW5kIE1pcXVlbG9uIChTYWludC1QaWVycmUtZXQtTWlxdWVsb24pXCIsXCJwbVwiLFwiNTA4XCJdLFtcIlNhaW50IFZpbmNlbnQgYW5kIHRoZSBHcmVuYWRpbmVzXCIsXCJ2Y1wiLFwiMVwiLDIwLFtcIjc4NFwiXV0sW1wiU2Ftb2FcIixcIndzXCIsXCI2ODVcIl0sW1wiU2FuIE1hcmlub1wiLFwic21cIixcIjM3OFwiXSxbXCJTw6NvIFRvbcOpIGFuZCBQcsOtbmNpcGUgKFPDo28gVG9tw6kgZSBQcsOtbmNpcGUpXCIsXCJzdFwiLFwiMjM5XCJdLFtcIlNhdWRpIEFyYWJpYSAo4oCr2KfZhNmF2YXZhNmD2Kkg2KfZhNi52LHYqNmK2Kkg2KfZhNiz2LnZiNiv2YrYqeKArOKAjilcIixcInNhXCIsXCI5NjZcIl0sW1wiU2VuZWdhbCAoU8OpbsOpZ2FsKVwiLFwic25cIixcIjIyMVwiXSxbXCJTZXJiaWEgKNCh0YDQsdC40ZjQsClcIixcInJzXCIsXCIzODFcIl0sW1wiU2V5Y2hlbGxlc1wiLFwic2NcIixcIjI0OFwiXSxbXCJTaWVycmEgTGVvbmVcIixcInNsXCIsXCIyMzJcIl0sW1wiU2luZ2Fwb3JlXCIsXCJzZ1wiLFwiNjVcIl0sW1wiU2ludCBNYWFydGVuXCIsXCJzeFwiLFwiMVwiLDIxLFtcIjcyMVwiXV0sW1wiU2xvdmFraWEgKFNsb3ZlbnNrbylcIixcInNrXCIsXCI0MjFcIl0sW1wiU2xvdmVuaWEgKFNsb3ZlbmlqYSlcIixcInNpXCIsXCIzODZcIl0sW1wiU29sb21vbiBJc2xhbmRzXCIsXCJzYlwiLFwiNjc3XCJdLFtcIlNvbWFsaWEgKFNvb21hYWxpeWEpXCIsXCJzb1wiLFwiMjUyXCJdLFtcIlNvdXRoIEFmcmljYVwiLFwiemFcIixcIjI3XCJdLFtcIlNvdXRoIEtvcmVhICjrjIDtlZzrr7zqta0pXCIsXCJrclwiLFwiODJcIl0sW1wiU291dGggU3VkYW4gKOKAq9is2YbZiNioINin2YTYs9mI2K/Yp9mG4oCs4oCOKVwiLFwic3NcIixcIjIxMVwiXSxbXCJTcGFpbiAoRXNwYcOxYSlcIixcImVzXCIsXCIzNFwiXSxbXCJTcmkgTGFua2EgKOC3geC3iuKAjeC2u+C3kyDgtr3gtoLgtprgt4/gt4ApXCIsXCJsa1wiLFwiOTRcIl0sW1wiU3VkYW4gKOKAq9in2YTYs9mI2K/Yp9mG4oCs4oCOKVwiLFwic2RcIixcIjI0OVwiXSxbXCJTdXJpbmFtZVwiLFwic3JcIixcIjU5N1wiXSxbXCJTdmFsYmFyZCBhbmQgSmFuIE1heWVuXCIsXCJzalwiLFwiNDdcIiwxLFtcIjc5XCJdXSxbXCJTd2F6aWxhbmRcIixcInN6XCIsXCIyNjhcIl0sW1wiU3dlZGVuIChTdmVyaWdlKVwiLFwic2VcIixcIjQ2XCJdLFtcIlN3aXR6ZXJsYW5kIChTY2h3ZWl6KVwiLFwiY2hcIixcIjQxXCJdLFtcIlN5cmlhICjigKvYs9mI2LHZitin4oCs4oCOKVwiLFwic3lcIixcIjk2M1wiXSxbXCJUYWl3YW4gKOWPsOeBoylcIixcInR3XCIsXCI4ODZcIl0sW1wiVGFqaWtpc3RhblwiLFwidGpcIixcIjk5MlwiXSxbXCJUYW56YW5pYVwiLFwidHpcIixcIjI1NVwiXSxbXCJUaGFpbGFuZCAo4LmE4LiX4LiiKVwiLFwidGhcIixcIjY2XCJdLFtcIlRpbW9yLUxlc3RlXCIsXCJ0bFwiLFwiNjcwXCJdLFtcIlRvZ29cIixcInRnXCIsXCIyMjhcIl0sW1wiVG9rZWxhdVwiLFwidGtcIixcIjY5MFwiXSxbXCJUb25nYVwiLFwidG9cIixcIjY3NlwiXSxbXCJUcmluaWRhZCBhbmQgVG9iYWdvXCIsXCJ0dFwiLFwiMVwiLDIyLFtcIjg2OFwiXV0sW1wiVHVuaXNpYSAo4oCr2KrZiNmG2LPigKzigI4pXCIsXCJ0blwiLFwiMjE2XCJdLFtcIlR1cmtleSAoVMO8cmtpeWUpXCIsXCJ0clwiLFwiOTBcIl0sW1wiVHVya21lbmlzdGFuXCIsXCJ0bVwiLFwiOTkzXCJdLFtcIlR1cmtzIGFuZCBDYWljb3MgSXNsYW5kc1wiLFwidGNcIixcIjFcIiwyMyxbXCI2NDlcIl1dLFtcIlR1dmFsdVwiLFwidHZcIixcIjY4OFwiXSxbXCJVLlMuIFZpcmdpbiBJc2xhbmRzXCIsXCJ2aVwiLFwiMVwiLDI0LFtcIjM0MFwiXV0sW1wiVWdhbmRhXCIsXCJ1Z1wiLFwiMjU2XCJdLFtcIlVrcmFpbmUgKNCj0LrRgNCw0ZfQvdCwKVwiLFwidWFcIixcIjM4MFwiXSxbXCJVbml0ZWQgQXJhYiBFbWlyYXRlcyAo4oCr2KfZhNil2YXYp9ix2KfYqiDYp9mE2LnYsdio2YrYqSDYp9mE2YXYqtit2K/YqeKArOKAjilcIixcImFlXCIsXCI5NzFcIl0sW1wiVW5pdGVkIEtpbmdkb21cIixcImdiXCIsXCI0NFwiLDBdLFtcIlVuaXRlZCBTdGF0ZXNcIixcInVzXCIsXCIxXCIsMF0sW1wiVXJ1Z3VheVwiLFwidXlcIixcIjU5OFwiXSxbXCJVemJla2lzdGFuIChPyrt6YmVraXN0b24pXCIsXCJ1elwiLFwiOTk4XCJdLFtcIlZhbnVhdHVcIixcInZ1XCIsXCI2NzhcIl0sW1wiVmF0aWNhbiBDaXR5IChDaXR0w6AgZGVsIFZhdGljYW5vKVwiLFwidmFcIixcIjM5XCIsMSxbXCIwNjY5OFwiXV0sW1wiVmVuZXp1ZWxhXCIsXCJ2ZVwiLFwiNThcIl0sW1wiVmlldG5hbSAoVmnhu4d0IE5hbSlcIixcInZuXCIsXCI4NFwiXSxbXCJXYWxsaXMgYW5kIEZ1dHVuYSAoV2FsbGlzLWV0LUZ1dHVuYSlcIixcIndmXCIsXCI2ODFcIl0sW1wiV2VzdGVybiBTYWhhcmEgKOKAq9in2YTYtdit2LHYp9ihINin2YTYutix2KjZitip4oCs4oCOKVwiLFwiZWhcIixcIjIxMlwiLDEsW1wiNTI4OFwiLFwiNTI4OVwiXV0sW1wiWWVtZW4gKOKAq9in2YTZitmF2YbigKzigI4pXCIsXCJ5ZVwiLFwiOTY3XCJdLFtcIlphbWJpYVwiLFwiem1cIixcIjI2MFwiXSxbXCJaaW1iYWJ3ZVwiLFwiendcIixcIjI2M1wiXSxbXCLDhWxhbmQgSXNsYW5kc1wiLFwiYXhcIixcIjM1OFwiLDEsW1wiMThcIl1dXSxoPTA7aDxnLmxlbmd0aDtoKyspe3ZhciBpPWdbaF07Z1toXT17bmFtZTppWzBdLGlzbzI6aVsxXSxkaWFsQ29kZTppWzJdLHByaW9yaXR5OmlbM118fDAsYXJlYUNvZGVzOmlbNF18fG51bGx9fWEuaW50bFRlbElucHV0R2xvYmFscz17Z2V0SW5zdGFuY2U6ZnVuY3Rpb24oYil7dmFyIGM9Yi5nZXRBdHRyaWJ1dGUoXCJkYXRhLWludGwtdGVsLWlucHV0LWlkXCIpO3JldHVybiBhLmludGxUZWxJbnB1dEdsb2JhbHMuaW5zdGFuY2VzW2NdfSxpbnN0YW5jZXM6e319O3ZhciBqPTAsaz17YWxsb3dEcm9wZG93bjohMCxhdXRvSGlkZURpYWxDb2RlOiEwLGF1dG9QbGFjZWhvbGRlcjpcInBvbGl0ZVwiLGN1c3RvbUNvbnRhaW5lcjpcIlwiLGN1c3RvbVBsYWNlaG9sZGVyOm51bGwsZHJvcGRvd25Db250YWluZXI6bnVsbCxleGNsdWRlQ291bnRyaWVzOltdLGZvcm1hdE9uRGlzcGxheTohMCxnZW9JcExvb2t1cDpudWxsLGhpZGRlbklucHV0OlwiXCIsaW5pdGlhbENvdW50cnk6XCJcIixsb2NhbGl6ZWRDb3VudHJpZXM6bnVsbCxuYXRpb25hbE1vZGU6ITAsb25seUNvdW50cmllczpbXSxwbGFjZWhvbGRlck51bWJlclR5cGU6XCJNT0JJTEVcIixwcmVmZXJyZWRDb3VudHJpZXM6W1widXNcIixcImdiXCJdLHNlcGFyYXRlRGlhbENvZGU6ITEsdXRpbHNTY3JpcHQ6XCJcIn0sbD1bXCI4MDBcIixcIjgyMlwiLFwiODMzXCIsXCI4NDRcIixcIjg1NVwiLFwiODY2XCIsXCI4NzdcIixcIjg4MFwiLFwiODgxXCIsXCI4ODJcIixcIjg4M1wiLFwiODg0XCIsXCI4ODVcIixcIjg4NlwiLFwiODg3XCIsXCI4ODhcIixcIjg4OVwiXTthLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsZnVuY3Rpb24oKXthLmludGxUZWxJbnB1dEdsb2JhbHMud2luZG93TG9hZGVkPSEwfSk7dmFyIG09ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9T2JqZWN0LmtleXMoYSksZD0wO2Q8Yy5sZW5ndGg7ZCsrKWIoY1tkXSxhW2NbZF1dKX0sbj1mdW5jdGlvbihiKXttKGEuaW50bFRlbElucHV0R2xvYmFscy5pbnN0YW5jZXMsZnVuY3Rpb24oYyl7YS5pbnRsVGVsSW5wdXRHbG9iYWxzLmluc3RhbmNlc1tjXVtiXSgpfSl9LG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGEsYil7dmFyIGM9dGhpcztkKHRoaXMsZSksdGhpcy5pZD1qKyssdGhpcy5hPWEsdGhpcy5iPW51bGwsdGhpcy5jPW51bGw7dmFyIGY9Ynx8e307dGhpcy5kPXt9LG0oayxmdW5jdGlvbihhLGIpe2MuZFthXT1mLmhhc093blByb3BlcnR5KGEpP2ZbYV06Yn0pLHRoaXMuZT1Cb29sZWFuKGEuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIikpfXJldHVybiBmKGUsW3trZXk6XCJfaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcztpZih0aGlzLmQubmF0aW9uYWxNb2RlJiYodGhpcy5kLmF1dG9IaWRlRGlhbENvZGU9ITEpLHRoaXMuZC5zZXBhcmF0ZURpYWxDb2RlJiYodGhpcy5kLmF1dG9IaWRlRGlhbENvZGU9dGhpcy5kLm5hdGlvbmFsTW9kZT0hMSksdGhpcy5nPS9BbmRyb2lkLitNb2JpbGV8d2ViT1N8aVBob25lfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSx0aGlzLmcmJihiLmJvZHkuY2xhc3NMaXN0LmFkZChcIml0aS1tb2JpbGVcIiksdGhpcy5kLmRyb3Bkb3duQ29udGFpbmVyfHwodGhpcy5kLmRyb3Bkb3duQ29udGFpbmVyPWIuYm9keSkpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlKXt2YXIgYz1uZXcgUHJvbWlzZShmdW5jdGlvbihiLGMpe2EuaD1iLGEuaT1jfSksZD1uZXcgUHJvbWlzZShmdW5jdGlvbihiLGMpe2EuaTA9YixhLmkxPWN9KTt0aGlzLnByb21pc2U9UHJvbWlzZS5hbGwoW2MsZF0pfWVsc2UgdGhpcy5oPXRoaXMuaT1mdW5jdGlvbigpe30sdGhpcy5pMD10aGlzLmkxPWZ1bmN0aW9uKCl7fTt0aGlzLnM9e30sdGhpcy5fYigpLHRoaXMuX2YoKSx0aGlzLl9oKCksdGhpcy5faSgpLHRoaXMuX2kzKCl9fSx7a2V5OlwiX2JcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2QoKSx0aGlzLl9kMigpLHRoaXMuX2UoKSx0aGlzLmQubG9jYWxpemVkQ291bnRyaWVzJiZ0aGlzLl9kMCgpLCh0aGlzLmQub25seUNvdW50cmllcy5sZW5ndGh8fHRoaXMuZC5sb2NhbGl6ZWRDb3VudHJpZXMpJiZ0aGlzLnAuc29ydCh0aGlzLl9kMSl9fSx7a2V5OlwiX2NcIix2YWx1ZTpmdW5jdGlvbihhLGIsZCl7Yi5sZW5ndGg+dGhpcy5kaWFsQ29kZU1heExlbiYmKHRoaXMuZGlhbENvZGVNYXhMZW49Yi5sZW5ndGgpLHRoaXMucS5oYXNPd25Qcm9wZXJ0eShiKXx8KHRoaXMucVtiXT1bXSk7Zm9yKHZhciBlPTA7ZTx0aGlzLnFbYl0ubGVuZ3RoO2UrKylpZih0aGlzLnFbYl1bZV09PT1hKXJldHVybjt2YXIgZj1kIT09Yz9kOnRoaXMucVtiXS5sZW5ndGg7dGhpcy5xW2JdW2ZdPWF9fSx7a2V5OlwiX2RcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuZC5vbmx5Q291bnRyaWVzLmxlbmd0aCl7dmFyIGE9dGhpcy5kLm9ubHlDb3VudHJpZXMubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhLnRvTG93ZXJDYXNlKCl9KTt0aGlzLnA9Zy5maWx0ZXIoZnVuY3Rpb24oYil7cmV0dXJuIGEuaW5kZXhPZihiLmlzbzIpPi0xfSl9ZWxzZSBpZih0aGlzLmQuZXhjbHVkZUNvdW50cmllcy5sZW5ndGgpe3ZhciBiPXRoaXMuZC5leGNsdWRlQ291bnRyaWVzLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYS50b0xvd2VyQ2FzZSgpfSk7dGhpcy5wPWcuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybi0xPT09Yi5pbmRleE9mKGEuaXNvMil9KX1lbHNlIHRoaXMucD1nfX0se2tleTpcIl9kMFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTx0aGlzLnAubGVuZ3RoO2ErKyl7dmFyIGI9dGhpcy5wW2FdLmlzbzIudG9Mb3dlckNhc2UoKTt0aGlzLmQubG9jYWxpemVkQ291bnRyaWVzLmhhc093blByb3BlcnR5KGIpJiYodGhpcy5wW2FdLm5hbWU9dGhpcy5kLmxvY2FsaXplZENvdW50cmllc1tiXSl9fX0se2tleTpcIl9kMVwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSl9fSx7a2V5OlwiX2QyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmRpYWxDb2RlTWF4TGVuPTAsdGhpcy5xPXt9O2Zvcih2YXIgYT0wO2E8dGhpcy5wLmxlbmd0aDthKyspe3ZhciBiPXRoaXMucFthXTt0aGlzLl9jKGIuaXNvMixiLmRpYWxDb2RlLGIucHJpb3JpdHkpfWZvcih2YXIgYz0wO2M8dGhpcy5wLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMucFtjXTtpZihkLmFyZWFDb2Rlcylmb3IodmFyIGU9dGhpcy5xW2QuZGlhbENvZGVdWzBdLGY9MDtmPGQuYXJlYUNvZGVzLmxlbmd0aDtmKyspe2Zvcih2YXIgZz1kLmFyZWFDb2Rlc1tmXSxoPTE7aDxnLmxlbmd0aDtoKyspe3ZhciBpPWQuZGlhbENvZGUrZy5zdWJzdHIoMCxoKTt0aGlzLl9jKGUsaSksdGhpcy5fYyhkLmlzbzIsaSl9dGhpcy5fYyhkLmlzbzIsZC5kaWFsQ29kZStnKX19fX0se2tleTpcIl9lXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnByZWZlcnJlZENvdW50cmllcz1bXTtmb3IodmFyIGE9MDthPHRoaXMuZC5wcmVmZXJyZWRDb3VudHJpZXMubGVuZ3RoO2ErKyl7dmFyIGI9dGhpcy5kLnByZWZlcnJlZENvdW50cmllc1thXS50b0xvd2VyQ2FzZSgpLGM9dGhpcy5feShiLCExLCEwKTtjJiZ0aGlzLnByZWZlcnJlZENvdW50cmllcy5wdXNoKGMpfX19LHtrZXk6XCJfZTJcIix2YWx1ZTpmdW5jdGlvbihhLGMsZCl7dmFyIGU9Yi5jcmVhdGVFbGVtZW50KGEpO3JldHVybiBjJiZtKGMsZnVuY3Rpb24oYSxiKXtyZXR1cm4gZS5zZXRBdHRyaWJ1dGUoYSxiKX0pLGQmJmQuYXBwZW5kQ2hpbGQoZSksZX19LHtrZXk6XCJfZlwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5hLnNldEF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZVwiLFwib2ZmXCIpO3ZhciBhPVwiaXRpXCI7dGhpcy5kLmFsbG93RHJvcGRvd24mJihhKz1cIiBpdGktLWFsbG93LWRyb3Bkb3duXCIpLHRoaXMuZC5zZXBhcmF0ZURpYWxDb2RlJiYoYSs9XCIgaXRpLS1zZXBhcmF0ZS1kaWFsLWNvZGVcIiksdGhpcy5kLmN1c3RvbUNvbnRhaW5lciYmKGErPVwiIFwiLGErPXRoaXMuZC5jdXN0b21Db250YWluZXIpO3ZhciBiPXRoaXMuX2UyKFwiZGl2XCIse1wiY2xhc3NcIjphfSk7aWYodGhpcy5hLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGIsdGhpcy5hKSx0aGlzLms9dGhpcy5fZTIoXCJkaXZcIix7XCJjbGFzc1wiOlwiaXRpX19mbGFnLWNvbnRhaW5lclwifSxiKSxiLmFwcGVuZENoaWxkKHRoaXMuYSksdGhpcy5zZWxlY3RlZEZsYWc9dGhpcy5fZTIoXCJkaXZcIix7XCJjbGFzc1wiOlwiaXRpX19zZWxlY3RlZC1mbGFnXCIscm9sZTpcImNvbWJvYm94XCIsXCJhcmlhLW93bnNcIjpcImNvdW50cnktbGlzdGJveFwifSx0aGlzLmspLHRoaXMubD10aGlzLl9lMihcImRpdlwiLHtcImNsYXNzXCI6XCJpdGlfX2ZsYWdcIn0sdGhpcy5zZWxlY3RlZEZsYWcpLHRoaXMuZC5zZXBhcmF0ZURpYWxDb2RlJiYodGhpcy50PXRoaXMuX2UyKFwiZGl2XCIse1wiY2xhc3NcIjpcIml0aV9fc2VsZWN0ZWQtZGlhbC1jb2RlXCJ9LHRoaXMuc2VsZWN0ZWRGbGFnKSksdGhpcy5kLmFsbG93RHJvcGRvd24mJih0aGlzLnNlbGVjdGVkRmxhZy5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLFwiMFwiKSx0aGlzLnU9dGhpcy5fZTIoXCJkaXZcIix7XCJjbGFzc1wiOlwiaXRpX19hcnJvd1wifSx0aGlzLnNlbGVjdGVkRmxhZyksdGhpcy5tPXRoaXMuX2UyKFwidWxcIix7XCJjbGFzc1wiOlwiaXRpX19jb3VudHJ5LWxpc3QgaXRpX19oaWRlXCIsaWQ6XCJjb3VudHJ5LWxpc3Rib3hcIixcImFyaWEtZXhwYW5kZWRcIjpcImZhbHNlXCIscm9sZTpcImxpc3Rib3hcIn0pLHRoaXMucHJlZmVycmVkQ291bnRyaWVzLmxlbmd0aCYmKHRoaXMuX2codGhpcy5wcmVmZXJyZWRDb3VudHJpZXMsXCJpdGlfX3ByZWZlcnJlZFwiKSx0aGlzLl9lMihcImxpXCIse1wiY2xhc3NcIjpcIml0aV9fZGl2aWRlclwiLHJvbGU6XCJzZXBhcmF0b3JcIixcImFyaWEtZGlzYWJsZWRcIjpcInRydWVcIn0sdGhpcy5tKSksdGhpcy5fZyh0aGlzLnAsXCJpdGlfX3N0YW5kYXJkXCIpLHRoaXMuZC5kcm9wZG93bkNvbnRhaW5lcj8odGhpcy5kcm9wZG93bj10aGlzLl9lMihcImRpdlwiLHtcImNsYXNzXCI6XCJpdGkgaXRpLS1jb250YWluZXJcIn0pLHRoaXMuZHJvcGRvd24uYXBwZW5kQ2hpbGQodGhpcy5tKSk6dGhpcy5rLmFwcGVuZENoaWxkKHRoaXMubSkpLHRoaXMuZC5oaWRkZW5JbnB1dCl7dmFyIGM9dGhpcy5kLmhpZGRlbklucHV0LGQ9dGhpcy5hLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7aWYoZCl7dmFyIGU9ZC5sYXN0SW5kZXhPZihcIltcIik7LTEhPT1lJiYoYz1cIlwiLmNvbmNhdChkLnN1YnN0cigwLGUpLFwiW1wiKS5jb25jYXQoYyxcIl1cIikpfXRoaXMuaGlkZGVuSW5wdXQ9dGhpcy5fZTIoXCJpbnB1dFwiLHt0eXBlOlwiaGlkZGVuXCIsbmFtZTpjfSksYi5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlbklucHV0KX19fSx7a2V5OlwiX2dcIix2YWx1ZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1cIlwiLGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIGU9YVtkXTtjKz1cIjxsaSBjbGFzcz0naXRpX19jb3VudHJ5IFwiLmNvbmNhdChiLFwiJyB0YWJJbmRleD0nLTEnIGlkPSdpdGktaXRlbS1cIikuY29uY2F0KGUuaXNvMixcIicgcm9sZT0nb3B0aW9uJyBkYXRhLWRpYWwtY29kZT0nXCIpLmNvbmNhdChlLmRpYWxDb2RlLFwiJyBkYXRhLWNvdW50cnktY29kZT0nXCIpLmNvbmNhdChlLmlzbzIsXCInPlwiKSxjKz1cIjxkaXYgY2xhc3M9J2l0aV9fZmxhZy1ib3gnPjxkaXYgY2xhc3M9J2l0aV9fZmxhZyBpdGlfX1wiLmNvbmNhdChlLmlzbzIsXCInPjwvZGl2PjwvZGl2PlwiKSxjKz1cIjxzcGFuIGNsYXNzPSdpdGlfX2NvdW50cnktbmFtZSc+XCIuY29uY2F0KGUubmFtZSxcIjwvc3Bhbj5cIiksYys9XCI8c3BhbiBjbGFzcz0naXRpX19kaWFsLWNvZGUnPitcIi5jb25jYXQoZS5kaWFsQ29kZSxcIjwvc3Bhbj5cIiksYys9XCI8L2xpPlwifXRoaXMubS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIixjKX19LHtrZXk6XCJfaFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5hLnZhbHVlLGI9dGhpcy5fNShhKSxjPXRoaXMuX3coYSksZD10aGlzLmQsZT1kLmluaXRpYWxDb3VudHJ5LGY9ZC5uYXRpb25hbE1vZGUsZz1kLmF1dG9IaWRlRGlhbENvZGUsaD1kLnNlcGFyYXRlRGlhbENvZGU7YiYmIWM/dGhpcy5fdihhKTpcImF1dG9cIiE9PWUmJihlP3RoaXMuX3ooZS50b0xvd2VyQ2FzZSgpKTpiJiZjP3RoaXMuX3ooXCJ1c1wiKToodGhpcy5qPXRoaXMucHJlZmVycmVkQ291bnRyaWVzLmxlbmd0aD90aGlzLnByZWZlcnJlZENvdW50cmllc1swXS5pc28yOnRoaXMucFswXS5pc28yLGF8fHRoaXMuX3oodGhpcy5qKSksYXx8Znx8Z3x8aHx8KHRoaXMuYS52YWx1ZT1cIitcIi5jb25jYXQodGhpcy5zLmRpYWxDb2RlKSkpLGEmJnRoaXMuX3UoYSl9fSx7a2V5OlwiX2lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2ooKSx0aGlzLmQuYXV0b0hpZGVEaWFsQ29kZSYmdGhpcy5fbCgpLHRoaXMuZC5hbGxvd0Ryb3Bkb3duJiZ0aGlzLl9pMigpLHRoaXMuaGlkZGVuSW5wdXQmJnRoaXMuX2kwKCl9fSx7a2V5OlwiX2kwXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuX2ExND1mdW5jdGlvbigpe2EuaGlkZGVuSW5wdXQudmFsdWU9YS5nZXROdW1iZXIoKX0sdGhpcy5hLmZvcm0mJnRoaXMuYS5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIix0aGlzLl9hMTQpfX0se2tleTpcIl9pMVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuYTthJiZcIkxBQkVMXCIhPT1hLnRhZ05hbWU7KWE9YS5wYXJlbnROb2RlO3JldHVybiBhfX0se2tleTpcIl9pMlwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLl9hOT1mdW5jdGlvbihiKXthLm0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXRpX19oaWRlXCIpP2EuYS5mb2N1cygpOmIucHJldmVudERlZmF1bHQoKX07dmFyIGI9dGhpcy5faTEoKTtiJiZiLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2E5KSx0aGlzLl9hMTA9ZnVuY3Rpb24oKXshYS5tLmNsYXNzTGlzdC5jb250YWlucyhcIml0aV9faGlkZVwiKXx8YS5hLmRpc2FibGVkfHxhLmEucmVhZE9ubHl8fGEuX24oKX0sdGhpcy5zZWxlY3RlZEZsYWcuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fYTEwKSx0aGlzLl9hMTE9ZnVuY3Rpb24oYil7YS5tLmNsYXNzTGlzdC5jb250YWlucyhcIml0aV9faGlkZVwiKSYmLTEhPT1bXCJBcnJvd1VwXCIsXCJBcnJvd0Rvd25cIixcIiBcIixcIkVudGVyXCJdLmluZGV4T2YoYi5rZXkpJiYoYi5wcmV2ZW50RGVmYXVsdCgpLGIuc3RvcFByb3BhZ2F0aW9uKCksYS5fbigpKSxcIlRhYlwiPT09Yi5rZXkmJmEuXzIoKX0sdGhpcy5rLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5fYTExKX19LHtrZXk6XCJfaTNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBiPXRoaXM7dGhpcy5kLnV0aWxzU2NyaXB0JiYhYS5pbnRsVGVsSW5wdXRVdGlscz9hLmludGxUZWxJbnB1dEdsb2JhbHMud2luZG93TG9hZGVkP2EuaW50bFRlbElucHV0R2xvYmFscy5sb2FkVXRpbHModGhpcy5kLnV0aWxzU2NyaXB0KTphLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsZnVuY3Rpb24oKXthLmludGxUZWxJbnB1dEdsb2JhbHMubG9hZFV0aWxzKGIuZC51dGlsc1NjcmlwdCl9KTp0aGlzLmkwKCksXCJhdXRvXCI9PT10aGlzLmQuaW5pdGlhbENvdW50cnk/dGhpcy5faTQoKTp0aGlzLmgoKX19LHtrZXk6XCJfaTRcIix2YWx1ZTpmdW5jdGlvbigpe2EuaW50bFRlbElucHV0R2xvYmFscy5hdXRvQ291bnRyeT90aGlzLmhhbmRsZUF1dG9Db3VudHJ5KCk6YS5pbnRsVGVsSW5wdXRHbG9iYWxzLnN0YXJ0ZWRMb2FkaW5nQXV0b0NvdW50cnl8fChhLmludGxUZWxJbnB1dEdsb2JhbHMuc3RhcnRlZExvYWRpbmdBdXRvQ291bnRyeT0hMCxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLmQuZ2VvSXBMb29rdXAmJnRoaXMuZC5nZW9JcExvb2t1cChmdW5jdGlvbihiKXthLmludGxUZWxJbnB1dEdsb2JhbHMuYXV0b0NvdW50cnk9Yi50b0xvd2VyQ2FzZSgpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gbihcImhhbmRsZUF1dG9Db3VudHJ5XCIpfSl9LGZ1bmN0aW9uKCl7cmV0dXJuIG4oXCJyZWplY3RBdXRvQ291bnRyeVByb21pc2VcIil9KSl9fSx7a2V5OlwiX2pcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXM7dGhpcy5fYTEyPWZ1bmN0aW9uKCl7YS5fdihhLmEudmFsdWUpJiZhLl84KCl9LHRoaXMuYS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIix0aGlzLl9hMTIpLHRoaXMuX2ExMz1mdW5jdGlvbigpe3NldFRpbWVvdXQoYS5fYTEyKX0sdGhpcy5hLmFkZEV2ZW50TGlzdGVuZXIoXCJjdXRcIix0aGlzLl9hMTMpLHRoaXMuYS5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIix0aGlzLl9hMTMpfX0se2tleTpcIl9qMlwiLHZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYS5nZXRBdHRyaWJ1dGUoXCJtYXhsZW5ndGhcIik7cmV0dXJuIGImJmEubGVuZ3RoPmI/YS5zdWJzdHIoMCxiKTphfX0se2tleTpcIl9sXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuX2E4PWZ1bmN0aW9uKCl7YS5fbDIoKX0sdGhpcy5hLmZvcm0mJnRoaXMuYS5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIix0aGlzLl9hOCksdGhpcy5hLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy5fYTgpfX0se2tleTpcIl9sMlwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoXCIrXCI9PT10aGlzLmEudmFsdWUuY2hhckF0KDApKXt2YXIgYT10aGlzLl9tKHRoaXMuYS52YWx1ZSk7YSYmdGhpcy5zLmRpYWxDb2RlIT09YXx8KHRoaXMuYS52YWx1ZT1cIlwiKX19fSx7a2V5OlwiX21cIix2YWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKC9cXEQvZyxcIlwiKX19LHtrZXk6XCJfbTJcIix2YWx1ZTpmdW5jdGlvbihhKXt2YXIgYz1iLmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7Yy5pbml0RXZlbnQoYSwhMCwhMCksdGhpcy5hLmRpc3BhdGNoRXZlbnQoYyl9fSx7a2V5OlwiX25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMubS5jbGFzc0xpc3QucmVtb3ZlKFwiaXRpX19oaWRlXCIpLHRoaXMubS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsXCJ0cnVlXCIpLHRoaXMuX28oKSx0aGlzLmImJih0aGlzLl94KHRoaXMuYiwhMSksdGhpcy5fMyh0aGlzLmIsITApKSx0aGlzLl9wKCksdGhpcy51LmNsYXNzTGlzdC5hZGQoXCJpdGlfX2Fycm93LS11cFwiKSx0aGlzLl9tMihcIm9wZW46Y291bnRyeWRyb3Bkb3duXCIpfX0se2tleTpcIl9uMlwiLHZhbHVlOmZ1bmN0aW9uKGEsYixjKXtjJiYhYS5jbGFzc0xpc3QuY29udGFpbnMoYik/YS5jbGFzc0xpc3QuYWRkKGIpOiFjJiZhLmNsYXNzTGlzdC5jb250YWlucyhiKSYmYS5jbGFzc0xpc3QucmVtb3ZlKGIpfX0se2tleTpcIl9vXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgYz10aGlzO2lmKHRoaXMuZC5kcm9wZG93bkNvbnRhaW5lciYmdGhpcy5kLmRyb3Bkb3duQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZHJvcGRvd24pLCF0aGlzLmcpe3ZhciBkPXRoaXMuYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxlPWEucGFnZVlPZmZzZXR8fGIuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCxmPWQudG9wK2UsZz10aGlzLm0ub2Zmc2V0SGVpZ2h0LGg9Zit0aGlzLmEub2Zmc2V0SGVpZ2h0K2c8ZSthLmlubmVySGVpZ2h0LGk9Zi1nPmU7aWYodGhpcy5fbjIodGhpcy5tLFwiaXRpX19jb3VudHJ5LWxpc3QtLWRyb3B1cFwiLCFoJiZpKSx0aGlzLmQuZHJvcGRvd25Db250YWluZXIpe3ZhciBqPSFoJiZpPzA6dGhpcy5hLm9mZnNldEhlaWdodDt0aGlzLmRyb3Bkb3duLnN0eWxlLnRvcD1cIlwiLmNvbmNhdChmK2osXCJweFwiKSx0aGlzLmRyb3Bkb3duLnN0eWxlLmxlZnQ9XCJcIi5jb25jYXQoZC5sZWZ0K2IuYm9keS5zY3JvbGxMZWZ0LFwicHhcIiksdGhpcy5fYTQ9ZnVuY3Rpb24oKXtyZXR1cm4gYy5fMigpfSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLl9hNCl9fX19LHtrZXk6XCJfbzJcIix2YWx1ZTpmdW5jdGlvbihhKXtmb3IodmFyIGI9YTtiJiZiIT09dGhpcy5tJiYhYi5jbGFzc0xpc3QuY29udGFpbnMoXCJpdGlfX2NvdW50cnlcIik7KWI9Yi5wYXJlbnROb2RlO3JldHVybiBiPT09dGhpcy5tP251bGw6Yn19LHtrZXk6XCJfcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLl9hMD1mdW5jdGlvbihiKXt2YXIgYz1hLl9vMihiLnRhcmdldCk7YyYmYS5feChjLCExKX0sdGhpcy5tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIix0aGlzLl9hMCksdGhpcy5fYTE9ZnVuY3Rpb24oYil7dmFyIGM9YS5fbzIoYi50YXJnZXQpO2MmJmEuXzEoYyl9LHRoaXMubS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9hMSk7dmFyIGM9ITA7dGhpcy5fYTI9ZnVuY3Rpb24oKXtjfHxhLl8yKCksYz0hMX0sYi5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fYTIpO3ZhciBkPVwiXCIsZT1udWxsO3RoaXMuX2EzPWZ1bmN0aW9uKGIpe2IucHJldmVudERlZmF1bHQoKSxcIkFycm93VXBcIj09PWIua2V5fHxcIkFycm93RG93blwiPT09Yi5rZXk/YS5fcShiLmtleSk6XCJFbnRlclwiPT09Yi5rZXk/YS5fcigpOlwiRXNjYXBlXCI9PT1iLmtleT9hLl8yKCk6L15bYS16QS1aw4Atw78gXSQvLnRlc3QoYi5rZXkpJiYoZSYmY2xlYXJUaW1lb3V0KGUpLGQrPWIua2V5LnRvTG93ZXJDYXNlKCksYS5fcyhkKSxlPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtkPVwiXCJ9LDFlMykpfSxiLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5fYTMpfX0se2tleTpcIl9xXCIsdmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9XCJBcnJvd1VwXCI9PT1hP3RoaXMuYy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOnRoaXMuYy5uZXh0RWxlbWVudFNpYmxpbmc7YiYmKGIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXRpX19kaXZpZGVyXCIpJiYoYj1cIkFycm93VXBcIj09PWE/Yi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOmIubmV4dEVsZW1lbnRTaWJsaW5nKSx0aGlzLl94KGIsITApKX19LHtrZXk6XCJfclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jJiZ0aGlzLl8xKHRoaXMuYyl9fSx7a2V5OlwiX3NcIix2YWx1ZTpmdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMucC5sZW5ndGg7YisrKWlmKHRoaXMuX3QodGhpcy5wW2JdLm5hbWUsYSkpe3ZhciBjPXRoaXMubS5xdWVyeVNlbGVjdG9yKFwiI2l0aS1pdGVtLVwiLmNvbmNhdCh0aGlzLnBbYl0uaXNvMikpO3RoaXMuX3goYywhMSksdGhpcy5fMyhjLCEwKTticmVha319fSx7a2V5OlwiX3RcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybiBhLnN1YnN0cigwLGIubGVuZ3RoKS50b0xvd2VyQ2FzZSgpPT09Yn19LHtrZXk6XCJfdVwiLHZhbHVlOmZ1bmN0aW9uKGIpe3ZhciBjPWI7aWYodGhpcy5kLmZvcm1hdE9uRGlzcGxheSYmYS5pbnRsVGVsSW5wdXRVdGlscyYmdGhpcy5zKXt2YXIgZD0hdGhpcy5kLnNlcGFyYXRlRGlhbENvZGUmJih0aGlzLmQubmF0aW9uYWxNb2RlfHxcIitcIiE9PWMuY2hhckF0KDApKSxlPWludGxUZWxJbnB1dFV0aWxzLm51bWJlckZvcm1hdCxmPWUuTkFUSU9OQUwsZz1lLklOVEVSTkFUSU9OQUwsaD1kP2Y6ZztjPWludGxUZWxJbnB1dFV0aWxzLmZvcm1hdE51bWJlcihjLHRoaXMucy5pc28yLGgpfWM9dGhpcy5fNyhjKSx0aGlzLmEudmFsdWU9Y319LHtrZXk6XCJfdlwiLHZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPWEsYz10aGlzLnMuZGlhbENvZGUsZD1cIjFcIj09PWM7YiYmdGhpcy5kLm5hdGlvbmFsTW9kZSYmZCYmXCIrXCIhPT1iLmNoYXJBdCgwKSYmKFwiMVwiIT09Yi5jaGFyQXQoMCkmJihiPVwiMVwiLmNvbmNhdChiKSksYj1cIitcIi5jb25jYXQoYikpLHRoaXMuZC5zZXBhcmF0ZURpYWxDb2RlJiZjJiZcIitcIiE9PWIuY2hhckF0KDApJiYoYj1cIitcIi5jb25jYXQoYykuY29uY2F0KGIpKTt2YXIgZT10aGlzLl81KGIpLGY9dGhpcy5fbShiKSxnPW51bGw7aWYoZSl7dmFyIGg9dGhpcy5xW3RoaXMuX20oZSldLGk9LTEhPT1oLmluZGV4T2YodGhpcy5zLmlzbzIpJiZmLmxlbmd0aDw9ZS5sZW5ndGgtMTtpZighKFwiMVwiPT09YyYmdGhpcy5fdyhmKSkmJiFpKWZvcih2YXIgaj0wO2o8aC5sZW5ndGg7aisrKWlmKGhbal0pe2c9aFtqXTticmVha319ZWxzZVwiK1wiPT09Yi5jaGFyQXQoMCkmJmYubGVuZ3RoP2c9XCJcIjpiJiZcIitcIiE9PWJ8fChnPXRoaXMuaik7cmV0dXJuIG51bGwhPT1nJiZ0aGlzLl96KGcpfX0se2tleTpcIl93XCIsdmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fbShhKTtpZihcIjFcIj09PWIuY2hhckF0KDApKXt2YXIgYz1iLnN1YnN0cigxLDMpO3JldHVybi0xIT09bC5pbmRleE9mKGMpfXJldHVybiExfX0se2tleTpcIl94XCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmM7YyYmYy5jbGFzc0xpc3QucmVtb3ZlKFwiaXRpX19oaWdobGlnaHRcIiksdGhpcy5jPWEsdGhpcy5jLmNsYXNzTGlzdC5hZGQoXCJpdGlfX2hpZ2hsaWdodFwiKSxiJiZ0aGlzLmMuZm9jdXMoKX19LHtrZXk6XCJfeVwiLHZhbHVlOmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9Yj9nOnRoaXMucCxlPTA7ZTxkLmxlbmd0aDtlKyspaWYoZFtlXS5pc28yPT09YSlyZXR1cm4gZFtlXTtpZihjKXJldHVybiBudWxsO3Rocm93IG5ldyBFcnJvcihcIk5vIGNvdW50cnkgZGF0YSBmb3IgJ1wiLmNvbmNhdChhLFwiJ1wiKSl9fSx7a2V5OlwiX3pcIix2YWx1ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnMuaXNvMj90aGlzLnM6e307dGhpcy5zPWE/dGhpcy5feShhLCExLCExKTp7fSx0aGlzLnMuaXNvMiYmKHRoaXMuaj10aGlzLnMuaXNvMiksdGhpcy5sLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsXCJpdGlfX2ZsYWcgaXRpX19cIi5jb25jYXQoYSkpO3ZhciBjPWE/XCJcIi5jb25jYXQodGhpcy5zLm5hbWUsXCI6ICtcIikuY29uY2F0KHRoaXMucy5kaWFsQ29kZSk6XCJVbmtub3duXCI7aWYodGhpcy5zZWxlY3RlZEZsYWcuc2V0QXR0cmlidXRlKFwidGl0bGVcIixjKSx0aGlzLmQuc2VwYXJhdGVEaWFsQ29kZSl7dmFyIGQ9dGhpcy5zLmRpYWxDb2RlP1wiK1wiLmNvbmNhdCh0aGlzLnMuZGlhbENvZGUpOlwiXCI7dGhpcy50LmlubmVySFRNTD1kO3ZhciBlPXRoaXMuc2VsZWN0ZWRGbGFnLm9mZnNldFdpZHRofHx0aGlzLl9nZXRIaWRkZW5TZWxlY3RlZEZsYWdXaWR0aCgpO3RoaXMuYS5zdHlsZS5wYWRkaW5nTGVmdD1cIlwiLmNvbmNhdChlKzYsXCJweFwiKX1pZih0aGlzLl8wKCksdGhpcy5kLmFsbG93RHJvcGRvd24pe3ZhciBmPXRoaXMuYjtpZihmJiYoZi5jbGFzc0xpc3QucmVtb3ZlKFwiaXRpX19hY3RpdmVcIiksZi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsXCJmYWxzZVwiKSksYSl7dmFyIGc9dGhpcy5tLnF1ZXJ5U2VsZWN0b3IoXCIjaXRpLWl0ZW0tXCIuY29uY2F0KGEpKTtnLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIixcInRydWVcIiksZy5jbGFzc0xpc3QuYWRkKFwiaXRpX19hY3RpdmVcIiksdGhpcy5iPWcsdGhpcy5tLnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLGcuZ2V0QXR0cmlidXRlKFwiaWRcIikpfX1yZXR1cm4gYi5pc28yIT09YX19LHtrZXk6XCJfZ2V0SGlkZGVuU2VsZWN0ZWRGbGFnV2lkdGhcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuYS5wYXJlbnROb2RlLmNsb25lTm9kZSgpO2Euc3R5bGUudmlzaWJpbGl0eT1cImhpZGRlblwiLGIuYm9keS5hcHBlbmRDaGlsZChhKTt2YXIgYz10aGlzLnNlbGVjdGVkRmxhZy5jbG9uZU5vZGUoITApO2EuYXBwZW5kQ2hpbGQoYyk7dmFyIGQ9Yy5vZmZzZXRXaWR0aDtyZXR1cm4gYS5yZW1vdmUoKSxkfX0se2tleTpcIl8wXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgYj1cImFnZ3Jlc3NpdmVcIj09PXRoaXMuZC5hdXRvUGxhY2Vob2xkZXJ8fCF0aGlzLmUmJlwicG9saXRlXCI9PT10aGlzLmQuYXV0b1BsYWNlaG9sZGVyO2lmKGEuaW50bFRlbElucHV0VXRpbHMmJmIpe3ZhciBjPWludGxUZWxJbnB1dFV0aWxzLm51bWJlclR5cGVbdGhpcy5kLnBsYWNlaG9sZGVyTnVtYmVyVHlwZV0sZD10aGlzLnMuaXNvMj9pbnRsVGVsSW5wdXRVdGlscy5nZXRFeGFtcGxlTnVtYmVyKHRoaXMucy5pc28yLHRoaXMuZC5uYXRpb25hbE1vZGUsYyk6XCJcIjtkPXRoaXMuXzcoZCksXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5kLmN1c3RvbVBsYWNlaG9sZGVyJiYoZD10aGlzLmQuY3VzdG9tUGxhY2Vob2xkZXIoZCx0aGlzLnMpKSx0aGlzLmEuc2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIixkKX19fSx7a2V5OlwiXzFcIix2YWx1ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLl96KGEuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb3VudHJ5LWNvZGVcIikpO3RoaXMuXzIoKSx0aGlzLl80KGEuZ2V0QXR0cmlidXRlKFwiZGF0YS1kaWFsLWNvZGVcIiksITApLHRoaXMuYS5mb2N1cygpO3ZhciBjPXRoaXMuYS52YWx1ZS5sZW5ndGg7dGhpcy5hLnNldFNlbGVjdGlvblJhbmdlKGMsYyksYiYmdGhpcy5fOCgpfX0se2tleTpcIl8yXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm0uY2xhc3NMaXN0LmFkZChcIml0aV9faGlkZVwiKSx0aGlzLm0uc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLFwiZmFsc2VcIiksdGhpcy51LmNsYXNzTGlzdC5yZW1vdmUoXCJpdGlfX2Fycm93LS11cFwiKSxiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5fYTMpLGIuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX2EyKSx0aGlzLm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLHRoaXMuX2EwKSx0aGlzLm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fYTEpLHRoaXMuZC5kcm9wZG93bkNvbnRhaW5lciYmKHRoaXMuZ3x8YS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5fYTQpLHRoaXMuZHJvcGRvd24ucGFyZW50Tm9kZSYmdGhpcy5kcm9wZG93bi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZHJvcGRvd24pKSx0aGlzLl9tMihcImNsb3NlOmNvdW50cnlkcm9wZG93blwiKX19LHtrZXk6XCJfM1wiLHZhbHVlOmZ1bmN0aW9uKGMsZCl7dmFyIGU9dGhpcy5tLGY9YS5wYWdlWU9mZnNldHx8Yi5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLGc9ZS5vZmZzZXRIZWlnaHQsaD1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCtmLGk9aCtnLGo9Yy5vZmZzZXRIZWlnaHQsaz1jLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCtmLGw9aytqLG09ay1oK2Uuc2Nyb2xsVG9wLG49Zy8yLWovMjtpZihrPGgpZCYmKG0tPW4pLGUuc2Nyb2xsVG9wPW07ZWxzZSBpZihsPmkpe2QmJihtKz1uKTt2YXIgbz1nLWo7ZS5zY3JvbGxUb3A9bS1vfX19LHtrZXk6XCJfNFwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGMsZD10aGlzLmEudmFsdWUsZT1cIitcIi5jb25jYXQoYSk7aWYoXCIrXCI9PT1kLmNoYXJBdCgwKSl7dmFyIGY9dGhpcy5fNShkKTtjPWY/ZC5yZXBsYWNlKGYsZSk6ZX1lbHNle2lmKHRoaXMuZC5uYXRpb25hbE1vZGV8fHRoaXMuZC5zZXBhcmF0ZURpYWxDb2RlKXJldHVybjtpZihkKWM9ZStkO2Vsc2V7aWYoIWImJnRoaXMuZC5hdXRvSGlkZURpYWxDb2RlKXJldHVybjtjPWV9fXRoaXMuYS52YWx1ZT1jfX0se2tleTpcIl81XCIsdmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9XCJcIjtpZihcIitcIj09PWEuY2hhckF0KDApKWZvcih2YXIgYz1cIlwiLGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIGU9YS5jaGFyQXQoZCk7aWYoIWlzTmFOKHBhcnNlSW50KGUsMTApKSYmKGMrPWUsdGhpcy5xW2NdJiYoYj1hLnN1YnN0cigwLGQrMSkpLGMubGVuZ3RoPT09dGhpcy5kaWFsQ29kZU1heExlbikpYnJlYWt9cmV0dXJuIGJ9fSx7a2V5OlwiXzZcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuYS52YWx1ZS50cmltKCksYj10aGlzLnMuZGlhbENvZGUsYz10aGlzLl9tKGEpO3JldHVybih0aGlzLmQuc2VwYXJhdGVEaWFsQ29kZSYmXCIrXCIhPT1hLmNoYXJBdCgwKSYmYiYmYz9cIitcIi5jb25jYXQoYik6XCJcIikrYX19LHtrZXk6XCJfN1wiLHZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPWE7aWYodGhpcy5kLnNlcGFyYXRlRGlhbENvZGUpe3ZhciBjPXRoaXMuXzUoYik7aWYoYyl7Yz1cIitcIi5jb25jYXQodGhpcy5zLmRpYWxDb2RlKTt2YXIgZD1cIiBcIj09PWJbYy5sZW5ndGhdfHxcIi1cIj09PWJbYy5sZW5ndGhdP2MubGVuZ3RoKzE6Yy5sZW5ndGg7Yj1iLnN1YnN0cihkKX19cmV0dXJuIHRoaXMuX2oyKGIpfX0se2tleTpcIl84XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9tMihcImNvdW50cnljaGFuZ2VcIil9fSx7a2V5OlwiaGFuZGxlQXV0b0NvdW50cnlcIix2YWx1ZTpmdW5jdGlvbigpe1wiYXV0b1wiPT09dGhpcy5kLmluaXRpYWxDb3VudHJ5JiYodGhpcy5qPWEuaW50bFRlbElucHV0R2xvYmFscy5hdXRvQ291bnRyeSx0aGlzLmEudmFsdWV8fHRoaXMuc2V0Q291bnRyeSh0aGlzLmopLHRoaXMuaCgpKX19LHtrZXk6XCJoYW5kbGVVdGlsc1wiLHZhbHVlOmZ1bmN0aW9uKCl7YS5pbnRsVGVsSW5wdXRVdGlscyYmKHRoaXMuYS52YWx1ZSYmdGhpcy5fdSh0aGlzLmEudmFsdWUpLHRoaXMuXzAoKSksdGhpcy5pMCgpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBiPXRoaXMuYS5mb3JtO2lmKHRoaXMuZC5hbGxvd0Ryb3Bkb3duKXt0aGlzLl8yKCksdGhpcy5zZWxlY3RlZEZsYWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fYTEwKSx0aGlzLmsucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLl9hMTEpO3ZhciBjPXRoaXMuX2kxKCk7YyYmYy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9hOSl9dGhpcy5oaWRkZW5JbnB1dCYmYiYmYi5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VibWl0XCIsdGhpcy5fYTE0KSx0aGlzLmQuYXV0b0hpZGVEaWFsQ29kZSYmKGImJmIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLHRoaXMuX2E4KSx0aGlzLmEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIix0aGlzLl9hOCkpLHRoaXMuYS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIix0aGlzLl9hMTIpLHRoaXMuYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY3V0XCIsdGhpcy5fYTEzKSx0aGlzLmEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsdGhpcy5fYTEzKSx0aGlzLmEucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1pbnRsLXRlbC1pbnB1dC1pZFwiKTt2YXIgZD10aGlzLmEucGFyZW50Tm9kZTtkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYSxkKSxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksZGVsZXRlIGEuaW50bFRlbElucHV0R2xvYmFscy5pbnN0YW5jZXNbdGhpcy5pZF19fSx7a2V5OlwiZ2V0RXh0ZW5zaW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gYS5pbnRsVGVsSW5wdXRVdGlscz9pbnRsVGVsSW5wdXRVdGlscy5nZXRFeHRlbnNpb24odGhpcy5fNigpLHRoaXMucy5pc28yKTpcIlwifX0se2tleTpcImdldE51bWJlclwiLHZhbHVlOmZ1bmN0aW9uKGIpe2lmKGEuaW50bFRlbElucHV0VXRpbHMpe3ZhciBjPXRoaXMucy5pc28yO3JldHVybiBpbnRsVGVsSW5wdXRVdGlscy5mb3JtYXROdW1iZXIodGhpcy5fNigpLGMsYil9cmV0dXJuXCJcIn19LHtrZXk6XCJnZXROdW1iZXJUeXBlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gYS5pbnRsVGVsSW5wdXRVdGlscz9pbnRsVGVsSW5wdXRVdGlscy5nZXROdW1iZXJUeXBlKHRoaXMuXzYoKSx0aGlzLnMuaXNvMik6LTk5fX0se2tleTpcImdldFNlbGVjdGVkQ291bnRyeURhdGFcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN9fSx7a2V5OlwiZ2V0VmFsaWRhdGlvbkVycm9yXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZihhLmludGxUZWxJbnB1dFV0aWxzKXt2YXIgYj10aGlzLnMuaXNvMjtyZXR1cm4gaW50bFRlbElucHV0VXRpbHMuZ2V0VmFsaWRhdGlvbkVycm9yKHRoaXMuXzYoKSxiKX1yZXR1cm4tOTl9fSx7a2V5OlwiaXNWYWxpZE51bWJlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5fNigpLnRyaW0oKSxjPXRoaXMuZC5uYXRpb25hbE1vZGU/dGhpcy5zLmlzbzI6XCJcIjtyZXR1cm4gYS5pbnRsVGVsSW5wdXRVdGlscz9pbnRsVGVsSW5wdXRVdGlscy5pc1ZhbGlkTnVtYmVyKGIsYyk6bnVsbH19LHtrZXk6XCJzZXRDb3VudHJ5XCIsdmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9YS50b0xvd2VyQ2FzZSgpO3RoaXMubC5jbGFzc0xpc3QuY29udGFpbnMoXCJpdGlfX1wiLmNvbmNhdChiKSl8fCh0aGlzLl96KGIpLHRoaXMuXzQodGhpcy5zLmRpYWxDb2RlLCExKSx0aGlzLl84KCkpfX0se2tleTpcInNldE51bWJlclwiLHZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX3YoYSk7dGhpcy5fdShhKSxiJiZ0aGlzLl84KCl9fSx7a2V5Olwic2V0UGxhY2Vob2xkZXJOdW1iZXJUeXBlXCIsdmFsdWU6ZnVuY3Rpb24oYSl7dGhpcy5kLnBsYWNlaG9sZGVyTnVtYmVyVHlwZT1hLHRoaXMuXzAoKX19XSksZX0oKVxuO2EuaW50bFRlbElucHV0R2xvYmFscy5nZXRDb3VudHJ5RGF0YT1mdW5jdGlvbigpe3JldHVybiBnfTt2YXIgcD1mdW5jdGlvbihhLGMsZCl7dmFyIGU9Yi5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2Uub25sb2FkPWZ1bmN0aW9uKCl7bihcImhhbmRsZVV0aWxzXCIpLGMmJmMoKX0sZS5vbmVycm9yPWZ1bmN0aW9uKCl7bihcInJlamVjdFV0aWxzU2NyaXB0UHJvbWlzZVwiKSxkJiZkKCl9LGUuY2xhc3NOYW1lPVwiaXRpLWxvYWQtdXRpbHNcIixlLmFzeW5jPSEwLGUuc3JjPWEsYi5ib2R5LmFwcGVuZENoaWxkKGUpfTtyZXR1cm4gYS5pbnRsVGVsSW5wdXRHbG9iYWxzLmxvYWRVdGlscz1mdW5jdGlvbihiKXtpZighYS5pbnRsVGVsSW5wdXRVdGlscyYmIWEuaW50bFRlbElucHV0R2xvYmFscy5zdGFydGVkTG9hZGluZ1V0aWxzU2NyaXB0KXtpZihhLmludGxUZWxJbnB1dEdsb2JhbHMuc3RhcnRlZExvYWRpbmdVdGlsc1NjcmlwdD0hMCxcInVuZGVmaW5lZFwiIT10eXBlb2YgUHJvbWlzZSlyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oYSxjKXtyZXR1cm4gcChiLGEsYyl9KTtwKGIpfXJldHVybiBudWxsfSxhLmludGxUZWxJbnB1dEdsb2JhbHMuZGVmYXVsdHM9ayxhLmludGxUZWxJbnB1dEdsb2JhbHMudmVyc2lvbj1cIjE2LjAuMFwiLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9bmV3IG8oYixjKTtyZXR1cm4gZC5faW5pdCgpLGIuc2V0QXR0cmlidXRlKFwiZGF0YS1pbnRsLXRlbC1pbnB1dC1pZFwiLGQuaWQpLGEuaW50bFRlbElucHV0R2xvYmFscy5pbnN0YW5jZXNbZC5pZF09ZCxkfX0oKX0od2luZG93LGRvY3VtZW50KTtcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1iOndpbmRvdy5pbnRsVGVsSW5wdXQ9Yn0oKTsiLCIvKiFcbiAgWm9vbSAxLjcuMjFcbiAgbGljZW5zZTogTUlUXG4gIGh0dHA6Ly93d3cuamFja2xtb29yZS5jb20vem9vbVxuKi9cbihmdW5jdGlvbiAoJCkge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgdXJsOiBmYWxzZSxcbiAgICBjYWxsYmFjazogZmFsc2UsXG4gICAgdGFyZ2V0OiBmYWxzZSxcbiAgICBkdXJhdGlvbjogMTIwLFxuICAgIG9uOiAnbW91c2VvdmVyJywgLy8gb3RoZXIgb3B0aW9uczogZ3JhYiwgY2xpY2ssIHRvZ2dsZVxuICAgIHRvdWNoOiB0cnVlLCAvLyBlbmFibGVzIGEgdG91Y2ggZmFsbGJhY2tcbiAgICBvblpvb21JbjogZmFsc2UsXG4gICAgb25ab29tT3V0OiBmYWxzZSxcbiAgICBtYWduaWZ5OiAxXG4gIH07XG5cbiAgLy8gQ29yZSBab29tIExvZ2ljLCBpbmRlcGVuZGVudCBvZiBldmVudCBsaXN0ZW5lcnMuXG4gICQuem9vbSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgaW1nLCBtYWduaWZ5KSB7XG4gICAgdmFyIHRhcmdldEhlaWdodCxcbiAgICAgIHRhcmdldFdpZHRoLFxuICAgICAgc291cmNlSGVpZ2h0LFxuICAgICAgc291cmNlV2lkdGgsXG4gICAgICB4UmF0aW8sXG4gICAgICB5UmF0aW8sXG4gICAgICBvZmZzZXQsXG4gICAgICAkdGFyZ2V0ID0gJCh0YXJnZXQpLFxuICAgICAgcG9zaXRpb24gPSAkdGFyZ2V0LmNzcygncG9zaXRpb24nKSxcbiAgICAgICRzb3VyY2UgPSAkKHNvdXJjZSk7XG5cbiAgICAvLyBUaGUgcGFyZW50IGVsZW1lbnQgbmVlZHMgcG9zaXRpb25pbmcgc28gdGhhdCB0aGUgem9vbWVkIGVsZW1lbnQgY2FuIGJlIGNvcnJlY3RseSBwb3NpdGlvbmVkIHdpdGhpbi5cbiAgICB0YXJnZXQuc3R5bGUucG9zaXRpb24gPSAvKGFic29sdXRlfGZpeGVkKS8udGVzdChwb3NpdGlvbikgPyBwb3NpdGlvbiA6ICdyZWxhdGl2ZSc7XG4gICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgaW1nLnN0eWxlLndpZHRoID0gaW1nLnN0eWxlLmhlaWdodCA9ICcnO1xuXG4gICAgJChpbWcpXG4gICAgICAuYWRkQ2xhc3MoJ3pvb21JbWcnKVxuICAgICAgLmNzcyh7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHdpZHRoOiBpbWcud2lkdGggKiBtYWduaWZ5LFxuICAgICAgICBoZWlnaHQ6IGltZy5oZWlnaHQgKiBtYWduaWZ5LFxuICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgbWF4V2lkdGg6ICdub25lJyxcbiAgICAgICAgbWF4SGVpZ2h0OiAnbm9uZSdcbiAgICAgIH0pXG4gICAgICAuYXBwZW5kVG8odGFyZ2V0KTtcblxuICAgIHJldHVybiB7XG4gICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRhcmdldFdpZHRoID0gJHRhcmdldC5vdXRlcldpZHRoKCk7XG4gICAgICAgIHRhcmdldEhlaWdodCA9ICR0YXJnZXQub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgICBpZiAoc291cmNlID09PSB0YXJnZXQpIHtcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IHRhcmdldFdpZHRoO1xuICAgICAgICAgIHNvdXJjZUhlaWdodCA9IHRhcmdldEhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9ICRzb3VyY2Uub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgIHNvdXJjZUhlaWdodCA9ICRzb3VyY2Uub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhSYXRpbyA9IChpbWcud2lkdGggLSB0YXJnZXRXaWR0aCkgLyBzb3VyY2VXaWR0aDtcbiAgICAgICAgeVJhdGlvID0gKGltZy5oZWlnaHQgLSB0YXJnZXRIZWlnaHQpIC8gc291cmNlSGVpZ2h0O1xuXG4gICAgICAgIG9mZnNldCA9ICRzb3VyY2Uub2Zmc2V0KCk7XG4gICAgICB9LFxuICAgICAgbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGxlZnQgPSAoZS5wYWdlWCAtIG9mZnNldC5sZWZ0KSxcbiAgICAgICAgICB0b3AgPSAoZS5wYWdlWSAtIG9mZnNldC50b3ApO1xuXG4gICAgICAgIHRvcCA9IE1hdGgubWF4KE1hdGgubWluKHRvcCwgc291cmNlSGVpZ2h0KSwgMCk7XG4gICAgICAgIGxlZnQgPSBNYXRoLm1heChNYXRoLm1pbihsZWZ0LCBzb3VyY2VXaWR0aCksIDApO1xuXG4gICAgICAgIGltZy5zdHlsZS5sZWZ0ID0gKGxlZnQgKiAteFJhdGlvKSArICdweCc7XG4gICAgICAgIGltZy5zdHlsZS50b3AgPSAodG9wICogLXlSYXRpbykgKyAncHgnO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgJC5mbi56b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhclxuICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSksXG4gICAgICAgIC8vdGFyZ2V0IHdpbGwgZGlzcGxheSB0aGUgem9vbWVkIGltYWdlXG4gICAgICAgIHRhcmdldCA9IHNldHRpbmdzLnRhcmdldCAmJiAkKHNldHRpbmdzLnRhcmdldClbMF0gfHwgdGhpcyxcbiAgICAgICAgLy9zb3VyY2Ugd2lsbCBwcm92aWRlIHpvb20gbG9jYXRpb24gaW5mbyAodGh1bWJuYWlsKVxuICAgICAgICBzb3VyY2UgPSB0aGlzLFxuICAgICAgICAkc291cmNlID0gJChzb3VyY2UpLFxuICAgICAgICBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKSxcbiAgICAgICAgJGltZyA9ICQoaW1nKSxcbiAgICAgICAgbW91c2Vtb3ZlID0gJ21vdXNlbW92ZS56b29tJyxcbiAgICAgICAgY2xpY2tlZCA9IGZhbHNlLFxuICAgICAgICB0b3VjaGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIElmIGEgdXJsIHdhc24ndCBzcGVjaWZpZWQsIGxvb2sgZm9yIGFuIGltYWdlIGVsZW1lbnQuXG4gICAgICBpZiAoIXNldHRpbmdzLnVybCkge1xuICAgICAgICB2YXIgc3JjRWxlbWVudCA9IHNvdXJjZS5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICAgICAgaWYgKHNyY0VsZW1lbnQpIHtcbiAgICAgICAgICBzZXR0aW5ncy51cmwgPSBzcmNFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKSB8fCBzcmNFbGVtZW50LmN1cnJlbnRTcmMgfHwgc3JjRWxlbWVudC5zcmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZXR0aW5ncy51cmwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgJHNvdXJjZS5vbmUoJ3pvb20uZGVzdHJveScsIGZ1bmN0aW9uIChwb3NpdGlvbiwgb3ZlcmZsb3cpIHtcbiAgICAgICAgJHNvdXJjZS5vZmYoXCIuem9vbVwiKTtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRhcmdldC5zdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICBpbWcub25sb2FkID0gbnVsbDtcbiAgICAgICAgJGltZy5yZW1vdmUoKTtcbiAgICAgIH0uYmluZCh0aGlzLCB0YXJnZXQuc3R5bGUucG9zaXRpb24sIHRhcmdldC5zdHlsZS5vdmVyZmxvdykpO1xuXG4gICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgem9vbSA9ICQuem9vbSh0YXJnZXQsIHNvdXJjZSwgaW1nLCBzZXR0aW5ncy5tYWduaWZ5KTtcblxuICAgICAgICBmdW5jdGlvbiBzdGFydChlKSB7XG4gICAgICAgICAgem9vbS5pbml0KCk7XG4gICAgICAgICAgem9vbS5tb3ZlKGUpO1xuXG4gICAgICAgICAgLy8gU2tpcCB0aGUgZmFkZS1pbiBmb3IgSUU4IGFuZCBsb3dlciBzaW5jZSBpdCBjaG9rZXMgb24gZmFkaW5nLWluXG4gICAgICAgICAgLy8gYW5kIGNoYW5naW5nIHBvc2l0aW9uIGJhc2VkIG9uIG1vdXNlbW92ZW1lbnQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAkaW1nLnN0b3AoKVxuICAgICAgICAgICAgLmZhZGVUbygkLnN1cHBvcnQub3BhY2l0eSA/IHNldHRpbmdzLmR1cmF0aW9uIDogMCwgMSwgJC5pc0Z1bmN0aW9uKHNldHRpbmdzLm9uWm9vbUluKSA/IHNldHRpbmdzLm9uWm9vbUluLmNhbGwoaW1nKSA6IGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgJGltZy5zdG9wKClcbiAgICAgICAgICAgIC5mYWRlVG8oc2V0dGluZ3MuZHVyYXRpb24sIDAsICQuaXNGdW5jdGlvbihzZXR0aW5ncy5vblpvb21PdXQpID8gc2V0dGluZ3Mub25ab29tT3V0LmNhbGwoaW1nKSA6IGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdXNlIGV2ZW50c1xuICAgICAgICBpZiAoc2V0dGluZ3Mub24gPT09ICdncmFiJykge1xuICAgICAgICAgICRzb3VyY2VcbiAgICAgICAgICAgIC5vbignbW91c2Vkb3duLnpvb20nLFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5vbmUoJ21vdXNldXAuem9vbScsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5vZmYobW91c2Vtb3ZlLCB6b29tLm1vdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICBzdGFydChlKTtcblxuICAgICAgICAgICAgICAgICAgJChkb2N1bWVudCkub24obW91c2Vtb3ZlLCB6b29tLm1vdmUpO1xuXG4gICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9uID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgJHNvdXJjZS5vbignY2xpY2suem9vbScsXG4gICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoY2xpY2tlZCkge1xuICAgICAgICAgICAgICAgIC8vIGJ1YmJsZSB0aGUgZXZlbnQgdXAgdG8gdGhlIGRvY3VtZW50IHRvIHRyaWdnZXIgdGhlIHVuYmluZC5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xpY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhcnQoZSk7XG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkub24obW91c2Vtb3ZlLCB6b29tLm1vdmUpO1xuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uZSgnY2xpY2suem9vbScsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5vZmYobW91c2Vtb3ZlLCB6b29tLm1vdmUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5vbiA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgICAkc291cmNlLm9uKCdjbGljay56b29tJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmIChjbGlja2VkKSB7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0KGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNsaWNrZWQgPSAhY2xpY2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9uID09PSAnbW91c2VvdmVyJykge1xuICAgICAgICAgIHpvb20uaW5pdCgpOyAvLyBQcmVlbXB0aXZlbHkgY2FsbCBpbml0IGJlY2F1c2UgSUU3IHdpbGwgZmlyZSB0aGUgbW91c2Vtb3ZlIGhhbmRsZXIgYmVmb3JlIHRoZSBob3ZlciBoYW5kbGVyLlxuXG4gICAgICAgICAgJHNvdXJjZVxuICAgICAgICAgICAgLm9uKCdtb3VzZWVudGVyLnpvb20nLCBzdGFydClcbiAgICAgICAgICAgIC5vbignbW91c2VsZWF2ZS56b29tJywgc3RvcClcbiAgICAgICAgICAgIC5vbihtb3VzZW1vdmUsIHpvb20ubW92ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUb3VjaCBmYWxsYmFja1xuICAgICAgICBpZiAoc2V0dGluZ3MudG91Y2gpIHtcbiAgICAgICAgICAkc291cmNlXG4gICAgICAgICAgICAub24oJ3RvdWNoc3RhcnQuem9vbScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgaWYgKHRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgICB0b3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvdWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXJ0KGUub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdIHx8IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ3RvdWNobW92ZS56b29tJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICB6b29tLm1vdmUoZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0gfHwgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ3RvdWNoZW5kLnpvb20nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGlmICh0b3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgdG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHNldHRpbmdzLmNhbGxiYWNrKSkge1xuICAgICAgICAgIHNldHRpbmdzLmNhbGxiYWNrLmNhbGwoaW1nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaW1nLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcbiAgICAgIGltZy5hbHQgPSAnJztcbiAgICAgIGltZy5zcmMgPSBzZXR0aW5ncy51cmw7XG4gICAgfSk7XG4gIH07XG5cbiAgJC5mbi56b29tLmRlZmF1bHRzID0gZGVmYXVsdHM7XG59KHdpbmRvdy5qUXVlcnkpKTsiLCIvKiFcbiogY291bnRyeS1yZWdpb24tc2VsZWN0b3JcbiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIDEuMC4wXG4qIEBhdXRob3IgQmVuIEtlZW5cbiogQHJlcG8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmtlZW4vY291bnRyeS1yZWdpb24tc2VsZWN0b3JcbiogQGxpY2VuY2UgTUlUXG4qL1xuXG4hZnVuY3Rpb24gKGEsIG4pIHsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQpIGRlZmluZShbXSwgbik7IGVsc2UgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMpIHRyeSB7IG1vZHVsZS5leHBvcnRzID0gbihyZXF1aXJlKCkpIH0gY2F0Y2ggKGEpIHsgbW9kdWxlLmV4cG9ydHMgPSBuKCkgfSBlbHNlIGEuY3JzID0gbigpIH0odGhpcywgZnVuY3Rpb24gKCkgeyBcInVzZSBzdHJpY3RcIjsgdmFyIG0gPSAhMCwgaCA9ICEwLCBNID0gW10sIGwgPSBbW1wiQWZnaGFuaXN0YW5cIiwgXCJBRlwiLCBcIkJhZGFraHNoYW5+QkRTfEJhZGdoaXN+QkRHfEJhZ2hsYW5+QkdMfEJhbGtofkJBTHxCYW15YW5+QkFNfERheWt1bmRpfkRBWXxGYXJhaH5GUkF8RmFyeWFifkZZQnxHaGF6bml+R0hBfEdob3J+R0hPfEhlbG1hbmR+SEVMfEhlcmF0fkhFUnxKb3d6amFufkpPV3xLYWJ1bH5LQUJ8S2FuZGFoYXJ+S0FOfEthcGlzYX5LQVB8S2hvc3R+S0hPfEt1bmFyfktOUnxLdW5kdXp+S0RafExhZ2htYW5+TEFHfExvZ2FyfkxPV3xNYWlkYW4gV2FyZGFrfldBUnxOYW5nYXJoYXJ+TkFOfE5pbXJ1en5OSU18TnVyaXN0YW5+TlVSfFBha3RpYX5QSUF8UGFrdGlrYX5QS0F8UGFuanNoaXJ+UEFOfFBhcndhbn5QQVJ8U2FtYW5nYW5+U0FNfFNhci1lIFBvbH5TQVJ8VGFraGFyflRBS3xVcm96Z2Fufk9SVXxaYWJ1bH5aQUJcIl0sIFtcIsOFbGFuZCBJc2xhbmRzXCIsIFwiQVhcIiwgXCJCcsOkbmTDtn5CUnxFY2tlcsO2fkVDfEZpbnN0csO2bX5GTnxGw7ZnbMO2fkZHfEdldGF+R1R8SGFtbWFybGFuZH5ITXxKb21hbGF+Sk18S3VtbGluZ2V+S018S8O2a2FyfktLfExlbWxhbmR+TEV8THVtcGFybGFuZH5MVXxNYXJpZWhhbW5+TUh8U2FsdHZpa35TVnxTb3R0dW5nYX5TVHxTdW5kflNEfFbDpXJkw7Z+VlJcIl0sIFtcIkFsYmFuaWFcIiwgXCJBTFwiLCBcIkJlcmF0fjAxfERpYsOrcn4wOXxEdXJyw6tzfjAyfEVsYmFzYW5+MDN8Rmllcn4wNHxHamlyb2thc3TDq3J+MDV8S29yw6fDq34wNnxLdWvDq3N+MDd8TGV6aMOrfjA4fFNoa29kw6tyfjEwfFRpcmFuYX4xMXxWbG9yw6t+MTJcIl0sIFtcIkFsZ2VyaWFcIiwgXCJEWlwiLCBcIkFkcmFyfjAxfEHDr24gRGVmbGF+NDR8QcOvbiBUw6ltb3VjaGVudH40NnxBbGdpZXJzfjE2fEFubmFiYX4yM3xCYXRuYX4wNXxCw6ljaGFyfjA4fELDqWphw69hfjA2fEJpc2tyYX4wN3xCbGlkYX4wOXxCb3JkaiBCb3UgQXJyw6lyaWRqfjM0fEJvdcOvcmF+MTB8Qm91bWVyZMOoc34zNXxDaGxlZn4wMnxDb25zdGFudGluZX4yNXxEamVsZmF+MTd8RWwgQmF5YWRofjMyfEVsIE91ZWR+Mzl8RWwgVGFyZn4zNnxHaGFyZGHDr2F+NDd8R3VlbG1hfjI0fElsbGl6aX4zM3xKaWplbH4xOHxLaGVuY2hlbGF+NDB8TGFnaG91YXR+MDN8TWFzY2FyYX4yOXxNw6lkw6lhfjI2fE1pbGF+NDN8TW9zdGFnYW5lbX4yN3xNc2lsYX4yOHxOYcOibWF+NDV8T3Jhbn4zMXxPdWFyZ2xhfjMwfE91bSBlbCBCb3VhZ2hpfjA0fFJlbGl6YW5lfjQ4fFNhw69kYX4yMHxTw6l0aWZ+MTl8U2lkaSBCZWwgQWJiw6hzfjIyfFNraWtkYX4yMXxTb3VrIEFocmFzfjQxfFRhbWFuZ2hhc3NldH4xMXxUw6liZXNzYX4xMnxUaWFyZXR+MTR8VGluZG91Zn4zN3xUaXBhemF+NDJ8VGlzc2Vtc2lsdH4zOHxUaXppIE91em91fjE1fFRsZW1jZW5+MTNcIl0sIFtcIkFtZXJpY2FuIFNhbW9hXCIsIFwiQVNcIiwgXCJUdXR1aWxhfjAxfEF1bnUndX4wMnxUYSfFq34wM3xPZnXigJFPbG9zZWdhfjA0fFJvc2UgQXRvbGx+MjF8U3dhaW5zIElzbGFuZH4yMlwiXSwgW1wiQW5kb3JyYVwiLCBcIkFEXCIsIFwiQW5kb3JyYSBsYSBWZWxsYX4wN3xDYW5pbGxvfjAyfEVuY2FtcH4wM3xFc2NhbGRlcy1FbmdvcmRhbnl+MDh8TGEgTWFzc2FuYX4wNHxPcmRpbm9+MDV8U2FudCBKdWxpw6AgZGUgTMOycmlhfjA2XCJdLCBbXCJBbmdvbGFcIiwgXCJBT1wiLCBcIkJlbmdvfkJHT3xCZW5ndWVsYX5CR1V8QmnDqX5CSUV8Q2FiaW5kYX5DQUJ8Q3VhbmRvIEN1YmFuZ29+Q0NVfEN1YW56YSBOb3J0ZX5DTk98Q3VhbnphIFN1bH5DVVN8Q3VuZW5lfkNOTnxIdWFtYm9+SFVBfEh1w61sYX5IVUl8THVhbmRhfkxVQXxMdW5kYSBOb3J0ZX5MTk98THVuZGEgU3VsfkxTVXxNYWxhbmplfk1BTHxNb3hpY29+TU9YfE5hbWliZX5OQU18VcOtZ2V+VUlHfFphaXJlflpBSVwiXSwgW1wiQW5ndWlsbGFcIiwgXCJBSVwiLCBcIkFuZ3VpbGxhfjAxfEFuZ3VpbGxpdGEgSXNsYW5kfjAyfEJsb3dpbmcgUm9ja34wM3xDb3ZlIENheX4wNHxDcm9jdXMgQ2F5fjA1fERlYWRtYW4ncyBDYXl+MDZ8RG9nIElzbGFuZH4wN3xFYXN0IENheX4wOHxMaXR0bGUgSXNsYW5kfjA5fExpdHRsZSBTY3J1YiBJc2xhbmR+MTB8TWlkIENheX4xMXxOb3J0aCBDYXl+MTJ8UHJpY2tseSBQZWFyIENheXN+MTN8UmFiYml0IElzbGFuZH4xNHxTYW5keSBJc2xhbmQvU2FuZCBJc2xhbmR+MTV8U2NpbGx5IENheX4xNnxTY3J1YiBJc2xhbmR+MTd8U2VhbCBJc2xhbmR+MTh8U29tYnJlcm8vSGF0IElzbGFuZH4xOXxTb3V0aCBDYXl+MjB8U291dGggV2FnZXIgSXNsYW5kfjIxfFdlc3QgQ2F5fjIyXCJdLCBbXCJBbnRhcmN0aWNhXCIsIFwiQVFcIiwgXCJBbnRhcmN0aWNhfkFRXCJdLCBbXCJBbnRpZ3VhIGFuZCBCYXJidWRhXCIsIFwiQUdcIiwgXCJBbnRpZ3VhIElzbGFuZH4wMXxCYXJidWRhIElzbGFuZH4wMnxCaXJkIElzbGFuZH4wNHxCaXNob3AgSXNsYW5kfjA1fEJsYWtlIElzbGFuZH4wNnxDcnVtcCBJc2xhbmR+MDl8RHVsY2luYSBJc2xhbmR+MTB8RXhjaGFuZ2UgSXNsYW5kfjExfEZpdmUgSXNsYW5kc34xMnxHcmVhdCBCaXJkIElzbGFuZH4xM3xHcmVlbiBJc2xhbmR+MTR8R3VpYW5hIElzbGFuZH4xNXxIYXdlcyBJc2xhbmR+MTd8SGVsbHMgR2F0ZSBJc2xhbmR+MTZ8SGVucnkgSXNsYW5kfjE4fEpvaG5zb24gSXNsYW5kfjE5fEtpZCBJc2xhbmR+MjB8TG9ic3RlciBJc2xhbmR+MjJ8TWFpZGVuIElzbGFuZH4yNHxNb29yIElzbGFuZH4yNXxOYW5ueSBJc2xhbmR+MjZ8UGVsaWNhbiBJc2xhbmR+Mjd8UHJpY2tseSBQZWFyIElzbGFuZH4yOHxSYWJiaXQgSXNsYW5kfjI5fFJlZCBIZWFkIElzbGFuZH4zMXxSZWRvbmRhIElzbGFuZH4wM3xTYW5keSBJc2xhbmR+MzJ8U21pdGggSXNsYW5kfjMzfFRoZSBTaXN0ZXJzfjM0fFZlcm5vbiBJc2xhbmR+MzV8V2lja2VkIFdpbGwgSXNsYW5kfjM2fFlvcmsgSXNsYW5kfjM3XCJdLCBbXCJBcmdlbnRpbmFcIiwgXCJBUlwiLCBcIkJ1ZW5vcyBBaXJlc35CfENhcGl0YWwgRmVkZXJhbH5DfENhdGFtYXJjYX5LfENoYWNvfkh8Q2h1YnV0flV8Q8OzcmRvYmF+WHxDb3JyaWVudGVzfld8RW50cmUgUsOtb3N+RXxGb3Jtb3NhflB8SnVqdXl+WXxMYSBQYW1wYX5MfExhIFJpb2phfkZ8TWVuZG96YX5NfE1pc2lvbmVzfk58TmV1cXXDqW5+UXxSw61vIE5lZ3JvflJ8U2FsdGF+QXxTYW4gSnVhbn5KfFNhbiBMdWlzfkR8U2FudGEgQ3J1en5afFNhbnRhIEZlflN8U2FudGlhZ28gZGVsIEVzdGVyb35HfFRpZXJyYSBkZWwgRnVlZ29+VnxUdWN1bcOhbn5UXCJdLCBbXCJBcm1lbmlhXCIsIFwiQU1cIiwgXCJBcmFnYXRzb3RufkFHfEFyYXJhdH5BUnxBcm1hdmlyfkFWfEdlZ2hhcmt1bmlrfkdSfEtvdGF5a35LVHxMb3JpfkxPfFNoaXJha35TSHxTeXVuaWt+U1V8VGF2dXNoflRWfFZheW90cyBEem9yflZEfFllcmV2YW5+RVJcIl0sIFtcIkFydWJhXCIsIFwiQVdcIiwgXCJBcnViYX5BV1wiXSwgW1wiQXVzdHJhbGlhXCIsIFwiQVVcIiwgXCJBdXN0cmFsaWFuIENhcGl0YWwgVGVycml0b3J5fkFDVHxOZXcgU291dGggV2FsZXN+TlNXfE5vcnRoZXJuIFRlcnJpdG9yeX5OVHxRdWVlbnNsYW5kflFMRHxTb3V0aCBBdXN0cmFsaWF+U0F8VGFzbWFuaWF+VEFTfFZpY3RvcmlhflZJQ3xXZXN0ZXJuIEF1c3RyYWxpYX5XQVwiXSwgW1wiQXVzdHJpYVwiLCBcIkFUXCIsIFwiQnVyZ2VubGFuZH4xfEvDpHJudGVufjJ8TmllZGVyw7ZzdGVycmVpY2h+M3xPYmVyw7ZzdGVycmVpY2h+NHxTYWx6YnVyZ341fFN0ZWllcm1hcmt+NnxUaXJvbH43fFZvcmFybGJlcmd+OHxXaWVufjlcIl0sIFtcIkF6ZXJiYWlqYW5cIiwgXCJBWlwiLCBcIkFixZ9lcm9ufkFCU3xBxJ9jYWLJmWRpfkFHQ3xBxJ9kYW1+QUdNfEHEn2RhxZ9+QUdTfEHEn3N0YWZhfkFHQXxBxJ9zdX5BR1V8QXN0YXJhfkFTVHxCYWLJmWt+QkFCfEJhbGFryZlufkJBTHxCyZlyZMmZfkJBUnxCZXlsyZlxYW5+QkVZfEJpbMmZc3V2YXJ+QklMfEPJmWJyYXnEsWx+Q0FCfEPJmWxpbGFiYWR+Q0FMfEN1bGZhfkNVTHxEYcWfa8mZc8mZbn5EQVN8RsO8enVsaX5GVVp8R8mZZMmZYsmZeX5HQUR8R29yYW5ib3l+R09SfEfDtnnDp2F5fkdPWXxHw7Z5Z8O2bH5HWUd8SGFjxLFxYWJ1bH5IQUN8xLBtacWfbGl+SU1JfMSwc21hecSxbGzEsX5JU018S8mZbGLJmWPJmXJ+S0FMfEvHnW5nx51ybGl+S0FOfEvDvHJkyZltaXJ+S1VSfExhw6fEsW5+TEFDfEzJmW5ryZlyYW5+TEFOfExlcmlrfkxFUnxNYXNhbGzEsX5NQVN8TmVmdMOnYWxhfk5FRnxPxJ91en5PR1V8T3JkdWJhZH5PUkR8UcmZYsmZbMmZflFBQnxRYXh+UUFYfFFhemF4flFBWnxRb2J1c3Rhbn5RT0J8UXViYX5RQkF8UXViYWRsaX5RQkl8UXVzYXJ+UVVTfFNhYXRsxLF+U0FUfFNhYmlyYWJhZH5TQUJ8xZ5hYnJhbn5TQk58U8mZZMmZcsmZa35TQUR8xZ5haGJ1en5TQUh8xZ7JmWtpflNBS3xTYWx5YW5+U0FMfMWeYW1heMSxflNNSXzFnsmZbWtpcn5TS1J8U2FtdXh+U01YfMWeyZlydXJ+U0FSfFNpecmZesmZbn5TSVl8xZ51xZ9hflNVU3xUyZlydMmZcn5UQVJ8VG92dXp+VE9WfFVjYXJ+VUNBfFhhw6dtYXp+WEFDfFjEsXrEsX5YSVp8WG9jYWzEsX5YQ0l8WG9jYXbJmW5kflhWRHxZYXJkxLFtbMSxfllBUnxZZXZsYXh+WUVWfFrJmW5naWxhbn5aQU58WmFxYXRhbGF+WkFRfFrJmXJkYWJ+WkFSXCJdLCBbXCJCYWhhbWFzXCIsIFwiQlNcIiwgXCJBY2tsaW5zIElzbGFuZH4wMXxCZXJyeSBJc2xhbmRzfjIyfEJpbWluaX4wMnxCbGFjayBQb2ludH4yM3xDYXQgSXNsYW5kfjAzfENlbnRyYWwgQWJhY29+MjR8Q3Jvb2tlZCBJc2xhbmQgYW5kIExvbmcgQ2F5fjI4fEVhc3QgR3JhbmQgQmFoYW1hfjI5fEV4dW1hfjA0fEZyZWVwb3J0fjA1fEZyZXNoIENyZWVrfjA2fEdvdmVybm9yJ3MgSGFyYm91cn4wN3xHcmVlbiBUdXJ0bGUgQ2F5fjA4fEhhcmJvdXIgSXNsYW5kfjA5fEhpZ2ggUm9ja34xMHxJbmFndWF+MTF8S2VtcHMgQmF5fjEyfExvbmcgSXNsYW5kfjEzfE1hcnNoIEhhcmJvdXJ+MTR8TWF5YWd1YW5hfjE1fE1vb3Jl4oCZcyBJc2xhbmR+NDB8TmV3IFByb3ZpZGVuY2V+MTZ8TmljaG9sbHN0b3duIGFuZCBCZXJyeSBJc2xhbmRzfjE3fE5vcnRoIEFiYWNvfjQyfE5vcnRoIEFuZHJvc340MXxOb3J0aCBFbGV1dGhlcmF+MzN8UmFnZ2VkIElzbGFuZH4xOHxSb2NrIFNvdW5kfjE5fFNhbiBTYWx2YWRvciBhbmQgUnVtIENheX4yMHxTYW5keSBQb2ludH4yMXxTb3V0aCBBYmFjb34zNXxTb3V0aCBBbmRyb3N+MzZ8U291dGggRWxldXRoZXJhfjM3fFdlc3QgR3JhbmQgQmFoYW1hfjM5XCJdLCBbXCJCYWhyYWluXCIsIFwiQkhcIiwgXCJBbCBKYW7Fq2LEq3lhaH4xNHxBbCBNYW7EgW1haH4xM3xBbCBNdeG4qWFycmFxfjE1fEFsIFd1c8Wjw6F+MTZ8QXNoIFNoYW3EgWzEq3lhaH4xN1wiXSwgW1wiQmFuZ2xhZGVzaFwiLCBcIkJEXCIsIFwiQmFyaXNhbH5BfENoaXR0YWdvbmd+QnxEaGFrYX5DfEtodWxuYX5EfE15bWVuc2luZ2h+TXxSYWpzaGFoaX5FfFJhbmdwdXJ+RnxTeWxoZXR+R1wiXSwgW1wiQmFyYmFkb3NcIiwgXCJCQlwiLCBcIkNocmlzdCBDaHVyY2h+MDF8U2FpbnQgQW5kcmV3fjAyfFNhaW50IEdlb3JnZX4wM3xTYWludCBKYW1lc34wNHxTYWludCBKb2hufjA1fFNhaW50IEpvc2VwaH4wNnxTYWludCBMdWN5fjA3fFNhaW50IE1pY2hhZWx+MDh8U2FpbnQgUGV0ZXJ+MDl8U2FpbnQgUGhpbGlwfjEwfFNhaW50IFRob21hc34xMVwiXSwgW1wiQmVsYXJ1c1wiLCBcIkJZXCIsIFwiQnJlc3Qgdm9ibGFzdH5CUnxHb3JvZCBNaW5za35IT3xIb21pZWwgdm9ibGFzdH5IT3xIcm9kbmEgdm9ibGFzdH5IUnxNYWhpbHlvdyB2b2JsYXN0fk1BfE1pbnNrIHZvYmxhc3R+TUl8Vml0c2Vic2sgdm9ibGFzdH5WSVwiXSwgW1wiQmVsZ2l1bVwiLCBcIkJFXCIsIFwiQnJ1eGVsbGVzLUNhcGl0YWxlfkJSVXxSw6lnaW9uIEZsYW1hbmRlflZMR3xSw6lnaW9uIFdhbGxvbmnDq35XQUxcIl0sIFtcIkJlbGl6ZVwiLCBcIkJaXCIsIFwiQmVsaXplIERpc3RyaWN0fkJafENheW8gRGlzdHJpY3R+Q1l8Q29yb3phbCBEaXN0cmljdH5DWkx8T3JhbmdlIFdhbGsgRGlzdHJpY3R+T1d8U3Rhbm4gQ3JlZWsgRGlzdHJpY3R+U0N8VG9sZWRvIERpc3RyaWN0flRPTFwiXSwgW1wiQmVuaW5cIiwgXCJCSlwiLCBcIkFsaWJvcml+QUx8QXRha29yYX5BS3xBdGxhbnRpcXVlfkFRfEJvcmdvdX5CT3xDb2xsaW5lcyBEZXBhcnRtZW50fkNPfERvbmdhfkRPfEtvdWZmb35LT3xMaXR0b3JhbCBEZXBhcnRtZW50fkxJfE1vbm8gRGVwYXJ0bWVudH5NT3xPdcOpbcOpfk9VfFBsYXRlYXV+UEx8Wm91flpPXCJdLCBbXCJCZXJtdWRhXCIsIFwiQk1cIiwgXCJDaXR5IG9mIEhhbWlsdG9ufjAzfERldm9uc2hpcmUgUGFyaXNofjAxfEhhbWlsdG9uIFBhcmlzaH4wMnxQYWdldCBQYXJpc2h+MDR8UGVtYnJva2UgUGFyaXNofjA1fFNhbmR5cyBQYXJpc2h+MDh8U21pdGgncyBQYXJpc2h+MDl8U291dGhhbXB0b24gUGFyaXNofjEwfFN0LiBHZW9yZ2UncyBQYXJpc2h+MDd8VG93biBvZiBTdC4gR2VvcmdlfjA2fFdhcndpY2sgUGFyaXNofjExXCJdLCBbXCJCaHV0YW5cIiwgXCJCVFwiLCBcIkJ1bXRoYW5nfjMzfENoaHVraGF+MTJ8RGFnYW5hfjIyfEdhc2F+R0F8SGFhfjEzfExodW50c2V+NDR8TW9uZ2FyfjQyfFBhcm9+MTF8UGVtYWdhdHNoZWx+NDN8UHVuYWtoYX4yM3xTYW1kcnVwIEpvbmdraGFyfjQ1fFNhbXRzZX4xNHxTYXJwYW5nfjMxfFRoaW1waHV+MTV8VHJhc2hpZ2FuZ340MXxUcmFzaGl5YW5ndHNlflRZfFRyb25nc2F+MzJ8VHNpcmFuZ34yMXxXYW5nZHVlIFBob2RyYW5nfjI0fFpoZW1nYW5nfjM0XCJdLCBbXCJCb2xpdmlhXCIsIFwiQk9cIiwgXCJCZW5pfkJ8Q2h1cXVpc2FjYX5IfENvY2hhYmFtYmF+Q3xMYSBQYXp+THxPcnVyb35PfFBhbmRvfk58UG90b3PDrX5QfFNhbnRhIENydXp+U3xUYXJpamF+VFwiXSwgW1wiQm9uYWlyZSwgU2ludCBFdXN0YXRpdXMgYW5kIFNhYmFcIiwgXCJCUVwiLCBcIkJvbmFpcmV+Qk98U2FiYSBJc2FuZH5TQXxTaW50IEV1c3RhdGl1c35TRVwiXSwgW1wiQm9zbmlhIGFuZCBIZXJ6ZWdvdmluYVwiLCBcIkJBXCIsIFwiQnLEjWtvIERpc3RyaWt0fkJSQ3xGZWRlcmFjaWphIEJvc25lIGkgSGVyY2Vnb3ZpbmV+QklIfFJlcHVibGlrYSBTcnBza2F+U1JQXCJdLCBbXCJCb3Rzd2FuYVwiLCBcIkJXXCIsIFwiQ2VudHJhbH5DRXxHaGFueml+R0h8S2dhbGFnYWRpfktHfEtnYXRsZW5nfktMfEt3ZW5lbmd+S1d8Tm9ydGggV2VzdH5OV3xOb3J0aC1FYXN0fk5FfFNvdXRoIEVhc3R+U0V8U291dGhlcm5+U09cIl0sIFtcIkJvdXZldCBJc2xhbmRcIiwgXCJCVlwiLCBcIkJvdXZldCBJc2xhbmR+QlZcIl0sIFtcIkJyYXppbFwiLCBcIkJSXCIsIFwiQWNyZX5BQ3xBbGFnb2FzfkFMfEFtYXDDoX5BUHxBbWF6b25hc35BTXxCYWhpYX5CQXxDZWFyw6F+Q0V8RGlzdHJpdG8gRmVkZXJhbH5ERnxFc3DDrXJpdG8gU2FudG9+RVN8R29pw6FzfkdPfE1hcmFuaMOjb35NQXxNYXRvIEdyb3Nzb35NVHxNYXRvIEdyb3NzbyBkbyBTdWx+TVN8TWluYXMgR2VyYWlzfk1HfFBhcsOhflBBfFBhcmHDrWJhflBCfFBhcmFuw6F+UFJ8UGVybmFtYnVjb35QRXxQaWF1w61+UEl8UmlvIGRlIEphbmVpcm9+Ukp8UmlvIEdyYW5kZSBkbyBOb3J0ZX5STnxSaW8gR3JhbmRlIGRvIFN1bH5SU3xSb25kw7RuaWF+Uk98Um9yYWltYX5SUnxTYW50YSBDYXRhcmluYX5TQ3xTw6NvIFBhdWxvflNQfFNlcmdpcGV+U0V8VG9jYW50aW5zflRPXCJdLCBbXCJCcml0aXNoIEluZGlhbiBPY2VhbiBUZXJyaXRvcnlcIiwgXCJJT1wiLCBcIkJyaXRpc2ggSW5kaWFuIE9jZWFuIFRlcnJpdG9yeX5JT1wiXSwgW1wiQnJ1bmVpIERhcnVzc2FsYW1cIiwgXCJCTlwiLCBcIkJlbGFpdH5CRXxCcnVuZWkgTXVhcmF+Qk18VGVtYnVyb25nflRFfFR1dG9uZ35UVVwiXSwgW1wiQnVsZ2FyaWFcIiwgXCJCR1wiLCBcIkJsYWdvZXZncmFkfjAxfEJ1cmdhc34wMnxEb2JyaWNofjA4fEdhYnJvdm9+MDd8SmFtYm9sfjI4fEtoYXNrb3ZvfjI2fEtqdXN0ZW5kaWx+MTB8S3VyZHpoYWxpfjA5fExvdmVjaH4xMXxNb250YW5hfjEyfFBhemFyZHpoaWt+MTN8UGVybmlrfjE0fFBsZXZlbn4xNXxQbG92ZGl2fjE2fFJhemdyYWR+MTd8UnVzZX4xOHxTaHVtZW5+Mjd8U2lsaXN0cmF+MTl8U2xpdmVufjIwfFNtb2xqYW5+MjF8U29maWphfjIzfFNvZmlqYS1HcmFkfjIyfFN0YXJhIFphZ29yYX4yNHxUdXJnb3Zpc2hoZX4yNXxWYXJuYX4wM3xWZWxpa28gVHVybm92b34wNHxWaWRpbn4wNXxWcmFjYX4wNlwiXSwgW1wiQnVya2luYSBGYXNvXCIsIFwiQkZcIiwgXCJCYWzDqX5CQUx8QmFtL0xha2UgQmFtfkJBTXxCYW53YSBQcm92aW5jZX5CQU58QmF6w6hnYX5CQVp8Qm91Z291cmliYX5CR1J8Qm91bGdvdSBQcm92aW5jZX5CTEd8Qm91bGtpZW1kw6l+QkxLfENvbW/DqS9Lb21vZX5DT018R2Fuem91cmdvdSBQcm92aW5jZX5HQU58R25hZ25hfkdOQXxHb3VybWEgUHJvdmluY2V+R09VfEhvdWV0fkhPVXxJb2JhfklPQnxLYWRpb2dvfktBRHxLw6luw6lkb3Vnb3V+S0VOfEtvbW9uZGphcml+S01EfEtvbXBpZW5nYX5LTVB8S29zc2kgUHJvdmluY2V+S09TfEtvdWxww6lsb2dvfktPUHxLb3VyaXRlbmdhfktPVHxLb3Vyd8Opb2dvfktPV3xMw6lyYWJhfkxFUnxMb3JvdW1+TE9SfE1vdWhvdW5+TU9VfE5hbWVudGVuZ2F+TkFNfE5hb3VyaS9OYWhvdXJpfk5BT3xOYXlhbGF+TkFZfE5vdW1iaWVsfk5PVXxPdWJyaXRlbmdhfk9VQnxPdWRhbGFufk9VRHxQYXNzb3LDqX5QQVN8UG9uaX5QT058U2FuZ3Vpw6l+U05HfFNhbm1hdGVuZ2F+U01UfFPDqW5vflNFTnxTaXNzaWxpflNJU3xTb3VtflNPTXxTb3Vyb3V+U09SfFRhcG9hflRBUHxUdWkvVHV5flRVSXxZYWdoYX5ZQUd8WWF0ZW5nYX5ZQVR8Wmlyb35aSVJ8Wm9uZG9tYX5aT058Wm91bmR3w6lvZ29+Wk9VXCJdLCBbXCJCdXJ1bmRpXCIsIFwiQklcIiwgXCJCdWJhbnphfkJCfEJ1anVtYnVyYSBNYWlyaWV+Qk18QnVqdW1idXJhIFJ1cmFsfkJMfEJ1cnVyaX5CUnxDYW5rdXpvfkNBfENpYml0b2tlfkNJfEdpdGVnYX5HSXxLYXJ1eml+S1J8S2F5YW56YX5LWXxLaXJ1bmRvfktJfE1ha2FtYmF+TUF8TXVyYW12eWF+TVV8TXV5aW5nYX5NWXxNd2Fyb35NV3xOZ296aX5OR3xSdXRhbmF+UlR8UnV5aWdpflJZXCJdLCBbXCJDYW1ib2RpYVwiLCBcIktIXCIsIFwiQmFhdCBEYW1iYW5nfjJ8QmFudGVheSBNZWFuIENoZXl+MXxLYW1wb25nIENoYWFtfjN8S2FtcG9uZyBDaGhuYW5nfjR8S2FtcG9uZyBTcHVldX41fEthbXBvbmcgVGh1bX42fEthbXBvdH43fEthbmRhYWx+OHxLYW9oIEtvbmd+OXxLcmFjaGVofjEwfEtyb25nIEthZWJ+MjN8S3JvbmcgUGFpbGlufjI0fEtyb25nIFByZWFoIFNpaGFub3VrfjE4fE1vbmRvbCBLaXJpfjExfE90ZGFyIE1lYW4gQ2hleX4yMnxQaG5vbSBQZW5ofjEyfFBvdXNhYXR+MTV8UHJlYWggVmloZWFyfjEzfFByZXkgVmVhZW5nfjE0fFJvdGFuYWggS2lyaX4xNnxTaWVtIFJlYWJ+MTd8U3R1ZW5nIFRyZW5nfjE5fFN2YWF5IFJpZW5nfjIwfFRhYWthZXZ+MjF8VGJvbmcgS2htdW1+MjVcIl0sIFtcIkNhbWVyb29uXCIsIFwiQ01cIiwgXCJBZGFtYW91YX5BRHxDZW50cmV+Q0V8RXN0fkVTfEV4dHLDqm1lLU5vcmR+RU58TGl0dG9yYWx+TFR8Tm9yZH5OT3xOb3JkLU91ZXN0fk5XfE91ZXN0fk9VfFN1ZH5TVXxTdWQtT3Vlc3R+U1dcIl0sIFtcIkNhbmFkYVwiLCBcIkNBXCIsIFwiQWxiZXJ0YX5BQnxCcml0aXNoIENvbHVtYmlhfkJDfE1hbml0b2Jhfk1CfE5ldyBCcnVuc3dpY2t+TkJ8TmV3Zm91bmRsYW5kIGFuZCBMYWJyYWRvcn5OTHxOb3J0aHdlc3QgVGVycml0b3JpZXN+TlR8Tm92YSBTY290aWF+TlN8TnVuYXZ1dH5OVXxPbnRhcmlvfk9OfFByaW5jZSBFZHdhcmQgSXNsYW5kflBFfFF1ZWJlY35RQ3xTYXNrYXRjaGV3YW5+U0t8WXVrb25+WVRcIl0sIFtcIkNhcGUgVmVyZGVcIiwgXCJDVlwiLCBcIkJvYSBWaXN0YX5CVnxCcmF2YX5CUnxDYWxoZXRhIGRlIFPDo28gTWlndWVsfkNTfE1haW9+TUF8TW9zdGVpcm9zfk1PfFBhw7psflBBfFBvcnRvIE5vdm9+UE58UHJhaWF+UFJ8UmliZWlyYSBCcmF2YX5SQnxSaWJlaXJhIEdyYW5kZX5SR3xTYWx+U0x8U2FudGEgQ2F0YXJpbmF+Q0F8U2FudGEgQ3J1en5DUnxTw6NvIERvbWluZ29zflNEfFPDo28gRmlsaXBlflNGfFPDo28gTmljb2xhdX5TTnxTw6NvIFZpY2VudGV+U1Z8VGFycmFmYWx+VEF8VGFycmFmYWwgZGUgU8OjbyBOaWNvbGF1flRTXCJdLCBbXCJDYXltYW4gSXNsYW5kc1wiLCBcIktZXCIsIFwiQ3JlZWt8RWFzdGVybnxNaWRsYW5kfFNvdXRoIFRvd258U3BvdCBCYXl8U3Rha2UgQmF5fFdlc3QgRW5kfFdlc3Rlcm5cIl0sIFtcIkNlbnRyYWwgQWZyaWNhbiBSZXB1YmxpY1wiLCBcIkNGXCIsIFwiQmFtaW5ndWktQmFuZ29yYW5+QkJ8QmFuZ3VpfkJHRnxCYXNzZS1Lb3R0b35CS3xIYXV0ZS1Lb3R0b35IS3xIYXV0LU1ib21vdX5ITXxLw6ltb35LR3xMb2JheWV+TEJ8TWFtYsOpcsOpLUthZMOpw69+SFN8TWJvbW91fk1CfE5hbmEtR3JlYml6aX4xMHxOYW5hLU1hbWLDqXLDqX5OTXxPbWJlbGxhLU0nUG9rb35NUHxPdWFrYX5VS3xPdWhhbX5BQ3xPdWhhbSBQw6luZMOpfk9QfFNhbmdoYS1NYmHDqXLDqX5TRXxWYWthZ2F+VktcIl0sIFtcIkNoYWRcIiwgXCJURFwiLCBcIkJhaHIgZWwgR2hhemFsfkJHfEJhdGhhfkJBfEJvcmtvdX5CT3xDaGFyaS1CYWd1aXJtaX5DQnxFbm5lZGktRXN0fkVFfEVubmVkaS1PdWVzdH5FT3xHdcOpcmF+R1J8SGFkamVyIExhbWlzfkhMfEthbmVtfktBfExhY35MQ3xMb2dvbmUgT2NjaWRlbnRhbH5MT3xMb2dvbmUgT3JpZW50YWx+TFJ8TW9uZG91bH5NQXxNYXlvLUvDqWJiaS1Fc3R+TUV8TW95ZW4tQ2hhcml+TUN8T3VhZGRhaX5PRHxTYWxhbWF0flNBfFNpbGF+U0l8VGFuZGppbMOpflRBfFRpYmVzdGl+VEl8VmlsbGUgZGUgTmRqYW1lbmF+TkR8V2FkaSBGaXJhfldGXCJdLCBbXCJDaGlsZVwiLCBcIkNMXCIsIFwiQWlzw6luIGRlbCBHZW5lcmFsIENhcmxvcyBJYsOhw7FleiBkZWwgQ2FtcG9+QUl8QW50b2ZhZ2FzdGF+QU58QXJhdWNhbsOtYX5BUnxBcmljYSB5IFBhcmluYWNvdGF+QVB8QXRhY2FtYX5BVHxCw61vLULDrW9+Qkl8Q29xdWltYm9+Q098TGliZXJ0YWRvciBHZW5lcmFsIEJlcm5hcmRvIE8nSGlnZ2luc35MSXxMb3MgTGFnb3N+TEx8TG9zIFLDrW9zfkxSfE1hZ2FsbGFuZXMgeSBBbnRhcnRpY2EgQ2hpbGVuYX5NQXxNYXJnYS1NYXJnYX58TWF1bGV+TUx8UmVnacOzbiBNZXRyb3BvbGl0YW5hIGRlIFNhbnRpYWdvflJNfFRhcmFwYWPDoX5UQXxWYWxwYXJhw61zb35WU1wiXSwgW1wiQ2hpbmFcIiwgXCJDTlwiLCBcIkFuaHVpfjM0fEJlaWppbmd+MTF8Q2hvbmdxaW5nfjUwfEZ1amlhbn4zNXxHYW5zdX42MnxHdWFuZ2Rvbmd+NDR8R3Vhbmd4aX40NXxHdWl6aG91fjUyfEhhaW5hbn40NnxIZWJlaX4xM3xIZWlsb25namlhbmd+MjN8SGVuYW5+NDF8SG9uZyBLb25nfjkxfEh1YmVpfjQyfEh1bmFufjQzfElubmVyIE1vbmdvbGlhfjE1fEppYW5nc3V+MzJ8Smlhbmd4aX4zNnxKaWxpbn4yMnxMaWFvbmluZ34yMXxNYWNhdX45MnxOaW5neGlhfjY0fFFpbmdoYWl+NjN8U2hhYW54aX42MXxTaGFuZG9uZ34zN3xTaGFuZ2hhaX4zMXxTaGFueGl+MTR8U2ljaHVhbn41MXxUaWFuamlufjEyfFRpYmV0fjU0fFhpbmppYW5nfjY1fFl1bm5hbn41M3xaaGVqaWFuZ34zM1wiXSwgW1wiQ2hyaXN0bWFzIElzbGFuZFwiLCBcIkNYXCIsIFwiQ2hyaXN0bWFzIElzbGFuZH5DWFwiXSwgW1wiQ29jb3MgKEtlZWxpbmcpIElzbGFuZHNcIiwgXCJDQ1wiLCBcIkRpcmVjdGlvbiBJc2xhbmR+REl8SG9tZSBJc2xhbmR+SE18SG9yc2J1cmdoIElzbGFuZH5IUnxOb3J0aCBLZWVsaW5nIElzbGFuZH5OS3xTb3V0aCBJc2xhbmR+U0l8V2VzdCBJc2xhbmR+V0lcIl0sIFtcIkNvbG9tYmlhXCIsIFwiQ09cIiwgXCJBbWF6b25hc35BTUF8QW50aW9xdWlhfkFOVHxBcmF1Y2F+QVJBfEFyY2hpcGnDqWxhZ28gZGUgU2FuIEFuZHLDqXN+U0FQfEF0bMOhbnRpY29+QVRMfEJvZ290w6EgRC5DLn5EQ3xCb2zDrXZhcn5CT0x8Qm95YWPDoX5CT1l8Q2FsZGFzfkNBTHxDYXF1ZXTDoX5DQVF8Q2FzYW5hcmV+Q0FTfENhdWNhfkNBVXxDZXNhcn5DRVN8Q2hvY8OzfkNIT3xDw7NyZG9iYX5DT1J8Q3VuZGluYW1hcmNhfkNVTnxHdWFpbsOtYX5HVUF8R3VhdmlhcmV+R1VWfEh1aWxhfkhVSXxMYSBHdWFqaXJhfkxBR3xNYWdkYWxlbmF+TUFHfE1ldGF+TUVUfE5hcmnDsW9+TkFSfE5vcnRlIGRlIFNhbnRhbmRlcn5OU0F8UHV0dW1heW9+UFVUfFF1aW5kw61vflFVSXxSaXNhcmFsZGF+UklTfFNhbnRhbmRlcn5TQU58U3VjcmV+U1VDfFRvbGltYX5UT0x8VmFsbGUgZGVsIENhdWNhflZBQ3xWYXVww6lzflZBVXxWaWNoYWRhflZJRFwiXSwgW1wiQ29tb3Jvc1wiLCBcIktNXCIsIFwiQW5kamF6w65kamF+R3xBbmRqb3XDom5+QXxNb8O7aMOubMOufk1cIl0sIFtcIkNvbmdvLCBSZXB1YmxpYyBvZiB0aGUgKEJyYXp6YXZpbGxlKVwiLCBcIkNHXCIsIFwiQm91ZW56YX4xMXxCcmF6emF2aWxsZX5CWlZ8Q3V2ZXR0ZX44fEN1dmV0dGUtT3Vlc3R+MTV8S291aWxvdX41fEzDqWtvdW1vdX4yfExpa291YWxhfjd8Tmlhcml+OXxQbGF0ZWF1eH4xNHxQb2ludGUtTm9pcmV+MTZ8UG9vbH4xMnxTYW5naGF+MTNcIl0sIFtcIkNvbmdvLCB0aGUgRGVtb2NyYXRpYyBSZXB1YmxpYyBvZiB0aGUgKEtpbnNoYXNhKVwiLCBcIkNEXCIsIFwiQmFuZHVuZHV+Qk58QmFzLUNvbmdvfkJDfMOJcXVhdGV1cn5FUXxLYXNhw68tT2NjaWRlbnRhbH5LRXxLYXNhw68tT3JpZW50YWx+S1d8S2F0YW5nYX5LQXxLaW5zaGFzYX5LTnxNYW5pZW1hfk1BfE5vcmQtS2l2dX5OS3xPcmllbnRhbGV+T1J8U3VkLUtpdnV+U0tcIl0sIFtcIkNvb2sgSXNsYW5kc1wiLCBcIkNLXCIsIFwiQWl0dXRha2l8QXRpdXxBdmFydWF8TWFuZ2FpYXxNYW5paGlraXxNYSd1a2V8TWl0aWFyb3xOYXNzYXV8UGFsbWVyc3RvbnxQZW5yaHlufFB1a2FwdWthfFJha2FoYW5nYVwiXSwgW1wiQ29zdGEgUmljYVwiLCBcIkNSXCIsIFwiQWxhanVlbGF+MnxDYXJ0YWdvfjN8R3VhbmFjYXN0ZX41fEhlcmVkaWF+NHxMaW3Ds25+N3xQdW50YXJlbmFzfjZ8U2FuIEpvc8OpfjFcIl0sIFtcIkPDtHRlIGQnSXZvaXJlLCBSZXB1YmxpYyBvZlwiLCBcIkNJXCIsIFwiQWduw6lieX4xNnxCYWZpbmd+MTd8QmFzLVNhc3NhbmRyYX4wOXxEZW5ndcOpbMOpfjEwfERpeC1IdWl0IE1vbnRhZ25lc34wNnxGcm9tYWdlcn4xOHxIYXV0LVNhc3NhbmRyYX4wMnxMYWNzfjA3fExhZ3VuZXN+MDF8TWFyYWhvdcOpfjEyfE1veWVuLUNhdmFsbHl+MTl8TW95ZW4tQ29tb8OpfjA1fE4nemktQ29tb8OpfjExfFNhdmFuZXN+MDN8U3VkLUJhbmRhbWF+MTV8U3VkLUNvbW/DqX4xM3xWYWxsw6llIGR1IEJhbmRhbWF+MDR8V29yb2RvdWdvdX4xNHxaYW56YW5+MDhcIl0sIFtcIkNyb2F0aWFcIiwgXCJIUlwiLCBcIkJqZWxvdmFyc2tvLUJpbG9nb3Jza2Egxb11cGFuaWphfjA3fEJyb2Rza28tUG9zYXZza2Egxb11cGFuaWphfjEyfER1YnJvdmHEjWtvLU5lcmV0dmFuc2thIMW9dXBhbmlqYX4xOXxHcmFkIFphZ3JlYn4yMXxJc3RhcnNrYSDFvXVwYW5pamF+MTh8S2FybG92YcSNa2Egxb11cGFuaWphfjA0fEtvcHJpdm5pxI1rby1Lcml6ZXZhxI1rYSDFvXVwYW5pamF+MDZ8S3JhcGluc2tvLVphZ29yc2thIMW9dXBhbmlqYX4wMnxMacSNa28tU2VuanNrYSDFvXVwYW5pamF+MDl8TWXEkWltdXJza2Egxb11cGFuaWphfjIwfE9zamXEjWtvLUJhcmFuanNrYSDFvXVwYW5pamF+MTR8UG/FvmXFoWtvLVNsYXZvbnNrYSDFvXVwYW5pamF+MTF8UHJpbW9yc2tvLUdvcmFuc2thIMW9dXBhbmlqYX4wOHxTaXNhxI1rby1Nb3NsYXZhxI1rYSDFvXVwYW5pamF+MDN8U3BsaXRza28tRGFsbWF0aW5za2Egxb11cGFuaWphfjE3fFNpYmVuc2tvLUtuaW5za2Egxb11cGFuaWphfjE1fFZhcmHFvmRpbnNrYSDFvXVwYW5pamF+MDV8Vmlyb3ZpdGnEjWtvLVBvZHJhdnNrYSDFvXVwYW5pamF+MTB8VnVrb3ZhcnNrby1TcmlqZW1za2Egxb11cGFuaWphfjE2fFphZGFyc2thIMW9dXBhbmlqYX4xM3xaYWdyZWJhY2thIFp1cGFuaWphfjAxXCJdLCBbXCJDdWJhXCIsIFwiQ1VcIiwgXCJBcnRlbWlzYX4xNXxDYW1hZ8O8ZXl+MDl8Q2llZ28gZGUgw4F2aWxhfjA4fENpZW5mdWVnb3N+MDZ8R3Jhbm1hfjEyfEd1YW50w6FuYW1vfjE0fEhvbGd1w61ufjExfElzbGEgZGUgbGEgSnV2ZW50dWR+OTl8TGEgSGFiYW5hfjAzfExhcyBUdW5hc34xMHxNYXRhbnphc34wNHxNYXlhYmVxdWV+MTZ8UGluYXIgZGVsIFLDrW9+MDF8U2FuY3RpIFNww61yaXR1c34wN3xTYW50aWFnbyBkZSBDdWJhfjEzfFZpbGxhIENsYXJhfjA1XCJdLCBbXCJDdXJhw6dhb1wiLCBcIkNXXCIsIFwiQ3VyYcOnYW9+Q1dcIl0sIFtcIkN5cHJ1c1wiLCBcIkNZXCIsIFwiQW1tb2Nob3N0b3N+MDR8S2VyeW5laWF+MDV8TGFybmFrYX4wM3xMZWZrb3NpYX4wMXxMZW1lc29zfjAyfFBhZm9zfjA1XCJdLCBbXCJDemVjaCBSZXB1YmxpY1wiLCBcIkNaXCIsIFwiSGxhdm7DrSBtxJtzdG8gUHJhaGF+UFJ8Smlob8SNZXNrw70ga3Jhan5KQ3xKaWhvbW9yYXZza8O9IGtyYWp+Sk18S2FybG92YXJza8O9IGtyYWp+S0F8S3LDoWxvdsOpaHJhZGVja8O9IGtyYWp+S1J8TGliZXJlY2vDvSBrcmFqfkxJfE1vcmF2c2tvc2xlenNrw70ga3Jhan5NT3xPbG9tb3Vja8O9IGtyYWp+T0x8UGFyZHViaWNrw70ga3Jhan5QQXxQbHplxYhza8O9IGtyYWp+UEx8U3TFmWVkb8SNZXNrw70ga3Jhan5TVHzDmnN0ZWNrw70ga3Jhan5VU3xWeXNvxI1pbmF+Vll8WmzDrW5za8O9IGtyYWp+WkxcIl0sIFtcIkRlbm1hcmtcIiwgXCJES1wiLCBcIkhvdmVkc3RhZGVufjg0fEt1amFsbGVxfkdMLUtVfE1pZHRqeWxsYW5kfjgyfE5vcmRlcsO4ZXJuZX5GTy0wMXxOb3JkanlsbGFuZH44MXzDmHN0ZXLDuH5GTy0wNnxRYWFzdWl0c3VwfkdMLVFBfFFlcXFhdGF+R0wtUUV8U2FuZMO4fkZPLTAyfFNlcm1lcnNvb3F+R0wtU018U2rDpmxsYW5kfjg1fFN0csO4bcO4fkZPLTAzfFN1ZGVyw7h+Rk8tMDR8U3lkZGFubWFya344M3xWw6Vnw7h+Rk8tMDVcIl0sIFtcIkRqaWJvdXRpXCIsIFwiREpcIiwgXCJBbGkgU2FiaWVofkFTfEFydGF+QVJ8RGlraGlsfkRJfE9ib2Nrfk9CfFRhZGpvdXJhaH5UQVwiXSwgW1wiRG9taW5pY2FcIiwgXCJETVwiLCBcIlNhaW50IEFuZHJldyBQYXJpc2h+MDJ8U2FpbnQgRGF2aWQgUGFyaXNofjAzfFNhaW50IEdlb3JnZSBQYXJpc2h+MDR8U2FpbnQgSm9obiBQYXJpc2h+MDV8U2FpbnQgSm9zZXBoIFBhcmlzaH4wNnxTYWludCBMdWtlIFBhcmlzaH4wN3xTYWludCBNYXJrIFBhcmlzaH4wOHxTYWludCBQYXRyaWNrIFBhcmlzaH4wOXxTYWludCBQYXVsIFBhcmlzaH4xMHxTYWludCBQZXRlciBQYXJpc2h+MTFcIl0sIFtcIkRvbWluaWNhbiBSZXB1YmxpY1wiLCBcIkRPXCIsIFwiQ2liYW8gQ2VudHJhbH4wMnxEZWwgVmFsbGV+Mzd8RGlzdHJpdG8gTmFjaW9uYWx+MDF8RW5yaXF1aWxsb34zOHxOb3JjZW50cmFsfjA0fE5vcmRlc3RlfjM0fE5vcm9lc3RlfjM0fE5vcnRlfjM1fFZhbGRlc2lhfjQyXCJdLCBbXCJFY3VhZG9yXCIsIFwiRUNcIiwgXCJBenVheX5BfEJvbMOtdmFyfkJ8Q2HDsWFyfkZ8Q2FyY2hpfkN8Q2hpbWJvcmF6b35IfENvdG9wYXhpflh8RWwgT3Jvfk98RXNtZXJhbGRhc35FfEdhbMOhcGFnb3N+V3xHdWF5YXN+R3xJbWJhYnVyYX5JfExvamF+THxMb3MgUsOtb3N+UnxNYW5hYsOtfk18TW9yb25hLVNhbnRpYWdvflN8TmFwb35OfE9yZWxsYW5hfkR8UGFzdGF6YX5ZfFBpY2hpbmNoYX5QfFNhbnRhIEVsZW5hflNFfFNhbnRvIERvbWluZ28gZGUgbG9zIFRzw6FjaGlsYXN+U0R8U3VjdW1iw61vc35VfFR1bmd1cmFodWF+VHxaYW1vcmEtQ2hpbmNoaXBlflpcIl0sIFtcIkVneXB0XCIsIFwiRUdcIiwgXCJBbGV4YW5kcmlhfkFMWHxBc3dhbn5BU058QXN5b3V0fkFTVHxCYW5pIFN1ZWlmfkJOU3xCZWhlaXJhfkJIfENhaXJvfkN8RGFxYWhsaWF+REt8RHVtaWF0fkRUfEVsIEJhaHIgRWwgQWhtYXJ+QkF8RWwgSXNtYWlsaWF+SVN8RWwgU3Vlen5TVVp8RWwgV2FkaSBFbCBHZWRlZWR+V0FEfEZheW91bX5GWU18R2hhcmJpYX5HSHxHaXphflNVWnxIZWx3YW5+SFV8S2FmciBFbCBTaGVpa2h+S0ZTfEx1eG9yfkxYfE1hdHJvdWh+TVR8TWVuaWF+TU58TWVub2ZpYX5NTkZ8Tm9ydGggU2luYWl+U0lOfFBvcnQgU2FpZH5QVFN8UWFsdWJpYX5LQnxRZW5hfktOfFNoYXJxaWF+U0hSfFNpeHRoIG9mIE9jdG9iZXJ+U1V8U29oYWd+U0hHfFNvdXRoIFNpbmFpfkpTXCJdLCBbXCJFbCBTYWx2YWRvclwiLCBcIlNWXCIsIFwiQWh1YWNoYXDDoW5+QUh8Q2FiYcOxYXN+Q0F8Q3VzY2F0bMOhbn5DVXxDaGFsYXRlbmFuZ29+Q0h8TGEgTGliZXJ0YWR+TEl8TGEgUGF6flBBfExhIFVuacOzbn5VTnxNb3JhesOhbn5NT3xTYW4gTWlndWVsflNNfFNhbiBTYWx2YWRvcn5TU3xTYW50YSBBbmF+U0F8U2FuIFZpY2VudGV+U1Z8U29uc29uYXRlflNPfFVzdWx1dMOhbn5VU1wiXSwgW1wiRXF1YXRvcmlhbCBHdWluZWFcIiwgXCJHUVwiLCBcIkFubm9iw7NufkFOfEJpb2tvIE5vcnRlfkJOfEJpb2tvIFN1cn5CU3xDZW50cm8gU3VyfkNTfEtpw6ktTnRlbX5LTnxMaXRvcmFsfkxJfFdlbGUtTnphc35XTlwiXSwgW1wiRXJpdHJlYVwiLCBcIkVSXCIsIFwiQW5zZWJhfkFOfERlYnVifkRVfERlYnViLUtlaWgtQmFocml+REt8R2FzaC1CYXJrYX5HQnxNYWVrZWx+TUF8U2VtaWVuLUtlaWgtQmFocml+U0tcIl0sIFtcIkVzdG9uaWFcIiwgXCJFRVwiLCBcIkhhcmp1bWFhIChUYWxsaW5uKX4zN3xIaWl1bWFhIChLYXJkbGEpfjM5fElkYS1WaXJ1bWFhIChKb2h2aSl+NDR8SsOkcnZhbWFhIChQYWlkZSl+NDF8SsO1Z2V2YW1hYSAoSm9nZXZhKX40OXxMw6TDpG5lbWFhfjU3fEzDpMOkbmUtVmlydW1hYSAoUmFrdmVyZSl+NTl8UMOkcm51bWFhIChQYXJudSl+Njd8UMO1bHZhbWFhIChQb2x2YSl+NjV8UmFwbGFtYWEgKFJhcGxhKX43MHxTYWFyZW1hYSAoS3Vlc3NhYXJlKX43NHxUYXJ0dW1hYSAoVGFydHUpfjc4fFZhbGdhbWFhIChWYWxnYSl+ODJ8VmlsamFuZGltYWEgKFZpbGphbmRpKX44NHxWw7VydW1hYSAoVm9ydSl+ODZcIl0sIFtcIkV0aGlvcGlhXCIsIFwiRVRcIiwgXCJBZGRpcyBBYmFiYX5BQXxBZmFyfkFGfEFtaGFyYX5BTXxCZW5zaGFuZ3VsLUd1bWF6fkJFfERpcmUgRGF3YX5ERHxHYW1iZWxhfkdBfEhhcmFyaX5IQXxPcm9taWF+T1J8U29tYWxpflNPfFNvdXRoZXJuIE5hdGlvbnMgTmF0aW9uYWxpdGllcyBhbmQgUGVvcGxlJ3MgUmVnaW9uflNOfFRpZ3JheX5USVwiXSwgW1wiRmFsa2xhbmQgSXNsYW5kcyAoSXNsYXMgTWFsdmluYXMpXCIsIFwiRktcIiwgXCJGYWxrbGFuZCBJc2xhbmRzIChJc2xhcyBNYWx2aW5hcylcIl0sIFtcIkZhcm9lIElzbGFuZHNcIiwgXCJGT1wiLCBcIkJvcmRveXxFeXN0dXJveXxNeWtpbmVzfFNhbmRveXxTa3V2b3l8U3RyZXltb3l8U3VkdXJveXxUdm9yb3lyaXxWYWdhclwiXSwgW1wiRmlqaVwiLCBcIkZKXCIsIFwiQmF+MDF8QnVhfjAxfENha2F1ZHJvdmV+MDN8S2FkYXZ1fjA0fExhdX4wNXxMb21haXZpdGl+MDZ8TWFjdWF0YX4wN3xOYWRyb2dhIGFuZCBOYXZvc2F+MDh8TmFpdGFzaXJpfjA5fE5hbW9zaX4xMHxSYX4wMTF8UmV3YX4xMnxSb3R1bWF+UnxTZXJ1YX4xMnxUYWlsZXZ1fjE0XCJdLCBbXCJGaW5sYW5kXCIsIFwiRklcIiwgXCJBaHZlbmFubWFhbiBsw6TDpG5pfkFMfEV0ZWzDpC1TdW9tZW4gbMOkw6RuaX5FU3xJdMOkLVN1b21lbiBsw6TDpG5pfklTfEzDpG5zaS1TdW9tZW4gbMOkw6RuaX5MU3xMYXBpbiBsw6TDpG5pfkxMfE91bHVuIGzDpMOkbml+T0xcIl0sIFtcIkZyYW5jZVwiLCBcIkZSXCIsIFwiQXV2ZXJnbmUtUmjDtG5lLUFscGVzfkFSQXxCb3VyZ29nbmUtRnJhbmNoZS1Db210w6l+QkZDfEJyZXRhZ25lfkJSRXxDZW50cmUtVmFsIGRlIExvaXJlfkNWTHxDb3JzZX5DT1J8R3JhbmQgRXN0fkdFU3xIYXV0cy1kZS1GcmFuY2V+SERGfMOObGUtZGUtRnJhbmNlfklERnxOb3JtYW5kaWV+Tk9SfE5vdXZlbGxlLUFxdWl0YWluZX5OQVF8T2NjaXRhbmllfk9DQ3xQYXlzIGRlIGxhIExvaXJlflBETHxQcm92ZW5jZS1BbHBlcy1Db3RlIGQnQXp1cn5QQUN8Q2xpcHBlcnRvbn5DUHxHdWFkZWxvdXBlfkdQfEd1eWFuZX5HRnxNYXJ0aW5pcXVlfk1RfE1heW90dGV+WVR8Tm92ZWxsZS1DYWzDqWRvbmllfk5DfFBvbHluw6lzaWV+UEZ8U2FpbnQtUGllcnJlLWV0LU1pcXVlbG9uflBNfFNhaW50IEJhcnRow6lsZW15fkJMfFNhaW50IE1hcnRpbn5NRnxSw6l1bmlvbn5SRXxUZXJyZXMgQXVzdHJhbGVzIEZyYW7Dp2Fpc2VzflRGfFdhbGxpcy1ldC1GdXR1bmF+V0ZcIl0sIFtcIkZyZW5jaCBHdWlhbmFcIiwgXCJHRlwiLCBcIkZyZW5jaCBHdWlhbmFcIl0sIFtcIkZyZW5jaCBQb2x5bmVzaWFcIiwgXCJQRlwiLCBcIkFyY2hpcGVsIGRlcyBNYXJxdWlzZXN8QXJjaGlwZWwgZGVzIFR1YW1vdHV8QXJjaGlwZWwgZGVzIFR1YnVhaXxJbGVzIGR1IFZlbnR8SWxlcyBTb3VzLWxlLVZlbnRcIl0sIFtcIkZyZW5jaCBTb3V0aGVybiBhbmQgQW50YXJjdGljIExhbmRzXCIsIFwiVEZcIiwgXCJBZGVsaWUgTGFuZHxJbGUgQ3JvemV0fElsZXMgS2VyZ3VlbGVufElsZXMgU2FpbnQtUGF1bCBldCBBbXN0ZXJkYW1cIl0sIFtcIkdhYm9uXCIsIFwiR0FcIiwgXCJFc3R1YWlyZX4xfEhhdXQtT2dvb3XDqX4yfE1veWVuLU9nb291w6l+M3xOZ291bmnDqX40fE55YW5nYX41fE9nb291w6ktSXZpbmRvfjZ8T2dvb3XDqS1Mb2xvfjd8T2dvb3XDqS1NYXJpdGltZX44fFdvbGV1LU50ZW1+OVwiXSwgW1wiR2FtYmlhLCBUaGVcIiwgXCJHTVwiLCBcIkJhbmp1bH5CfENlbnRyYWwgUml2ZXJ+TXxMb3dlciBSaXZlcn5MfE5vcnRoIEJhbmt+TnxVcHBlciBSaXZlcn5VfFdlc3Rlcm5+V1wiXSwgW1wiR2VvcmdpYVwiLCBcIkdFXCIsIFwiQWJraGF6aWEgKFNva2h1bWkpfkFCfEFqYXJpYSAoQmF0J3VtaSl+QUp8R3VyaWF+R1V8SW1lcmV0aX5JTXxLJ2FraGV0aX5LQXxLdmVtbyBLYXJ0bGl+S0t8TXRzaGtoZXRhLU10aWFuZXRpfk1NfFJhY2gnYS1MZXhoa3VtaS1LdmVtb1N2YW5ldGl+Ukx8U2FtZWdyZWxvLVplbW8gU3ZhbmV0aX5TWnxTYW10c2toZS1KYXZha2hldGl+U0p8U2hpZGEgS2FydGxpflNLfFRiaWxpc2l+VEJcIl0sIFtcIkdlcm1hbnlcIiwgXCJERVwiLCBcIkJhZGVuLVfDvHJ0dGVtYmVyZ35CV3xCYXllcm5+Qll8QmVybGlufkJFfEJyYW5kZW5idXJnfkJCfEJyZW1lbn5IQnxIYW1idXJnfkhIfEhlc3Nlbn5IRXxNZWNrbGVuYnVyZy1Wb3Jwb21tZXJufk1WfE5pZWRlcnNhY2hzZW5+Tkl8Tm9yZHJoZWluLVdlc3RmYWxlbn5OV3xSaGVpbmxhbmQtUGZhbHp+UlB8U2FhcmxhbmR+U0x8U2FjaHNlbn5TTnxTYWNoc2VuLUFuaGFsdH5TVHxTY2hsZXN3aWctSG9sc3RlaW5+U0h8VGjDvHJpbmdlbn5USFwiXSwgW1wiR2hhbmFcIiwgXCJHSFwiLCBcIkFzaGFudGl+QUh8QnJvbmctQWhhZm9+QkF8Q2VudHJhbH5DUHxFYXN0ZXJufkVQfEdyZWF0ZXIgQWNjcmF+QUF8Tm9ydGhlcm5+TlB8VXBwZXIgRWFzdH5VRXxVcHBlciBXZXN0flVXfFZvbHRhflRWfFdlc3Rlcm5+V1BcIl0sIFtcIkdpYnJhbHRhclwiLCBcIkdJXCIsIFwiR2licmFsdGFyXCJdLCBbXCJHcmVlY2VcIiwgXCJHUlwiLCBcIkFuYXRvbGlrw60gTWFrZWRvbsOtYSBrYWkgVGhyw6FraX5BfEF0dGlr4bivfkl8RHl0aWvDrSBFbGzDoWRhfkd8RHl0aWvDrSBNYWtlZG9uw61hfkN8SW9uw61hIE7DrXNpYX5GfEtlbnRyaWvDrSBNYWtlZG9uw61hfkJ8S3LDrXTDrX5NfE5vdMOtbyBBaWdhw61vfkx8UGVsb3Bvbm7DrXNvc35KfFN0ZXJlw6EgRWxsw6FkYX5IfFRoZXNzYWzDrWF+RXxWb3Jlw61vIEFpZ2HDrW9+S3zDjXBlaXJvc35EfMOBZ2lvbiDDk3Jvc342OVwiXSwgW1wiR3JlZW5sYW5kXCIsIFwiR0xcIiwgXCJLb21tdW5lIEt1amFsbGVxfktVfEtvbW11bmVxYXJmaWsgU2VybWVyc29vcX5TTXxRYWFzdWl0c3VwIEtvbW11bmlhflFBfFFlcXFhdGEgS29tbXVuaWF+UUVcIl0sIFtcIkdyZW5hZGFcIiwgXCJHRFwiLCBcIlNhaW50IEFuZHJld34wMXxTYWludCBEYXZpZH4wMnxTYWludCBHZW9yZ2V+MDN8U2FpbnQgSm9obn4wNHxTYWludCBNYXJrfjA1fFNhaW50IFBhdHJpY2t+MDZ8U291dGhlcm4gR3JlbmFkaW5lIElzbGFuZHN+MTBcIl0sIFtcIkd1YWRlbG91cGVcIiwgXCJHUFwiLCBcIkd1YWRlbG91cGVcIl0sIFtcIkd1YW1cIiwgXCJHVVwiLCBcIkd1YW1cIl0sIFtcIkd1YXRlbWFsYVwiLCBcIkdUXCIsIFwiQWx0YSBWZXJhcGF6fkFWfEJhamEgVmVyYXBhen5CVnxDaGltYWx0ZW5hbmdvfkNNfENoaXF1aW11bGF+Q1F8RWwgUHJvZ3Jlc29+UFJ8RXNjdWludGxhfkVTfEd1YXRlbWFsYX5HVXxIdWVodWV0ZW5hbmdvfkhVfEl6YWJhbH5JWnxKYWxhcGF+SkF8SnV0aWFwYX5KVXxQZXTDqW5+UEV8UXVldHphbHRlbmFuZ29+UVp8UXVpY2jDqX5RQ3xSZXRhbGh1bGV1flJlfFNhY2F0ZXDDqXF1ZXp+U0F8U2FuIE1hcmNvc35TTXxTYW50YSBSb3NhflNSfFNvbG9sw6F+U098U3VjaGl0ZXDDqXF1ZXp+U1V8VG90b25pY2Fww6FuflRPfFphY2FwYX5aQVwiXSwgW1wiR3Vlcm5zZXlcIiwgXCJHR1wiLCBcIkNhc3RlbHxGb3Jlc3R8U3QuIEFuZHJld3xTdC4gTWFydGlufFN0LiBQZXRlciBQb3J0fFN0LiBQaWVycmUgZHUgQm9pc3xTdC4gU2FtcHNvbnxTdC4gU2F2aW91cnxUb3J0ZXZhbHxWYWxlXCJdLCBbXCJHdWluZWFcIiwgXCJHTlwiLCBcIkJva8OpfkJ8Q29uYWtyeX5DfEZhcmFuYWh+RnxLYW5rYW5+S3xLaW5kaWF+RHxMYWLDqX5MfE1hbW91fk18TnrDqXLDqWtvcsOpfk5cIl0sIFtcIkd1aW5lYS1CaXNzYXVcIiwgXCJHV1wiLCBcIkJhZmF0w6F+QkF8QmlvbWJvfkJNfEJpc3NhdX5CU3xCb2xhbWEtQmlqYWdvc35CTHxDYWNoZXV+Q0F8R2Fiw7p+R0F8T2lvfk9JfFF1aW5hcmF+UVV8VG9tYmFsaX5UT1wiXSwgW1wiR3V5YW5hXCIsIFwiR1lcIiwgXCJCYXJpbWEtV2Fpbml+QkF8Q3V5dW5pLU1hemFydW5pfkNVfERlbWVyYXJhLU1haGFpY2F+REV8RWFzdCBCZXJiaWNlLUNvcmVudHluZX5FQnxFc3NlcXVpYm8gSXNsYW5kcy1XZXN0IERlbWVyYXJhfkVTfE1haGFpY2EtQmVyYmljZX5NQXxQb21lcm9vbi1TdXBlbmFhbX5QTXxQb3Rhcm8tU2lwYXJ1bml+UFR8VXBwZXIgRGVtZXJhcmEtQmVyYmljZX5VRHxVcHBlciBUYWt1dHUtVXBwZXIgRXNzZXF1aWJvflVUXCJdLCBbXCJIYWl0aVwiLCBcIkhUXCIsIFwiQXJ0aWJvbml0ZX5BUnxDZW50cmV+Q0V8R3JhbmQnQW5zZX5HQXxOaXBwZXN+Tkl8Tm9yZH5ORHxOb3JkLUVzdH5ORXxOb3JkLU91ZXN0fk5PfE91ZXN0fk9VfFN1ZH5TRHxTdWQtRXN0flNFXCJdLCBbXCJIZWFyZCBJc2xhbmQgYW5kIE1jRG9uYWxkIElzbGFuZHNcIiwgXCJITVwiLCBcIkhlYXJkIElzbGFuZCBhbmQgTWNEb25hbGQgSXNsYW5kc1wiXSwgW1wiSG9seSBTZWUgKFZhdGljYW4gQ2l0eSlcIiwgXCJWQVwiLCBcIkhvbHkgU2VlIChWYXRpY2FuIENpdHkpfjAxXCJdLCBbXCJIb25kdXJhc1wiLCBcIkhOXCIsIFwiQXRsw6FudGlkYX5BVHxDaG9sdXRlY2F+Q0h8Q29sw7NufkNMfENvbWF5YWd1YX5DTXxDb3DDoW5+Q1B8Q29ydMOpc35DUnxFbCBQYXJhw61zb35FUHxGcmFuY2lzY28gTW9yYXphbn5GTXxHcmFjaWFzIGEgRGlvc35HRHxJbnRpYnVjw6F+SU58SXNsYXMgZGUgbGEgQmFow61hfklCfExhIFBhen5MUHxMZW1waXJhfkxFfE9jb3RlcGVxdWV+T0N8T2xhbmNob35PTHxTYW50YSBCw6FyYmFyYX5TQnxWYWxsZX5WQXxZb3JvfllPXCJdLCBbXCJIb25nIEtvbmdcIiwgXCJIS1wiLCBcIkhvbmcgS29uZ1wiXSwgW1wiSHVuZ2FyeVwiLCBcIkhVXCIsIFwiQsOhY3MtS2lza3VufkJLfEJhcmFueWF+QkF8QsOpa8Opc35CRXxCw6lrw6lzY3NhYmF+QkN8Qm9yc29kLUFiYXVqLVplbXBsZW5+Qlp8QnVkYXBlc3R+QlV8Q3Nvbmdyw6FkfkNTfERlYnJlY2VufkRFfER1bmHDump2w6Fyb3N+RFV8RWdlcn5FR3zDiXJkfkVSfEZlasOpcn5GRXxHecWRcn5HWXxHecWRci1Nb3Nvbi1Tb3Byb25+R1N8SGFqZMO6LUJpaGFyfkhCfEhldmVzfkhFfEjDs2RtZXrFkXbDoXPDoXJoZWx5fkhWfErDoXN6LU5hZ3lrdW4tU3pvbG5va35OfEthcG9zdsOhcn5LVnxLZWNza2Vtw6l0fktNfEtvbcOhcm9tLUVzenRlcmdvbX5LRXxNaXNrb2xjfk1JfE5hZ3lrYW5penNhfk5LfE7Ds2dyw6Fkfk5PfE55w61yZWd5aMOhemF+Tll8UMOpY3N+UFN8UGVzdH5QRXxTYWxnw7N0YXJqw6FuflNUfFNvbW9neX5TT3xTb3Byb25+U058U3phYm9sY3Mtw6EtQmVyZWd+U1p8U3plZ2VkflNEfFN6w6lrZXNmZWjDqXJ2w6FyflNGfFN6ZWtzesOhcmR+U1N8U3pvbG5va35TS3xTem9tYmF0aGVseX5TSHxUYXRhYsOhbnlhflRCfFRvbG5hflRPfFZhc35WQXxWZXN6cHLDqW1+VkV8VmVzenByw6ltIChDaXR5KX5WTXxaYWxhflpBfFphbGFlZ2Vyc3plZ35aRVwiXSwgW1wiSWNlbGFuZFwiLCBcIklTXCIsIFwiQXVzdHVybGFuZH43fEjDtmZ1w7Bib3JnYXJzdsOmw7BpIHV0YW4gUmV5a2phdsOta3VyfjF8Tm9yw7B1cmxhbmQgZXlzdHJhfjZ8Tm9yw7B1cmxhbmQgdmVzdHJhfjV8U3XDsHVybGFuZH44fFN1w7B1cm5lc34yfFZlc3RmaXLDsGlyfjR8VmVzdHVybGFuZH4zXCJdLCBbXCJJbmRpYVwiLCBcIklOXCIsIFwiQW5kYW1hbiBhbmQgTmljb2JhciBJc2xhbmRzfkFOfEFuZGhyYSBQcmFkZXNofkFQfEFydW5hY2hhbCBQcmFkZXNofkFSfEFzc2FtfkFTfEJpaGFyfkJSfENoYW5kaWdhcmh+Q0h8Q2hoYXR0aXNnYXJofkNUfERhZHJhIGFuZCBOYWdhciBIYXZlbGl+RE58RGFtYW4gYW5kIERpdX5ERHxEZWxoaX5ETHxHb2F+R0F8R3VqYXJhdH5HSnxIYXJ5YW5hfkhSfEhpbWFjaGFsIFByYWRlc2h+SFB8SmFtbXUgYW5kIEthc2htaXJ+Skt8SmhhcmtoYW5kfkpIfEthcm5hdGFrYX5LQXxLZXJhbGF+S0x8TGFrc2hhZHdlZXB+TER8TWFkaHlhIFByYWRlc2h+TVB8TWFoYXJhc2h0cmF+TUh8TWFuaXB1cn5NTnxNZWdoYWxheWF+TUx8TWl6b3JhbX5NWnxOYWdhbGFuZH5OTHxPZGlzaGF+T1J8UHVkdWNoZXJyeX5QWXxQdW5qYWJ+UEJ8UmFqYXN0aGFuflJKfFNpa2tpbX5XS3xUYW1pbCBOYWR1flROfFRlbGFuZ2FuYX5UR3xUcmlwdXJhflRSfFV0dGFyYWtoYW5kflVUfFV0dGFyIFByYWRlc2h+VVB8V2VzdCBCZW5nYWx+V0JcIl0sIFtcIkluZG9uZXNpYVwiLCBcIklEXCIsIFwiQWNlaH5BQ3xCYWxpfkJBfEJhbmdrYSBCZWxpdHVuZ35CQnxCYW50ZW5+QlR8QmVuZ2t1bHV+QkV8R29yb250YWxvfkdPfEpha2FydGEgUmF5YX5KS3xKYW1iaX5KQXxKYXdhIEJhcmF0fkpCfEphd2EgVGVuZ2FofkpUfEphd2EgVGltdXJ+Skl8S2FsaW1hbnRhbiBCYXJhdH5LQnxLYWxpbWFudGFuIFNlbGF0YW5+S1N8S2FsaW1hbnRhbiBUZW5nYWh+S1R8S2FsaW1hbnRhbiBUaW11cn5LSXxLYWxpbWFudGFuIFV0YXJhfktVfEtlcHVsYXVhbiBSaWF1fktSfExhbXB1bmd+TEF8TWFsdWt1fk1BfE1hbHVrdSBVdGFyYX5NVXxOdXNhIFRlbmdnYXJhIEJhcmF0fk5CfE51c2EgVGVuZ2dhcmEgVGltdXJ+TlR8UGFwdWF+UEF8UGFwdWEgQmFyYXR+UEJ8UmlhdX5SSXxTdWxhd2VzaSBTZWxhdGFuflNSfFN1bGF3ZXNpIFRlbmdhaH5TVHxTdWxhd2VzaSBUZW5nZ2FyYX5TR3xTdWxhd2VzaSBVdGFyYX5TQXxTdW1hdGVyYSBCYXJhdH5TQnxTdW1hdGVyYSBTZWxhdGFuflNTfFN1bWF0ZXJhIFV0YXJhflNVfFlvZ3lha2FydGF+WU9cIl0sIFtcIklyYW4sIElzbGFtaWMgUmVwdWJsaWMgb2ZcIiwgXCJJUlwiLCBcIkFsYm9yen4zMnxBcmRhYsSrbH4wM3zEgHrMhGFyYsSBeWrEgW4tZSBHaGFyYsSrfjAyfMSAesyEYXJixIF5asSBbi1lIFNoYXJxxKt+MDF8QsWrc2hlaHJ+MDZ8Q2hhaMSBciBNYeG4qcSBbCB2YSBCYWtodMSrxIFyxKt+MDh8RcWfZmFoxIFufjA0fEbEgXJzfjE0fEfEq2zEgW5+MTl8R29sZXN0xIFufjI3fEhhbWFkxIFufjI0fEhvcm1vemfEgW5+MjN8xKpsxIFtfjA1fEtlcm3EgW5+MTV8S2VybcSBbnNoxIFofjE3fEtob3LEgXPEgW4tZSBKb27Fq2LEq34yOXxLaG9yxIFzxIFuLWUgUmHhupVhdsSrfjMwfEtob3LEgXPEgW4tZSBTaG9txIFsxKt+NjF8S2jFq3plc3TEgW5+MTB8S29oZ8SrbMWreWVoIHZhIEJvd3llciBB4bipbWFkfjE4fEtvcmRlc3TEgW5+MTZ8TG9yZXN0xIFufjIwfE1hcmtheml+MjJ8TcSBemFuZGFyxIFufjIxfFFhenbEq25+Mjh8UW9tfjI2fFNlbW7EgW5+MTJ8U8Src3TEgW4gdmEgQmFsxatjaGVzdMSBbn4xM3xUZWhyxIFufjA3fFlhemR+MjV8WmFuasSBbn4xMVwiXSwgW1wiSXJhcVwiLCBcIklRXCIsIFwiQWwgQW5ixIFyfkFOfEFsIEJhxZ9yYWh+QkF8QWwgTXV0aGFubsOhfk1VfEFsIFHEgWRpc8SreWFoflFBfEFuIE5hamFmfk5BfEFyYsSrbH5BUnxBcyBTdWxheW3EgW7Eq3lhaH5TVXxCxIFiaWx+QkJ8QmFnaGTEgWR+Qkd8RG9odWt+REF8RGjEqyBRxIFyfkRRfERpecSBbMOhfkRJfEthcmJhbMSBJ35LQXxLaXJrdWt+S0l8TWF5c8SBbn5NQXxOxKtuYXfDoX5OSXzFnmFsxIHhuKkgYWQgRMSrbn5TRHxXxIFzacWjfldBXCJdLCBbXCJJcmVsYW5kXCIsIFwiSUVcIiwgXCJDYXJsb3d+Q1d8Q2F2YW5+Q058Q2xhcmV+Q0V8Q29ya35DT3xEb25lZ2FsfkRMfER1Ymxpbn5EfEdhbHdheX5HfEtlcnJ5fktZfEtpbGRhcmV+S0V8S2lsa2Vubnl+S0t8TGFvaXN+TFN8TGVpdHJpbX5MTXxMaW1lcmlja35MS3xMb25nZm9yZH5MRHxMb3V0aH5MSHxNYXlvfk1PfE1lYXRofk1IfE1vbmFnaGFufk1OfE9mZmFseX5PWXxSb3Njb21tb25+Uk58U2xpZ29+U098VGlwcGVyYXJ5flRBfFdhdGVyZm9yZH5XRHxXZXN0bWVhdGh+V0h8V2V4Zm9yZH5XWHxXaWNrbG93fldXXCJdLCBbXCJJc2xlIG9mIE1hblwiLCBcIklNXCIsIFwiSXNsZSBvZiBNYW5cIl0sIFtcIklzcmFlbFwiLCBcIklMXCIsIFwiSGFEYXJvbX5EfEhhTWVya2F6fk18SGFUc2Fmb25+WnxIzLFlZmF+SEF8VGVsLUF2aXZ+VEF8WWVydXNoYWxheWltfkpNXCJdLCBbXCJJdGFseVwiLCBcIklUXCIsIFwiQWJydXp6b342NXxCYXNpbGljYXRhfjc3fENhbGFicmlhfjc4fENhbXBhbmlhfjcyfEVtaWxpYS1Sb21hZ25hfjQ1fEZyaXVsaS1WZW5lemlhIEdpdWxpYX4zNnxMYXppb342MnxMaWd1cmlhfjQyfExvbWJhcmRpYX4yNXxNYXJjaGV+NTd8TW9saXNlfjY3fFBpZW1vbnRlfjIxfFB1Z2xpYX43NXxTYXJkZWduYX44OHxTaWNpbGlhfjgyfFRvc2NhbmF+NTJ8VHJlbnRpbm8tQWx0byBBZGlnZX4zMnxVbWJyaWF+NTV8VmFsbGUgZCdBb3N0YX4yM3xWZW5ldG9+MzRcIl0sIFtcIkphbWFpY2FcIiwgXCJKTVwiLCBcIkNsYXJlbmRvbn4xM3xIYW5vdmVyfjA5fEtpbmdzdG9ufjAxfE1hbmNoZXN0ZXJ+MTJ8UG9ydGxhbmR+MDR8U2FpbnQgQW5kcmV3fjAyfFNhaW50IEFubn4wNnxTYWludCBDYXRoZXJpbmV+MTR8U2FpbnQgRWxpemFiZXRofjExfFNhaW50IEphbWVzfjA4fFNhaW50IE1hcnl+MDV8U2FpbnQgVGhvbWFzfjAzfFRyZWxhd255fjA3fFdlc3Rtb3JlbGFuZH4xMFwiXSwgW1wiSmFwYW5cIiwgXCJKUFwiLCBcIkFpY2hpfjIzfEFraXRhfjA1fEFvbW9yaX4wMnxDaGliYX4xMnxFaGltZX4zOHxGdWt1aX4xOHxGdWt1b2thfjQwfEZ1a3VzaGltYX4wN3xHaWZ1fjIxfEd1bm1hfjEwfEhpcm9zaGltYX4zNHxIb2trYWlkb34wMXxIeW9nb34yOHxJYmFyYWtpfjA4fElzaGlrYXdhfjE3fEl3YXRlfjAzfEthZ2F3YX4zN3xLYWdvc2hpbWF+NDZ8S2FuYWdhd2F+MTR8S29jaGl+Mzl8S3VtYW1vdG9+NDN8S3lvdG9+MjZ8TWllfjI0fE1peWFnaX4wNHxNaXlhemFraX40NXxOYWdhbm9+MjB8TmFnYXNha2l+NDJ8TmFyYX4yOXxOaWlnYXRhfjE1fE9pdGF+NDR8T2theWFtYX4zM3xPa2luYXdhfjQ3fE9zYWthfjI3fFNhZ2F+NDF8U2FpdGFtYX4xMXxTaGlnYX4yNXxTaGltYW5lfjMyfFNoaXp1b2thfjIyfFRvY2hpZ2l+MDl8VG9rdXNoaW1hfjM2fFRva3lvfjEzfFRvdHRvcml+MzF8VG95YW1hfjE2fFdha2F5YW1hfjMwfFlhbWFnYXRhfjA2fFlhbWFndWNoaX4zNXxZYW1hbmFzaGl+MTlcIl0sIFtcIkplcnNleVwiLCBcIkpFXCIsIFwiSmVyc2V5XCJdLCBbXCJKb3JkYW5cIiwgXCJKT1wiLCBcIuKAmEFqbMWrbn5BSnxBbCAnQXFhYmFofkFRfEFsIEJhbHHEgeKAmX5CQXxBbCBLYXJha35LQXxBbCBNYWZyYXF+TUF8QWwg4oCYQcyFxZ9pbWFofkFNfEHFoyDFomFmxKtsYWh+QVR8QXogWmFyccSB4oCZfkFafElyYmlkfklSfEphcmFzaH5KQXxNYeKAmMSBbn5NTnxNxIFkYWLEgX5NRFwiXSwgW1wiS2F6YWtoc3RhblwiLCBcIktaXCIsIFwiQWxtYXR5fkFMQXxBcW1vbGF+QUtNfEFxdG9iZX5BS1R8QXN0YW5hfkFTVHxBdHlyYXV+QVRZfEJhdHlzIFFhemFxc3Rhbn5aQVB8QmF5cW9uZ3lyfE1hbmdnaHlzdGF1fk1BTnxPbmd0dXN0aWsgUWF6YXFzdGFufllVWnxQYXZsb2Rhcn5QQVZ8UWFyYWdoYW5keX5LQVJ8UW9zdGFuYXl+S1VTfFF5enlsb3JkYX5LWll8U2h5Z2h5cyBRYXphcXN0YW5+Vk9TfFNvbHR1c3RpayBRYXphcXN0YW5+U0VWfFpoYW1ieWx+WkhBXCJdLCBbXCJLZW55YVwiLCBcIktFXCIsIFwiQmFyaW5nb34wMXxCb21ldH4wMnxCdW5nb21hfjAzfEJ1c2lhfjA0fEVsZXlvL01hcmFrd2V0fjA1fEVtYnV+MDZ8R2FyaXNzYX4wN3xIb21hIEJheX4wOHxJc2lvbG9+MDl8S2FqaWFkb34xMHxLYWthbWVnYX4xMXxLZXJpY2hvfjEyfEtpYW1idX4xM3xLaWxpZml+MTR8S2lyaW55YWdhfjE1fEtpc2lpfjE2fEtpc3VtdX4xN3xLaXR1aX4xOHxLd2FsZX4xOXxMYWlraXBpYX4yMHxMYW11fjIxfE1hY2hha29zfjIyfE1ha3Vlbml+MjN8TWFuZGVyYX4yNHxNYXJzYWJpdH4yNXxNZXJ1fjI2fE1pZ29yaX4yN3xNb21iYXNhfjI4fE11cmFuZydhfjI5fE5haXJvYmkgQ2l0eX4zMHxOYWt1cnV+MzF8TmFuZGl+MzJ8TmFyb2t+MzN8TnlhbWlyYX4zNHxOeWFuZGFydWF+MzV8Tnllcml+MzZ8U2FtYnVydX4zN3xTaWF5YX4zOHxUYWl0YS9UYXZldGF+Mzl8VGFuYSBSaXZlcn40MHxUaGFyYWthLU5pdGhpfjQxfFRyYW5zIE56b2lhfjQyfFR1cmthbmF+NDN8VWFzaW4gR2lzaHV+NDR8VmloaWdhfjQ1fFdhamlyfjQ2fFdlc3QgUG9rb3R+NDdcIl0sIFtcIktpcmliYXRpXCIsIFwiS0lcIiwgXCJBYmFpYW5nfEFiZW1hbWF8QXJhbnVrYXxBcm9yYWV8QmFuYWJhfEJlcnV8QnV0YXJpdGFyaXxDZW50cmFsIEdpbGJlcnRzfEdpbGJlcnQgSXNsYW5kc35HfEthbnRvbnxLaXJpdGltYXRpfEt1cmlhfExpbmUgSXNsYW5kc35MfE1haWFuYXxNYWtpbnxNYXJha2VpfE5pa3VuYXV8Tm9ub3V0aXxOb3J0aGVybiBHaWxiZXJ0c3xPbm90b2F8UGhvZW5peCBJc2xhbmRzflB8U291dGhlcm4gR2lsYmVydHN8VGFiaXRldWVhfFRhYnVhZXJhbnxUYW1hbmF8VGFyYXdhfFRlcmFpbmFcIl0sIFtcIktvcmVhLCBEZW1vY3JhdGljIFBlb3BsZSdzIFJlcHVibGljIG9mXCIsIFwiS1BcIiwgXCJDaGFnYW5nLWRvIChDaGFnYW5nIFByb3ZpbmNlKX4wNHxIYW1neW9uZy1idWt0byAoTm9ydGggSGFtZ3lvbmcgUHJvdmluY2UpfjA5fEhhbWd5b25nLW5hbWRvIChTb3V0aCBIYW1neW9uZyBQcm92aW5jZSl+MDh8SHdhbmdoYWUtYnVrdG8gKE5vcnRoIEh3YW5naGFlIFByb3ZpbmNlKX4wNnxId2FuZ2hhZS1uYW1kbyAoU291dGggSHdhbmdoYWUgUHJvdmluY2UpfjA1fEthbmd3b24tZG8gKEthbmd3b24gUHJvdmluY2UpfjA3fE5hc8WPbiAoTmFqaW4tU8WPbmJvbmcpfjEzfFAneW9uZ2FuLWJ1a3RvIChOb3J0aCBQJ3lvbmdhbiBQcm92aW5jZSl+MDN8UCd5b25nYW4tbmFtZG8gKFNvdXRoIFAneW9uZ2FuIFByb3ZpbmNlKX4wMnxQJ3lvbmd5YW5nLXNpIChQJ3lvbmd5YW5nIENpdHkpfjAxfFlhbmdnYW5nLWRvIChZYW5nZ2FuZyBQcm92aW5jZSl+MTBcIl0sIFtcIktvcmVhLCBSZXB1YmxpYyBvZlwiLCBcIktSXCIsIFwiQ2gndW5nY2gnb25nYnVrLWRvfjQzfENoJ3VuZ2NoJ29uZ25hbS1kb340NHxDaGVqdS1kb340OXxDaG9sbGFidWstZG9+NDV8Q2hvbGxhbmFtLWRvfjQ2fEluY2gnb24tS3dhbmd5b2toaX4yOHxLYW5nLXdvbi1kb340MnxLd2FuZ2p1LUt3YW5neW9rc2hpfjI4fEt5b25nZ2ktZG9+NDF8S3lvbmdzYW5nYnVrLWRvfjQ3fEt5b25nc2FuZ25hbS1kb340OHxQdXNhbi1Ld2FuZ3lva3NoaX4yNnxTZW91bC1UJ3VrcHlvbHNoaX4xMXxTZWpvbmd+NTB8VGFlZ3UtS3dhbmd5b2tzaGl+Mjd8VGFlam9uLUt3YW5neW9rc2hpfjMwfFVsc2FuLUt3YW5neW9rc2hpfjMxXCJdLCBbXCJLdXdhaXRcIiwgXCJLV1wiLCBcIkFsIEHhuKltYWRpfkFIfEFsIEZhcnfEgW7Eq3lhaH5GQXxBbCBKYWhyxIHigJl+SkF8QWwg4oCYxIDFn2ltYWh+S1V84bioYXdhbGzEq35IQXxNdWLEgXJhayBhbCBLYWJpcn5NVVwiXSwgW1wiS3lyZ3l6c3RhblwiLCBcIktHXCIsIFwiQmF0a2VuIE9ibGFzdHl+QnxCaXNoa2VrIFNoYWFyeX5HQnxDaHV5IE9ibGFzdHkgKEJpc2hrZWspfkN8SmFsYWwtQWJhZCBPYmxhc3R5fkp8TmFyeW4gT2JsYXN0eX5OfE9zaCBPYmxhc3R5fk98VGFsYXMgT2JsYXN0eX5UfFlzeWstS29sIE9ibGFzdHkgKEthcmFrb2wpfllcIl0sIFtcIkxhb3NcIiwgXCJMQVwiLCBcIkF0dGFwdX5BVHxCb2vDqG9+Qkt8Qm9saWtoYW14YWl+Qkx8Q2hhbXBhc2FrfkNIfEhvdWFwaGFufkhPfEtoYW1tb3Vhbn5LSHxMb3VhbmcgTmFtdGhhfkxNfExvdWFuZ3BoYWJhbmd+TFB8T3Vkw7RteGFpfk9VfFBow7RuZ3NhbGl+UEh8U2FsYXZhbn5TTHxTYXZhbm5ha2jDqXR+U1Z8VmllbnRpYW5lflZJfFhhaWduYWJvdWxpflhBfFjDqWtvbmd+WEV8WGFpc29tYm91bn5YU3xYaWFuZ2tob3Vhbmd+WElcIl0sIFtcIkxhdHZpYVwiLCBcIkxWXCIsIFwiQWdsb25hfjAwMXxBaXprcmF1a2xlfjAwMnxBaXpwdXRlfjAwM3xBa27Eq3N0ZX4wMDR8QWxvamF+MDA1fEFsc3VuZ2F+MDZ8QWzFq2tzbmV+MDA3fEFtYXRhfjAwOHxBcGV+MDA5fEF1Y2V+MDEwfMSAZGHFvml+MDExfEJhYsSrdGV+MDEyfEJhbGRvbmV+MDEzfEJhbHRpbmF2YX4wMTR8QmFsdml+MDE1fEJhdXNrYX4wMTZ8QmV2ZXLEq25hfjAxN3xCcm9jxJNuaX4wMTh8QnVydG5pZWtpfjAxOXxDYXJuaWthdmF+MDIwfENlc3ZhaW5lfjAyMXxDxJNzaXN+MDIyfENpYmxhfjAyM3xEYWdkYX4wMjR8RGF1Z2F2cGlsc34wMjV8RGF1Z2F2cGlscyAoQ2l0eSl+REdWfERvYmVsZX4wMjZ8RHVuZGFnYX4wMjd8RHVyYmV+MDI4fEVuZ3VyZX4wMjl8xJJyZ8S8aX4wMzB8R2Fya2FsbmV+MDMxfEdyb2JpxYZhfjAzMnxHdWxiZW5lfjAzM3xJZWNhdmF+MDM0fElrxaHEt2lsZX4wMzV8SWzFq2tzdGV+MDM2fEluxI11a2FsbnN+MDM3fEphdW5qZWxnYXZhfjAzOHxKYXVucGllYmFsZ2F+MDM5fEphdW5waWxzfjA0MHxKZWxnYXZhfjA0MXxKZWxnYXZhIChDaXR5KX5KRUx8SsSTa2FicGlsc34wNDJ8SsSTa2FicGlscyAoQ2l0eSl+SktCfErFq3JtYWxhIChDaXR5KX5KVVJ8S2FuZGF2YX4wNDN8S8SBcnNhdmF+MDQ0fEtvY8STbml+MDQ1fEtva25lc2V+MDQ2fEtyxIFzbGF2YX4wNDd8S3JpbXVsZGF+MDQ4fEtydXN0cGlsc34wNDl8S3VsZMSrZ2F+MDUwfMS2ZWd1bXN+MDUxfMS2ZWthdmF+MDUyfExpZWx2xIFyZGV+MDUzfExpZXDEgWphfkxQWHxMaW1iYcW+aX4wNTR8TMSrZ2F0bmV+MDU1fEzEq3bEgW5pfjA1NnxMdWLEgW5hfjA1N3xMdWR6YX4wNTh8TWFkb25hfjA1OXxNYXpzYWxhY2F+MDYwfE3EgWxwaWxzfjA2MXxNxIFydXBlfjA2MnxNxJNyc3JhZ3N+MDYzfE5hdWvFocSTbml+MDY0fE5lcmV0YX4wNjV8TsSrY2F+MDY2fE9ncmV+MDY3fE9sYWluZX4wNjh8T3pvbG5pZWtpfjA2OXxQxIFyZ2F1amF+MDcwfFDEgXZpbG9zdGF+MDcxfFDEvGF2acWGYXN+MDcyfFByZWnEvGl+MDczfFByaWVrdWxlfjA3NHxQcmlla3XEvGl+MDc1fFJhdW5hfjA3NnxSxJN6ZWtuZX4wNzd8UsSTemVrbmUgKENpdHkpflJFWnxSaWViacWGaX4wNzh8UsSrZ2F+UklYfFJvamF+MDc5fFJvcGHFvml+MDgwfFJ1Y2F2YX4wODF8UnVnxIFqaX4wODJ8UnVuZMSBbGV+MDgzfFLFq2ppZW5hfjA4NHxTYWxhfjA4NXxTYWxhY2dyxKt2YX4wODZ8U2FsYXNwaWxzfjA4N3xTYWxkdXN+MDg4fFNhdWxrcmFzdGl+MDg5fFPEk2phfjA5MHxTaWd1bGRhfjA5MXxTa3LEq3Zlcml+MDkyfFNrcnVuZGF+MDkzfFNtaWx0ZW5lfjA5NHxTdG9wacWGaX4wOTV8U3RyZW7EjWl+MDk2fFRhbHNpfjA5N3xUxJNydmV0ZX4wOTh8VHVrdW1zfjA5OXxWYWnFhm9kZX4xMDB8VmFsa2F+MTAxfFZhbG1pZXJhflZNUnxWYXJha8S8xIFuaX4xMDJ8VsSBcmthdmF+MTAzfFZlY3BpZWJhbGdhfjEwNHxWZWN1bW5pZWtpfjEwNXxWZW50c3BpbHN+MTA2fFZlbnRzcGlscyAoQ2l0eSl+VkVOfFZpZXPEq3RlfjEwN3xWacS8YWthfjEwOHxWacS8xIFuaX4xMDl8WmlsdXBlfjExMFwiXSwgW1wiTGViYW5vblwiLCBcIkxCXCIsIFwiQWFra8Oicn5BS3xCYWFsYmVsay1IZXJtZWx+Qkh8QsOpcWFhfkJJfEJleXJvdXRofkJBfExpYmFuLU5vcmR+QVN8TGliYW4tU3VkfkpBfE1vbnQtTGliYW5+Skx8TmFiYXTDrnnDqX5OQVwiXSwgW1wiTGVzb3Rob1wiLCBcIkxTXCIsIFwiQmVyZWF+RHxCdXRoYS1CdXRoZX5CfExlcmliZX5DfE1hZmV0ZW5nfkV8TWFzZXJ1fkF8TW9oYWxlcyBIb2VrfkZ8TW9raG90bG9uZ35KfFFhY2hhJ3MgTmVrfkh8UXV0aGluZ35HfFRoYWJhLVRzZWthfktcIl0sIFtcIkxpYmVyaWFcIiwgXCJMUlwiLCBcIkJvbWl+Qk18Qm9uZ35CR3xHYmFycG9sdX5HUHxHcmFuZCBCYXNzYX5HQnxHcmFuZCBDYXBlIE1vdW50fkNNfEdyYW5kIEdlZGVofkdHfEdyYW5kIEtydX5HS3xMb2ZhfkxPfE1hcmdpYml+TUd8TWFyeWxhbmR+TVl8TW9udHNlcnJhZG9+TU98TmltYmF+Tkl8Uml2ZXIgQ2Vzc35SSXxSaXZlciBHZWVlflJHfFNpbm9lflNJXCJdLCBbXCJMaWJ5YVwiLCBcIkxZXCIsIFwiQWwgQnXFo27EgW5+QlV8QWwgSmFiYWwgYWwgQWto4biRYXJ+SkF8QWwgSmFiYWwgYWwgR2hhcmLEq35KR3xBbCBKYWbEgXJhaH5KQXxBbCBKdWZyYWh+SlV8QWwgS3VmcmFofkZLfEFsIE1hcmp+TUp8QWwgTWFycXVhYn5NQnxBbCBXxIHhuKnEgXR+V0F8QW4gTnVxYcWjIGFsIEtoYW1zfk5RfEF6IFrEgXdpeWFoflpBfEJhbmdoxIF6xKt+QkF8RGFybmFofkRSfEdoxIF0fkdIfE1pxZ9yxIF0YWh+TUl8TXVyenVxfk1RfE7EgWzFq3R+Tkx8U2FiaMSBflNCfFN1cnR+U1J8xaJhcsSBYnVsdXN+VEJ8WWFmcmFufldEfFfEgWTEqyBhc2ggU2jEgcWjacq+fldTXCJdLCBbXCJMaWVjaHRlbnN0ZWluXCIsIFwiTElcIiwgXCJCYWx6ZXJzfjAxfEVzY2hlbn4wMnxHYW1wcmlufjAzfE1hdXJlbn4wNHxQbGFua2VufjA1fFJ1Z2dlbGx+MDZ8U2NoYWFufjA3fFNjaGVsbGVuYmVyZ34wOHxUcmllc2VufjA5fFRyaWVzZW5iZXJnfjEwfFZhZHV6fjExXCJdLCBbXCJMaXRodWFuaWFcIiwgXCJMVFwiLCBcIkFseXRhdXN+QUx8S2F1bm9+S1V8S2xhaXDEl2Rvc35LTHxNYXJpamFtcG9sxJdzfk1SfFBhbmV2xJfFvmlvflBOfMWgaWF1bGnFs35TQXxUYXVyYWfEl3N+VEF8VGVsxaFpxbN+VEV8VXRlbm9zflVUfFZpbG5pYXVzflZMXCJdLCBbXCJMdXhlbWJvdXJnXCIsIFwiTFVcIiwgXCJDYXBlbGxlbn5DQXxDbGV2YXV4fkNMfERpZWtpcmNofkRJfEVjaHRlcm5hY2h+RUN8RXNjaC1zdXItQWx6ZXR0ZX5FU3xHcmV2ZW5tYWNoZXJ+R1J8THV4ZW1ib3VyZ35MVXxNZXJzY2h+TUV8UmVkYW5nZX5SRHxSZW1pY2h+Uk18VmlhbmRlbn5WRHxXaWx0en5XSVwiXSwgW1wiTWFjYW9cIiwgXCJNT1wiLCBcIk1hY2FvXCJdLCBbXCJNYWNlZG9uaWEsIFJlcHVibGljIG9mXCIsIFwiTUtcIiwgXCJBcmHEjWlub3ZvfjAyfEJlcm92b34wM3xCaXRvbGF+MDR8Qm9nZGFuY2l+MDV8Qm9nb3ZpbmplfjA2fEJvc2lsb3ZvfjA3fEJydmVuaWNhfjA4fENlbnRhciDFvXVwYX43OHzEjGHFoWthfjA4fMSMZcWhaW5vdm8tT2JsZcWhZXZvfjgxfMSMdcSNZXIgU2FuZGV2b344MnxEZWJhcn4yMXxEZWJhcmNhfjIyfERlbMSNZXZvfjIzfERlbWlyIEhpc2FyfjI1fERlbWlyIEthcGlqYX4yNHxEb3Jhbn4yNnxEb2xuZW5pfjI3fEdldmdlbGlqYX4xOHxHb3N0aXZhcn4xOXxHcmFkc2tvfjIwfElsaW5kZW5+MzR8SmVndW5vdmNlfjM1fEthcmJpbmNpfjM3fEthdmFkYXJjaX4zNnxLacSNZXZvfjQwfEtvxI1hbml+NDJ8S29uxI1lfjQxfEtyYXRvdm9+NDN8S3JpdmEgUGFsYW5rYX40NHxLcml2b2dhxaF0YW5pfjQ1fEtydcWhZXZvfjQ2fEt1bWFub3ZvfjQ3fExpcGtvdm9+NDh8TG96b3ZvfjQ5fE1ha2Vkb25za2EgS2FtZW5pY2F+NTF8TWFrZWRvbnNraSBCcm9kfjUyfE1hdnJvdm8gaSBSb3N0dcWhYX41MHxNb2dpbGF+NTN8TmVnb3Rpbm9+NTR8Tm92YWNpfjU1fE5vdm8gU2Vsb341NnxPaHJpZH41OHxQZWjEjWV2b342MHxQZXRyb3ZlY341OXxQbGFzbmljYX42MXxQcmlsZXB+NjJ8UHJvYmnFoXRpcH42M3xSYWRvdmnFoX58UmFua292Y2V+NjV8UmVzZW5+NjZ8Um9zb21hbn42N3xTa29wamV+ODV8U29wacWhdGV+NzB8U3Rhcm8gTmFnb3JpxI1hbmV+NzF8U3RydWdhfjcyfFN0cnVtaWNhfjczfFN0dWRlbmnEjWFuaX43NHxTdmV0aSBOaWtvbGV+Njl8xaB0aXB+ODN8VGVhcmNlfjc1fFRldG92b343NnxWYWxhbmRvdm9+MTB8VmFzaWxldm9+MTF8VmVsZXN+MTN8VmV2xI1hbml+MTJ8VmluaWNhfjE0fFZyYXDEjWnFoXRlfjE2fFplbGVuaWtvdm9+MzJ8WnJub3ZjaX4zM3zFvWVsaW5vfjMwXCJdLCBbXCJNYWRhZ2FzY2FyXCIsIFwiTUdcIiwgXCJBbnRhbmFuYXJpdm9+VHxBbnRzaXJhbmFuYX5EfEZpYW5hcmFudHNvYX5GfE1haGFqYW5nYX5NfFRvYW1hc2luYX5BfFRvbGlhcmF+VVwiXSwgW1wiTWFsYXdpXCIsIFwiTVdcIiwgXCJCYWxha2F+QkF8QmxhbnR5cmV+Qkx8Q2hpa3dhd2F+Q0t8Q2hpcmFkenVsdX5DUnxDaGl0aXBhfkNUfERlZHphfkRFfERvd2F+RE98S2Fyb25nYX5LUnxLYXN1bmd1fktTfExpa29tYX5MS3xMaWxvbmd3ZX5MSXxNYWNoaW5nYX5NSHxNYW5nb2NoaX5NR3xNY2hpbmppfk1DfE11bGFuamV+TVV8TXdhbnphfk1XfE16aW1iYX5NWnxOa2hhdGEgQmF5fk5FfE5raG90YWtvdGF+TkJ8TnNhbmplfk5TfE50Y2hldX5OVXxOdGNoaXNpfk5JfFBoYWxvbWJlflBIfFJ1bXBoaX5SVXxTYWxpbWF+U0F8VGh5b2xvflRIfFpvbWJhflpPXCJdLCBbXCJNYWxheXNpYVwiLCBcIk1ZXCIsIFwiSm9ob3J+MDF8S2VkYWh+MDJ8S2VsYW50YW5+MDN8TWVsYWthfjA0fE5lZ2VyaSBTZW1iaWxhbn4wNXxQYWhhbmd+MDZ8UGVyYWt+MDh8UGVybGlzfjA5fFB1bGF1IFBpbmFuZ34wN3xTYWJhaH4xMnxTYXJhd2FrfjEzfFNlbGFuZ29yfjEwfFRlcmVuZ2dhbnV+MTF8V2lsYXlhaCBQZXJzZWt1dHVhbiAoS3VhbGEgTHVtcHVyKX4xNHxXaWxheWFoIFBlcnNla3V0dWFuIChMYWJ1YW4pfjE1fFdpbGF5YWggUGVyc2VrdXR1YW4gKFB1dHJhamF5YSl+MTZcIl0sIFtcIk1hbGRpdmVzXCIsIFwiTVZcIiwgXCJBbGlmdSBBbGlmdX4wMnxBbGlmdSBEaGFhbHV+MDB8QmFhfjIwfERoYWFsdX4xN3xGYWFmdX4xNHxHYWFmdSBBbGlmdX4yN3xHYWFmdSBEaGFhbHV+Mjh8R25hdml5YW5pfjI5fEhhYSBBbGlmdX4wN3xIYWEgRGhhYWx1fjIzfEthYWZ1fjI5fExhYW11fjA1fExoYXZpeWFuaX4wM3xNYWzDqX5NTEV8TWVlbXV+MTJ8Tm9vbnV+MjV8UmFhfjEzfFNlZW51fjAxfFNoYXZpeWFuaX4yNHxUaGFhfjA4fFZhYXZ1fjA0XCJdLCBbXCJNYWxpXCIsIFwiTUxcIiwgXCJCYW1ha29+QktPfEdhb343fEtheWVzfjF8S2lkYWx+OHxLb3VsaWtvcm9+MnxNb3B0aX41fFNlZ291fjR8U2lrYXNzb34zfFRvbWJvdWN0b3V+NlwiXSwgW1wiTWFsdGFcIiwgXCJNVFwiLCBcIkF0dGFyZH4wMXxCYWx6YW5+MDJ8QmlyZ3V+MDN8Qmlya2lya2FyYX4wNHxCaXLFvGViYnXEoWF+MDV8Qm9ybWxhfjA2fERpbmdsaX4wN3xGZ3VyYX4wOHxGbG9yaWFuYX4wOXxGb250YW5hfjEwfEd1ZGF+MTF8R8W8aXJhfjEyfEfEp2FqbnNpZWxlbX4xM3xHxKdhcmJ+MTR8R8SnYXJnxKd1cn4xNXxHxKdhc3JpfjE2fEfEp2F4YXF+MTd8xKZhbXJ1bn4xOHxJa2xpbn4xOXxJc2xhfjIwfEthbGthcmF+MjF8S2VyxItlbX4yMnxLaXJrb3B+MjN8TGlqYX4yNHxMdXFhfjI1fE1hcnNhfjI2fE1hcnNhc2thbGF+Mjd8TWFyc2F4bG9ra34yOHxNZGluYX4yOXxNZWxsaWXEp2F+MzB8TcShYXJyfjMxfE1vc3RhfjMyfE1xYWJiYX4zM3xNc2lkYX4zNHxNdGFyZmF+MzV8TXVueGFyfjM2fE5hZHVyfjM3fE5heHhhcn4zOHxQYW9sYX4zOXxQZW1icm9rZX40MHxQaWV0w6B+NDF8UWFsYX40MnxRb3JtaX40M3xRcmVuZGl+NDR8UmFiYXQgR8SnYXdkZXh+NDV8UmFiYXQgTWFsdGF+NDZ8U2FmaX40N3xTYW4gxKBpbGphbn40OHxTYW4gxKB3YW5ufjQ5fFNhbiBMYXdyZW56fjUwfFNhbiBQYXdsIGlsLUJhxKdhcn41MXxTYW5uYXR+NTJ8U2FudGEgTHXEi2lqYX41M3xTYW50YSBWZW5lcmF+NTR8U2nEocShaWV3aX41NXxTbGllbWF+NTZ8U3dpZXFpfjU3fFRhaSBYYmlleH41OHxUYXJ6aWVufjU5fFZhbGxldHRhfjYwfFhhZ8SncmF+NjF8WGV3a2lqYX42MnxYZ8SnYWpyYX42M3zFu2FiYmFyfjY0fMW7ZWJidcShIEfEp2F3ZGV+NjV8xbtlYmJ1xKEgTWFsdGF+NjZ8xbtlanR1bn42N3zFu3VycmllcX42OFwiXSwgW1wiTWFyc2hhbGwgSXNsYW5kc1wiLCBcIk1IXCIsIFwiQWlsaW5nbGFwbGFwfkFMTHxBaWx1a35BTEt8QXJub35BUk58QXVyfkFVUnxCaWtpbmkgYW5kIEtpbGl+S0lMfEVib25+RUJPfEphYmF0fkpBQnxKYWx1aXR+SkFMfEt3YWphbGVpbn5LV0F8TGFlfkxBRXxMaWJ+TElCfExpa2llcH5MSUt8TWFqdXJvfk1BSnxNYWxvZWxhcH5NQUx8TWVqaXR+TUVKfE5hbWRyaWt+Tk1LfE5hbXV+Tk1VfFJvbmdlbGFwflJPTnxVamFlflVKQXxVdHJpa35VVEl8V290aG9+V1RIfFdvdGplfldUSlwiXSwgW1wiTWFydGluaXF1ZVwiLCBcIk1RXCIsIFwiTWFydGluaXF1ZVwiXSwgW1wiTWF1cml0YW5pYVwiLCBcIk1SXCIsIFwiQWRyYXJ+MDd8QXNzYWJhfjAzfEJyYWtuYX4wNXxEYWtobGV0IE5vdWFkaGlib3V+MDh8R29yZ29sfjA0fEd1aWRpbWFrYX4xMHxIb2RoIEVjaCBDaGFyZ3VpfjAxfEhvZGggRWwgR2hhcmJpfjAyfEluY2hpcml+MTJ8Tm91YWtjaG90dCBOb3JkfjE0fE5vdWFrY2hvdHQgT3Vlc3R+MTN8Tm91YWtjaG90dCBTdWR+MTV8VGFnYW50fjA5fFRpcmlzIFplbW1vdXJ+MTF8VHJhcnphfjA2XCJdLCBbXCJNYXVyaXRpdXNcIiwgXCJNVVwiLCBcIkFnYWxlZ2EgSXNsYW5kc35BR3xCZWF1IEJhc3Npbi1Sb3NlIEhpbGx+QlJ8QmxhY2sgUml2ZXJ+Qkx8Q2FyZ2Fkb3MgQ2FyYWpvcyBTaG9hbHN+Q0N8Q3VyZXBpcGV+Q1V8RmxhY3F+Rkx8R3JhbmQgUG9ydH5HUHxNb2thfk1PfFBhbXBsZW1vdXNzZXN+UEF8UGxhaW5lcyBXaWxoZW1zflBXfFBvcnQgTG91aXMgKENpdHkpflBVfFBvcnQgTG91aXN+UEx8Uml2aWVyZSBkdSBSZW1wYXJ0flJSfFJvZHJpZ3VlcyBJc2xhbmR+Uk98U2F2YW5uZX5TQXxWYWNvYXMtUGhvZW5peH5DUFwiXSwgW1wiTWF5b3R0ZVwiLCBcIllUXCIsIFwiRHphb3Vkeml+MDF8UGFtYW5keml+MDJ8TWFtb3Vkem91fjAzfERlbWJlbml+MDR8QmFuZHLDqWzDqX4wNXxLYW5pLUvDqWxpfjA2fEJvdcOpbml+MDd8Q2hpcm9uZ3VpfjA4fFNhZGF+MDl8T3Vhbmdhbml+MTB8Q2hpY29uaX4xMXxUc2luZ29uaX4xMnxNJ1RzYW5nYW1vdWppfjEzfEFjb3VhfjE0fE10c2FtYm9yb34xNXxCYW5kcmFib3VhfjE2fEtvdW5nb3V+MTdcIl0sIFtcIk1leGljb1wiLCBcIk1YXCIsIFwiQWd1YXNjYWxpZW50ZXN+QUdVfEJhamEgQ2FsaWZvcm5pYX5CQ058QmFqYSBDYWxpZm9ybmlhIFN1cn5CQ1N8Q2FtcGVjaGV+Q0FNfENpdWRhZCBkZSBNw6l4aWNvfkRJRnxDaGlhcGFzfkNIUHxDaGlodWFodWF+Q0hIfENvYWh1aWxhIGRlIFphcmFnb3phfkNPQXxDb2xpbWF+Q09MfER1cmFuZ29+RFVSfEVzdGFkbyBkZSBNw6l4aWNvfk1FWHxHdWFuYWp1YXRvfkdVQXxHdWVycmVyb35HUk98SGlkYWxnb35ISUR8SmFsaXNjb35KQUx8TWljaG9hY8OhbiBkZSBPY2FtcG9+TUlDfE1vcmVsb3N+TU9SfE5heWFyaXR+TkFZfE51ZXZvIExlw7Nufk5MRXxPYXhhY2F+T0FYfFB1ZWJsYX5QVUV8UXVlcsOpdGFybyBkZSBBcnRlYWdhflFVRXxRdWludGFuYSBSb29+Uk9PfFNhbiBMdWlzIFBvdG9zw61+U0xQfFNpbmFsb2F+U0lOfFNvbm9yYX5TT058VGFiYXNjb35UQUJ8VGFtYXVsaXBhc35UQU18VGxheGNhbGF+VExBfFZlcmFjcnV6flZFUnxZdWNhdMOhbn5ZVUN8WmFjYXRlY2FzflpBQ1wiXSwgW1wiTWljcm9uZXNpYSwgRmVkZXJhdGVkIFN0YXRlcyBvZlwiLCBcIkZNXCIsIFwiQ2h1dWsgKFRydWspflRSS3xLb3NyYWV+S1NBfFBvaG5wZWl+UE5JfFlhcH5ZQVBcIl0sIFtcIk1vbGRvdmFcIiwgXCJNRFwiLCBcIkFlbmlpIE5vaX5BTnxCYXNhcmFiZWFzY2F+QlN8QsSDbMibaX5CQXxCZW5kZXJ+QkR8QnJpY2VuaX5CUnxDYWh1bH5DQXxDYW50ZW1pcn5DVHxDxINsxINyYciZaX5DTHxDxIN1yJllbml+Q1N8Q2hpyJlpbsSDdX5DVXxDaW1pyJlsaWF+Q018Q3JpdWxlbml+Q1J8RG9uZHXImWVuaX5ET3xEcm9jaGlhfkRSfER1YsSDc2FyaX5EVXxFZGluZcibfkVEfEbEg2xlyJl0aX5GQXxGbG9yZciZdGl+Rkx8R8SDZ8SDdXppYX5HQXxHbG9kZW5pfkdMfEjDrm5jZciZdGl+SEl8SWFsb3Zlbml+SUF8TGVvdmF+TEV8TmlzcG9yZW5pfk5JfE9jbmnIm2F+T0N8T3JoZWl+T1J8UmV6aW5hflJFfFLDrsiZY2FuaX5SSXxTw65uZ2VyZWl+U0l8U29yb2NhflNPfFN0w65uZ2EgTmlzdHJ1bHVpflNOfFN0csSDyJllbml+U1R8yJhvbGTEg25lyJl0aX5TRHzImHRlZmFuIFZvZMSDflNWfFRhcmFjbGlhflRBfFRlbGVuZciZdGl+VEV8VW5naGVuaX5VTlwiXSwgW1wiTW9uYWNvXCIsIFwiTUNcIiwgXCJDb2xsZX5DTHxDb25kYW1pbmV+Q098Rm9udHZpZWlsbGV+Rk98R2FyZX5HQXxKYXJkaW4gRXhvdGlxdWV+SkV8TGFydm90dG9+TEF8TWFsYm91c3F1ZXR+TUF8TW9uYWNvLVZpbGxlfk1PfE1vbmVnaGV0dGl+TUd8TW9udGUtQ2FybG9+TUN8TW91bGluc35NVXxQb3J0LUhlcmN1bGV+UEh8U2FpbnQtUm9tYW5+U1J8U2FpbnRlLUTDqXZvdGV+U0R8U291cmNlflNPfFNww6lsdWd1ZXN+U1B8VmFsbG9uIGRlIGxhIFJvdXNzZX5WUlwiXSwgW1wiTW9uZ29saWFcIiwgXCJNTlwiLCBcIkFyaGFuZ2F5fjA3M3xCYXlhbi1PbGdpeX4wNzF8QmF5YW5ob25nb3J+MDY5fEJ1bGdhbn4wNjd8RGFyaGFufjAzN3xEb3Jub2R+MDYxfERvcm5vZ292aX4wNjN8RHVuZGdvdml+MDU5fER6YXZoYW5+MDY1fEdvdmktQWx0YXl+MDY1fEdvdmktU3VtYmVyfjA2NHxIb3ZkfjA0M3xIb3ZzZ29sfjA0MXxPbW5vZ292aX4wNTN8T3ZvcmhhbmdheX4wNTV8U2VsZW5nZX4wNDl8U3VoYmFhdGFyfjA1MXxUb3Z+MDQ3fFVsYWFuYmFhdGFyfjF8VXZzfjA0NlwiXSwgW1wiTW9udGVuZWdyb1wiLCBcIk1FXCIsIFwiQW5kcmlqZXZpY2F+MDF8QmFyfjAyfEJlcmFuZX4wM3xCaWplbG8gUG9samV+MDR8QnVkdmF+MDV8Q2V0aW5qZX4wNnxEYW5pbG92Z3JhZH4wN3xHdXNpbmplfjIyfEhlcmNlZyBOb3ZpfjA4fEtvbGHFoWlufjA5fEtvdG9yfjEwfE1vamtvdmFjfjExfE5pa8WhacSHfjEyfFBldG5pY2F+MjN8UGxhdn4xM3xQbHXFvmluZX4xNHxQbGpldmxqYX4xNXxQb2Rnb3JpY2F+MTZ8Um/FvmFqZX4xN3zFoGF2bmlrfjE4fFRpdmF0fjE5fFVsY2luan4yMHzFvWFibGpha34yMVwiXSwgW1wiTW9udHNlcnJhdFwiLCBcIk1TXCIsIFwiU2FpbnQgQW50aG9ueXxTYWludCBHZW9yZ2VzfFNhaW50IFBldGVyJ3NcIl0sIFtcIk1vcm9jY29cIiwgXCJNQVwiLCBcIkNoYW91aWEtT3VhcmRpZ2hhfjA5fERvdWtoYWxhLUFiZGF+MTB8RsOocy1Cb3VsZW1hbmV+MDV8R2hhcmItQ2hyYXJkYS1CZW5pIEhzc2VufjAyfEdyYW5kIENhc2FibGFuY2F+MDh8R3VlbG1pbS1FcyBTZW1hcmF+MTR8TGHDonlvdW5lLUJvdWpkb3VyLVNha2lhIGVsIEhhbXJhfjE1fE1hcnJha2VjaC1UZW5zaWZ0LUFsIEhhb3V6fjExfE1la27DqHMtVGFmaWxhbGV0fjA2fE9yaWVudGFsfjA0fE91ZWQgZWQgRGFoYWItTGFnb3VpcmF+MTZ8U291c3MtTWFzc2EtRHLDomF+MTN8VGFkbGEtQXppbGFsfjEyfFRhbmdlci1Uw6l0b3Vhbn4wMXxUYXphLUFsIEhvY2VpbWEtVGFvdW5hdGV+MDNcIl0sIFtcIk1vemFtYmlxdWVcIiwgXCJNWlwiLCBcIkNhYm8gRGVsZ2Fkb35QfEdhemF+R3xJbmhhbWJhbmV+SXxNYW5pY2F+QnxNYXB1dG9+THxNYXB1dG8gKENpdHkpfk1QTXxOYW1wdWxhfk58Tmlhc3NhfkF8U29mYWxhflN8VGV0ZX5UfFphbWJlemlhflFcIl0sIFtcIk15YW5tYXJcIiwgXCJNTVwiLCBcIkF5ZXlhcndhZHl+MDd8QmFnb34wMnxDaGlufjE0fEthY2hpbn4xMXxLYXlhaH4xMnxLYXlpbn4xM3xNYWd3YXl+MDN8TWFuZGFsYXl+MDR8TW9ufjE1fE5heSBQeWkgVGF3fjE4fFJha2hpbmV+MTZ8U2FnYWluZ34wMXxTaGFufjE3fFRhbmludGhhcnlpfjA1fFlhbmdvbn4wNlwiXSwgW1wiTmFtaWJpYVwiLCBcIk5BXCIsIFwiRXJvbmdvfkVSfEhhcmRhcH5IQXxLYXZhbmdvIEVhc3R+S0V8S2F2YW5nbyBXZXN0fktXfEthcmFzfktBfEtob21hc35LSHxLdW5lbmV+S1V8T2hhbmd3ZW5hfk9XfE9tYWhla2V+T0h8T211c2F0aX5PU3xPc2hhbmF+T058T3NoaWtvdG9+T1R8T3Rqb3pvbmRqdXBhfk9EfFphbWJleml+Q0FcIl0sIFtcIk5hdXJ1XCIsIFwiTlJcIiwgXCJBaXdvfjAxfEFuYWJhcn4wMnxBbmV0YW5+MDN8QW5pYmFyZX4wNHxCYWl0aX4wNXxCb2V+MDZ8QnVhZGF+MDd8RGVuaWdvbW9kdX4wOHxFd2F+MDl8SWp1d34xMHxNZW5lbmd+MTF8Tmlib2t+MTJ8VWFib2V+MTN8WWFyZW5+MTRcIl0sIFtcIk5lcGFsXCIsIFwiTlBcIiwgXCJCYWdtYXRpfkJBfEJoZXJpfkJIfERoYXdhbGFnaXJpfkRIfEdhbmRha2l+R0F8SmFuYWtwdXJ+SkF8S2FybmFsaX5LQXxLb3NpfktPfEx1bWJpbml+TFV8TWFoYWthbGl+TUF8TWVjaGl+TUV8TmFyYXlhbml+TkF8UmFwdGl+UkF8U2FnYXJtYXRoYX5TQXxTZXRpflNFXCJdLCBbXCJOZXRoZXJsYW5kc1wiLCBcIk5MXCIsIFwiRHJlbnRoZX5EUnxGbGV2b2xhbmR+Rkx8RnJpZXNsYW5kfkZSfEdlbGRlcmxhbmR+R0V8R3JvbmluZ2VufkdSfExpbWJ1cmd+TEl8Tm9vcmQtQnJhYmFudH5OQnxOb29yZC1Ib2xsYW5kfk5IfE92ZXJpanNzZWx+T1Z8VXRyZWNodH5VVHxaZWVsYW5kflpFfFp1aWQtSG9sbGFuZH5aSFwiXSwgW1wiTmV3IENhbGVkb25pYVwiLCBcIk5DXCIsIFwiSWxlcyBMb3lhdXRlfE5vcmR8U3VkXCJdLCBbXCJOZXcgWmVhbGFuZFwiLCBcIk5aXCIsIFwiQXVja2xhbmR+QVVLfEJheSBvZiBQbGVudHl+Qk9QfENhbnRlcmJ1cnl+Q0FOfEdpc2Jvcm5lfkdJU3xIYXdrZSdzIEJheX5IS0J8TWFybGJvcm91Z2h+TUJIfE1hbmF3YXR1LVdhbmdhbnVpfk1XVHxOb3J0aGxhbmR+TlRMfE5lbHNvbn5OU058T3RhZ29+T1RBfFNvdXRobGFuZH5TVEx8VGFyYW5ha2l+VEtJfFRhc21hbn5UQVN8V2Fpa2F0b35XS098V2VsbGluZ3Rvbn5XR058V2VzdCBDb2FzdH5XVEN8Q2hhdGhhbSBJc2xhbmRzIFRlcnJpdG9yeX5DSVRcIl0sIFtcIk5pY2FyYWd1YVwiLCBcIk5JXCIsIFwiQm9hY29+Qk98Q2FyYXpvfkNBfENoaW5hbmRlZ2F+Q0l8Q2hvbnRhbGVzfkNPfEVzdGVsw61+RVN8R3JhbmFkYX5HUnxKaW5vdGVnYX5KSXxMZcOzbn5MRXxNYWRyaXp+TUR8TWFuYWd1YX5NTnxNYXNheWF+TVN8TWF0YWdhbHBhfk1UfE51ZXZhIFNlZ292aWF+TlN8UsOtbyBTYW4gSnVhbn5TSnxSaXZhc35SSXxBdGzDoW50aWNvIE5vcnRlfkFOfEF0bMOhbnRpY28gU3VyfkFTXCJdLCBbXCJOaWdlclwiLCBcIk5FXCIsIFwiQWdhZGV6fjF8RGlmZmF+MnxEb3Nzb34zfE1hcmFkaX40fE5pYW1leX44fFRhaG91YX41fFRpbGxhYsOpcml+NnxaaW5kZXJ+N1wiXSwgW1wiTmlnZXJpYVwiLCBcIk5HXCIsIFwiQWJpYX5BQnxBYnVqYSBGZWRlcmFsIENhcGl0YWwgVGVycml0b3J5fkZDfEFkYW1hd2F+QUR8QWt3YSBJYm9tfkFLfEFuYW1icmF+QU58QmF1Y2hpfkJBfEJheWVsc2F+Qll8QmVudWV+QkV8Qm9ybm9+Qk98Q3Jvc3MgUml2ZXJ+Q1J8RGVsdGF+REV8RWJvbnlpfkVCfEVkb35FRHxFa2l0aX5FS3xFbnVndX5FTnxHb21iZX5HT3xJbW9+SU18SmlnYXdhfkpJfEthZHVuYX5LRHxLYW5vfktOfEthdHNpbmF+S1R8S2ViYml+S0V8S29naX5LT3xLd2FyYX5LV3xMYWdvc35MQXxOYXNzYXJhd2F+TkF8TmlnZXJ+Tkl8T2d1bn5PR3xPbmRvfk9OfE9zdW5+T1N8T3lvfk9ZfFBsYXRlYXV+UEx8Uml2ZXJzflJJfFNva290b35TT3xUYXJhYmF+VEF8WW9iZX5ZT3xaYW1mYXJhflpBXCJdLCBbXCJOaXVlXCIsIFwiTlVcIiwgXCJOaXVlXCJdLCBbXCJOb3Jmb2xrIElzbGFuZFwiLCBcIk5GXCIsIFwiTm9yZm9sayBJc2xhbmRcIl0sIFtcIk5vcnRoZXJuIE1hcmlhbmEgSXNsYW5kc1wiLCBcIk1QXCIsIFwiTm9ydGhlcm4gSXNsYW5kc3xSb3RhfFNhaXBhbnxUaW5pYW5cIl0sIFtcIk5vcndheVwiLCBcIk5PXCIsIFwiQWtlcnNodXN+MDJ8QXVzdC1BZ2Rlcn4wOXxCdXNrZXJ1ZH4wNnxGaW5ubWFya34yMHxIZWRtYXJrfjA0fEhvcmRhbGFuZH4xMnxNw7hyZSBvZyBSb21zZGFsfjE1fE5vcmRsYW5kfjE4fE5vcmQtVHLDuG5kZWxhZ34xN3xPcHBsYW5kfjA1fE9zbG9+MDN8Um9nYWxhbmR+MTF8U29nbiBvZyBGam9yZGFuZX4xNHxTw7hyLVRyw7huZGVsYWd+MTZ8VGVsZW1hcmt+MDh8VHJvbXN+MTl8VmVzdC1BZ2Rlcn4xMHxWZXN0Zm9sZH4wN3zDmHN0Zm9sZH4wMXxKYW4gTWF5ZW5+MjJ8U3ZhbGJhcmR+MjFcIl0sIFtcIk9tYW5cIiwgXCJPTVwiLCBcIkFkIERha2hpbGl5YWh+REF8QWwgQnVyYXltaX5CVXxBbCBXdXN0YX5XVXxBeiBaYWhpcmFoflpBfEphbnViIGFsIEJhdGluYWh+QlN8SmFudWIgYXNoIFNoYXJxaXlhaH5TU3xNYXNxYXR+TUF8TXVzYW5kYW1+TVV8U2hhbWFsIGFsIEJhdGluYWh+Qkp8U2hhbWFsIGFzaCBTaGFycWl5YWh+U0p8WnVmYXJ+WlVcIl0sIFtcIlBha2lzdGFuXCIsIFwiUEtcIiwgXCLEgHrEgWQgS2FzaG3Eq3J+Skt8QmFsxY1jaGlzdMSBbn5CQXxHaWxnaXQtQmFsdGlzdMSBbn5HQnxJc2zEgW3EgWLEgWR+SVN8S2hhxKtiYXIgUGFraHTFq25raHfEgXN+S1B8UHVuasSBYn5QQnxTaW5kaH5TRHxGZWRlcmFsbHkgQWRtaW5pc3RlcmVkIFRyaWJhbCBBcmVhc35UQVwiXSwgW1wiUGFsYXVcIiwgXCJQV1wiLCBcIkFpbWVsaWlrfjAwMnxBaXJhaX4wMDR8QW5nYXVyfjAxMHxIYXRvYm9oZWl+MDUwfEtheWFuZ2VsfjEwMHxLb3Jvcn4xNTB8TWVsZWtlb2t+MjEyfE5nYXJhYXJkfjIxNHxOZ2FyY2hlbG9uZ34yMTh8TmdhcmRtYXV+MjIyfE5nYXRwYW5nfjIyNHxOZ2NoZXNhcn4yMjZ8TmdlcmVtbGVuZ3VpfjIyN3xOZ2l3YWx+MjI4fFBlbGVsaXV+MzUwfFNvbnNvcmFsfjM1MFwiXSwgW1wiUGFsZXN0aW5lLCBTdGF0ZSBvZlwiLCBcIlBTXCIsIFwiQWsgS2hhbMSrbH5IQk58QWwgUXVkc35KRU18QXLEq+G4qcSBIHdhbCBBZ2h3xIFyfkpSSHxCYXl0IExh4bipbX5CVEh8RGF5ciBhbCBCYWxh4bipfkRFQnxHaGF6emFofkdaQXxKYW7Eq25+SkVOfEtoxIFuIFnFq25pc35LWVN8TsSBYmx1c35OQlN8UWFsccSreWFoflFRQXxSYWZh4bipflJGSHxSxIFtIEFsbMSBaCB3YWwgQsSrcmFoflJCSHxTYWxmxKt0flNMVHxTaGFtxIFsIEdoYXp6YWh+TkdafMWixatixIFzflRCU3zFosWrbGthcm1+VEtNXCJdLCBbXCJQYW5hbWFcIiwgXCJQQVwiLCBcIkJvY2FzIGRlbCBUb3JvfjF8Q2hpcmlxdcOtfjR8Q29jbMOpfjJ8Q29sw7NufjN8RGFyacOpbn41fEVtYmVyw6F+RU18SGVycmVyYX42fEt1bmEgWWFsYX5LWXxMb3MgU2FudG9zfjd8TmfDpGJlLUJ1Z2zDqX5OQnxQYW5hbcOhfjh8UGFuYW3DoSBPZXN0ZX4xMHxWZXJhZ3Vhc345XCJdLCBbXCJQYXB1YSBOZXcgR3VpbmVhXCIsIFwiUEdcIiwgXCJCb3VnYWludmlsbGV+TlNCfENlbnRyYWx+Q1BNfENoaW1idX5DUEt8RWFzdCBOZXcgQnJpdGFpbn5FQlJ8RWFzdCBTZXBpa35FU1d8RWFzdGVybiBIaWdobGFuZHN+RUhHfEVuZ2F+RVBXfEd1bGZ+R1BLfEhlbGF+SExBfEppd2FrYX5KV0t8TWFkYW5nfk1PTXxNYW51c35NUkx8TWlsbmUgQmF5fk1CQXxNb3JvYmV+TVBMfFBvcnQgTW9yZXNieX5OQ0R8TmV3IElyZWxhbmR+TklLfE5vcnRoZXJufk5QUHxTb3V0aGVybiBIaWdobGFuZHN+U0hNfFdlc3QgTmV3IEJyaXRhaW5+V0JLfFdlc3QgU2VwaWt+U0FOfFdlc3Rlcm5+V1BEfFdlc3Rlcm4gSGlnaGxhbmRzfldITVwiXSwgW1wiUGFyYWd1YXlcIiwgXCJQWVwiLCBcIkFsdG8gUGFyYWd1YXl+MTZ8QWx0byBQYXJhbmF+MTB8QW1hbWJheX4xM3xBc3VuY2lvbn5BU1V8Q2FhZ3VhenV+NXxDYWF6YXBhfjZ8Q2FuaW5kZXl1fjE0fENlbnRyYWx+MTF8Q29uY2VwY2lvbn4xfENvcmRpbGxlcmF+M3xHdWFpcmF+NHxJdGFwdWF+N3xNaXNpb25lc344fE5lZW1idWN1fjEyfFBhcmFndWFyaX45fFByZXNpZGVudGUgSGF5ZXN+MTV8U2FuIFBlZHJvfjJcIl0sIFtcIlBlcnVcIiwgXCJQRVwiLCBcIkFtYXpvbmFzfkFNQXxBbmNhc2h+QU5DfEFwdXJpbWFjfkFQVXxBcmVxdWlwYX5BUkV8QXlhY3VjaG9+QVlBfENhamFtYXJjYX5DQUp8Q2FsbGFvfkNBTHxDdXNjb35DVVN8SHVhbmNhdmVsaWNhfkhVVnxIdWFudWNvfkhVQ3xJY2F+SUNBfEp1bmlufkpVTnxMYSBMaWJlcnRhZH5MQUx8TGFtYmF5ZXF1ZX5MQU18TGltYX5MSU18TG9yZXRvfkxPUnxNYWRyZSBkZSBEaW9zfk1ERHxNb3F1ZWd1YX5NT1F8TXVuaWNpcGFsaWRhZCBNZXRyb3BvbGl0YW5hIGRlIExpbWF+TE1BfFBhc2NvflBBU3xQaXVyYX5QSVV8UHVub35QVU58U2FuIE1hcnRpbn5TQU18VGFjbmF+VEFDfFR1bWJlc35UVU18VWNheWFsaX5VQ0FcIl0sIFtcIlBoaWxpcHBpbmVzXCIsIFwiUEhcIiwgXCJBYnJhfkFCUnxBZ3VzYW4gZGVsIE5vcnRlfkFHTnxBZ3VzYW4gZGVsIFN1cn5BR1N8QWtsYW5+QUtMfEFsYmF5fkFMQnxBbnRpcXVlfkFOVHxBcGF5YW9+QVBBfEF1cm9yYX5BVVJ8QmFzaWxhbn5CQVN8QmF0YWFufkJBTnxCYXRhbmVzfkJUTnxCYXRhbmdhc35CVEd8QmVuZ3VldH5CRU58QmlsaXJhbn5CSUx8Qm9ob2x+Qk9IfEJ1a2lkbm9ufkJVS3xCdWxhY2FufkJVTHxDYWdheWFufkNBR3xDYW1hcmluZXMgTm9ydGV+Q0FOfENhbWFyaW5lcyBTdXJ+Q0FTfENhbWlndWlufkNBTXxDYXBpen5DQVB8Q2F0YW5kdWFuZXN+Q0FUfENhdml0ZX5DQVZ8Q2VidX5DRUJ8Q29tcG9zdGVsYX5DT018Q290YWJhdG9+TkNPfERhdmFvIGRlbCBOb3J0ZX5EQVZ8RGF2YW8gZGVsIFN1cn5EQVN8RGF2YW8gT2NjaWRlbnRhbH5EVk98RGF2YW8gT3JpZW50YWx+REFPfERpbmFnYXQgSXNsYW5kc35ESU58RWFzdGVybiBTYW1hcn5FQVN8R3VpbWFyYXN+R1VJfElmdWdhb35JRlV8SWxvY29zIE5vcnRlfklMTnxJbG9jb3MgU3VyfklMU3xJbG9pbG9+SUxJfElzYWJlbGF+SVNBfEthbGluZ2F+S0FMfExhIFVuaW9ufkxVTnxMYWd1bmF+TEFHfExhbmFvIGRlbCBOb3J0ZX5MQU58TGFuYW8gZGVsIFN1cn5MQVN8TGV5dGV+TEVZfE1hZ3VpbmRhbmFvfk1BR3xNYXNiYXRlfk1BU3xNZXRybyBNYW5pbGF+MDB8TWluZG9ybyBPY2NpZGVudGFsfk1EQ3xNaW5kb3JvIE9yaWVudGFsfk1EUnxNaXNhbWlzIE9jY2lkZW50YWx+TVNDfE1pc2FtaXMgT3JpZW50YWx+TVNSfE1vdW50YWluIFByb3ZpbmNlfk1PVXxOZWdyb3MgT2NjaWRlbnRhbH5ORUN8TmVncm9zIE9yaWVudGFsfk5FUnxOb3J0aGVybiBTYW1hcn5OU0F8TnVldmEgRWNpamF+TlVFfE51ZXZhIFZpemNheWF+TlVWfFBhbGF3YW5+UExXfFBhbXBhbmdhflBBTXxQYW5nYXNpbmFuflBBTnxRdWV6b25+UVVFfFF1aXJpbm9+UVVJfFJpemFsflJJWnxSb21ibG9uflJPTXxTYW1hcn5XU0F8U2FyYW5nYW5pflNBUnxTaXF1aWpvcn5TSUd8U29yc29nb25+U09SfFNvdXRoZXJuIExleXRlflNMRXxTdWx0YW4gS3VkYXJhdH5BVUt8U3VsdX5TTFV8U3VyaWdhbyBkZWwgTm9ydGV+U1VOfFN1cmlnYW8gZGVsIFN1cn5TVVJ8VGFybGFjflRBUnxUYXdpLVRhd2l+VEFXfFphbWJhbGVzflpNQnxaYW1ib2FuZ2EgZGVsIE5vcnRlflpBTnxaYW1ib2FuZ2EgZGVsIFN1cn5aQVN8WmFtYm9hbmdhIFNpYnVnYXl+WlNJXCJdLCBbXCJQaXRjYWlyblwiLCBcIlBOXCIsIFwiUGl0Y2Fpcm4gSXNsYW5kc1wiXSwgW1wiUG9sYW5kXCIsIFwiUExcIiwgXCJEb2xub8WbbMSFc2tpZX5EU3xLdWphd3Nrby1wb21vcnNraWV+S1B8xYHDs2R6a2llfkxEfEx1YmVsc2tpZX5MVXxMdWJ1c2tpZX5MQnxNYWxvcG9sc2tpZX5NQXxNYXpvd2llY2tpZX5NWnxPcG9sc2tpZX5PUHxQb2RrYXJwYWNraWV+UEt8UG9kbGFza2llflBEfFBvbW9yc2tpZX5QTXzFmmzEhXNraWV+U0x8xZp3acSZdG9rcnp5c2tpZX5TS3xXYXJtacWEc2tvLW1henVyc2tpZX5XTnxXaWVsa29wb2xza2llfldQfFphY2hvZG5pb3BvbW9yc2tpZX5aUFwiXSwgW1wiUG9ydHVnYWxcIiwgXCJQVFwiLCBcIkFjb3Jlc34yMHxBdmVpcm9+MDF8QmVqYX4wMnxCcmFnYX4wM3xCcmFnYW5jYX4wNHxDYXN0ZWxvIEJyYW5jb34wNXxDb2ltYnJhfjA2fEV2b3JhfjA3fEZhcm9+MDh8R3VhcmRhfjA5fExlaXJpYX4xMHxMaXNib2F+MTF8TWFkZWlyYX4zMHxQb3J0YWxlZ3JlfjEyfFBvcnRvfjEzfFNhbnRhcmVtfjE0fFNldHViYWx+MTV8VmlhbmEgZG8gQ2FzdGVsb34xNnxWaWxhIFJlYWx+MTd8VmlzZXV+MThcIl0sIFtcIlB1ZXJ0byBSaWNvXCIsIFwiUFJcIiwgXCJBZGp1bnRhc3xBZ3VhZGF8QWd1YWRpbGxhfEFndWFzIEJ1ZW5hc3xBaWJvbml0b3xBbmFzY298QXJlY2lib3xBcnJveW98QmFyY2Vsb25ldGF8QmFycmFucXVpdGFzfEJheWFtb258Q2FibyBSb2pvfENhZ3Vhc3xDYW11eXxDYW5vdmFuYXN8Q2Fyb2xpbmF8Q2F0fENlaWJhfENpYWxlc3xDaWRyYXxDb2Ftb3xDb21lcmlvfENvcm96YWx8Q3VsZWJyYXxEb3JhZG98RmFqYXJkb3xGbG9yaWRhfEd1YW5pY2F8R3VheWFtYXxHdWF5YW5pbGxhfEd1YXluYWJvfEd1cmFib3xIYXRpbGxvfEhvcm1pZ3Vlcm9zfEh1bWFjYW98SXNhYmV8SnVhbmEgRGlhenxKdW5jb3N8TGFqYXN8TGFyZXN8TGFzIE1hcmlhc3xMYXMgb2l6YXxMdXF1aWxsb3xNYW5hdGl8TWFyaWNhb3xNYXVuYWJvfE1heWFndWV6fE1vY2F8TW9yb3Zpc3xOYWd1YWJvfE5hcmFuaml0b3xPcm9jb3Zpc3xQYXRpbGxhc3xQZW51ZWxhc3xQb25jZXxRdWVicmFkaWxsYXN8UmluY29ufFJpbyBHcmFuZGV8U2FiYW5hIGxpbmFzfFNhbiBHZXJtYW58U2FuIEp1YW58U2FuIExvcmVuem98U2FuIFNlYmFzdGlhbnxTYW50YSBJc2FiZWx8VG9hIEFsdGF8VG9hIEJhamF8VHJ1amlsbG8gQWx0b3xVdHVhZG98VmVnYSBBbHRhfFZlZ2EgdWVzfFZpbGxhbGJhfFlhYnVjb2F8WWF1Y29cIl0sIFtcIlFhdGFyXCIsIFwiUUFcIiwgXCJBZCBEYXfhuKlhaH5EQXxBbCBLaGF3ciB3YSBhZGggRGhha2jEq3JhaH5LSHxBbCBXYWtyYWh+V0F8QXIgUmF5ecSBbn5SQXxBc2ggU2hhbcSBbH5NU3xBesynIFphzKdgxIF5aW5+WkF8VW1tIMWeYWzEgWx+VVNcIl0sIFtcIlLDqXVuaW9uXCIsIFwiUkVcIiwgXCJSw6l1bmlvblwiXSwgW1wiUm9tYW5pYVwiLCBcIlJPXCIsIFwiQWxiYX5BQnxBcmFkfkFSfEFyZ2VzfkFHfEJhY2F1fkJDfEJpaG9yfkJIfEJpc3RyaXRhLU5hc2F1ZH5CTnxCb3Rvc2FuaX5CVHxCcmFpbGF+QlJ8QnJhc292fkJWfEJ1Y3VyZXN0aX5CfEJ1emF1fkJafENhbGFyYXNpfkNMfENhcmFzLVNldmVyaW5+Q1N8Q2x1an5DSnxDb25zdGFudGF+Q1R8Q292YXNuYX5DVnxEYW1ib3ZpdGF+REJ8RG9san5ESnxHYWxhdGl+R0x8R2l1cmdpdX5HUnxHb3JqfkdKfEhhcmdoaXRhfkhSfEh1bmVkb2FyYX5IRHxJYWxvbWl0YX5JTHxJYXNpfklTfE1hcmFtdXJlc35NTXxNZWhlZGludGl+TUh8TXVyZXN+TVN8TmVhbXR+TlR8T2x0fk9UfFByYWhvdmF+UEh8U2FsYWp+U0p8U2F0dSBNYXJlflNNfFNpYml1flNCfFN1Y2VhdmF+U1Z8VGVsZW9ybWFuflRSfFRpbWlzflRNfFR1bGNlYX5UTHxWYWxjZWF+Vkx8VmFzbHVpflZTfFZyYW5jZWF+Vk5cIl0sIFtcIlJ1c3NpYW4gRmVkZXJhdGlvblwiLCBcIlJVXCIsIFwiUmVwdWJsaWMgb2YgQWR5Z2VhfkFEfFJlcHVibGljIG9mIEFsdGFpIChHb3Juby1BbHRheXNrKX5BTHxBbHRhaSBLcmFpfkFMVHxBbXVyIE9ibGFzdH5BTVV8QXJraGFuZ2Vsc2sgT2JsYXN0fkFSS3xBc3RyYWtoYW4gT2JsYXN0fkFTVHxSZXB1YmxpYyBvZiBCYXNoa29ydG9zdGFufkJBfEJlbGdvcm9kIE9ibGFzdH5CRUx8QnJ5YW5zayBPYmxhc3R+QlJZfFJlcHVibGljIG9mIEJ1cnlhdGlhfkJVfENoZWNoZW4gUmVwdWJsaWN+Q0V8Q2hlbHlhYmluc2sgT2JsYXN0fkNIRXxDaHVrb3RrYSBBdXRvbm9tb3VzIE9rcnVnfkNIVXxDaHV2YXNoIFJlcHVibGljfkNVfFJlcHVibGljIG9mIERhZ2VzdGFufkRBfFJlcHVibGljIG9mIEluZ3VzaGV0aWF+SU58SXJrdXRzayBPYmxhc3R+SVJLfEl2YW5vdm8gT2JsYXN0fklWQXxKZXdpc2ggQXV0b25vbW91cyBPYmxhc3R+SkVXfEthYmFyZGluby1CYWxrYXIgUmVwdWJsaWN+S0J8S2FsaW5pbmdyYWQgT2JsYXN0fktMTnxSZXB1YmxpYyBvZiBLYWxteWtpYX5LTHxLYWx1Z2EgT2JsYXN0fktMVXxLYW1jaGF0a2EgS3JhaX5LQU18S2FyYWNoYXktQ2hlcmtlc3MgUmVwdWJsaWN+S0N8UmVwdWJsaWMgb2YgS2FyZWxpYX5LUnxLaGFiYXJvdnNrIEtyYWl+S0hBfFJlcHVibGljIG9mIEtoYWthc3NpYX5LS3xLaGFudHktTWFuc2kgQXV0b25vbW91cyBPa3J1ZyAtIFl1Z3JhfktITXxLZW1lcm92byBPYmxhc3R+S0VNfEtpcm92IE9ibGFzdH5LSVJ8S29taSBSZXB1YmxpY35LT3xLb3N0cm9tYSBPYmxhc3R+S09TfEtyYXNub2RhciBLcmFpfktEQXxLcmFzbm95YXJzayBLcmFpfktZQXxLdXJnYW4gT2JsYXN0fktHTnxLdXJzayBPYmxhc3R+S1JTfExlbmluZ3JhZCBPYmxhc3R+TEVOfExpcGV0c2sgT2JsYXN0fkxJUHxNYWdhZGFuIE9ibGFzdH5NQUd8TWFyaSBFbCBSZXB1YmxpY35NRXxSZXB1YmxpYyBvZiBNb3Jkb3ZpYX5NT3xNb3Njb3cgT2JsYXN0fk1PU3xNb3Njb3d+TU9XfE11cm1hbnNrIE9ibGFzdH5NVXxOZW5ldHMgQXV0b25vbW91cyBPa3J1Z35ORU58Tml6aG55IE5vdmdvcm9kIE9ibGFzdH5OSVp8Tm92Z29yb2QgT2JsYXN0fk5HUnxOb3Zvc2liaXJzayBPYmxhc3R+TlZTfE9tc2sgT2JsYXN0fk9NU3xPcmVuYnVyZyBPYmxhc3R+T1JFfE9yeW9sIE9ibGFzdH5PUkx8UGVuemEgT2JsYXN0flBOWnxQZXJtIEtyYWl+UEVSfFByaW1vcnNreSBLcmFpflBSSXxQc2tvdiBPYmxhc3R+UFNLfFJvc3RvdiBPYmxhc3R+Uk9TfFJ5YXphbiBPYmxhc3R+UllBfFNhaW50IFBldGVyc2J1cmd+U1BFfFNha2hhIChZYWt1dGlhKSBSZXB1YmxpY35TQXxTYWtoYWxpbiBPYmxhc3R+U0FLfFNhbWFyYSBPYmxhc3R+U0FNfFNhcmF0b3YgT2JsYXN0flNBUnxSZXB1YmxpYyBvZiBOb3J0aCBPc3NldGlhLUFsYW5pYX5OT0F8U21vbGVuc2sgT2JsYXN0flNNT3xTdGF2cm9wb2wgS3JhaX5TVEF8U3ZlcmRsb3ZzayBPYmxhc3R+U1ZFfFRhbWJvdiBPYmxhc3R+VEFNfFJlcHVibGljIG9mIFRhdGFyc3Rhbn5UQXxUb21zayBPYmxhc3R+VE9NfFR1dmEgUmVwdWJsaWN+VFV8VHVsYSBPYmxhc3R+VFVMfFR2ZXIgT2JsYXN0flRWRXxUeXVtZW4gT2JsYXN0flRZVXxVZG11cnQgUmVwdWJsaWN+VUR8VWx5YW5vdnNrIE9ibGFzdH5VTFl8VmxhZGltaXIgT2JsYXN0flZMQXxWb2xnb2dyYWQgT2JsYXN0flZHR3xWb2xvZ2RhIE9ibGFzdH5WTEd8Vm9yb25lemggT2JsYXN0flZPUnxZYW1hbG8tTmVuZXRzIEF1dG9ub21vdXMgT2tydWd+WUFOfFlhcm9zbGF2bCBPYmxhc3R+WUFSfFphYmF5a2Fsc2t5IEtyYWl+WkFCXCJdLCBbXCJSd2FuZGFcIiwgXCJSV1wiLCBcIktpZ2FsaX4wMXxFYXN0ZXJufjAyfE5vcnRoZXJufjAzfFdlc3Rlcm5+MDR8U291dGhlcm5+MDVcIl0sIFtcIlNhaW50IEJhcnRow6lsZW15XCIsIFwiQkxcIiwgXCJBdSBWZW50fjAyfFNvdXMgbGUgVmVudH4wMVwiXSwgW1wiU2FpbnQgSGVsZW5hLCBBc2NlbnNpb24gYW5kIFRyaXN0YW4gZGEgQ3VuaGFcIiwgXCJTSFwiLCBcIkFzY2Vuc2lvbn5BQ3xTYWludCBIZWxlbmF+SEx8VHJpc3RhbiBkYSBDdW5oYX5UQVwiXSwgW1wiU2FpbnQgS2l0dHMgYW5kIE5ldmlzXCIsIFwiS05cIiwgXCJTYWludCBLaXR0c35LfE5ldmlzfk5cIl0sIFtcIlNhaW50IEx1Y2lhXCIsIFwiTENcIiwgXCJBbnNlLWxhLVJheWV+MDF8Q2FuYXJpZXN+MTJ8Q2FzdHJpZXN+MDJ8Q2hvaXNldWx+MDN8RGVubmVyeX4wNXxHcm9zIElzbGV0fjA2fExhYm9yaWV+MDd8TWljb3VkfjA4fFNvdWZyaWVyZX4xMHxWaWV1eCBGb3J0fjExXCJdLCBbXCJTYWludCBNYXJ0aW5cIiwgXCJNRlwiLCBcIlNhaW50IE1hcnRpblwiXSwgW1wiU2FpbnQgUGllcnJlIGFuZCBNaXF1ZWxvblwiLCBcIlBNXCIsIFwiTWlxdWVsb258U2FpbnQgUGllcnJlXCJdLCBbXCJTYWludCBWaW5jZW50IGFuZCB0aGUgR3JlbmFkaW5lc1wiLCBcIlZDXCIsIFwiQ2hhcmxvdHRlfjAxfEdyZW5hZGluZXN+MDZ8U2FpbnQgQW5kcmV3fjAyfFNhaW50IERhdmlkfjAzfFNhaW50IEdlb3JnZX4wNHxTYWludCBQYXRyaWNrfjA1XCJdLCBbXCJTYW1vYVwiLCBcIldTXCIsIFwiQSdhbmF+QUF8QWlnYS1pLWxlLVRhaX5BTHxBdHVhfkFUfEZhJ2FzYWxlbGVhZ2F+RkF8R2FnYSdlbWF1Z2F+R0V8R2FnYWlmb21hdWdhfkdJfFBhbGF1bGl+UEF8U2F0dXBhJ2l0ZWF+U0F8VHVhbWFzYWdhflRVfFZhJ2Etby1Gb25vdGl+VkZ8VmFpc2lnYW5vflZTXCJdLCBbXCJTYW4gTWFyaW5vXCIsIFwiU01cIiwgXCJBY3F1YXZpdmF+MDF8Qm9yZ28gTWFnZ2lvcmV+MDZ8Q2hpZXNhbnVvdmF+MDJ8RG9tYWduYW5vfjAzfEZhZXRhbm9+MDR8RmlvcmVudGlub34wNXxNb250ZWdpYXJkaW5vfjA4fFNhbiBNYXJpbm9+MDd8U2VycmF2YWxsZX4wOVwiXSwgW1wiU2FvIFRvbWUgYW5kIFByaW5jaXBlXCIsIFwiU1RcIiwgXCJQcmluY2lwZX5QfFNhbyBUb21lflNcIl0sIFtcIlNhdWRpIEFyYWJpYVwiLCBcIlNBXCIsIFwiJ0FzaXJ+MTR8QWwgQmFoYWh+MTF8QWwgSHVkdWQgYXNoIFNoYW1hbGl5YWh+MDh8QWwgSmF3Zn4xMnxBbCBNYWRpbmFoIGFsIE11bmF3d2FyYWh+MDN8QWwgUWFzaW1+MDV8QXIgUml5YWR+MDF8QXNoIFNoYXJxaXlhaH4wNHxIYSdpbH4wNnxKYXphbn4wOXxNYWtrYWggYWwgTXVrYXJyYW1haH4wMnxOYWpyYW5+MTB8VGFidWt+MDdcIl0sIFtcIlNlbmVnYWxcIiwgXCJTTlwiLCBcIkRha2FyfkRLfERpb3VyYmVsfkRCfEZhdGlja35GS3xLYWZmcmluZX5LQXxLYW9sYWNrfktMfEtlZG91Z291fktFfEtvbGRhfktEfExvdWdhfkxHfE1hdGFtfk1UfFNhaW50LUxvdWlzflNMfFNlZGhpb3V+U0V8VGFtYmFjb3VuZGF+VEN8VGhpZXN+VEh8WmlndWluY2hvcn5aR1wiXSwgW1wiU2VyYmlhXCIsIFwiUlNcIiwgXCJCZW9ncmFkIChCZWxncmFkZSl+MDB8Qm9yc2tpfjE0fEJyYW5pxI1ldnNraX4xMXxKYWJsYW5pxI1raX4yM3xKdcW+bm9iYcSNa2l+MDZ8SnXFvm5vYmFuYXRza2l+MDR8S29sdWJhcnNraX4wOXxLb3NvdnNraX4yNXxLb3NvdnNrby1NaXRyb3ZhxI1raX4yOHxLb3NvdnNrby1Qb21vcmF2c2tpfjI5fE1hxI12YW5za2l+MDh8TW9yYXZpxI1raX4xN3xOacWhYXZza2l+MjB8UMSNaW5qc2tpfjI0fFBlxIdraX4yNnxQaXJvdHNraX4yMnxQb2R1bmF2c2tpfjEwfFBvbW9yYXZza2l+MTN8UHJpenJlbnNraX4yN3xSYXNpbnNraX4xOXxSYcWha2l+MTh8U2V2ZXJub2JhxI1raX4wMXxTZXZlcm5vYmFuYXRza2l+MDN8U3JlZG5qZWJhbmF0c2tpfjAyfFNyZW1za2l+MDd8xaB1bWFkaWpza2l+MTJ8VG9wbGnEjWtpfjIxfFphamXEjWFyc2tpfjE1fFphcGFkbm9iYcSNa2l+MDV8WmxhdGlib3Jza2l+MTZcIl0sIFtcIlNleWNoZWxsZXNcIiwgXCJTQ1wiLCBcIkFuc2UgYXV4IFBpbnN+MDF8QW5zZSBCb2lsZWF1fjAyfEFuc2UgRXRvaWxlfjAzfEFuc2UgUm95YWxlfjA1fEFudSBDYXB+MDR8QmFpZSBMYXphcmV+MDZ8QmFpZSBTYWludGUgQW5uZX4wN3xCZWF1IFZhbGxvbn4wOHxCZWwgQWlyfjA5fEJlbCBPbWJyZX4xMHxDYXNjYWRlfjExfEdsYWNpc34xMnxHcmFuZCdBbnNlIE1haGV+MTN8R3JhbmQnQW5zZSBQcmFzbGlufjE0fExhIERpZ3VlfjE1fExhIFJpdmllcmUgQW5nbGFpc2V+MTZ8TGVzIE1hbWVsbGVzfjI0fE1vbnQgQnV4dG9ufjE3fE1vbnQgRmxldXJpfjE4fFBsYWlzYW5jZX4xOXxQb2ludGUgTGEgUnVlfjIwfFBvcnQgR2xhdWR+MjF8Um9jaGUgQ2FpbWFufjI1fFNhaW50IExvdWlzfjIyfFRha2FtYWthfjIzXCJdLCBbXCJTaWVycmEgTGVvbmVcIiwgXCJTTFwiLCBcIkVhc3Rlcm5+RXxOb3J0aGVybn5OfFNvdXRoZXJuflN8V2VzdGVybn5XXCJdLCBbXCJTaW5nYXBvcmVcIiwgXCJTR1wiLCBcIkNlbnRyYWwgU2luZ2Fwb3JlfjAxfE5vcnRoIEVhc3R+MDJ8Tm9ydGggV2VzdH4wM3xTb3V0aCBFYXN0fjA0fFNvdXRoIFdlc3R+MDVcIl0sIFtcIlNpbnQgTWFhcnRlbiAoRHV0Y2ggcGFydClcIiwgXCJTWFwiLCBcIlNpbnQgTWFhcnRlblwiXSwgW1wiU2xvdmFraWFcIiwgXCJTS1wiLCBcIkJhbnNrb2J5c3RyaWNreX5CQ3xCcmF0aXNsYXZza3l+Qkx8S29zaWNreX5LSXxOaXRyaWFuc2t5fk5JfFByZXNvdnNreX5QVnxUcmVuY2lhbnNreX5UQ3xUcm5hdnNreX5UQXxaaWxpbnNreX5aSVwiXSwgW1wiU2xvdmVuaWFcIiwgXCJTSVwiLCBcIkFqZG92c2NpbmF+MDAxfEFwYWNlfjE5NXxCZWx0aW5jaX4wMDJ8QmVuZWRpa3R+MTQ4fEJpc3RyaWNhIG9iIFNvdGxpfjE0OXxCbGVkfjAwM3xCbG9rZX4xNTB8Qm9oaW5qfjAwNHxCb3Jvdm5pY2F+MDA1fEJvdmVjfjAwNnxCcmFzbG92Y2V+MTUxfEJyZGF+MDA3fEJyZXppY2V+MDA5fEJyZXpvdmljYX4wMDh8Q2Fua292YX4xNTJ8Q2VsamV+MDExfENlcmtsamUgbmEgR29yZW5qc2tlbX4wMTJ8Q2Vya25pY2F+MDEzfENlcmtub34wMTR8Q2Vya3Zlbmpha34xNTN8Q2lya3VsYW5lfjE5NnxDcmVuc292Y2l+MDE1fENybmEgbmEgS29yb3NrZW1+MDE2fENybm9tZWxqfjAxN3xEZXN0cm5pa34wMTh8RGl2YWNhfjAxOXxEb2JqZX4xNTR8RG9icmVwb2xqZX4wMjB8RG9icm5hfjE1NXxEb2Jyb3ZhLVBvbGhvdiBHcmFkZWN+MDIxfERvYnJvdm5pa34xNTZ8RG9sIHByaSBManVibGphbml+MDIyfERvbGVuanNrZSBUb3BsaWNlfjE1N3xEb216YWxlfjAyM3xEb3JuYXZhfjAyNHxEcmF2b2dyYWR+MDI1fER1cGxla34wMjZ8R29yZW5qYSBWYXMtUG9samFuZX4wMjd8R29yaXNuaWNhfjAyOHxHb3JqZX4yMDd8R29ybmphIFJhZGdvbmF+MDI5fEdvcm5qaSBHcmFkfjAzMHxHb3JuamkgUGV0cm92Y2l+MDMxfEdyYWR+MTU4fEdyb3N1cGxqZX4wMzJ8SGFqZGluYX4xNTl8SG9jZS1TbGl2bmljYX4xNjB8SG9kb3N+MTYxfEhvcmp1bH4xNjJ8SHJhc3RuaWt+MDM0fEhycGVsamUtS296aW5hfjAzNXxJZHJpamF+MDM2fElnfjAzN3xJbGlyc2thIEJpc3RyaWNhfjAzOHxJdmFuY25hIEdvcmljYX4wMzl8SXpvbGF+MDQwc3xKZXNlbmljZX4wNDF8SnVyc2luY2l+MDQyfEthbW5pa34wNDN8S2FuYWx+MDQ0fEtpZHJpY2V2b34wNDV8S29iYXJpZH4wNDZ8S29iaWxqZX4wNDd8S29jZXZqZX4wNDh8S29tZW5+MDQ5fEtvbWVuZGF+MTY0fEtvcGVyfjA1MHxLb2RhbmpldmljYSBuYSBLcmtpfjE5N3xLb3N0ZWx+MTY1fEtvemplfjA1MXxLcmFuan4wNTJ8S3Jhbmpza2EgR29yYX4wNTN8S3JpemV2Y2l+MTY2fEtyc2tvfjA1NHxLdW5nb3RhfjA1NXxLdXptYX4wNTZ8TGFza29+MDU3fExlbmFydH4wNTh8TGVuZGF2YX4wNTl8TGl0aWphfjA2OHxManVibGphbmF+MDYxfExqdWJub34wNjJ8TGp1dG9tZXJ+MDYzfExvZy1EcmFnb21lcn4yMDh8TG9nYXRlY34wNjR8TG9za2EgRG9saW5hfjA2NXxMb3NraSBQb3Rva34wNjZ8TG92cmVuYyBuYSBQb2hvcmp1fjE2N3xMdWtvdmljYX4wNjh8THVjZX4wNjd8TWFqc3Blcmt+MDY5fE1ha29sZX4xOTh8TWFyaWJvcn4wNzB8TWFya292Y2l+MTY4fE1lZHZvZGV+MDcxfE1lbmdlc34wNzJ8TWV0bGlrYX4wNzN8TWV6aWNhfjA3NHxNaWtsYXZ6IG5hIERyYXZza2VtIFBvbGp1fjE2OXxNaXJlbi1Lb3N0YW5qZXZpY2F+MDc1fE1pcm5hfjIxMnxNaXJuYSBQZWN+MTcwfE1pc2xpbmphfjA3NnxNb2tyb25vZy1UcmViZWxub34xOTl8TW9yYXZjZX4wNzd8TW9yYXZza2UgVG9wbGljZX4wNzh8TW96aXJqZX4wNzl8TXVyc2thIFNvYm90YX4wODB8TmFrbG9+MDgyfE5hemFyamV+MDgzfE5vdmEgR29yaWNhfjA4NHxOb3ZvIE1lc3RvfjA4NXxPZHJhbmNpfjA4NnxPcm1ven4wODd8T3NpbG5pY2F+MDg4fFBlc25pY2F+MDg5fFBpcmFufjA5MHxQaXZrYX4wOTF8UG9kY2V0cnRla34wOTJ8UG9kbGVobmlrfjE3MnxQb2R2ZWxrYX4wOTN8UG9samNhbmV+MjAwfFBvc3Rvam5hfjA5NHxQcmVib2xkfjE3NHxQcmVkZHZvcn4wOTV8UHJldmFsamV+MTc1fFB0dWp+MDk2fFJhY2UtRnJhbX4wOTh8UmFkZWNlfjA5OXxSYWRlbmNpfjEwMHxSYWRsamUgb2IgRHJhdml+MTAxfFJhZG92bGppY2F+MTAyfFJhdm5lIG5hIEtvcm9za2VtfjEwM3xSYXprcml6amV+MTc2fFJlY2ljYSBvYiBTYXZpbmppfjIwOXxSZW5jZS1Wb2dyc2tvfjIwMXxSaWJuaWNhfjEwNHxSaWJuaWNhIG5hIFBvYm9yaXV+MTc3fFJvZ2Fza2EgU2xhdGluYX4xMDZ8Um9nYXNvdmNpfjEwNXxSb2dhdGVjfjEwN3xSdXNlfjEwOHxTYWxvdmNpfjAzM3xTZWxuaWNhIG9iIERyYXZpfjE3OHxTZW1pY34xMDl8U2VtcGV0ZXItVnJ0b2piYX4xODN8U2VuY3VyfjExN3xTZW50aWxqfjExOHxTZW50amVybmVqfjExOXxTZW50anVyfjEyMHxTZW50cnVwZXJ0fjIxMXxTZXZuaWNhfjExMHxTZXphbmF+MTExfFNrb2NqYW5+MTIxfFNrb2ZqYSBMb2thfjEyMnxTa29mbGppY2F+MTIzfFNsb3ZlbmogR3JhZGVjfjExMnxTbG92ZW5za2EgQmlzdHJpY2F+MTEzfFNsb3ZlbnNrZSBLb25qaWNlfjExNHxTbWFyamUgcHJpIGVsc2FofjEyNHxTbWFyamVza2UgVG9wbGljZX4yMDZ8U21hcnRubyBvYiBQYWtpfjEyNXxTbWFydG5vIHByaSBMaXRpaml+MTk0fFNvZHJhemljYX4xNzl8U29sY2F2YX4xODB8U29zdGFuan4xMjZ8U3JlZGlzY2Ugb2IgRHJhdml+MjAyfFN0YXJzZX4xMTV8U3RvcmV+MTI3fFN0cmF6YX4yMDN8U3ZldGEgQW5hfjE4MXxTdmV0YSBUcm9qaWNhIHYgU2xvdmVuc2tpaCBHb3JpY2FofjIwNHxTdmV0YSBBbmRyYXogdiBTbG92ZW5za2loIEdvcmljYWh+MTgyfFN2ZXRpIEp1cmlqfjExNnxTdmV0aSBKdXJpaiB2IFNsb3ZlbnNraWggR29yaWNhaH4yMTB8U3ZldGkgVG9tYXp+MjA1fFRhYm9yfjE4NHxUaXNpbmF+MTI4fFRvbG1pbn4xMjh8VHJib3ZsamV+MTI5fFRyZWJuamV+MTMwfFRybm92c2thIFZhc34xODV8VHJ6aW5+MTg2fFRyemljfjEzMXxUdXJuaXNjZX4xMzJ8VmVsZW5qZX4xMzN8VmVsaWthIFBvbGFuYX4xODd8VmVsaWtlIExhc2NlfjEzNHxWZXJ6ZWp+MTg4fFZpZGVtfjEzNXxWaXBhdmF+MTM2fFZpdGFuamV+MTM3fFZvZGljZX4xMzh8Vm9qbmlrfjEzOXxWcmFuc2tvfjE4OXxWcmhuaWthfjE0MHxWdXplbmljYX4xNDF8WmFnb3JqZSBvYiBTYXZpfjE0MnxaYXZyY34xNDN8WnJlY2V+MTQ0fFphbGVjfjE5MHxaZWxlem5pa2l+MTQ2fFpldGFsZX4xOTF8WmlyaX4xNDd8Wmlyb3ZuaWNhfjE5MnxadXplbWJlcmt+MTkzXCJdLCBbXCJTb2xvbW9uIElzbGFuZHNcIiwgXCJTQlwiLCBcIkNlbnRyYWx+Q0V8Q2hvaXNldWx+Q0h8R3VhZGFsY2FuYWx+R1V8SG9uaWFyYX5DVHxJc2FiZWx+SVN8TWFraXJhLVVsYXdhfk1LfE1hbGFpdGF+TUx8UmVubmVsbCBhbmQgQmVsbG9uYX5SQnxUZW1vdHV+VEV8V2VzdGVybn5XRVwiXSwgW1wiU29tYWxpYVwiLCBcIlNPXCIsIFwiQXdkYWx+QVd8QmFrb29sfkJLfEJhbmFhZGlyfkJOfEJhcml+QlJ8QmF5fkJZfEdhbGd1ZHV1ZH5HQXxHZWRvfkdFfEhpaXJhYW5+SEl8SnViYmFkYSBEaGV4ZX5KRHxKdWJiYWRhIEhvb3NlfkpIfE11ZHVnfk1VfE51Z2FhbH5OVXxTYW5hYWd+U0F8U2hhYmVlbGxhaGEgRGhleGV+U0R8U2hhYmVlbGxhaGEgSG9vc2V+U0h8U29vbH5TT3xUb2dkaGVlcn5UT3xXb3Fvb3lpIEdhbGJlZWR+V09cIl0sIFtcIlNvdXRoIEFmcmljYVwiLCBcIlpBXCIsIFwiRWFzdGVybiBDYXBlfkVDfEZyZWUgU3RhdGV+RlN8R2F1dGVuZ35HVHxLd2FadWx1LU5hdGFsfk5MfExpbXBvcG9+TFB8TXB1bWFsYW5nYX5NUHxOb3J0aGVybiBDYXBlfk5DfE5vcnRoIFdlc3R+Tld8V2VzdGVybiBDYXBlfldDXCJdLCBbXCJTb3V0aCBHZW9yZ2lhIGFuZCBTb3V0aCBTYW5kd2ljaCBJc2xhbmRzXCIsIFwiR1NcIiwgXCJCaXJkIElzbGFuZHxCcmlzdG9sIElzbGFuZHxDbGVya2UgUm9ja3N8TW9udGFndSBJc2xhbmR8U2F1bmRlcnMgSXNsYW5kfFNvdXRoIEdlb3JnaWF8U291dGhlcm4gVGh1bGV8VHJhdmVyc2F5IElzbGFuZHNcIl0sIFtcIlNvdXRoIFN1ZGFuXCIsIFwiU1NcIiwgXCJDZW50cmFsIEVxdWF0b3JpYX5DRXxFYXN0ZXJuIEVxdWF0b3JpYX5FRXxKb25nbGVpfkpHfExha2VzfkxLfE5vcnRoZXJuIEJhaHIgZWwgR2hhemFsfkJOfFVuaXR5flVZfFVwcGVyIE5pbGV+TlV8V2FycmFwfldSfFdlc3Rlcm4gQmFociBlbCBHaGF6YWx+Qld8V2VzdGVybiBFcXVhdG9yaWF+RVdcIl0sIFtcIlNwYWluXCIsIFwiRVNcIiwgXCJBbGJhY2V0ZX5DTXxBbGljYW50ZX5WQ3xBbG1lcsOtYX5BTnxBcmFiYS/DgWxhdmF+Vkl8QXN0dXJpYXN+T3zDgXZpbGF+QVZ8QmFkYWpven5CQXxCYXJjZWxvbmF+QnxCaXprYWlhfkJJfEJ1cmdvc35CVXxDw6FjZXJlc35DQ3xDw6FkaXp+Q0F8Q2FudGFicmlhflN8Q2FzdGVsbMOzbn5DU3xDdWV0YX5DVXxDaXVkYWQgUmVhbH5DUnxDw7NyZG9iYX5DT3xBIENvcnXDsWF+Q3xDdWVuY2F+Q1V8R2lwdXprb2F+U1N8R2lyb25hfkdJfEdyYW5hZGF+R1J8R3VhZGFsYWphcmF+R1V8SHVlbHZhfkh8SHVlc2NhfkhVfElsbGVzIEJhbGVhcnN+UE18SmHDqW5+SnxMZcOzbn5MRXxMbGVpZGF+THxMdWdvfkxVfE1hZHJpZH5NfE3DoWxhZ2F+TUF8TWVsaWxsYX5NTHxNdXJjaWF+TVV8TmF2YXJyZX5OQXxPdXJlbnNlfk9SfFBhbGVuY2lhflB8TGFzIFBhbG1hc35HQ3xQb250ZXZlZHJhflBPfExhIFJpb2phfkxPfFNhbGFtYW5jYX5TQXxTYW50YSBDcnV6IGRlIFRlbmVyaWZlflRGfFNlZ292aWF+U0d8U2V2aWxsYX5TRXxTb3JpYX5TT3xUYXJyYWdvbmF+VHxUZXJ1ZWx+VEV8VG9sZWRvflRPfFZhbGVuY2lhflZ8VmFsbGFkb2xpZH5WQXxaYW1vcmF+WkF8WmFyYWdvemF+WlwiXSwgW1wiU3JpIExhbmthXCIsIFwiTEtcIiwgXCJCYXNuYWhpcmF+MXxEYWt1bnV+M3xNYWRoeWFtYX4yfE5hZWdlbmFoaXJhfjV8U2FiYXJhZ2FtdXdhfjl8VXR1cnV+NHxVdHVydW1hZWRhfjd8VmF5YW1iYX42fFV2YX44XCJdLCBbXCJTdWRhblwiLCBcIlNEXCIsIFwiQWwgQmFociBhbCBBaG1hcn5SU3xBbCBKYXppcmFofkdafEFsIEtoYXJ0dW1+S0h8QWwgUWFkYXJpZn5HRHxBbiBOaWwgYWwgQWJ5YWR+Tld8QW4gTmlsIGFsIEF6cmFxfk5CfEFzaCBTaGFtYWxpeWFofk5PfEdoYXJiIERhcmZ1cn5EV3xHaGFyYiBLdXJkdWZhbn5HS3xKYW51YiBEYXJmdXJ+RFN8SmFudWIgS3VyZHVmYW5+S1N8S2Fzc2FsYX5LQXxOYWhyIGFuIE5pbH5OUnxTaGFtYWwgRGFyZnVyfkROfFNoYXJxIERhcmZ1cn5ERXxTaGlhbWFsIEt1cmR1ZmFufktOfFNpbm5hcn5TSXxXYXNhdCBEYXJmdXIgWmFsaW5qYXl+RENcIl0sIFtcIlN1cmluYW1lXCIsIFwiU1JcIiwgXCJCcm9rb3BvbmRvfkJSfENvbW1ld2lqbmV+Q018Q29yb25pZX5DUnxNYXJvd2lqbmV+TUF8Tmlja2VyaWV+Tkl8UGFyYX5QUnxQYXJhbWFyaWJvflBNfFNhcmFtYWNjYX5TQXxTaXBhbGl3aW5pflNJfFdhbmljYX5XQVwiXSwgW1wiU3dhemlsYW5kXCIsIFwiU1pcIiwgXCJIaG9oaG9+SEh8THVib21ib35MVXxNYW56aW5pfk1BfFNoaXNlbHdlbml+U0hcIl0sIFtcIlN3ZWRlblwiLCBcIlNFXCIsIFwiQmxla2luZ2V+S3xEYWxhcm5hc35XfEdvdGxhbmRzflh8R2F2bGVib3Jnc35JfEhhbGxhbmRzfk58SmFtdGxhbmRzflp8Sm9ua29waW5nc35GfEthbG1hcn5IfEtyb25vYmVyZ3N+R3xOb3JyYm90dGVuc35CRHxPcmVicm9+VHxPc3RlcmdvdGxhbmRzfkV8U2thbmV+TXxTb2Rlcm1hbmxhbmRzfkR8U3RvY2tob2xtfkFCfFZhcm1sYW5kc35TfFZhc3RlcmJvdHRlbnN+QUN8VmFzdGVybm9ycmxhbmRzfll8VmFzdG1hbmxhbmRzflV8VmFzdHJhIEdvdGFsYW5kc35PXCJdLCBbXCJTd2l0emVybGFuZFwiLCBcIkNIXCIsIFwiQWFyZ2F1fkFHfEFwcGVuemVsbCBBdXNzZXJyaG9kZW5+QVJ8QXBwZW56ZWxsIElubmVyaG9kZW5+QUl8QmFzZWwtTGFuZHNjaGFmdH5CTHxCYXNlbC1TdGFkdH5CU3xCZXJufkJFfEZyaWJvdXJnfkZSfEdlbsOodmV+R0V8R2xhcnVzfkdMfEdyYXViw7xuZGVufkdSfEp1cmF+SlV8THV6ZXJufkxVfE5ldWNow6J0ZWx+TkV8Tmlkd2FsZGVufk5XfE9id2FsZGVufk9XfFNhbmt0IEdhbGxlbn5TR3xTY2hhZmZoYXVzZW5+U0h8U2Nod3l6flNafFNvbG90aHVybn5TT3xUaHVyZ2F1flRHfFRpY2lub35USXxVcml+VVJ8VmFsYWlzflZTfFZhdWR+VkR8WnVnflpHfFrDvHJpY2h+WkhcIl0sIFtcIlN5cmlhbiBBcmFiIFJlcHVibGljXCIsIFwiU1lcIiwgXCJBbCBIYXNha2FofkhBfEFsIExhZGhpcWl5YWh+TEF8QWwgUXVuYXl0aXJhaH5RVXxBciBSYXFxYWh+UkF8QXMgU3V3YXlkYSd+U1V8RGFyJ2F+RFJ8RGF5ciBheiBaYXdyfkRZfERpbWFzaHF+REl8SGFsYWJ+SEx8SGFtYWh+SE18SGltc35ISXxJZGxpYn5JRHxSaWYgRGltYXNocX5SRHxUYXJ0dXN+VEFcIl0sIFtcIlRhaXdhblwiLCBcIlRXXCIsIFwiQ2hhbmctaHVhfkNIQXxDaGlhLWl+Q1lRfEhzaW4tY2h1fkhTUXxIdWEtbGllbn5IVUF8S2FvLWhzaXVuZ35LSEh8S2VlbHVuZ35LRUV8S2lubWVufktJTnxMaWVuY2hpYW5nfkxJRXxNaWFvLWxpfk1JQXxOYW4tdCdvdX5OQU58UCdlbmctaHV+UEVOfE5ldyBUYWlwZWl+TldUfFAnaW5nLWNodW5nflBJRnxUJ2FpLWNodW5nflRYR3xUJ2FpLW5hbn5UTk58VCdhaS1wZWl+VFBFfFQnYWktdHVuZ35UVFR8VCdhby15dWFuflRBT3xZaS1sYW5+SUxBfFl1bi1saW5+WVVOXCJdLCBbXCJUYWppa2lzdGFuXCIsIFwiVEpcIiwgXCJEdXNoYW5iZX5EVXxLxa1oaXN0b25pIEJhZGFraHNob25+R0J8S2hhdGxvbn5LVHxTdWdoZH5TVVwiXSwgW1wiVGFuemFuaWEsIFVuaXRlZCBSZXB1YmxpYyBvZlwiLCBcIlRaXCIsIFwiQXJ1c2hhfjAxfENvYXN0fjE5fERhciBlcyBTYWxhYW1+MDJ8RG9kb21hfjAzfElyaW5nYX4wNHxLYWdlcmF+MDV8S2lnb21hfjA4fEtpbGltYW5qYXJvfjA5fExpbmRpfjEyfE1hbnlhcmF+MjZ8TWFyYX4xM3xNYmV5YX4xNHxNb3JvZ29yb34xNnxNdHdhcmF+MTd8TXdhbnphfjE4fFBlbWJhIE5vcnRofjA2fFBlbWJhIFNvdXRofjEwfFJ1a3dhfjIwfFJ1dnVtYX4yMXxTaGlueWFuZ2F+MjJ8U2luZ2lkYX4yM3xUYWJvcmF+MjR8VGFuZ2F+MjV8WmFuemliYXIgTm9ydGh+MDd8WmFuemliYXIgQ2VudHJhbC9Tb3V0aH4xMXxaYW56aWJhciBVcmJhbi9XZXN0fjE1XCJdLCBbXCJUaGFpbGFuZFwiLCBcIlRIXCIsIFwiQW1uYXQgQ2hhcm9lbn4zN3xBbmcgVGhvbmd+MTV8QnVlbmcgS2FufjM4fEJ1cmkgUmFtfjMxfENoYWNob2VuZ3Nhb34yNHxDaGFpIE5hdH4xOHxDaGFpeWFwaHVtfjM2fENoYW50aGFidXJpfjIyfENoaWFuZyBNYWl+NTB8Q2hpYW5nIFJhaX41N3xDaG9uIEJ1cml+MjB8Q2h1bXBob25+ODZ8S2FsYXNpbn40NnxLYW1waGFlbmcgUGhldH42MnxLYW5jaGFuYWJ1cml+NzF8S2hvbiBLYWVufjQwfEtyYWJpfjgxfEtydW5nIFRoZXAgTWFoYW5ha2hvbiAoQmFuZ2tvayl+MTB8TGFtcGFuZ341MnxMYW1waHVufjUxfExvZWl+NDJ8TG9wIEJ1cml+MTZ8TWFlIEhvbmcgU29ufjU4fE1haGEgU2FyYWtoYW1+NDR8TXVrZGFoYW5+NDl8TmFraG9uIE5heW9rfjI2fE5ha2hvbiBQaGF0aG9tfjczfE5ha2hvbiBQaGFub21+NDh8TmFraG9uIFJhdGNoYXNpbWF+MzB8TmFraG9uIFNhd2FufjYwfE5ha2hvbiBTaSBUaGFtbWFyYXR+ODB8TmFufjU1fE5hcmF0aGl3YXR+OTZ8Tm9uZyBCdWEgTGFtIFBodX4zOXxOb25nIEtoYWl+NDN8Tm9udGhhYnVyaX4xMnxQYXRodW0gVGhhbml+MTN8UGF0dGFuaX45NHxQaGFuZ25nYX44MnxQaGF0dGhhbHVuZ345M3xQaGF5YW9+NTZ8UGhldGNoYWJ1bn43NnxQaGV0Y2hhYnVyaX43NnxQaGljaGl0fjY2fFBoaXRzYW51bG9rfjY1fFBocmEgTmFraG9uIFNpIEF5dXR0aGF5YX4xNHxQaHJhZX41NHxQaHVrZXR+ODN8UHJhY2hpbiBCdXJpfjI1fFByYWNodWFwIEtoaXJpIEtoYW5+Nzd8UmFub25nfjg1fFJhdGNoYWJ1cml+NzB8UmF5b25nfjIxfFJvaSBFdH40NXxTYSBLYWVvfjI3fFNha29uIE5ha2hvbn40N3xTYW11dCBQcmFrYW5+MTF8U2FtdXQgU2FraG9ufjc0fFNhbXV0IFNvbmdraHJhbX43NXxTYXJhYnVyaX4xOXxTYXR1bn45MXxTaW5nIEJ1cml+MTd8U2kgU2Ega2V0fjMzfFNvbmdraGxhfjkwfFN1a2hvdGhhaX42NHxTdXBoYW4gQnVyaX43MnxTdXJhdCBUaGFuaX44NHxTdXJpbn4zMnxUYWt+NjN8VHJhbmd+OTJ8VHJhdH4yM3xVYm9uIFJhdGNoYXRoYW5pfjM0fFVkb24gVGhhbml+NDF8VXRoYWkgVGhhbml+NjF8VXR0YXJhZGl0fjUzfFlhbGF+OTV8WWFzb3Rob25+MzVcIl0sIFtcIlRpbW9yLUxlc3RlXCIsIFwiVExcIiwgXCJBaWxldX5BTHxBaW5hcm9+QU58QmF1Y2F1fkJBfEJvYm9uYXJvfkJPfENvdmEgTGltYX5DT3xEaWxpfkRJfEVybWVyYX5FUnxMYXV0ZW1+TEF8TGlxdWljYX5MSXxNYW5hdHV0b35NVHxNYW51ZmFoaX5NRnxPZWN1c3Npfk9FfFZpcXVlcXVlflZJXCJdLCBbXCJUb2dvXCIsIFwiVEdcIiwgXCJDZW50cmV+Q3xLYXJhfkt8TWFyaXRpbWV+TXxQbGF0ZWF1eH5QfFNhdmFubmVzflNcIl0sIFtcIlRva2VsYXVcIiwgXCJUS1wiLCBcIkF0YWZ1fEZha2FvZm98TnVrdW5vbnVcIl0sIFtcIlRvbmdhXCIsIFwiVE9cIiwgXCInRXVhfjAxfEhhJ2FwYWl+MDJ8Tml1YXN+MDN8VG9uZ2F0YXB1fjA0fFZhdmEndX4wNVwiXSwgW1wiVHJpbmlkYWQgYW5kIFRvYmFnb1wiLCBcIlRUXCIsIFwiQXJpbWF+QVJJfENoYWd1YW5hc35DSEF8Q291dmEtVGFiYXF1aXRlLVRhbHBhcm9+Q1RUfERpZWZvIE1hcnRpbn5ETU58TWF5YXJvLVJpbyBDbGFyb35NUkN8UGVuYWwtRGViZX5QRUR8UG9pbnQgRm9ydGluflBURnxQb3J0LW9mLVNwYWluflBPU3xQcmluY2VzIFRvd25+UFJUfFNhbiBGZXJuYW5kb35TRk98U2FuIEp1YW4tTGF2ZW50aWxsZX5TSkx8U2FuZ3JlIEdyYW5kZX5TR0V8U2lwYXJpYX5TSVB8VG9iYWdvflRPQnxUdW5hcHVuYS1QaWFyY29+VFVQXCJdLCBbXCJUdW5pc2lhXCIsIFwiVE5cIiwgXCJBcmlhbmF+MTJ8QmVqYX4zMXxCZW4gQXJvdXN+MTN8Qml6ZXJ0ZX4yM3xHYWJlc344MXxHYWZzYX43MXxKZW5kb3ViYX4zMnxLYWlyb3Vhbn40MXxLYXNzZXJpbmV+NDJ8S2ViaWxpfjczfEtlZn4zM3xNYWhkaWF+NTN8TWVkZW5pbmV+ODJ8TW9uYXN0aXJ+NTJ8TmFiZXVsfjIxfFNmYXh+NjF8U2lkaSBCb3V6aWR+NDN8U2lsaWFuYX4zNHxTb3Vzc2V+NTF8VGF0YW91aW5lfjgzfFRvemV1cn43MnxUdW5pc34xMXxaYWdob3Vhbn4yMlwiXSwgW1wiVHVya2V5XCIsIFwiVFJcIiwgXCJBZGFuYX4wMXxBZGl5YW1hbn4wMnxBZnlvbmthcmFoaXNhcn4wM3xBZ3JpfjA0fEFrc2FyYXl+Njh8QW1hc3lhfjA1fEFua2FyYX4wNnxBbnRhbHlhfjA3fEFyZGFoYW5+NzV8QXJ0dmlufjA4fEF5ZGlufjA5fEJhbGlrZXNpcn4xMHxCYXJ0aW5+NzR8QmF0bWFufjcyfEJheWJ1cnR+Njl8QmlsZWNpa34xMXxCaW5nb2x+MTJ8Qml0bGlzfjEzfEJvbHV+MTR8QnVyZHVyfjE1fEJ1cnNhfjE2fENhbmFra2FsZX4xN3xDYW5raXJpfjE4fENvcnVtfjE5fERlbml6bGl+MjB8RGl5YXJiYWtpcn4yMXxEdXpjZX44MXxFZGlybmV+MjJ8RWxhemlnfjIzfEVyemluY2FufjI0fEVyenVydW1+MjV8RXNraXNlaGlyfjI2fEdhemlhbnRlcH4yN3xHaXJlc3VufjI4fEd1bXVzaGFuZX4yOXxIYWtrYXJpfjMwfEhhdGF5fjMxfElnZGlyfjc2fElzcGFydGF+MzJ8SXN0YW5idWx+MzR8SXptaXJ+MzV8S2FocmFtYW5tYXJhc340NnxLYXJhYnVrfjc4fEthcmFtYW5+NzB8S2Fyc34zNnxLYXN0YW1vbnV+Mzd8S2F5c2VyaX4zOHxLaWxpc343OXxLaXJpa2thbGV+NzF8S2lya2xhcmVsaX4zOXxLaXJzZWhpcn40MHxLb2NhZWxpfjQxfEtvbnlhfjQyfEt1dGFoeWF+NDN8TWFsYXR5YX40NHxNYW5pc2F+NDV8TWFyZGlufjQ3fE1lcnNpbn4zM3xNdWdsYX40OHxNdXN+NDl8TmV2c2VoaXJ+NTB8TmlnZGV+NTF8T3JkdX41MnxPc21hbml5ZX44MHxSaXplfjUzfFNha2FyeWF+NTR8U2Ftc3VufjU1fFNhbmxpdXJmYX42M3xTaWlydH41NnxTaW5vcH41N3xTaXJuYWt+NzN8U2l2YXN+NTh8VGVraXJkYWd+NTl8VG9rYXR+NjB8VHJhYnpvbn42MXxUdW5jZWxpfjYyfFVzYWt+NjR8VmFufjY1fFlhbG92YX43N3xZb3pnYXR+NjZ8Wm9uZ3VsZGFrfjY3XCJdLCBbXCJUdXJrbWVuaXN0YW5cIiwgXCJUTVwiLCBcIkFoYWx+QXxBc2dhYmF0flN8QmFsa2FufkJ8RGFzaG9ndXp+RHxMZWJhcH5MfE1hcnl+TVwiXSwgW1wiVHVya3MgYW5kIENhaWNvcyBJc2xhbmRzXCIsIFwiVENcIiwgXCJUdXJrcyBhbmQgQ2FpY29zIElzbGFuZHNcIl0sIFtcIlR1dmFsdVwiLCBcIlRWXCIsIFwiRnVuYWZ1dGl+RlVOfE5hbnVtYW5nYX5OTUd8TmFudW1lYX5OTUF8Tml1dGFvfk5JVHxOdWl+TlVJfE51a3VmZXRhdX5OS0Z8TnVrdWxhZWxhZX5OS0x8VmFpdHVwdX5WQVVcIl0sIFtcIlVnYW5kYVwiLCBcIlVHXCIsIFwiQWJpbX4zMTd8QWRqdW1hbml+MzAxfEFtb2xhdGFyfjMxNHxBbXVyaWF+MjE2fEFtdXJ1fjMxOXxBcGFjfjMwMnxBcnVhfjMwM3xCdWRha2F+MjE3fEJ1ZHVkYX4yMjN8QnVnaXJpfjIwMXxCdWtlZGVhfjIyNHxCdWt3YX4yMTh8QnVsaWlzYX40MTl8QnVuZGlidWd5b340MDF8QnVzaGVueWl+NDAyfEJ1c2lhfjIwMnxCdXRhbGVqYX4yMTl8RG9rb2xvfjMxOHxHdWx1fjMwNHxIb2ltYX40MDN8SWJhbmRhfjQxNnxJZ2FuZ2F+MjAzfElzaW5naXJvfjQxN3xKaW5qYX4yMDR8S2FhYm9uZ34zMTV8S2FiYWxlfjQwNHxLYWJhcm9sZX40MDV8S2FiZXJhbWFpZG9+MjEzfEthbGFuZ2FsYX4xMDF8S2FsaXJvfjIyMHxLYW1wYWxhfjEwMnxLYW11bGl+MjA1fEthbXdlbmdlfjQxM3xLYW51bmd1fjQxNHxLYXBjaG9yd2F+MjA2fEthc2VzZX40MDZ8S2F0YWt3aX4yMDd8S2F5dW5nYX4xMTJ8S2liYWFsZX40MDd8S2lib2dhfjEwM3xLaXJ1aHVyYX40MTh8S2lzb3JvfjQwOHxLaXRndW1+MzA1fEtvYm9rb34zMTZ8S290aWRvfjMwNnxLdW1pfjIwOHxLeWVuam9qb340MTV8TGlyYX4zMDd8THV3ZXJvfjEwNHxMeWFudG9uZGV+MTE2fE1hbmFmd2F+MjIxfE1hcmFjaGF+MzIwfE1hc2FrYX4xMDV8TWFzaW5kaX40MDl8TWF5dWdlfjIxNHxNYmFsZX4yMDl8TWJhcmFyYX40MTB8TWl0eWFuYX4xMTR8TW9yb3RvfjMwOHxNb3lvfjMwOXxNcGlnaX4xMDZ8TXViZW5kZX4xMDd8TXVrb25vfjEwOHxOYWthcGlyaXBpcml0fjMxMXxOYWthc2VrZX4xMTV8TmFrYXNvbmdvbGF+MTA5fE5hbXV0dW1iYX4yMjJ8TmViYml+MzEwfE50dW5nYW1vfjQxMXxPeWFtfjMyMXxQYWRlcn4zMTJ8UGFsbGlzYX4yMTB8UmFrYWl+MTEwfFJ1a3VuZ2lyaX40MTJ8U2VtYmFidWxlfjExMXxTaXJvbmtvfjIxNXxTb3JvdGl+MjExfFRvcm9yb34yMTJ8V2FraXNvfjExM3xZdW1iZX4zMTNcIl0sIFtcIlVrcmFpbmVcIiwgXCJVQVwiLCBcIkNoZXJrYXN5fjcxfENoZXJuaWhpdn43NHxDaGVybml2dHNpfjc3fERuaXByb3BldHJvdnNrfjEyfERvbmV0c2t+MTR8SXZhbm8tRnJhbmtpdnNrfjI2fEtoYXJraXZ+NjN8S2hlcnNvbn42NXxLaG1lbG55dHNreWl+Njh8S2lldn4zMnxLaXJvdm9ocmFkfjM1fEx1aGFuc2t+MDl8THZpdn40NnxNeWtvbGFpdn40OHxPZGVzc2F+NTF8UG9sdGF2YX41M3xSaXZuZX41NnxTdW15fjU5fFRlcm5vcGlsfjYxfFZpbm55dHNpYX4wNXxWb2x5bn4wN3xaYWthcnBhdHRpYX4yMXxaYXBvcml6aGlhfjIzfFpoeXRvbXlyfjE4fEF2dG9ub21uYSBSZXNwdWJsaWthIEtyeW1+NDN8S3nDr3Z+MzB8U2V2YXN0b3BvbH40MFwiXSwgW1wiVW5pdGVkIEFyYWIgRW1pcmF0ZXNcIiwgXCJBRVwiLCBcIkFidSBEaGFiaX5BWnxBam1hbn5BSnxEdWJhaX5EVXxGdWphaXJhaH5GVXxSYXMgYWwgS2hhaW1haH5SS3xTaGFyamFoflNIfFVtbSBBbCBRdXdhaW5+VVFcIl0sIFtcIlVuaXRlZCBLaW5nZG9tXCIsIFwiR0JcIiwgXCJBdm9ufkFWTnxCZWRmb3Jkc2hpcmV+QkRGfEJlcmtzaGlyZX5CUkt8QnJpc3RvbCwgQ2l0eSBvZn5DT0J8QnVja2luZ2hhbXNoaXJlfkJLTXxDYW1icmlkZ2VzaGlyZX5DQU18Q2hlc2hpcmV+Q0hTfENsZXZlbGFuZH5DTFZ8Q29ybndhbGx+Q09OfEN1bWJyaWF+Q01BfERlcmJ5c2hpcmV+REJZfERldm9ufkRFVnxEb3JzZXR+RE9SfER1cmhhbX5EVVJ8RWFzdCBTdXNzZXh+U1hFfEVzc2V4fkVTU3xHbG91Y2VzdGVyc2hpcmV+R0xTfEdyZWF0ZXIgTG9uZG9ufkxORHxHcmVhdGVyIE1hbmNoZXN0ZXJ+R1RNfEhhbXBzaGlyZSAoQ291bnR5IG9mIFNvdXRoYW1wdG9uKX5IQU18SGVyZWZvcmQgYW5kIFdvcmNlc3Rlcn5IV1J8SGVyZWZvcmRzaGlyZX5IRUZ8SGVydGZvcmRzaGlyZX5IUlR8SXNsZSBvZiBXaWdodH5JT1d8S2VudH5LRU58TGFuY2FzaGlyZX5MQU58TGVpY2VzdGVyc2hpcmV+TEVJfExpbmNvbG5zaGlyZX5MSU58TG9uZG9ufkxETnxNZXJzZXlzaWRlfk1TWXxNaWRkbGVzZXh+TURYfE5vcmZvbGt+TkZLfE5vcnRoYW1wdG9uc2hpcmV+TlRIfE5vcnRodW1iZXJsYW5kfk5CTHxOb3J0aCBIdW1iZXJzaWRlfk5ITXxOb3J0aCBZb3Jrc2hpcmV+TllLfE5vdHRpbmdoYW1zaGlyZX5OVFR8T3hmb3Jkc2hpcmV+T1hGfFJ1dGxhbmR+UlVUfFNocm9wc2hpcmV+U0FMfFNvbWVyc2V0flNPTXxTb3V0aCBIdW1iZXJzaWRlflNITXxTb3V0aCBZb3Jrc2hpcmV+U1lLfFN0YWZmb3Jkc2hpcmV+U1RTfFN1ZmZvbGt+U0ZLfFN1cnJleX5TUll8VHluZSBhbmQgV2Vhcn5UV1J8V2Fyd2lja3NoaXJlfldBUnxXZXN0IE1pZGxhbmRzfldNRHxXZXN0IFN1c3NleH5TWFd8V2VzdCBZb3Jrc2hpcmV+V1lLfFdpbHRzaGlyZX5XSUx8V29yY2VzdGVyc2hpcmV+V09SfEFudHJpbX5BTlR8QXJtYWdofkFSTXxCZWxmYXN0LCBDaXR5IG9mfkJMRnxEb3dufkRPV3xGZXJtYW5hZ2h+RkVSfExvbmRvbmRlcnJ5fkxEWXxEZXJyeSwgQ2l0eSBvZn5EUll8VHlyb25lflRZUnxBYmVyZGVlbiwgQ2l0eSBvZn5BTnxBYmVyZGVlbnNoaXJlfkFCRHxBbmd1cyAoRm9yZmFyc2hpcmUpfkFOU3xBcmd5bGx+QUdCfEF5cnNoaXJlfkFSR3xCYW5mZnNoaXJlfkJBTnxCZXJ3aWNrc2hpcmV+QkVXfEJ1dGV+QlVUfENhaXRobmVzc35DQUl8Q2xhY2ttYW5uYW5zaGlyZX5DTEt8Q3JvbWFydHlzaGlyZX5DT0N8RHVtZnJpZXNzaGlyZX5ERlN8RHVuYmFydG9uc2hpcmUgKER1bWJhcnRvbil+RE5CfER1bmRlZSwgQ2l0eSBvZn5ERHxFYXN0IExvdGhpYW4gKEhhZGRpbmd0b25zaGlyZSl+RUxOfEVkaW5idXJnaCwgQ2l0eSBvZn5FQnxGaWZlfkZJRnxHbGFzZ293LCBDaXR5IG9mfkdMQXxJbnZlcm5lc3Mtc2hpcmV+SU5WfEtpbmNhcmRpbmVzaGlyZX5LQ0R8S2lucm9zcy1zaGlyZX5LUlN8S2lya2N1ZGJyaWdodHNoaXJlfktLRHxMYW5hcmtzaGlyZX5MS1N8TWlkbG90aGlhbiAoQ291bnR5IG9mIEVkaW5idXJnaCl+TUxOfE1vcmF5IChFbGdpbnNoaXJlKX5NT1J8TmFpcm5zaGlyZX5OQUl8T3JrbmV5fk9LSXxQZWVibGVzc2hpcmV+UEVFfFBlcnRoc2hpcmV+UEVSfFJlbmZyZXdzaGlyZX5SRld8Um9zcyBhbmQgQ3JvbWFydHl+Uk9DfFJvc3Mtc2hpcmV+Uk9TfFJveGJ1cmdoc2hpcmV+Uk9YfFNlbGtpcmtzaGlyZX5TRUx8U2hldGxhbmQgKFpldGxhbmQpflNISXxTdGlybGluZ3NoaXJlflNUSXxTdXRoZXJsYW5kflNVVHxXZXN0IExvdGhpYW4gKExpbmxpdGhnb3dzaGlyZSl+V0xOfFdpZ3Rvd25zaGlyZX5XSUd8Q2x3eWR+Q1dEfER5ZmVkfkRGRHxHd2VudH5HTlR8R3d5bmVkZH5HV058TWlkIEdsYW1vcmdhbn5NR018UG93eXN+UE9XfFNvdXRoIEdsYW1vcmdhbn5TR018V2VzdCBHbGFtb3JnYW5+V0dNXCJdLCBbXCJVbml0ZWQgU3RhdGVzXCIsIFwiVVNcIiwgXCJBbGFiYW1hfkFMfEFsYXNrYX5BS3xBbWVyaWNhbiBTYW1vYX5BU3xBcml6b25hfkFafEFya2Fuc2FzfkFSfENhbGlmb3JuaWF+Q0F8Q29sb3JhZG9+Q098Q29ubmVjdGljdXR+Q1R8RGVsYXdhcmV+REV8RGlzdHJpY3Qgb2YgQ29sdW1iaWF+REN8TWljcm9uZXNpYX5GTXxGbG9yaWRhfkZMfEdlb3JnaWF+R0F8R3VhbX5HVXxIYXdhaWl+SEl8SWRhaG9+SUR8SWxsaW5vaXN+SUx8SW5kaWFuYX5JTnxJb3dhfklBfEthbnNhc35LU3xLZW50dWNreX5LWXxMb3Vpc2lhbmF+TEF8TWFpbmV+TUV8TWFyc2hhbGwgSXNsYW5kc35NSHxNYXJ5bGFuZH5NRHxNYXNzYWNodXNldHRzfk1BfE1pY2hpZ2Fufk1JfE1pbm5lc290YX5NTnxNaXNzaXNzaXBwaX5NU3xNaXNzb3VyaX5NT3xNb250YW5hfk1UfE5lYnJhc2thfk5FfE5ldmFkYX5OVnxOZXcgSGFtcHNoaXJlfk5IfE5ldyBKZXJzZXl+Tkp8TmV3IE1leGljb35OTXxOZXcgWW9ya35OWXxOb3J0aCBDYXJvbGluYX5OQ3xOb3J0aCBEYWtvdGF+TkR8Tm9ydGhlcm4gTWFyaWFuYSBJc2xhbmRzfk1QfE9oaW9+T0h8T2tsYWhvbWF+T0t8T3JlZ29ufk9SfFBhbGF1flBXfFBlbm5zeWx2YW5pYX5QQXxQdWVydG8gUmljb35QUnxSaG9kZSBJc2xhbmR+Ukl8U291dGggQ2Fyb2xpbmF+U0N8U291dGggRGFrb3RhflNEfFRlbm5lc3NlZX5UTnxUZXhhc35UWHxVdGFoflVUfFZlcm1vbnR+VlR8VmlyZ2luIElzbGFuZHN+Vkl8VmlyZ2luaWF+VkF8V2FzaGluZ3Rvbn5XQXxXZXN0IFZpcmdpbmlhfldWfFdpc2NvbnNpbn5XSXxXeW9taW5nfldZfEFybWVkIEZvcmNlcyBBbWVyaWNhc35BQXxBcm1lZCBGb3JjZXMgRXVyb3BlLCBDYW5hZGEsIEFmcmljYSBhbmQgTWlkZGxlIEVhc3R+QUV8QXJtZWQgRm9yY2VzIFBhY2lmaWN+QVBcIl0sIFtcIlVuaXRlZCBTdGF0ZXMgTWlub3IgT3V0bHlpbmcgSXNsYW5kc1wiLCBcIlVNXCIsIFwiQmFrZXIgSXNsYW5kfjgxfEhvd2xhbmQgSXNsYW5kfjg0fEphcnZpcyBJc2xhbmR+ODZ8Sm9obnN0b24gQXRvbGx+Njd8S2luZ21hbiBSZWVmfjg5fE1pZHdheSBJc2xhbmRzfjcxfE5hdmFzc2EgSXNsYW5kfjc2fFBhbG15cmEgQXRvbGx+OTV8V2FrZSBJc2xhbmR+Nzl8QmFqbyBOdWV2byBCYW5rfkJOfFNlcnJhbmlsbGEgQmFua35TQlwiXSwgW1wiVXJ1Z3VheVwiLCBcIlVZXCIsIFwiQXJ0aWdhc35BUnxDYW5lbG9uZXN+Q0F8Q2Vycm8gTGFyZ29+Q0x8Q29sb25pYX5DT3xEdXJhem5vfkRVfEZsb3Jlc35GU3xGbG9yaWRhfkZEfExhdmFsbGVqYX5MQXxNYWxkb25hZG9+TUF8TW9udGV2aWRlb35NT3xQYXlzYW5kw7p+UEF8UsOtbyBOZWdyb35STnxSaXZlcmF+UlZ8Um9jaGF+Uk98U2FsdG9+U0F8U2FuIEpvc8OpflNKfFNvcmlhbm9+U098VGFjdWFyZW1iw7N+VEF8VHJlaW50YSB5IFRyZXN+VFRcIl0sIFtcIlV6YmVraXN0YW5cIiwgXCJVWlwiLCBcIlRvc2hrZW50IHNoYWhyaX5US3xBbmRpam9ufkFOfEJ1eG9yb35CVXxGYXJn4oCYb25hfkZBfEppenpheH5KSXxOYW1hbmdhbn5OR3xOYXZvaXl+Tld8UWFzaHFhZGFyeW8gKFFhcnNoaSl+UUF8U2FtYXJxYW5kflNBfFNpcmRhcnlvIChHdWxpc3Rvbil+U0l8U3VyeG9uZGFyeW8gKFRlcm1peil+U1V8VG9zaGtlbnQgd2lsb3lhdGl+VE98WG9yYXptIChVcmdhbmNoKX5YT3xRb3JhcWFscG9n4oCYaXN0b24gUmVzcHVibGlrYXNpIChOdWt1cyl+UVJcIl0sIFtcIlZhbnVhdHVcIiwgXCJWVVwiLCBcIk1hbGFtcGF+TUFQfFDDqW5hbWF+UEFNfFNhbm1hflNBTXxTaMOpZmF+U0VFfFRhZsOpYX5UQUV8VG9yYmF+VE9CXCJdLCBbXCJWZW5lenVlbGEsIEJvbGl2YXJpYW4gUmVwdWJsaWMgb2ZcIiwgXCJWRVwiLCBcIkRlcGVuZGVuY2lhcyBGZWRlcmFsZXN+V3xEaXN0cml0byBGZWRlcmFsfkF8QW1hem9uYXN+WnxBbnpvw6F0ZWd1aX5CfEFwdXJlfkN8QXJhZ3VhfkR8QmFyaW5hc35FfEJvbMOtdmFyfkZ8Q2FyYWJvYm9+R3xDb2plZGVzfkh8RGVsdGEgQW1hY3Vyb35ZfEZhbGPDs25+SXxHdcOhcmljb35KfExhcmF+S3xNw6lyaWRhfkx8TWlyYW5kYX5NfE1vbmFnYXN+TnxOdWV2YSBFc3BhcnRhfk98UG9ydHVndWVzYX5QfFN1Y3JlflJ8VMOhY2hpcmF+U3xUcnVqaWxsb35UfFZhcmdhc35YfFlhcmFjdXl+VXxadWxpYX5WXCJdLCBbXCJWaWV0bmFtXCIsIFwiVk5cIiwgXCLEkOG7k25nIE5haX4zOXzEkOG7k25nIFRow6FwfjQ1fEdpYSBMYWl+MzB8SMOgIEdpYW5nfjAzfEjDoCBOYW1+NjN8SMOgIFTDonl+MTV8SMOgIFTEqW5ofjIzfEjhuqNpIETGsMahbmd+NjF8SOG6rXUgR2lhbmd+NzN8SMOyYSBCw6xuaH4xNHxIxrBuZyBZw6pufjY2fEtow6FuaCBIw7JhfjM0fEtpw6puIEdpYW5nfjQ3fEtvbiBUdW1+Mjh8TGFpIENow6J1fjAxfEzDom0gxJDhu5NuZ34zNXxM4bqhbmcgU8ahbn4wOXxMw6BvIENhaX4wMnxMb25nIEFufjQxfE5hbSDEkOG7i25ofjY3fE5naOG7hyBBbn4yMnxOaW5oIELDrG5ofjE4fE5pbmggVGh14bqtbn4zNnxQaMO6IFRo4buNfjY4fFBow7ogWcOqbn4zMnxRdeG6o25nIELDrG5ofjI0fFF14bqjbmcgTmFtfjI3fFF14bqjbmcgTmfDo2l+Mjl8UXXhuqNuZyBOaW5ofjEzfFF14bqjbmcgVHLhu4t+MjV8U8OzYyBUcsSDbmd+NTJ8U8ahbiBMYX4wNXxUw6J5IE5pbmh+Mzd8VGjDoWkgQsOsbmh+MjB8VGjDoWkgTmd1ecOqbn42OXxUaGFuaCBIw7NhfjIxfFRo4burYSBUaGnDqm7igJNIdeG6v34yNnxUaeG7gW4gR2lhbmd+NDZ8VHLDoCBWaW5ofjUxfFR1ecOqbiBRdWFuZ34wN3xWxKluaCBMb25nfjQ5fFbEqW5oIFBow7pjfjcwfFnDqm4gQsOhaX4wNnxD4bqnbiBUaMahfkNUfMSQw6AgTuG6tW5nfkROfEjDoCBO4buZaX5ITnxI4bqjaSBQaMOybmd+SFB8SOG7kyBDaMOtIE1pbmggKFPDoGkgR8Oybil+U0dcIl0sIFtcIlZpcmdpbiBJc2xhbmRzLCBCcml0aXNoXCIsIFwiVkdcIiwgXCJBbmVnYWRhfkFOR3xKb3N0IFZhbiBEeWtlfkpWRHxUb3J0b2xhflRUQXxWaXJnaW4gR29yZGF+VkdEXCJdLCBbXCJWaXJnaW4gSXNsYW5kcywgVS5TLlwiLCBcIlZJXCIsIFwiU3QuIFRob21hc35TVEh8U3QuIEpvaG5+U0pPfFN0LiBDcm9peH5TQ1JcIl0sIFtcIldhbGxpcyBhbmQgRnV0dW5hXCIsIFwiV0ZcIiwgXCJBbG9+QUxPfFNpZ2F2ZX5TSUd8V2FsbGlzfldBTFwiXSwgW1wiV2VzdGVybiBTYWhhcmFcIiwgXCJFSFwiLCBcIkVzIFNtYXJhfkVTTXxCb3VqZG91cn5CT0R8TGHDonlvdW5lfkxBQXxBb3Vzc2VyZH5BT1V8T3VlZCBlZCBEYWhhYn5PVURcIl0sIFtcIlllbWVuXCIsIFwiWUVcIiwgXCJBYnnEgW5+QUJ8J0FkYW5+QUR8QeG4kSDhuJDEgWxpJ35EQXxBbCBCYXnhuJHEgSd+QkF8QWwg4biodWRheWRhaH5IVXxBbCBKYXdmfkpBfEFsIE1haHJhaH5NUnxBbCBNYeG4qXfEq3R+TVd8J0FtcsSBbn5BTXxEaGFtxIFyfkRIfOG4qGHhuJFyYW1hd3R+SER84bioYWpqYWh+SEp8SWJifklCfExh4bipaWp+TEF8TWEncmlifk1BfFJheW1haH5SQXzFnsSB4oCYZGFoflNEfMWeYW7igJjEgSd+U058U2hhYndhaH5TSHxUxIHigJhpenp+VEFcIl0sIFtcIlphbWJpYVwiLCBcIlpNXCIsIFwiQ2VudHJhbH4wMnxDb3BwZXJiZWx0fjA4fEVhc3Rlcm5+MDN8THVhcHVsYX4wNHxMdXNha2F+MDl8Tm9ydGhlcm5+MDV8Tm9ydGgtV2VzdGVybn4wNnxTb3V0aGVybn4wN3xXZXN0ZXJufjAxXCJdLCBbXCJaaW1iYWJ3ZVwiLCBcIlpXXCIsIFwiQnVsYXdheW9+QlV8SGFyYXJlfkhBfE1hbmljYWxhbmR+TUF8TWFzaG9uYWxhbmQgQ2VudHJhbH5NQ3xNYXNob25hbGFuZCBFYXN0fk1FfE1hc2hvbmFsYW5kIFdlc3R+TVd8TWFzdmluZ29+TVZ8TWF0YWJlbGVsYW5kIE5vcnRofk1OfE1hdGFiZWxlbGFuZCBTb3V0aH5NU3xNaWRsYW5kc35NSVwiXV0sIGEgPSBmdW5jdGlvbiAoKSB7ICQoXCIuY3JzLWNvdW50cnlcIikuZWFjaChuKSB9LCBuID0gZnVuY3Rpb24gKCkgeyB2YXIgYSA9IHRoaXM7IGlmIChcInRydWVcIiAhPT0gYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNycy1sb2FkZWRcIikpIHsgYS5sZW5ndGggPSAwOyB2YXIgbiA9ICQoYSkuYXR0cihcImRhdGEtZGVmYXVsdC1vcHRpb25cIiksIGkgPSBuIHx8IFwiU2VsZWN0IGNvdW50cnlcIiwgZSA9IGEuZ2V0QXR0cmlidXRlKFwiZGF0YS1zaG93LWRlZmF1bHQtb3B0aW9uXCIpOyBtID0gbnVsbCA9PT0gZSB8fCBcInRydWVcIiA9PT0gZTsgdmFyIHIgPSAkKGEpLmF0dHIoXCJkYXRhLWRlZmF1bHQtdmFsdWVcIiksIG8gPSAkKGEpLmF0dHIoXCJkYXRhLXZhbHVlXCIpLCBsID0gMDsgbSAmJiAodGhpcy5vcHRpb25zWzBdID0gbmV3IE9wdGlvbihpLCBcIlwiKSksIGsoeyB3aGl0ZWxpc3Q6IGEuZ2V0QXR0cmlidXRlKFwiZGF0YS13aGl0ZWxpc3RcIiksIGJsYWNrbGlzdDogYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJsYWNrbGlzdFwiKSwgcHJlZmVycmVkOiBhLmdldEF0dHJpYnV0ZShcImRhdGEtcHJlZmVycmVkXCIpLCBwcmVmZXJyZWREZWxpbTogYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXByZWZlcnJlZC1kZWxpbVwiKSB9KTsgZm9yICh2YXIgdCA9IDA7IHQgPCBNLmxlbmd0aDsgdCsrKSB7IHZhciBzID0gXCJzaG9ydGNvZGVcIiA9PSBvIHx8IFwiMi1jaGFyXCIgPT09IG8gPyBNW3RdWzFdIDogTVt0XVswXTsgTVt0XVs0XSAmJiAocyA9IFwiXCIpLCBhLm9wdGlvbnNbYS5sZW5ndGhdID0gbmV3IE9wdGlvbihNW3RdWzBdLCBzKSwgbnVsbCAhPSByICYmIHIgPT09IHMgJiYgKGwgPSB0LCBtICYmIGwrKykgfSB0aGlzLnNlbGVjdGVkSW5kZXggPSBsOyB2YXIgdSA9ICQoYSkuYXR0cihcImRhdGEtcmVnaW9uLWlkXCIpOyBpZiAodSkgeyB2YXIgZCA9ICQoXCIjXCIgKyB1KVswXTsgaWYgKGQpIGlmIChCKGQpLCAkKHRoaXMpLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHsgYihhLCBkKSB9KSwgciAmJiAwIDwgYS5zZWxlY3RlZEluZGV4KSB7IGIoYSwgZCk7IHZhciBoID0gJChkKS5hdHRyKFwiZGF0YS1kZWZhdWx0LXZhbHVlXCIpLCBTID0gXCJzaG9ydGNvZGVcIiA9PT0gZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpOyBpZiAobnVsbCAhPT0gaCkgeyB2YXIgQSA9IG0gPyBhLnNlbGVjdGVkSW5kZXggLSAxIDogYS5zZWxlY3RlZEluZGV4LCBnID0gTVtBXVszXTsgYyhkLCBnLCBoLCBTKSB9IH0gZWxzZSAhMSA9PT0gbSAmJiBiKGEsIGQpOyBlbHNlIGNvbnNvbGUuZXJyb3IoXCJSZWdpb24gZHJvcGRvd24gRE9NIG5vZGUgd2l0aCBJRCBcIiArIHUgKyBcIiBub3QgZm91bmQuXCIpOyBhLnNldEF0dHJpYnV0ZShcImRhdGEtY3JzLWxvYWRlZFwiLCBcInRydWVcIikgfSBlbHNlIGNvbnNvbGUuZXJyb3IoXCJNaXNzaW5nIGRhdGEtcmVnaW9uLWlkIG9uIGNvdW50cnktcmVnaW9uLXNlbGVjdG9yIGNvdW50cnkgZmllbGQuXCIpIH0gfSwgQiA9IGZ1bmN0aW9uIChhKSB7IHZhciBuID0gJChhKS5hdHRyKFwiZGF0YS1ibGFuay1vcHRpb25cIiksIGkgPSBuIHx8IFwiLVwiLCBlID0gYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXNob3ctZGVmYXVsdC1vcHRpb25cIik7IGggPSBudWxsID09PSBlIHx8IFwidHJ1ZVwiID09PSBlLCBhLmxlbmd0aCA9IDAsIGggJiYgKGEub3B0aW9uc1swXSA9IG5ldyBPcHRpb24oaSwgXCJcIiksIGEuc2VsZWN0ZWRJbmRleCA9IDApIH0sIGsgPSBmdW5jdGlvbiAoYSkgeyB2YXIgbiA9IGwsIGkgPSBbXSwgZSA9IDA7IGlmIChhLndoaXRlbGlzdCkgeyB2YXIgciA9IGEud2hpdGVsaXN0LnNwbGl0KFwiLFwiKTsgZm9yIChlID0gMDsgZSA8IGwubGVuZ3RoOyBlKyspLTEgIT09IHIuaW5kZXhPZihsW2VdWzFdKSAmJiBpLnB1c2gobFtlXSk7IG4gPSBpIH0gZWxzZSBpZiAoYS5ibGFja2xpc3QpIHsgdmFyIG8gPSBhLmJsYWNrbGlzdC5zcGxpdChcIixcIik7IGZvciAoZSA9IDA7IGUgPCBsLmxlbmd0aDsgZSsrKS0xID09PSBvLmluZGV4T2YobFtlXVsxXSkgJiYgaS5wdXNoKGxbZV0pOyBuID0gaSB9IGEucHJlZmVycmVkICYmIChuID0gcyhuLCBhLnByZWZlcnJlZCwgYS5wcmVmZXJyZWREZWxpbSkpLCBNID0gbiwgdCgpIH0sIHQgPSBmdW5jdGlvbiAoKSB7IGZvciAodmFyIGEgPSAwOyBhIDwgTS5sZW5ndGg7IGErKykgeyBmb3IgKHZhciBuID0geyBoYXNTaG9ydGNvZGVzOiAvfi8udGVzdChNW2FdWzJdKSwgcmVnaW9uczogW10gfSwgaSA9IE1bYV1bMl0uc3BsaXQoXCJ8XCIpLCBlID0gMDsgZSA8IGkubGVuZ3RoOyBlKyspIHsgdmFyIHIgPSBpW2VdLnNwbGl0KFwiflwiKTsgbi5yZWdpb25zLnB1c2goW3JbMF0sIHJbMV1dKSB9IE1bYV1bM10gPSBuIH0gfSwgYyA9IGZ1bmN0aW9uIChhLCBuLCBpLCBlKSB7IGZvciAodmFyIHIgPSAwOyByIDwgbi5yZWdpb25zLmxlbmd0aDsgcisrKSB7IGlmICgoZSAmJiBuLmhhc1Nob3J0Y29kZXMgJiYgbi5yZWdpb25zW3JdWzFdID8gbi5yZWdpb25zW3JdWzFdIDogbi5yZWdpb25zW3JdWzBdKSA9PT0gaSkgeyBhLnNlbGVjdGVkSW5kZXggPSBoID8gciArIDEgOiByOyBicmVhayB9IH0gfSwgYiA9IGZ1bmN0aW9uIChhLCBuKSB7IHZhciBpID0gbSA/IGEuc2VsZWN0ZWRJbmRleCAtIDEgOiBhLnNlbGVjdGVkSW5kZXgsIGUgPSAkKG4pLmF0dHIoXCJkYXRhLWRlZmF1bHQtb3B0aW9uXCIpLCByID0gbi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpLCBvID0gZSB8fCBcIlNlbGVjdCByZWdpb25cIjsgaWYgKFwiXCIgPT09IGEudmFsdWUpIEIobik7IGVsc2UgeyBuLmxlbmd0aCA9IDAsIGggJiYgKG4ub3B0aW9uc1swXSA9IG5ldyBPcHRpb24obywgXCJcIikpOyB2YXIgbCA9IE1baV1bM10sIHQgPSBcInNob3J0Y29kZVwiID09PSByICYmIGwuaGFzU2hvcnRjb2RlcywgcyA9IHQgPyAxIDogMDsgbC5yZWdpb25zLnNvcnQoZnVuY3Rpb24gKGEsIG4pIHsgdmFyIGkgPSBhW3NdLnRvTG93ZXJDYXNlKCksIGUgPSBuW3NdLnRvTG93ZXJDYXNlKCk7IHJldHVybiBpIDwgZSA/IC0xIDogZSA8IGkgPyAxIDogMCB9KTsgZm9yICh2YXIgdSA9IDA7IHUgPCBsLnJlZ2lvbnMubGVuZ3RoOyB1KyspIHsgdmFyIGQgPSB0ID8gbC5yZWdpb25zW3VdWzFdIDogbC5yZWdpb25zW3VdWzBdOyBuLm9wdGlvbnNbbi5sZW5ndGhdID0gbmV3IE9wdGlvbihsLnJlZ2lvbnNbdV1bMF0sIGQpIH0gbi5zZWxlY3RlZEluZGV4ID0gMCB9IH0sIHMgPSBmdW5jdGlvbiAoYSwgbiwgaSkgeyB2YXIgZSA9IG4uc3BsaXQoXCIsXCIpLnJldmVyc2UoKSwgciA9IHt9LCBvID0gITEsIGwgPSBhLmZpbHRlcihmdW5jdGlvbiAoYSkgeyByZXR1cm4gLTEgPT09IGUuaW5kZXhPZihhWzFdKSB8fCAoclthWzFdXSA9IGEsICEobyA9ICEwKSkgfSk7IG8gJiYgaSAmJiBsLnVuc2hpZnQoW2ksIFwiXCIsIFwiXCIsIHt9LCAhMF0pOyBmb3IgKHZhciB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHsgdmFyIHMgPSBlW3RdOyBsLnVuc2hpZnQocltzXSkgfSByZXR1cm4gbCB9OyByZXR1cm4gJChhKSwgeyBpbml0OiBhIH0gfSk7IiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKVxud2luZG93LiQgPSB3aW5kb3cualF1ZXJ5ID0gJFxucmVxdWlyZSgnLi9qcXVlcnkuY3JzLm1pbicpXG5yZXF1aXJlKCcuL2pRdWVyeS16b29tJylcbnJlcXVpcmUoJy4vcGFyc2xleS5taW4nKVxuXG53aW5kb3cucG9wcGVyID0gcmVxdWlyZSgnLi9wb3BwZXInKVxud2luZG93LnRpcHB5ID0gcmVxdWlyZSgnLi90aXBweScpXG53aW5kb3cuU3BsaWRlID0gcmVxdWlyZSgnLi9zcGxpZGUnKVxucmVxdWlyZSgnLi9zcGxpZGUtZ3JpZCcpXG53aW5kb3cuaW50bFRlbElucHV0ID0gcmVxdWlyZSgnLi9pbnRsVGVsSW5wdXQnKVxud2luZG93LnplbnNjcm9sbCA9IHJlcXVpcmUoJy4vemVuc2Nyb2xsJylcbndpbmRvdy5mYW5jeWJveCA9IHJlcXVpcmUoJy4vZmFuY3lib3gubWluJylcblxuLyoqIC0tIEdsb2JhbHMgKi9cbi8qKiBDb25zdGFudHMgLyBWYXJpYWJsZXMgLyBVdGlscyAvIEFqYXggKi9cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9jb25zdGFudHMnKVxuY29uc3QgdmFyaWFibGVzID0gcmVxdWlyZSgnLi9tb2R1bGVzL3ZhcmlhYmxlcycpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vbW9kdWxlcy91dGlscycpXG5jb25zdCBhamF4ID0gcmVxdWlyZSgnLi9tb2R1bGVzL2FqYXgnKVxuT2JqZWN0LmFzc2lnbih3aW5kb3csIGNvbnN0YW50cywgdmFyaWFibGVzLCB1dGlscywgYWpheClcblxuLyoqIC0tIEFwcGVuZCBFbGVtZW50cyAqL1xuLyogUGFnZSBUaXBzICovXG53aW5kb3cuUGFnZVRpcCA9IHJlcXVpcmUoJy4vbW9kdWxlcy9keW5hbWljL3BhZ2VUaXAnKVxuLyogQmFja2Ryb3AgKi9cbndpbmRvdy5CYWNrZHJvcCA9IHJlcXVpcmUoJy4vbW9kdWxlcy9keW5hbWljL2JhY2tkcm9wJylcbi8qIFBhZ2UgQ29uZmV0dGkgKi9cbndpbmRvdy5QYWdlQ29uZmV0dGkgPSByZXF1aXJlKCcuL21vZHVsZXMvZHluYW1pYy9wYWdlLWNvbmZldHRpJylcbi8qIEFzayBNb2RhbCAqL1xud2luZG93LkFza01vZGFsID0gcmVxdWlyZSgnLi9tb2R1bGVzL2R5bmFtaWMvYXNrLW1vZGFsJylcbi8qIExvYWRlciBSb290ICovXG53aW5kb3cucm9vdExvYWRlciA9IHJlcXVpcmUoJy4vbW9kdWxlcy9keW5hbWljL3Jvb3QtbG9hZGVyJylcbi8qIFNpZ24gVXAgcHJpY2UgYWxlcnRzICovXG53aW5kb3cucHJpY2VNb2RhbCA9IHJlcXVpcmUoJy4vbW9kdWxlcy9keW5hbWljL3ByaWNlLW1vZGFsJylcblxuLyoqIC0tIFBhZ2UgRWxlbWVudHMgKi9cbi8vIExvZ2luXG5yZXF1aXJlKCcuL21vZHVsZXMvbG9naW4nKVxuXG4vKiogSGVhZGVyIC8gRm9vdGVyXG4gKiBAdHlwZSBPYmplY3RzXG4gKi9cbndpbmRvdy5oZWFkZXIgPSByZXF1aXJlKCcuL21vZHVsZXMvZWxlbWVudHMvaGVhZGVyJylcbndpbmRvdy5mb290ZXIgPSByZXF1aXJlKCcuL21vZHVsZXMvZWxlbWVudHMvZm9vdGVyJylcblxuLyoqIFBhZ2UgRWxlbWVudHNcbiAqIEB0eXBlIE9iamVjdFxuICovXG53aW5kb3cucGFnZUVscyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9lbGVtZW50cy9wYWdlLWVsZW1lbnRzJylcbndpbmRvdy5wYWdlUmV2aWV3cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9lbGVtZW50cy9wYWdlLXJldmlld3MnKVxud2luZG93Lmhlcm9TcGxpZGUgPSByZXF1aXJlKCcuL21vZHVsZXMvZWxlbWVudHMvaGVyby1zcGxpZGUnKVxud2luZG93LnBhZ2VBbGVydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvZWxlbWVudHMvcGFnZS1hbGVydHMnKVxud2luZG93LnNpcnZDYXJkcyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9lbGVtZW50cy9zaXJ2JylcblxuLyoqIE1vZGFsc1xuICogQ3VycmVuY3kgLyBDYXJ0IC8gTWVudSAvIE1haWwgLyBRdWl6IC8gU2lnbiAvIE1lbnVcbiAqIEB0eXBlIE9iZWpjdHNcbiAqL1xud2luZG93LmN1cnJlbmN5TW9kYWwgPSByZXF1aXJlKCcuL21vZHVsZXMvbW9kYWxzL2N1cnJlbmN5LW1vZGFsJylcbndpbmRvdy5jYXJ0TW9kYWwgPSByZXF1aXJlKCcuL21vZHVsZXMvbW9kYWxzL2NhcnQtbW9kYWwnKVxud2luZG93LmJvb2tNb2RhbCA9IHJlcXVpcmUoJy4vbW9kdWxlcy9tb2RhbHMvYm9vay1tb2RhbCcpXG53aW5kb3cubWFpbE1vZGFsID0gcmVxdWlyZSgnLi9tb2R1bGVzL21vZGFscy9tYWlsLW1vZGFsJylcbndpbmRvdy5xdWl6TW9kYWwgPSByZXF1aXJlKCcuL21vZHVsZXMvbW9kYWxzL3F1aXotbW9kYWwnKVxud2luZG93LnNhbGVzTW9kYWwgPSByZXF1aXJlKCcuL21vZHVsZXMvbW9kYWxzL3NhbGVzLW1vZGFsJylcbmNvbnN0IG5vdGljZU1vZGFsID0gcmVxdWlyZSgnLi9tb2R1bGVzL21vZGFscy9ub3RpY2UtbW9kYWwnKVxuY29uc3QgTWVudSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9tb2RhbHMvbWVudScpXG5jb25zdCBBZGRDYXJ0TW9kYWwgPSByZXF1aXJlKCcuL21vZHVsZXMvZHluYW1pYy9hZGQtY2FydC1tb2RhbCcpXG5cbi8qKiBQRyBGaWx0ZXJzL1NlbGVjdC9Nb2RhbFxuICogQHR5cGUgT2JqZWN0c1xuICovXG53aW5kb3cucGdTZWxlY3QgPSByZXF1aXJlKCcuL21vZHVsZXMvZWxlbWVudHMvcGctc2VsZWN0JylcbndpbmRvdy5wZ01vZGFsID0gcmVxdWlyZSgnLi9tb2R1bGVzL2VsZW1lbnRzL3BnLW1vZGFsJylcblxuXG4vKiogLS0gUGFnZXMgKi9cbmNvbnN0XG4gIC8qIExvYW4gQXBwIDogL2ZpbmFuY2luZyAqL1xuICBMb2FuQXBwID0gcmVxdWlyZSgnLi9tb2R1bGVzL3BhZ2VzL2xvYW4tYXBwJyksXG4gIC8qIEpvYiBBcHBseSA6IC9hcHBseS1qb2IgKi9cbiAgSm9iQXBwID0gcmVxdWlyZSgnLi9tb2R1bGVzL3BhZ2VzL2pvYi1hcHAnKSxcbiAgLyogU2VsbCBXYXRjaCA6IC9zZWxsLW15LXdhdGNoICovXG4gIFNlbGxXYXRjaCA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9zZWxsLXdhdGNoJyksXG4gIC8qIExvb3NlIERpYW1vbmRzIDogL2xvb3NlLWRpYW1vbmRzICovXG4gIExvb3NlRGlhbW9uZHMgPSByZXF1aXJlKCcuL21vZHVsZXMvcGFnZXMvbG9vc2UtZGlhbW9uZHMnKSxcbiAgLyogSG9tZXBhZ2UgOiAvaW5kZXggKi9cbiAgSG9tZXBhZ2UgPSByZXF1aXJlKCcuL21vZHVsZXMvcGFnZXMvaG9tZXBhZ2UnKSxcbiAgUmVzdWx0c1BhZ2UgPSByZXF1aXJlKCcuL21vZHVsZXMvcGFnZXMvcmVzdWx0cycpLFxuICBQcm9kdWN0UGFnZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9wcm9kdWN0JyksXG4gIC8qIE15IEJhZyA6IC9jYXJ0ICovXG4gIG15QmFnID0gcmVxdWlyZSgnLi9tb2R1bGVzL3BhZ2VzL215LWJhZycpLFxuICAvKiBBY2NvdW50IFByb2ZpbGUgOiAvYWNjb3VudCAqL1xuICBhY2NvdW50ID0gcmVxdWlyZSgnLi9tb2R1bGVzL3BhZ2VzL2FjY291bnQtcGFnZScpLFxuICAvKiBMb2NhdGlvbnMgOiAvbG9jYXRpb25zICovXG4gIGxvY2F0aW9uUGFnZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9sb2NhdGlvbi1wYWdlJyksXG4gIC8qIFNlbGwgUGFnZXMgOiAvc2VsbCAqL1xuICBzZWxsUGFnZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9zZWxsLXBhZ2UnKSxcbiAgLyogUGFzcyBSZXNldCA6IC9wYXNzLXJlc2V0ICovXG4gIHBhc3NSZXNldCA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9wYXNzLXJlc2V0JyksXG4gIC8qIEJsb2cgOiAvYmxvZyAqL1xuICBibG9nUGFnZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9wYWdlcy9ibG9nLXBhZ2UnKSxcbiAgLyogRm9ybSBQYWdlIDogL2Zvcm0gKi9cbiAgZm9ybVBhZ2UgPSByZXF1aXJlKCcuL21vZHVsZXMvcGFnZXMvZm9ybS1wYWdlJyksXG4gIC8qIFRhZyBQcmV2aWV3IDogL3RhZyAqL1xuICB0YWdQcmV2aWV3ID0gcmVxdWlyZSgnLi9tb2R1bGVzL3BhZ2VzL3RhZy1wcmV2aWV3JylcbmNvbnN0IHNpcnZDYXJkcyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9lbGVtZW50cy9zaXJ2JylcblxuXG4vKiogLS0gSW5pdGlhbGl6ZSBQYWdlIE9iamVjdHMgKi9cbmNvbnN0XG4gIHBhZ2VPYmplY3RzQXJyID0gW1xuICAgIGhlYWRlcixcbiAgICBjYXJ0TW9kYWwsXG4gICAgY3VycmVuY3lNb2RhbCxcbiAgICBwZ01vZGFsLFxuICAgIGZvb3RlcixcbiAgICBwYWdlRWxzLFxuICAgIG15QmFnLFxuICAgIGFjY291bnQsXG4gICAgbG9jYXRpb25QYWdlLFxuICAgIHBhZ2VBbGVydHMsXG4gICAgc2lydkNhcmRzLFxuICAgIHNlbGxQYWdlLFxuICAgIGJvb2tNb2RhbCxcbiAgICBwYXNzUmVzZXQsXG4gICAgcGFnZVJldmlld3MsXG4gICAgYmxvZ1BhZ2UsXG4gICAgaGVyb1NwbGlkZSxcbiAgICBtYWlsTW9kYWwsXG4gICAgcXVpek1vZGFsLFxuICAgIHNhbGVzTW9kYWwsXG4gICAgZm9ybVBhZ2UsXG4gICAgdGFnUHJldmlld1xuICBdXG5jb25zdCBpbml0UGFnZU9iamVjdHMgPSAoKSA9PiB7XG4gIGZvciAoY29uc3Qgb2JqIG9mIHBhZ2VPYmplY3RzQXJyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmluaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvYmouaW5pdCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhvYmosICdObyBpbml0IGZ1bmN0aW9uJylcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluaXRpYWxpemluZyAke29ian06YCwgZXJyKVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKiAtLSBJbml0IFBhZ2UgT2JqZWN0cyAqL1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKCkge1xuICBpbml0UGFnZU9iamVjdHMoKVxuICB3aW5kb3cucGFnZVRpcCA9IG5ldyBQYWdlVGlwKClcblxuICAvLyBMb2FuIEFwcFxuICBjb25zdCBsb2FuQ2FzZUhvbGRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWlkPVwibG9hbi1hcHBseVwiXScpXG4gIGlmIChsb2FuQ2FzZUhvbGRlcikge1xuICAgIHdpbmRvdy5sb2FuQXBwID0gbmV3IExvYW5BcHAobG9hbkNhc2VIb2xkZXIpXG4gIH1cblxuICAvLyBKb2IgQXBwbHlcbiAgY29uc3Qgam9iQ2FzZUhvbGRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWlkPVwiam9iLWFwcGx5XCJdJylcbiAgaWYgKGpvYkNhc2VIb2xkZXIpIHtcbiAgICB3aW5kb3cuam9iQXBwID0gbmV3IEpvYkFwcChqb2JDYXNlSG9sZGVyKVxuICB9XG5cbiAgLy8gRm9ybSBQYWdlXG4gIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdmb3JtI3NlbGxfbXlfd2F0Y2gnKVxuICBpZiAoZm9ybSkge1xuICAgIHdpbmRvdy5zZWxsTXlXYXRjaCA9IG5ldyBTZWxsV2F0Y2goKVxuICB9XG5cbiAgLy8gTG9vc2UgRGlhbW9uZHNcbiAgY29uc3QgbG9vc2VEaWFtb25kc01haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubG9vc2VfZGlhbW9uZHMnKVxuICBpZiAobG9vc2VEaWFtb25kc01haW4pIHtcbiAgICB3aW5kb3cubG9vc2UgPSBuZXcgTG9vc2VEaWFtb25kcygpXG4gIH1cblxuICAvLyBNZW51XG4gIGNvbnN0IG1lbnVFbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1lbnUnKVxuICBpZiAobWVudUVsZW0pIHtcbiAgICB3aW5kb3cubWVudSA9IG5ldyBNZW51KCcubWVudScpXG4gIH1cblxuICAvLyBIb21lcGFnZVxuICBuZXcgSG9tZXBhZ2UoKVxuXG4gIC8vIFJlc3VsdHNcbiAgY29uc3QgcmVzdWx0c01haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbl9yZXN1bHRzJylcbiAgaWYgKHJlc3VsdHNNYWluKSB7XG4gICAgbmV3IFJlc3VsdHNQYWdlKClcbiAgfVxuXG4gIGNvbnN0IHByb2R1Y3RNYWluID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW5fcHJvZHVjdCcpXG4gIGlmIChwcm9kdWN0TWFpbikge1xuICAgIG5ldyBQcm9kdWN0UGFnZSgpXG4gIH1cblxuICAvLyBOb3RpY2UgbW9kYWxcbiAgd2luZG93Lm5vdGljZU1vZGFsID0gbmV3IG5vdGljZU1vZGFsKClcblxuICAvLyBBZGQgdG8gY2FydCBNb2RhbFxuICB3aW5kb3cuYWRkQ2FydE1vZGFsID0gbmV3IEFkZENhcnRNb2RhbCgpXG59KSIsImZ1bmN0aW9uIGFwcGx5UmVkZWVtQ29kZSgpIHtcbiAgY29uc3QgdmFsdWUgPSAkKCcjcmVkZWVtX2lucHV0JykudmFsKCk7XG4gIGlmICh2YWx1ZSAhPSAnJykge1xuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvanNvbi9yZWRlZW0tcHJvbW8tY29kZScsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiB7IGNvZGU6IHZhbHVlIH0sXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgciA9ICQucGFyc2VKU09OKGRhdGEpO1xuICAgICAgICBpZiAoIXIuZXJyb3IpIHtcbiAgICAgICAgICAkKCcuY2hlY2tvdXQtcmVkZWVtJykuc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3dNZXNzYWdlKCdlcnJvcicsICdFcnJvcicsIHIubXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcHBseVJlZGVlbUNvZGVcbn0iLCJjb25zdCBjb25zdGFudHMgPSB7XG4gIElTX1ZJU0lCTEU6IFwiaXMtdmlzaWJsZVwiLFxuICBJU19BQ1RJVkU6IFwiaXMtYWN0aXZlXCIsXG4gIEJVVFRPTl9MT0FESU5HOiBcImJ1dHRvbl9sb2FkaW5nXCIsXG4gIElTX0hJRERFTjogJ2lzLWhpZGRlbicsXG4gIElTX0VYUEFOREVEOiAnaXMtZXhwYW5kZWQnLFxuICBJU19NSU5JTUlaRUQ6ICdpcy1taW5pbWl6ZWQnLFxuICBJU19DT1BJRUQ6ICdpcy1jb3BpZWQnLFxuICBJU19FUlJPUjogJ2lzLWVycm9yJyxcbiAgSVNfRU1QVFk6ICdpcy1lbXB0eScsXG4gIF9fVFJVRTogJy0tdHJ1ZScsXG4gIF9fRkFMU0U6ICctLWZhbHNlJyxcbiAgX19GQURFOiAnLS1mYWRlJyxcbiAgX19IQUxGOiAnLS1oYWxmJyxcbiAgX19TRUxFQ1RFRDogJy0tc2VsZWN0ZWQnLFxuICBfX0xPQURFRDogJy0tbG9hZGVkJyxcbiAgX19ISURERU46ICctLWhpZGRlbicsXG4gIF9fVklTSUJMRTogJy0tdmlzaWJsZScsXG4gIF9fVkFMSUQ6ICctLXZhbGlkJyxcbiAgX19JTlZBTElEOiAnLS1pbnZhbGlkJyxcbiAgX19QRU5ESU5HOiAnLS1wZW5kaW5nJyxcbiAgX19MT0NLRUQ6ICctLWxvY2tlZCcsXG4gIF9fQUNUSVZFOiAnLS1hY3RpdmUnLFxuICBfX0VYUEFOREVEOiAnLS1leHBhbmRlZCcsXG4gIHBhY2VPcHRpb25zOiB7XG4gICAgYWpheDogdHJ1ZSxcbiAgICBkb2N1bWVudDogdHJ1ZSxcbiAgICBlbGVtZW50czoge1xuICAgICAgc2VsZWN0b3JzOiBbJ21haW4nXVxuICAgIH1cbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnRzOyIsImNsYXNzIEFkZENhcnRNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZWxlbSA9IG51bGxcbiAgICB0aGlzLm5hbWVFbGVtID0gbnVsbFxuICAgIHRoaXMucHJpY2VFbGVtID0gbnVsbFxuICAgIHRoaXMuc2FsZVByaWNlRWxlbSA9IG51bGxcbiAgICB0aGlzLnNyYyA9IG51bGxcbiAgICB0aGlzLmNhdGVnb3J5RWxlbSA9IG51bGxcbiAgICB0aGlzLmhlYWRpbmcgPSAnSXRlbSBhZGRlZCB0byBjYXJ0LidcbiAgfVxuXG4gIF9zZXRQcm9kdWN0KCkge1xuICAgIGNvbnN0IG5hbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaXRlbV9uYW1lJylcbiAgICBjb25zdCBwcmljZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjdXJyZW50X2Jhc2VfcHJpY2UnKVxuICAgIGNvbnN0IHNhbGVQcmljZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vbGRfcHJpY2UnKVxuICAgIGNvbnN0IGNhdGVnb3J5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNpZGUtcm93X19jYXRlZ29yeScpXG4gICAgY29uc3Qgc3JjID0gKCgpID0+IHtcblxuICAgICAgY29uc3QgZ2FsbGVyeSA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ2FsbGVyeV9kZXNrdG9wIC5wcm9kdWN0X19nYWxsZXJ5JyldLmZpbmQoKGVsKSA9PiB7XG4gICAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgcmV0dXJuIGVsXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBjb25zdCBpbWcgPSBnYWxsZXJ5LnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0X19tYWluLWdhbGxlcnkgaW1nJylcbiAgICAgIGlmICghaW1nKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGltYWdlIGZvdW5kJylcblxuICAgICAgcmV0dXJuIGltZy5zcmNcbiAgICB9KSgpXG5cbiAgICBpZiAoIW5hbWUgfHwgIXByaWNlIHx8ICFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBlbGVtZW50cyA6IG5hbWUsIHByaWNlLCBzcmMnKVxuICAgIH1cblxuICAgIHRoaXMubmFtZUVsZW0gPSBuYW1lXG4gICAgdGhpcy5wcmljZUVsZW0gPSBwcmljZVxuICAgIHRoaXMuc2FsZVByaWNlRWxlbSA9IHNhbGVQcmljZSA/IHNhbGVQcmljZSA6IG51bGxcbiAgICB0aGlzLnNyYyA9IHNyY1xuICAgIHRoaXMuY2F0ZWdvcnlFbGVtID0gY2F0ZWdvcnkgPyBjYXRlZ29yeSA6IG51bGxcbiAgfVxuXG4gIF9yZW5kZXJJdGVtSFRNTCgpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lRWxlbS50ZXh0Q29udGVudFxuICAgIGNvbnN0IHByaWNlID0gdGhpcy5wcmljZUVsZW0udGV4dENvbnRlbnRcbiAgICBjb25zdCBzYWxlUHJpY2UgPSB0aGlzLnNhbGVQcmljZUVsZW0gPyBgPHNwYW4gY2xhc3M9XCJjYXJ0LWl0ZW0tcHJpY2Vfc2FsZVwiPiR7dGhpcy5zYWxlUHJpY2VFbGVtLnRleHRDb250ZW50fTwvc3Bhbj48L3NwYW4+YCA6ICcnXG4gICAgY29uc3QgY2F0ZWdvcnkgPSB0aGlzLmNhdGVnb3J5RWxlbSA/IGA8ZGl2IGNsYXNzPVwiY2FydC1pdGVtX19jYXRlZ29yeVwiPiR7dGhpcy5jYXRlZ29yeUVsZW0udGV4dENvbnRlbnR9PC9kaXY+YCA6ICcnXG4gICAgY29uc3Qgc3JjID0gdGhpcy5zcmNcblxuICAgIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cImNhcnQtaXRlbVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImNhcnQtaXRlbV9fbWVkaWFcIj5cbiAgICAgICAgPGltZyBzcmM9XCIke3NyY31cIj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImNhcnQtaXRlbV9fZGV0YWlsc1wiPlxuICAgICAgJHtjYXRlZ29yeX1cbiAgICAgIDxoMyBjbGFzcz1cImNhcnQtaXRlbS1uYW1lXCI+JHtuYW1lfTwvaDM+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2FydC1pdGVtX19wcmljZS1yb3dcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJjYXJ0LWl0ZW0tcHJpY2VcIj4ke3ByaWNlfTwvc3Bhbj5cbiAgICAgICAgJHtzYWxlUHJpY2V9XG4gICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIGBcbiAgfVxuXG4gIF9yZW5kZXJIVE1MKCkge1xuICAgIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cImFkZC1jYXJ0LW1vZGFsX19jb250YWluZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJhZGQtY2FydC1tb2RhbF9faGVhZGVyXCI+XG4gICAgICAgIDxoMz4ke3RoaXMuaGVhZGluZ308L2gzPlxuICAgICAgICA8YnV0dG9uIG9uY2xpY2s9XCJ3aW5kb3cuYWRkQ2FydE1vZGFsLmRlc3Ryb3koKVwiPlxuICAgICAgICAgIDxzdmcgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdib3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMyAzTDIxIDIxXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiM1wiPjwvcGF0aD5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMjEgM0wzIDIxXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiM1wiPjwvcGF0aD5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgICR7dGhpcy5fcmVuZGVySXRlbUhUTUwoKX1cbiAgICAgIDxkaXYgY2xhc3M9XCJhZGQtY2FydC1tb2RhbF9fZm9vdGVyXCI+XG4gICAgICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBvbmNsaWNrPVwiZXZlbnQucHJldmVudERlZmF1bHQoKTsgd2luZG93LmFkZENhcnRNb2RhbC5kZXN0cm95KClcIiBjbGFzcz1cIi0tc3ViXCI+QmFjayBUbyBTaG9wcGluZzwvYT5cbiAgICAgICAgPGEgaHJlZj1cIi9jYXJ0XCI+R28gVG8gQ2hlY2tvdXQ8L2E+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICBgXG4gIH1cblxuICBfY3JlYXRlRWxlbWVudCgpIHtcbiAgICB0aGlzLl9zZXRQcm9kdWN0KClcblxuICAgIHRoaXMuZWxlbSA9IGNyZWF0ZUVsZW0oJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2FkZC1jYXJ0LW1vZGFsJyxcbiAgICAgIGlubmVySFRNTDogdGhpcy5fcmVuZGVySFRNTCgpXG4gICAgfSlcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluX3Byb2R1Y3QnKSkge1xuICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudCgpXG5cbiAgICAgIGlmICghdGhpcy5lbGVtKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgY3JlYXRlZCcpXG5cbiAgICAgIGxvY2tTY3JvbGwoKVxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZGVyJykuYXBwZW5kQ2hpbGQodGhpcy5lbGVtKVxuICAgICAgdGhpcy5lbGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuZWxlbS5jbGFzc0xpc3QuYWRkKF9fVklTSUJMRSlcbiAgICAgIH0pXG5cbiAgICAgIHdpbmRvdy5hZGRDYXJ0TW9kYWxCYWNrZHJvcCA9IG5ldyBCYWNrZHJvcCh7XG4gICAgICAgIG9wYWNpdHk6IDAuNyxcbiAgICAgICAgekluZGV4OiA5MCxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZWxlbSkge1xuXG4gICAgICB1bmxvY2tTY3JvbGwoKVxuICAgICAgdGhpcy5lbGVtLmNsYXNzTGlzdC5yZW1vdmUoX19WSVNJQkxFKVxuXG4gICAgICBjb25zdCBiYWNrZHJvcCA9IHdpbmRvdy5hZGRDYXJ0TW9kYWxCYWNrZHJvcFxuICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgIGJhY2tkcm9wLmhpZGUodHJ1ZSlcbiAgICAgICAgZGVsZXRlIHdpbmRvdy5hZGRDYXJ0TW9kYWxCYWNrZHJvcFxuICAgICAgfVxuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5lbGVtLnJlbW92ZSgpXG4gICAgICAgIHRoaXMuX2NsZWFyKClcbiAgICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMuZWxlbSkpXG4gICAgfVxuICB9XG5cbiAgX2NsZWFyKCkge1xuICAgIHRoaXMuZWxlbSA9IG51bGxcbiAgICB0aGlzLm5hbWVFbGVtID0gbnVsbFxuICAgIHRoaXMucHJpY2VFbGVtID0gbnVsbFxuICAgIHRoaXMuc2FsZVByaWNlRWxlbSA9IG51bGxcbiAgICB0aGlzLnNyYyA9IG51bGxcbiAgICB0aGlzLmNhdGVnb3J5RWxlbSA9IG51bGxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFkZENhcnRNb2RhbCIsImNsYXNzIEFza01vZGFsIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSkge1xuICAgIHRoaXMuaGVhZGluZyA9IHNldHRpbmdzLmhlYWRpbmcgfHwgJ0FyZSBZb3UgU3VyZSBZb3UgV2FudCBUbyBFeGl0PydcbiAgICB0aGlzLnN1YmhlYWRpbmcgPSBzZXR0aW5ncy5zdWJoZWFkaW5nIHx8ICdZb3Ugd2lsbCBsb3NlIGFsbCB1bnNhdmVkIHByb2dyZXNzLidcbiAgICB0aGlzLmV4aXRUZXh0ID0gc2V0dGluZ3MuZXhpdFRleHQgfHwgJ0V4aXQnXG4gICAgdGhpcy5rZWVwVGV4dCA9IHNldHRpbmdzLmtlZXBUZXh0IHx8ICdLZWVwJ1xuICAgIHRoaXMuZXhpdENhbGxiYWNrID0gc2V0dGluZ3MuZXhpdENhbGxiYWNrXG4gICAgdGhpcy5rZWVwQ2FsbGJhY2sgPSB0aGlzLmRlc3Ryb3lcbiAgfVxuXG4gIGdldCByZW5kZXJIVE1MKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8ZGl2IGRhdGEtZXZ0PVwiY2xvc2VBc2tNb2RhbFwiPjwvZGl2PlxuICAgICAgPGRpdj5cbiAgICAgICAgPGg0PiR7dGhpcy5oZWFkaW5nfTwvaDQ+XG4gICAgICAgIDxwPiR7dGhpcy5zdWJoZWFkaW5nfTwvcD5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8YnV0dG9uPiR7dGhpcy5leGl0VGV4dH08L2J1dHRvbj5cbiAgICAgICAgICA8YnV0dG9uPiR7dGhpcy5rZWVwVGV4dH08L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgXG4gIH1cblxuICBjcmVhdGUoKSB7XG4gICAgY29uc3QgbW9kYWwgPSBjcmVhdGVFbGVtKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICdhc2stbW9kYWwnLFxuICAgICAgaW5uZXJIVE1MOiB0aGlzLnJlbmRlckhUTUxcbiAgICB9KVxuICAgIGNvbnN0IGJ1dHRvbnMgPSBbLi4ubW9kYWwucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJyldXG4gICAgY29uc3QgY2xvc2VFdnQgPSBbLi4ubW9kYWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZXZ0PVwiY2xvc2VBc2tNb2RhbFwiXScpXVxuICAgIGJ1dHRvbnNbMF0ub25jbGljayA9ICgpID0+IHsgdGhpcy5kZXN0cm95KCk7IHRoaXMuZXhpdENhbGxiYWNrKCkgfVxuICAgIGJ1dHRvbnNbMV0ub25jbGljayA9ICgpID0+IHsgdGhpcy5rZWVwQ2FsbGJhY2soKSB9XG4gICAgZm9yIChjb25zdCBldnQgb2YgY2xvc2VFdnQpIHtcbiAgICAgIGV2dC5vbmNsaWNrID0gKCkgPT4geyB0aGlzLmRlc3Ryb3koKSB9XG4gICAgfVxuICAgIHJldHVybiBtb2RhbFxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB1bmxvY2tTY3JvbGwoKVxuICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFzay1tb2RhbCcpXG4gICAgaWYgKG1vZGFsKSB7XG4gICAgICBtb2RhbC5yZW1vdmUoKVxuICAgIH1cbiAgfVxuXG4gIHNob3coKSB7XG4gICAgbG9ja1Njcm9sbCgpXG4gICAgY29uc3QgZWxlbSA9IHRoaXMuY3JlYXRlKClcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBc2tNb2RhbCIsImNsYXNzIEJhY2tkcm9wIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSkge1xuICAgIHRoaXMuZWwgPSBjcmVhdGVFbGVtKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICdwYWdlLWJhY2tkcm9wJyxcbiAgICB9KVxuICAgIHRoaXMuY2FsbGJhY2sgPSBzZXR0aW5ncy5jYWxsYmFjayB8fCBudWxsXG4gICAgdGhpcy56SW5kZXggPSBzZXR0aW5ncy56SW5kZXggfHwgdW5kZWZpbmVkXG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gc2V0dGluZ3MuYmFja2dyb3VuZCB8fCB1bmRlZmluZWRcbiAgICB0aGlzLmhhbGYgPSBzZXR0aW5ncy5oYWxmIHx8IGZhbHNlXG4gICAgdGhpcy5vcGFjaXR5ID0gc2V0dGluZ3Mub3BhY2l0eSB8fCAxXG4gICAgdGhpcy5zaG93KClcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy5lbCkge1xuICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzaG93KCkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5lbClcbiAgICBpZiAodGhpcy56SW5kZXgpIHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuekluZGV4ID0gdGhpcy56SW5kZXhcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFsZikge1xuICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKF9fSEFMRilcbiAgICB9XG4gICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5lbC5zdHlsZS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5XG4gICAgfSwgMSk7XG4gIH1cblxuICBoaWRlKGlnbm9yZUNhbGxiYWNrID0gZmFsc2UpIHtcbiAgICB0aGlzLmVsLnN0eWxlLm9wYWNpdHkgPSAnMCdcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgdGhpcy5lbC5yZW1vdmUoKVxuICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMuZWwpKTtcblxuICAgIGlmICh0aGlzLmNhbGxiYWNrICYmICFpZ25vcmVDYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjaygpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2Ryb3AiLCJjbGFzcyBQYWdlQ29uZmV0dGkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVsID0gbnVsbFxuICAgIHRoaXMuY29udGFpbmVyRWwgPSBudWxsXG4gICAgdGhpcy5jb25mZXR0aUZyZXF1ZW5jeSA9IDNcbiAgICB0aGlzLmNvbmZldHRpSW50ZXJ2YWwgPSA1MFxuICAgIHRoaXMudGltZVRvRGVzdHJveSA9IDgwMDBcbiAgICB0aGlzLmNvbmZldHRpQ29sb3JzID0gWycjMDA5NWM2JywgJyMxYWI4ZWMnLCAnIzhjZGZmYScsICcjZDhmM2ZjJ11cbiAgICB0aGlzLmNvbmZldHRpQW5pbWF0aW9ucyA9IFsnc2xvdycsICdtZWRpdW0nLCAnZmFzdCddXG4gIH1cblxuICBjcmVhdGVIb2xkZXIoKSB7XG4gICAgdGhpcy5lbCA9IGNyZWF0ZUVsZW0oJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2NvbmZldHRpLWhvbGRlcidcbiAgICB9KVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5lbClcbiAgfVxuXG4gIHNldHVwKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lckVsID0gY3JlYXRlRWxlbSgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAnY29uZmV0dGktY29udGFpbmVyJ1xuICAgIH0pXG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZChjb250YWluZXJFbClcbiAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWxcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbmZldHRpSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBjb25mZXR0aUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIGNvbnN0IGNvbmZldHRpU2l6ZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMpICsgNyArICdweCdcbiAgICAgIGNvbnN0IGNvbmZldHRpQmFja2dyb3VuZCA9IHRoaXMuY29uZmV0dGlDb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5jb25mZXR0aUNvbG9ycy5sZW5ndGgpXVxuICAgICAgY29uc3QgY29uZmV0dGlMZWZ0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5lbC5vZmZzZXRXaWR0aCkgKyAncHgnXG4gICAgICBjb25zdCBjb25mZXR0aUFuaW1hdGlvbiA9IHRoaXMuY29uZmV0dGlBbmltYXRpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMuY29uZmV0dGlBbmltYXRpb25zLmxlbmd0aCldXG5cbiAgICAgIGNvbmZldHRpRWwuY2xhc3NMaXN0LmFkZCgnY29uZmV0dGknLCAnY29uZmV0dGktLWFuaW1hdGlvbi0nICsgY29uZmV0dGlBbmltYXRpb24pXG4gICAgICBjb25mZXR0aUVsLnN0eWxlLmxlZnQgPSBjb25mZXR0aUxlZnRcbiAgICAgIGNvbmZldHRpRWwuc3R5bGUud2lkdGggPSBjb25mZXR0aVNpemVcbiAgICAgIGNvbmZldHRpRWwuc3R5bGUuaGVpZ2h0ID0gY29uZmV0dGlTaXplXG4gICAgICBjb25mZXR0aUVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbmZldHRpQmFja2dyb3VuZFxuXG4gICAgICBjb25mZXR0aUVsLnJlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uZmV0dGlFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvbmZldHRpRWwpXG4gICAgICB9LCAzMDAwKVxuXG4gICAgICB0aGlzLmNvbnRhaW5lckVsLmFwcGVuZENoaWxkKGNvbmZldHRpRWwpXG4gICAgfSwgdGhpcy5jb25mZXR0aUludGVydmFsKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSAnMCdcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKVxuICAgICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUoZWwpKTtcbiAgICB9XG4gIH1cblxuICBwdXNoKGluZmluaXR5ID0gZmFsc2UpIHtcbiAgICB0aGlzLmNyZWF0ZUhvbGRlcigpXG4gICAgdGhpcy5zZXR1cCgpXG4gICAgdGhpcy5yZW5kZXIoKVxuICAgIGlmICghaW5maW5pdHkpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKVxuICAgICAgfSwgdGhpcy50aW1lVG9EZXN0cm95KTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlQ29uZmV0dGkiLCIvKipcbiAqIFBhZ2UgVGlwc1xuICovXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIGZ1bmN0aW9uIFBhZ2VUaXAoKSB7XG4gICAgdGhpcy50aXBFbGVtID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMuc2Nyb2xsSGFuZGxlciA9IHRoaXMuaGFuZGxlU2Nyb2xsLmJpbmQodGhpcyk7IC8vINCf0YDQuNCy0Y/Qt9GL0LLQsNC10Lwg0LrQvtC90YLQtdC60YHRgiDQuCDRgdC+0YXRgNCw0L3Rj9C10Lwg0YHRgdGL0LvQutGDINC90LAg0YTRg9C90LrRhtC40Y5cbiAgICB0aGlzLmhhbmRsZUhvdmVyKCk7XG4gIH1cblxuICBQYWdlVGlwLnByb3RvdHlwZS5oYW5kbGVIb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRpcF0nKS5mb3JFYWNoKGVsZW0gPT4ge1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZSA9PiB7XG4gICAgICAgIHRoaXMuY3JlYXRlVGlwKGVsZW0pO1xuICAgICAgICB0aGlzLnRpcEVsZW0udGV4dENvbnRlbnQgPSBlbGVtLmRhdGFzZXQudGlwO1xuICAgICAgICB0aGlzLnNldFRpcFBvc2l0aW9uKGVsZW0pO1xuXG4gICAgICAgIC8vINCU0L7QsdCw0LLQu9GP0LXQvCDQvtCx0YDQsNCx0L7RgtGH0LjQuiDRgdC+0LHRi9GC0LjRjyBzY3JvbGxcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuc2Nyb2xsSGFuZGxlcik7XG4gICAgICB9KTtcblxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZSA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveVRpcCgpO1xuXG4gICAgICAgIC8vINCj0LHQuNGA0LDQtdC8INC+0LHRgNCw0LHQvtGC0YfQuNC6INGB0L7QsdGL0YLQuNGPIHNjcm9sbFxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5zY3JvbGxIYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFBhZ2VUaXAucHJvdG90eXBlLmNyZWF0ZVRpcCA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIGlmICghdGhpcy50aXBFbGVtKSB7XG4gICAgICB0aGlzLnRpcEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMudGlwRWxlbS5jbGFzc0xpc3QuYWRkKCdwYWdlLXRpcCcpO1xuICAgICAgdGhpcy50aXBFbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJzsgLy8g0KPRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0L/QvtC30LjRhtC40L7QvdC40YDQvtCy0LDQvdC40LUg0L3QsCBhYnNvbHV0ZVxuICAgICAgdGhpcy50aXBFbGVtLnN0eWxlLm9wYWNpdHkgPSAnMCc7IC8vINCd0LDRh9Cw0LvRjNC90LDRjyDQvdC10L/RgNC+0LfRgNCw0YfQvdC+0YHRgtGMXG4gICAgICB0aGlzLnRpcEVsZW0uc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5IDAuM3MgZWFzZSwgdHJhbnNmb3JtIDAuM3MgZWFzZSc7IC8vINCf0LXRgNC10YXQvtC00Ysg0LTQu9GPINCw0L3QuNC80LDRhtC40LhcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMudGlwRWxlbSk7XG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgZXh0cmFDbGFzcyA9IHRhcmdldC5kYXRhc2V0LnRpcENsYXNzO1xuICAgICAgICBpZiAoZXh0cmFDbGFzcykge1xuICAgICAgICAgIHRoaXMudGlwRWxlbS5jbGFzc0xpc3QuYWRkKGAtLSR7ZXh0cmFDbGFzc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyDQodC+0YXRgNCw0L3Rj9C10Lwg0YLQtdC60YPRidC40Lkg0YbQtdC70LXQstC+0Lkg0Y3Qu9C10LzQtdC90YJcbiAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICB9XG4gIH07XG5cbiAgUGFnZVRpcC5wcm90b3R5cGUuc2V0VGlwUG9zaXRpb24gPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgY29uc3QgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdGlwUmVjdCA9IHRoaXMudGlwRWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgY29uc3QgZWxlbUhlaWdodCA9IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IGVsZW1XaWR0aCA9IGVsZW0ub2Zmc2V0V2lkdGg7XG5cbiAgICBsZXQgdG9wUG9zaXRpb24gPSByZWN0LnRvcCArIHNjcm9sbFRvcCAtIHRpcFJlY3QuaGVpZ2h0IC0gNDtcbiAgICBsZXQgbGVmdFBvc2l0aW9uID0gcmVjdC5sZWZ0ICsgc2Nyb2xsTGVmdCArIChlbGVtV2lkdGggLyAyKSAtICh0aXBSZWN0LndpZHRoIC8gMik7XG5cbiAgICAvLyDQodCx0YDQsNGB0YvQstCw0LXQvCDQutC70LDRgdGB0YtcbiAgICB0aGlzLnRpcEVsZW0uY2xhc3NMaXN0LnJlbW92ZSgnLS10b3AnLCAnLS1ib3R0b20nLCAnLS1sZWZ0JywgJy0tcmlnaHQnKTtcblxuICAgIC8vINCe0L/RgNC10LTQtdC70Y/QtdC8LCDRgdCy0LXRgNGF0YMg0LjQu9C4INGB0L3QuNC30YMg0L7RgtC+0LHRgNCw0LbQsNGC0Ywg0L/QvtC00YHQutCw0LfQutGDXG4gICAgbGV0IGlzQmVsb3cgPSBmYWxzZTtcbiAgICBpZiAodG9wUG9zaXRpb24gPCBzY3JvbGxUb3AgKyAxMDApIHsgLy8g0KPRh9C40YLRi9Cy0LDQtdC8INC/0L7Qt9C40YbQuNGOINC/0YDQvtC60YDRg9GC0LrQuFxuICAgICAgdG9wUG9zaXRpb24gPSByZWN0LnRvcCArIHNjcm9sbFRvcCArIGVsZW1IZWlnaHQgKyA0O1xuICAgICAgdGhpcy50aXBFbGVtLmNsYXNzTGlzdC5hZGQoJy0tYm90dG9tJyk7XG4gICAgICBpc0JlbG93ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50aXBFbGVtLmNsYXNzTGlzdC5hZGQoJy0tdG9wJyk7XG4gICAgfVxuXG4gICAgaWYgKGxlZnRQb3NpdGlvbiA8IDApIHtcbiAgICAgIGxlZnRQb3NpdGlvbiA9IHJlY3QubGVmdCArIHNjcm9sbExlZnQ7XG4gICAgICB0aGlzLnRpcEVsZW0uY2xhc3NMaXN0LmFkZCgnLS1sZWZ0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy50aXBFbGVtLnN0eWxlLnRvcCA9IGAke3RvcFBvc2l0aW9ufXB4YDtcbiAgICB0aGlzLnRpcEVsZW0uc3R5bGUubGVmdCA9IGAke2xlZnRQb3NpdGlvbn1weGA7XG5cbiAgICAvLyDQo9GB0YLQsNC90LDQstC70LjQstCw0LXQvCDQvdCw0YfQsNC70YzQvdGL0LUg0YHRgtC40LvQuCDQtNC70Y8g0LDQvdC40LzQsNGG0LjQuFxuICAgIGlmIChpc0JlbG93KSB7XG4gICAgICB0aGlzLnRpcEVsZW0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoOHB4KSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGlwRWxlbS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgtOHB4KSc7XG4gICAgfVxuXG4gICAgLy8g0JjRgdC/0L7Qu9GM0LfRg9C10LwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lINC00LvRjyDQvtCx0LXRgdC/0LXRh9C10L3QuNGPINC/0YDQsNCy0LjQu9GM0L3QvtCz0L4g0L/RgNC40LzQtdC90LXQvdC40Y8g0YHRgtC40LvQtdC5XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMudGlwRWxlbS5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgICAgdGhpcy50aXBFbGVtLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKDBweCknO1xuICAgIH0pO1xuICB9O1xuXG4gIFBhZ2VUaXAucHJvdG90eXBlLmhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGVzdHJveVRpcCgpO1xuXG4gICAgLy8g0KPQsdC40YDQsNC10Lwg0L7QsdGA0LDQsdC+0YLRh9C40Log0YHQvtCx0YvRgtC40Y8gc2Nyb2xsXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuc2Nyb2xsSGFuZGxlcik7XG4gIH07XG5cbiAgUGFnZVRpcC5wcm90b3R5cGUuZGVzdHJveVRpcCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnRpcEVsZW0pIHtcbiAgICAgIHRoaXMudGlwRWxlbS5yZW1vdmUoKTtcbiAgICAgIHRoaXMudGlwRWxlbSA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvLyDQrdC60YHQv9C+0YDRgtC40YDRg9C10Lwg0LrQu9Cw0YHRgSBQYWdlVGlwXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gUGFnZVRpcDtcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuUGFnZVRpcCA9IFBhZ2VUaXA7XG4gIH1cbn0pKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBnbG9iYWwpO1xuIiwiY29uc3QgQmFja2Ryb3AgPSByZXF1aXJlKFwiLi9iYWNrZHJvcFwiKVxuXG5jbGFzcyBQcmljZU1vZGFsIHtcbiAgY29uc3RydWN0b3IoY2FyZCwgaWQpIHtcbiAgICBpZiAoIWNhcmQpIHtcbiAgICAgIGNvbnNvbGUud2FybignTWlzc2luZyBjYXJkJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2FyZCA9IGNhcmRcbiAgICB0aGlzLmlkID0gaWRcbiAgICB0aGlzLm5hbWUgPSB1bmRlZmluZWRcbiAgICB0aGlzLmltZ1NyYyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuZWxlbSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuaW5wdXQgPSB1bmRlZmluZWRcbiAgICB0aGlzLmNsb3NlQXJyID0gW11cblxuICAgIHRoaXMuc2V0dXAoKVxuICAgIHRoaXMuc2hvdygpXG4gIH1cblxuICBzaWdudXAoKSB7XG4gICAgdGhpcy5yZXNldCgpXG5cbiAgICBjb25zdCBlbWFpbCA9IHRoaXMuaW5wdXQudmFsdWVcbiAgICBjb25zdCByZWcgPSAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcXSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC9cblxuICAgIGlmICghcmVnLnRlc3QoU3RyaW5nKGVtYWlsKS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgdGhpcy5lcnJvcignSW52YWxpZCBlbWFpbCBhZGRyZXNzJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZWxlbS5jbGFzc0xpc3QuYWRkKCctLWxvYWRpbmcnKVxuXG4gICAgY29uc3QgcmVzZXQgPSB0aGlzLnJlc2V0LmJpbmQodGhpcylcbiAgICBjb25zdCBlcnJvciA9IHRoaXMuZXJyb3IuYmluZCh0aGlzKVxuICAgIGNvbnN0IGRlc3Ryb3kgPSB0aGlzLmRlc3Ryb3kuYmluZCh0aGlzKVxuXG4gICAgY29uc3Qgc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmVsZW1cblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZSgnLS1sb2FkaW5nJylcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZGVzdHJveSgpXG4gICAgICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKGVsZW0pKTtcbiAgICAgIH0sIDIwMDApO1xuICAgIH1cblxuICAgICQuYWpheCh7XG4gICAgICB1cmw6ICcvanNvbi9zaWdudXAtcHJpY2UnLFxuICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgZGF0YTogeyBpZDogdGhpcy5pZCwgZW1haWw6IGVtYWlsIH0sXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEuZXJyb3IpIHtcbiAgICAgICAgICBzdWNjZXNzKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc2V0KClcbiAgICAgICAgZXJyb3IoJ1NvbWV0aGluZyB3ZW50IHdyb25nJylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZXJyb3IobXNnKSB7XG4gICAgdGhpcy5lbGVtLmNsYXNzTGlzdC5hZGQoJy0tZXJyb3InKVxuICAgIHRoaXMuZWxlbS5xdWVyeVNlbGVjdG9yKCcucHJpY2UtbW9kYWxfX2Vycm9yJykudGV4dENvbnRlbnQgPSBtc2dcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZWxlbS5jbGFzc0xpc3QucmVtb3ZlKCctLWVycm9yJylcbiAgICB0aGlzLmVsZW0uY2xhc3NMaXN0LnJlbW92ZSgnLS1sb2FkaW5nJylcbiAgfVxuXG4gIHNldHVwKCkge1xuICAgIGNvbnN0IG5hbWVFbGVtID0gdGhpcy5jYXJkLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LWNhcmRfX25hbWUnKVxuICAgIGNvbnN0IGltZ0VsZW0gPSB0aGlzLmNhcmQucXVlcnlTZWxlY3RvcignLnByb2R1Y3QtY2FyZF9faW1nJylcblxuICAgIGlmICghbmFtZUVsZW0gfHwgIWltZ0VsZW0pIHtcbiAgICAgIGNvbnNvbGUud2FybignTWlzc2luZyBuYW1lIGVsZW1lbnQgb3IgaW1nJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IG5hbWVFbGVtLnRleHRDb250ZW50XG4gICAgdGhpcy5pbWdTcmMgPSBpbWdFbGVtLmdldEF0dHJpYnV0ZSgnc3JjJylcbiAgfVxuXG4gIGdldCByZW5kZXJIVE1MKCkge1xuICAgIHJldHVybiBgXG5cdFx0XHQ8ZGl2IGNsYXNzPVwicHJpY2UtbW9kYWxfX2hlYWRlclwiPlxuXHRcdFx0XHQ8aDI+U2lnbiB1cCBmb3IgcHJpY2UgYWxlcnRzPC9oMj5cblx0XHRcdFx0PHA+V2UnbGwgc2VuZCB5b3UgYW4gZW1haWwgaWYgcHJpY2UgaXMgY2hhbmdlZC48L3A+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9XCJwcmljZS1tb2RhbF9faXRlbVwiPlxuXHRcdFx0XHQ8aW1nIHNyYz1cIiR7dGhpcy5pbWdTcmN9XCIgYWx0PVwiXCI+XG5cdFx0XHRcdDxkaXY+PGgzPiR7dGhpcy5uYW1lfTwvaDM+PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9XCJwcmljZS1tb2RhbF9fbWFpblwiPlxuXHRcdFx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIllvdXIgRW1haWwgQWRkcmVzcy4uLlwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicHJpY2UtbW9kYWxfX2Vycm9yXCI+U29tZXRoaW5nIHdlbnQgd3Jvbmc8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cInByaWNlLW1vZGFsX19mb290ZXJcIj5cblx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwiLS1zdWJcIj5DbG9zZTwvYnV0dG9uPlxuXHRcdFx0XHRcdDxidXR0b24gb25jbGljaz1cIndpbmRvdy5zaWdudXBQcmljZSgpXCI+U3VibWl0PC9idXR0b24+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG4gICAgYFxuICB9XG5cbiAgY3JlYXRlKCkge1xuICAgIGNvbnN0IG1vZGFsID0gY3JlYXRlRWxlbSgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAncHJpY2UtbW9kYWwnLFxuICAgICAgaW5uZXJIVE1MOiB0aGlzLnJlbmRlckhUTUxcbiAgICB9KVxuICAgIHJldHVybiBtb2RhbFxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB1bmxvY2tTY3JvbGwoKVxuICAgIHRoaXMuZWxlbS5jbGFzc0xpc3QucmVtb3ZlKF9fVklTSUJMRSlcblxuICAgIGNvbnN0IGJhY2tkcm9wID0gd2luZG93LnByaWNlTW9kYWxCYWNrZHJvcFxuICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgYmFja2Ryb3AuaGlkZSh0cnVlKVxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5lbGVtLnJlbW92ZSgpXG4gICAgICB3aW5kb3cucHJpY2VNb2RhbEJhY2tkcm9wID0gdW5kZWZpbmVkXG4gICAgICB3aW5kb3cuc2lnblByaWNlTW9kYWwgPSB1bmRlZmluZWRcbiAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmVsZW0pKTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgbG9ja1Njcm9sbCgpXG4gICAgdGhpcy5lbGVtID0gdGhpcy5jcmVhdGUoKVxuICAgIHRoaXMuaW5wdXQgPSB0aGlzLmVsZW0ucXVlcnlTZWxlY3RvcignaW5wdXQnKVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5lbGVtKVxuICAgIHRoaXMuaW5wdXQuZm9jdXMoKVxuICAgIHRoaXMuY2xvc2VBcnIucHVzaCh0aGlzLmVsZW0ucXVlcnlTZWxlY3RvcignLi0tc3ViJykpXG5cbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdGhpcy5jbG9zZUFycikge1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95KClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcbiAgICAgIHRoaXMucmVzZXQoKVxuXG4gICAgICBpZiAodGhpcy5pbnB1dC52YWx1ZSkge1xuICAgICAgICB0aGlzLmVsZW0uY2xhc3NMaXN0LmFkZCgnLS11bmxvY2tlZCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsZW0uY2xhc3NMaXN0LnJlbW92ZSgnLS11bmxvY2tlZCcpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmVsZW0uY2xhc3NMaXN0LmFkZChfX1ZJU0lCTEUpXG4gICAgICB3aW5kb3cucHJpY2VNb2RhbEJhY2tkcm9wID0gbmV3IEJhY2tkcm9wKHtcbiAgICAgICAgaGFsZjogdHJ1ZSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcmljZU1vZGFsIiwiY29uc3Qgcm9vdExvYWRlciA9IG5ldyBPYmplY3Qoe1xuICBjbGFzczogJ3Jvb3RfbG9hZGVyJyxcbiAgcmVuZGVySFRNTDogKCkgPT4geyByZXR1cm4gYDxkaXYgY2xhc3M9JHtyb290TG9hZGVyLmNsYXNzfT48L2Rpdj5gIH0sXG4gIGlzRXhpc3Q6ICgpID0+IHsgcmV0dXJuICQoZG9jdW1lbnQpLmZpbmQoYC4ke3Jvb3RMb2FkZXIuY2xhc3N9YCkubGVuZ3RoID8gdHJ1ZSA6IGZhbHNlIH0sXG5cbiAgcHVzaDogZnVuY3Rpb24gKG5vTG9jayA9IGZhbHNlKSB7XG4gICAgaWYgKCFub0xvY2spIHsgbG9ja1Njcm9sbCgpIH1cbiAgICBpZiAoIXRoaXMuaXNFeGlzdCgpKSB7ICRib2R5LmFwcGVuZChyb290TG9hZGVyLnJlbmRlckhUTUwoKSkgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIChub1VubG9jayA9IGZhbHNlKSB7XG4gICAgaWYgKCFub1VubG9jaykgdW5sb2NrU2Nyb2xsKCk7XG4gICAgaWYgKHRoaXMuaXNFeGlzdCgpKSB7ICQoZG9jdW1lbnQpLmZpbmQoYC4ke3Jvb3RMb2FkZXIuY2xhc3N9YCkucmVtb3ZlKCkgfVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3RMb2FkZXIiLCJjbGFzcyBab29tR2FsbGVyeSB7XG4gIGNvbnN0cnVjdG9yKG1lZGlhQXJyKSB7XG4gICAgdGhpcy5lbGVtID0gbnVsbFxuICAgIHRoaXMubWVkaWFBcnIgPSBtZWRpYUFyclxuICAgIHRoaXMuaW5pdCgpXG4gIH1cblxuICAvLyBSZW5kZXIgSFRNTFxuICBfcmVuZGVyTWVkaWFIVE1MKCkge1xuICAgIGxldCBodG1sID0gJydcbiAgICBmb3IgKGNvbnN0IG1lZGlhIG9mIHRoaXMubWVkaWFBcnIpIHtcbiAgICAgIGNvbnN0IGNsb25lID0gbWVkaWEuY2xvbmVOb2RlKHRydWUpXG4gICAgICBjbG9uZS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcbiAgICAgIGNsb25lLmNsYXNzTmFtZSA9ICdwcm9kdWN0LW1lZGlhJ1xuXG4gICAgICBodG1sICs9IGNsb25lLm91dGVySFRNTFxuICAgIH1cbiAgICByZXR1cm4gaHRtbFxuICB9XG4gIF9yZW5kZXJJbm5lckhUTUwoKSB7XG4gICAgY29uc3QgbmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpdGVtX25hbWUnKVxuICAgIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cInpvb20yX193cmFwcGVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiem9vbTJfX3Njcm9sbGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ6b29tMl9faGVhZGVyXCI+XG4gICAgICAgICAgPGg0PiR7bmFtZS50ZXh0Q29udGVudH08L2g0PlxuICAgICAgICAgIDxidXR0b24gZGF0YS16b29tLWNsb3NlIGNsYXNzPVwiem9vbTJfX2Nsb3NlLWJ0blwiPjwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgJHt0aGlzLl9yZW5kZXJNZWRpYUhUTUwoKX1cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBkYXRhLXpvb20tY2xvc2UgY2xhc3M9XCJ6b29tMl9fZm9vdGVyXCI+XG4gICAgICAgIDxzcGFuPkdldCBCYWNrPC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYFxuICB9XG4gIF9jcmVhdGUoKSB7XG4gICAgdGhpcy5lbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLmVsZW0uY2xhc3NOYW1lID0gJ3pvb20yJ1xuICAgIHRoaXMuZWxlbS5pbm5lckhUTUwgPSB0aGlzLl9yZW5kZXJJbm5lckhUTUwoKVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMuZWxlbSlcbiAgfVxuXG4gIC8vIE1ldGhvZHNcbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtKSB7XG4gICAgICB1bmxvY2tTY3JvbGwoKVxuICAgICAgdGhpcy5lbGVtLmNsYXNzTGlzdC5yZW1vdmUoX19WSVNJQkxFKVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmVsZW0pKVxuICAgIH1cbiAgfVxuICBvcGVuKCkge1xuICAgIGlmICghdGhpcy5lbGVtKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgY3JlYXRlZCBab29tMiBab29tR2FsbGVyeScpXG5cbiAgICBsb2NrU2Nyb2xsKClcbiAgICB0aGlzLmVsZW0uc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5lbGVtLmNsYXNzTGlzdC5hZGQoX19WSVNJQkxFKVxuICAgIH0pXG4gIH1cblxuICAvLyBFdmVudHNcbiAgX2JpbmRJbm5lckV2ZW50cygpIHtcbiAgICBpZiAodGhpcy5lbGVtKSB7XG4gICAgICBjb25zdCBjbG9zZUFyciA9IFsuLi50aGlzLmVsZW0ucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtem9vbS1jbG9zZV0nKV07XG4gICAgICBjbG9zZUFyci5mb3JFYWNoKChjbG9zZUVsZW0pID0+IHtcbiAgICAgICAgY2xvc2VFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oaWRlLmJpbmQodGhpcykpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5pdFxuICBpbml0KCkge1xuICAgIHRoaXMuX2NyZWF0ZSgpXG4gICAgdGhpcy5fYmluZElubmVyRXZlbnRzKClcbiAgICB0aGlzLm9wZW4oKVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZWxlbSkge1xuICAgICAgdGhpcy5lbGVtLnJlbW92ZSgpXG4gICAgICB0aGlzLmVsZW0gPSBudWxsXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWm9vbUdhbGxlcnkiLCJjb25zdCBmb290ZXIgPSBuZXcgT2JqZWN0KHtcbiAgYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDwgNDgwKSB7XG4gICAgICBjb25zdCBldnRBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZvb3Rlcl9fY29sLWhlYWQnKV1cbiAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBldnRBcnIpIHtcbiAgICAgICAgY29uc3QgY29sID0gZWxlbS5jbG9zZXN0KCcuZm9vdGVyX19jb2wnKVxuICAgICAgICBpZiAoIWNvbCkgcmV0dXJuXG5cbiAgICAgICAgaWYgKCFjb2wuY2xhc3NMaXN0LmNvbnRhaW5zKCcuLS1zdGF0aWMnKSkge1xuICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBjb2wuY2xhc3NMaXN0LnRvZ2dsZSgnLS1vcGVuJylcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5iaW5kRXZlbnRzKClcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBmb290ZXIiLCJjb25zdCBoZWFkZXIgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbmRlckRPTSgpO1xuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIHRoaXMuc2V0RHJvcGRvd25zKClcbiAgfSxcbiAgcmVuZGVyRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTG9naW4gRHJvcGRvd25cbiAgICB0aGlzLmxvZ2luQnRuID0gJCgnW2RhdGEtZXZ0PVwidG9nZ2xlQWNjb3VudERyb3Bkb3duXCJdJyk7XG4gICAgdGhpcy5sb2dpbkRyb3Bkb3duID0gJChcIi5sb2dpbi1kcm9wZG93blwiKTtcblxuICAgIC8vIFNlYXJjaFxuICAgIHRoaXMuc2VhcmNoQnRuID0gJCgnW2RhdGEtZXZ0PVwidG9nZ2xlU2VhcmNoXCJdJyk7XG4gICAgdGhpcy5zZWFyY2hCbG9jayA9ICQoXCIuaGVhZGVyLXNlYXJjaFwiKTtcblxuICAgIHRoaXMubG9naW5MaW5rID0gJCgnLmxvZ2luLW5hdl9fbGluaycpXG4gIH0sXG4gIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxvZ2luQnRuLm9uKCdtb3VzZW92ZXIgbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGxldCBkZCA9IGhlYWRlci5sb2dpbkRyb3Bkb3duXG4gICAgICBpZiAoZGQubGVuZ3RoKSB7XG4gICAgICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgICAgICAgICAgZGQuY3NzKHsgZGlzcGxheTogJ2Jsb2NrJywgb3BhY2l0eTogMSB9KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbW91c2VsZWF2ZSc6XG4gICAgICAgICAgICBkZC5jc3MoeyBkaXNwbGF5OiAnbm9uZScsIG9wYWNpdHk6IDAgfSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmxvZ2luTGluay5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIH0pXG5cbiAgICB0aGlzLnNlYXJjaEJ0bi5jbGljaygoKSA9PiB7XG4gICAgICBsZXQgZWwgPSBoZWFkZXIuc2VhcmNoQmxvY2s7XG5cbiAgICAgIGZ1bmN0aW9uIGhpZGVTZWFyY2goKSB7XG4gICAgICAgIGVsLnJlbW92ZUNsYXNzKElTX1ZJU0lCTEUpO1xuICAgICAgICB1bmxvY2tTY3JvbGwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsLmhhc0NsYXNzKElTX1ZJU0lCTEUpKSB7XG4gICAgICAgIGhpZGVTZWFyY2goKVxuICAgICAgICBpZiAod2luZG93LnNlYXJjaEJhY2tkcm9wKSB7XG4gICAgICAgICAgd2luZG93LnNlYXJjaEJhY2tkcm9wLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9ja1Njcm9sbCgpO1xuICAgICAgICBlbC5hZGRDbGFzcyhJU19WSVNJQkxFKTtcbiAgICAgICAgZWwuZmluZChcImlucHV0XCIpLmZvY3VzKCk7XG5cbiAgICAgICAgd2luZG93LnNlYXJjaEJhY2tkcm9wID0gbmV3IEJhY2tkcm9wKHtcbiAgICAgICAgICBoYWxmOiB0cnVlLFxuICAgICAgICAgIHpJbmRleDogKGdldFpJbmRleChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkZXInKSkgLSAxKSxcbiAgICAgICAgICBjYWxsYmFjazogaGlkZVNlYXJjaFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBzZXREcm9wZG93bnM6IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgYXJncyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmhlYWRlcl9fc3ViLWxpbmsnKSlcblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMCAmJiBhcmdzKSB7XG5cbiAgICAgIGNvbnN0IGRkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm5hdi1kcm9wJylcbiAgICAgIGNvbnN0IGNvbnQgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm5hdi1kcm9wX19jb250ZW50JyldXG4gICAgICBjb25zdCBzdWJMaW5rID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5uYXYtZHJvcF9tb3JlJyldXG4gICAgICBjb25zdCBJU19BQ1RJVkUgPSAnaXMtYWN0aXZlJ1xuXG4gICAgICBsZXQgaGlkZURlbGF5VGltZSwgc2hvd0RlbGF5VGltZVxuXG4gICAgICBpZiAoZGQgJiYgY29udCAmJiBzdWJMaW5rKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IChlbCkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIGVsLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyAoZWwub2Zmc2V0V2lkdGggLyAyKSAtIChkZC5vZmZzZXRXaWR0aCAvIDIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm4gPSB7XG4gICAgICAgICAgaW5pdGlhbDogKCkgPT4ge1xuICAgICAgICAgICAgZGQuc3R5bGUudG9wID0gYCR7cG9zKGFyZ3NbMF0pLnRvcH1weGBcbiAgICAgICAgICAgIGRkLnN0eWxlLmxlZnQgPSBgJHtwb3MoYXJnc1swXSkubGVmdH1weGBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhpZGU6ICgpID0+IHtcbiAgICAgICAgICAgIGRkLnN0eWxlLm9wYWNpdHkgPSAwXG4gICAgICAgICAgICBkZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICBhcmdzLmZvckVhY2goZWwgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShJU19BQ1RJVkUpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2hvdzogKGVsKSA9PiB7XG4gICAgICAgICAgICBhcmdzLmZvckVhY2goZWwgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShJU19BQ1RJVkUpKVxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChJU19BQ1RJVkUpXG4gICAgICAgICAgICBkZC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgZGQuc3R5bGUudG9wID0gYCR7cG9zKGVsKS50b3B9cHhgXG4gICAgICAgICAgICBkZC5zdHlsZS5sZWZ0ID0gYCR7cG9zKGVsKS5sZWZ0fXB4YFxuICAgICAgICAgICAgZGQuc3R5bGUub3BhY2l0eSA9IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN3aXRjaENvbnRlbnQ6IChhdHRyKSA9PiB7XG4gICAgICAgICAgICBjb250LmZvckVhY2goZWwgPT4gZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJylcbiAgICAgICAgICAgIGNvbnQuZmlsdGVyKGVsID0+IGVsLmlkID09IGBkZF8ke2F0dHJ9YCkuZm9yRWFjaChlbCA9PiBlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGluaXRpYWw6IHNldEluaXRpYWwsIGhpZGU6IGhpZGUsIHNob3c6IHNob3csIHN3aXRjaENvbnRlbnQ6IHN3aXRjaENvbnRlbnQgfSA9IGZuXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJMaW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSBzdWJMaW5rW2ldLFxuICAgICAgICAgICAgY29udGVudCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5uYXYtZHJvcF9fc3ViJylcbiAgICAgICAgICBlbC5vbm1vdXNlb3ZlciA9ICgpID0+IHsgY29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJyB9XG4gICAgICAgICAgZWwub25tb3VzZWxlYXZlID0gKCkgPT4geyBjb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZScgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGQub25tb3VzZW92ZXIgPSAoZSkgPT4ge1xuICAgICAgICAgIGlmIChoaWRlRGVsYXlUaW1lKSB3aW5kb3cuY2xlYXJUaW1lb3V0KGhpZGVEZWxheVRpbWUpXG4gICAgICAgIH1cblxuICAgICAgICBkZC5vbm1vdXNlbGVhdmUgPSAoZSkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc2hvd0RlbGF5VGltZSlcbiAgICAgICAgICBoaWRlRGVsYXlUaW1lID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaGlkZSgpXG4gICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgYXJncy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgIGVsLm9ubW91c2VvdmVyID0gKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBlbC5kYXRhc2V0LmRyb3Bkb3duXG4gICAgICAgICAgICBpZiAoYXR0cikge1xuICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGhpZGVEZWxheVRpbWUpXG4gICAgICAgICAgICAgIHNob3dEZWxheVRpbWUgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoQ29udGVudChhdHRyKVxuICAgICAgICAgICAgICAgIHNob3coZWwpXG4gICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWwub25tb3VzZWxlYXZlID0gKGUpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc2hvd0RlbGF5VGltZSlcbiAgICAgICAgICAgIGhpZGVEZWxheVRpbWUgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGhpZGUoKVxuICAgICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgd2luZG93Lm9uc2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc2hvd0RlbGF5VGltZSlcbiAgICAgICAgICBoaWRlKCk7IHNldEluaXRpYWwoKVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW5pdGlhbCgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGVhZGVyIiwiY29uc3QgaGVyb1NwbGlkZSA9IHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmluaXRTcGxpZGUoKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coZXJyLm1lc3NhZ2UpXG4gICAgfVxuICB9LFxuICBpbml0U3BsaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgaGVyb1NwbGlkZSA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaGVyb19zcGxpZGUnKV1cbiAgICBpZiAoaGVyb1NwbGlkZS5sZW5ndGggIT09IDApIHtcbiAgICAgIGhlcm9TcGxpZGUuZm9yRWFjaCgoc2xpZGUpID0+IHtcbiAgICAgICAgbGV0IHNsaWRlciA9IG5ldyBTcGxpZGUoc2xpZGUsIHtcbiAgICAgICAgICB0eXBlOiBcInNsaWRlclwiLFxuICAgICAgICAgIHBlclBhZ2U6IDQsXG4gICAgICAgICAgcGVyTW92ZTogMixcbiAgICAgICAgICBhdXRvcGxheTogMCxcbiAgICAgICAgICBnYXA6IFwiMTJweFwiLFxuICAgICAgICAgIGFycm93czogMSxcbiAgICAgICAgICBwYWdpbmF0aW9uOiAwLFxuICAgICAgICAgIHNwZWVkOiA3NTAsXG4gICAgICAgICAgYnJlYWtwb2ludHM6IHtcbiAgICAgICAgICAgIDk5MTogeyBwZXJQYWdlOiAyLjUsIH0sXG4gICAgICAgICAgICA3Njc6IHsgcGVyUGFnZTogMiwgcGVyTW92ZTogMSB9LFxuICAgICAgICAgICAgNDc4OiB7IHBlclBhZ2U6IDEuNCwgcGVyTW92ZTogMSwgZ2FwOiA4IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHNsaWRlci5tb3VudCgpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhlcm9TcGxpZGUiLCJjb25zdCBwYWdlQWxlcnRzID0ge1xuICBjbGFzc2VzOiB7XG4gICAgZnVsbFdpZHRoOiAncGFnZS1hbGVydF9iYWNrZHJvcCcsXG4gICAgZXJyb3I6ICdwYWdlLWFsZXJ0X2Vycm9yJyxcbiAgICB3YXJuaW5nOiAncGFnZS1hbGVydF93YXJuaW5nJyxcbiAgICBpbmZvOiAncGFnZS1hbGVydF9pbmZvJyxcbiAgICB2aXNpYmxlOiAnaXMtdmlzaWJsZSdcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FjaGVET00oKVxuICAgIHRoaXMuYmluZEV2ZW50cygpXG4gICAgLy8gdGhpcy5mdWxsV2lkdGgoKVxuICB9LFxuICBjYWNoZURPTTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udGFpbmVyID0gJCgnLnBhZ2UtYWxlcnQnKVxuICAgIHRoaXMudGl0bGUgPSAkKCcucGFnZS1hbGVydC10aXRsZScpXG4gICAgdGhpcy5zdWJ0aXRsZSA9ICQoJy5wYWdlLWFsZXJ0LXRleHQnKVxuICAgIHRoaXMuY2xvc2UgPSAkKCdbZGF0YS1ldnQ9XCJoaWRlUGFnZUFsZXJ0XCJdJylcbiAgfSxcbiAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2xvc2UuY2xpY2sodGhpcy5oaWRlQWxlcnQuYmluZCh0aGlzKSlcbiAgICBjbGVhclRpbWVvdXQoYWxlcnRUaW1lcilcbiAgfSxcbiAgZnVsbFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3ModGhpcy5jbGFzc2VzLmZ1bGxXaWR0aClcbiAgfSxcbiAgc2hvd0FsZXJ0OiBmdW5jdGlvbiAoZXJyb3JUeXBlID0gZnVuY3Rpb24gKCkgeyBwYWdlQWxlcnRzLnJlc2V0QWxlcnQoKSB9LCB0aXRsZSwgdGV4dCwgaGlkZVRpbWUgPSAyNTAwKSB7XG4gICAgY2xlYXJUaW1lb3V0KGFsZXJ0VGltZXIpXG4gICAgdGhpcy5yZXNldEFsZXJ0KCk7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLmNsYXNzZXMudmlzaWJsZSkuYWRkQ2xhc3MoZXJyb3JUeXBlKVxuICAgIHRoaXMuY2hhbmdlTXNnKHRpdGxlLCB0ZXh0KVxuICAgIGFsZXJ0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBwYWdlQWxlcnRzLmhpZGVBbGVydCgpXG4gICAgfSwgaGlkZVRpbWUpXG4gIH0sXG4gIGhpZGVBbGVydDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMuY2xhc3Nlcy52aXNpYmxlKVxuICB9LFxuICBjaGFuZ2VNc2c6IGZ1bmN0aW9uICh0aXRsZSwgdGV4dCkge1xuICAgIHRoaXMudGl0bGUuaHRtbCh0aXRsZSlcbiAgICB0aGlzLnN1YnRpdGxlLmh0bWwodGV4dClcbiAgfSxcbiAgcmVzZXRBbGVydDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBpID0gcGFnZUFsZXJ0cy5jbGFzc2VzXG4gICAgICByZXR1cm4gYCR7aS53YXJuaW5nfSAke2kuaW5mb30gJHtpLmVycm9yfWBcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFnZUFsZXJ0cyIsImNvbnN0IHBhZ2VFbHMgPSBuZXcgT2JqZWN0KHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5hdHRhY2hFdmVudCkuZm9yRWFjaCgodGFyZ2V0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRhcmdldCgpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgYXR0YWNoRXZlbnQ6IHtcbiAgICAvLyBGbG9hdGluZyBXaGF0c2FwcCBCdXR0b25cbiAgICBvYnNlcnZlRmxvYXRXaGF0c2FwcCgpIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcud2EtZmxvYXQnKVxuICAgICAgY29uc3QgdHJpZ2dlckVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9vdGVyJylcbiAgICAgIGlmICghZWxlbSB8fCAhdHJpZ2dlckVsZW0pIHJldHVyblxuXG4gICAgICBsZXQgb2Zmc2V0ID0gMTIwXG4gICAgICBsZXQgb2JzZXJ2ZXIgPSBudWxsXG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGVudHJpZXMpID0+IHtcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKF9fSElEREVOKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoX19ISURERU4pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihjYWxsYmFjaywge1xuICAgICAgICByb290OiBudWxsLFxuICAgICAgICByb290TWFyZ2luOiBgMHB4IDBweCAtJHtvZmZzZXR9cHggMHB4YCxcbiAgICAgICAgdGhyZXNob2xkOiAwXG4gICAgICB9KVxuXG4gICAgICBvYnNlcnZlci5vYnNlcnZlKHRyaWdnZXJFbGVtKVxuICAgIH0sXG4gICAgLy8gQ29weSBFbGVtZW50c1xuICAgIGNvcHlFdmVudHM6ICgpID0+IHtcbiAgICAgIGNvbnN0IGNvcHlBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZXZ0LWNvcHldJyldXG4gICAgICBpZiAoY29weUFyci5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCBidG4gb2YgY29weUFycikge1xuICAgICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRUb0NvcHkgPSBidG4uZGF0YXNldC5ldnRDb3B5XG4gICAgICAgICAgICBpZiAodGV4dFRvQ29weSkge1xuICAgICAgICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0VG9Db3B5KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFRyYWNrIE9yZGVyXG4gICAgdHJhY2tPcmRlclN3aXRjaDogKCkgPT4ge1xuICAgICAgY29uc3QgYXJyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT1cInRyYWNrX3dpdGhcIl0nKVxuICAgICAgaWYgKGFyci5sZW5ndGgpIHtcblxuICAgICAgICBmdW5jdGlvbiB0b2dnbGVJbnB1dCh2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0ge1xuICAgICAgICAgICAgcGhvbmU6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNmb3JtX3RyYWNrX29yZGVyIC5pdGknKSxcbiAgICAgICAgICAgIGVtYWlsOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaW5wdXRfdHJhY2tfZW1haWwnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZWxlbWVudHMucGhvbmUgfHwgIWVsZW1lbnRzLmVtYWlsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdwaG9uZSBvciBlbWFpbCBub3QgZm91bmQnKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVsZW1lbnRzW3ZhbHVlXSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZWxlbWVudHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgZWxlbWVudHNba2V5XS5zdHlsZS5kaXNwbGF5ID0ga2V5ID09PSB2YWx1ZSA/ICdibG9jaycgOiAnbm9uZSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgdmFsdWU6ICR7dmFsdWV9YClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnIuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0b2dnbGVJbnB1dChpbnB1dC52YWx1ZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVzZXRUcmFja09yZGVyRm9ybTogKCkgPT4ge1xuICAgICAgY29uc3QgZWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWV2dD1cInJlc2V0X3RyYWNrX2Zvcm1cIl0nKVxuICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNmb3JtX3RyYWNrX29yZGVyJylcbiAgICAgICAgICBpZiAoIWZvcm0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Zvcm0gbm90IGZvdW5kJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcm0ucmVzZXQoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gT3RoZXJcbiAgICBmaWx0ZXJEcm9wZG93bjogKCkgPT4ge1xuICAgICAgbGV0IGRyb3Bkb3duRWxzID0gQXJyYXkuZnJvbSgkKCcuZmlsdGVyLWRyb3Bkb3duJykpXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJvcGRvd25FbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWwgPSBkcm9wZG93bkVsc1tpXTtcbiAgICAgICAgJChlbCkuaG92ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxldCB0aGlzQ3VycmVudCA9ICQodGhpcykuZmluZCgnLmZpbHRlci1kcm9wZG93bl9fY3VycmVudCcpLFxuICAgICAgICAgICAgbGlzdCA9ICQodGhpcykuZmluZCgnLmZpbHRlci1kcm9wZG93bl9fbGlzdCcpLFxuICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyID0gbGlzdC5maW5kKCc+IGRpdicpLFxuICAgICAgICAgICAgYnV0dG9ucyA9IEFycmF5LmZyb20oc2Nyb2xsQ29udGFpbmVyLmZpbmQoJz4gZGl2JykpLFxuICAgICAgICAgICAgbWFpbiA9ICQodGhpcykuZmluZCgnLmZpbHRlci1kcm9wZG93bl9fbWFpbicpXG5cbiAgICAgICAgICBjb25zdCBzY3JvbGxIID0gc2Nyb2xsQ29udGFpbmVyWzBdLnNjcm9sbEhlaWdodFxuXG4gICAgICAgICAgaWYgKGxpc3QuaGVpZ2h0KCkgPT0gMCkge1xuICAgICAgICAgICAgbGlzdC5jc3MoeyBoZWlnaHQ6IGAke3Njcm9sbEh9cHhgIH0pXG4gICAgICAgICAgICBtYWluLmFkZENsYXNzKElTX0FDVElWRSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5jc3MoeyBoZWlnaHQ6ICcwcHgnIH0pXG4gICAgICAgICAgICBtYWluLnJlbW92ZUNsYXNzKElTX0FDVElWRSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkLmVhY2goYnV0dG9ucywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGJ1dHRvbnNbaV0ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgbGV0IHNpYnMgPSAkKGJ1dHRvbnNbaV0pLnNpYmxpbmdzKClcbiAgICAgICAgICAgICAgc2licy5yZW1vdmVDbGFzcyhJU19BQ1RJVkUpXG4gICAgICAgICAgICAgIGJ1dHRvbnNbaV0uY2xhc3NMaXN0LmFkZChJU19BQ1RJVkUpXG5cbiAgICAgICAgICAgICAgbGV0IHZhbCA9ICQoYnV0dG9uc1tpXSkuaHRtbCgpXG4gICAgICAgICAgICAgIHRoaXNDdXJyZW50Lmh0bWwodmFsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgICB0cmFja2luZ0RhdGVVcGRhdGU6ICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGVzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRyYWNrPVwidXBkYXRlZF9kYXRlXCJdJyldXG4gICAgICBjb25zdCBub3dEYXRlID0gbmV3IERhdGUoKVxuXG4gICAgICBpZiAoZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRheSA9IG5vd0RhdGUuZ2V0RGF0ZSgpXG4gICAgICAgIGNvbnN0IG1vbnRoID0gbm93RGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLVVTJywgeyBtb250aDogJ3Nob3J0JyB9KVxuICAgICAgICBjb25zdCB5ZWFyID0gbm93RGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICAgIGxldCBob3VycyA9IG5vd0RhdGUuZ2V0SG91cnMoKVxuICAgICAgICBjb25zdCBtaW51dGVzID0gbm93RGF0ZS5nZXRNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpXG4gICAgICAgIGNvbnN0IGFtcG0gPSBob3VycyA+PSAxMiA/ICdQTScgOiAnQU0nXG4gICAgICAgIGhvdXJzID0gaG91cnMgJSAxMiB8fCAxMlxuXG4gICAgICAgIGZvciAoY29uc3QgZGF0ZSBvZiBkYXRlcykge1xuICAgICAgICAgIGRhdGUuaW5uZXJIVE1MID0gYCR7ZGF5fSAke21vbnRofSwgJHt5ZWFyfSwgJHtob3Vyc306JHttaW51dGVzfSAke2FtcG19YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwYWdlRmlsdGVyczogKCkgPT4ge1xuICAgICAgbGV0IGZpbHRlclJvd3MgPSBBcnJheS5mcm9tKCQoJy5maWx0ZXItcm93JykpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlclJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWwgPSAkKGZpbHRlclJvd3NbaV0pLFxuICAgICAgICAgIGhlYWRlciA9IGVsLmZpbmQoJy5maWx0ZXItcm93X19oZWFkZXInKSxcbiAgICAgICAgICBib2R5ID0gZWwuZmluZCgnLmZpbHRlci1yb3dfX2JvZHknKSxcbiAgICAgICAgICBjb250YWluZXIgPSBlbC5maW5kKCcuZmlsdGVyLXJvd19fY29udGFpbmVyJyksXG4gICAgICAgICAgaWNvbiA9IGhlYWRlci5maW5kKCdzdmcnKVxuXG4gICAgICAgIGhlYWRlci5jbGljaygoKSA9PiB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRCb2R5SGVpZ2h0ID0gYm9keS5oZWlnaHQoKVxuICAgICAgICAgIGlmIChjdXJyZW50Qm9keUhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgYm9keS5jc3MoeyBoZWlnaHQ6IGAke2N1cnJlbnRCb2R5SGVpZ2h0fXB4YCB9KVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGJvZHkuY3NzKHsgaGVpZ2h0OiAwIH0pXG4gICAgICAgICAgICAgIGNvbnRhaW5lci5jc3MoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC0yNHB4KScsIG9wYWNpdHk6IDAgfSlcbiAgICAgICAgICAgICAgaWNvbi5jc3MoeyB0cmFuc2Zvcm06ICdyb3RhdGUoMGRlZyknIH0pXG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNjcm9sbEggPSBjb250YWluZXJbMF0uc2Nyb2xsSGVpZ2h0XG4gICAgICAgICAgICBib2R5LmNzcyh7IGhlaWdodDogc2Nyb2xsSCB9KVxuICAgICAgICAgICAgY29udGFpbmVyLmNzcyh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMHB4KScsIG9wYWNpdHk6IDEgfSlcbiAgICAgICAgICAgIGljb24uY3NzKHsgdHJhbnNmb3JtOiAncm90YXRlKDE4MGRlZyknIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgZmFxTGlzdHM6ICgpID0+IHtcbiAgICAgIGNvbnN0IGhlYWRBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZhcS1oZWFkJyldXG4gICAgICBsZXQgbGlBcnIgPSBbXVxuICAgICAgZm9yIChjb25zdCBmYXFIZWFkIG9mIGhlYWRBcnIpIHtcbiAgICAgICAgY29uc3QgbGkgPSBmYXFIZWFkLmNsb3Nlc3QoJ2xpJylcbiAgICAgICAgY29uc3QgYm9keSA9IGZhcUhlYWQubmV4dEVsZW1lbnRTaWJsaW5nXG4gICAgICAgIGlmIChsaSAmJiBib2R5KSB7XG4gICAgICAgICAgbGlBcnIucHVzaChsaSlcbiAgICAgICAgICBsaS5zaG93ID0gKCkgPT4ge1xuICAgICAgICAgICAgbGkuY2xhc3NMaXN0LmFkZChfX0FDVElWRSlcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgICAgICAgICBib2R5LnN0eWxlLmhlaWdodCA9IGAke3Njcm9sbEhlaWdodH1weGBcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBib2R5LnN0eWxlLmhlaWdodCA9ICdhdXRvJ1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpLmhpZGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBsaS5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgICAgICAgICAgYm9keS5zdHlsZS5oZWlnaHQgPSAwXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmFxSGVhZC5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYm9keSlcbiAgICAgICAgICAgIGlmIChib2R5Lm9mZnNldEhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgICBsaS5oaWRlKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxpLnNob3coKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRyYW5zZm9ybSBsZXR0ZXJzXG4gICAgICAgICAgY29uc3QgaDYgPSBmYXFIZWFkLnF1ZXJ5U2VsZWN0b3IoJ2g2JylcbiAgICAgICAgICBpZiAoaDYpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcGl0YWxpemVkID0gaDYudGV4dENvbnRlbnQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oXFxiKShcXHcpL2csIChtYXRjaCwgcDEsIHAyKSA9PiBwMi50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgaDYudGV4dENvbnRlbnQgPSBjYXBpdGFsaXplZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJldmVhbCBmaXJzdFxuICAgICAgICAgIGlmIChsaUFyclswXSA9PT0gbGkpIGxpLnNob3coKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0aW5nczogKCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGluZ3MgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxpc3Rpbmctc2V0JyldXG4gICAgICBmb3IgKGNvbnN0IGxpc3Rpbmcgb2YgbGlzdGluZ3MpIHtcbiAgICAgICAgY29uc3QgYnV0dG9uQXJyYXkgPSBbLi4ubGlzdGluZy5xdWVyeVNlbGVjdG9yQWxsKCcubGlzdGluZy1idG46bm90KC4tLWRpc2FibGVkKScpXVxuICAgICAgICBidXR0b25BcnJheS5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBidG4uY2xhc3NMaXN0LmFkZChJU19BQ1RJVkUpXG4gICAgICAgICAgICBidXR0b25BcnJheS5mb3JFYWNoKChhcnJCdG4pID0+IHtcbiAgICAgICAgICAgICAgaWYgKGFyckJ0biAhPSBidG4pIGFyckJ0bi5jbGFzc0xpc3QucmVtb3ZlKElTX0FDVElWRSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZVplcm9TdWJoZWFkaW5nOiAoKSA9PiB7XG4gICAgICBjb25zdCBhcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnJlc3VsdHNfX3N1YmhlYWRpbmcnKV1cbiAgICAgIGZvciAoY29uc3Qgc3ViaGVhZGluZyBvZiBhcnIpIHtcbiAgICAgICAgaWYgKHN1YmhlYWRpbmcuaW5uZXJIVE1MLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICBzdWJoZWFkaW5nLnJlbW92ZSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGluaXRUZWxJbnB1dDogKCkgPT4ge1xuICAgICAgbGV0IHRlbElucHV0QXJyID0gQXJyYXkuZnJvbSgkKCdbZGF0YS1pbnB1dD1cInRlbFwiXScpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZWxJbnB1dEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGkgPSBpbnRsVGVsSW5wdXQodGVsSW5wdXRBcnJbaV0sIHtcbiAgICAgICAgICBpbml0aWFsQ291bnRyeTogXCJhdXRvXCIsXG4gICAgICAgICAgcHJlZmVycmVkQ291bnRyaWVzOiBbXCJ1c1wiLCBcImdiXCIsIFwiYnJcIiwgXCJjblwiLCBcImVzXCIsIFwiaXRcIl0sXG4gICAgICAgICAgYXV0b1BsYWNlaG9sZGVyOiBcImFnZ3Jlc3NpdmVcIixcbiAgICAgICAgICB1c2VGdWxsc2NyZWVuUG9wdXA6IHRydWUsXG4gICAgICAgICAgdXRpbHNTY3JpcHQ6XG4gICAgICAgICAgICBcIi9hc3NldHMvcHVibGljLTIwMjAvanMvcGx1Z2lucy9waG9uZS91dGlscy5qc1wiLFxuICAgICAgICAgIGdlb0lwTG9va3VwOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGZldGNoKFwiaHR0cHM6Ly9pcGluZm8uaW8vanNvblwiLCB7XG4gICAgICAgICAgICAgIGNhY2hlOiBcInJlbG9hZFwiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQ6IFwiICsgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnRoZW4oKGlwanNvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlwanNvbi5jb3VudHJ5KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soXCJ1c1wiKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0Q3VzdG9tVXBsb2FkczogKCkgPT4ge1xuICAgICAgdGhpcy5hcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY3VzdG9tLXVwbG9hZF0nKV1cblxuICAgICAgY29uc3QgcmVuZGVyT3V0cHV0RmlsZSA9IChmaWxlLCBpbWdTcmMgPSAnJykgPT4ge1xuICAgICAgICBsZXQgaW1nRWxlbSA9IGltZ1NyYyA/IGA8ZGl2IGNsYXNzPVwiLS1maWxsZWRcIiBzdHlsZT1cImJhY2tncm91bmQtaW1hZ2U6IHVybCgke2ltZ1NyY30pXCI+PC9kaXY+YCA6IGA8ZGl2PjwvZGl2PmBcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImN1c3RvbS11cGxvYWRfX2ZpbGVcIj5cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgJHtpbWdFbGVtfVxuICAgICAgICAgICAgPHNwYW4gZGF0YS1jdXN0b20tbmFtZT4ke2ZpbGUubmFtZX08L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS1ldnQ9XCJjdXN0b21fdXBsb2FkX3JlbW92ZVwiIGNsYXNzPVwiLS1yZW1vdmVcIj48L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIGBcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpbmRCb3hFdmVudHMgPSAoYm94LCBpbnB1dCkgPT4ge1xuICAgICAgICBib3gub25kcmFnb3ZlciA9IChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyBib3guY2xhc3NMaXN0LmFkZChfX0FDVElWRSlcbiAgICAgICAgfVxuICAgICAgICBib3gub25kcmFnbGVhdmUgPSAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgYm94LmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpXG4gICAgICAgIH1cbiAgICAgICAgYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgIGJveC5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgICAgICAgIGNvbnN0IGZpbGVzID0gZS5kYXRhVHJhbnNmZXIuZmlsZXNcbiAgICAgICAgICBjb25zdCBuZXdEYXRhVHJhbnNmZXIgPSBuZXcgRGF0YVRyYW5zZmVyKClcblxuICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgbmV3RGF0YVRyYW5zZmVyLml0ZW1zLmFkZChmaWxlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dC5maWxlcyA9IG5ld0RhdGFUcmFuc2Zlci5maWxlc1xuICAgICAgICAgIGlucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7ICdidWJibGVzJzogdHJ1ZSB9KSlcbiAgICAgICAgfSlcbiAgICAgICAgYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICBpbnB1dC5jbGljaygpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBjb25zdCBzZXRJbmRleGVzID0gKHVwbG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlcyA9IFsuLi51cGxvYWQucXVlcnlTZWxlY3RvckFsbCgnLmN1c3RvbS11cGxvYWRfX2ZpbGUnKV1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpbGVzW2ldLmRhdGFzZXQuY3VzdG9tSW5kZXggPSBpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2Nlc3NGaWxlcyA9IChmaWxlcywgdXBsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHVwbG9hZC5xdWVyeVNlbGVjdG9yKCcuY3VzdG9tLXVwbG9hZF9fZmlsZXMnKVxuICAgICAgICBjb25zdCBjdXJyZW50RmlsZXMgPSBbLi4udXBsb2FkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jdXN0b20tdXBsb2FkX19maWxlJyldXG5cbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGN1cnJlbnRGaWxlcykge1xuICAgICAgICAgIGZpbGUucmVtb3ZlKClcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgIGNvbnN0IGZpbGVJc0ltYWdlID0gZmlsZS50eXBlLm1hdGNoKCdpbWFnZS4qJylcbiAgICAgICAgICBpZiAoZmlsZUlzSW1hZ2UpIHtcbiAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgb3V0cHV0Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgcmVuZGVyT3V0cHV0RmlsZShmaWxlLCBlLnRhcmdldC5yZXN1bHQpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgcmVuZGVyT3V0cHV0RmlsZShmaWxlKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW5kZXhlcyh1cGxvYWQpXG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgdXBsb2FkIG9mIHRoaXMuYXJyKSB7XG4gICAgICAgIGNvbnN0IGJveCA9IHVwbG9hZC5xdWVyeVNlbGVjdG9yKCcuY3VzdG9tLXVwbG9hZF9fYm94JylcbiAgICAgICAgY29uc3QgaW5wdXQgPSB1cGxvYWQucXVlcnlTZWxlY3RvcignaW5wdXQnKVxuXG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICBiaW5kQm94RXZlbnRzKGJveCwgaW5wdXQpXG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbGVzID0gZS50YXJnZXQuZmlsZXNcbiAgICAgICAgICBwcm9jZXNzRmlsZXMoZmlsZXMsIHVwbG9hZClcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldFxuICAgICAgICBpZiAoZS50YXJnZXQuY2xvc2VzdCgnW2RhdGEtZXZ0PVwiY3VzdG9tX3VwbG9hZF9yZW1vdmVcIl0nKSkge1xuICAgICAgICAgIGNvbnN0IHVwbG9hZCA9IHRhcmdldC5jbG9zZXN0KCdbZGF0YS1jdXN0b20tdXBsb2FkXScpXG4gICAgICAgICAgaWYgKCF1cGxvYWQpIHRocm93IG5ldyBFcnJvcignZGF0YS1jdXN0b20tdXBsb2FkIG5vdCBmb3VuZCcpXG4gICAgICAgICAgY29uc3QgaW5wdXQgPSB1cGxvYWQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cImZpbGVcIl0nKVxuICAgICAgICAgIGlmICghaW5wdXQpIHRocm93IG5ldyBFcnJvcignaW5wdXRbdHlwZT1cImZpbGVcIl0gbm90IGZvdW5kJylcbiAgICAgICAgICBjb25zdCBuYW1lRWwgPSBlLnRhcmdldC5jbG9zZXN0KCcuY3VzdG9tLXVwbG9hZF9fZmlsZScpLnF1ZXJ5U2VsZWN0b3IoJypbZGF0YS1jdXN0b20tbmFtZV0nKVxuICAgICAgICAgIGlmICghbmFtZUVsKSB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEtY3VzdG9tLW5hbWUgbm90IGZvdW5kJylcblxuICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lRWwuaW5uZXJIVE1MXG4gICAgICAgICAgY29uc3QgbmV3RGF0YVRyYW5zZmVyID0gbmV3IERhdGFUcmFuc2ZlcigpXG4gICAgICAgICAgY29uc3QgeyBmaWxlcyB9ID0gaW5wdXRcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmaWxlc1tpXS5uYW1lICE9PSBuYW1lKSB7XG4gICAgICAgICAgICAgIG5ld0RhdGFUcmFuc2Zlci5pdGVtcy5hZGQoZmlsZXNbaV0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5ld0RhdGFUcmFuc2Zlci5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gJydcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQuZmlsZXMgPSBuZXdEYXRhVHJhbnNmZXIuZmlsZXNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyAnYnViYmxlcyc6IHRydWUgfSkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBhdHRhY2hQYXlNb2RhbDogKCkgPT4ge1xuICAgICAgbGV0IGV2dE9wZW5MYXRlciA9ICQoJ1tkYXRhLWV2dD1cInBheU1vZGFsTGF0ZXJcIl0nKSxcbiAgICAgICAgZXZ0T3BlbkNyeXB0byA9ICQoJ1tkYXRhLWV2dD1cInBheU1vZGFsQ3J5cHRvXCJdJyksXG4gICAgICAgIGV2dENsb3NlID0gJCgnW2RhdGEtZXZ0PVwiY2xvc2VQYXlNb2RhbFwiXScpLFxuICAgICAgICBjcnlwdG8gPSAkKCcjcGF5TW9kYWxDcnlwdG8nKSxcbiAgICAgICAgbGF0ZXIgPSAkKCcjcGF5TW9kYWxMYXRlcicpLFxuICAgICAgICBtb2RhbCA9ICQoJy5wYXktbW9kYWwnKVxuXG4gICAgICBjb25zdCBvcGVuTW9kYWwgPSAoKSA9PiB7XG4gICAgICAgIGxvY2tTY3JvbGwoKVxuICAgICAgICBtb2RhbC5zaG93KClcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgbW9kYWwuY3NzKHsgb3BhY2l0eTogMSB9KVxuICAgICAgICB9LCAxKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2xvc2VNb2RhbCA9ICgpID0+IHtcbiAgICAgICAgdW5sb2NrU2Nyb2xsKClcbiAgICAgICAgbW9kYWwuY3NzKHsgb3BhY2l0eTogMCB9KVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBtb2RhbC5oaWRlKClcbiAgICAgICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUobW9kYWwpKTtcbiAgICAgIH1cblxuICAgICAgZXZ0T3BlbkxhdGVyLmFkZChldnRPcGVuQ3J5cHRvKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9wZW5Nb2RhbCgpXG4gICAgICAgIGNyeXB0by5hZGQobGF0ZXIpLmhpZGUoKVxuICAgICAgICBpZiAoJCh0aGlzKS5pcyhldnRPcGVuQ3J5cHRvKSkge1xuICAgICAgICAgIGNyeXB0by5zaG93KClcbiAgICAgICAgfVxuICAgICAgICBpZiAoJCh0aGlzKS5pcyhldnRPcGVuTGF0ZXIpKSB7XG4gICAgICAgICAgbGF0ZXIuc2hvdygpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGV2dENsb3NlLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xvc2VNb2RhbCgpXG4gICAgICB9KVxuICAgIH0sXG4gICAgYXR0YWNoVG9nZ2xlSW5wdXRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBhcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtaW5wdXQtdG9nZ2xlXScpXVxuICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBhcnIpIHtcbiAgICAgICAgY29uc3QgYnRuID0gaW5wdXQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKCdidXR0b24nKSB8fCBpbnB1dC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJzdWJtaXRcIl0nKVxuICAgICAgICBpZiAoYnRuKSB7XG4gICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgYnRuLmRpc2FibGVkID0gZmFsc2VcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidG4uZGlzYWJsZWQgPSB0cnVlXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlJc0VudGVyID0gZS5rZXkgPT09ICdFbnRlcidcbiAgICAgICAgICAgIGlmIChrZXlJc0VudGVyKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICBidG4uY2xpY2soKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9ICcnXG4gICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnKSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0UHJvZHVjdFpvb206ICgpID0+IHtcbiAgICAgIGNvbnN0IGlzRGVza3RvcCA9IHdpbmRvdy5pbm5lcldpZHRoID4gOTkxXG4gICAgICB3aW5kb3cucmVtb3ZlU2xpZGVyID0gKHRhcmdldCkgPT4ge1xuICAgICAgICB1bmxvY2tTY3JvbGwoKVxuICAgICAgICBjb25zdCBzbGlkZXIgPSB0YXJnZXQuY2xvc2VzdCgnLnpvb21fc2xpZGVyJyk7IHNsaWRlci5jc3MoeyBvcGFjaXR5OiAwIH0pXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBzbGlkZXIuaGlkZSgpIH0sIDQwMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNldERlc2t0b3Bab29tID0gKCkgPT4ge1xuICAgICAgICBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnByb2R1Y3QtbWVkaWEtaW1nJyldLnJlZHVjZSgoYWNjLCBlbCkgPT4ge1xuICAgICAgICAgIGlmIChlbCAmJiBlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCEvKHBsYWNlaG9sZGVyfHN0b3JlfHBheSkvZ2kudGVzdChlbC5nZXRBdHRyaWJ1dGUoJ3NyYycpKSkge1xuICAgICAgICAgICAgICBhY2MucHVzaCgkKGVsKS5wYXJlbnQoJy5wcm9kdWN0LW1lZGlhX19pbm5lci13cmFwJykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgfSwgW10pLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgJChlbCkuem9vbSh7IG1hZ25pZnk6IDEuOSwgb246ICdjbGljaycgfSlcbiAgICAgICAgICAkKGVsKS5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHsgJChkb2N1bWVudCkudHJpZ2dlcignY2xpY2snKSB9KVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZXRNb2JpbGVab29tID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBzbGlkZXJzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcm9kdWN0LXNsaWRlcicpXSAvLyBHZXQgYWxsIGV4aXN0aW5nIHNsaWRlcnNcblxuICAgICAgICBzbGlkZXJzLmZvckVhY2goKHNsaWRlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBidXR0b24gPSAkKCc8YnV0dG9uLz4nLCB7IGNsYXNzOiBgcHJvZHVjdF9fem9vbS1idG4gem9vbV9idG4ke2luZGV4fWAgfSk7IGJ1dHRvbi5hcHBlbmRUbygkKHNsaWRlcikpIC8vIENyZWF0ZSAmIGFwcGVuZCB6b29tIGJ1dHRvblxuICAgICAgICAgIGNvbnN0IHJlbmRlck5ld1NsaWRlciA9IChzbGlkZXIsIGluZGV4KSA9PiB7IC8vIEdldCBIVE1MIG5ldyB6b29tIHNsaWRlclxuICAgICAgICAgICAgbGV0IG1lZGlhQXJyID0gWy4uLnNsaWRlci5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKV0ucmVkdWNlKChhY2MsIGltZykgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzcmMgPSBpbWcuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICAgICAgICAgICAgICBpZiAoIWFjYy5pbmNsdWRlcyhzcmMpICYmICEvKHBsYWNlaG9sZGVyfHN0b3JlfHBheSkvZ2kudGVzdChzcmMpKSB7IGFjYy5wdXNoKHNyYykgfVxuICAgICAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgICAgICB9LCBbXSkuc29ydCgpXG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyTWVkaWEgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBtZWRpYUFyci5yZWR1Y2UoKGFjYywgc3JjKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjICs9IGA8ZGl2IGNsYXNzPVwic3BsaWRlX19zbGlkZVwiPjxpbWcgc3JjPVwiJHtzcmN9XCI+PC9kaXY+YFxuICAgICAgICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgICAgICAgfSwgJycpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiem9vbV9zbGlkZXIgenNsJHtpbmRleH1cIj5cbiAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiem9vbV9zbGlkZXJfbG9nb1wiPjxpbWcgc3JjPVwiJHtTdHJpbmcucmF3YFxcdGhlbWVzXFxkZWZhdWx0XFxmcm9udGVuZFxcb2N0LTIwMjMvYXNzZXRzL2xvZ28uc3ZnYH1cIj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiem9vbV9zbGlkZXItY2xvc2VcIiBvbmNsaWNrPVwicmVtb3ZlU2xpZGVyKCQodGhpcykpXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInpvb20tc2wke2luZGV4fSBzcGxpZGVcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGxpZGVfX3RyYWNrXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGxpZGVfX2xpc3RcIj5cbiAgICAgICAgICAgICAgICAgICAgJHt0aGlzLnJlbmRlck1lZGlhKCl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BsaWRlX19hcnJvd3NcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwbGlkZV9fYXJyb3ctLXByZXZcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwbGlkZV9fYXJyb3ctLW5leHRcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PmBcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXBwZW5kTmV3U2xpZGVyID0gKGh0bWwpID0+IHsgJGJvZHkuYXBwZW5kKGh0bWwpIH0gLy8gQXBwZW5kIFpvb20gU2xpZGVyXG4gICAgICAgICAgY29uc3QgaW5pdE5ld1NsaWRlciA9IChpbmRleCkgPT4geyAvLyBTcGxpZGUgSW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibG9vcFwiLFxuICAgICAgICAgICAgICBwZXJQYWdlOiAxLFxuICAgICAgICAgICAgICBwZXJNb3ZlOiAxLFxuICAgICAgICAgICAgICBhdXRvcGxheTogMCxcbiAgICAgICAgICAgICAgZ2FwOiBcIjEycHhcIixcbiAgICAgICAgICAgICAgYXJyb3dzOiAxLFxuICAgICAgICAgICAgICBwYWdpbmF0aW9uOiAwLFxuICAgICAgICAgICAgICBzcGVlZDogODAwLFxuICAgICAgICAgICAgICBkcmFnOiBmYWxzZSxcbiAgICAgICAgICAgICAgZHJhZ0FuZ2xlVGhyZXNob2xkOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB6b29tU2xpZGVyID0gbmV3IFNwbGlkZShgLnpvb20tc2wke2luZGV4fWAsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgem9vbVNsaWRlci5tb3VudCgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGluaXRab29tID0gKGluZGV4KSA9PiB7IC8vIEluaXRpYWxpemUgalF1ZXJ5IHpvb20gZm9yIHRoZSBuZXcgc2xpZGVyXG4gICAgICAgICAgICBsZXQgc2xpZGVzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYC56b29tX3NsaWRlci56c2wke2luZGV4fWApLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zcGxpZGVfX3NsaWRlJyldXG4gICAgICAgICAgICBzbGlkZXMuZm9yRWFjaCgoc2xpZGUpID0+IHtcbiAgICAgICAgICAgICAgJChzbGlkZSkuem9vbSh7XG4gICAgICAgICAgICAgICAgbWFnbmlmeTogMS40LFxuICAgICAgICAgICAgICAgIG9uWm9vbUluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJy5zcGxpZGUnKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjZTZlYWVjJylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uWm9vbU91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCcuc3BsaWRlJykuY3NzKCdib3JkZXItY29sb3InLCAnIzAwOTVjNicpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2hvd05ld1NsaWRlciA9IChpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvY2FsU2xpZGVyID0gJChgLnpvb21fc2xpZGVyLnpzbCR7aW5kZXh9YClcbiAgICAgICAgICAgIGlmIChsb2NhbFNsaWRlcikgeyBsb2NhbFNsaWRlci5zaG93KCk7IGxvY2tTY3JvbGwoKTsgc2V0VGltZW91dCgoKSA9PiB7IGxvY2FsU2xpZGVyLmNzcyh7IG9wYWNpdHk6IDEgfSkgfSwgMSk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3BlblNsaWRlciA9IChpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNsaWRlciA9ICQoYC56b29tX3NsaWRlci56c2wke2luZGV4fWApXG4gICAgICAgICAgICBpZiAoc2xpZGVyKSB7IHNsaWRlci5zaG93KCk7IGxvY2tTY3JvbGwoKTsgc2V0VGltZW91dCgoKSA9PiB7IHNsaWRlci5jc3MoeyBvcGFjaXR5OiAxIH0pIH0sIDEpOyB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnV0dG9uLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU2xpZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLnpvb21fc2xpZGVyLnpzbCR7aW5kZXh9YClcbiAgICAgICAgICAgIGlmICghbG9jYWxTbGlkZXIpIHtcbiAgICAgICAgICAgICAgYXBwZW5kTmV3U2xpZGVyKHJlbmRlck5ld1NsaWRlcihzbGlkZXIsIGluZGV4KSlcbiAgICAgICAgICAgICAgaW5pdE5ld1NsaWRlcihpbmRleClcbiAgICAgICAgICAgICAgaW5pdFpvb20oaW5kZXgpXG4gICAgICAgICAgICAgIHNob3dOZXdTbGlkZXIoaW5kZXgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcGVuU2xpZGVyKGluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNldFpvb20gPSAoKSA9PiB7XG4gICAgICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW5fcHJvZHVjdF96b29tJykgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlzRGVza3RvcCAmJiAkKCcubWFpbl9wcm9kdWN0JykubGVuZ3RoKSB7IHNldERlc2t0b3Bab29tKCkgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0TW9iaWxlWm9vbSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0Wm9vbSgpXG4gICAgfSxcbiAgICBpbml0VGVzdFByb2R1Y3Rab29tOiAoKSA9PiB7XG4gICAgICBsZXQgem9vbU9wZW5Db3VudCA9IDBcblxuICAgICAgY29uc3Qgc2V0Wm9vbSA9ICgpID0+IHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICBzcmNJc1ZhbGlkID0gKHNyYykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICEvKHBsYWNlaG9sZGVyfHN0b3JlfHBheSkvZ2kudGVzdChzcmMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaWx0ZXJNZWRpYSA9IChhcnIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKChhY2MsIG1lZGlhKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgaW1nID0gbWVkaWEucXVlcnlTZWxlY3RvcignaW1nJyksXG4gICAgICAgICAgICAgICAgdGh1bWJBbmNlc3RvciA9IG1lZGlhLmNsb3Nlc3QoJy5wcm9kdWN0LXNsaWRlcl90aHVtYm5haWxzJyksXG4gICAgICAgICAgICAgICAgem9vbUFuY2VzdG9yID0gbWVkaWEuY2xvc2VzdCgnLnpvb20tbW9kYWwnKVxuXG4gICAgICAgICAgICAgIGlmIChpbWcgJiYgaW1nICE9PSBudWxsICYmIHRodW1iQW5jZXN0b3IgPT0gbnVsbCAmJiB6b29tQW5jZXN0b3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNyYyA9IGltZy5nZXRBdHRyaWJ1dGUoJ3NyYycpXG4gICAgICAgICAgICAgICAgaWYgKHNyY0lzVmFsaWQoc3JjKSkgeyBhY2MucHVzaChtZWRpYSkgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0U3JjQXJyID0gKGFycikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5yZWR1Y2UoKGFjYywgbWVkaWEpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaW1nID0gbWVkaWEucXVlcnlTZWxlY3RvcignaW1nJylcbiAgICAgICAgICAgICAgaWYgKGltZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbWcuaGFzQXR0cmlidXRlKCdzcmMnKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3JjID0gaW1nLmdldEF0dHJpYnV0ZSgnc3JjJylcbiAgICAgICAgICAgICAgICAgIGlmIChzcmNJc1ZhbGlkKHNyYykgJiYgIWFjYy5pbmNsdWRlcyhzcmMpKSB7IGFjYy5wdXNoKHNyYykgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbmRlclNsaWRlc0hUTUwgPSAoc3JjQXJyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3JjQXJyLnJlZHVjZSgoYWNjLCBzcmMpID0+IHtcbiAgICAgICAgICAgICAgYWNjICs9IGA8ZGl2IHN0eWxlPVwiY3Vyc29yOiB6b29tLWluXCIgY2xhc3M9XCJ6b29tLW1vZGFsX19zbGlkZSBzcGxpZGVfX3NsaWRlXCI+PGltZyBsb2FkaW5nPVwiZWFnZXJcIiBhbHQ9XCJcIiBzcmM9XCIke3NyY31cIj48L2Rpdj5gXG4gICAgICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgICAgIH0sICcnKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVuZGVyU3BsaWRlSFRNTCA9IChzbGlkZXNIVE1MKSA9PiB7XG4gICAgICAgICAgICBsZXQgcHJvZHVjdFRpdGxlID0gJCgnLnByb2R1Y3RfX2l0ZW0tdGl0bGUnKS5odG1sKCksXG4gICAgICAgICAgICAgIHByaWNlID0gJCgnLnByb2R1Y3RfX2l0ZW0tcHJpY2UnKS5lcSgtMSkuaHRtbCgpXG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ6b29tLW1vZGFsIHNwbGlkZVwiPlxuICAgICAgICAgICAgPGJ1dHRvbiBkYXRhLWV2dD1cImNsb3NlWm9vbU1vZGFsXCIgY2xhc3M9XCJ6b29tLW1vZGFsX19jbG9zZS1idG5cIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ6b29tLW1vZGFsX19ob2xkZXJcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwbGlkZV9fYXJyb3dzXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNwbGlkZV9fYXJyb3ctLXByZXZcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BsaWRlX19hcnJvdy0tbmV4dFwiPjwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInpvb20tbW9kYWxfX2hlYWRlclwiPlxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiJHtTdHJpbmcucmF3YFxcdGhlbWVzXFxkZWZhdWx0XFxmcm9udGVuZFxcb2N0LTIwMjMvYXNzZXRzL2xvZ28uc3ZnYH1cIiBsb2FkaW5nPVwibGF6eVwiIGFsdD1cIlwiPlxuICAgICAgICAgICAgICAgIDxpbWcgc3R5bGU9XCJkaXNwbGF5OiBub25lXCIgc3JjPVwiJHtTdHJpbmcucmF3YC4vYXNzZXRzL2xvZ28uc3ZnYH1cIiBsb2FkaW5nPVwibGF6eVwiIGFsdD1cIlwiPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInpvb20tbW9kYWxfX2Zvb3RlclwiPlxuICAgICAgICAgICAgICAgIDxoMSBjbGFzcz1cInpvb20tbW9kYWxfX25hbWVcIj4ke3Byb2R1Y3RUaXRsZX08L2gxPlxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBkYXRhLWV2dD1cImNsb3NlWm9vbU1vZGFsXCIgY2xhc3M9XCJ6b29tLW1vZGFsX19idXktYnRuXCIgb25jbGljaz1cImFkZFRvQ2FydCgpXCI+QWRkIFRvIENhcnQ8c3Bhbj4ke3ByaWNlfSBVU0Q8L3NwYW4+PC9hPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInpvb20tbW9kYWxfX3NsaWRlclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGxpZGVfX3RyYWNrXCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3BsaWRlX19saXN0XCI+XG4gICAgICAgICAgICAgICAgICAgICR7c2xpZGVzSFRNTH1cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIGBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluaXRab29tU2xpZGVyID0gKGluZGV4VG9HbyA9IDApID0+IHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgIHNldHRpbmdzID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibG9vcFwiLFxuICAgICAgICAgICAgICAgIHBlclBhZ2U6IDEsXG4gICAgICAgICAgICAgICAgcGVyTW92ZTogMSxcbiAgICAgICAgICAgICAgICBhdXRvcGxheTogMCxcbiAgICAgICAgICAgICAgICBnYXA6IFwiMTJweFwiLFxuICAgICAgICAgICAgICAgIGFycm93czogMSxcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uOiAwLFxuICAgICAgICAgICAgICAgIHNwZWVkOiA4MDAsXG4gICAgICAgICAgICAgICAgZHJhZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJhZ0FuZ2xlVGhyZXNob2xkOiAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNsaWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy56b29tLW1vZGFsJylcbiAgICAgICAgICAgIGlmIChzbGlkZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3Qgem9vbVNsaWRlciA9IG5ldyBTcGxpZGUoJy56b29tLW1vZGFsJywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICB6b29tU2xpZGVyLm1vdW50KClcbiAgICAgICAgICAgICAgem9vbVNsaWRlci5nbyhpbmRleFRvR28pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbml0UHJlc3Nab29tID0gKHNsaWRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVzID0gWy4uLnNsaWRlci5xdWVyeVNlbGVjdG9yQWxsKCcuc3BsaWRlX19zbGlkZScpXSxcbiAgICAgICAgICAgICAgem9vbVZhbHVlID0gd2luZG93LmlubmVyV2lkdGggPiA0NzkgPyAyLjIgOiAxLjZcbiAgICAgICAgICAgIHNsaWRlcy5mb3JFYWNoKChzbGlkZSkgPT4ge1xuICAgICAgICAgICAgICAkKHNsaWRlKS56b29tKHtcbiAgICAgICAgICAgICAgICBtYWduaWZ5OiB6b29tVmFsdWUsXG4gICAgICAgICAgICAgICAgb246ICdncmFiJyxcbiAgICAgICAgICAgICAgICBvblpvb21JbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgJCgnLnpvb20tbW9kYWwgLnNwbGlkZV9fYXJyb3dzJykuY3NzKHsgb3BhY2l0eTogMCB9KVxuICAgICAgICAgICAgICAgICAgJCgnLnpvb20taGludCcpLmNzcyh7IG9wYWNpdHk6IDAgfSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uWm9vbU91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgJCgnLnpvb20tbW9kYWwgLnNwbGlkZV9fYXJyb3dzJykuY3NzKHsgb3BhY2l0eTogMSB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lZGlhQXJyID0gZmlsdGVyTWVkaWEoWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcm9kdWN0LW1lZGlhJyldKVxuXG4gICAgICAgIG1lZGlhQXJyLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgZWwub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGxvY2tTY3JvbGwoKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBzaWJTcmNBcnIgPSBnZXRTcmNBcnIoZmlsdGVyTWVkaWEoWy4uLmVsLnBhcmVudE5vZGUuY2xvc2VzdCgnZGl2JykucXVlcnlTZWxlY3RvckFsbCgnLnByb2R1Y3QtbWVkaWEnKV0pKSxcbiAgICAgICAgICAgICAgICBzcGxpZGVIVE1MID0gcmVuZGVyU3BsaWRlSFRNTChyZW5kZXJTbGlkZXNIVE1MKHNpYlNyY0FycikpXG5cbiAgICAgICAgICAgICAgJGJvZHkuYXBwZW5kKHNwbGlkZUhUTUwpXG4gICAgICAgICAgICAgIGluaXRab29tU2xpZGVyKHNpYlNyY0Fyci5pbmRleE9mKGVsLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpLmdldEF0dHJpYnV0ZSgnc3JjJykpKVxuXG4gICAgICAgICAgICAgIGxldCB6b29tTW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuem9vbS1tb2RhbCcpLFxuICAgICAgICAgICAgICAgIGhvbGRlciA9IHpvb21Nb2RhbC5xdWVyeVNlbGVjdG9yKCcuem9vbS1tb2RhbF9faG9sZGVyJylcbiAgICAgICAgICAgICAgaW5pdFByZXNzWm9vbSh6b29tTW9kYWwpXG5cbiAgICAgICAgICAgICAgbGV0IHpvb21IaW50ID0gJCgnPFxcZGl2PicsIHsgY2xhc3M6ICd6b29tLWhpbnQnIH0pXG5cbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgem9vbU1vZGFsLnN0eWxlLm9wYWNpdHkgPSAxXG4gICAgICAgICAgICAgICAgaWYgKHpvb21PcGVuQ291bnQgPD0gMSkgeyAkKGhvbGRlcikuYXBwZW5kKHpvb21IaW50KTsgc2V0VGltZW91dCgoKSA9PiB7IHpvb21IaW50LmNzcyh7IG9wYWNpdHk6IDEgfSkgfSwgNTAwKSB9XG4gICAgICAgICAgICAgIH0sIDEpO1xuXG4gICAgICAgICAgICAgIHpvb21Nb2RhbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgem9vbUhpbnQuY3NzKHsgb3BhY2l0eTogMCB9KTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHpvb21IaW50LnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgfSwgNDUwKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBkb2N1bWVudC5vbmtleWRvd24gPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudFxuICAgICAgICAgICAgICAgIGxldCBpc0VzYyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgaWYgKCdrZXknIGluIGUpIHtcbiAgICAgICAgICAgICAgICAgIGlzRXNjID0gKGUua2V5ID09PSBcIkVzY2FwZVwiIHx8IGUua2V5ID09PSBcIkVzY1wiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNFc2MgPSAoZS5rZXlDb2RlID09PSAyNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0VzYykge1xuICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICB1bmxvY2tTY3JvbGwoKVxuICAgICAgICAgICAgICAgICAgbGV0IG1vZGFsID0gJCgnLnpvb20tbW9kYWwnKVxuICAgICAgICAgICAgICAgICAgaWYgKG1vZGFsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RhbC5jc3MoeyBvcGFjaXR5OiAwIH0pXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIG1vZGFsLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKG1vZGFsKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHpvb21PcGVuQ291bnQrK1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlMgOiBJbml0IFByb2R1Y3QgWm9vbSBFcnJvcicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICdbZGF0YS1ldnQ9XCJjbG9zZVpvb21Nb2RhbFwiXScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1bmxvY2tTY3JvbGwoKVxuICAgICAgICAgIGxldCBtb2RhbCA9ICQoJy56b29tLW1vZGFsJylcbiAgICAgICAgICBpZiAobW9kYWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBtb2RhbC5jc3MoeyBvcGFjaXR5OiAwIH0pXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgbW9kYWwucmVtb3ZlKClcbiAgICAgICAgICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKG1vZGFsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW5fcHJvZHVjdF96b29tJykgIT09IG51bGwpIHsgc2V0Wm9vbSgpIH1cbiAgICB9LFxuICAgIGF0dGFjaFN0aWNreVNjcm9sbDogKCkgPT4ge1xuICAgICAgY29uc3QgYmFyID0gJCgnLmZpbHRlci1zaWRlYmFyJyksIG92ZXJsYXkgPSAkKCcuZmlsdGVyLXNpZGViYXJfX292ZXJsYXknKVxuICAgICAgaWYgKGJhci5sZW5ndGggJiYgb3ZlcmxheS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZWxzID0gYmFyLmZpbmQoJy5maWx0ZXItcm93JylcbiAgICAgICAgJC5lYWNoKGVscywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICBlbHNbaV0ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBjb250ID0gJCh0aGlzKS5maW5kKCcuZmlsdGVyLXJvd19fY29udGFpbmVyJylcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBsZXQgY3VycmVudEhlaWdodCA9IGJhci5oZWlnaHQoKVxuICAgICAgICAgICAgICBsZXQgc2Nyb2xsSGVpZ2h0ID0gYmFyWzBdLnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRIZWlnaHQgLSBzY3JvbGxIZWlnaHQpIDw9IC01KSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheS5jc3MoeyBvcGFjaXR5OiAxIH0pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheS5jc3MoeyBvcGFjaXR5OiAwIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKGNvbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGJhclswXS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCArIHRoaXMuY2xpZW50SGVpZ2h0ID49IHRoaXMuc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgICAgICBvdmVybGF5LmNzcyh7IG9wYWNpdHk6IDAgfSlcbiAgICAgICAgICB9IGVsc2UgeyBvdmVybGF5LmNzcyh7IG9wYWNpdHk6IDEgfSkgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgYXR0YWNoQ2hlY2tvdXRDb3B5OiAoKSA9PiB7XG4gICAgICBjb25zdCBidG5BcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNyeXB0by1ob3ctYnRuJyksIC4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jb3B5LWFkZHJlc3MtYnRuJyldXG4gICAgICBpZiAoYnRuQXJyLmxlbmd0aCkge1xuICAgICAgICBidG5BcnIuZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICAgICAgYnRuLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgIGxldCBkZXRhaWxzID0gYnRuLmNsb3Nlc3QoJy5jaGVja291dC1mb3JtX19yYWRpby1kZXRhaWxzJylcbiAgICAgICAgICAgICAgaWYgKGRldGFpbHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkcmVzcyA9IGRldGFpbHMucXVlcnlTZWxlY3RvcignLmNvcHktYWRkcmVzcy1idG5fX3R5cG8nKS5pbm5lckhUTUxcbiAgICAgICAgICAgICAgICBhc3luYyBmdW5jdGlvbiBjb3B5QWRkcmVzcygpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLmNsYXNzTGlzdC5hZGQoSVNfQ09QSUVEKVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLmNsYXNzTGlzdC5yZW1vdmUoSVNfQ09QSUVEKVxuICAgICAgICAgICAgICAgICAgICB9LCAxMzAwKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLmNsYXNzTGlzdC5yZW1vdmUoSVNfQ09QSUVELCBJU19FUlJPUilcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5jbGFzc0xpc3QucmVtb3ZlKElTX0NPUElFRCwgSVNfRVJST1IpXG4gICAgICAgICAgICAgICAgICAgIH0sIDIxMDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3B5QWRkcmVzcygpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgICBhZGp1c3RTdGlja3lFbHM6ICgpID0+IHtcbiAgICAgIGNvbnN0IGVsc0FyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZmlsdGVyLXNpZGViYXIudG8tc3RpY2snKSwgLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnN0aWNreS1maWx0ZXJzJyldXG4gICAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaGVhZGVyJylcblxuICAgICAgaWYgKGVsc0Fyci5sZW5ndGggJiYgaGVhZGVyKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFkanVzdCgpIHtcbiAgICAgICAgICBsZXQgaGVhZGVySGVpZ2h0ID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoaGVhZGVyKS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKSlcbiAgICAgICAgICBlbHNBcnIuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICAgIGxldCB0b3BWYWx1ZSA9ICQod2luZG93KS53aWR0aCgpID4gOTkxID8gaGVhZGVySGVpZ2h0ICsgMjQgOiBoZWFkZXJIZWlnaHRcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZWwuc3R5bGUsIHsgdG9wOiBgJHt0b3BWYWx1ZX1weGAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIFsnbG9hZCcsICdyZXNpemUnXS5mb3JFYWNoKChldmVudCkgPT4geyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgKCkgPT4geyBhZGp1c3QoKSB9KSB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgYmluZENhcmRGYXY6ICgpID0+IHtcbiAgICAgIGNvbnN0IGJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FyZC1pdGVtLWZhdicpXG4gICAgICBidXR0b25zLmZvckVhY2goYnRuID0+IGJ0bi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAoYnRuLmNsYXNzTGlzdC5jb250YWlucyhJU19BQ1RJVkUpKSB7XG4gICAgICAgICAgYnRuLmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ0bi5jbGFzc0xpc3QuYWRkKElTX0FDVElWRSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIG9ic2VydmVTbWFydFBpY3R1cmVzOiAoKSA9PiB7XG4gICAgICBjb25zdCBhcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNtYXJ0LXBpY3R1cmUnKV1cbiAgICAgIGZvciAoY29uc3QgZWwgb2YgYXJyKSB7XG4gICAgICAgIGNvbnN0IGltZyA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpXG4gICAgICAgIGlmICghaW1nKSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChfX0xPQURFRClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaW1nLmNvbXBsZXRlIHx8IGltZy5zcmMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKF9fTE9BREVEKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChfX0xPQURFRClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhZ2VFbHMiLCJjb25zdCBwYWdlUmV2aWV3cyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1yZXZpZXdzLnNwbGlkZScpICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmluaXRTcGxpZGUoKVxuICAgIH1cbiAgfSxcbiAgaW5pdFNwbGlkZTogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgbWFpbiA9IG5ldyBTcGxpZGUoJy5wYWdlLXJldmlld3MnLCB7XG4gICAgICAgIHR5cGU6IFwic2xpZGVyXCIsXG4gICAgICAgIHBlclBhZ2U6IDMuNCxcbiAgICAgICAgcGVyTW92ZTogMSxcbiAgICAgICAgYXV0b3BsYXk6IDAsXG4gICAgICAgIHBhdXNlT25Ib3ZlcjogMSxcbiAgICAgICAgcGF1c2VPbkZvY3VzOiAxLFxuICAgICAgICBnYXA6IDEyLFxuICAgICAgICBhcnJvd3M6IDEsXG4gICAgICAgIHBhZ2luYXRpb246IDEsXG4gICAgICAgIHNwZWVkOiA1MDAsXG4gICAgICAgIGJyZWFrcG9pbnRzOiB7XG4gICAgICAgICAgOTkxOiB7XG4gICAgICAgICAgICBwZXJQYWdlOiAyLjJcbiAgICAgICAgICB9LFxuICAgICAgICAgIDYyMDoge1xuICAgICAgICAgICAgcGVyUGFnZTogMS4zXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgbWFpbi5tb3VudCgpXG4gICAgfSBjYXRjaCB7XG4gICAgICBjb25zb2xlLmxvZygnUGFnZSBSZXZpZXcgU1BMSURFIEVSUicpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFnZVJldmlld3MiLCJjb25zdCBwZ01vZGFsID0gbmV3IE9iamVjdCh7XG4gIGluaXRpYWxpemVkOiB1bmRlZmluZWQsXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbmRlckRPTSgpO1xuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5pbml0Rm4pLmZvckVhY2goKHRhcmdldCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIikgdGFyZ2V0KCk7XG4gICAgfSk7XG4gICAgdGhpcy5pbnRpYWxpemVkID0gdHJ1ZTtcbiAgfSxcblxuICByZW5kZXJET006IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSb290XG4gICAgdGhpcy5tb2RhbCA9ICQoXCIucGctbW9kYWxcIik7XG4gICAgdGhpcy5jb250YWluZXIgPSAkKFwiLnBnLW1vZGFsX19jb250YWluZXJcIik7XG4gICAgdGhpcy5iYWNrZHJvcCA9ICQoXCIucGctbW9kYWxfX2JhY2tkcm9wXCIpO1xuICAgIHRoaXMuY2xvc2UgPSAkKCdbZGF0YS1ldnQ9XCJjbG9zZVBnTW9kYWxcIl0nKTtcblxuICAgIC8vIFNlY3Rpb25zXG4gICAgdGhpcy5zZWN0aW9uID0gJChcIi5wZy1zZWN0aW9uXCIpO1xuICAgIHRoaXMucm93ID0gJChcIi5wZy1yb3dcIik7XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIgPSAkKFwiLnBnLW1vZGFsX19vdmVyc2Nyb2xsXCIpO1xuICAgIHRoaXMuc2VjdGlvbkJyYWNlbGV0cyA9IHRoaXMuc2VjdGlvbi5maWx0ZXIoXCIjcGdCcmFjZWxldHNcIik7XG4gICAgdGhpcy5zZWN0aW9uRGlhbW9uZHMgPSB0aGlzLnNlY3Rpb24uZmlsdGVyKFwiI3BnRGlhbW9uZHNcIik7XG4gICAgdGhpcy5zZWN0aW9uUmluZ3MgPSB0aGlzLnNlY3Rpb24uZmlsdGVyKFwiI3BnUmluZ3NcIik7XG4gICAgdGhpcy5zZWN0aW9uTmVja2xhY2VzID0gdGhpcy5zZWN0aW9uLmZpbHRlcihcIiNwZ05lY2tsYWNlc1wiKTtcblxuICAgIC8vIENvbnRyb2xzXG4gICAgdGhpcy5zd2l0Y2hCdG4gPSAkKFwiLnBnLXN3aXRjaC1idG5cIik7XG5cbiAgICAvLyBTZWxlY3QgVGFic1xuICAgIHRoaXMuc2VsZWN0QXJyID0gQXJyYXkuZnJvbSgkKFwiLnBnLXNlbGVjdFwiKSk7XG4gICAgdGhpcy5zZWxlY3RCdG4gPSAkKFwiLnBnLXNlbGVjdC1idG5cIik7XG4gIH0sXG4gIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsb3NlLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHBnTW9kYWwuZm4uY2xvc2VNb2RhbCgpO1xuICAgIH0pO1xuICB9LFxuXG4gIGZuOiB7XG4gICAgb3Blbk1vZGFsOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBsb2NrU2Nyb2xsKCk7XG4gICAgICBwZ01vZGFsLm1vZGFsLnNob3coKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBwZ01vZGFsLmJhY2tkcm9wLmNzcyh7IG9wYWNpdHk6IDEgfSk7XG4gICAgICAgIHBnTW9kYWwuY29udGFpbmVyLnJlbW92ZUNsYXNzKFwiaXMtaGlkZGVuXCIpO1xuICAgICAgfSwgMSk7XG4gICAgICBsZXQgYXR0ID0gJCh0YXJnZXQpLmF0dHIoXCJkYXRhLXBnLW9wZW5cIik7XG4gICAgICBwZ01vZGFsLnNlY3Rpb24uaGlkZSgpO1xuICAgICAgc3dpdGNoIChhdHQpIHtcbiAgICAgICAgY2FzZSBcImRpYW1vbmRzXCI6XG4gICAgICAgICAgcGdNb2RhbC5zZWN0aW9uRGlhbW9uZHMuc2hvdygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmluZ3NcIjpcbiAgICAgICAgICBwZ01vZGFsLnNlY3Rpb25SaW5ncy5zaG93KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJicmFjZWxldHNcIjpcbiAgICAgICAgICBwZ01vZGFsLnNlY3Rpb25CcmFjZWxldHMuc2hvdygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibmVja2xhY2VzXCI6XG4gICAgICAgICAgcGdNb2RhbC5zZWN0aW9uTmVja2xhY2VzLnNob3coKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwZ01vZGFsLnNlY3Rpb25bMF0uc2hvdygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGdNb2RhbC5zY3JvbGxDb250YWluZXJbMF0uc2Nyb2xsVG9wID0gMDtcbiAgICAgIHBnU2VsZWN0LmF0dGFjaENvbnRyb2xzKHBnTW9kYWwuc2VsZWN0QXJyLCBwZ01vZGFsLnNlbGVjdEJ0bik7XG4gICAgfSxcbiAgICBjbG9zZU1vZGFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxvY2tTY3JvbGwoKTtcbiAgICAgIHBnTW9kYWwuYmFja2Ryb3AuY3NzKHsgb3BhY2l0eTogMCB9KTtcbiAgICAgIHBnTW9kYWwuY29udGFpbmVyLmFkZENsYXNzKFwiaXMtaGlkZGVuXCIpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHBnTW9kYWwubW9kYWwuaGlkZSgpO1xuICAgICAgfSwgNDc1KTtcbiAgICB9LFxuICAgIHNldE1vYmlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCQod2luZG93KS53aWR0aCgpIDwgNDgwKSB7XG4gICAgICAgIGxldCBhcnIgPSBBcnJheS5mcm9tKHBnTW9kYWwuc2VjdGlvbik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IG5BcnIgPSBBcnJheS5mcm9tKCQoYXJyW2ldKS5maW5kKHBnTW9kYWwucm93KSk7XG4gICAgICAgICAgJC5lYWNoKG5BcnIsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgJChuQXJyW2ldKS5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGF0dGFjaFNlY3Rpb25Db250cm9sczogZnVuY3Rpb24gKCkge1xuICAgICAgcGdNb2RhbC5zZWN0aW9uLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgYnRuQXJyID0gWy4uLiQodGhpcykuZmluZChwZ01vZGFsLnN3aXRjaEJ0bildO1xuICAgICAgICBsZXQgcm93QXJyID0gWy4uLiQodGhpcykuZmluZChwZ01vZGFsLnJvdyldO1xuICAgICAgICAkLmVhY2goYnRuQXJyLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIGJ0bkFycltpXS5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgJC5lYWNoKHJvd0FyciwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgJChyb3dBcnJbaV0pLmhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJC5lYWNoKGJ0bkFyciwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgJChidG5BcnJbaV0pLnJlbW92ZUNsYXNzKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgJChyb3dBcnJbaV0pLnNob3coKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG5cbiAgaW5pdEZuOiB7XG4gICAgc2V0SW5pdGlhbDogKCkgPT4ge1xuICAgICAgcGdNb2RhbC5mbi5jbG9zZU1vZGFsKCk7XG4gICAgICBwZ01vZGFsLmZuLnNldE1vYmlsZSgpO1xuICAgICAgcGdNb2RhbC5mbi5hdHRhY2hTZWN0aW9uQ29udHJvbHMoKTtcbiAgICB9LFxuICB9LFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBwZ01vZGFsIiwiY29uc3QgcGdTZWxlY3QgPSB7XG4gIGluaXRhbGl6ZWQ6IHVuZGVmaW5lZCxcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyRE9NKCk7XG4gICAgdGhpcy5pbml0YWxpemVkID0gdHJ1ZTtcbiAgfSxcbiAgZ2V0QXR0ckRPTTogZnVuY3Rpb24gKGF0dCkge1xuICAgIHJldHVybiAkKGBbZGF0YS1wZy1zZXQ9XCIke2F0dH1cIl1gKTtcbiAgfSxcbiAgcmVuZGVyRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2hhcGVcbiAgICB0aGlzLnNoYXBlSW1nID0gdGhpcy5nZXRBdHRyRE9NKFwic2hhcGVJbWdcIik7XG4gICAgdGhpcy5zaGFwZVRpdGxlID0gdGhpcy5nZXRBdHRyRE9NKFwic2hhcGVUaXRsZVwiKTtcbiAgICB0aGlzLnNoYXBlRGVzY3JpcHRpb24gPSB0aGlzLmdldEF0dHJET00oXCJzaGFwZURlc2NyaXB0aW9uXCIpO1xuXG4gICAgLy8gQ29sb3JcbiAgICB0aGlzLmNvbG9ySW1nID0gdGhpcy5nZXRBdHRyRE9NKFwiY29sb3JJbWdcIik7XG4gICAgdGhpcy5jb2xvclRpdGxlID0gdGhpcy5nZXRBdHRyRE9NKFwiY29sb3JUaXRsZVwiKTtcbiAgICB0aGlzLmNvbG9yRGVzY3JpcHRpb24gPSB0aGlzLmdldEF0dHJET00oXCJjb2xvckRlc2NyaXB0aW9uXCIpO1xuXG4gICAgLy8gQ2xhcml0eVxuICAgIHRoaXMuY2xhcml0eUltZyA9IHRoaXMuZ2V0QXR0ckRPTShcImNsYXJpdHlJbWdcIik7XG4gICAgdGhpcy5jbGFydHlUaXRsZSA9IHRoaXMuZ2V0QXR0ckRPTShcImNsYXJpdHlUaXRsZVwiKTtcbiAgICB0aGlzLmNsYXJpdHlEZXNjcmlwdGlvbiA9IHRoaXMuZ2V0QXR0ckRPTShcImNsYXJpdHlEZXNjcmlwdGlvblwiKTtcblxuICAgIC8vIFJpbmcgU2l6ZVxuICAgIHRoaXMuY3VycmVudFNpemUgPSB0aGlzLmdldEF0dHJET00oXCJjdXJyZW50U2l6ZVwiKTtcbiAgICB0aGlzLmNpcmNTaXplID0gdGhpcy5nZXRBdHRyRE9NKFwiY2lyY1NpemVcIik7XG4gICAgdGhpcy5kU2l6ZSA9IHRoaXMuZ2V0QXR0ckRPTShcImRTaXplXCIpO1xuICAgIHRoaXMuZXVTaXplID0gdGhpcy5nZXRBdHRyRE9NKFwiZXVTaXplXCIpO1xuICAgIHRoaXMudWtTaXplID0gdGhpcy5nZXRBdHRyRE9NKFwidWtTaXplXCIpO1xuICB9LFxuICBhdHRhY2hDb250cm9sczogZnVuY3Rpb24gKHNBcnIsIHNCdG4pIHtcbiAgICBpZiAoIXRoaXMuaW5pdGFsaXplZCkge1xuICAgICAgcGdTZWxlY3QuaW5pdCgpO1xuICAgIH1cbiAgICBsZXQgc2VsZWN0QXJyID0gc0FycixcbiAgICAgIHNlbGVjdEJ0biA9IHNCdG47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0aGlzQXR0ciA9IHNlbGVjdEFycltpXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBnLXNlbGVjdFwiKSxcbiAgICAgICAgYnRuQXJyID0gQXJyYXkuZnJvbSgkKHNlbGVjdEFycltpXSkuZmluZChzZWxlY3RCdG4pKTtcblxuICAgICAgZnVuY3Rpb24gc2V0UGdTZWxlY3RFdmVudCgpIHtcbiAgICAgICAgbGV0IGRhdGFTZXQ7XG4gICAgICAgIHN3aXRjaCAodGhpc0F0dHIpIHtcbiAgICAgICAgICBjYXNlIFwic2hhcGVcIjpcbiAgICAgICAgICAgIGRhdGFTZXQgPSBwZ1NlbGVjdC5zaGFwZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgICAgICAgZGF0YVNldCA9IHBnU2VsZWN0LmNvbG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNsYXJpdHlcIjpcbiAgICAgICAgICAgIGRhdGFTZXQgPSBwZ1NlbGVjdC5jbGFyaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJpbmctc2l6ZVwiOlxuICAgICAgICAgICAgZGF0YVNldCA9IHBnU2VsZWN0LnJpbmdTaXplO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YVNldCB9O1xuICAgICAgfVxuXG4gICAgICAkLmVhY2goYnRuQXJyLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICBidG5BcnJbaV0ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICBzZXRQZ1NlbGVjdEV2ZW50KCkuZGF0YVNldC5jaGFuZ2VEZXRhaWxzKGkpO1xuICAgICAgICAgICQuZWFjaChidG5BcnIsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICBidG5BcnJbaV0uY2xhc3NMaXN0LnJlbW92ZShcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBzaGFwZToge1xuICAgIGNoYW5nZURldGFpbHM6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcGdTZWxlY3Quc2hhcGVJbWcuYXR0cihcInNyY1wiLCBwZ1NlbGVjdC5kYXRhLnNoYXBlW2luZGV4XS51cmwpO1xuICAgICAgcGdTZWxlY3Quc2hhcGVUaXRsZS5odG1sKHBnU2VsZWN0LmRhdGEuc2hhcGVbaW5kZXhdLnRpdGxlKTtcbiAgICAgIHBnU2VsZWN0LnNoYXBlRGVzY3JpcHRpb24uaHRtbChwZ1NlbGVjdC5kYXRhLnNoYXBlW2luZGV4XS5kZXNjcmlwdGlvbik7XG4gICAgfSxcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBjaGFuZ2VEZXRhaWxzOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHBnU2VsZWN0LmNvbG9ySW1nLmF0dHIoXCJzcmNcIiwgcGdTZWxlY3QuZGF0YS5jb2xvcltpbmRleF0udXJsKTtcbiAgICAgIHBnU2VsZWN0LmNvbG9yVGl0bGUuaHRtbChwZ1NlbGVjdC5kYXRhLmNvbG9yW2luZGV4XS50aXRsZSk7XG4gICAgICBwZ1NlbGVjdC5jb2xvckRlc2NyaXB0aW9uLmh0bWwocGdTZWxlY3QuZGF0YS5jb2xvcltpbmRleF0uZGVzY3JpcHRpb24pO1xuICAgIH0sXG4gIH0sXG4gIGNsYXJpdHk6IHtcbiAgICBjaGFuZ2VEZXRhaWxzOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHBnU2VsZWN0LmNsYXJpdHlJbWcuYXR0cihcInNyY1wiLCBwZ1NlbGVjdC5kYXRhLmNsYXJpdHlbaW5kZXhdLnVybCk7XG4gICAgICBwZ1NlbGVjdC5jbGFydHlUaXRsZS5odG1sKHBnU2VsZWN0LmRhdGEuY2xhcml0eVtpbmRleF0udGl0bGUpO1xuICAgICAgcGdTZWxlY3QuY2xhcml0eURlc2NyaXB0aW9uLmh0bWwoXG4gICAgICAgIHBnU2VsZWN0LmRhdGEuY2xhcml0eVtpbmRleF0uZGVzY3JpcHRpb25cbiAgICAgICk7XG4gICAgfSxcbiAgfSxcbiAgcmluZ1NpemU6IHtcbiAgICBjaGFuZ2VEZXRhaWxzOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHBnU2VsZWN0LmN1cnJlbnRTaXplLmh0bWwocGdTZWxlY3QuZGF0YS5yaW5nU2l6ZVtpbmRleF0udXMpO1xuICAgICAgcGdTZWxlY3QuY2lyY1NpemUuaHRtbChwZ1NlbGVjdC5kYXRhLnJpbmdTaXplW2luZGV4XS5jaXJjKTtcbiAgICAgIHBnU2VsZWN0LmRTaXplLmh0bWwocGdTZWxlY3QuZGF0YS5yaW5nU2l6ZVtpbmRleF0uZGlhbWV0ZXIpO1xuICAgICAgcGdTZWxlY3QuZXVTaXplLmh0bWwocGdTZWxlY3QuZGF0YS5yaW5nU2l6ZVtpbmRleF0uZXVyb3BlKTtcbiAgICAgIHBnU2VsZWN0LnVrU2l6ZS5odG1sKHBnU2VsZWN0LmRhdGEucmluZ1NpemVbaW5kZXhdLnVrKTtcbiAgICB9LFxuICB9LFxuICBkYXRhOiB7XG4gICAgc2hhcGU6IFtcbiAgICAgIHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vaS5pYmIuY28vWkJtY0cwZi9kbWctc2hhcGUtcm91bmQucG5nXCIsXG4gICAgICAgIHRpdGxlOiBcIlJvdW5kXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiQSBjbGFzc2ljIGFuZCB0aW1lbGVzcyBzaGFwZSwgdGhlIHJvdW5kIGRpYW1vbmQgaXMga25vd24gZm9yIGl0cyBicmlsbGlhbnQgc3BhcmtsZSBhbmQgcGVyZmVjdCBzeW1tZXRyeS5cIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL3JkTmtZeXAvZG1nLXNoYXBlLXByaW5lc3MucG5nXCIsXG4gICAgICAgIHRpdGxlOiBcIlByaW5jZXNzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiQSBzcXVhcmUtc2hhcGVkIGRpYW1vbmQgd2l0aCBzaGFycCBjb3JuZXJzIGFuZCBleGNlcHRpb25hbCBicmlsbGlhbmNlLCBrbm93biBmb3IgaXRzIG1vZGVybiBhbmQgY2xlYW4gbGluZXMuXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9pLmliYi5jby8yNzFic0NaL2RtZy1zaGFwZS1vdmFsLnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJPdmFsXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiQSBtb2RpZmllZCBicmlsbGlhbnQgY3V0IGRpYW1vbmQgd2l0aCBhbiBlbG9uZ2F0ZWQgc2hhcGUsIGtub3duIGZvciBpdHMgYnJpbGxpYW5jZSBhbmQgYWJpbGl0eSB0byBjcmVhdGUgdGhlIGlsbHVzaW9uIG9mIGxvbmdlciwgc2xlbmRlciBmaW5nZXJzLlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vaS5pYmIuY28vcXlRblYxZi9kbWctc2hhcGUtcGVhci5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiUGVhclwiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICBcIkFuIGVsZWdhbnQgY29tYmluYXRpb24gb2YgYSByb3VuZCBhbmQgbWFycXVpc2Ugc2hhcGUsIHNvbWV0aW1lcyBjYWxsZWQgYSB0ZWFyZHJvcCwgb2ZmZXJpbmcgYSB1bmlxdWUgYW5kIGdyYWNlZnVsIGFwcGVhcmFuY2UuXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9pLmliYi5jby9OVmRnSnR2L2RtZy1zaGFwZS1lbWVyYWxkLnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJFbWVyYWxkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiQSByZWN0YW5ndWxhciBzaGFwZSB3aXRoIHN0ZXBwZWQgZmFjZXRzLCBoaWdobGlnaHRpbmcgdGhlIGRpYW1vbmRzIGNsYXJpdHkgYW5kIHNob3djYXNpbmcgYSB0aW1lbGVzcyBhbmQgc29waGlzdGljYXRlZCBsb29rLlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIGNvbG9yOiBbXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL01EblltR2gvZG1nLWNvbG9yLW5lYXIucG5nXCIsXG4gICAgICAgIHRpdGxlOiBcIksgLSBMYXN0IEdyYWRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiVGhlIGNvbG9yIG1heSBiZSB2aXNpYmxlIHRvIHRoZSB1bmFpZGVkIGV5ZS4gRGlhbW9uZHMgd2l0aCBhIEstY29sb3IgZ3JhZGUgY2FuIGJlIGEgc21hcnQgY2hvaWNlLCBvZmZlcmluZyBleGNlbGxlbnQgdmFsdWUgZm9yIG1vbmV5LlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vaS5pYmIuY28vTURuWW1HaC9kbWctY29sb3ItbmVhci5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiSiAtIExhc3QgR3JhZGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgJ0NvbG9yIGluIGRpYW1vbmRzIGdyYWRlZCBhcyBcIm5lYXItY29sb3JsZXNzXCIgbWF5IGJlIHNsaWdodGx5IHZpc2libGUgdG8gdGhlIG5ha2VkIGV5ZSwgZXNwZWNpYWxseSBpbiBmYW5jeSBzaGFwZXMgb3IgZGlhbW9uZHMgbGFyZ2VyIHRoYW4gMSBjYXJhdC4nLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vaS5pYmIuY28vSmtLNEIzQy9kbWctY29sb3Itc2xpZ2h0LnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJJIC0gU2xpZ2h0bHkgRGV0ZWN0YWJsZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICBcIlVwb24gY2xvc2UgZXhhbWluYXRpb24sIHRoZSBjb2xvciBtYXkgYmUgYmFyZWx5IG5vdGljZWFibGUsIGJ1dCBpdCBzdGlsbCBwcm92aWRlcyBleGNlcHRpb25hbCB2YWx1ZS5cIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL0oySmhQTTQvZG1nLWNvbG9yLWNsZWFyLnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJIIC0gTmVhciBDb2xvcmxlc3NcIixcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgJ1RoZSBcIm5lYXItY29sb3JsZXNzXCIgZ3JhZGUgb2YgQ0EgZXhoaWJpdHMgbm90aWNlYWJsZSBjb2xvciBvbmx5IHdoZW4gY29tcGFyZWQgdG8gbXVjaCBoaWdoZXIgY29sb3IgZ3JhZGVzLCBvZmZlcmluZyBleGNlbGxlbnQgdmFsdWUuJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL0oySmhQTTQvZG1nLWNvbG9yLWNsZWFyLnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJHIC0gQWxtb3N0IENvbG9ybGVzc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAnVGhpcyBncmFkZSBpcyB0aGUgaGlnaGVzdCBsZXZlbCBvZiBcIm5lYXItY29sb3JsZXNzXCIgYW5kIG1heSBzaG93IHNvbWUgY29sb3IgaW4gY29tcGFyaXNvbiB0byB0aGUgZXZlbiBoaWdoZXIgXCJjb2xvcmxlc3NcIiBncmFkZXMsIGJ1dCBpdCBvZmZlcnMgZXhjZWxsZW50IHZhbHVlLicsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9pLmliYi5jby9KMkpoUE00L2RtZy1jb2xvci1jbGVhci5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiRiAtIENvbG9ybGVzc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAnVGhlIFwiY29sb3JsZXNzXCIgZ3JhZGUgaXMgbW9zdCB2YWx1ZWQgd2hlbiBwbGFjZWQgaW4gcGxhdGludW0gb3Igd2hpdGUgZ29sZCwgd2l0aCBhIGZhaW50IGNvbG9yIHRoYXQgY2FuIGJlIGlkZW50aWZpZWQgYnkgYSBza2lsbGVkIGdlbW9sb2dpc3QuJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL0oySmhQTTQvZG1nLWNvbG9yLWNsZWFyLnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJFIC0gQ29sb3JsZXNzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICdUaGlzIGdyYWRlLCBiZXN0IHNob3djYXNlZCBpbiBwbGF0aW51bSBvciB3aGl0ZSBnb2xkLCBpcyBzbyBcImNvbG9ybGVzc1wiIHRoYXQgZXZlbiB0cmFpbmVkIGV5ZXMgd291bGQgc3RydWdnbGUgdG8gZGV0ZWN0IHRyYWNlcyBvZiBjb2xvci4nLFxuICAgICAgfSxcbiAgICBdLFxuICAgIGNsYXJpdHk6IFtcbiAgICAgIHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vaS5pYmIuY28vR3A4cEt3Sy9jbGFyaXR5LWkzLnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJJMSwgSTIsIEkzIC0gSW5jbHVkZWRcIixcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgXCJEaWFtb25kcyBpbiB0aGlzIGNsYXJpdHkgcmFuZ2UgaGF2ZSBpbmNsdXNpb25zIHRoYXQgYXJlIGVhc2lseSB2aXNpYmxlIHVuZGVyIDEweCBtYWduaWZpY2F0aW9uIGFuZCBtYXkgYWxzbyBiZSB2aXNpYmxlIHRvIHRoZSBuYWtlZCBleWUuIFRoZXNlIGRpYW1vbmRzIG1heSBoYXZlIHJlZHVjZWQgYnJpbGxpYW5jZSBhbmQgc3BhcmtsZSBkdWUgdG8gdGhlaXIgaW5jbHVzaW9ucy5cIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL1pIQnZKejkvY2xhcml0eS1zaTEtc2kyLnBuZ1wiLFxuICAgICAgICB0aXRsZTogXCJTSTEgJiBTSTIgLSBTbGlnaHRseSBJbmNsdWRlZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICBcIlRoZXNlIGdyYWRlcyBoYXZlIG5vdGljZWFibGUgaW5jbHVzaW9ucyB1bmRlciAxMHggbWFnbmlmaWNhdGlvbiwgc29tZSBvZiB3aGljaCBtaWdodCBiZSB2aXNpYmxlIHRvIHRoZSBuYWtlZCBleWUuIFNJIGRpYW1vbmRzIGdlbmVyYWxseSBvZmZlciBnb29kIHZhbHVlIGFzIHRoZXkgaGF2ZSBpbmNsdXNpb25zIHRoYXQgbWlnaHQgbm90IHNpZ25pZmljYW50bHkgYWZmZWN0IHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFtb25kLlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vaS5pYmIuY28vMjd4RzdHQy9jbGFyaXR5LXZzMS12czIucG5nXCIsXG4gICAgICAgIHRpdGxlOiBcIlZTMSAmIFZTMiAtIFZlcnkgU2xpZ2h0bHkgSW5jbHVkZWRcIixcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgXCJUaGVzZSBncmFkZXMgaGF2ZSBtaW5vciBpbmNsdXNpb25zIHRoYXQgYXJlIHZpc2libGUgdW5kZXIgMTB4IG1hZ25pZmljYXRpb24gYnV0IGFyZSBjb25zaWRlcmVkIHJlbGF0aXZlbHkgc21hbGwgYW5kIG5vdCBlYXNpbHkgbm90aWNlYWJsZSB0byB0aGUgbmFrZWQgZXllLlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vaS5pYmIuY28vZDYxd25MOS9jbGFyaXR5LXZ2czEtdnZzMi5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiVlZTMSAmIFZWUzIgLSBWZXJ5LCBWZXJ5IFNsaWdodGx5IEluY2x1ZGVkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiVGhlc2UgZ3JhZGVzIGluZGljYXRlIHRoYXQgaW5jbHVzaW9ucyBhcmUgZXh0cmVtZWx5IGRpZmZpY3VsdCB0byBzZWUgZXZlbiB1bmRlciAxMHggbWFnbmlmaWNhdGlvbi4gVlZTIGRpYW1vbmRzIG1heSBoYXZlIG1pbm9yIGluY2x1c2lvbnMgdGhhdCBhcmUgYmFyZWx5IHZpc2libGUgdG8gYSBza2lsbGVkIGdyYWRlci5cIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHVybDogXCJodHRwczovL2kuaWJiLmNvL1dLc3FzOTkvY2xhcml0eS1mbC1pZi5wbmdcIixcbiAgICAgICAgdGl0bGU6IFwiRkwgJiBJRiAtIEZsYXdsZXNzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiVGhlc2UgYXJlIHRoZSBoaWdoZXN0IGNsYXJpdHkgZ3JhZGVzLiBGbGF3bGVzcyBkaWFtb25kcyBoYXZlIG5vIHZpc2libGUgaW5jbHVzaW9ucyBvciBibGVtaXNoZXMgdW5kZXIgMTB4IG1hZ25pZmljYXRpb24sIGV2ZW4gYnkgYSBza2lsbGVkIGdyYWRlci4gSW50ZXJuYWxseSBGbGF3bGVzcyBkaWFtb25kcyBoYXZlIG5vIGludGVybmFsIGluY2x1c2lvbnMgYnV0IG1heSBoYXZlIG1pbm9yIHN1cmZhY2UgYmxlbWlzaGVzLlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHJpbmdTaXplOiBbXG4gICAgICB7IHVzOiA0LCBldXJvcGU6IFwiNDdcIiwgdWs6IFwiSCAxLzJcIiwgZGlhbWV0ZXI6IFwiMTQuOVwiLCBjaXJjOiBcIjQ2LjhcIiB9LFxuICAgICAgeyB1czogNC41LCBldXJvcGU6IFwiNDhcIiwgdWs6IFwiSSAxLzJcIiwgZGlhbWV0ZXI6IFwiMTUuM1wiLCBjaXJjOiBcIjQ4XCIgfSxcbiAgICAgIHsgdXM6IDUsIGV1cm9wZTogXCI0OVwiLCB1azogXCJKIDEvMlwiLCBkaWFtZXRlcjogXCIxNS43XCIsIGNpcmM6IFwiNDkuM1wiIH0sXG4gICAgICB7IHVzOiA1LjUsIGV1cm9wZTogXCI1MVwiLCB1azogXCJLIDEvMlwiLCBkaWFtZXRlcjogXCIxNi4xXCIsIGNpcmM6IFwiNTAuNlwiIH0sXG4gICAgICB7IHVzOiA2LCBldXJvcGU6IFwiNTJcIiwgdWs6IFwiTCAxLzJcIiwgZGlhbWV0ZXI6IFwiMTYuNVwiLCBjaXJjOiBcIjUxLjlcIiB9LFxuICAgICAgeyB1czogNi41LCBldXJvcGU6IFwiNTNcIiwgdWs6IFwiTSAxLzJcIiwgZGlhbWV0ZXI6IFwiMTYuOVwiLCBjaXJjOiBcIjUzLjFcIiB9LFxuICAgICAgeyB1czogNywgZXVyb3BlOiBcIjU0XCIsIHVrOiBcIk4gMS8yXCIsIGRpYW1ldGVyOiBcIjE3LjNcIiwgY2lyYzogXCI1NC40XCIgfSxcbiAgICAgIHsgdXM6IDcuNSwgZXVyb3BlOiBcIjU1XCIsIHVrOiBcIk8gMS8yXCIsIGRpYW1ldGVyOiBcIjE3LjdcIiwgY2lyYzogXCI1NS43XCIgfSxcbiAgICAgIHsgdXM6IDgsIGV1cm9wZTogXCI1N1wiLCB1azogXCJQIDEvMlwiLCBkaWFtZXRlcjogXCIxOC4xXCIsIGNpcmM6IFwiNTcuMFwiIH0sXG4gICAgICB7IHVzOiA4LjUsIGV1cm9wZTogXCI1OFwiLCB1azogXCJRIDEvMlwiLCBkaWFtZXRlcjogXCIxOC41XCIsIGNpcmM6IFwiNTguM1wiIH0sXG4gICAgICB7IHVzOiA5LCBldXJvcGU6IFwiNTlcIiwgdWs6IFwiUiAxLzJcIiwgZGlhbWV0ZXI6IFwiMTkuMFwiLCBjaXJjOiBcIjU5LjVcIiB9LFxuICAgICAgeyB1czogOS41LCBldXJvcGU6IFwiNjFcIiwgdWs6IFwiUyAxLzJcIiwgZGlhbWV0ZXI6IFwiMTkuNFwiLCBjaXJjOiBcIjYwLjhcIiB9LFxuICAgICAgeyB1czogMTAsIGV1cm9wZTogXCI2MlwiLCB1azogXCJUIDEvMlwiLCBkaWFtZXRlcjogXCIxOS44XCIsIGNpcmM6IFwiNjIuMVwiIH0sXG4gICAgICB7IHVzOiAxMC41LCBldXJvcGU6IFwiNjNcIiwgdWs6IFwiVSAxLzJcIiwgZGlhbWV0ZXI6IFwiMjAuMlwiLCBjaXJjOiBcIjYzLjRcIiB9LFxuICAgICAgeyB1czogMTEsIGV1cm9wZTogXCI2NFwiLCB1azogXCJWIDEvMlwiLCBkaWFtZXRlcjogXCIyMC42XCIsIGNpcmM6IFwiNjQuNlwiIH0sXG4gICAgICB7IHVzOiAxMS41LCBldXJvcGU6IFwiNjZcIiwgdWs6IFwiVyAxLzJcIiwgZGlhbWV0ZXI6IFwiMjEuMFwiLCBjaXJjOiBcIjY1LjlcIiB9LFxuICAgICAgeyB1czogMTIsIGV1cm9wZTogXCI2N1wiLCB1azogXCJYIDEvMlwiLCBkaWFtZXRlcjogXCIyMS40XCIsIGNpcmM6IFwiNjcuMlwiIH0sXG4gICAgICB7IHVzOiAxMi41LCBldXJvcGU6IFwiNjhcIiwgdWs6IFwiWiAxLzJcIiwgZGlhbWV0ZXI6IFwiMjEuOFwiLCBjaXJjOiBcIjY4LjVcIiB9LFxuICAgIF0sXG4gIH0sXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGdTZWxlY3QiLCJ3aW5kb3cuc2lydlRpbWVyID0gbnVsbFxuY29uc3Qgc2lydkNhcmRzID0ge1xuICB2aXNpYmxlQ2xhc3M6ICdpcy12aXNpYmxlJyxcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FjaGVET00oKVxuICAgIHRoaXMuYmluZEV2ZW50cygpXG4gIH0sXG4gIGNhY2hlRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYXJkcyA9ICQoJy5wcm9kdWN0LWNhcmQnKVxuICB9LFxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY2FyZHMpIHtcbiAgICAgIHRoaXMuY2FyZHMub24oJ21vdXNlZW50ZXIgbW91c2VsZWF2ZSB0b3VjaHN0YXJ0IHRvdWNoZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc3dpdGNoIChlLnR5cGUpIHtcblxuICAgICAgICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgICAgICAgICAgc2lydkNhcmRzLnRvZ2dsZVNpcnYoJCh0aGlzKSwgMSlcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgICAgICAgc2lydkNhcmRzLnRvZ2dsZVNpcnYoJCh0aGlzKSwgMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICAgICAgc2lydkNhcmRzLnRvZ2dsZVNpcnYoJCh0aGlzKSwgMSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21vdXNlbGVhdmUnOlxuICAgICAgICAgICAgc2lydkNhcmRzLnRvZ2dsZVNpcnYoJCh0aGlzKSwgMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSxcbiAgdG9nZ2xlU2lydjogZnVuY3Rpb24gKCR0aGlzLCBzdGF0ZSkge1xuICAgIGxldCBzaXJ2ID0gJHRoaXMuZmluZCgnLnByb2R1Y3QtcGljdHVyZV9zaXJ2JylcbiAgICBpZiAoc2lydi5sZW5ndGggIT09IDApIHtcbiAgICAgIGxldCBpZCA9IHNpcnYuZmluZCgnLlNpcnYnKS5hdHRyKCdpZCcpXG4gICAgICBpZiAoc3RhdGUgIT09IDApIHtcbiAgICAgICAgc2lydi5zaG93KClcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgc2lydi5hZGRDbGFzcyh0aGlzLnZpc2libGVDbGFzcylcbiAgICAgICAgfSwgMSk7XG4gICAgICAgIFNpcnYuaW5zdGFuY2UoaWQpLnBsYXkoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgU2lydi5pbnN0YW5jZShpZCkucGF1c2UoKVxuICAgICAgICBzaXJ2LnJlbW92ZUNsYXNzKHRoaXMudmlzaWJsZUNsYXNzKVxuICAgICAgICBzaXJ2VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2lydi5oaWRlKClcbiAgICAgICAgfSwgMzAwKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpcnZDYXJkcyIsImZ1bmN0aW9uIGluaXRWYWxpZGF0b3JzKCkge1xuICAkKFwiLm5lZWRzLXZhbGlkYXRpb25cIikucGFyc2xleSh7XG4gICAgZXJyb3JDbGFzczogJ2lzLWludmFsaWQgdGV4dC1kYW5nZXInLFxuICAgIHN1Y2Nlc3NDbGFzczogJ2lzLXZhbGlkJyxcbiAgICBlcnJvcnNXcmFwcGVyOiAnPGRpdiBjbGFzcz1cImludmFsaWQtZmVlZGJhY2tcIj48L2Rpdj4nLFxuICAgIGVycm9yVGVtcGxhdGU6ICc8c3Bhbj48L3NwYW4+JyxcbiAgICB0cmlnZ2VyOiAnY2hhbmdlJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRCdG5TdGF0ZXMoZWwpIHtcbiAgZWwucmVtb3ZlQ2xhc3MoJ2lzLXN1Y2Nlc3NmdWwnKTtcbiAgZWwucmVtb3ZlQ2xhc3MoJ2lzLWZhaWxlZCcpO1xufVxuXG5mdW5jdGlvbiBzaG93QWx0ZXJuYXRpdmVCdG5UZXh0KGVsLCBtc2csIGNzc19jbGFzcykge1xuICB2YXIgb3JpZ2luYWxfbXNnID0gJChlbCkuaHRtbCgpO1xuICByZXNldEJ0blN0YXRlcygkKGVsKSk7XG4gICQoZWwpLmFkZENsYXNzKGNzc19jbGFzcykuaHRtbChtc2cpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICByZXNldEJ0blN0YXRlcygkKGVsKSk7XG4gICAgJChlbCkuaHRtbChvcmlnaW5hbF9tc2cpO1xuICB9LCA0MDAwKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTaWduTWVzc2FnZSgpIHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2lnbi1tb2RhbF9fbWVzc2FnZScpXG4gIGlmIChlbCkge1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLXN1Y2Nlc3NmdWwnKVxuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWZhaWxlZCcpXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIGVsLmlubmVySFRNTCA9ICcnXG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvd1NpZ25NZXNzYWdlKG1zZywgY3NzX2NsYXNzKSB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNpZ24tbW9kYWxfX21lc3NhZ2UnKVxuICBpZiAoZWwpIHtcbiAgICB2YXIgb3JpZ2luYWxfbXNnID0gZWwuaW5uZXJIVE1MXG4gICAgcmVzZXRTaWduTWVzc2FnZSgpXG4gICAgZWwuY2xhc3NMaXN0LmFkZChjc3NfY2xhc3MpXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xuICAgIGVsLmlubmVySFRNTCA9IG1zZ1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVzZXRTaWduTWVzc2FnZSgpXG4gICAgICBlbC5pbm5lckhUTUwgPSBvcmlnaW5hbF9tc2dcbiAgICB9LCA0MDAwKTtcbiAgfVxufVxuXG53aW5kb3cuUGFyc2xleS5vbignZm9ybTpzdWJtaXQnLCBmdW5jdGlvbiAoKSB7XG4gIC8vY29uc29sZS5sb2coXCJzdWJtaXQgZm9ybVwiKTtcbiAgdmFyIGZvcm0gPSAkKHRoaXMuJGVsZW1lbnRbMF0pO1xuICB2YXIgdXJsID0gZm9ybS5hdHRyKCdhY3Rpb24nKTtcbiAgdmFyIGJ0biA9IGZvcm0uZmluZChcIi5qcy1sb2FkaW5nLWJ0blwiKTtcbiAgJC5hamF4KHtcbiAgICB0eXBlOiBcIlBPU1RcIixcbiAgICB1cmw6IHVybCxcbiAgICBkYXRhOiBmb3JtLnNlcmlhbGl6ZSgpLCAvLyBzZXJpYWxpemVzIHRoZSBmb3JtJ3MgZWxlbWVudHMuXG4gICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciByID0gJC5wYXJzZUpTT04oZGF0YSk7XG4gICAgICBpZiAoIXIuZXJyb3IpIHtcbiAgICAgICAgLy9zaG93IHN1Y2Nlc3Mgc3RhdGUgb24gYnV0dG9uIGFuZCByZXR1cm4gbWVzc2FnZSBpbiByLm1zZ1xuICAgICAgICBzaG93U2lnbk1lc3NhZ2Uoci5tc2csICdpcy1zdWNjZXNzZnVsJyk7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoci5saW5rICE9IHVuZGVmaW5lZCAmJiByLmxpbmsgIT0gJycpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gci5saW5rO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vc2hvdyBmYWlsZWQgc3RhdGUgb24gYnV0dG9uIGFuZCByZXR1cm4gbWVzc2FnZSBpbiByLm1zZ1xuICAgICAgICBzaG93U2lnbk1lc3NhZ2Uoci5tc2csICdpcy1mYWlsZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmFsc2U7XG59KTtcblxuY2xhc3MgU2lnbk1vZGFsIHtcbiAgY29uc3RydWN0b3Iocm9vdEVsKSB7XG4gICAgdGhpcy5yb290RWwgPSByb290RWxcbiAgICB0aGlzLmFkanVzdEVsID0gcm9vdEVsLnF1ZXJ5U2VsZWN0b3IoJy5zaWduLW1vZGFsX19hZGp1c3QnKVxuICAgIHRoaXMuYmFja2Ryb3AgPSByb290RWwucXVlcnlTZWxlY3RvcignLnNpZ24tbW9kYWxfX2JhY2tkcm9wJylcbiAgICB0aGlzLmNvbnRhaW5lciA9IHJvb3RFbC5xdWVyeVNlbGVjdG9yKCcuc2lnbi1tb2RhbF9fY29udGFpbmVyJylcbiAgICB0aGlzLmZvcm1zQXJyID0gWy4uLnJvb3RFbC5xdWVyeVNlbGVjdG9yQWxsKCdmb3JtJyldXG4gICAgdGhpcy5ldnRPcGVuQXJyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZXZ0PVwib3BlblNpZ25Nb2RhbFwiXScpXG4gICAgdGhpcy5ldnRDbG9zZUFyciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWV2dD1cImNsb3NlU2lnbk1vZGFsXCJdJylcbiAgICB0aGlzLmV2dEpzVG9nZ2xlU2lnbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5qcy10b2dnbGUtc2lnbicpXG4gICAgdGhpcy5jb250ZW50QXJyID0gWy4uLnJvb3RFbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zaWduLWNvbnRlbnRdJyldXG4gICAgdGhpcy5ldnRTd2l0Y2hDb250ZW50QXJyID0gcm9vdEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNpZ24tc3dpdGNoXScpXG4gICAgdGhpcy5ldnRUb2dnbGVQYXNzd29yZCA9IFsuLi5yb290RWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZXZ0PVwidG9nZ2xlUGFzc3dvcmRcIl0nKV1cbiAgICB0aGlzLmxvYWRlciA9IHJvb3RFbC5xdWVyeVNlbGVjdG9yKCcuc2lnbi1tb2RhbF9fbG9hZGVyJylcbiAgICB0aGlzLmpzU3VibWl0QXJyID0gWy4uLnJvb3RFbC5xdWVyeVNlbGVjdG9yQWxsKCcuanMtc3VibWl0JyldXG4gICAgdGhpcy5vdHBBcnIgPSBbLi4udGhpcy5yb290RWwucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQuLS1vdHAnKV1cbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlXG4gICAgdGhpcy5vcGVuZWQgPSB0cnVlXG4gICAgdGhpcy5hY3RpdmVDb250ZW50ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogR2V0dGVyc1xuICAgKi9cbiAgZ2V0IGdldEFjdGl2ZUNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudEFyci5maW5kKGUgPT4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSkuZGlzcGxheSAhPT0gJ25vbmUnKVxuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxzXG4gICAqL1xuICBsb2NrTW9kYWwoKSB7XG4gICAgdGhpcy5yb290RWwuY2xhc3NMaXN0LmFkZChfX0xPQ0tFRClcbiAgICB0aGlzLmxvY2tlZCA9IHRydWVcbiAgfVxuICB1bmxvY2tNb2RhbCgpIHtcbiAgICB0aGlzLnJvb3RFbC5jbGFzc0xpc3QucmVtb3ZlKF9fTE9DS0VEKVxuICAgIHRoaXMubG9ja2VkID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2RzXG4gICAqL1xuICBzd2l0Y2goY29udGVudFR5cGUpIHtcbiAgICBsZXQgc2VjdGlvbiA9IHRoaXMuY29udGVudEFyci5maW5kKGUgPT4gZS5kYXRhc2V0LnNpZ25Db250ZW50ID09PSBjb250ZW50VHlwZSkgfHwgdGhpcy5jb250ZW50QXJyWzBdXG4gICAgbGV0IGFjdGl2ZVNlY3Rpb24gPSB0aGlzLmNvbnRlbnRBcnIuZmluZCgoZWwpID0+IHtcbiAgICAgIGxldCBkaXNwbGF5UHJvcGVydHkgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZGlzcGxheVxuICAgICAgcmV0dXJuIGRpc3BsYXlQcm9wZXJ0eSAhPT0gJ25vbmUnXG4gICAgfSlcbiAgICBpZiAoIXNlY3Rpb24pIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdG8gZmluZCBzZWN0aW9uIHdpdGggZGF0YS1zaWduLWNvbnRlbnQ9JHtjb250ZW50VHlwZX1gKVxuICAgIGlmIChhY3RpdmVTZWN0aW9uID09IHNlY3Rpb24pIHJldHVyblxuICAgIGlmIChjb250ZW50VHlwZSA9PSAnb3RwJykge1xuICAgICAgdGhpcy5vdHBBcnIuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgZWwudmFsdWUgPSAnJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmFjdGl2ZUNvbnRlbnQgPSBzZWN0aW9uXG4gICAgdGhpcy5sb2NrTW9kYWwoKVxuICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSB0aGlzLmFkanVzdEVsLm9mZnNldEhlaWdodFxuICAgIHRoaXMuYWRqdXN0RWwuc3R5bGUub3BhY2l0eSA9IDBcbiAgICB0aGlzLmFkanVzdEVsLnN0eWxlLmhlaWdodCA9IGAke2N1cnJlbnRIZWlnaHR9cHhgXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmNvbnRlbnRBcnIuZm9yRWFjaChlID0+IGUuc3R5bGUuZGlzcGxheSA9ICdub25lJylcbiAgICAgIHNlY3Rpb24uc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xuICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gc2VjdGlvbi5zY3JvbGxIZWlnaHRcbiAgICAgIHRoaXMuYWRqdXN0RWwuc3R5bGUuaGVpZ2h0ID0gYCR7bmV3SGVpZ2h0fXB4YFxuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5hZGp1c3RFbC5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgICAgIHRoaXMudW5sb2NrTW9kYWwoKVxuICAgICAgfSwgNSlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkanVzdEVsLnN0eWxlLmhlaWdodCA9ICdhdXRvJ1xuICAgICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUodGhpcy5hZGp1c3RFbCkpO1xuICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMuYWRqdXN0RWwpKTtcbiAgfVxuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGVuKClcbiAgICB9XG4gIH1cbiAgb3BlbigpIHtcbiAgICBpZiAoIXRoaXMub3BlbmVkKSB7XG4gICAgICBpZiAod2luZG93Lm1lbnUpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5tZW51LnN0YXRlKSB7XG4gICAgICAgICAgd2luZG93Lm1lbnUuc3RhdGUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5jb250ZW50QXJyLmZpbmQoZSA9PiBlLmRhdGFzZXQuc2lnbkNvbnRlbnQgPT0gJ3NtcycpIHx8IHRoaXMuY29udGVudEFyclswXVxuICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlXG4gICAgICB0aGlzLnJvb3RFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgdGhpcy5hZGp1c3RFbC5zdHlsZS5oZWlnaHQgPSAnYXV0bydcbiAgICAgIHRoaXMuY29udGVudEFyci5mb3JFYWNoKGUgPT4gZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnKVxuICAgICAgY29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgICAvLyBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykuZm9jdXMoKVxuICAgICAgbG9ja1Njcm9sbCgpXG4gICAgICBjb25zdCBzaG93ID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmJhY2tkcm9wLnN0eWxlLm9wYWNpdHkgPSAxXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoSVNfSElEREVOKVxuICAgICAgfVxuICAgICAgc2V0VGltZW91dChzaG93LCAxKVxuICAgIH1cbiAgfVxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgIHRoaXMub3BlbmVkID0gZmFsc2VcbiAgICAgIHRoaXMuYmFja2Ryb3Auc3R5bGUub3BhY2l0eSA9IDBcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoSVNfSElEREVOKVxuICAgICAgdW5sb2NrU2Nyb2xsKClcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnJvb3RFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmJhY2tkcm9wKSlcbiAgICB9XG4gIH1cbiAgc3RhcnRMb2FkaW5nKCkge1xuICAgIGlmICh0aGlzLmxvYWRlciAmJiAhdGhpcy5sb2NrZWQpIHtcbiAgICAgIHRoaXMudW5sb2NrTW9kYWwoKVxuICAgICAgdGhpcy5sb2FkZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMubG9hZGVyLnN0eWxlLm9wYWNpdHkgPSAnMScgfSwgMTApXG4gICAgfVxuICB9XG4gIHN0b3BMb2FkaW5nKCkge1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuc3R5bGUub3BhY2l0eSA9ICcwJ1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubG9hZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZVxuICAgICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUodGhpcy5sb2FkZXIpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIEV2ZW50c1xuICAgKi9cbiAgYmluZFRvZ2dsZVZpc2libGl0eSgpIHtcbiAgICAvLyBPcGVuXG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmV2dE9wZW5BcnIpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHRoaXMudG9nZ2xlKClcbiAgICAgIH0pXG4gICAgfVxuICAgIC8vIENsb3NlXG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmV2dENsb3NlQXJyKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgIH0pXG4gICAgfVxuICAgIC8vIFRvZ2dsZVxuICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5ldnRKc1RvZ2dsZVNpZ24pIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHRoaXMudG9nZ2xlKClcbiAgICAgICAgY29uc3QgY29udGVudE5hbWUgPSBlbC5kYXRhc2V0LnNpZ25Td2l0Y2hcbiAgICAgICAgaWYgKGNvbnRlbnROYW1lKSB7XG4gICAgICAgICAgdGhpcy5zd2l0Y2goY29udGVudE5hbWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGJpbmRTd2l0Y2hDb250ZW50KCkge1xuICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5ldnRTd2l0Y2hDb250ZW50QXJyKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBjb25zdCBjb250ZW50TmFtZSA9IGVsLmRhdGFzZXQuc2lnblN3aXRjaFxuICAgICAgICB0aGlzLnN3aXRjaChjb250ZW50TmFtZSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGJpbmRPVFBJbnB1dCgpIHtcbiAgICBjb25zdCBpbnB1dHMgPSB0aGlzLm90cEFyclxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dCcpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGEuc3BsaXQoXCJcIik7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IGlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGluZGV4KSA9PiAoaW5wdXQudmFsdWUgPSB2YWx1ZVtpbmRleF0pKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlLnRhcmdldC52YWx1ZVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gdmFsdWUucmVwbGFjZSgvLi9nLCAnJylcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubWF0Y2goL1xcRC9nKSkge1xuICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gJydcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG5leHRJbnB1dCA9IGUudGFyZ2V0Lm5leHRFbGVtZW50U2libGluZ1xuICAgICAgICAgIGNvbnN0IHZhbHVlSXNEaWdpdCA9IHZhbHVlLm1hdGNoKC9cXGQvZylcbiAgICAgICAgICBpZiAobmV4dElucHV0ICYmIHZhbHVlSXNEaWdpdCkge1xuICAgICAgICAgICAgbmV4dElucHV0LmZvY3VzKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gJydcbiAgICAgICAgICBjb25zdCBwcmV2SW5wdXQgPSBlLnRhcmdldC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXG4gICAgICAgICAgaWYgKHByZXZJbnB1dCkge1xuICAgICAgICAgICAgcHJldklucHV0LmZvY3VzKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUua2V5ID09PSAnQXJyb3dMZWZ0Jykge1xuICAgICAgICAgIGNvbnN0IHByZXZJbnB1dCA9IGUudGFyZ2V0LnByZXZpb3VzRWxlbWVudFNpYmxpbmdcbiAgICAgICAgICBpZiAocHJldklucHV0KSB7XG4gICAgICAgICAgICBwcmV2SW5wdXQuZm9jdXMoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLmtleSA9PT0gJ0Fycm93UmlnaHQnKSB7XG4gICAgICAgICAgY29uc3QgbmV4dElucHV0ID0gZS50YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nXG4gICAgICAgICAgaWYgKG5leHRJbnB1dCkge1xuICAgICAgICAgICAgbmV4dElucHV0LmZvY3VzKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGJpbmRUb2dnbGVQYXNzd29yZCgpIHtcbiAgICBmb3IgKGNvbnN0IGJ0biBvZiB0aGlzLmV2dFRvZ2dsZVBhc3N3b3JkKSB7XG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgY29uc3QgaW5wdXQgPSBidG4ucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpXG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ3Bhc3N3b3JkJyA/ICd0ZXh0JyA6ICdwYXNzd29yZCdcbiAgICAgICAgICBjb25zdCBzdmdTaG93ID0gYnRuLnF1ZXJ5U2VsZWN0b3IoJy5zdmdfcGFzc19zaG93JylcbiAgICAgICAgICBjb25zdCBzdmdIaWRlID0gYnRuLnF1ZXJ5U2VsZWN0b3IoJy5zdmdfcGFzc19oaWRlJylcblxuICAgICAgICAgIGlucHV0LnR5cGUgPSB0eXBlXG4gICAgICAgICAgaWYgKHN2Z1Nob3cgJiYgc3ZnSGlkZSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICBzdmdTaG93LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgICAgc3ZnSGlkZS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSdcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN2Z1Nob3cuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnXG4gICAgICAgICAgICAgIHN2Z0hpZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZFN1Ym1pdCgpIHtcbiAgICB0aGlzLmZvcm1zQXJyLmZvckVhY2goKGZvcm0sIGluZGV4KSA9PiB7XG4gICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKCQoZm9ybSkucGFyc2xleSgpLmlzVmFsaWQoKSkge1xuICAgICAgICAgIHRoaXMuc3RhcnRMb2FkaW5nKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG4gIGJpbmRLZXlQcmVzcygpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIChlKSA9PiB7XG4gICAgICBjb25zdCBpc0VudGVyID0gZS5rZXkgPT09ICdFbnRlcicgfHwgZS5rZXlDb2RlID09PSAxM1xuXG4gICAgICBpZiAoaXNFbnRlciAmJiB0aGlzLm9wZW5lZCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgY29uc3QgYWN0aXZlU2VjdGlvbiA9IHRoaXMuZ2V0QWN0aXZlQ29udGVudFxuICAgICAgICBpZiAoYWN0aXZlU2VjdGlvbikge1xuICAgICAgICAgIGFjdGl2ZVNlY3Rpb24ucXVlcnlTZWxlY3RvcignLmpzLXN1Ym1pdCcpLmNsaWNrKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZVxuICAgKi9cbiAgaW5pdGlhbFNldHVwKCkge1xuICAgIHRoaXMucm9vdEVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICB0aGlzLmNsb3NlKClcbiAgICB0aGlzLnN3aXRjaCgncGhvbmVfcmVnaXN0ZXInKVxuICB9XG4gIGluaXQoKSB7XG4gICAgaWYgKHRoaXMucm9vdEVsKSB7XG4gICAgICB0aGlzLmJpbmRUb2dnbGVWaXNpYmxpdHkoKVxuICAgICAgdGhpcy5iaW5kU3dpdGNoQ29udGVudCgpXG4gICAgICB0aGlzLmJpbmRPVFBJbnB1dCgpXG4gICAgICB0aGlzLmJpbmRUb2dnbGVQYXNzd29yZCgpXG4gICAgICB0aGlzLmJpbmRTdWJtaXQoKVxuICAgICAgdGhpcy5pbml0aWFsU2V0dXAoKVxuICAgICAgdGhpcy5iaW5kS2V5UHJlc3MoKVxuICAgIH1cbiAgfVxufVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zaWduLW1vZGFsJylcbiAgaWYgKG1vZGFsKSB7XG4gICAgd2luZG93LnNpZ25Nb2RhbCA9IG5ldyBTaWduTW9kYWwobW9kYWwpXG4gICAgd2luZG93LnNpZ25Nb2RhbC5pbml0KClcbiAgICBpbml0VmFsaWRhdG9ycygpXG4gIH1cbn0pXG5cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgJCgnI2J0bl9jb25maXJtX290cCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBjb25maXJtTG9naW5PdHAoKTtcbiAgfSk7XG4gICQoJyNyZXNlbmQtb3RwLWJ0bicpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICByZXNlbmRPdHAoKTtcbiAgfSk7XG4gICQoJyNmcm1fbG9naW5fb3RwJykub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHBob25lRmllbGQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGhvbmVfaW5wdXRfTG9naW4nKTtcbiAgICB2YXIgaXRpID0gd2luZG93LmludGxUZWxJbnB1dEdsb2JhbHMuZ2V0SW5zdGFuY2UocGhvbmVGaWVsZCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBmdWxsUGhvbmUgPSBpdGkuZ2V0TnVtYmVyKCk7XG4gICAgdmFyIGNvdW50cnlDb2RlID0gJysnICsgaXRpLmdldFNlbGVjdGVkQ291bnRyeURhdGEoKS5kaWFsQ29kZTtcbiAgICB2YXIgcGhvbmUgPSBmdWxsUGhvbmUucmVwbGFjZShjb3VudHJ5Q29kZSwgJycpO1xuICAgIHZhciBidG4gPSAkKGUudGFyZ2V0KS5maW5kKFwiLmpzLWxvYWRpbmctYnRuXCIpO1xuICAgICQoJyNvdHBfcGhvbmUnKS52YWwocGhvbmUpO1xuICAgICQoJyNvdHBfY291bnRyeScpLnZhbChjb3VudHJ5Q29kZSk7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9zZW5kLW90cCcsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiB7IGNvdW50cnlfY29kZTogY291bnRyeUNvZGUsIHBob25lX251bWJlcjogcGhvbmUgfSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByID0gJC5wYXJzZUpTT04oZGF0YSk7XG4gICAgICAgIHZhciBNc2dDbGFzcyA9IChyLmVycm9yKSA/ICdpcy1mYWlsZWQnIDogJ2lzLXN1Y2Nlc3NmdWwnO1xuICAgICAgICBzaG93U2lnbk1lc3NhZ2Uoci5tc2csIE1zZ0NsYXNzKTtcbiAgICAgICAgaWYgKCFyLmVycm9yKSB7XG4gICAgICAgICAgJCgnLnNpZ24tbW9kYWxfX3Bob25lLXNwYW4nKS5odG1sKGZ1bGxQaG9uZSk7XG4gICAgICAgICAgd2luZG93LnNpZ25Nb2RhbC5zd2l0Y2goJ290cCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZnVuY3Rpb24gY29uZmlybUxvZ2luT3RwKCkge1xuICB2YXIgb3RwID0gJCgnI290cF8xJykudmFsKCkgKyAkKCcjb3RwXzInKS52YWwoKSArICQoJyNvdHBfMycpLnZhbCgpICsgJCgnI290cF80JykudmFsKCk7XG4gIHZhciBwaG9uZSA9ICQoJyNvdHBfcGhvbmUnKS52YWwoKTtcbiAgdmFyIGNvdW50cnlDb2RlID0gJCgnI290cF9jb3VudHJ5JykudmFsKCk7XG4gIHZhciBidG4gPSAnI2J0bl9jb25maXJtX290cCc7XG5cblxuICBpZiAob3RwICE9ICcnICYmIG90cC5sZW5ndGggPT0gNCkge1xuICAgIHdpbmRvdy5zaWduTW9kYWwuc3RhcnRMb2FkaW5nKCk7XG4gICAgJC5hamF4KHtcbiAgICAgIHVybDogJy9jb25maXJtLW90cCcsXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICBkYXRhOiB7IGNvdW50cnlfY29kZTogY291bnRyeUNvZGUsIHBob25lX251bWJlcjogcGhvbmUsIG90cF9jb2RlOiBvdHAgfSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByID0gJC5wYXJzZUpTT04oZGF0YSk7XG4gICAgICAgIHZhciBNc2dDbGFzcyA9IChyLmVycm9yKSA/ICdpcy1mYWlsZWQnIDogJ2lzLXN1Y2Nlc3NmdWwnO1xuICAgICAgICB3aW5kb3cuc2lnbk1vZGFsLnN0b3BMb2FkaW5nKCk7XG4gICAgICAgIHNob3dTaWduTWVzc2FnZShyLm1zZywgTXNnQ2xhc3MpO1xuICAgICAgICBpZiAoIXIuZXJyb3IpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzaG93U2lnbk1lc3NhZ2UoJ0VudGVyIDQgZGlnaXRzIE9UUCcsICdpcy1mYWlsZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNlbmRPdHAoKSB7XG4gIHZhciBwaG9uZSA9ICQoJyNvdHBfcGhvbmUnKS52YWwoKTtcbiAgdmFyIGNvdW50cnlDb2RlID0gJCgnI290cF9jb3VudHJ5JykudmFsKCk7XG4gIHZhciBidG4gPSAnI3Jlc2VuZC1vdHAtYnRuJztcbiAgd2luZG93LnNpZ25Nb2RhbC5zdGFydExvYWRpbmcoKTtcbiAgJC5hamF4KHtcbiAgICB1cmw6ICcvcmVzZW5kLW90cCcsXG4gICAgdHlwZTogJ1BPU1QnLFxuICAgIGRhdGE6IHsgY291bnRyeV9jb2RlOiBjb3VudHJ5Q29kZSwgcGhvbmVfbnVtYmVyOiBwaG9uZSB9LFxuICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgciA9ICQucGFyc2VKU09OKGRhdGEpO1xuICAgICAgdmFyIE1zZ0NsYXNzID0gKHIuZXJyb3IpID8gJ2lzLWZhaWxlZCcgOiAnaXMtc3VjY2Vzc2Z1bCc7XG4gICAgICB3aW5kb3cuc2lnbk1vZGFsLnN0b3BMb2FkaW5nKCk7XG4gICAgICBzaG93U2lnbk1lc3NhZ2Uoci5tc2csIE1zZ0NsYXNzKTtcbiAgICB9XG4gIH0pXG59IiwiY29uc3QgYm9va01vZGFsID0ge1xuICBzdGVwOiAxLFxuICBhcHB0RGF0YToge30sXG5cbiAgcm9vdDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmJvb2stc2VsbCcpLFxuICBiYWNrZHJvcDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmJvb2stc2VsbF9fYmFja2Ryb3AnKSxcbiAgY29udGFpbmVyOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYm9vay1zZWxsX19jb250YWluZXInKSxcblxuICBldnROZXh0U3RlcDogJCgnW2RhdGEtZXZ0PVwiYm9va01vZGFsTmV4dFwiXScpLFxuICBldnRCYWNrU3RlcDogJCgnW2RhdGEtZXZ0PVwiYm9va01vZGFsQmFja1wiXScpLFxuICBldnRUb2dnbGU6ICQoJ1tkYXRhLWV2dD1cInRvZ2dsZUJvb2tNb2RhbFwiXScpLFxuXG4gIHNlY3Rpb25EYXRlOiAkKCcjYm9va1NlY3Rpb25EYXRlJyksXG4gIHNlY3Rpb25QZXJzb25hbDogJCgnI2Jvb2tTZWN0aW9uUGVyc29uYWwnKSxcbiAgc2VjdGlvbkNvbmZpcm06ICQoJyNib29rU2VjdGlvbkNvbmZpcm0nKSxcblxuICBpbnB1dE5hbWU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib29rRnVsbE5hbWUnKSxcbiAgaW5wdXRFbWFpbDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Jvb2tFbWFpbCcpLFxuICBpbnB1dFBob25lOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm9va1Bob25lJyksXG4gIGlucHV0QXJyOiBbdGhpcy5pbnB1dE5hbWUsIHRoaXMuaW5wdXRFbWFpbCwgdGhpcy5pbnB1dFBob25lXSxcblxuICBjb25maXJtTmFtZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Jvb2tDb25maXJtTmFtZScpLFxuICBjb25maXJtRW1haWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib29rQ29uZmlybUVtYWlsJyksXG4gIGNvbmZpcm1QaG9uZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Jvb2tDb25maXJtUGhvbmUnKSxcbiAgY29uZmlybURhdGU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib29rQ29uZmlybURhdGUnKSxcbiAgY29uZmlybVRpbWU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib29rQ29uZmlybVRpbWUnKSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucm9vdCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5kYXRlVGltZS5pbml0KClcbiAgICAgIHRoaXMuYXR0YWNoRXZlbnRzKClcbiAgICB9XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB1bmxvY2tTY3JvbGwoKVxuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKDEwMCUpJ1xuICAgIHRoaXMuYmFja2Ryb3Auc3R5bGUub3BhY2l0eSA9IDBcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUodGhpcy5jb250YWluZXIpKTtcbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgIGlmICghJCgnLmJvb2stc2VsbF9fZGF0ZS1ib3gnKS5sZW5ndGgpIHsgYm9va01vZGFsLmRhdGVUaW1lLmFwcGVuZEJveGVzKGJvb2tNb2RhbC5kYXRlVGltZS5nZXREYXRlcyh0cnVlKSkgfVxuICAgIGxvY2tTY3JvbGwoKVxuICAgIHRoaXMucm9vdC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoMCUpJ1xuICAgICAgdGhpcy5iYWNrZHJvcC5zdHlsZS5vcGFjaXR5ID0gMVxuICAgIH0sIDEpO1xuICB9LFxuICB0b2dnbGU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5yb290KS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5JykgIT09ICdub25lJykge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3BlbigpXG4gICAgfVxuICB9LFxuICBhdHRhY2hFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmV2dFRvZ2dsZS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBib29rTW9kYWwudG9nZ2xlKClcbiAgICB9KVxuICAgIHRoaXMuZXZ0TmV4dFN0ZXAuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgc3dpdGNoIChib29rTW9kYWwuc3RlcCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGJvb2tNb2RhbC5hcHB0RGF0YS5kYXRlKSB7XG4gICAgICAgICAgICBib29rTW9kYWwuc3RlcCA9IDJcbiAgICAgICAgICAgIGJvb2tNb2RhbC5zZWN0aW9uRGF0ZS5oaWRlKClcbiAgICAgICAgICAgIGJvb2tNb2RhbC5zZWN0aW9uUGVyc29uYWwuc2hvdygpXG4gICAgICAgICAgICBib29rTW9kYWwub2JzZXJ2ZXIoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmIChib29rTW9kYWwuaW5wdXROYW1lLnZhbHVlICYmIGJvb2tNb2RhbC5pbnB1dEVtYWlsLnZhbHVlICYmIGJvb2tNb2RhbC5pbnB1dFBob25lLnZhbHVlKSB7XG4gICAgICAgICAgICBib29rTW9kYWwuc3RlcCA9IDNcbiAgICAgICAgICAgIGJvb2tNb2RhbC5zZWN0aW9uUGVyc29uYWwuaGlkZSgpXG4gICAgICAgICAgICBib29rTW9kYWwuc2VjdGlvbkNvbmZpcm0uc2hvdygpXG4gICAgICAgICAgICBib29rTW9kYWwuYXBwdERhdGEubmFtZSA9IGJvb2tNb2RhbC5pbnB1dE5hbWUudmFsdWVcbiAgICAgICAgICAgIGJvb2tNb2RhbC5hcHB0RGF0YS5lbWFpbCA9IGJvb2tNb2RhbC5pbnB1dEVtYWlsLnZhbHVlXG4gICAgICAgICAgICBib29rTW9kYWwuYXBwdERhdGEucGhvbmUgPSBib29rTW9kYWwuaW5wdXRQaG9uZS52YWx1ZVxuICAgICAgICAgICAgYm9va01vZGFsLmFwcHREYXRhLnVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgICAgICAgYm9va01vZGFsLm9ic2VydmVyKClcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBib29rTW9kYWwuYXBwdERhdGEuZGF0ZV9kYXkgPSAkKCcjYm9va0NvbmZpcm1EYXRlJykudGV4dCgpO1xuICAgICAgICAgIGJvb2tNb2RhbC5hcHB0RGF0YS50aW1lID0gJCgnI2Jvb2tDb25maXJtVGltZScpLnRleHQoKTtcbiAgICAgICAgICAvL2FsZXJ0KEpTT04uc3RyaW5naWZ5KGJvb2tNb2RhbC5hcHB0RGF0YSkpIC8vIGNoYW5nZSBsYXRlclxuICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6ICcvanNvbi9ib29rLWFwcG9pbnRtZW50JyxcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIGRhdGE6IHsganNvbjogSlNPTi5zdHJpbmdpZnkoYm9va01vZGFsLmFwcHREYXRhKSB9LFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgYm9va01vZGFsLmNsb3NlKClcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgYm9va01vZGFsLnJlc2V0KClcbiAgICAgICAgICAgICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUoYm9va01vZGFsLmNvbnRhaW5lcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmV2dEJhY2tTdGVwLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHN3aXRjaCAoYm9va01vZGFsLnN0ZXApIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJvb2tNb2RhbC5jbG9zZSgpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAtLWJvb2tNb2RhbC5zdGVwXG4gICAgICAgICAgYm9va01vZGFsLm9ic2VydmVyKClcbiAgICAgICAgICBib29rTW9kYWwuc2VjdGlvblBlcnNvbmFsLmhpZGUoKVxuICAgICAgICAgIGJvb2tNb2RhbC5zZWN0aW9uRGF0ZS5zaG93KClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIC0tYm9va01vZGFsLnN0ZXBcbiAgICAgICAgICBib29rTW9kYWwub2JzZXJ2ZXIoKVxuICAgICAgICAgIGJvb2tNb2RhbC5zZWN0aW9uQ29uZmlybS5oaWRlKClcbiAgICAgICAgICBib29rTW9kYWwuc2VjdGlvblBlcnNvbmFsLnNob3coKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pXG4gICAgY29uc3QgYXR0YWNoSW5wdXRPYmVzcnZlciA9ICgpID0+IHtcbiAgICAgIGxldCBhcnIgPSBbYm9va01vZGFsLmlucHV0TmFtZSwgYm9va01vZGFsLmlucHV0RW1haWwsIGJvb2tNb2RhbC5pbnB1dFBob25lXVxuICAgICAgYXJyLmZvckVhY2goKGVsKSA9PiB7IGVsLm9uaW5wdXQgPSAoKSA9PiB7IGJvb2tNb2RhbC5vYnNlcnZlcigpIH0gfSlcbiAgICB9XG4gICAgYXR0YWNoSW5wdXRPYmVzcnZlcigpXG4gIH0sXG5cbiAgZGF0ZVRpbWU6IHtcbiAgICBpbnRlcnZhbHM6IFtbMTEsIDBvMCwgMG8wXSwgWzEzLCAzMCwgMG8wXSwgWzE1LCAzMCwgMG8wXSwgWzE2LCAwbzAsIDBvMF0sIFsxNiwgMzAsIDBvMF1dLFxuICAgIGRheXNQZXJWaWV3OiAzLFxuICAgIGhvbGRlcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Jvb2tTZWxsRGF0ZXMnKSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYXR0YWNoRXZlbnRzKClcbiAgICAgIHRoaXMuYXBwZW5kQm94ZXModGhpcy5nZXREYXRlcyh0cnVlKSlcbiAgICB9LFxuICAgIHJlbmRlckhUTUw6IChkYXRlKSA9PiB7XG4gICAgICBjb25zdCB3ZWVrZGF5ID0gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLVVTJywgeyB3ZWVrZGF5OiAnbG9uZycgfSksIGRheSA9IGRhdGUuZ2V0RGF0ZSgpLCBtb250aCA9IGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHsgbW9udGg6ICdzaG9ydCcgfSksIHRpbWUgPSBkYXRlLnRvTG9jYWxlVGltZVN0cmluZygnZW4tVVMnLCB7IGhvdXI6ICdudW1lcmljJywgaG91cjEyOiB0cnVlLCBtaW51dGU6ICdudW1lcmljJyB9KVxuXG4gICAgICBsZXQgaWZQYXN0ID0gbmV3IERhdGUoKSA+IGRhdGUgPyAnIGRpc2FibGVkJyA6ICcnXG4gICAgICBsZXQgZGF5VGltZSA9IGRhdGUuZ2V0RGF5KCkgPT0gNiA/ICdDbG9zZWQnIDogZGF0ZS5nZXREYXkoKSA9PSAwID8gJ0Nsb3NlZCcgOiB0aW1lXG4gICAgICBsZXQgaXNXZWVrZW5kID0gZGF0ZS5nZXREYXkoKSA9PSA2ID8gJyBpcy1jbG9zZWQnIDogZGF0ZS5nZXREYXkoKSA9PSAwID8gJyBpcy1jbG9zZWQnIDogJydcblxuICAgICAgcmV0dXJuIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJib29rLXNlbGxfX2RhdGUtYm94JHtpc1dlZWtlbmR9XCIgZGF0YS10aW1lPVwiJHtTdHJpbmcoZGF0ZSl9XCIke2lmUGFzdH0+XG4gICAgICAgIDxzcGFuPiR7d2Vla2RheX0sICR7ZGF5fSR7Z2V0T3JkaW5hbFR4dChkYXkpfSAke21vbnRofTwvc3Bhbj5cbiAgICAgICAgPHNwYW4+JHtkYXlUaW1lfTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgICAgYFxuICAgIH0sXG4gICAgYXBwZW5kQm94ZXM6IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgIGFyci5mb3JFYWNoKChlbCkgPT4gdGhpcy5ob2xkZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBlbCkpXG4gICAgfSxcbiAgICBnZXREYXRlczogZnVuY3Rpb24gKGlzTmV4dCkge1xuICAgICAgbGV0IGRheXNBcnIgPSBbXSwgaW5pdGlhbCA9IDBcbiAgICAgIGxldCBhcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJvb2stc2VsbF9fZGF0ZS1ib3gnKV1cbiAgICAgIGxldCBpbml0aWFsRGF0ZVxuXG4gICAgICBpZiAoYXJyLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGluaXRpYWxEYXRlID0gbmV3IERhdGUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmV4dCA9PSB0cnVlKSB7XG4gICAgICAgICAgaW5pdGlhbERhdGUgPSBuZXcgRGF0ZShhcnJbYXJyLmxlbmd0aCAtIDFdLmdldEF0dHJpYnV0ZSgnZGF0YS10aW1lJykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdGlhbERhdGUgPSBuZXcgRGF0ZShhcnJbMF0uZ2V0QXR0cmlidXRlKCdkYXRhLXRpbWUnKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBhcnIuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSk7XG4gICAgICAgIGlmIChpc05leHQgPT0gdHJ1ZSkge1xuICAgICAgICAgIGluaXRpYWxEYXRlLnNldERhdGUoaW5pdGlhbERhdGUuZ2V0RGF0ZSgpICsgMSlcbiAgICAgICAgfSBlbHNlIHsgaW5pdGlhbERhdGUuc2V0RGF0ZShpbml0aWFsRGF0ZS5nZXREYXRlKCkgLSAxKSB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpbml0aWFsICE9PSB0aGlzLmRheXNQZXJWaWV3KSB7XG4gICAgICAgIGxldCBkYXlEYXRlID0gbmV3IERhdGUoaW5pdGlhbERhdGUpXG4gICAgICAgIGlmIChpc05leHQgPT0gdHJ1ZSkgeyBkYXlzQXJyLnB1c2gobmV3IERhdGUoZGF5RGF0ZS5zZXREYXRlKGluaXRpYWxEYXRlLmdldERhdGUoKSArIGluaXRpYWwpKSkgfSBlbHNlIHtcbiAgICAgICAgICBkYXlzQXJyLnB1c2gobmV3IERhdGUoZGF5RGF0ZS5zZXREYXRlKGluaXRpYWxEYXRlLmdldERhdGUoKSAtIGluaXRpYWwpKSlcbiAgICAgICAgfVxuICAgICAgICArK2luaXRpYWxcbiAgICAgIH1cblxuICAgICAgbGV0IGludHMgPSBpc05leHQgPT0gdHJ1ZSA/IHRoaXMuaW50ZXJ2YWxzIDogdGhpcy5pbnRlcnZhbHMuc2xpY2UoKS5yZXZlcnNlKClcblxuICAgICAgbGV0IGh0bWxBcnIgPSBkYXlzQXJyLnJlZHVjZSgoYWNjLCBkYXRlKSA9PiB7XG4gICAgICAgIGludHMuZm9yRWFjaCgoaW50ZXJ2YWwpID0+IHtcbiAgICAgICAgICBsZXQgdGhpc0RhdGUgPSBuZXcgRGF0ZShkYXRlKVxuICAgICAgICAgIHRoaXNEYXRlLnNldEhvdXJzKC4uLmludGVydmFsKVxuICAgICAgICAgIGFjYy5wdXNoKHRoaXMucmVuZGVySFRNTCh0aGlzRGF0ZSkpXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBhY2NcbiAgICAgIH0sIFtdKVxuXG4gICAgICBpZiAoaXNOZXh0ID09IHRydWUpIHsgcmV0dXJuIGh0bWxBcnIgfSBlbHNlIHsgcmV0dXJuIGh0bWxBcnIucmV2ZXJzZSgpIH1cbiAgICB9LFxuICAgIGF0dGFjaEV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgJCgnW2RhdGEtc3dpdGNoLXRpbWVdJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgYXR0ciA9ICQodGhpcykuYXR0cignZGF0YS1zd2l0Y2gtdGltZScpXG4gICAgICAgIHN3aXRjaCAoYXR0cikge1xuICAgICAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICAgICAgYm9va01vZGFsLmRhdGVUaW1lLmFwcGVuZEJveGVzKGJvb2tNb2RhbC5kYXRlVGltZS5nZXREYXRlcyh0cnVlKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ByZXYnOlxuICAgICAgICAgICAgaWYgKFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYm9vay1zZWxsX19kYXRlLWJveCcpXVswXSlcbiAgICAgICAgICAgICAgYm9va01vZGFsLmRhdGVUaW1lLmFwcGVuZEJveGVzKGJvb2tNb2RhbC5kYXRlVGltZS5nZXREYXRlcyhmYWxzZSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcuYm9vay1zZWxsX19kYXRlLWJveCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkKHRoaXMpLnRvZ2dsZUNsYXNzKElTX0FDVElWRSkuc2libGluZ3MoKS5yZW1vdmVDbGFzcyhJU19BQ1RJVkUpXG4gICAgICAgICAgYm9va01vZGFsLm9ic2VydmVyKClcbiAgICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgb2JzZXJ2ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RlcCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBsZXQgYWN0aXZlRGF0ZSA9ICQoJy5ib29rLXNlbGxfX2RhdGUtYm94JykuZmlsdGVyKGAuJHtJU19BQ1RJVkV9YClcbiAgICAgICAgaWYgKGFjdGl2ZURhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5hcHB0RGF0YS5kYXRlID0gbmV3IERhdGUoYWN0aXZlRGF0ZS5hdHRyKCdkYXRhLXRpbWUnKSlcbiAgICAgICAgICB0aGlzLmV2dE5leHRTdGVwLmF0dHIoJ2Rpc2FibGVkJywgZmFsc2UpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYXBwdERhdGEuZGF0ZVxuICAgICAgICAgIHRoaXMuZXZ0TmV4dFN0ZXAuYXR0cignZGlzYWJsZWQnLCB0cnVlKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBpZiAodGhpcy5pbnB1dE5hbWUudmFsdWUgJiYgdGhpcy5pbnB1dEVtYWlsLnZhbHVlICYmIHRoaXMuaW5wdXRQaG9uZS52YWx1ZSAmJiB0aGlzLmFwcHREYXRhLmRhdGUpIHtcbiAgICAgICAgICB0aGlzLmV2dE5leHRTdGVwLmF0dHIoJ2Rpc2FibGVkJywgZmFsc2UpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ldnROZXh0U3RlcC5hdHRyKCdkaXNhYmxlZCcsIHRydWUpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMuY29uZmlybU5hbWUuaW5uZXJIVE1MID0gdGhpcy5hcHB0RGF0YS5uYW1lXG4gICAgICAgIHRoaXMuY29uZmlybUVtYWlsLmlubmVySFRNTCA9IHRoaXMuYXBwdERhdGEuZW1haWxcbiAgICAgICAgdGhpcy5jb25maXJtUGhvbmUuaW5uZXJIVE1MID0gdGhpcy5hcHB0RGF0YS5waG9uZVxuICAgICAgICB0aGlzLmNvbmZpcm1EYXRlLmlubmVySFRNTCA9IGAke3RoaXMuYXBwdERhdGEuZGF0ZS5nZXREYXRlKCl9JHtnZXRPcmRpbmFsVHh0KHRoaXMuYXBwdERhdGEuZGF0ZS5nZXREYXRlKCkpfSAke3RoaXMuYXBwdERhdGEuZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLVVTJywgeyBtb250aDogJ2xvbmcnIH0pfWBcbiAgICAgICAgdGhpcy5jb25maXJtVGltZS5pbm5lckhUTUwgPSB0aGlzLmFwcHREYXRhLmRhdGUudG9Mb2NhbGVUaW1lU3RyaW5nKCdlbi1VUycsIHsgaG91cjogJ251bWVyaWMnLCBob3VyMTI6IHRydWUsIG1pbnV0ZTogJ251bWVyaWMnIH0pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBib29rTW9kYWwuc3RlcCA9IDFcbiAgICBsZXQgaW5wdXRBcnIgPSBbdGhpcy5pbnB1dE5hbWUsIHRoaXMuaW5wdXRFbWFpbCwgdGhpcy5pbnB1dFBob25lXVxuICAgIGlucHV0QXJyLmZvckVhY2goKGVsKSA9PiB7IGVsLnZhbHVlID0gJycgfSlcbiAgICAkKCcuYm9vay1zZWxsX19kYXRlLWJveCcpLnJlbW92ZUNsYXNzKElTX0FDVElWRSlcbiAgICBib29rTW9kYWwuc2VjdGlvbkNvbmZpcm0uaGlkZSgpXG4gICAgYm9va01vZGFsLnNlY3Rpb25QZXJzb25hbC5oaWRlKClcbiAgICBib29rTW9kYWwuc2VjdGlvbkRhdGUuc2hvdygpXG4gICAgT2JqZWN0LnZhbHVlcyhib29rTW9kYWwuYXBwdERhdGEpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBkZWxldGUgZWxcbiAgICB9KVxuICAgICQoJy5ib29rLXNlbGxfX2RhdGUtYm94JykucmVtb3ZlKClcbiAgICBib29rTW9kYWwub2JzZXJ2ZXIoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYm9va01vZGFsIiwiY2xhc3MgQ2FyZU1vZGFsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhcmUtbW9kYWwnKVxuICAgIHRoaXMub3BlbkFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jYXJlLW9wZW5dJyldXG4gICAgdGhpcy5jbG9zZUFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jYXJlLWNsb3NlXScpXVxuICAgIHRoaXMuY29udGVudEFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jYXJlLWNvbnRlbnRdJyldXG4gICAgdGhpcy5hY3RpdmVTZWN0aW9uID0gdW5kZWZpbmVkXG4gICAgdGhpcy5vcGVuZWQgPSBmYWxzZVxuICAgIHRoaXMuaW5pdCgpXG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmJpbmRFdmVudHMoKVxuICAgIHRoaXMuc2V0U29hcE92ZXJsYXkoKVxuICB9XG5cbiAgLy8gVXRpbHNcbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jb250ZW50QXJyLmZvckVhY2goZSA9PiBlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZScpXG4gICAgdGhpcy5jb250ZW50QXJyWzBdLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gIH1cblxuICAvLyBFdmVudHNcbiAgYmluZEV2ZW50cygpIHtcbiAgICAvLyBPcGVuXG4gICAgZm9yIChjb25zdCBlbGVtIG9mIHRoaXMub3BlbkFycikge1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgdGhpcy5zd2l0Y2hDb250ZW50KGVsZW0uZGF0YXNldC5jYXJlT3BlbilcbiAgICAgICAgdGhpcy5zaG93KClcbiAgICAgIH0pXG4gICAgfVxuICAgIC8vIEhpZGVcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdGhpcy5jbG9zZUFycikge1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgIH0pXG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0XG4gICAgICBpZiAodGhpcy5vcGVuZWQgJiYgIXRhcmdldC5jbG9zZXN0KCcuY2FyZS1tb2RhbCcpICYmICF0YXJnZXQuY2xvc2VzdCgnW2RhdGEtY2FyZS1vcGVuXScpKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIFRvZ2dsZSB2aWV3XG4gIGhpZGUoKSB7XG4gICAgaWYgKHdpbmRvdy5jYXJlQmFja2Ryb3ApIHtcbiAgICAgIHdpbmRvdy5jYXJlQmFja2Ryb3AuaGlkZSh0cnVlKVxuICAgIH1cblxuICAgIHRoaXMub3BlbmVkID0gZmFsc2VcbiAgICB1bmxvY2tTY3JvbGwoKVxuICAgIHRoaXMuZWxlbS5jbGFzc0xpc3QucmVtb3ZlKF9fVklTSUJMRSlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICB0aGlzLnJlc2V0KClcbiAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmVsZW0pKTtcbiAgfVxuICBzaG93KCkge1xuXG4gICAgd2luZG93LmNhcmVCYWNrZHJvcCA9IG5ldyB3aW5kb3cuQmFja2Ryb3Aoe1xuICAgICAgaGFsZjogdHJ1ZSxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMub3BlbmVkID0gdHJ1ZVxuICAgIGxvY2tTY3JvbGwoKVxuICAgIHRoaXMuZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuXG4gICAgaWYgKHRoaXMuYWN0aXZlU2VjdGlvbikge1xuICAgICAgY29uc3QgYm9keSA9IHRoaXMuYWN0aXZlU2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcuY2FyZS1tb2RhbF9fYm9keScpXG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICBib2R5LnNjcm9sbFRvcCA9IDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5lbGVtLmNsYXNzTGlzdC5hZGQoX19WSVNJQkxFKVxuICAgIH0pXG4gIH1cbiAgc3dpdGNoQ29udGVudCh0eXBlKSB7XG4gICAgY29uc3Qgc2VjdGlvblRvU2hvdyA9IHRoaXMuY29udGVudEFyci5maW5kKGUgPT4gZS5kYXRhc2V0LmNhcmVDb250ZW50ID09PSB0eXBlKSB8fCB0aGlzLmNvbnRlbnRBcnJbMF1cbiAgICB0aGlzLmFjdGl2ZVNlY3Rpb24gPSBzZWN0aW9uVG9TaG93XG5cbiAgICB0aGlzLmNvbnRlbnRBcnIuZm9yRWFjaChlID0+IGUuc3R5bGUuZGlzcGxheSA9ICdub25lJylcbiAgICBzZWN0aW9uVG9TaG93LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gIH1cblxuICAvLyBBbmltYXRpb24gQmFja2dyb3VuZFxuICBzZXRTb2FwT3ZlcmxheSgpIHtcbiAgICBjb25zdCBpc01vYmlsZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCA8IDk5MlxuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc29hcF9vdmVybGF5Jyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBidWJibGVzID0gW107XG4gICAgdmFyIGJ1YmJsZUNvdW50ID0gaXNNb2JpbGUoKSA/IDIwIDogMzU7XG4gICAgdmFyIGJ1YmJsZVNwZWVkID0gaXNNb2JpbGUoKSA/IDEuNiA6IDIuMjtcbiAgICB2YXIgcG9wTGluZXMgPSA2O1xuICAgIHZhciBwb3BEaXN0YW5jZSA9IDEwO1xuICAgIHZhciBzdHJva2VDb2xvciA9ICcjZmZmZmZmZjgnO1xuXG4gICAgLy8g0J/QtdGA0LXQvNC10L3QvdGL0LUg0LTQu9GPINGA0LDQt9C80LXRgNC+0LIg0L/Rg9C30YvRgNGM0LrQvtCyXG4gICAgdmFyIG1pbkJ1YmJsZVNpemUgPSA0OyAvLyDQnNC40L3QuNC80LDQu9GM0L3Ri9C5INGA0LDQt9C80LXRgCDQv9GD0LfRi9GA0YzQutCwXG4gICAgdmFyIG1heEJ1YmJsZVNpemUgPSBpc01vYmlsZSgpID8gMjggOiA0NjsgLy8g0JzQsNC60YHQuNC80LDQu9GM0L3Ri9C5INGA0LDQt9C80LXRgCDQv9GD0LfRi9GA0YzQutCwXG4gICAgdmFyIHJhbmRvbUJ1YmJsZVNpemUgPSB0cnVlOyAvLyB0cnVlINC00LvRjyDRgdC70YPRh9Cw0LnQvdGL0YUg0YDQsNC30LzQtdGA0L7QsiwgZmFsc2Ug0LTQu9GPINGE0LjQutGB0LjRgNC+0LLQsNC90L3QvtCz0L4g0YDQsNC30LzQtdGA0LBcblxuICAgIC8vINCf0LXRgNC10LzQtdC90L3Ri9C1INC00LvRjyDQutC+0L3RgtGA0L7Qu9GPINC/0YDQvtC30YDQsNGH0L3QvtGB0YLQuCDQv9GD0LfRi9GA0YzQutC+0LIgKNC+0YIgMCDQtNC+IDEpXG4gICAgdmFyIGJ1YmJsZU9wYWNpdHkgPSAxOyAgICAvLyDQnNCw0LrRgdC40LzQsNC70YzQvdCw0Y8g0L/RgNC+0LfRgNCw0YfQvdC+0YHRgtGMINC/0YPQt9GL0YDRjNC60L7QslxuICAgIHZhciBtaW5pbWFsT3BhY2l0eSA9IDE7ICAgLy8g0JzQuNC90LjQvNCw0LvRjNC90LDRjyDQv9GA0L7Qt9GA0LDRh9C90L7RgdGC0Ywg0L/Rg9C30YvRgNGM0LrQvtCyXG4gICAgdmFyIHJhbmRvbU9wYWNpdHkgPSBmYWxzZTsgICAvLyB0cnVlINC00LvRjyDRgdC70YPRh9Cw0LnQvdC+0Lkg0L/RgNC+0LfRgNCw0YfQvdC+0YHRgtC4LCBmYWxzZSDQtNC70Y8g0YTQuNC60YHQuNGA0L7QstCw0L3QvdC+0LlcblxuICAgIC8vINCf0LXRgNC10LzQtdC90L3QsNGPINC00LvRjyDQv9GA0L7RhtC10L3RgtCwINC/0YPQt9GL0YDRjNC60L7Qsiwg0LrQvtGC0L7RgNGL0LUg0LHRg9C00YPRgiDQu9C+0L/QsNGC0YzRgdGPINGB0LDQvNC4INC/0L4g0YHQtdCx0LVcbiAgICB2YXIgcG9wUGVyY2VudGFnZSA9IDk4OyAvLyDQn9GA0L7RhtC10L3RgiDQv9GD0LfRi9GA0YzQutC+0LIsINC60L7RgtC+0YDRi9C1INCx0YPQtNGD0YIg0LvQvtC/0LDRgtGM0YHRjyAo0L7RgiAwINC00L4gMTAwKVxuXG4gICAgLy8g0J/QtdGA0LXQvNC10L3QvdCw0Y8g0LTQu9GPINGD0L/RgNCw0LLQu9C10L3QuNGPINC/0LvQsNCy0L3Ri9C8INC40YHRh9C10LfQvdC+0LLQtdC90LjQtdC8INC/0YPQt9GL0YDRjNC60L7QslxuICAgIHZhciBmYWRlT3V0ID0gdHJ1ZTsgLy8gdHJ1ZSDQtNC70Y8g0LLQutC70Y7Rh9C10L3QuNGPINGN0YTRhNC10LrRgtCwINC/0LvQsNCy0L3QvtCz0L4g0LjRgdGH0LXQt9C90L7QstC10L3QuNGPLCBmYWxzZSDQtNC70Y8g0L7RgtC60LvRjtGH0LXQvdC40Y9cblxuICAgIC8vINCk0YPQvdC60YbQuNGPINC00LvRjyDRg9GB0YLQsNC90L7QstC60Lgg0YDQsNC30LzQtdGA0L7QsiBjYW52YXNcbiAgICBmdW5jdGlvbiBzZXRDYW52YXNTaXplKCkge1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8g0KPRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0YDQsNC30LzQtdGA0YsgY2FudmFzINC/0YDQuCDQt9Cw0LPRgNGD0LfQutC1INGB0YLRgNCw0L3QuNGG0YtcbiAgICBzZXRDYW52YXNTaXplKCk7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLVxuICAgIC8vINCm0LjQutC7INCw0L3QuNC80LDRhtC40LhcbiAgICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gICAgZnVuY3Rpb24gYW5pbWF0ZSgpIHtcblxuICAgICAgLy8g0J7Rh9C40YHRgtC60LAgQ2FudmFzXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIC8vINCg0LjRgdGD0LXQvCDQv9GD0LfRi9GA0YzQutC4XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1YmJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnViYmxlc1tpXS5wb3NpdGlvbi54ID0gTWF0aC5zaW4oYnViYmxlc1tpXS5jb3VudCAvIGJ1YmJsZXNbaV0uZGlzdGFuY2VCZXR3ZWVuV2F2ZXMpICogNTAgKyBidWJibGVzW2ldLnhPZmY7XG4gICAgICAgIGJ1YmJsZXNbaV0ucG9zaXRpb24ueSA9IGJ1YmJsZXNbaV0uY291bnQ7XG4gICAgICAgIGJ1YmJsZXNbaV0ucmVuZGVyKCk7XG5cbiAgICAgICAgaWYgKGJ1YmJsZXNbaV0uY291bnQgPCAwIC0gYnViYmxlc1tpXS5yYWRpdXMpIHtcbiAgICAgICAgICBidWJibGVzW2ldLmNvdW50ID0gY2FudmFzLmhlaWdodCArIGJ1YmJsZXNbaV0ueU9mZjtcbiAgICAgICAgICBidWJibGVzW2ldLnJlc2V0UHJvcGVydGllcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1YmJsZXNbaV0uY291bnQgLT0gYnViYmxlU3BlZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQm9C+0LPQuNC60LAg0LDQstGC0L7QvdC+0LzQvdC+0LPQviDQu9C+0L/QsNC90LjRjyDQv9GD0LfRi9GA0YzQutCwXG4gICAgICAgIGlmICghYnViYmxlc1tpXS5wb3BwaW5nICYmIGJ1YmJsZXNbaV0uc2hvdWxkUG9wKCkpIHtcbiAgICAgICAgICBidWJibGVzW2ldLmluaXRpYXRlUG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICB9XG5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8g0JrQvtC90YHRgtGA0YPQutGC0L7RgCDQv9GD0LfRi9GA0YzQutCwXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgY3JlYXRlQnViYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgdGhpcy5yYWRpdXMgPSBnZXRCdWJibGVSYWRpdXMoKTtcbiAgICAgIHRoaXMueE9mZiA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXMud2lkdGggLSB0aGlzLnJhZGl1cztcbiAgICAgIHRoaXMueU9mZiA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXMuaGVpZ2h0O1xuICAgICAgdGhpcy5kaXN0YW5jZUJldHdlZW5XYXZlcyA9IDUwICsgTWF0aC5yYW5kb20oKSAqIDQwO1xuICAgICAgdGhpcy5jb3VudCA9IGNhbnZhcy5oZWlnaHQgKyB0aGlzLnlPZmY7XG4gICAgICB0aGlzLmNvbG9yID0gc3Ryb2tlQ29sb3I7XG4gICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgICB0aGlzLnBvcHBpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubWF4Um90YXRpb24gPSAxNDA7XG4gICAgICB0aGlzLnJvdGF0aW9uID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHRoaXMubWF4Um90YXRpb24gKiAyKSkgLSB0aGlzLm1heFJvdGF0aW9uO1xuICAgICAgdGhpcy5yb3RhdGlvbkRpcmVjdGlvbiA9ICdmb3J3YXJkJztcbiAgICAgIHRoaXMub3BhY2l0eSA9IGdldEJ1YmJsZU9wYWNpdHkoKTsgLy8g0KPRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0L3QsNGH0LDQu9GM0L3Rg9GOINC/0YDQvtC30YDQsNGH0L3QvtGB0YLRjFxuXG4gICAgICAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LvQuNC90LjQuCDQtNC70Y8g0LDQvdC40LzQsNGG0LjQuCDQu9C+0L/QsNC90LjRj1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3BMaW5lczsgaSsrKSB7XG4gICAgICAgIHZhciB0ZW1wTGluZSA9IG5ldyBjcmVhdGVMaW5lKCk7XG4gICAgICAgIHRlbXBMaW5lLmJ1YmJsZSA9IHRoaXM7XG4gICAgICAgIHRlbXBMaW5lLmluZGV4ID0gaTtcblxuICAgICAgICB0aGlzLmxpbmVzLnB1c2godGVtcExpbmUpO1xuICAgICAgfVxuXG4gICAgICAvLyDQpNC70LDQsywg0YPQutCw0LfRi9Cy0LDRjtGJ0LjQuSwg0LTQvtC70LbQtdC9INC70Lgg0L/Rg9C30YvRgNC10Log0LvQvtC/0L3Rg9GC0YxcbiAgICAgIHRoaXMud2lsbFBvcCA9IE1hdGgucmFuZG9tKCkgPCBwb3BQZXJjZW50YWdlIC8gMTAwO1xuICAgICAgLy8g0KLQvtGH0LrQsCwg0LIg0LrQvtGC0L7RgNC+0Lkg0L/Rg9C30YvRgNC10Log0LvQvtC/0L3QtdGCICjRgdC70YPRh9Cw0LnQvdCw0Y8g0L/QvtC30LjRhtC40Y8g0L/QviBZKVxuICAgICAgdGhpcy5wb3BQb2ludCA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXMuaGVpZ2h0O1xuXG4gICAgICB0aGlzLnJlc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSBnZXRCdWJibGVSYWRpdXMoKTtcbiAgICAgICAgdGhpcy54T2ZmID0gTWF0aC5yYW5kb20oKSAqIGNhbnZhcy53aWR0aCAtIHRoaXMucmFkaXVzO1xuICAgICAgICB0aGlzLnlPZmYgPSBNYXRoLnJhbmRvbSgpICogY2FudmFzLmhlaWdodDtcbiAgICAgICAgdGhpcy5kaXN0YW5jZUJldHdlZW5XYXZlcyA9IDUwICsgTWF0aC5yYW5kb20oKSAqIDQwO1xuICAgICAgICB0aGlzLnBvcHBpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53aWxsUG9wID0gTWF0aC5yYW5kb20oKSA8IHBvcFBlcmNlbnRhZ2UgLyAxMDA7XG4gICAgICAgIHRoaXMucG9wUG9pbnQgPSBNYXRoLnJhbmRvbSgpICogY2FudmFzLmhlaWdodDtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gZ2V0QnViYmxlT3BhY2l0eSgpOyAvLyDQodCx0YDQsNGB0YvQstCw0LXQvCDQv9GA0L7Qt9GA0LDRh9C90L7RgdGC0YxcblxuICAgICAgICAvLyDQodCx0YDQsNGB0YvQstCw0LXQvCDRgdC+0YHRgtC+0Y/QvdC40Y8g0LvQuNC90LjQuVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmxpbmVzW2ldLnJlc2V0VmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8LCDQtNC+0LvQttC10L0g0LvQuCDQv9GD0LfRi9GA0LXQuiDQu9C+0L/QvdGD0YLRjCDQsiDRgtC10LrRg9GJ0LXQuSDQv9C+0LfQuNGG0LjQuFxuICAgICAgdGhpcy5zaG91bGRQb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbGxQb3AgJiYgdGhpcy5wb3NpdGlvbi55IDw9IHRoaXMucG9wUG9pbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vINCY0L3QuNGG0LjQsNC70LjQt9C40YDRg9C10Lwg0L/RgNC+0YbQtdGB0YEg0LvQvtC/0LDQvdC40Y9cbiAgICAgIHRoaXMuaW5pdGlhdGVQb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucG9wcGluZyA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdGhpcy5saW5lcy5sZW5ndGg7IGErKykge1xuICAgICAgICAgIHRoaXMubGluZXNbYV0ucG9wcGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8g0KDQtdC90LTQtdGA0LjQvdCzINC/0YPQt9GL0YDRjNC60LBcbiAgICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yb3RhdGlvbkRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgaWYgKHRoaXMucm90YXRpb24gPCB0aGlzLm1heFJvdGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb25EaXJlY3Rpb24gPSAnYmFja3dhcmQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5yb3RhdGlvbiA+IC10aGlzLm1heFJvdGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uLS07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb25EaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSk7XG4gICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbiAqIE1hdGguUEkgLyAxODApO1xuXG4gICAgICAgIC8vINCe0LHQvdC+0LLQu9GP0LXQvCDQv9GA0L7Qt9GA0LDRh9C90L7RgdGC0YwsINC10YHQu9C4INCy0LrQu9GO0YfQtdC9INGN0YTRhNC10LrRgiBmYWRlT3V0XG4gICAgICAgIGlmIChmYWRlT3V0ICYmICF0aGlzLnBvcHBpbmcpIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2VSZW1haW5pbmcgPSB0aGlzLnBvc2l0aW9uLnkgKyB0aGlzLnJhZGl1cztcbiAgICAgICAgICB2YXIgdG90YWxEaXN0YW5jZSA9IGNhbnZhcy5oZWlnaHQgKyB0aGlzLnJhZGl1cztcbiAgICAgICAgICB2YXIgZmFkZU9wYWNpdHkgPSB0aGlzLm9wYWNpdHkgKiAoZGlzdGFuY2VSZW1haW5pbmcgLyB0b3RhbERpc3RhbmNlKTtcbiAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBmYWRlT3BhY2l0eSA8IDAgPyAwIDogZmFkZU9wYWNpdHk7IC8vINCe0LHQtdGB0L/QtdGH0LjQstCw0LXQvCwg0YfRgtC+INC/0YDQvtC30YDQsNGH0L3QvtGB0YLRjCDQvdC1INC+0YLRgNC40YbQsNGC0LXQu9GM0L3QsNGPXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnBvcHBpbmcpIHtcbiAgICAgICAgICAvLyDQoNC40YHRg9C10Lwg0LLQvdC10YjQvdC40Lkg0LrQvtC90YLRg9GAINC/0YPQt9GL0YDRjNC60LBcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICBjdHguYXJjKDAsIDAsIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICAgIC8vINCg0LjRgdGD0LXQvCDQsdC70LjQulxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoLXRoaXMucmFkaXVzIC8gMywgLXRoaXMucmFkaXVzIC8gMywgMCwgLXRoaXMucmFkaXVzIC8gMywgLXRoaXMucmFkaXVzIC8gMywgdGhpcy5yYWRpdXMpO1xuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpJyk7XG4gICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDApJyk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgICAgICAgIGN0eC5hcmMoLXRoaXMucmFkaXVzIC8gMywgLXRoaXMucmFkaXVzIC8gMywgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7IC8vINCh0LHRgNCw0YHRi9Cy0LDQtdC8INC/0YDQvtC30YDQsNGH0L3QvtGB0YLRjCDQtNC70Y8g0LTRgNGD0LPQuNGFINGN0LvQtdC80LXQvdGC0L7QslxuXG4gICAgICAgIC8vINCg0LjRgdGD0LXQvCDQu9C40L3QuNC4INC/0YDQuCDQu9C+0L/QsNC90LjQuFxuICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHRoaXMubGluZXMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5saW5lc1thXS5wb3BwaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lc1thXS5saW5lTGVuZ3RoIDwgcG9wRGlzdGFuY2UgJiYgIXRoaXMubGluZXNbYV0uaW52ZXJzZVBvcCkge1xuICAgICAgICAgICAgICB0aGlzLmxpbmVzW2FdLnBvcERpc3RhbmNlICs9IDAuMDY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy5saW5lc1thXS5wb3BEaXN0YW5jZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lc1thXS5pbnZlcnNlUG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVzW2FdLnBvcERpc3RhbmNlUmV0dXJuICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lc1thXS5wb3BEaXN0YW5jZSAtPSAwLjAzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGluZXNbYV0ucmVzZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0UHJvcGVydGllcygpO1xuICAgICAgICAgICAgICAgIC8vINCf0LXRgNC10LfQsNC/0YPRgdC60LDQtdC8INC/0YPQt9GL0YDQtdC6INC/0L7RgdC70LUg0LvQvtC/0LDQvdC40Y9cbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gY2FudmFzLmhlaWdodCArIHRoaXMueU9mZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxpbmVzW2FdLnVwZGF0ZVZhbHVlcygpO1xuICAgICAgICAgICAgdGhpcy5saW5lc1thXS5yZW5kZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDQpNGD0L3QutGG0LjRjyDQtNC70Y8g0L7Qv9GA0LXQtNC10LvQtdC90LjRjyDRgNCw0LTQuNGD0YHQsCDQv9GD0LfRi9GA0YzQutCwXG4gICAgZnVuY3Rpb24gZ2V0QnViYmxlUmFkaXVzKCkge1xuICAgICAgaWYgKHJhbmRvbUJ1YmJsZVNpemUpIHtcbiAgICAgICAgLy8g0KHQu9GD0YfQsNC50L3Ri9C5INGA0LDQt9C80LXRgCDQvNC10LbQtNGDINC80LjQvdC40LzQsNC70YzQvdGL0Lwg0Lgg0LzQsNC60YHQuNC80LDQu9GM0L3Ri9C8XG4gICAgICAgIHJldHVybiBtaW5CdWJibGVTaXplICsgTWF0aC5yYW5kb20oKSAqIChtYXhCdWJibGVTaXplIC0gbWluQnViYmxlU2l6ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyDQpNC40LrRgdC40YDQvtCy0LDQvdC90YvQuSDRgNCw0LfQvNC10YAgKNGB0YDQtdC00L3QtdC1INC30L3QsNGH0LXQvdC40LUg0LzQtdC20LTRgyDQvNC40L3QuNC80LDQu9GM0L3Ri9C8INC4INC80LDQutGB0LjQvNCw0LvRjNC90YvQvClcbiAgICAgICAgcmV0dXJuIChtaW5CdWJibGVTaXplICsgbWF4QnViYmxlU2l6ZSkgLyAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vINCk0YPQvdC60YbQuNGPINC00LvRjyDQvtC/0YDQtdC00LXQu9C10L3QuNGPINC/0YDQvtC30YDQsNGH0L3QvtGB0YLQuCDQv9GD0LfRi9GA0YzQutCwXG4gICAgZnVuY3Rpb24gZ2V0QnViYmxlT3BhY2l0eSgpIHtcbiAgICAgIGlmIChyYW5kb21PcGFjaXR5KSB7XG4gICAgICAgIC8vINCh0LvRg9GH0LDQudC90LDRjyDQv9GA0L7Qt9GA0LDRh9C90L7RgdGC0Ywg0LzQtdC20LTRgyDQvNC40L3QuNC80LDQu9GM0L3QvtC5INC4INC80LDQutGB0LjQvNCw0LvRjNC90L7QuVxuICAgICAgICByZXR1cm4gbWluaW1hbE9wYWNpdHkgKyBNYXRoLnJhbmRvbSgpICogKGJ1YmJsZU9wYWNpdHkgLSBtaW5pbWFsT3BhY2l0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyDQpNC40LrRgdC40YDQvtCy0LDQvdC90LDRjyDQv9GA0L7Qt9GA0LDRh9C90L7RgdGC0YxcbiAgICAgICAgcmV0dXJuIGJ1YmJsZU9wYWNpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vINCh0L7Qt9C00LDQtdC8INC/0YPQt9GL0YDRjNC60LhcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1YmJsZUNvdW50OyBpKyspIHtcbiAgICAgIHZhciB0ZW1wQnViYmxlID0gbmV3IGNyZWF0ZUJ1YmJsZSgpO1xuXG4gICAgICBidWJibGVzLnB1c2godGVtcEJ1YmJsZSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vINCa0L7QvdGB0YLRgNGD0LrRgtC+0YAg0LvQuNC90LjQuFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpbmUoKSB7XG4gICAgICB0aGlzLmxpbmVMZW5ndGggPSAwO1xuICAgICAgdGhpcy5wb3BEaXN0YW5jZSA9IDA7XG4gICAgICB0aGlzLnBvcERpc3RhbmNlUmV0dXJuID0gMDtcbiAgICAgIHRoaXMuaW52ZXJzZVBvcCA9IGZhbHNlO1xuICAgICAgdGhpcy5wb3BwaW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMucmVzZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9wRGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLnBvcERpc3RhbmNlUmV0dXJuID0gMDtcbiAgICAgICAgdGhpcy5pbnZlcnNlUG9wID0gZmFsc2U7XG4gICAgICAgIHRoaXMucG9wcGluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnggPSB0aGlzLmJ1YmJsZS5wb3NpdGlvbi54ICsgKHRoaXMuYnViYmxlLnJhZGl1cyArIHRoaXMucG9wRGlzdGFuY2VSZXR1cm4pICogTWF0aC5jb3MoMiAqIE1hdGguUEkgKiB0aGlzLmluZGV4IC8gdGhpcy5idWJibGUubGluZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy55ID0gdGhpcy5idWJibGUucG9zaXRpb24ueSArICh0aGlzLmJ1YmJsZS5yYWRpdXMgKyB0aGlzLnBvcERpc3RhbmNlUmV0dXJuKSAqIE1hdGguc2luKDIgKiBNYXRoLlBJICogdGhpcy5pbmRleCAvIHRoaXMuYnViYmxlLmxpbmVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IHRoaXMuYnViYmxlLnJhZGl1cyAqIHRoaXMucG9wRGlzdGFuY2U7XG4gICAgICAgIHRoaXMuZW5kWCA9IHRoaXMubGluZUxlbmd0aDtcbiAgICAgICAgdGhpcy5lbmRZID0gdGhpcy5saW5lTGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZXMoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuYnViYmxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIGlmICh0aGlzLnggPCB0aGlzLmJ1YmJsZS5wb3NpdGlvbi54KSB7XG4gICAgICAgICAgdGhpcy5lbmRYID0gdGhpcy5saW5lTGVuZ3RoICogLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMueSA8IHRoaXMuYnViYmxlLnBvc2l0aW9uLnkpIHtcbiAgICAgICAgICB0aGlzLmVuZFkgPSB0aGlzLmxpbmVMZW5ndGggKiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy55ID09PSB0aGlzLmJ1YmJsZS5wb3NpdGlvbi55KSB7XG4gICAgICAgICAgdGhpcy5lbmRZID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy54ID09PSB0aGlzLmJ1YmJsZS5wb3NpdGlvbi54KSB7XG4gICAgICAgICAgdGhpcy5lbmRYID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjdHgubGluZVRvKHRoaXMueCArIHRoaXMuZW5kWCwgdGhpcy55ICsgdGhpcy5lbmRZKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgICAvLyDQntCx0YDQsNCx0L7RgtGH0LjQutC4INGB0L7QsdGL0YLQuNC5XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyDQpNGD0L3QutGG0LjRjyDQtNC70Y8g0L7QsdC90L7QstC70LXQvdC40Y8g0YDQsNC30LzQtdGA0L7QsiBjYW52YXMg0L/RgNC4INC40LfQvNC10L3QtdC90LjQuCDRgNCw0LfQvNC10YDQsCDQvtC60L3QsFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRDYW52YXNTaXplKCk7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYXJlTW9kYWwiLCJjb25zdCBjYXJ0TW9kYWwgPSBuZXcgT2JqZWN0KHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyRE9NKClcbiAgICB0aGlzLmJpbmRUb2dnbGUoKVxuICB9LFxuICByZW5kZXJET006IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl8gPSAkKFwiLmNhcnQtbW9kYWxcIik7XG4gICAgdGhpcy5iYWNrZHJvcCA9IHRoaXMuXy5maW5kKFwiLmNhcnQtbW9kYWxfX2JhY2tkcm9wXCIpO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5fLmZpbmQoXCIuY2FydC1tb2RhbF9fY29udGFpbmVyXCIpO1xuICAgIHRoaXMuZXZ0VG9nZ2xlID0gZ2V0RXZ0RE9NKFwidG9nZ2xlQ2FydFwiKTtcbiAgfSxcbiAgYmluZFRvZ2dsZTogZnVuY3Rpb24gKCkge1xuICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICdbZGF0YS1ldnQ9XCJ0b2dnbGVDYXJ0XCJdJywgZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGVsID0gJChcIi5jYXJ0LW1vZGFsXCIpXG4gICAgICBpZiAoZWwubGVuZ3RoKSB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSAkKFwiLmNhcnQtbW9kYWxfX2NvbnRhaW5lclwiKSxcbiAgICAgICAgICBiYWNrZHJvcCA9ICQoXCIuY2FydC1tb2RhbF9fYmFja2Ryb3BcIilcbiAgICAgICAgaWYgKGVsZW1EaXNwbGF5ZWQoZWwpKSB7XG4gICAgICAgICAgdW5sb2NrU2Nyb2xsKCk7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihiYWNrZHJvcFswXS5zdHlsZSwgeyBvcGFjaXR5OiAwIH0pO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udGFpbmVyWzBdLnN0eWxlLCB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVYKDEwMCUpXCIgfSk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBlbC5oaWRlKCk7XG4gICAgICAgICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUoY29udGFpbmVyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9ja1Njcm9sbCgpO1xuICAgICAgICAgIGVsLnNob3coKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYmFja2Ryb3BbMF0uc3R5bGUsIHsgb3BhY2l0eTogMSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udGFpbmVyWzBdLnN0eWxlLCB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVYKDAlKVwiIH0pO1xuICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgdG9nZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGVsID0gY2FydE1vZGFsLl87XG4gICAgaWYgKGVsLmxlbmd0aCkge1xuICAgICAgaWYgKGVsZW1EaXNwbGF5ZWQoZWwpKSB7XG4gICAgICAgIGNhcnRNb2RhbC5jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FydE1vZGFsLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICBsb2NrU2Nyb2xsKCk7XG4gICAgdGhpcy5fLnNob3coKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5iYWNrZHJvcFswXS5zdHlsZSwgeyBvcGFjaXR5OiAxIH0pO1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbnRhaW5lclswXS5zdHlsZSwgeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWCgwJSlcIiB9KTtcbiAgICB9LCAxKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB1bmxvY2tTY3JvbGwoKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuYmFja2Ryb3BbMF0uc3R5bGUsIHsgb3BhY2l0eTogMCB9KTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuY29udGFpbmVyWzBdLnN0eWxlLCB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVYKDEwMCUpXCIgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl8uaGlkZSgpO1xuICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKGNhcnRNb2RhbC5jb250YWluZXIpKTtcbiAgfSxcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gY2FydE1vZGFsIiwiY29uc3QgY3VycmVuY3lNb2RhbCA9IG5ldyBPYmplY3Qoe1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW5kZXJET00oKTtcbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgfSxcbiAgcmVuZGVyRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fID0gJChcIi5jdXItbW9kYWxcIik7XG4gICAgdGhpcy5iYWNrZHJvcCA9IHRoaXMuXy5maW5kKFwiLmN1ci1tb2RhbF9fYmFja2Ryb3BcIik7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLl8uZmluZChcIi5jdXItbW9kYWxfX2NvbnRhaW5lclwiKTtcbiAgICB0aGlzLmV2dFRvZ2dsZSA9IGdldEV2dERPTShcInRvZ2dsZUN1cnJlbmN5XCIpO1xuICAgIHRoaXMuaW5wdXQgPSB0aGlzLl8uZmluZChcImlucHV0XCIpO1xuICB9LFxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGN1cnJlbmN5TW9kYWwuZXZ0VG9nZ2xlLmxlbmd0aCkge1xuICAgICAgJC5lYWNoKGN1cnJlbmN5TW9kYWwuZXZ0VG9nZ2xlLCAoaSkgPT4ge1xuICAgICAgICBjdXJyZW5jeU1vZGFsLmV2dFRvZ2dsZVtpXS5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgIGN1cnJlbmN5TW9kYWwudG9nZ2xlKCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVuY3lNb2RhbC5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIGN1cnJlbmN5TW9kYWwuaW5wdXQub24oXCJrZXl1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbmN5TW9kYWwuaW50cmFTZWFyY2goJCh0aGlzKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIHRvZ2dsZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaW5wdXQudmFsKFwiXCIpLnRyaWdnZXIoXCJrZXl1cFwiKTtcbiAgICBsZXQgbW9kYWwgPSBjdXJyZW5jeU1vZGFsLl87XG4gICAgaWYgKG1vZGFsLmxlbmd0aCkge1xuICAgICAgaWYgKGVsZW1EaXNwbGF5ZWQobW9kYWwpKSB7XG4gICAgICAgIGN1cnJlbmN5TW9kYWwuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbmN5TW9kYWwub3BlbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgIGxvY2tTY3JvbGwoKTtcbiAgICB0aGlzLl8uc2hvdygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5iYWNrZHJvcC5jc3MoeyBvcGFjaXR5OiAxIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIuY3NzKHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoMCUpXCIgfSk7XG4gICAgfSwgMSk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdW5sb2NrU2Nyb2xsKCk7XG4gICAgdGhpcy5iYWNrZHJvcC5jc3MoeyBvcGFjaXR5OiAwIH0pO1xuICAgIHRoaXMuY29udGFpbmVyLmNzcyh7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVYKDEwMCUpXCIgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl8uaGlkZSgpO1xuICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKGN1cnJlbmN5TW9kYWwuYmFja2Ryb3ApKTtcbiAgfSxcbiAgaW50cmFTZWFyY2g6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGxldCB2YWwgPSBpbnB1dC52YWwoKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgYXJyID0gWy4uLiQoXCIuY3VyLWl0ZW1cIildO1xuICAgICQuZWFjaChhcnIsIGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgbGV0IHR4dCA9ICQoYXJyW2luZGV4XSkuZmluZChcIi5jdXItaXRlbV9fbmFtZVwiKS50ZXh0KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh+dHh0LmluZGV4T2YodmFsKSkge1xuICAgICAgICAkKGFycltpbmRleF0pLnNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoYXJyW2luZGV4XSkuaGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBjdXJyZW5jeU1vZGFsIiwiY29uc3QgbWFpbE1vZGFsID0gbmV3IE9iamVjdCh7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbmRlckRPTSgpXG4gICAgaWYgKHRoaXMubW9kYWwubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKVxuICAgIH1cbiAgfSxcbiAgcmVuZGVyRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tb2RhbCA9ICQoJy5tYWlsLW1vZGFsJylcbiAgICB0aGlzLmJhY2tkcm9wID0gJCgnLm1haWwtbW9kYWxfX2JhY2tkcm9wJylcbiAgICB0aGlzLmNvbnRhaW5lciA9ICQoJy5tYWlsLW1vZGFsX19jb250YWluZXInKVxuICAgIHRoaXMuZXZ0Q2xvc2UgPSAkKCdbZGF0YS1tYWlsLW1vZGFsPVwiY2xvc2VcIl0nKVxuICB9LFxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ldnRDbG9zZS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7IG1haWxNb2RhbC5jbG9zZSgpIH0pXG4gIH0sXG4gIG9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICBsb2NrU2Nyb2xsKClcbiAgICB0aGlzLm1vZGFsLnNob3coKVxuICAgIHRoaXMubW9kYWwuZmluZCgnaW5wdXQnKS5mb2N1cygpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLm1vZGFsLmFkZENsYXNzKF9fQUNUSVZFKVxuICAgIH0sIDUpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHVubG9ja1Njcm9sbCgpXG4gICAgdGhpcy5tb2RhbC5yZW1vdmVDbGFzcyhfX0FDVElWRSlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMubW9kYWwuaGlkZSgpXG4gICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUodGhpcy5jb250YWluZXIpKTtcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBtYWlsTW9kYWwiLCJjbGFzcyBNZW51IHtcbiAgY29uc3RydWN0b3Iocm9vdFNlbGVjdG9yID0gJy5tZW51Jykge1xuICAgIHRoaXMuX3N0YXRlID0gZmFsc2VcbiAgICB0aGlzLm92ZXJTdGF0ZSA9IGZhbHNlXG4gICAgdGhpcy5yb290RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJvb3RTZWxlY3RvcilcblxuICAgIGlmICghdGhpcy5yb290RWwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY29udGVudExpc3QgPSB0aGlzLnJvb3RFbC5xdWVyeVNlbGVjdG9yKCcubWVudV9fY29udGVudC1saXN0JylcbiAgICB0aGlzLm92ZXJMaXN0ID0gdGhpcy5yb290RWwucXVlcnlTZWxlY3RvcignLm1lbnVfX292ZXItbGlzdCcpXG4gICAgdGhpcy5zdWJMaXN0QXJyID0gWy4uLnRoaXMucm9vdEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1lbnUtbGlzdF0nKV1cbiAgICB0aGlzLmFjdGl2ZUxpc3ROYW1lID0gdGhpcy5yb290RWwucXVlcnlTZWxlY3RvcignI2FjdGl2ZUxpc3ROYW1lJylcblxuICAgIHRoaXMuaW5pdCgpXG4gIH1cblxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlXG4gIH1cblxuICBzZXQgc3RhdGUodmFsdWUpIHtcbiAgICB0aGlzLl9zdGF0ZSA9IHZhbHVlXG4gICAgaWYgKHRoaXMuX3N0YXRlKSB7XG4gICAgICB0aGlzLm9wZW4odHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbG9zZSh0cnVlKVxuICAgIH1cbiAgfVxuXG4gIG9wZW4oZnJvbVNldHRlciA9IGZhbHNlKSB7XG4gICAgaWYgKCFmcm9tU2V0dGVyKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHRydWVcbiAgICB9XG5cbiAgICB0aGlzLnJvb3RFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbG9ja1Njcm9sbCgpXG4gICAgICB0aGlzLnJvb3RFbC5jbGFzc0xpc3QuYWRkKF9fQUNUSVZFKVxuICAgICAgd2luZG93Lm1lbnVCYWNrZHJvcCA9IG5ldyBCYWNrZHJvcCh7XG4gICAgICAgIGhhbGY6IHRydWUsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7IHRoaXMuY2xvc2UoKSB9XG4gICAgICB9KVxuICAgIH0sIDUpO1xuICB9XG5cbiAgY2xvc2UoZnJvbVNldHRlciA9IGZhbHNlKSB7XG4gICAgaWYgKCFmcm9tU2V0dGVyKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5tZW51QmFja2Ryb3ApIHtcbiAgICAgIHdpbmRvdy5tZW51QmFja2Ryb3AuaGlkZSh0cnVlKVxuICAgIH1cblxuICAgIHVubG9ja1Njcm9sbCgpXG4gICAgdGhpcy5yb290RWwuY2xhc3NMaXN0LnJlbW92ZShfX0FDVElWRSlcblxuICAgIGlmICh0aGlzLm92ZXJTdGF0ZSkge1xuICAgICAgdGhpcy5jbG9zZU92ZXJMaXN0KClcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY29udGVudExpc3Quc2Nyb2xsVG9wID0gMFxuICAgICAgdGhpcy5yb290RWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMucm9vdEVsKSk7XG4gIH1cblxuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9ICF0aGlzLnN0YXRlXG4gIH1cblxuICBvcGVuT3Zlckxpc3QoKSB7XG4gICAgaWYgKCF0aGlzLm92ZXJTdGF0ZSkge1xuICAgICAgdGhpcy5vdmVyU3RhdGUgPSB0cnVlXG4gICAgICB0aGlzLm92ZXJMaXN0LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICB0aGlzLm92ZXJMaXN0LnNjcm9sbFRvcCA9IDBcbiAgICAgIHRoaXMucm9vdEVsLmNsYXNzTGlzdC5hZGQoJy0tb3Zlci1hY3RpdmUnKVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY29udGVudExpc3QuY2xhc3NMaXN0LmFkZChfX0hJRERFTilcbiAgICAgICAgdGhpcy5vdmVyTGlzdC5jbGFzc0xpc3QuYWRkKF9fVklTSUJMRSlcbiAgICAgIH0sIDUpO1xuICAgIH1cbiAgfVxuXG4gIGNsb3NlT3Zlckxpc3QoKSB7XG4gICAgaWYgKHRoaXMub3ZlclN0YXRlKSB7XG4gICAgICB0aGlzLm92ZXJTdGF0ZSA9IGZhbHNlXG4gICAgICB0aGlzLmNvbnRlbnRMaXN0LmNsYXNzTGlzdC5yZW1vdmUoX19ISURERU4pXG4gICAgICB0aGlzLm92ZXJMaXN0LmNsYXNzTGlzdC5yZW1vdmUoX19WSVNJQkxFKVxuICAgICAgdGhpcy5yb290RWwuY2xhc3NMaXN0LnJlbW92ZSgnLS1vdmVyLWFjdGl2ZScpXG4gICAgICB0aGlzLmNvbnRlbnRMaXN0LnNjcm9sbFRvcCA9IDBcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMub3Zlckxpc3Quc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUodGhpcy5vdmVyTGlzdCkpO1xuXG4gICAgICBpZiAodGhpcy5hY3RpdmVMaXN0TmFtZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZUxpc3ROYW1lLmlubmVySFRNTCA9IHRoaXMuYWN0aXZlTGlzdE5hbWUuZGF0YXNldC50aXRsZSB8fCAnRXhwbG9yZSBJY2Vib3gnXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ29Ub05hdkxpc3QobmFtZSwgaXRlbSA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICBjb25zdCBsaXN0ID0gdGhpcy5zdWJMaXN0QXJyLmZpbmQoZWwgPT4gZWwuZGF0YXNldC5tZW51TGlzdCA9PT0gbmFtZSlcbiAgICAgIGlmICghbGlzdCkgdGhyb3cgbmV3IEVycm9yKCdkYXRhLW1lbnUtbGlzdCBub3QgZm91bmQnKVxuXG4gICAgICB0aGlzLnN1Ykxpc3RBcnIuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgaWYgKGVsICE9PSBsaXN0KSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZiAodGhpcy5hY3RpdmVMaXN0TmFtZSAmJiBpdGVtKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlTGlzdE5hbWUuaW5uZXJIVE1MID0gaXRlbS5xdWVyeVNlbGVjdG9yQWxsKCdzcGFuJylbMF0uaW5uZXJIVE1MXG4gICAgICB9XG4gICAgICB0aGlzLm9wZW5PdmVyTGlzdCgpXG4gICAgfVxuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IGZhbHNlXG4gICAgdGhpcy5vdmVyU3RhdGUgPSBmYWxzZVxuICAgIHRoaXMuY29udGVudExpc3Quc2Nyb2xUb3AgPSAwXG4gICAgdGhpcy5vdmVyTGlzdC5zY3JvbGxUb3AgPSAwXG4gIH1cblxuICAvLyBFdmVudHNcbiAgYmluZEV2ZW50cygpIHtcbiAgICBjb25zdCBldnROYXZBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbWVudS1uYXZdJyldXG4gICAgZXZ0TmF2QXJyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGl0ZW0ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiYgIXRoaXMub3ZlclN0YXRlKSB7XG4gICAgICAgICAgY29uc3QgbGlzdE5hbWUgPSBpdGVtLmRhdGFzZXQubWVudU5hdlxuICAgICAgICAgIHRoaXMuZ29Ub05hdkxpc3QobGlzdE5hbWUsIGl0ZW0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgZXZ0VG9nZ2xlTWVudUFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1ldnQ9XCJ0b2dnbGVNZW51XCJdJyldXG4gICAgZXZ0VG9nZ2xlTWVudUFyci5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRoaXMub3BlbigpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMucmVzZXQoKVxuICAgIHRoaXMuYmluZEV2ZW50cygpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZW51IiwiY2xhc3MgTm90aWNlTW9kYWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgICB0aGlzLmVsZW0gPSBudWxsO1xuICAgIHRoaXMudGV4dCA9IG51bGw7XG5cbiAgICB0aGlzLnNob3cgPSB0aGlzLnNob3cuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhpZGUgPSB0aGlzLmhpZGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9iaW5kUHVsbERvd24gPSB0aGlzLl9iaW5kUHVsbERvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl91bmJpbmRQdWxsRG93biA9IHRoaXMuX3VuYmluZFB1bGxEb3duLmJpbmQodGhpcyk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2JpbmREb2N1bWVudENsaWNrKCk7XG4gIH1cblxuICAvLyBFdmVudHNcbiAgX2JpbmREb2N1bWVudENsaWNrKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IGVsZW0gPSBlLnRhcmdldC5jbG9zZXN0KCdbZGF0YS1ub3RpY2VdJyk7XG4gICAgICBpZiAoIWVsZW0pIHJldHVybjtcblxuICAgICAgY29uc3QgdGV4dCA9IGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLW5vdGljZScpO1xuICAgICAgaWYgKCF0ZXh0KSByZXR1cm47XG5cbiAgICAgIHRoaXMuY3JlYXRlKHRleHQpO1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBCaW5kIFB1bGwtRG93biBHZXN0dXJlXG4gIF9iaW5kUHVsbERvd24oKSB7XG4gICAgaWYgKCF0aGlzLmVsZW0pIHJldHVybjtcblxuICAgIGxldCBzdGFydFkgPSAwO1xuICAgIGxldCBjdXJyZW50WSA9IDA7XG4gICAgbGV0IGlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBsZXQgaXNNb3ZpbmcgPSBmYWxzZTtcblxuICAgIGNvbnN0IG1vZGFsID0gdGhpcy5lbGVtO1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShtb2RhbCkudHJhbnNpdGlvbjtcblxuICAgIC8vIFRvdWNoIFN0YXJ0XG4gICAgY29uc3Qgb25Ub3VjaFN0YXJ0ID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgICAgc3RhcnRZID0gdG91Y2guY2xpZW50WTtcbiAgICAgIGlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIG1vZGFsLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgfTtcblxuICAgIC8vIFRvdWNoIE1vdmVcbiAgICBjb25zdCBvblRvdWNoTW92ZSA9IChlKSA9PiB7XG4gICAgICBpZiAoIWlzRHJhZ2dpbmcpIHJldHVybjtcblxuICAgICAgY3VycmVudFkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgIGxldCBkaWZmWSA9IGN1cnJlbnRZIC0gc3RhcnRZO1xuXG4gICAgICBpZiAoZGlmZlkgPiAwKSB7XG4gICAgICAgIGlzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIG1vZGFsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKCR7ZGlmZll9cHgpYDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVG91Y2ggRW5kXG4gICAgY29uc3Qgb25Ub3VjaEVuZCA9ICgpID0+IHtcbiAgICAgIGlmICghaXNEcmFnZ2luZykgcmV0dXJuO1xuICAgICAgaXNEcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoaXNNb3ZpbmcpIHtcbiAgICAgICAgbGV0IGRpZmZZID0gY3VycmVudFkgLSBzdGFydFk7XG4gICAgICAgIGxldCBoaWRlT2Zmc2V0ID0gbW9kYWwub2Zmc2V0SGVpZ2h0ICogMC4yO1xuICAgICAgICBtb2RhbC5zdHlsZS50cmFuc2l0aW9uID0gJ3RyYW5zZm9ybSAwLjNzIGVhc2UnO1xuXG4gICAgICAgIGlmIChkaWZmWSA+IGhpZGVPZmZzZXQpIHtcbiAgICAgICAgICBtb2RhbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgxMDAlKWBcbiAgICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGFsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKDAlKWA7XG4gICAgICAgICAgbW9kYWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX3B1bGxEb3duSGFuZGxlcnMgPSB7XG4gICAgICBvblRvdWNoU3RhcnQsXG4gICAgICBvblRvdWNoTW92ZSxcbiAgICAgIG9uVG91Y2hFbmQsXG4gICAgfTtcblxuICAgIG1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgbW9kYWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgbW9kYWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcbiAgfVxuXG4gIC8vIFVuYmluZCBQdWxsLURvd24gR2VzdHVyZVxuICBfdW5iaW5kUHVsbERvd24oKSB7XG4gICAgaWYgKCF0aGlzLmVsZW0gfHwgIXRoaXMuX3B1bGxEb3duSGFuZGxlcnMpIHJldHVybjtcblxuICAgIGNvbnN0IHsgb25Ub3VjaFN0YXJ0LCBvblRvdWNoTW92ZSwgb25Ub3VjaEVuZCB9ID0gdGhpcy5fcHVsbERvd25IYW5kbGVycztcblxuICAgIHRoaXMuZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgICB0aGlzLmVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuICAgIHRoaXMuZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuXG4gICAgdGhpcy5fcHVsbERvd25IYW5kbGVycyA9IG51bGw7XG4gIH1cblxuICAvLyBTaG93ICYgSGlkZVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLmVsZW0pIHtcbiAgICAgIGxvY2tTY3JvbGwoKVxuXG4gICAgICB0aGlzLmVsZW0uc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbGVtLmNsYXNzTGlzdC5hZGQoX19WSVNJQkxFKTtcbiAgICAgICAgdGhpcy5fYmluZFB1bGxEb3duKClcblxuICAgICAgICB3aW5kb3cubm90aWNlQmFja2Ryb3AgPSBuZXcgd2luZG93LkJhY2tkcm9wKHtcbiAgICAgICAgICBoYWxmOiB0cnVlLFxuICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLmhpZGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLmVsZW0pIHtcbiAgICAgIHVubG9ja1Njcm9sbCgpXG5cbiAgICAgIHRoaXMuZWxlbS5jbGFzc0xpc3QucmVtb3ZlKF9fVklTSUJMRSk7XG4gICAgICBjb25zdCBiYWNrZHJvcCA9IHdpbmRvdy5ub3RpY2VCYWNrZHJvcDtcblxuICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgIGJhY2tkcm9wLmhpZGUodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5lbGVtKSB7XG4gICAgICAgICAgdGhpcy5lbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91bmJpbmRQdWxsRG93bigpXG4gICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmVsZW0pKVxuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSAmIERlc3Ryb3lcbiAgY3JlYXRlKHRleHQgPSBcIlNvbWV0aGluZyB3ZW50IHdyb25nLi4uXCIpIHtcbiAgICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG1vZGFsLmNsYXNzTmFtZSA9ICdub3RpY2UtbW9kYWwnO1xuICAgIG1vZGFsLmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwibm90aWNlLW1vZGFsX190eXBvXCI+JHt0ZXh0fTwvZGl2PmA7XG5cbiAgICB0aGlzLmVsZW0gPSBtb2RhbDtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKG1vZGFsKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZWxlbSkge1xuICAgICAgdGhpcy5lbGVtLnJlbW92ZSgpO1xuICAgICAgdGhpcy5lbGVtID0gbnVsbDtcbiAgICAgIHRoaXMudGV4dCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTm90aWNlTW9kYWw7XG4iLCJjb25zdCBxdWl6TW9kYWwgPSB7XG4gIGN1cnJlbnRTdGVwOiB1bmRlZmluZWQsXG4gIGlzRmluaXNoZWQ6IHVuZGVmaW5lZCxcbiAgcG9sbExlbmd0aDogdW5kZWZpbmVkLFxuICBtYXhTdGVwOiB1bmRlZmluZWQsXG4gIGlzSW5pdGlhbGl6ZWQ6IHVuZGVmaW5lZCxcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyRE9NKClcbiAgICB0aGlzLnNldEluaXRpYWwoKVxuICAgIHRoaXMuYmluZEV2ZW50cygpXG4gIH0sXG4gIHJlbmRlckRPTTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubW9kYWwgPSAkKCcucXVpei1tb2RhbCcpXG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm1vZGFsLmZpbmQoJy5xdWl6LWNvbnRhaW5lcicpXG4gICAgdGhpcy5iYWNrZHJvcCA9IHRoaXMubW9kYWwuZmluZCgnLnF1aXotbW9kYWxfX2JhY2tkcm9wJylcbiAgICB0aGlzLmhlaWdodENvbnRhaW5lciA9IHRoaXMubW9kYWwuZmluZCgnLnF1aXotY29udGFpbmVyLWhlaWdodCcpXG4gICAgdGhpcy5wb2xsID0gdGhpcy5tb2RhbC5maW5kKCcucXVpei1wb2xsJylcbiAgICB0aGlzLnBvbGxBcnIgPSBbLi4udGhpcy5wb2xsXVxuICAgIHRoaXMuYW5zd2VycyA9IHRoaXMubW9kYWwuZmluZCgnLnF1aXotYW5zd2VyJylcbiAgICB0aGlzLmZ1bGxTdGVwVGV4dCA9IHRoaXMubW9kYWwuZmluZCgnLnF1aXotc3RlcC10ZXh0JylcbiAgICB0aGlzLmN1cnJlbnRTdGVwVGV4dCA9IHRoaXMubW9kYWwuZmluZCgnLnF1aXotY3VycmVudC1zdGVwJylcbiAgICB0aGlzLm1heFN0ZXBUZXh0ID0gdGhpcy5tb2RhbC5maW5kKCcucXVpei1tYXgtc3RlcCcpXG4gICAgdGhpcy5iYXIgPSB0aGlzLm1vZGFsLmZpbmQoJy5xdWl6LWJhcicpXG4gICAgdGhpcy5ldnRHb05leHQgPSAkKCdbZGF0YS1ldnQ9XCJxdWl6R29OZXh0XCJdJylcbiAgICB0aGlzLmV2dE9wZW4gPSAkKCdbZGF0YS1ldnQ9XCJvcGVuUXVpek1vZGFsXCJdJylcbiAgICB0aGlzLmNsb3NlQnRuID0gJCgnW2RhdGEtZXZ0PVwiY2xvc2VRdWl6TW9kYWxcIl0nKVxuICB9LFxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ldnRHb05leHQuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgcXVpek1vZGFsLmdvTmV4dFN0ZXAoKVxuICAgIH0pXG4gICAgdGhpcy5jbG9zZUJ0bi5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBxdWl6TW9kYWwuY2xvc2UoKVxuICAgIH0pXG4gICAgdGhpcy5ldnRPcGVuLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHF1aXpNb2RhbC5vcGVuKClcbiAgICB9KVxuICB9LFxuICBzZXRJbml0aWFsOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IDEsIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlLCB0aGlzLnBvbGxMZW5ndGggPSB0aGlzLnBvbGxBcnIubGVuZ3RoLCB0aGlzLm1heFN0ZXAgPSB0aGlzLnBvbGxMZW5ndGhcbiAgICBpZiAodGhpcy5wb2xsTGVuZ3RoICE9PSAwICYmIHRoaXMucG9sbExlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaXNJbml0aWFsaXplZCAhPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZVxuICAgICAgcXVpek1vZGFsLmN1cnJlbnRTdGVwVGV4dC5odG1sKHF1aXpNb2RhbC5jdXJyZW50U3RlcClcbiAgICAgIHF1aXpNb2RhbC5tYXhTdGVwVGV4dC5odG1sKHF1aXpNb2RhbC5tYXhTdGVwKVxuICAgICAgdGhpcy5tb2RhbC5maW5kKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpOyB0aGlzLmV2dEdvTmV4dC5odG1sKCdOZXh0JylcbiAgICAgIC8vIE9iamVjdC5hc3NpZ24odGhpcy5oZWlnaHRDb250YWluZXJbMF0uc3R5bGUsIHsgaGVpZ2h0OiBgJHt0aGlzLmdldE9iamVjdFNjcm9sbEhlaWdodCh0aGlzLnBvbGxBcnJbMF0pfWAgfSlcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5iYXJbMF0uc3R5bGUsIHsgd2lkdGg6IGAkeygxMDAgLyB0aGlzLnBvbGxMZW5ndGgpfSVgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgLy8gdXRpbHNcbiAgZ2V0T2JqZWN0U2Nyb2xsSGVpZ2h0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIGpRdWVyeSkge1xuICAgICAgcmV0dXJuIGAke29ialswXS5zY3JvbGxIZWlnaHR9cHhgXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJHtvYmouc2Nyb2xsSGVpZ2h0fXB4YFxuICAgIH1cbiAgfSxcbiAgbm9FbXB0eUFuc3dlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcGFyZW50ID0gJChxdWl6TW9kYWwucG9sbEFyclsocXVpek1vZGFsLmN1cnJlbnRTdGVwIC0gMSldKSxcbiAgICAgIGNoZWNrZWRSYWRpbyA9IHBhcmVudC5maW5kKCdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCcpLFxuICAgICAgYW5zd2VycyA9IHBhcmVudC5maW5kKHF1aXpNb2RhbC5hbnN3ZXJzKVxuICAgIGlmIChjaGVja2VkUmFkaW8ubGVuZ3RoID09IDApIHtcbiAgICAgIGFuc3dlcnMuY3NzKHsgb3BhY2l0eTogJzAuMycgfSk7IHNldFRpbWVvdXQoKCkgPT4geyBhbnN3ZXJzLmNzcyh7IG9wYWNpdHk6IDEgfSkgfSwgMzc1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0sXG4gIGdvTmV4dFN0ZXAoKSB7XG4gICAgaWYgKHF1aXpNb2RhbC5jdXJyZW50U3RlcCAhPT0gcXVpek1vZGFsLm1heFN0ZXApIHtcbiAgICAgIGlmIChxdWl6TW9kYWwubm9FbXB0eUFuc3dlcnMoKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHF1aXpNb2RhbC5wb2xsQXJyWyhxdWl6TW9kYWwuY3VycmVudFN0ZXAgLSAxKV0uc3R5bGUsIHsgb3BhY2l0eTogMCB9KVxuICAgICAgICBPYmplY3QuYXNzaWduKHF1aXpNb2RhbC5iYXJbMF0uc3R5bGUsIHsgd2lkdGg6IGAkeygxMDAgLyBxdWl6TW9kYWwucG9sbExlbmd0aCkgKiAocXVpek1vZGFsLmN1cnJlbnRTdGVwICsgMSl9JWAgfSlcbiAgICAgICAgJC5lYWNoKHF1aXpNb2RhbC5wb2xsQXJyLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLnBvbGxBcnJbaV0uc3R5bGUsIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgtJHsocXVpek1vZGFsLmN1cnJlbnRTdGVwICogMTAwKX0lKWAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgT2JqZWN0LmFzc2lnbihxdWl6TW9kYWwuaGVpZ2h0Q29udGFpbmVyWzBdLnN0eWxlLCB7IGhlaWdodDogYCR7cXVpek1vZGFsLnBvbGxBcnJbcXVpek1vZGFsLmN1cnJlbnRTdGVwXS5zY3JvbGxIZWlnaHR9cHhgIH0pXG4gICAgICAgICsrcXVpek1vZGFsLmN1cnJlbnRTdGVwXG4gICAgICAgIHF1aXpNb2RhbC5jdXJyZW50U3RlcFRleHQuaHRtbChxdWl6TW9kYWwuY3VycmVudFN0ZXApXG4gICAgICAgIGlmIChxdWl6TW9kYWwuY3VycmVudFN0ZXAgPT0gcXVpek1vZGFsLm1heFN0ZXApIHtcbiAgICAgICAgICBxdWl6TW9kYWwuZXZ0R29OZXh0Lmh0bWwoJ1Nob3cgUmVzdWx0cycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHF1aXpNb2RhbC5ub0VtcHR5QW5zd2VycygpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLmhlaWdodENvbnRhaW5lclswXS5zdHlsZSwgeyBoZWlnaHQ6ICcwcHgnIH0pXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLmJhclswXS5zdHlsZSwgeyB3aWR0aDogJzUlJyB9KVxuICAgICAgICAkLmVhY2gocXVpek1vZGFsLnBvbGxBcnIsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWl6TW9kYWwucG9sbEFycltpXS5zdHlsZSwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKC0keyhxdWl6TW9kYWwuY3VycmVudFN0ZXAgKiAxMDApfSUpYCB9KVxuICAgICAgICB9KVxuICAgICAgICBPYmplY3QuYXNzaWduKHF1aXpNb2RhbC5wb2xsQXJyWyhxdWl6TW9kYWwuY3VycmVudFN0ZXAgLSAxKV0uc3R5bGUsIHsgb3BhY2l0eTogMCB9KVxuICAgICAgICBxdWl6TW9kYWwuZXZ0R29OZXh0LnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSlcbiAgICAgICAgcXVpek1vZGFsLmZ1bGxTdGVwVGV4dC50ZXh0KCdGSU5ESU5HIFdBVENIRVMnKVxuICAgICAgICAkKCcucXVpei1jbG9zZS1idG4nKS5yZW1vdmUoKVxuICAgICAgICBxdWl6TW9kYWwuaXNGaW5pc2hlZCA9IHRydWVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcXVpek1vZGFsLmJhci5hbmltYXRlKHsgd2lkdGg6ICcxMDAlJyB9LCAzMDAwLCBmdW5jdGlvbiAoKSB7IHF1aXpNb2RhbC5jbG9zZSgpIH0pXG4gICAgICAgIH0sIDYwMCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBvcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgbG9ja1Njcm9sbCgpXG4gICAgcXVpek1vZGFsLm1vZGFsLnNob3coKVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5oZWlnaHRDb250YWluZXJbMF0uc3R5bGUsIHsgaGVpZ2h0OiBgJHt0aGlzLmdldE9iamVjdFNjcm9sbEhlaWdodCh0aGlzLnBvbGxBcnJbcXVpek1vZGFsLmN1cnJlbnRTdGVwIC0gMV0pfWAgfSlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLmJhY2tkcm9wWzBdLnN0eWxlLCB7IG9wYWNpdHk6IDEgfSlcbiAgICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLmNvbnRhaW5lclswXS5zdHlsZSwgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDBweCknLCBvcGFjaXR5OiAxIH0pXG4gICAgfSwgMSk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdW5sb2NrU2Nyb2xsKClcbiAgICBsZXQgdGltZVRvSGlkZSA9IChwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHF1aXpNb2RhbC5iYWNrZHJvcFswXSkudHJhbnNpdGlvbkR1cmF0aW9uKSAqIDEwMDApXG4gICAgT2JqZWN0LmFzc2lnbihxdWl6TW9kYWwuYmFja2Ryb3BbMF0uc3R5bGUsIHsgb3BhY2l0eTogMCB9KVxuICAgIE9iamVjdC5hc3NpZ24ocXVpek1vZGFsLmNvbnRhaW5lclswXS5zdHlsZSwgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDMycHgpJywgb3BhY2l0eTogMCB9KVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcXVpek1vZGFsLm1vZGFsLmhpZGUoKVxuICAgIH0sIHRpbWVUb0hpZGUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVpek1vZGFsIiwiY29uc3Qgc2FsZXNNb2RhbCA9IHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyRE9NKClcbiAgICBpZiAodGhpcy5tb2RhbC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpXG4gICAgfVxuICB9LFxuICByZW5kZXJET006IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1vZGFsID0gJCgnLnNhbGUtaGlzdG9yeS1tb2RhbCcpXG4gICAgdGhpcy5jb250YWluZXIgPSAkKCcuc2FsZS1oaXN0b3J5X19jb250YWluZXInKVxuICAgIHRoaXMuZXZ0Q2xvc2UgPSAkKCdbZGF0YS1ldnQ9XCJjbG9zZVNhbGVzTW9kYWxcIl0nKVxuICB9LFxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ldnRDbG9zZS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBzYWxlc01vZGFsLmNsb3NlKClcbiAgICB9KVxuICB9LFxuICBvcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgc2FsZXNNb2RhbC5jbG9zZSgpXG4gICAgICB9XG4gICAgfSwgeyBvbmNlOiB0cnVlIH0pXG4gICAgbG9ja1Njcm9sbCgpXG4gICAgdGhpcy5tb2RhbC5zaG93KClcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMubW9kYWwuY3NzKHsgJ2JhY2tncm91bmQtY29sb3InOiBcInJnYmEoMTMsIDE2LCAyNiwgLjcpXCIgfSlcbiAgICAgIHRoaXMuY29udGFpbmVyLmNzcyh7ICd0cmFuc2Zvcm0nOiAndHJhbnNsYXRlWCgwJSknIH0pXG4gICAgfSwgMSk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdW5sb2NrU2Nyb2xsKClcbiAgICB0aGlzLm1vZGFsLmNzcyh7ICdiYWNrZ3JvdW5kLWNvbG9yJzogXCJyZ2JhKDEzLCAxNiwgMjYsIDApXCIgfSlcbiAgICB0aGlzLmNvbnRhaW5lci5jc3MoeyAndHJhbnNmb3JtJzogJ3RyYW5zbGF0ZVgoMTAwJSknIH0pXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLm1vZGFsLmhpZGUoKVxuICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHRoaXMubW9kYWwpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhbGVzTW9kYWwiLCJjb25zdCBhY2NvdW50ID0gbmV3IE9iamVjdCh7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuYXR0YWNoRXZlbnRzKS5mb3JFYWNoKChmbikgPT4ge1xuICAgICAgaWYgKGZuICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGZuID09ICdmdW5jdGlvbicpIGZuKCk7XG4gICAgfSlcbiAgfSxcbiAgYXR0YWNoRXZlbnRzOiB7XG4gICAgZWRpdEFkZHJlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGV2dEVkaXRBZGRyZXNzID0gQXJyYXkuZnJvbSgkKCdbZGF0YS1lZGl0PVwiYWRkcmVzc1wiXScpKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldnRFZGl0QWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbCA9IGV2dEVkaXRBZGRyZXNzW2ldO1xuXG4gICAgICAgICQoZWwpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsZXQgZGV0YWlscyA9ICQodGhpcykuY2xvc2VzdCgnLnByb2ZpbGUtY2FyZCcpLmZpbmQoJy5wcm9maWxlLWNhcmRfX2RldGFpbHMnKSxcbiAgICAgICAgICAgIGZvcm0gPSBkZXRhaWxzLmZpbHRlcignLmZvcm0nKVxuICAgICAgICAgIGlmIChlbGVtRGlzcGxheWVkKGZvcm0pKSB7XG4gICAgICAgICAgICBkZXRhaWxzLmhpZGUoKS5ub3QoZm9ybSkuc2hvdygpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRldGFpbHMuc2hvdygpLm5vdChmb3JtKS5oaWRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgIH1cbiAgICB9LFxuICAgIHRvZ2dsZUludm9pY2VIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGludm9pY2VBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm9yZGVyX19pbnZvaWNlJyldXG4gICAgICBmb3IgKGNvbnN0IGludm9pY2Ugb2YgaW52b2ljZUFycikge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBpbnZvaWNlLnF1ZXJ5U2VsZWN0b3IoJy5vcmRlcl9faW52b2ljZS1oZWFkZXInKVxuICAgICAgICBjb25zdCBib2R5ID0gaW52b2ljZS5xdWVyeVNlbGVjdG9yKCcub3JkZXJfX2ludm9pY2UtYm9keScpXG5cbiAgICAgICAgaGVhZGVyLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdG9DbG9zZSA9IGludm9pY2UuY2xhc3NMaXN0LmNvbnRhaW5zKF9fQUNUSVZFKVxuICAgICAgICAgIGlmICh0b0Nsb3NlKSB7XG4gICAgICAgICAgICBpbnZvaWNlLmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpXG4gICAgICAgICAgICBib2R5LnN0eWxlLmhlaWdodCA9IGA4MHB4YFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnZvaWNlLmNsYXNzTGlzdC5hZGQoX19BQ1RJVkUpXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBib2R5LnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgYm9keS5zdHlsZS5oZWlnaHQgPSBgJHtzY3JvbGxIZWlnaHR9cHhgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY291bnQiLCJjb25zdCBibG9nUGFnZSA9IHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5pbml0Rm4pLmZvckVhY2goKGZuKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRyeSB7IGZuKCkgfVxuICAgICAgICBjYXRjaCB7IGNvbnNvbGUubG9nKCdibG9nIEpTIEVSUicpIH1cbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBpbml0Rm46IHtcbiAgICBhdHRhY2hDb21tZW50U3VibWl0OiAoKSA9PiB7XG4gICAgICBjb25zdCBjb21tZW50QXJlYSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWFydGljbGU9XCJjb21tZW50QXJlYVwiXScpXG4gICAgICBjb25zdCBjb21tZW50U3VibWl0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtYXJ0aWNsZT1cImNvbW1lbnRTdWJtaXRcIl0nKVxuICAgICAgY29uc3QgaG9sZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFydGljbGVfX2NvbW1lbnRzLXdyYXAnKVxuXG4gICAgICBpZiAoY29tbWVudEFyZWEgIT09IG51bGwgJiYgY29tbWVudFN1Ym1pdCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzdWJtaXQgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHZhbCA9IGNvbW1lbnRBcmVhLnZhbHVlXG4gICAgICAgICAgaWYgKHZhbC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgIHVzZXIgPSAnR3VldHMnLFxuICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLXVzJywgeyB5ZWFyOiBcIm51bWVyaWNcIiwgbW9udGg6IFwic2hvcnRcIiwgZGF5OiBcIm51bWVyaWNcIiB9KSxcbiAgICAgICAgICAgICAgaHRtbCA9IGBcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFydGljbGUtY29tbWVudFwiPjxzcGFuPiR7dXNlcn08L3NwYW4+PHNwYW4+JHt2YWx9PC9zcGFuPjxzcGFuPiR7ZGF0ZX08L3NwYW4+PC9kaXY+XG4gICAgICAgICAgICAgIGBcblxuICAgICAgICAgICAgaG9sZGVyLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBodG1sKVxuICAgICAgICAgICAgY29tbWVudEFyZWEudmFsdWUgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbW1lbnRTdWJtaXQub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICBzdWJtaXQoKVxuICAgICAgICB9XG5cbiAgICAgICAgY29tbWVudEFyZWEub25rZXlkb3duID0gKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpc0VudGVyID0gZS5rZXkgPT09ICdFbnRlcicgfHwgZS5rZXlDb2RlID09PSAxM1xuICAgICAgICAgIGlmIChpc0VudGVyKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIHN1Ym1pdCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVQcm9ncmVzc0JhcjogKCkgPT4ge1xuICAgICAgY29uc3QgcmVhZENvbnRlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXJ0aWNsZV9fcmVhZC1jb250ZW50JylcbiAgICAgIGlmICghcmVhZENvbnRlbnQpIHJldHVyblxuICAgICAgbGV0IHkgPSAwXG4gICAgICBsZXQgZnVsbEhlaWdodCA9IChyZWFkQ29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gKyAxMjApIC0gKHdpbmRvdy5pbm5lckhlaWdodCAqIDAuNylcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZVBlcmNlbnRhZ2UgPSAobnVtYmVyLCB0b3RhbCkgPT4ge1xuICAgICAgICByZXR1cm4gKG51bWJlciAvIHRvdGFsKSAqIDEwMFxuICAgICAgfVxuICAgICAgY29uc3Qgc2V0RWxlbWVudFdpZHRoUGVyY2VudCA9IChlbCwgcGVyY2VudCkgPT4ge1xuICAgICAgICBlbC5zdHlsZS53aWR0aCA9IGAke3BlcmNlbnR9JWBcbiAgICAgIH1cblxuICAgICAgY29uc3RcbiAgICAgICAgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgIHByb2dyZXNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICAgICAgYmFyLmNsYXNzTmFtZSA9ICdibG9nLXByb2dyZXNzJ1xuICAgICAgYmFyLmFwcGVuZENoaWxkKHByb2dyZXNzKVxuXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJhcilcblxuICAgICAgd2luZG93Lm9uc2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICB5ID0gd2luZG93LnNjcm9sbFlcbiAgICAgICAgbGV0IGYgPSBjYWxjdWxhdGVQZXJjZW50YWdlKHksIGZ1bGxIZWlnaHQpXG4gICAgICAgIHNldEVsZW1lbnRXaWR0aFBlcmNlbnQocHJvZ3Jlc3MsIGYpXG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRSZWFkaW5nVGltZTogKCkgPT4ge1xuICAgICAgY29uc3RcbiAgICAgICAgcmVhZENvbnRlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXJ0aWNsZV9fcmVhZC1jb250ZW50JyksXG4gICAgICAgIHRpbWVFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZWFkLXRpbWUnKVxuICAgICAgaWYgKCFyZWFkQ29udGVudCB8fCAhdGltZUVsKSByZXR1cm5cblxuICAgICAgY29uc3RcbiAgICAgICAgd29yZHNQZXJNaW51dGUgPSAyMDAsXG4gICAgICAgIHRleHRDb250ZW50ID0gcmVhZENvbnRlbnQudGV4dENvbnRlbnQsXG4gICAgICAgIHdvcmRDb3VudCA9IHRleHRDb250ZW50LnNwbGl0KC9cXHMvZykubGVuZ3RoLFxuICAgICAgICByZWFkaW5nVGltZSA9IE1hdGguY2VpbCh3b3JkQ291bnQgLyB3b3Jkc1Blck1pbnV0ZSlcblxuXG4gICAgICB0aW1lRWwudGV4dENvbnRlbnQgPSBgJHtyZWFkaW5nVGltZX0gbWluIHJlYWRpbmdgXG4gICAgfSxcbiAgICBhdHRhY2hTY3JvbGw6ICgpID0+IHtcbiAgICAgIHJldHVyblxuICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFydGljbGUtdG9wLWNvdmVyIGltZycpXG4gICAgICBpZiAoaW1nICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBtYXggPSBpbWcub2Zmc2V0SGVpZ2h0ICsgMTAwXG4gICAgICAgIHdpbmRvdy5vbnNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgICBsZXQgeSA9IHdpbmRvdy5zY3JvbGxZXG4gICAgICAgICAgaWYgKG1heCA+IHkpIHtcbiAgICAgICAgICAgIGxldCBmID0gMSAtICh5ICogMTAwIC8gbWF4ICogMC4wMSlcbiAgICAgICAgICAgIGltZy5zdHlsZS5tYXJnaW5Ub3AgPSBgLSR7eSAqIDAuMDh9cHhgXG4gICAgICAgICAgICBpbWcuc3R5bGUub3BhY2l0eSA9IGZcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBibG9nUGFnZSIsImNvbnN0IGZvcm1QYWdlID0gbmV3IE9iamVjdCh7XG4gIHVwbG9hZGVkSW1hZ2VzOiBbXSxcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbl9mb3JtcGFnZScpKSB7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKVxuICAgICAgLy8gdGhpcy5pbWdVcGxvYWQoKVxuICAgICAgdGhpcy5hdHRhY2hJbWFnZXNVcGxvYWRlcigpXG4gICAgICB0aGlzLmF0dGFjaFdhdGNoZXNVcGxvYWQoKVxuICAgIH1cbiAgfSxcbiAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICQoJy5mb3JtcGFnZV9fdXBsb2FkLWJ0bicpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICgkKCcjaW1hZ2VfdXBsb2FkJykubGVuZ3RoKSB7ICQoJyNpbWFnZV91cGxvYWQnKS50cmlnZ2VyKCdjbGljaycpIH1cbiAgICB9KVxuICAgIC8vICQoJyNmb3JtcGFnZV9mb3JtJykub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgLy8gICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgLy8gICBmb3JtUGFnZS5zdWJtaXRBamF4KCk7XG4gICAgLy8gfSk7XG4gIH0sXG4gIHN1Ym1pdEFqYXg6IGZ1bmN0aW9uICgpIHsgfSxcbiAgYXR0YWNoSW1hZ2VzVXBsb2FkZXI6ICgpID0+IHtcbiAgICBjb25zdCB1cGxvYWRMYWJlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNmb3JtcGFnZV9pbWctdXBsb2FkZXInKSxcbiAgICAgIHVwbG9hZElucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2ltYWdlX3VwbG9hZCcpLFxuICAgICAgaW1hZ2VzV3JhcCA9ICQoJy5mb3JtcGFnZV9faW1hZ2VzLXRodW1ibmFpbHMnKVxuXG4gICAgLy8gU2V0dGluZyBkcmFnJmRyb3AgZXZlbnRcbiAgICBpZiAodXBsb2FkTGFiZWwgIT09IG51bGwpIHtcbiAgICAgIHVwbG9hZExhYmVsLm9uZHJhZ292ZXIgPSAoZXZ0KSA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHVwbG9hZExhYmVsLmNsYXNzTGlzdC5hZGQoSVNfQUNUSVZFKVxuICAgICAgfVxuICAgICAgdXBsb2FkTGFiZWwub25kcmFnbGVhdmUgPSAoZXZ0KSA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHVwbG9hZExhYmVsLmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKVxuICAgICAgfVxuICAgICAgdXBsb2FkTGFiZWwub25kcm9wID0gKGV2dCkgPT4ge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB1cGxvYWRMYWJlbC5jbGFzc0xpc3QucmVtb3ZlKElTX0FDVElWRSlcbiAgICAgICAgJCgnI2ltYWdlX3VwbG9hZCcpLnByb3AoJ2ZpbGVzJywgZXZ0LmRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gW10sIGl0ZW1zID0gWy4uLmV2dC5kYXRhVHJhbnNmZXIuaXRlbXNdXG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICBpZiAoaXRlbS5raW5kID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgIGZpbGVzLnB1c2goaXRlbS5nZXRBc0ZpbGUoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAkKCcuZm9ybXBhZ2VfX2ltYWdlcy10aHVtYm5haWxzJykuZW1wdHkoKVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NGaWxlcyhbLi4uZmlsZXNdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldHRpbmcgbWFudWFsIGZpbGVzIHVwbG9hZFxuICAgIGlmICh1cGxvYWRJbnB1dCAhPT0gbnVsbCkge1xuICAgICAgdXBsb2FkSW5wdXQub25jaGFuZ2UgPSAoZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gWy4uLmV2dC50YXJnZXQuZmlsZXNdXG4gICAgICAgICQoJy5mb3JtcGFnZV9faW1hZ2VzLXRodW1ibmFpbHMnKS5lbXB0eSgpXG4gICAgICAgIHByb2Nlc3NGaWxlcyhmaWxlcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoZmlsZXMpIHtcbiAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSwgaSkgPT4ge1xuICAgICAgICAgIGlmICghZmlsZS50eXBlLm1hdGNoKCdpbWFnZS4qJykpIHsgcmV0dXJuIH1cblxuICAgICAgICAgIGxldCBnZXRJbmRleCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAkKCcuZm9ybXBhZ2VfX3VwbG9hZCcpLmxlbmd0aCArIDFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgbGV0IGh0bWwgPVxuICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybXBhZ2VfX3VwbG9hZFwiIGRhdGEtaW1nLWlkPVwiJHtnZXRJbmRleCgpfVwiPlxuICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybXBhZ2VfX2lucHV0LWJveGVzXCI+XG4gICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT1cIjFcIiBuYW1lPVwidmlzaWJsZV9pbWFnZV8ke2l9XCIgaWQ9XCJpbWFnZV8ke2kgKyAxfVwiIHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ+XG4gICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiaW1hZ2VfJHtnZXRJbmRleCgpfVwiPjwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgIDxkaXYgZGF0YS1uYW1lPVwiJHtmaWxlLm5hbWV9XCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJHtlLnRhcmdldC5yZXN1bHR9KVwiIGNsYXNzPVwiZm9ybXBhZ2VfX3VwbG9hZC1iZ1wiPlxuICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgIGBcbiAgICAgICAgICAgIGltYWdlc1dyYXAuYXBwZW5kKGh0bWwpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyBjaGVja2JveCB0b2dnbGUgb24gYXBwZW5kZWQgaW1hZ2VzXG4gICAgJGJvZHkub24oJ2NsaWNrJywgXCIuZm9ybXBhZ2VfX3VwbG9hZC1iZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBsb2NrU2Nyb2xsKClcbiAgICAgIGxldCBodG1sID1cbiAgICAgICAgYFxuICAgICAgPGRpdiBjbGFzcz1cImZvcm1wYWdlLXpvb21cIj5cbiAgICAgICAgPGRpdiBkYXRhLWV2dD1cImNsb3NlRm9ybXBhZ2Vab29tXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgZGF0YS1ibG9jaz1cImZvcm1wYWdlWm9vbVwiPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICBgXG4gICAgICAkYm9keS5hcHBlbmQoaHRtbClcbiAgICAgICQoJ1tkYXRhLWJsb2NrPVwiZm9ybXBhZ2Vab29tXCJdJykuYXR0cignc3R5bGUnLCAkKHRoaXMpLmF0dHIoJ3N0eWxlJykpXG4gICAgfSk7XG4gICAgJGJvZHkub24oJ2NsaWNrJywgJ1tkYXRhLWV2dD1cImNsb3NlRm9ybXBhZ2Vab29tXCJdJywgZnVuY3Rpb24gKCkge1xuICAgICAgdW5sb2NrU2Nyb2xsKClcbiAgICAgICQoJy5mb3JtcGFnZS16b29tJykucmVtb3ZlKClcbiAgICB9KVxuICB9LFxuICBhdHRhY2hXYXRjaGVzVXBsb2FkOiAoKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3dhdGNoZXNfdXBsb2FkX2xhYmVsJyksXG4gICAgICBpbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN3YXRjaGVzX3VwbG9hZCcpXG5cbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICB9LCBmYWxzZSlcblxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsICgpID0+IHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKF9fQUNUSVZFKVxuICAgIH0pXG5cbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShfX0FDVElWRSlcbiAgICB9KVxuXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgICAgaW5wdXQuZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlc1xuICAgIH0pXG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZm9ybVBhZ2UiLCJjbGFzcyBIb21lcGFnZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdCgpXG4gIH1cblxuICAvLyBTcGxpZGVzXG4gIGluaXRDYXRlZ29yaWVzU3BsaWRlKCkge1xuICAgIGNvbnN0IGNhdGVnb3JpZXNFbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhvbWUtY2F0ZWdvcmllcy1zcGxpZGUnKVxuICAgIGlmIChjYXRlZ29yaWVzRWxlbSkge1xuICAgICAgbGV0IHNsaWRlciA9IG5ldyBTcGxpZGUoY2F0ZWdvcmllc0VsZW0sIHtcbiAgICAgICAgdHlwZTogXCJsb29wXCIsXG4gICAgICAgIHBlclBhZ2U6IDcsXG4gICAgICAgIHBlck1vdmU6IDIsXG4gICAgICAgIGF1dG9wbGF5OiAwLFxuICAgICAgICBnYXA6IFwiOHB4XCIsXG4gICAgICAgIGFycm93czogMSxcbiAgICAgICAgcGFnaW5hdGlvbjogMCxcbiAgICAgICAgc3BlZWQ6IDc1MCxcbiAgICAgICAgYnJlYWtwb2ludHM6IHtcbiAgICAgICAgICAxNjgwOiB7IHBlclBhZ2U6IDYsIH0sXG4gICAgICAgICAgMTEyMDogeyBwZXJQYWdlOiA1LCB9LFxuICAgICAgICAgIDc2NzogeyBwZXJQYWdlOiAzLCBwZXJNb3ZlOiAyIH0sXG4gICAgICAgICAgNjAwOiB7IHBlclBhZ2U6IDIsIGdhcDogNiB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBzbGlkZXIubW91bnQoKVxuICAgIH1cbiAgfVxuXG4gIGluaXRTcGxpZGUoKSB7XG4gICAgY29uc3Qgc3BsaWRlQXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5ob21lLXNwbGlkZScpXVxuICAgIGlmIChzcGxpZGVBcnIubGVuZ3RoKSB7XG4gICAgICBzcGxpZGVBcnIuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgICBsZXQgc2xpZGVyID0gbmV3IFNwbGlkZShlbGVtLCB7XG4gICAgICAgICAgdHlwZTogXCJsb29wXCIsXG4gICAgICAgICAgcGVyUGFnZTogNSxcbiAgICAgICAgICBwZXJNb3ZlOiAxLFxuICAgICAgICAgIGF1dG9wbGF5OiAwLFxuICAgICAgICAgIGdhcDogXCI4cHhcIixcbiAgICAgICAgICBhcnJvd3M6IDEsXG4gICAgICAgICAgcGFnaW5hdGlvbjogMCxcbiAgICAgICAgICBzcGVlZDogNzUwLFxuICAgICAgICAgIGJyZWFrcG9pbnRzOiB7XG4gICAgICAgICAgICAxOTgwOiB7XG4gICAgICAgICAgICAgIHBlclBhZ2U6IDVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxNjgwOiB7XG4gICAgICAgICAgICAgIHBlclBhZ2U6IDRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA5OTE6IHtcbiAgICAgICAgICAgICAgcGVyUGFnZTogNCxcbiAgICAgICAgICAgICAgcGVyTW92ZTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA3Njc6IHtcbiAgICAgICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgICAgIHJvd3M6IDIsXG4gICAgICAgICAgICAgICAgY29sczogMyxcbiAgICAgICAgICAgICAgICBnYXA6IHsgcm93OiBcIjI0cHhcIiwgY29sOiBcIjhweFwiIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDQ3ODoge1xuICAgICAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICAgICAgcm93czogMixcbiAgICAgICAgICAgICAgICBjb2xzOiAyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgIHNsaWRlci5tb3VudCh3aW5kb3cuc3BsaWRlLkV4dGVuc2lvbnMpO1xuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuaW5pdENhdGVnb3JpZXNTcGxpZGUoKVxuICAgIHRoaXMuaW5pdFNwbGlkZSgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIb21lcGFnZSIsImNsYXNzIEpvYkFwcCB7XG4gIGNvbnN0cnVjdG9yKGhvbGRlciwgc2V0dGluZ3MgPSB7fSkge1xuICAgIHRoaXMuaG9sZGVyID0gaG9sZGVyXG4gICAgdGhpcy5maWxlc0hvbGRlciA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJyNqb2JfZmlsZXNfdXBsb2FkJylcbiAgICB0aGlzLnNlY3Rpb25zID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWxvYW4tc2VjdGlvbl0nKV1cbiAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1jYXNlX19jb250ZW50JylcbiAgICB0aGlzLnNjcm9sbGVyID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tc2Nyb2xsZXInKVxuICAgIHRoaXMuZm9vdGVyID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tY2FzZV9fZm9vdGVyJylcbiAgICB0aGlzLmJ0bkdyb3VwID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tY2FzZV9fYnRuLWdyb3VwJylcbiAgICB0aGlzLmV2dEdvID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWxvYW4tZXZ0PVwiZ29cIl0nKV1cbiAgICB0aGlzLmV2dFRvZ2dsZSA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1sb2FuLWV2dD1cInRvZ2dsZVwiXScpXVxuICAgIHRoaXMuZXZ0U3VibWl0ID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWxvYW4tZXZ0PVwic3VibWl0XCJdJyldXG4gICAgdGhpcy5ldnRCYWNrID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWxvYW4tZXZ0PVwiYmFja1wiXScpXVxuICAgIHRoaXMuYmFyID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tYmFyJylcbiAgICB0aGlzLmJhcl9wcm9ncmVzcyA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWJhcl9fcHJvZ3Jlc3MnKVxuICAgIHRoaXMuZmxvdyA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWZsb3cnKVxuICAgIHRoaXMuZmluaXNoID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tZmluaXNoJylcbiAgICB0aGlzLm1heFN0ZXBzID0gdW5kZWZpbmVkXG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuc3RlcHNMZWZ0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5lbmRSZWFjaGVkID0gdW5kZWZpbmVkXG4gICAgdGhpcy5hdFN0YXJ0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5zbGlkaW5nID0gZmFsc2VcbiAgICB0aGlzLmRhdGEgPSB7fVxuICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICBzY3JvbGxTcGVlZDogc2V0dGluZ3Muc2Nyb2xsU3BlZWQgfHwgNjAwLFxuICAgICAgZWFzaW5nOiBzZXR0aW5ncy5lYXNpbmcgfHwgJ2N1YmljLWJlemllciguMzksIC41NzUsIC41NjUsIDEpJyxcbiAgICB9XG4gICAgaWYgKHRoaXMuaG9sZGVyKSB7XG4gICAgICB0aGlzLmluaXQoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsc1xuICAgKi9cbiAgZ2V0IGdldExlZnRTdGVwcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwcyAtIHRoaXMuY3VycmVudFN0ZXBcbiAgfVxuICBnZXQgZ2V0QWN0aXZlU2VjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWN0aW9uc1t0aGlzLmN1cnJlbnRTdGVwXVxuICB9XG4gIGdldCBnZXRBY3RpdmVJbnB1dCgpIHtcbiAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5nZXRBY3RpdmVTZWN0aW9uXG4gICAgaWYgKHNlY3Rpb24gJiYgc2VjdGlvbi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50LnRhZ05hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cbiAgZ2V0IGdldExvYWRlckhUTUwoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgaWQ9XCJsb2FkZXItMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4PVwiMHB4XCIgeT1cIjBweFwiIHdpZHRoPVwiNDBweFwiIGhlaWdodD1cIjQwcHhcIiB2aWV3Qm94PVwiMCAwIDQwIDQwXCIgZW5hYmxlLWJhY2tncm91bmQ9XCJuZXcgMCAwIDQwIDQwXCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBvcGFjaXR5PVwiMC4yXCIgZmlsbD1cIiMwMDBcIiBkPVwiTTIwLjIwMSw1LjE2OWMtOC4yNTQsMC0xNC45NDYsNi42OTItMTQuOTQ2LDE0Ljk0NmMwLDguMjU1LDYuNjkyLDE0Ljk0NiwxNC45NDYsMTQuOTQ2IHMxNC45NDYtNi42OTEsMTQuOTQ2LTE0Ljk0NkMzNS4xNDYsMTEuODYxLDI4LjQ1NSw1LjE2OSwyMC4yMDEsNS4xNjl6IE0yMC4yMDEsMzEuNzQ5Yy02LjQyNSwwLTExLjYzNC01LjIwOC0xMS42MzQtMTEuNjM0IGMwLTYuNDI1LDUuMjA5LTExLjYzNCwxMS42MzQtMTEuNjM0YzYuNDI1LDAsMTEuNjMzLDUuMjA5LDExLjYzMywxMS42MzRDMzEuODM0LDI2LjU0MSwyNi42MjYsMzEuNzQ5LDIwLjIwMSwzMS43NDl6XCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGZpbGw9XCIjMDAwXCIgZD1cIk0yNi4wMTMsMTAuMDQ3bDEuNjU0LTIuODY2Yy0yLjE5OC0xLjI3Mi00Ljc0My0yLjAxMi03LjQ2Ni0yLjAxMmgwdjMuMzEyaDBDMjIuMzIsOC40ODEsMjQuMzAxLDkuMDU3LDI2LjAxMywxMC4wNDd6XCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZVR5cGU9XCJ4bWxcIiBhdHRyaWJ1dGVOYW1lPVwidHJhbnNmb3JtXCIgdHlwZT1cInJvdGF0ZVwiIGZyb209XCIwIDIwIDIwXCIgdG89XCIzNjAgMjAgMjBcIiBkdXI9XCIwLjVzXCIgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCI+PC9hbmltYXRlVHJhbnNmb3JtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgIGBcbiAgfVxuICBjcmVhdGVFbGVtKHRhZ05hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgaWQsIGlubmVySFRNTCwgc3R5bGUsIGF0dHJpYnV0ZXMsIHRvQXBwZW5kIH0gPSBvcHRpb25zXG4gICAgY29uc3QgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSlcbiAgICBpZiAoY2xhc3NOYW1lKSBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICBpZiAoaWQpIGVsZW0uaWQgPSBpZDtcbiAgICBpZiAoaW5uZXJIVE1MKSBlbGVtLmlubmVySFRNTCA9IGlubmVySFRNTDtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMuc3R5bGUpIHsgZWxlbS5zdHlsZVtrZXldID0gb3B0aW9ucy5zdHlsZVtrZXldIH1cbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMuYXR0cmlidXRlcykgeyBlbGVtLnNldEF0dHJpYnV0ZShrZXksIG9wdGlvbnMuYXR0cmlidXRlc1trZXldKSB9XG4gICAgfVxuICAgIGlmICh0b0FwcGVuZCkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0b0FycmF5KHRvQXBwZW5kKSkgeyBlbGVtLmFwcGVuZENoaWxkKGNoaWxkKSB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtXG4gIH1cbiAgdG9BcnJheSh0YXJnZXQpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0YXJnZXQpID8gdGFyZ2V0IDogW3RhcmdldF1cbiAgfVxuICBsb2FkaW5nT24odGltZVRvUmVtb3ZlKSB7XG4gICAgaWYgKHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWNhc2UtbG9hZGVyJykpIHJldHVyblxuICAgIGNvbnN0IGxvYWRlciA9IGNyZWF0ZUVsZW0oJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2xvYW4tY2FzZS1sb2FkZXInLFxuICAgICAgaW5uZXJIVE1MOiB0aGlzLmdldExvYWRlckhUTUxcbiAgICB9KVxuICAgIHRoaXMuaG9sZGVyLmFwcGVuZENoaWxkKGxvYWRlcilcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5hZGQoX19MT0NLRUQpXG4gICAgICBpZiAodGltZVRvUmVtb3ZlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5yZW1vdmUoX19MT0NLRUQpXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBsb2FkZXIucmVtb3ZlKClcbiAgICAgICAgICB9LCAzNTApO1xuICAgICAgICB9LCB0aW1lVG9SZW1vdmUpO1xuICAgICAgfVxuICAgIH0sIDEpO1xuICB9XG4gIGxvYWRpbmdPZmYoKSB7XG4gICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnJlbW92ZShfX0xPQ0tFRClcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1jYXNlLWxvYWRlcicpXG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxvYWRlci5yZW1vdmUoKVxuICAgICAgfSwgMzUwKTtcbiAgICB9XG4gIH1cbiAgc2hvd0lucHV0RXJyb3IoaW5wdXQsIHRleHQpIHtcbiAgICBjb25zdCBlcnIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubG9hbi1pbnB1dC1lcnJvcicpID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxvYW4taW5wdXQtZXJyb3InKSA6IGNyZWF0ZUVsZW0oJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2xvYW4taW5wdXQtZXJyb3InLFxuICAgICAgaW5uZXJIVE1MOiB0ZXh0XG4gICAgfSlcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoX19JTlZBTElEKVxuICAgIH1cbiAgICB0aGlzLmZvb3Rlci5wcmVwZW5kKGVycilcbiAgfVxuICBjbGVhckVycm9ycygpIHtcbiAgICBjb25zdCBhY3RpdmVTZWN0aW9uID0gdGhpcy5nZXRBY3RpdmVTZWN0aW9uXG4gICAgY29uc3QgaW5wdXRzID0gWy4uLmFjdGl2ZVNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSwgLi4uYWN0aXZlU2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKV1cbiAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKF9fSU5WQUxJRCkpXG4gICAgY29uc3QgZXJyID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4taW5wdXQtZXJyb3InKVxuICAgIGlmIChlcnIpIGVyci5yZW1vdmUoKVxuICB9XG4gIG9ic2VydmVCYXIoKSB7XG4gICAgY29uc3QgcHJldlNlY3Rpb25zID0gdGhpcy5zZWN0aW9ucy5zbGljZSgwLCB0aGlzLmN1cnJlbnRTdGVwKS5sZW5ndGhcbiAgICBjb25zdCBwcm9ncmVzcyA9IChwcmV2U2VjdGlvbnMgKyAxKSAvIHRoaXMuc3RlcHMgKiAxMDBcbiAgICB0aGlzLmJhcl9wcm9ncmVzcy5zdHlsZS53aWR0aCA9IGAke3Byb2dyZXNzfSVgXG4gIH1cbiAgY2xlYXJBbGxGaWVsZHMoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Om5vdChbdHlwZT1cImNoZWNrYm94XCJdKScpXVxuICAgIGNvbnN0IHNlbGVjdHMgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0JyldXG4gICAgY29uc3QgY2hlY2tib3hlcyA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKV1cbiAgICBjb25zdCBmdWxsQXJyID0gWy4uLmlucHV0cywgLi4uc2VsZWN0cywgLi4uY2hlY2tib3hlc11cblxuICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IGlucHV0LnZhbHVlID0gJycpXG4gICAgc2VsZWN0cy5mb3JFYWNoKHNlbGVjdCA9PiBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IDApXG4gICAgY2hlY2tib3hlcy5mb3JFYWNoKChjaGVja2JveCkgPT4geyBjaGVja2JveC5jaGVja2VkID0gZmFsc2UgfSlcbiAgICBmdWxsQXJyLmZvckVhY2goZWxlbSA9PiBlbGVtLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnKSkpXG4gIH1cblxuICAvKipcbiAgICogTWFpblxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICAkKCcjam9iX2FwcGxpY2F0aW9uX2Zvcm0nKS5zdWJtaXQoKTtcbiAgfVxuICBmaW5pc2hNZXNzYWdlKCkge1xuICAgIHRoaXMubG9hZGluZ09uKDEwMDApXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmZsb3cuc3R5bGUub3BhY2l0eSA9IDBcbiAgICAgIGxldCBjdXJyZW50SGVpZ2h0ID0gdGhpcy5ob2xkZXIub2Zmc2V0SGVpZ2h0XG4gICAgICB0aGlzLmhvbGRlci5zdHlsZS5oZWlnaHQgPSBgJHtjdXJyZW50SGVpZ2h0fXB4YFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZmluaXNoLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgIGxldCBzY3JvbGxIID0gdGhpcy5maW5pc2guc2Nyb2xsSGVpZ2h0XG4gICAgICAgIHRoaXMuaG9sZGVyLnN0eWxlLmhlaWdodCA9IGAke3Njcm9sbEh9cHhgXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZmluaXNoLnN0eWxlLm9wYWNpdHkgPSAxXG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApXG4gICAgICAgICAgY29uc3QgY29uZmV0dGkgPSBuZXcgUGFnZUNvbmZldHRpKClcbiAgICAgICAgICBjb25mZXR0aS5wdXNoKGZhbHNlKVxuICAgICAgICB9LCAxMCk7XG4gICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmZsb3cpICsgMTApXG4gICAgfSwgODAwKTtcbiAgfVxuICBzbGlkZShzZWN0aW9uKSB7XG4gICAgc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgY29uc3QgaGVpZ2h0ID0gc2VjdGlvbi5zY3JvbGxIZWlnaHRcbiAgICBjb25zdCBweFRvVHJhbnNmb3JtID0gdGhpcy5zZWN0aW9ucy5zbGljZSgwLCB0aGlzLmN1cnJlbnRTdGVwKS5yZWR1Y2UoKGFjYywgZWwpID0+IGFjYyArIGVsLnNjcm9sbEhlaWdodCwgMClcbiAgICB0aGlzLmNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YFxuICAgIHRoaXMuc2Nyb2xsZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoLSR7cHhUb1RyYW5zZm9ybX1weClgXG4gICAgdGhpcy5zZWN0aW9ucy5mb3JFYWNoKGUgPT4gZS5jbGFzc0xpc3QucmVtb3ZlKElTX0FDVElWRSkpXG4gICAgc2VjdGlvbi5jbGFzc0xpc3QuYWRkKElTX0FDVElWRSlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlXG4gICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUodGhpcy5zY3JvbGxlcikpO1xuICB9XG4gIGdvKHRvU3RlcCkge1xuICAgIGlmICh0aGlzLmhvbGRlci5jbGFzc0xpc3QuY29udGFpbnMoX19MT0NLRUQpKSByZXR1cm5cbiAgICBjb25zdCBpbnB1dHMgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSwgLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0JyldXG4gICAgY29uc3Qgc3RlcCA9IHRvU3RlcCB8fCB0aGlzLmN1cnJlbnRTdGVwIHx8IDBcbiAgICBjb25zdCBuZXh0U3RlcCA9IHN0ZXAgKyAxXG4gICAgY29uc3QgbmV4dFNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zW25leHRTdGVwXVxuXG4gICAgaWYgKCF0aGlzLnNlY3Rpb25zW25leHRTdGVwICsgMV0pIHtcbiAgICAgIHRoaXMuZXZ0R28uZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICAgIGJ0bi5pbm5lckhUTUwgPSAnU3VibWl0J1xuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAobmV4dFNlY3Rpb24pIHtcbiAgICAgIHRoaXMuc2xpZGluZyA9IHRydWVcbiAgICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IGlucHV0LmJsdXIoKSlcbiAgICAgIHRoaXMubG9hZGluZ09uKClcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gbmV4dFN0ZXBcbiAgICAgICAgdGhpcy5zbGlkZShuZXh0U2VjdGlvbilcbiAgICAgICAgdGhpcy5sb2FkaW5nT2ZmKClcbiAgICAgICAgdGhpcy5vYnNlcnZlQmFyKClcbiAgICAgIH0sIDYwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2F2ZSgpXG4gICAgICB0aGlzLmZpbmlzaE1lc3NhZ2UoKVxuICAgIH1cbiAgfVxuICBiYWNrKHRvU3RlcCkge1xuICAgIGlmICh0aGlzLmhvbGRlci5jbGFzc0xpc3QuY29udGFpbnMoX19MT0NLRUQpKSByZXR1cm5cbiAgICB0aGlzLmNsZWFyRXJyb3JzKClcbiAgICBjb25zdCBzdGVwID0gdG9TdGVwIHx8IHRoaXMuY3VycmVudFN0ZXAgfHwgMFxuICAgIGNvbnN0IHByZXZTdGVwID0gc3RlcCAtIDFcbiAgICBjb25zdCBwcmV2U2VjdGlvbiA9IHRoaXMuc2VjdGlvbnNbcHJldlN0ZXBdXG4gICAgaWYgKHByZXZTZWN0aW9uKSB7XG4gICAgICB0aGlzLmV2dEdvLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgICBidG4uaW5uZXJIVE1MID0gJ05leHQnXG4gICAgICB9KVxuICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IHByZXZTdGVwXG4gICAgICB0aGlzLnNsaWRlKHByZXZTZWN0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvZ2dsZSgpXG4gICAgfVxuICB9XG4gIHZhbGlkYXRlKHNlY3Rpb24pIHtcbiAgICBjb25zdCByZXF1aXJlZFRleHRJbnB1dHMgPSBbLi4uc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwidGV4dFwiXVtyZXF1aXJlZF06bm90KC4tLWRpc2FibGVkJyksIC4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cImVtYWlsXCJdW3JlcXVpcmVkXScpXVxuICAgIGNvbnN0IGVtcHR5SW5wdXRzID0gcmVxdWlyZWRUZXh0SW5wdXRzLmZpbHRlcihpbnB1dCA9PiAhaW5wdXQudmFsdWUpXG4gICAgY29uc3QgbnVtYmVySW5wdXRzID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtkYXRhLXZhbGlkYXRlPVwibnVtYmVyXCJdJylcbiAgICBjb25zdCBzZWxlY3RJbnB1dHMgPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdFtyZXF1aXJlZF0nKVxuICAgIGNvbnN0IGVtYWlsSW5wdXRzID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtkYXRhLXZhbGlkYXRlPVwiZW1haWxcIl0nKVxuICAgIGNvbnN0IHppcElucHV0cyA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbZGF0YS12YWxpZGF0ZT1cInppcF9jb2RlXCJdJylcbiAgICBjb25zdCBmaWxlSW5wdXRzID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtyZXF1aXJlZF1bdHlwZT1cImZpbGVcIl0nKVxuICAgIGNvbnN0IHNlY3Rpb25JRCA9IHNlY3Rpb24uZGF0YXNldC5sb2FuU2VjdGlvblxuXG4gICAgaWYgKHJlcXVpcmVkVGV4dElucHV0cy5zb21lKGlucHV0ID0+IGlucHV0LmNsYXNzTGlzdC5jb250YWlucyhfX0lOVkFMSUQpKSkgcmV0dXJuIGZhbHNlXG5cbiAgICBpZiAoc2VsZWN0SW5wdXRzLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBzZWxlY3Qgb2Ygc2VsZWN0SW5wdXRzKSB7XG4gICAgICAgIGlmICghc2VsZWN0LnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5zaG93SW5wdXRFcnJvcihzZWxlY3QsICdQbGVhc2Ugc2VsZWN0IGFuIG9wdGlvbicpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bWJlcklucHV0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbnVtYmVySW5wdXRzWzBdLnZhbHVlXG4gICAgICBjb25zdCByZWdleCA9IC9eXFwrXFxkezF9XFxzXFwoXFxkezN9XFwpXFxzXFxkezN9XFwtXFxkezR9JC9cbiAgICAgIGlmICghcmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5zaG93SW5wdXRFcnJvcihudW1iZXJJbnB1dHNbMF0sICdQbGVhc2UgZW50ZXIgYSB2YWxpZCBwaG9uZSBudW1iZXInKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVtYWlsSW5wdXRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBlbWFpbElucHV0c1swXS52YWx1ZVxuICAgICAgY29uc3QgcmVnZXggPSAvXlthLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rQFthLXpBLVowLTktXSsoPzpcXC5bYS16QS1aMC05LV0rKSokL1xuICAgICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICB0aGlzLnNob3dJbnB1dEVycm9yKGVtYWlsSW5wdXRzWzBdLCAnUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwnKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHppcElucHV0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gemlwSW5wdXRzWzBdLnZhbHVlXG4gICAgICBjb25zdCByZWdleCA9IC9eXFxkezV9JC9cbiAgICAgIGlmICghcmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5zaG93SW5wdXRFcnJvcih6aXBJbnB1dHNbMF0sICdQbGVhc2UgZW50ZXIgYSB2YWxpZCB6aXAgY29kZScpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW1wdHlJbnB1dHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnNob3dJbnB1dEVycm9yKGVtcHR5SW5wdXRzWzBdLCAnVGhpcyBmaWVsZCBpcyByZXF1aXJlZCcpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKGZpbGVJbnB1dHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGZpbGVJbnB1dHMpIHtcbiAgICAgICAgaWYgKCFpbnB1dC5maWxlc1swXSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGlucHV0LmZpbGVzKVxuICAgICAgICAgIHRoaXMuc2hvd0lucHV0RXJyb3IobnVsbCwgJ1BsZWFzZSB1cGxvYWQgYSBmaWxlJylcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsZWFyRXJyb3JzKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGFkanVzdEFjdGl2ZVNlY3Rpb25IZWlnaHQoKSB7XG4gICAgY29uc3QgYWN0aXZlU2VjdGlvbiA9IHRoaXMuZ2V0QWN0aXZlU2VjdGlvblxuICAgIGlmIChhY3RpdmVTZWN0aW9uKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBhY3RpdmVTZWN0aW9uLnNjcm9sbEhlaWdodFxuICAgICAgdGhpcy5jb250ZW50LnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGBcbiAgICB9XG4gIH1cbiAgdG9nZ2xlKCkge1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JylcbiAgICBjb25zdCBoZWFkZXJOYXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaGVhZGVyX19zdWItbmF2JylcbiAgICBjb25zdCB3ZWxjb21lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnN1YnBhZ2VfX3dlbGNvbWUnKVxuICAgIGNvbnN0IGZvb3Rlck1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9vdGVyX193cmFwcGVyID4gLndyYXBwZXInKVxuICAgIGNvbnN0IGxvYW5XZWxjb21lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxvYW4td2VsY29tZScpXG4gICAgY29uc3QgaGVhZGluZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWNhc2VfX2hlYWRpbmcnKVxuICAgIGNvbnN0IGJhY2tHcm91cCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWNhc2VfX2JhY2stZ3JvdXAnKVxuICAgIGNvbnN0IENBU0VfQ0xBU1MgPSAnbG9hbl9jYXNlJ1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW2hlYWRlck5hdiwgd2VsY29tZSwgZm9vdGVyTWFpbiwgbG9hbldlbGNvbWVdXG5cbiAgICBjb25zdCBoaWRlRWxlbWVudCA9IChlbCkgPT4ge1xuICAgICAgY29uc3QgY3VySGVpZ2h0ID0gZWwuc2Nyb2xsSGVpZ2h0XG4gICAgICBlbC5zdHlsZS5oZWlnaHQgPSBgJHtjdXJIZWlnaHR9cHhgXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnMHB4J1xuICAgICAgfSwgMSk7XG4gICAgfVxuICAgIGNvbnN0IHNob3dFbGVtZW50ID0gKGVsKSA9PiB7XG4gICAgICBjb25zdCBjdXJIZWlnaHQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0JylcbiAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IGVsLnNjcm9sbEhlaWdodFxuICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gYCR7Y3VySGVpZ2h0fWBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlbC5zdHlsZS5vdmVyZmxvdyA9ICd2aXNpYmxlJ1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBgJHtzY3JvbGxIZWlnaHR9cHhgXG4gICAgICB9LCAxKVxuICAgIH1cblxuICAgIGNvbnN0IGhpZGVMb2FuID0gKCkgPT4ge1xuICAgICAgYm9keS5jbGFzc0xpc3QucmVtb3ZlKENBU0VfQ0xBU1MpXG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHNob3dFbGVtZW50KGVsZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2Nyb2xsZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgdGhpcy5jb250ZW50LnN0eWxlLmhlaWdodCA9IGAwcHhgXG5cbiAgICAgIGlmIChiYWNrR3JvdXApIHtcbiAgICAgICAgYmFja0dyb3VwLnN0eWxlLmhlaWdodCA9IGAwcHhgXG4gICAgICB9XG5cbiAgICAgIGlmIChoZWFkaW5nKSB7XG4gICAgICAgIGhlYWRpbmcuaW5uZXJIVE1MID0gJ1dlbGNvbWUgVG8gdGhlIEljZWJveCBNYXggQXBwcm92YWwgRmluYW5jaW5nIEZvcm0nXG4gICAgICAgIGhlYWRpbmcuY2xhc3NMaXN0LnJlbW92ZSgnLS1iaWcnKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNsZWFyRXJyb3JzKClcbiAgICAgIHRoaXMuYmFjaygxKVxuICAgICAgdGhpcy5jbGVhckFsbEZpZWxkcygpXG4gICAgfVxuICAgIGNvbnN0IHNob3dMb2FuID0gKCkgPT4ge1xuICAgICAgYm9keS5jbGFzc0xpc3QuYWRkKCdsb2FuX2Nhc2UnKVxuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChlbGVtZW50KSBoaWRlRWxlbWVudChlbGVtZW50KVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbGVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLnNlY3Rpb25zWzBdLnNjcm9sbEhlaWdodH1weGBcblxuICAgICAgaWYgKGJhY2tHcm91cCkge1xuICAgICAgICBiYWNrR3JvdXAuc3R5bGUuaGVpZ2h0ID0gYCR7YmFja0dyb3VwLnNjcm9sbEhlaWdodH1weGBcbiAgICAgIH1cblxuICAgICAgaWYgKGhlYWRpbmcpIHtcbiAgICAgICAgaGVhZGluZy5pbm5lckhUTUwgPSAnSm9iIEFwcGxpY2F0aW9uJ1xuICAgICAgICBoZWFkaW5nLmNsYXNzTGlzdC5hZGQoJy0tYmlnJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm9keS5jbGFzc0xpc3QuY29udGFpbnMoQ0FTRV9DTEFTUykpIHtcbiAgICAgIGNvbnN0IGFza01vZGFsID0gbmV3IEFza01vZGFsKHtcbiAgICAgICAgaGVhZGluZzogJ0FyZSBZb3UgU3VyZSBZb3UgV2FudCBUbyBFeGl0IEZpbmFuY2luZyBBcHA/JyxcbiAgICAgICAgc3ViaGVhZGluZzogJ1lvdSB3aWxsIGxvc2UgYWxsIHRoZSBwcm9ncmVzcy4gS2VlcCBmaWxsaW5nIG91dCB0aGUgZm9ybSBhbmQgZ2V0IGFwcHJvdmVkIGFzIHNvb24gYXMgcG9zc2libGUhJyxcbiAgICAgICAgZXhpdFRleHQ6ICdFeGl0JyxcbiAgICAgICAga2VlcFRleHQ6ICdLZWVwIEZpbGxpbmcnLFxuICAgICAgICBleGl0Q2FsbGJhY2s6IGhpZGVMb2FuLFxuICAgICAgfSlcbiAgICAgIGFza01vZGFsLnNob3coKVxuICAgIH0gZWxzZSB7XG4gICAgICBzaG93TG9hbigpXG4gICAgfVxuICB9XG4gIHRhYlByZXNzKCkge1xuICAgIGlmICghdGhpcy5zbGlkaW5nKSB7XG4gICAgICBjb25zdCBhY3RpdmVJbnB1dCA9IHRoaXMuZ2V0QWN0aXZlSW5wdXRcbiAgICAgIGlmICghYWN0aXZlSW5wdXQpIHtcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuZ2V0QWN0aXZlU2VjdGlvblxuICAgICAgICBjb25zdCBpbnB1dEFycmF5ID0gWy4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6bm90KC4tLWRpc2FibGVkKSwgc2VsZWN0Om5vdCguLS1kaXNhYmxlZCknKV1cbiAgICAgICAgaWYgKGlucHV0QXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGlucHV0VG9Gb2N1c1xuICAgICAgICAgIGNvbnN0IGludmFsaWRJbnB1dHMgPSBpbnB1dEFycmF5LmZpbHRlcihpbnB1dCA9PiBpbnB1dC5jbGFzc0xpc3QuY29udGFpbnMoJy0taW52YWxpZCcpKVxuICAgICAgICAgIGlmIChpbnZhbGlkSW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaW5wdXRUb0ZvY3VzID0gaW52YWxpZElucHV0c1swXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbXB0eUlucHV0cyA9IGlucHV0QXJyYXkuZmlsdGVyKGlucHV0ID0+ICFpbnB1dC52YWx1ZSAmJiBpbnB1dC52YWx1ZSAhPT0gMClcbiAgICAgICAgICAgIGlmIChlbXB0eUlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaW5wdXRUb0ZvY3VzID0gZW1wdHlJbnB1dHNbMF1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0VG9Gb2N1cyA9IGlucHV0QXJyYXlbMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXRUb0ZvY3VzLmZvY3VzKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWN0aXZlSW5wdXRXcmFwID0gYWN0aXZlSW5wdXQucGFyZW50Tm9kZS5jbG9zZXN0KCcubG9hbi1pbnB1dC13cmFwJylcbiAgICAgICAgY29uc3QgbmV4dElucHV0V3JhcCA9IGFjdGl2ZUlucHV0V3JhcC5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgICAgaWYgKG5leHRJbnB1dFdyYXApIHtcbiAgICAgICAgICBjb25zdCBuZXh0SW5wdXQgPSBuZXh0SW5wdXRXcmFwLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LCBzZWxlY3QnKVxuICAgICAgICAgIGlmIChuZXh0SW5wdXQpIHtcbiAgICAgICAgICAgIG5leHRJbnB1dC5mb2N1cygpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGZpcnN0SW5wdXRXcmFwID0gdGhpcy5nZXRBY3RpdmVTZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWlucHV0LXdyYXAnKVxuICAgICAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBmaXJzdElucHV0V3JhcC5xdWVyeVNlbGVjdG9yKCdpbnB1dCwgc2VsZWN0JylcbiAgICAgICAgICBpZiAoZmlyc3RJbnB1dCkge1xuICAgICAgICAgICAgZmlyc3RJbnB1dC5mb2N1cygpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJpbmQgRXZlbnRzXG4gICAqL1xuICBiaW5kU3RlcEV2dCgpIHtcbiAgICB0aGlzLmV2dEdvLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLmdldEFjdGl2ZVNlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGUoc2VjdGlvbikpIHRoaXMuZ28oKVxuICAgICAgfSlcbiAgICB9KVxuICAgIHRoaXMuZXZ0QmFjay5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgdGhpcy5iYWNrKClcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLmV2dFN1Ym1pdC5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0aGlzLmV2dEdvWzBdLmNsaWNrKClcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLmV2dFRvZ2dsZS5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIHRoaXMudG9nZ2xlKClcbiAgICAgIH0pXG4gICAgfSlcblxuICB9XG4gIGJpbmRJbnB1dEV2ZW50cygpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKV1cbiAgICBjb25zdCBzZWxlY3RzID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCcpXVxuICAgIGNvbnN0IG5vV2Vic2l0ZUNoZWNrYm94ID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignI2xvYW5fZW1wbG95ZXJfd2Vic2l0ZScpXG4gICAgY29uc3QgaW5wdXRXZWJzaXRlRW1wbG95ZXIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcjbG9hbl9lbXBsb3llcl93ZWJzaXRlJylcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgY29uc3QgaXNUYWIgPSBlLmtleSA9PT0gJ1RhYidcbiAgICAgIGlmIChpc1RhYikge1xuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ2xvYW5fY2FzZScpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgdGhpcy50YWJQcmVzcygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckVycm9ycygpXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGlucHV0LnBhcmVudE5vZGUuY2xvc2VzdCgnLmxvYW4taW5wdXQtd3JhcCcpXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQuY2xhc3NMaXN0LmFkZCgnLS1mb2N1c2VkJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGlucHV0LnBhcmVudE5vZGUuY2xvc2VzdCgnLmxvYW4taW5wdXQtd3JhcCcpXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQuY2xhc3NMaXN0LnJlbW92ZSgnLS1mb2N1c2VkJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyRXJyb3JzKClcbiAgICAgICAgY29uc3QgaXNFbnRlciA9IGUua2V5ID09PSAnRW50ZXInXG4gICAgICAgIGNvbnN0IGlzVGFiID0gZS5rZXkgPT09ICdUYWInXG4gICAgICAgIGlmIChpc0VudGVyKSB7XG4gICAgICAgICAgdGhpcy5ldnRHb1swXS5jbGljaygpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICBzZWxlY3RzLmZvckVhY2goKHNlbGVjdCkgPT4ge1xuICAgICAgc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckVycm9ycygpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbiAgYmluZFNTTklucHV0KCkge1xuICAgIGNvbnN0IGlucHV0cyA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W2RhdGEtZm9ybWF0PVwic3NuXCJdJylcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9ICcnXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGFyID0gdmFsdWUuY2hhckF0KGkpXG4gICAgICAgICAgaWYgKGNoYXIubWF0Y2goL15bMC05XSQvKSAmJiBuZXdWYWx1ZS5sZW5ndGggPCA5KSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSArPSBjaGFyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGUudGFyZ2V0LnZhbHVlID0gbmV3VmFsdWVcbiAgICAgIH0pXG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlLnRhcmdldC52YWx1ZVxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8oW14wLTldKS9nLCAnJylcbiAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnNsaWNlKDAsIDMpICsgJ+KAlCcgKyBuZXdWYWx1ZS5zbGljZSgzLCA1KSArICfigJQnICsgbmV3VmFsdWUuc2xpY2UoNSlcbiAgICAgICAgICBlLnRhcmdldC52YWx1ZSA9IG5ld1ZhbHVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIChlKSA9PiB7XG4gICAgICAgIGUudGFyZ2V0LnZhbHVlID0gZS50YXJnZXQudmFsdWUucmVwbGFjZSgvKFteMC05XSkvZywgJycpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBiaW5kTnVtYmVySW5wdXQoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbZGF0YS12YWxpZGF0ZT1cIm51bWJlclwiXScpXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgIGxldCBrZXlDb2RlO1xuICAgICAgZnVuY3Rpb24gbWFzayhldmVudCkge1xuICAgICAgICBldmVudC5rZXlDb2RlICYmIChrZXlDb2RlID0gZXZlbnQua2V5Q29kZSk7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBpZiAocG9zIDwgMykgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICBsZXQgbWF0cml4ID0gXCIrMSAoX19fKSBfX18tX19fX1wiLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGRlZiA9IG1hdHJpeC5yZXBsYWNlKC9cXEQvZywgXCJcIiksXG4gICAgICAgICAgdmFsID0gdGhpcy52YWx1ZS5yZXBsYWNlKC9cXEQvZywgXCJcIiksXG4gICAgICAgICAgbmV3VmFsdWUgPSBtYXRyaXgucmVwbGFjZSgvW19cXGRdL2csIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gaSA8IHZhbC5sZW5ndGggPyB2YWwuY2hhckF0KGkrKykgfHwgZGVmLmNoYXJBdChpKSA6IGE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGkgPSBuZXdWYWx1ZS5pbmRleE9mKFwiX1wiKTtcbiAgICAgICAgaWYgKGkgIT0gLTEpIHtcbiAgICAgICAgICBpIDwgNSAmJiAoaSA9IDMpO1xuICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlZyA9IG1hdHJpeC5zdWJzdHIoMCwgdGhpcy52YWx1ZS5sZW5ndGgpLnJlcGxhY2UoL18rL2csXG4gICAgICAgICAgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxkezEsXCIgKyBhLmxlbmd0aCArIFwifVwiO1xuICAgICAgICAgIH0pLnJlcGxhY2UoL1srKCldL2csIFwiXFxcXCQmXCIpO1xuICAgICAgICByZWcgPSBuZXcgUmVnRXhwKFwiXlwiICsgcmVnICsgXCIkXCIpO1xuICAgICAgICBpZiAoIXJlZy50ZXN0KHRoaXMudmFsdWUpIHx8IHRoaXMudmFsdWUubGVuZ3RoIDwgNSB8fCBrZXlDb2RlID4gNDcgJiYga2V5Q29kZSA8IDU4KSB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGlmIChldmVudC50eXBlID09IFwiYmx1clwiICYmIHRoaXMudmFsdWUubGVuZ3RoIDwgNSkgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBtYXNrLCBmYWxzZSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgbWFzaywgZmFsc2UpO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgbWFzaywgZmFsc2UpO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgbWFzaywgZmFsc2UpO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICBpZiAoaW5wdXQudmFsdWUubGVuZ3RoIDwgNCkge1xuICAgICAgICAgIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKDQsIDQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoaW5wdXQudmFsdWUubGVuZ3RoLCBpbnB1dC52YWx1ZS5sZW5ndGgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGJpbmRSZXN1bWVVcGxvYWQoKSB7XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjam9iX3Jlc3VtZScpXG4gICAgY29uc3QgYm94ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtbG9hbj1cImZpbGVzX3VwbG9hZFwiXScpXG4gICAgY29uc3QgaG9sZGVyID0gdGhpcy5maWxlc0hvbGRlclxuICAgIC8vIGlmICghaW5wdXQgfHwgIWJveCB8fCAhaG9sZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ0pTIDogQmluZCBJRCBVcGxvYWQgOiBJbnB1dCBvciBCb3ggb3IgSG9sZGVyIG5vdCBmb3VuZCcpXG5cbiAgICBpZiAoaW5wdXQgJiYgYm94ICYmIGhvbGRlcikge1xuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoZmlsZXMpIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZEV4dGVuc2lvbnMgPSBbJ3BkZicsICdkb2N4JywgJ2RvYyddXG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBmaWxlLm5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5hbWUuc3BsaXQoJy4nKS5wb3AoKVxuICAgICAgICAgIGlmIChhbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhleHRlbnNpb24pKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhmaWxlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBib3gub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckVycm9ycygpXG4gICAgICAgIGlucHV0LmNsaWNrKClcbiAgICAgIH1cbiAgICAgIGlucHV0Lm9uY2hhbmdlID0gKGUpID0+IHtcbiAgICAgICAgcHJvY2Vzc0ZpbGVzKGUudGFyZ2V0LmZpbGVzKVxuICAgICAgfVxuICAgICAgYm94Lm9uZHJhZ292ZXIgPSAoZSkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyRXJyb3JzKClcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGJveC5jbGFzc0xpc3QuYWRkKElTX0FDVElWRSlcbiAgICAgIH1cbiAgICAgIGJveC5vbmRyYWdsZWF2ZSA9IChlKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYXJFcnJvcnMoKVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgYm94LmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKVxuICAgICAgfVxuICAgICAgYm94Lm9uZHJvcCA9IChlKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYXJFcnJvcnMoKVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgYm94LmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBiaW5kRHVhbFNlbGVjdCgpIHtcbiAgICBjb25zdCBkdWFsQXJyID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbG9hbi1ldnQ9XCJkdWFsX3NlbGVjdFwiXScpXG4gICAgZm9yIChjb25zdCBkdWFsIG9mIGR1YWxBcnIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZHVhbC5xdWVyeVNlbGVjdG9yKCdpbnB1dDpub3QoW3R5cGU9XCJjaGVja2JveFwiXSknKVxuICAgICAgY29uc3QgY2hlY2tib3ggPSBkdWFsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpXG4gICAgICBpZiAoaW5wdXQgJiYgY2hlY2tib3gpIHtcbiAgICAgICAgY2hlY2tib3gub25jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgbGV0IGlzQ2hlY2tlZCA9IGNoZWNrYm94LmNoZWNrZWRcbiAgICAgICAgICBpZiAoaXNDaGVja2VkKSB7XG4gICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCctLWRpc2FibGVkJylcbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKVxuICAgICAgICAgICAgaWYgKGlucHV0LnR5cGUgIT09ICdyYW5nZScpIHtcbiAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoJy0tZGlzYWJsZWQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJhbmdlT3V0cHV0QXJyID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jdXN0b20tcmFuZ2VfX291dHB1dCcpXVxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgcmFuZ2VPdXRwdXRBcnIpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGlucHV0LmNsb3Nlc3QoJ1tkYXRhLWxvYW4tZXZ0PVwiZHVhbF9zZWxlY3RcIl0nKVxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBjb25zdCByYW5nZUlucHV0ID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJyYW5nZVwiXScpXG4gICAgICAgIGlmIChyYW5nZUlucHV0KSB7XG4gICAgICAgICAgY29uc3QgbWF4VmFsdWUgPSByYW5nZUlucHV0Lm1heFxuICAgICAgICAgIGNvbnN0IG1pblZhbHVlID0gcmFuZ2VJbnB1dC5taW5cblxuICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gZS50YXJnZXQudmFsdWUucmVwbGFjZSgvW14wLTldL2csICcnKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGUpID0+IHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4oZS50YXJnZXQudmFsdWUsIG1heFZhbHVlKSwgbWluVmFsdWUpXG4gICAgICAgICAgICByYW5nZUlucHV0LnZhbHVlID0gZS50YXJnZXQudmFsdWVcbiAgICAgICAgICAgIHJhbmdlSW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JykpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBiaW5kRm9ybWF0dGluZygpIHtcbiAgICBjb25zdCBjdXJyZW5jeUFyciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZvcm1hdD1cImN1cnJlbmN5XCJdJylcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGN1cnJlbmN5QXJyKSB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBpbnB1dC52YWx1ZVxuICAgICAgICBpZiAodmFsLmxlbmd0aCkge1xuICAgICAgICAgIGlucHV0LnZhbHVlID0gZm9ybWF0QXNDdXJyZW5jeSh2YWwpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxcbiAgICovXG4gIHNldEluaXRpYWxWYXIoKSB7XG4gICAgdGhpcy5zdGVwcyA9IHRoaXMuc2VjdGlvbnMubGVuZ3RoXG4gICAgaWYgKCF0aGlzLnN0ZXBzKSB0aHJvdyBuZXcgRXJyb3IoJ05vIExvYW4gU2VjdGlvbnMgRm91bmQnKVxuICAgIHRoaXMuY3VycmVudFN0ZXAgPSAwXG4gICAgdGhpcy5zdGVwc0xlZnQgPSB0aGlzLnN0ZXBzXG4gICAgdGhpcy5lbmRSZWFjaGVkID0gZmFsc2VcbiAgICB0aGlzLmF0VGhlU3RhcnQgPSB0cnVlXG4gIH1cbiAgc2V0SW5pdGlhbExheW91dCgpIHtcbiAgICBjb25zdCBmaXJzdFNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zWzBdXG4gICAgY29uc3QgaGVpZ2h0ID0gZmlyc3RTZWN0aW9uLnNjcm9sbEhlaWdodFxuICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgXG4gICAgdGhpcy5jb250ZW50LnN0eWxlLnRyYW5zaXRpb24gPSBgYWxsICR7dGhpcy5zZXR0aW5ncy5zY3JvbGxTcGVlZH1tcyAke3RoaXMuc2V0dGluZ3MuZWFzaW5nfWBcbiAgICB0aGlzLnNjcm9sbGVyLnN0eWxlLnRyYW5zaXRpb24gPSBgYWxsICR7dGhpcy5zZXR0aW5ncy5zY3JvbGxTcGVlZH1tcyAke3RoaXMuc2V0dGluZ3MuZWFzaW5nfWBcbiAgICAvLyB0aGlzLnNlY3Rpb25zLmZvckVhY2goc2VjdGlvbiA9PiBzZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSAnZmxleCcpXG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnNldEluaXRpYWxMYXlvdXQoKVxuICAgIHRoaXMuc2V0SW5pdGlhbFZhcigpXG4gICAgdGhpcy5iaW5kU3RlcEV2dCgpXG4gICAgdGhpcy5iaW5kSW5wdXRFdmVudHMoKVxuICAgIHRoaXMuYmluZE51bWJlcklucHV0KClcbiAgICB0aGlzLmJpbmRTU05JbnB1dCgpXG4gICAgdGhpcy5iaW5kUmVzdW1lVXBsb2FkKClcbiAgICB0aGlzLmJpbmREdWFsU2VsZWN0KClcbiAgICB0aGlzLmJpbmRGb3JtYXR0aW5nKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEpvYkFwcCIsImNsYXNzIExvYW5BcHAge1xuICBjb25zdHJ1Y3Rvcihob2xkZXIsIHNldHRpbmdzID0ge30pIHtcbiAgICB0aGlzLmhvbGRlciA9IGhvbGRlclxuICAgIHRoaXMuZmlsZXNIb2xkZXIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcjbG9hbl9maWxlc191cGxvYWQnKVxuICAgIHRoaXMuc2VjdGlvbnMgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbG9hbi1zZWN0aW9uXScpXVxuICAgIHRoaXMuY29udGVudCA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWNhc2VfX2NvbnRlbnQnKVxuICAgIHRoaXMuc2Nyb2xsZXIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1zY3JvbGxlcicpXG4gICAgdGhpcy5mb290ZXIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1jYXNlX19mb290ZXInKVxuICAgIHRoaXMuYnRuR3JvdXAgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1jYXNlX19idG4tZ3JvdXAnKVxuICAgIHRoaXMuZXZ0R28gPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbG9hbi1ldnQ9XCJnb1wiXScpXVxuICAgIHRoaXMuZXZ0VG9nZ2xlID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWxvYW4tZXZ0PVwidG9nZ2xlXCJdJyldXG4gICAgdGhpcy5ldnRTdWJtaXQgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbG9hbi1ldnQ9XCJzdWJtaXRcIl0nKV1cbiAgICB0aGlzLmV2dEJhY2sgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbG9hbi1ldnQ9XCJiYWNrXCJdJyldXG4gICAgdGhpcy5iYXIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1iYXInKVxuICAgIHRoaXMuYmFyX3Byb2dyZXNzID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tYmFyX19wcm9ncmVzcycpXG4gICAgdGhpcy5mbG93ID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tZmxvdycpXG4gICAgdGhpcy5maW5pc2ggPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1maW5pc2gnKVxuICAgIHRoaXMubWF4U3RlcHMgPSB1bmRlZmluZWRcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gdW5kZWZpbmVkXG4gICAgdGhpcy5zdGVwc0xlZnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLmVuZFJlYWNoZWQgPSB1bmRlZmluZWRcbiAgICB0aGlzLmF0U3RhcnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZVxuICAgIHRoaXMuZGF0YSA9IHt9XG4gICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgIHNjcm9sbFNwZWVkOiBzZXR0aW5ncy5zY3JvbGxTcGVlZCB8fCA2MDAsXG4gICAgICBlYXNpbmc6IHNldHRpbmdzLmVhc2luZyB8fCAnY3ViaWMtYmV6aWVyKC4zOSwgLjU3NSwgLjU2NSwgMSknLFxuICAgIH1cbiAgICBpZiAodGhpcy5ob2xkZXIpIHtcbiAgICAgIHRoaXMuaW5pdCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxzXG4gICAqL1xuICBnZXQgZ2V0TGVmdFN0ZXBzKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzIC0gdGhpcy5jdXJyZW50U3RlcFxuICB9XG4gIGdldCBnZXRBY3RpdmVTZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNlY3Rpb25zW3RoaXMuY3VycmVudFN0ZXBdXG4gIH1cbiAgZ2V0IGdldEFjdGl2ZUlucHV0KCkge1xuICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLmdldEFjdGl2ZVNlY3Rpb25cbiAgICBpZiAoc2VjdGlvbiAmJiBzZWN0aW9uLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnIHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuICBnZXQgZ2V0TG9hZGVySFRNTCgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnIHZlcnNpb249XCIxLjFcIiBpZD1cImxvYWRlci0xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCIgd2lkdGg9XCI0MHB4XCIgaGVpZ2h0PVwiNDBweFwiIHZpZXdCb3g9XCIwIDAgNDAgNDBcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgNDAgNDBcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIG9wYWNpdHk9XCIwLjJcIiBmaWxsPVwiIzAwMFwiIGQ9XCJNMjAuMjAxLDUuMTY5Yy04LjI1NCwwLTE0Ljk0Niw2LjY5Mi0xNC45NDYsMTQuOTQ2YzAsOC4yNTUsNi42OTIsMTQuOTQ2LDE0Ljk0NiwxNC45NDYgczE0Ljk0Ni02LjY5MSwxNC45NDYtMTQuOTQ2QzM1LjE0NiwxMS44NjEsMjguNDU1LDUuMTY5LDIwLjIwMSw1LjE2OXogTTIwLjIwMSwzMS43NDljLTYuNDI1LDAtMTEuNjM0LTUuMjA4LTExLjYzNC0xMS42MzQgYzAtNi40MjUsNS4yMDktMTEuNjM0LDExLjYzNC0xMS42MzRjNi40MjUsMCwxMS42MzMsNS4yMDksMTEuNjMzLDExLjYzNEMzMS44MzQsMjYuNTQxLDI2LjYyNiwzMS43NDksMjAuMjAxLDMxLjc0OXpcIj48L3BhdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIiMwMDBcIiBkPVwiTTI2LjAxMywxMC4wNDdsMS42NTQtMi44NjZjLTIuMTk4LTEuMjcyLTQuNzQzLTIuMDEyLTcuNDY2LTIuMDEyaDB2My4zMTJoMEMyMi4zMiw4LjQ4MSwyNC4zMDEsOS4wNTcsMjYuMDEzLDEwLjA0N3pcIj48L3BhdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlVHlwZT1cInhtbFwiIGF0dHJpYnV0ZU5hbWU9XCJ0cmFuc2Zvcm1cIiB0eXBlPVwicm90YXRlXCIgZnJvbT1cIjAgMjAgMjBcIiB0bz1cIjM2MCAyMCAyMFwiIGR1cj1cIjAuNXNcIiByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIj48L2FuaW1hdGVUcmFuc2Zvcm0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgYFxuICB9XG4gIGNyZWF0ZUVsZW0odGFnTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBpZCwgaW5uZXJIVE1MLCBzdHlsZSwgYXR0cmlidXRlcywgdG9BcHBlbmQgfSA9IG9wdGlvbnNcbiAgICBjb25zdCBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKVxuICAgIGlmIChjbGFzc05hbWUpIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIGlmIChpZCkgZWxlbS5pZCA9IGlkO1xuICAgIGlmIChpbm5lckhUTUwpIGVsZW0uaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5zdHlsZSkgeyBlbGVtLnN0eWxlW2tleV0gPSBvcHRpb25zLnN0eWxlW2tleV0gfVxuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5hdHRyaWJ1dGVzKSB7IGVsZW0uc2V0QXR0cmlidXRlKGtleSwgb3B0aW9ucy5hdHRyaWJ1dGVzW2tleV0pIH1cbiAgICB9XG4gICAgaWYgKHRvQXBwZW5kKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRvQXJyYXkodG9BcHBlbmQpKSB7IGVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQpIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1cbiAgfVxuICB0b0FycmF5KHRhcmdldCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQgOiBbdGFyZ2V0XVxuICB9XG4gIGxvYWRpbmdPbih0aW1lVG9SZW1vdmUpIHtcbiAgICBpZiAodGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignLmxvYW4tY2FzZS1sb2FkZXInKSkgcmV0dXJuXG4gICAgY29uc3QgbG9hZGVyID0gY3JlYXRlRWxlbSgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAnbG9hbi1jYXNlLWxvYWRlcicsXG4gICAgICBpbm5lckhUTUw6IHRoaXMuZ2V0TG9hZGVySFRNTFxuICAgIH0pXG4gICAgdGhpcy5ob2xkZXIuYXBwZW5kQ2hpbGQobG9hZGVyKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmFkZChfX0xPQ0tFRClcbiAgICAgIGlmICh0aW1lVG9SZW1vdmUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnJlbW92ZShfX0xPQ0tFRClcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGxvYWRlci5yZW1vdmUoKVxuICAgICAgICAgIH0sIDM1MCk7XG4gICAgICAgIH0sIHRpbWVUb1JlbW92ZSk7XG4gICAgICB9XG4gICAgfSwgMSk7XG4gIH1cbiAgbG9hZGluZ09mZigpIHtcbiAgICB0aGlzLmhvbGRlci5jbGFzc0xpc3QucmVtb3ZlKF9fTE9DS0VEKVxuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWNhc2UtbG9hZGVyJylcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbG9hZGVyLnJlbW92ZSgpXG4gICAgICB9LCAzNTApO1xuICAgIH1cbiAgfVxuICBzaG93SW5wdXRFcnJvcihpbnB1dCwgdGV4dCkge1xuICAgIGNvbnN0IGVyciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLWlucHV0LWVycm9yJykgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubG9hbi1pbnB1dC1lcnJvcicpIDogY3JlYXRlRWxlbSgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAnbG9hbi1pbnB1dC1lcnJvcicsXG4gICAgICBpbm5lckhUTUw6IHRleHRcbiAgICB9KVxuICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoX19JTlZBTElEKVxuICAgIHRoaXMuZm9vdGVyLnByZXBlbmQoZXJyKVxuICB9XG4gIGNsZWFyRXJyb3JzKCkge1xuICAgIGNvbnN0IGFjdGl2ZVNlY3Rpb24gPSB0aGlzLmdldEFjdGl2ZVNlY3Rpb25cbiAgICBjb25zdCBpbnB1dHMgPSBbLi4uYWN0aXZlU2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpLCAuLi5hY3RpdmVTZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCcpXVxuICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoX19JTlZBTElEKSlcbiAgICBjb25zdCBlcnIgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKCcubG9hbi1pbnB1dC1lcnJvcicpXG4gICAgaWYgKGVycikgZXJyLnJlbW92ZSgpXG4gIH1cbiAgb2JzZXJ2ZUJhcigpIHtcbiAgICBjb25zdCBwcmV2U2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zLnNsaWNlKDAsIHRoaXMuY3VycmVudFN0ZXApLmxlbmd0aFxuICAgIGNvbnN0IHByb2dyZXNzID0gKHByZXZTZWN0aW9ucyArIDEpIC8gdGhpcy5zdGVwcyAqIDEwMFxuICAgIHRoaXMuYmFyX3Byb2dyZXNzLnN0eWxlLndpZHRoID0gYCR7cHJvZ3Jlc3N9JWBcbiAgfVxuICBjbGVhckFsbEZpZWxkcygpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6bm90KFt0eXBlPVwiY2hlY2tib3hcIl0pJyldXG4gICAgY29uc3Qgc2VsZWN0cyA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKV1cbiAgICBjb25zdCBjaGVja2JveGVzID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpXVxuICAgIGNvbnN0IGZ1bGxBcnIgPSBbLi4uaW5wdXRzLCAuLi5zZWxlY3RzLCAuLi5jaGVja2JveGVzXVxuXG4gICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gaW5wdXQudmFsdWUgPSAnJylcbiAgICBzZWxlY3RzLmZvckVhY2goc2VsZWN0ID0+IHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gMClcbiAgICBjaGVja2JveGVzLmZvckVhY2goKGNoZWNrYm94KSA9PiB7IGNoZWNrYm94LmNoZWNrZWQgPSBmYWxzZSB9KVxuICAgIGZ1bGxBcnIuZm9yRWFjaChlbGVtID0+IGVsZW0uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWluXG4gICAqL1xuICBzYXZlKCkge1xuICAgICQoJyNsb2FuX2Zvcm0nKS5zdWJtaXQoKTtcbiAgfVxuICBmaW5pc2hNZXNzYWdlKCkge1xuICAgIHRoaXMubG9hZGluZ09uKDEwMDApXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmZsb3cuc3R5bGUub3BhY2l0eSA9IDBcbiAgICAgIGxldCBjdXJyZW50SGVpZ2h0ID0gdGhpcy5ob2xkZXIub2Zmc2V0SGVpZ2h0XG4gICAgICB0aGlzLmhvbGRlci5zdHlsZS5oZWlnaHQgPSBgJHtjdXJyZW50SGVpZ2h0fXB4YFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZmluaXNoLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgIGxldCBzY3JvbGxIID0gdGhpcy5maW5pc2guc2Nyb2xsSGVpZ2h0XG4gICAgICAgIHRoaXMuaG9sZGVyLnN0eWxlLmhlaWdodCA9IGAke3Njcm9sbEh9cHhgXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZmluaXNoLnN0eWxlLm9wYWNpdHkgPSAxXG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApXG4gICAgICAgICAgY29uc3QgY29uZmV0dGkgPSBuZXcgUGFnZUNvbmZldHRpKClcbiAgICAgICAgICBjb25mZXR0aS5wdXNoKGZhbHNlKVxuICAgICAgICB9LCAxMCk7XG4gICAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmZsb3cpICsgMTApXG4gICAgfSwgODAwKTtcbiAgfVxuICBzbGlkZShzZWN0aW9uKSB7XG4gICAgc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgY29uc3QgaGVpZ2h0ID0gc2VjdGlvbi5zY3JvbGxIZWlnaHRcbiAgICBjb25zdCBweFRvVHJhbnNmb3JtID0gdGhpcy5zZWN0aW9ucy5zbGljZSgwLCB0aGlzLmN1cnJlbnRTdGVwKS5yZWR1Y2UoKGFjYywgZWwpID0+IGFjYyArIGVsLnNjcm9sbEhlaWdodCwgMClcbiAgICB0aGlzLmNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YFxuICAgIHRoaXMuc2Nyb2xsZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoLSR7cHhUb1RyYW5zZm9ybX1weClgXG4gICAgdGhpcy5zZWN0aW9ucy5mb3JFYWNoKGUgPT4gZS5jbGFzc0xpc3QucmVtb3ZlKElTX0FDVElWRSkpXG4gICAgc2VjdGlvbi5jbGFzc0xpc3QuYWRkKElTX0FDVElWRSlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlXG4gICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUodGhpcy5zY3JvbGxlcikpO1xuICB9XG4gIGdvKHRvU3RlcCkge1xuICAgIGlmICh0aGlzLmhvbGRlci5jbGFzc0xpc3QuY29udGFpbnMoX19MT0NLRUQpKSByZXR1cm5cbiAgICBjb25zdCBpbnB1dHMgPSBbLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSwgLi4udGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0JyldXG4gICAgY29uc3Qgc3RlcCA9IHRvU3RlcCB8fCB0aGlzLmN1cnJlbnRTdGVwIHx8IDBcbiAgICBjb25zdCBuZXh0U3RlcCA9IHN0ZXAgKyAxXG4gICAgY29uc3QgbmV4dFNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zW25leHRTdGVwXVxuXG4gICAgaWYgKCF0aGlzLnNlY3Rpb25zW25leHRTdGVwICsgMV0pIHtcbiAgICAgIHRoaXMuZXZ0R28uZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICAgIGJ0bi5pbm5lckhUTUwgPSAnU3VibWl0J1xuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAobmV4dFNlY3Rpb24pIHtcbiAgICAgIHRoaXMuc2xpZGluZyA9IHRydWVcbiAgICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IGlucHV0LmJsdXIoKSlcbiAgICAgIHRoaXMubG9hZGluZ09uKClcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gbmV4dFN0ZXBcbiAgICAgICAgdGhpcy5zbGlkZShuZXh0U2VjdGlvbilcbiAgICAgICAgdGhpcy5sb2FkaW5nT2ZmKClcbiAgICAgICAgdGhpcy5vYnNlcnZlQmFyKClcbiAgICAgIH0sIDYwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2F2ZSgpXG4gICAgICB0aGlzLmZpbmlzaE1lc3NhZ2UoKVxuICAgIH1cbiAgfVxuICBiYWNrKHRvU3RlcCkge1xuICAgIGlmICh0aGlzLmhvbGRlci5jbGFzc0xpc3QuY29udGFpbnMoX19MT0NLRUQpKSByZXR1cm5cbiAgICB0aGlzLmNsZWFyRXJyb3JzKClcbiAgICBjb25zdCBzdGVwID0gdG9TdGVwIHx8IHRoaXMuY3VycmVudFN0ZXAgfHwgMFxuICAgIGNvbnN0IHByZXZTdGVwID0gc3RlcCAtIDFcbiAgICBjb25zdCBwcmV2U2VjdGlvbiA9IHRoaXMuc2VjdGlvbnNbcHJldlN0ZXBdXG4gICAgaWYgKHByZXZTZWN0aW9uKSB7XG4gICAgICB0aGlzLmV2dEdvLmZvckVhY2goKGJ0bikgPT4ge1xuICAgICAgICBidG4uaW5uZXJIVE1MID0gJ05leHQnXG4gICAgICB9KVxuICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IHByZXZTdGVwXG4gICAgICB0aGlzLnNsaWRlKHByZXZTZWN0aW9uKVxuICAgIH1cbiAgfVxuICB2YWxpZGF0ZShzZWN0aW9uKSB7XG4gICAgY29uc3QgcmVxdWlyZWRUZXh0SW5wdXRzID0gWy4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInRleHRcIl1bcmVxdWlyZWRdOm5vdCguLS1kaXNhYmxlZCcpLCAuLi5zZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJlbWFpbFwiXVtyZXF1aXJlZF0nKV1cbiAgICBjb25zdCBlbXB0eUlucHV0cyA9IHJlcXVpcmVkVGV4dElucHV0cy5maWx0ZXIoaW5wdXQgPT4gIWlucHV0LnZhbHVlKVxuICAgIGNvbnN0IG51bWJlcklucHV0cyA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbZGF0YS12YWxpZGF0ZT1cIm51bWJlclwiXScpXG4gICAgY29uc3Qgc2VsZWN0SW5wdXRzID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3RbcmVxdWlyZWRdJylcbiAgICBjb25zdCBlbWFpbElucHV0cyA9IHNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbZGF0YS12YWxpZGF0ZT1cImVtYWlsXCJdJylcbiAgICBjb25zdCB6aXBJbnB1dHMgPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W2RhdGEtdmFsaWRhdGU9XCJ6aXBfY29kZVwiXScpXG4gICAgY29uc3Qgc2VjdGlvbklEID0gc2VjdGlvbi5kYXRhc2V0LmxvYW5TZWN0aW9uXG5cbiAgICBpZiAocmVxdWlyZWRUZXh0SW5wdXRzLnNvbWUoaW5wdXQgPT4gaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKF9fSU5WQUxJRCkpKSByZXR1cm4gZmFsc2VcbiAgICBpZiAobnVtYmVySW5wdXRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBudW1iZXJJbnB1dHNbMF0udmFsdWVcbiAgICAgIGNvbnN0IHJlZ2V4ID0gL15cXCtcXGR7MX1cXHNcXChcXGR7M31cXClcXHNcXGR7M31cXC1cXGR7NH0kL1xuICAgICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICB0aGlzLnNob3dJbnB1dEVycm9yKG51bWJlcklucHV0c1swXSwgJ1BsZWFzZSBlbnRlciBhIHZhbGlkIHBob25lIG51bWJlcicpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW1haWxJbnB1dHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGVtYWlsSW5wdXRzWzBdLnZhbHVlXG4gICAgICBjb25zdCByZWdleCA9IC9eW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtekEtWjAtOS1dKyg/OlxcLlthLXpBLVowLTktXSspKiQvXG4gICAgICBpZiAoIXJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc2hvd0lucHV0RXJyb3IoZW1haWxJbnB1dHNbMF0sICdQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCcpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoemlwSW5wdXRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB6aXBJbnB1dHNbMF0udmFsdWVcbiAgICAgIGNvbnN0IHJlZ2V4ID0gL15cXGR7NX0kL1xuICAgICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICB0aGlzLnNob3dJbnB1dEVycm9yKHppcElucHV0c1swXSwgJ1BsZWFzZSBlbnRlciBhIHZhbGlkIHppcCBjb2RlJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbXB0eUlucHV0cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc2hvd0lucHV0RXJyb3IoZW1wdHlJbnB1dHNbMF0sICdUaGlzIGZpZWxkIGlzIHJlcXVpcmVkJylcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoc2VsZWN0SW5wdXRzLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBzZWxlY3Qgb2Ygc2VsZWN0SW5wdXRzKSB7XG4gICAgICAgIGlmICghc2VsZWN0LnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5zaG93SW5wdXRFcnJvcihzZWxlY3QsICdQbGVhc2Ugc2VsZWN0IGFuIG9wdGlvbicpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBhZGp1c3RBY3RpdmVTZWN0aW9uSGVpZ2h0KCkge1xuICAgIGNvbnN0IGFjdGl2ZVNlY3Rpb24gPSB0aGlzLmdldEFjdGl2ZVNlY3Rpb25cbiAgICBpZiAoYWN0aXZlU2VjdGlvbikge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYWN0aXZlU2VjdGlvbi5zY3JvbGxIZWlnaHRcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgXG4gICAgfVxuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpXG4gICAgY29uc3QgaGVhZGVyTmF2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhlYWRlcl9fc3ViLW5hdicpXG4gICAgY29uc3Qgd2VsY29tZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zdWJwYWdlX193ZWxjb21lJylcbiAgICBjb25zdCBmb290ZXJNYWluID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvb3Rlcl9fd3JhcHBlciA+IC53cmFwcGVyJylcbiAgICBjb25zdCBsb2FuV2VsY29tZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sb2FuLXdlbGNvbWUnKVxuICAgIGNvbnN0IGhlYWRpbmcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubG9hbi1jYXNlX19oZWFkaW5nJylcbiAgICBjb25zdCBiYWNrR3JvdXAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubG9hbi1jYXNlX19iYWNrLWdyb3VwJylcbiAgICBjb25zdCBDQVNFX0NMQVNTID0gJ2xvYW5fY2FzZSdcbiAgICBjb25zdCBlbGVtZW50cyA9IFtoZWFkZXJOYXYsIHdlbGNvbWUsIGZvb3Rlck1haW4sIGxvYW5XZWxjb21lXVxuXG4gICAgY29uc3QgaGlkZUVsZW1lbnQgPSAoZWwpID0+IHtcbiAgICAgIGNvbnN0IGN1ckhlaWdodCA9IGVsLnNjcm9sbEhlaWdodFxuICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gYCR7Y3VySGVpZ2h0fXB4YFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbidcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJzBweCdcbiAgICAgIH0sIDEpO1xuICAgIH1cbiAgICBjb25zdCBzaG93RWxlbWVudCA9IChlbCkgPT4ge1xuICAgICAgY29uc3QgY3VySGVpZ2h0ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpXG4gICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHRcbiAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGAke2N1ckhlaWdodH1gXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSdcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gYCR7c2Nyb2xsSGVpZ2h0fXB4YFxuICAgICAgfSwgMSlcbiAgICB9XG5cbiAgICBjb25zdCBoaWRlTG9hbiA9ICgpID0+IHtcbiAgICAgIGJvZHkuY2xhc3NMaXN0LnJlbW92ZShDQVNFX0NMQVNTKVxuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChlbGVtZW50KSBzaG93RWxlbWVudChlbGVtZW50KVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBgMHB4YFxuXG4gICAgICBpZiAoYmFja0dyb3VwKSB7XG4gICAgICAgIGJhY2tHcm91cC5zdHlsZS5oZWlnaHQgPSBgMHB4YFxuICAgICAgfVxuXG4gICAgICBpZiAoaGVhZGluZykge1xuICAgICAgICBoZWFkaW5nLmlubmVySFRNTCA9ICdXZWxjb21lIFRvIHRoZSBJY2Vib3ggTWF4IEFwcHJvdmFsIEZpbmFuY2luZyBGb3JtJ1xuICAgICAgICBoZWFkaW5nLmNsYXNzTGlzdC5yZW1vdmUoJy0tYmlnJylcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGVhckVycm9ycygpXG4gICAgICB0aGlzLmJhY2soMSlcbiAgICAgIHRoaXMuY2xlYXJBbGxGaWVsZHMoKVxuICAgIH1cbiAgICBjb25zdCBzaG93TG9hbiA9ICgpID0+IHtcbiAgICAgIGJvZHkuY2xhc3NMaXN0LmFkZCgnbG9hbl9jYXNlJylcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBpZiAoZWxlbWVudCkgaGlkZUVsZW1lbnQoZWxlbWVudClcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGxlci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgICB0aGlzLmNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5zZWN0aW9uc1swXS5zY3JvbGxIZWlnaHR9cHhgXG5cbiAgICAgIGlmIChiYWNrR3JvdXApIHtcbiAgICAgICAgYmFja0dyb3VwLnN0eWxlLmhlaWdodCA9IGAke2JhY2tHcm91cC5zY3JvbGxIZWlnaHR9cHhgXG4gICAgICB9XG5cbiAgICAgIGlmIChoZWFkaW5nKSB7XG4gICAgICAgIGhlYWRpbmcuaW5uZXJIVE1MID0gJ0ZpbmFuY2luZyBBcHBsaWNhdGlvbidcbiAgICAgICAgaGVhZGluZy5jbGFzc0xpc3QuYWRkKCctLWJpZycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJvZHkuY2xhc3NMaXN0LmNvbnRhaW5zKENBU0VfQ0xBU1MpKSB7XG4gICAgICBjb25zdCBhc2tNb2RhbCA9IG5ldyBBc2tNb2RhbCh7XG4gICAgICAgIGhlYWRpbmc6ICdBcmUgWW91IFN1cmUgWW91IFdhbnQgVG8gRXhpdCBGaW5hbmNpbmcgQXBwPycsXG4gICAgICAgIHN1YmhlYWRpbmc6ICdZb3Ugd2lsbCBsb3NlIGFsbCB0aGUgcHJvZ3Jlc3MuIEtlZXAgZmlsbGluZyBvdXQgdGhlIGZvcm0gYW5kIGdldCBhcHByb3ZlZCBhcyBzb29uIGFzIHBvc3NpYmxlIScsXG4gICAgICAgIGV4aXRUZXh0OiAnRXhpdCcsXG4gICAgICAgIGtlZXBUZXh0OiAnS2VlcCBGaWxsaW5nJyxcbiAgICAgICAgZXhpdENhbGxiYWNrOiBoaWRlTG9hbixcbiAgICAgIH0pXG4gICAgICBhc2tNb2RhbC5zaG93KClcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvd0xvYW4oKVxuICAgIH1cbiAgfVxuICB0YWJQcmVzcygpIHtcbiAgICBpZiAoIXRoaXMuc2xpZGluZykge1xuICAgICAgY29uc3QgYWN0aXZlSW5wdXQgPSB0aGlzLmdldEFjdGl2ZUlucHV0XG4gICAgICBpZiAoIWFjdGl2ZUlucHV0KSB7XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLmdldEFjdGl2ZVNlY3Rpb25cbiAgICAgICAgY29uc3QgaW5wdXRBcnJheSA9IFsuLi5zZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Om5vdCguLS1kaXNhYmxlZCksIHNlbGVjdDpub3QoLi0tZGlzYWJsZWQpJyldXG4gICAgICAgIGlmIChpbnB1dEFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGxldCBpbnB1dFRvRm9jdXNcbiAgICAgICAgICBjb25zdCBpbnZhbGlkSW5wdXRzID0gaW5wdXRBcnJheS5maWx0ZXIoaW5wdXQgPT4gaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKCctLWludmFsaWQnKSlcbiAgICAgICAgICBpZiAoaW52YWxpZElucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlucHV0VG9Gb2N1cyA9IGludmFsaWRJbnB1dHNbMF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZW1wdHlJbnB1dHMgPSBpbnB1dEFycmF5LmZpbHRlcihpbnB1dCA9PiAhaW5wdXQudmFsdWUgJiYgaW5wdXQudmFsdWUgIT09IDApXG4gICAgICAgICAgICBpZiAoZW1wdHlJbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlucHV0VG9Gb2N1cyA9IGVtcHR5SW5wdXRzWzBdXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnB1dFRvRm9jdXMgPSBpbnB1dEFycmF5WzBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0VG9Gb2N1cy5mb2N1cygpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUlucHV0V3JhcCA9IGFjdGl2ZUlucHV0LnBhcmVudE5vZGUuY2xvc2VzdCgnLmxvYW4taW5wdXQtd3JhcCcpXG4gICAgICAgIGNvbnN0IG5leHRJbnB1dFdyYXAgPSBhY3RpdmVJbnB1dFdyYXAubmV4dEVsZW1lbnRTaWJsaW5nXG4gICAgICAgIGlmIChuZXh0SW5wdXRXcmFwKSB7XG4gICAgICAgICAgY29uc3QgbmV4dElucHV0ID0gbmV4dElucHV0V3JhcC5xdWVyeVNlbGVjdG9yKCdpbnB1dCwgc2VsZWN0JylcbiAgICAgICAgICBpZiAobmV4dElucHV0KSB7XG4gICAgICAgICAgICBuZXh0SW5wdXQuZm9jdXMoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmaXJzdElucHV0V3JhcCA9IHRoaXMuZ2V0QWN0aXZlU2VjdGlvbi5xdWVyeVNlbGVjdG9yKCcubG9hbi1pbnB1dC13cmFwJylcbiAgICAgICAgICBjb25zdCBmaXJzdElucHV0ID0gZmlyc3RJbnB1dFdyYXAucXVlcnlTZWxlY3RvcignaW5wdXQsIHNlbGVjdCcpXG4gICAgICAgICAgaWYgKGZpcnN0SW5wdXQpIHtcbiAgICAgICAgICAgIGZpcnN0SW5wdXQuZm9jdXMoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIEV2ZW50c1xuICAgKi9cbiAgYmluZFN0ZXBFdnQoKSB7XG4gICAgdGhpcy5ldnRHby5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5nZXRBY3RpdmVTZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRlKHNlY3Rpb24pKSB0aGlzLmdvKClcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLmV2dEJhY2suZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuYmFjaygpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5ldnRTdWJtaXQuZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdGhpcy5ldnRHb1swXS5jbGljaygpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5ldnRUb2dnbGUuZm9yRWFjaCgoYnRuKSA9PiB7XG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICB0aGlzLnRvZ2dsZSgpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgfVxuICBiaW5kSW5wdXRFdmVudHMoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gWy4uLnRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JyldXG4gICAgY29uc3Qgc2VsZWN0cyA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKV1cbiAgICBjb25zdCBub1dlYnNpdGVDaGVja2JveCA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJyNsb2FuX2VtcGxveWVyX3dlYnNpdGUnKVxuICAgIGNvbnN0IGlucHV0V2Vic2l0ZUVtcGxveWVyID0gdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcignI2xvYW5fZW1wbG95ZXJfd2Vic2l0ZScpXG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IGlzVGFiID0gZS5rZXkgPT09ICdUYWInXG4gICAgICBpZiAoaXNUYWIpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmNvbnRhaW5zKCdsb2FuX2Nhc2UnKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgIHRoaXMudGFiUHJlc3MoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYXJFcnJvcnMoKVxuICAgICAgICBjb25zdCBwYXJlbnQgPSBpbnB1dC5wYXJlbnROb2RlLmNsb3Nlc3QoJy5sb2FuLWlucHV0LXdyYXAnKVxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50LmNsYXNzTGlzdC5hZGQoJy0tZm9jdXNlZCcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBpbnB1dC5wYXJlbnROb2RlLmNsb3Nlc3QoJy5sb2FuLWlucHV0LXdyYXAnKVxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50LmNsYXNzTGlzdC5yZW1vdmUoJy0tZm9jdXNlZCcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckVycm9ycygpXG4gICAgICAgIGNvbnN0IGlzRW50ZXIgPSBlLmtleSA9PT0gJ0VudGVyJ1xuICAgICAgICBjb25zdCBpc1RhYiA9IGUua2V5ID09PSAnVGFiJ1xuICAgICAgICBpZiAoaXNFbnRlcikge1xuICAgICAgICAgIHRoaXMuZXZ0R29bMF0uY2xpY2soKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gICAgc2VsZWN0cy5mb3JFYWNoKChzZWxlY3QpID0+IHtcbiAgICAgIHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYXJFcnJvcnMoKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG4gIGJpbmRTU05JbnB1dCgpIHtcbiAgICBjb25zdCBpbnB1dHMgPSB0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtkYXRhLWZvcm1hdD1cInNzblwiXScpXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlLnRhcmdldC52YWx1ZVxuICAgICAgICBsZXQgbmV3VmFsdWUgPSAnJ1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hhciA9IHZhbHVlLmNoYXJBdChpKVxuICAgICAgICAgIGlmIChjaGFyLm1hdGNoKC9eWzAtOV0kLykgJiYgbmV3VmFsdWUubGVuZ3RoIDwgOSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgKz0gY2hhclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlLnRhcmdldC52YWx1ZSA9IG5ld1ZhbHVlXG4gICAgICB9KVxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZS50YXJnZXQudmFsdWVcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgbGV0IG5ld1ZhbHVlID0gdmFsdWUucmVwbGFjZSgvKFteMC05XSkvZywgJycpXG4gICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5zbGljZSgwLCAzKSArICfigJQnICsgbmV3VmFsdWUuc2xpY2UoMywgNSkgKyAn4oCUJyArIG5ld1ZhbHVlLnNsaWNlKDUpXG4gICAgICAgICAgZS50YXJnZXQudmFsdWUgPSBuZXdWYWx1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoZSkgPT4ge1xuICAgICAgICBlLnRhcmdldC52YWx1ZSA9IGUudGFyZ2V0LnZhbHVlLnJlcGxhY2UoLyhbXjAtOV0pL2csICcnKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZE51bWJlcklucHV0KCkge1xuICAgIGNvbnN0IGlucHV0cyA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W2RhdGEtdmFsaWRhdGU9XCJudW1iZXJcIl0nKVxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBsZXQga2V5Q29kZTtcbiAgICAgIGZ1bmN0aW9uIG1hc2soZXZlbnQpIHtcbiAgICAgICAgZXZlbnQua2V5Q29kZSAmJiAoa2V5Q29kZSA9IGV2ZW50LmtleUNvZGUpO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgaWYgKHBvcyA8IDMpIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgbGV0IG1hdHJpeCA9IFwiKzEgKF9fXykgX19fLV9fX19cIixcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBkZWYgPSBtYXRyaXgucmVwbGFjZSgvXFxEL2csIFwiXCIpLFxuICAgICAgICAgIHZhbCA9IHRoaXMudmFsdWUucmVwbGFjZSgvXFxEL2csIFwiXCIpLFxuICAgICAgICAgIG5ld1ZhbHVlID0gbWF0cml4LnJlcGxhY2UoL1tfXFxkXS9nLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgPCB2YWwubGVuZ3RoID8gdmFsLmNoYXJBdChpKyspIHx8IGRlZi5jaGFyQXQoaSkgOiBhO1xuICAgICAgICAgIH0pO1xuICAgICAgICBpID0gbmV3VmFsdWUuaW5kZXhPZihcIl9cIik7XG4gICAgICAgIGlmIChpICE9IC0xKSB7XG4gICAgICAgICAgaSA8IDUgJiYgKGkgPSAzKTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnNsaWNlKDAsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWcgPSBtYXRyaXguc3Vic3RyKDAsIHRoaXMudmFsdWUubGVuZ3RoKS5yZXBsYWNlKC9fKy9nLFxuICAgICAgICAgIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcZHsxLFwiICsgYS5sZW5ndGggKyBcIn1cIjtcbiAgICAgICAgICB9KS5yZXBsYWNlKC9bKygpXS9nLCBcIlxcXFwkJlwiKTtcbiAgICAgICAgcmVnID0gbmV3IFJlZ0V4cChcIl5cIiArIHJlZyArIFwiJFwiKTtcbiAgICAgICAgaWYgKCFyZWcudGVzdCh0aGlzLnZhbHVlKSB8fCB0aGlzLnZhbHVlLmxlbmd0aCA8IDUgfHwga2V5Q29kZSA+IDQ3ICYmIGtleUNvZGUgPCA1OCkgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PSBcImJsdXJcIiAmJiB0aGlzLnZhbHVlLmxlbmd0aCA8IDUpIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgfVxuXG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgbWFzaywgZmFsc2UpO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIG1hc2ssIGZhbHNlKTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIG1hc2ssIGZhbHNlKTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG1hc2ssIGZhbHNlKTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgaWYgKGlucHV0LnZhbHVlLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSg0LCA0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKGlucHV0LnZhbHVlLmxlbmd0aCwgaW5wdXQudmFsdWUubGVuZ3RoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBiaW5kSURVcGxvYWQoKSB7XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbG9hbl9pZCcpXG4gICAgY29uc3QgYm94ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtbG9hbj1cImZpbGVzX3VwbG9hZFwiXScpXG4gICAgY29uc3QgaG9sZGVyID0gdGhpcy5maWxlc0hvbGRlclxuICAgIC8vIGlmICghaW5wdXQgfHwgIWJveCB8fCAhaG9sZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ0pTIDogQmluZCBJRCBVcGxvYWQgOiBJbnB1dCBvciBCb3ggb3IgSG9sZGVyIG5vdCBmb3VuZCcpXG5cbiAgICBpZiAoaW5wdXQgJiYgYm94ICYmIGhvbGRlcikge1xuICAgICAgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVzKGZpbGVzKSB7XG4gICAgICAgIGlmICghZmlsZXMpIHRocm93IG5ldyBFcnJvcignTm8gZmlsZXMgc2VsZWN0ZWQnKVxuICAgICAgICBmaWxlcyA9IFsuLi5maWxlc11cbiAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHJldHVyblxuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICBpZiAoIWZpbGUudHlwZS5tYXRjaCgnaW1hZ2UuKicpKSBjb250aW51ZVxuICAgICAgICAgIGNvbnN0IGltYWdlcyA9IGhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKVxuICAgICAgICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgaW1hZ2VzKSB7XG4gICAgICAgICAgICBpbWFnZS5yZW1vdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgICAgICAgYXBwZW5kSW1hZ2UoZS50YXJnZXQucmVzdWx0KVxuICAgICAgICAgIH1cbiAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFwcGVuZEltYWdlKGltZ1VSTCkge1xuICAgICAgICBjb25zdCBpbWcgPSBjcmVhdGVFbGVtKCdpbWcnLCB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogYHVybCgke2ltZ1VSTH0pYFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgIGhvbGRlci5hcHBlbmQoaW1nKVxuICAgICAgfVxuXG4gICAgICBib3gub25jbGljayA9ICgpID0+IHsgaW5wdXQuY2xpY2soKSB9XG4gICAgICBpbnB1dC5vbmNoYW5nZSA9IChlKSA9PiB7XG4gICAgICAgIHByb2Nlc3NGaWxlcyhlLnRhcmdldC5maWxlcylcbiAgICAgICAgLy8gaW5wdXQudmFsdWUgPSAnJ1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkanVzdEFjdGl2ZVNlY3Rpb25IZWlnaHQoKVxuICAgICAgICB9LCAxMCk7XG4gICAgICB9XG4gICAgICBib3gub25kcmFnb3ZlciA9IChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBib3guY2xhc3NMaXN0LmFkZChJU19BQ1RJVkUpXG4gICAgICB9XG4gICAgICBib3gub25kcmFnbGVhdmUgPSAoZSkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgYm94LmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKVxuICAgICAgfVxuICAgICAgYm94Lm9uZHJvcCA9IChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBib3guY2xhc3NMaXN0LnJlbW92ZShJU19BQ1RJVkUpXG4gICAgICAgIHByb2Nlc3NGaWxlcyhlLmRhdGFUcmFuc2Zlci5maWxlcylcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmluZER1YWxTZWxlY3QoKSB7XG4gICAgY29uc3QgZHVhbEFyciA9IHRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWxvYW4tZXZ0PVwiZHVhbF9zZWxlY3RcIl0nKVxuICAgIGZvciAoY29uc3QgZHVhbCBvZiBkdWFsQXJyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGR1YWwucXVlcnlTZWxlY3RvcignaW5wdXQ6bm90KFt0eXBlPVwiY2hlY2tib3hcIl0pJylcbiAgICAgIGNvbnN0IGNoZWNrYm94ID0gZHVhbC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKVxuICAgICAgaWYgKGlucHV0ICYmIGNoZWNrYm94KSB7XG4gICAgICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgIGxldCBpc0NoZWNrZWQgPSBjaGVja2JveC5jaGVja2VkXG4gICAgICAgICAgaWYgKGlzQ2hlY2tlZCkge1xuICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnLS1kaXNhYmxlZCcpXG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJylcbiAgICAgICAgICAgIGlmIChpbnB1dC50eXBlICE9PSAncmFuZ2UnKSB7XG4gICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpXG4gICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCctLWRpc2FibGVkJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByYW5nZU91dHB1dEFyciA9IFsuLi50aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yQWxsKCcuY3VzdG9tLXJhbmdlX19vdXRwdXQnKV1cbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIHJhbmdlT3V0cHV0QXJyKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBpbnB1dC5jbG9zZXN0KCdbZGF0YS1sb2FuLWV2dD1cImR1YWxfc2VsZWN0XCJdJylcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgY29uc3QgcmFuZ2VJbnB1dCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwicmFuZ2VcIl0nKVxuICAgICAgICBpZiAocmFuZ2VJbnB1dCkge1xuICAgICAgICAgIGNvbnN0IG1heFZhbHVlID0gcmFuZ2VJbnB1dC5tYXhcbiAgICAgICAgICBjb25zdCBtaW5WYWx1ZSA9IHJhbmdlSW5wdXQubWluXG5cbiAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG4gICAgICAgICAgICBlLnRhcmdldC52YWx1ZSA9IGUudGFyZ2V0LnZhbHVlLnJlcGxhY2UoL1teMC05XS9nLCAnJylcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIChlKSA9PiB7XG4gICAgICAgICAgICBlLnRhcmdldC52YWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKGUudGFyZ2V0LnZhbHVlLCBtYXhWYWx1ZSksIG1pblZhbHVlKVxuICAgICAgICAgICAgcmFuZ2VJbnB1dC52YWx1ZSA9IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICByYW5nZUlucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmluZEZvcm1hdHRpbmcoKSB7XG4gICAgY29uc3QgY3VycmVuY3lBcnIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mb3JtYXQ9XCJjdXJyZW5jeVwiXScpXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBjdXJyZW5jeUFycikge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gaW5wdXQudmFsdWVcbiAgICAgICAgaWYgKHZhbC5sZW5ndGgpIHtcbiAgICAgICAgICBpbnB1dC52YWx1ZSA9IGZvcm1hdEFzQ3VycmVuY3kodmFsKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsXG4gICAqL1xuICBzZXRJbml0aWFsVmFyKCkge1xuICAgIHRoaXMuc3RlcHMgPSB0aGlzLnNlY3Rpb25zLmxlbmd0aFxuICAgIGlmICghdGhpcy5zdGVwcykgdGhyb3cgbmV3IEVycm9yKCdObyBMb2FuIFNlY3Rpb25zIEZvdW5kJylcbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gMFxuICAgIHRoaXMuc3RlcHNMZWZ0ID0gdGhpcy5zdGVwc1xuICAgIHRoaXMuZW5kUmVhY2hlZCA9IGZhbHNlXG4gICAgdGhpcy5hdFRoZVN0YXJ0ID0gdHJ1ZVxuICB9XG4gIHNldEluaXRpYWxMYXlvdXQoKSB7XG4gICAgY29uc3QgZmlyc3RTZWN0aW9uID0gdGhpcy5zZWN0aW9uc1swXVxuICAgIGNvbnN0IGhlaWdodCA9IGZpcnN0U2VjdGlvbi5zY3JvbGxIZWlnaHRcbiAgICB0aGlzLmNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YFxuICAgIHRoaXMuY29udGVudC5zdHlsZS50cmFuc2l0aW9uID0gYGFsbCAke3RoaXMuc2V0dGluZ3Muc2Nyb2xsU3BlZWR9bXMgJHt0aGlzLnNldHRpbmdzLmVhc2luZ31gXG4gICAgdGhpcy5zY3JvbGxlci5zdHlsZS50cmFuc2l0aW9uID0gYGFsbCAke3RoaXMuc2V0dGluZ3Muc2Nyb2xsU3BlZWR9bXMgJHt0aGlzLnNldHRpbmdzLmVhc2luZ31gXG4gICAgLy8gdGhpcy5zZWN0aW9ucy5mb3JFYWNoKHNlY3Rpb24gPT4gc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnKVxuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5zZXRJbml0aWFsTGF5b3V0KClcbiAgICB0aGlzLnNldEluaXRpYWxWYXIoKVxuICAgIHRoaXMuYmluZFN0ZXBFdnQoKVxuICAgIHRoaXMuYmluZElucHV0RXZlbnRzKClcbiAgICB0aGlzLmJpbmROdW1iZXJJbnB1dCgpXG4gICAgdGhpcy5iaW5kU1NOSW5wdXQoKVxuICAgIHRoaXMuYmluZElEVXBsb2FkKClcbiAgICB0aGlzLmJpbmREdWFsU2VsZWN0KClcbiAgICB0aGlzLmJpbmRGb3JtYXR0aW5nKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExvYW5BcHAiLCJjb25zdCBsb2NhdGlvblBhZ2UgPSBuZXcgT2JqZWN0KHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5hdHRhY2hFdmVudHMpLmZvckVhY2goKGZuKSA9PiB7XG4gICAgICBpZiAoZm4gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJykgZm4oKTtcbiAgICB9KVxuICB9LFxuICBhdHRhY2hFdmVudHM6IHtcbiAgICB0b2dnbGVTdG9yZXNWaXNpYmlsaXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgaGVhZEFyciA9IFsuLi4kKCcuc3RvcmUtcm93X19oZWFkJyldXG4gICAgICAkLmVhY2goaGVhZEFyciwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgJChoZWFkQXJyW2ldKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbGV0IHJvd3MgPSAkKCcuc3RvcmUtcm93JyksXG4gICAgICAgICAgICB0aGlzUm93ID0gJCh0aGlzKS5jbG9zZXN0KHJvd3MpXG4gICAgICAgICAgaWYgKGVsZW1EaXNwbGF5ZWQodGhpc1Jvdy5maW5kKCcuc3RvcmUtcm93X19ib2R5JykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm93cy5maW5kKCcuc3RvcmUtcm93X19ib2R5Jykuc2hvdygpXG4gICAgICAgICAgICByb3dzLm5vdCh0aGlzUm93KS5maW5kKCcuc3RvcmUtcm93X19ib2R5JykuaGlkZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gbG9jYXRpb25QYWdlIiwiY2xhc3MgTG9vc2VEaWFtb25kcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWFpbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sb29zZV9kaWFtb25kcycpXG4gICAgdGhpcy5yZXN1bHRzQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxvb3NlX19yZXN1bHRzJylcbiAgICB0aGlzLnZpZXdCdG5BcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxvb3NlX192aWV3LWJ0bicpXVxuICAgIHRoaXMubG9vc2VTZWxlY3RBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxvb3NlLXNlbGVjdCcpXVxuICAgIHRoaXMuZG1CdG5BcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRtLWZpbHRlci1idG4nKV1cbiAgICB0aGlzLnNvcnRNb2RhbEFjdGl2ZSA9IGZhbHNlXG4gICAgaWYgKHRoaXMubWFpbikge1xuICAgICAgdGhpcy5pbml0KClcbiAgICB9XG4gIH1cblxuICAvLyBNZXRob2RzXG4gIGxpc3RWaWV3KCkge1xuICAgIHRoaXMubWFpbi5jbGFzc0xpc3QuYWRkKCctLWxpc3QnKVxuICB9XG4gIGdyaWRWaWV3KCkge1xuICAgIHRoaXMubWFpbi5jbGFzc0xpc3QucmVtb3ZlKCctLWxpc3QnKVxuICB9XG4gIG9ic2VydmVGaWx0ZXJzKCkge1xuICAgIGZvciAoY29uc3Qgc2VsZWN0IG9mIHRoaXMubG9vc2VTZWxlY3RBcnIpIHtcbiAgICAgIGNvbnN0IGJ0bkFyciA9IFsuLi5zZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnLmxvb3NlLWZpbHRlci1idG4nKV1cbiAgICAgIGNvbnN0IGlucHV0QXJyID0gWy4uLnNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwidGV4dFwiXScpXVxuXG4gICAgICBjb25zdCBzb21lSXNDaGVja2VkID0gYnRuQXJyLnNvbWUoZWwgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKF9fQUNUSVZFKSlcbiAgICAgIGNvbnN0IHNvbWVJc1ZhbHVlID0gaW5wdXRBcnIuc29tZShlbCA9PiBlbC52YWx1ZS5sZW5ndGggPiAwKVxuXG4gICAgICBpZiAoc29tZUlzQ2hlY2tlZCB8fCBzb21lSXNWYWx1ZSkge1xuICAgICAgICBzZWxlY3QuY2xhc3NMaXN0LmFkZChfX1NFTEVDVEVEKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0LmNsYXNzTGlzdC5yZW1vdmUoX19TRUxFQ1RFRClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzZXRGaWx0ZXJzKCkge1xuICAgIGZvciAoY29uc3Qgc2VsZWN0IG9mIHRoaXMubG9vc2VTZWxlY3RBcnIpIHtcbiAgICAgIGNvbnN0IGJ0bkFyciA9IFsuLi5zZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnLmxvb3NlLWZpbHRlci1idG4nKV1cbiAgICAgIGNvbnN0IGlucHV0QXJyID0gWy4uLnNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwidGV4dFwiXScpXVxuXG4gICAgICBidG5BcnIuZm9yRWFjaChlbCA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKSlcbiAgICAgIGlucHV0QXJyLmZvckVhY2goZWwgPT4gZWwudmFsdWUgPSAnJylcblxuICAgICAgc2VsZWN0LmNsYXNzTGlzdC5yZW1vdmUoX19TRUxFQ1RFRClcbiAgICB9XG4gIH1cbiAgb3BlblNvcnRNb2RhbCgpIHtcbiAgICBjb25zdCBzb3J0TW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc29ydC1tb2RhbCcpXG4gICAgY29uc3QgY2xvc2VDYWxsYmFjayA9ICgpID0+IHsgdGhpcy5jbG9zZVNvcnRNb2RhbCh0cnVlKSB9XG4gICAgaWYgKHNvcnRNb2RhbCkge1xuICAgICAgd2luZG93Lmxvb3NlU29ydEJhY2tkcm9wID0gbmV3IEJhY2tkcm9wKHtcbiAgICAgICAgaGFsZjogdHJ1ZSxcbiAgICAgICAgY2FsbGJhY2s6IGNsb3NlQ2FsbGJhY2tcbiAgICAgIH0pXG4gICAgICBsb2NrU2Nyb2xsKClcbiAgICAgIHNvcnRNb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNvcnRNb2RhbC5jbGFzc0xpc3QuYWRkKF9fQUNUSVZFKVxuICAgICAgfSwgNSk7XG4gICAgfVxuICB9XG4gIGNsb3NlU29ydE1vZGFsKGNvbmQgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNvcnRNb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zb3J0LW1vZGFsJylcbiAgICBpZiAoc29ydE1vZGFsKSB7XG4gICAgICB1bmxvY2tTY3JvbGwoKVxuICAgICAgc29ydE1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc29ydE1vZGFsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgIH0sIGdldFRyYW5zaXRpb25UaW1lKHNvcnRNb2RhbCkpO1xuICAgICAgaWYgKCFjb25kKSB7XG4gICAgICAgIGNvbnN0IGJhY2tkcm9wID0gd2luZG93Lmxvb3NlU29ydEJhY2tkcm9wXG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIGJhY2tkcm9wLmhpZGUoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvd0FyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc29ydC1tb2RhbC1yb3cnKV1cbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd0Fycikge1xuICAgICAgICByb3cucXVlcnlTZWxlY3RvcignLnNvcnQtbW9kYWwtcm93X19ib2R5Jykuc3R5bGUuaGVpZ2h0ID0gMFxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhcHBseUZpbHRlcnMoKSB7XG4gICAgdGhpcy5jbG9zZVNvcnRNb2RhbCgpXG4gIH1cbiAgaGlkZUFkbWluKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXQuY2xvc2VzdCgnLmRtLWl0ZW0nKVxuICAgICAgY29uc3QgYWRtaW5CYXIgPSBpdGVtLnF1ZXJ5U2VsZWN0b3IoJy5kbS1pdGVtX19hZG1pbicpXG4gICAgICBpZiAoYWRtaW5CYXIpIHtcbiAgICAgICAgYWRtaW5CYXIuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJpbmQgRXZlbnRzXG4gIGJpbmRMb29zZVNlbGVjdHMoKSB7XG4gICAgZm9yIChjb25zdCBzZWxlY3Qgb2YgdGhpcy5sb29zZVNlbGVjdEFycikge1xuICAgICAgY29uc3QgYnRuID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJy5sb29zZS1zZWxlY3RfX2J0bicpXG4gICAgICBjb25zdCBkcm9wID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJy5sb29zZS1zZWxlY3RfX2Ryb3AnKVxuICAgICAgaWYgKGJ0biAmJiBkcm9wKSB7XG4gICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICBpZiAoc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucyhfX0FDVElWRSkpIHtcbiAgICAgICAgICAgIHNlbGVjdC5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvb3NlU2VsZWN0QXJyLmZvckVhY2goZWwgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShfX0FDVElWRSkpXG4gICAgICAgICAgICBzZWxlY3QuY2xhc3NMaXN0LmFkZChfX0FDVElWRSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmxvb3NlU2VsZWN0QXJyLnNvbWUoZWwgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKF9fQUNUSVZFKSkpIHtcbiAgICAgICAgdGhpcy5sb29zZVNlbGVjdEFyci5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoX19BQ1RJVkUpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldFxuICAgICAgaWYgKCF0YXJnZXQuY2xvc2VzdCgnLmxvb3NlLXNlbGVjdCcpKSB7XG4gICAgICAgIHRoaXMubG9vc2VTZWxlY3RBcnIuZm9yRWFjaChlbCA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGJpbmRGaWx0ZXJCdG5Hcm91cCgpIHtcbiAgICBjb25zdCBncm91cEFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1maWx0ZXItZ3JvdXBdJyldXG4gICAgZm9yIChjb25zdCBncm91cCBvZiBncm91cEFycikge1xuICAgICAgY29uc3QgYnRuQXJyID0gWy4uLmdyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoJy5sb29zZS1maWx0ZXItYnRuJyldXG4gICAgICBmb3IgKGNvbnN0IGJ0biBvZiBidG5BcnIpIHtcbiAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgIGJ0bi5jbGFzc0xpc3QudG9nZ2xlKF9fQUNUSVZFKVxuICAgICAgICAgIHRoaXMub2JzZXJ2ZUZpbHRlcnMoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3Qgc2VsZWN0IG9mIHRoaXMubG9vc2VTZWxlY3RBcnIpIHtcbiAgICAgIGNvbnN0IGlucHV0QXJyID0gWy4uLnNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwidGV4dFwiXScpXVxuICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dEFycikge1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVGaWx0ZXJzKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmluZERtU2VsZWN0Q2xpY2soKSB7XG4gICAgY29uc3QgZmFkZSA9IChleGNlcHQgPSB1bmRlZmluZWQpID0+IHtcbiAgICAgIHRoaXMuZG1CdG5BcnIuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGlmIChlbCAhPT0gZXhjZXB0ICYmICFlbC5jbGFzc0xpc3QuY29udGFpbnMoX19BQ1RJVkUpKSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChfX0ZBREUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRtQnRuQXJyLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKF9fRkFERSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBidG4gb2YgdGhpcy5kbUJ0bkFycikge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBzb21lRmFkZWQgPSB0aGlzLmRtQnRuQXJyLnNvbWUoZWwgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKF9fRkFERSkpXG4gICAgICAgIGNvbnN0IHRhcmdldEFjdGl2ZSA9IGJ0bi5jbGFzc0xpc3QuY29udGFpbnMoX19BQ1RJVkUpXG4gICAgICAgIGNvbnN0IHRhcmdldEZhZGVkID0gYnRuLmNsYXNzTGlzdC5jb250YWlucyhfX0ZBREUpXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGJ0blxuXG4gICAgICAgIGlmICh0YXJnZXRBY3RpdmUpIHtcbiAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShfX0FDVElWRSlcbiAgICAgICAgICBpZiAodGhpcy5kbUJ0bkFyci5zb21lKGVsID0+IGVsLmNsYXNzTGlzdC5jb250YWlucyhfX0FDVElWRSkpKSB7XG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChfX0ZBREUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoX19BQ1RJVkUpXG4gICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoX19GQURFKVxuICAgICAgICAgIGZhZGUodGFyZ2V0KVxuICAgICAgICB9XG5cbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGJpbmRTb3J0TW9kYWxFdmVudHMoKSB7XG4gICAgY29uc3QgbW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc29ydC1tb2RhbCcpXG4gICAgaWYgKG1vZGFsKSB7XG4gICAgICBjb25zdCByb3dBcnIgPSBbLi4ubW9kYWwucXVlcnlTZWxlY3RvckFsbCgnLnNvcnQtbW9kYWwtcm93JyldXG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dBcnIpIHtcbiAgICAgICAgY29uc3QgaGVhZCA9IHJvdy5xdWVyeVNlbGVjdG9yKCcuc29ydC1tb2RhbC1yb3dfX2hlYWQnKVxuICAgICAgICBjb25zdCBib2R5ID0gcm93LnF1ZXJ5U2VsZWN0b3IoJy5zb3J0LW1vZGFsLXJvd19fYm9keScpXG5cbiAgICAgICAgaWYgKGhlYWQgJiYgYm9keSkge1xuICAgICAgICAgIGhlYWQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYm9keS5jbGllbnRIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgIHJvdy5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgICAgICAgICAgICBib2R5LnN0eWxlLmhlaWdodCA9IDBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJvd0Fyci5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHIgIT09IHJvdykge1xuICAgICAgICAgICAgICAgICAgci5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgICAgICAgICAgICAgICAgci5xdWVyeVNlbGVjdG9yKCcuc29ydC1tb2RhbC1yb3dfX2JvZHknKS5zdHlsZS5oZWlnaHQgPSAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByb3cuY2xhc3NMaXN0LmFkZChfX0FDVElWRSlcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGJvZHkucXVlcnlTZWxlY3RvcignLnNvcnQtbW9kYWwtcm93X19jb250ZW50JylcbiAgICAgICAgICAgICAgYm9keS5zdHlsZS5oZWlnaHQgPSBgJHtjb250ZW50LnNjcm9sbEhlaWdodCArIDF9cHhgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5iaW5kTG9vc2VTZWxlY3RzKClcbiAgICB0aGlzLmJpbmRGaWx0ZXJCdG5Hcm91cCgpXG4gICAgdGhpcy5iaW5kRG1TZWxlY3RDbGljaygpXG4gICAgdGhpcy5vYnNlcnZlRmlsdGVycygpXG4gICAgdGhpcy5iaW5kU29ydE1vZGFsRXZlbnRzKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExvb3NlRGlhbW9uZHMiLCJjb25zdCBteUJhZyA9IG5ldyBPYmplY3Qoe1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLmF0dGFjaEV2ZW50cykuZm9yRWFjaCgoZm4pID0+IHtcbiAgICAgIGlmIChmbiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nKSBmbigpO1xuICAgIH0pXG4gIH0sXG4gIGF0dGFjaEV2ZW50czoge1xuICAgIGZvcm1hdFN1bW1hcnlQcmljZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgbGluZXMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnN1bW1hcnktcHJpY2UnKV1cbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICBjb25zdCBzcGFuID0gbGluZS5xdWVyeVNlbGVjdG9yKCdzcGFuOmxhc3QtY2hpbGQnKVxuICAgICAgICBpZiAoc3Bhbikge1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBzcGFuLmlubmVyVGV4dFxuICAgICAgICAgIGxldCBudW0gPSBOdW1iZXIodGV4dC5yZXBsYWNlKC9bXjAtOS4tXS9nLCAnJykpXG4gICAgICAgICAgaWYgKG51bSAhPT0gMCkge1xuICAgICAgICAgICAgbnVtID0gbnVtLnRvRml4ZWQoMilcbiAgICAgICAgICAgIG51bSA9IG51bS50b1N0cmluZygpLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiLFwiKTtcbiAgICAgICAgICAgIHNwYW4uaW5uZXJUZXh0ID0gYCQgJHtudW19YFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2V0U2FsZVBlcmNlbnRWYWx1ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGNhcmRzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5teWJhZy1jYXJkJyldXG4gICAgICBmb3IgKGNvbnN0IGNhcmQgb2YgY2FyZHMpIHtcbiAgICAgICAgY29uc3QgbmV3UHJpY2UgPSBjYXJkLnF1ZXJ5U2VsZWN0b3IoJy5jYXJkLXByaWNlX25ldycpXG4gICAgICAgIGNvbnN0IG9sZFByaWNlID0gY2FyZC5xdWVyeVNlbGVjdG9yKCcuY2FyZC1wcmljZV9vbGQnKVxuICAgICAgICBjb25zdCBzYWxlRWxlbSA9IGNhcmQucXVlcnlTZWxlY3RvcignLm15YmFnLWNhcmQtc2FsZScpXG4gICAgICAgIGlmIChuZXdQcmljZSAmJiBvbGRQcmljZSAmJiBzYWxlRWxlbSkge1xuICAgICAgICAgIGNvbnN0IG5ld1ByaWNlTnVtID0gTnVtYmVyKG5ld1ByaWNlLmlubmVyVGV4dC5yZXBsYWNlKC9bXjAtOV0vZywgJycpKVxuICAgICAgICAgIGNvbnN0IG9sZFByaWNlTnVtID0gTnVtYmVyKG9sZFByaWNlLmlubmVyVGV4dC5yZXBsYWNlKC9bXjAtOV0vZywgJycpKVxuICAgICAgICAgIGxldCBzYWxlID0gKChvbGRQcmljZU51bSAtIG5ld1ByaWNlTnVtKSAvIG9sZFByaWNlTnVtKSAqIDEwMFxuICAgICAgICAgIHNhbGUgPSBNYXRoLnJvdW5kKHNhbGUgLyAxMCkgKiAxMDtcbiAgICAgICAgICBpZiAoc2FsZSAlIDEwID49IDUpIHtcbiAgICAgICAgICAgIHNhbGUgPSBNYXRoLmNlaWwoc2FsZSAvIDEwKSAqIDEwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzYWxlID0gTWF0aC5mbG9vcihzYWxlIC8gMTApICogMTA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhbGVFbGVtLmlubmVyVGV4dCA9IGAke3NhbGV9JSBPRkZgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNldENhcGl0YWxpemVDaGVja291dEJ0bjogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgYnRuQXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jaGVja291dF9fbWFpbi1idG4nKV1cbiAgICAgIGZvciAoY29uc3QgYnRuIG9mIGJ0bkFycikge1xuICAgICAgICBjb25zdCB0ZXh0ID0gYnRuLmlubmVyVGV4dC5zcGxpdCgnICcpLnJlZHVjZSgoYWNjLCBlbCkgPT4ge1xuICAgICAgICAgIGFjYy5wdXNoKGVsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZWwuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgIH0sIFtdKVxuICAgICAgICBidG4uaW5uZXJUZXh0ID0gdGV4dC5qb2luKCcgJylcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBteUJhZyIsImNvbnN0IHBhc3NSZXNldCA9IHtcbiAgSVNfRU1QVFk6ICdpcy1lbXB0eScsXG4gIElTX0RJU0FCTEVEOiAnaXMtZGlzYWJsZWQnLFxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCQoJy5wYXNzLXJlc2V0LXBhZ2UnKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVuZGVyRE9NKClcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpXG4gICAgfVxuICB9LFxuICByZW5kZXJET006IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZvcm0gPSAkKCcjcGFzc1Jlc2V0Rm9ybScpXG4gICAgdGhpcy5zdWJtaXRCdG4gPSAkKCcjcGFzc1Jlc2V0U3VibWl0JylcbiAgICB0aGlzLmlucHV0QXJyID0gWy4uLnRoaXMuZm9ybS5maW5kKCdpbnB1dFt0eXBlPVwicGFzc3dvcmRcIl0nKV1cbiAgICB0aGlzLmVycm9yID0gJCgnLnBhc3MtcmVzZXQtZXJyb3InKVxuICAgIHRoaXMubG9hZGVyID0gJCgnLnBhc3MtcmVzZXQtbG9hZGVyJylcbiAgICB0aGlzLm1haW4gPSAkKCcucGFzcy1yZXNldF9fbWFpbicpXG4gICAgdGhpcy5yZXN1bHQgPSAkKCcucGFzcy1yZXNldF9fcmVzdWx0JylcbiAgfSxcbiAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgIC8vIHN1Ym1pdCBjbGlja1xuICAgICQuZWFjaCh0aGlzLnN1Ym1pdEJ0biwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHBhc3NSZXNldC5zdWJtaXRCdG5baV0ub25jbGljayA9IChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBwYXNzUmVzZXQuZm9ybS5zdWJtaXQoKVxuICAgICAgfVxuICAgIH0pXG4gICAgLy8gaW5wdXQgZXZlbnRzXG4gICAgJC5lYWNoKHRoaXMuaW5wdXRBcnIsIGZ1bmN0aW9uIChpKSB7XG4gICAgICBwYXNzUmVzZXQuaW5wdXRBcnJbaV0ub25pbnB1dCA9ICgpID0+IHtcbiAgICAgICAgbGV0IGFyciA9IHBhc3NSZXNldC5pbnB1dEFyclxuICAgICAgICBsZXQgcGFzczEgPSBhcnJbMF0udmFsdWUsIHBhc3MyID0gYXJyWzFdLnZhbHVlXG4gICAgICAgIGlmIChwYXNzMi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHBhc3NSZXNldC5oaWRlRXJyb3IoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwYXNzMS5sZW5ndGggIT09IHBhc3MyLmxlbmd0aCkgeyBwYXNzUmVzZXQuc2hvd0Vycm9yKCdEaWZmZXJlbnQgcGFzc3dvcmQgbGVuZ3RoJykgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFzc1Jlc2V0LmhpZGVFcnJvcigpOyBpZiAocGFzczEgPT09IHBhc3MyKSB7IHBhc3NSZXNldC5zdWNjZXNzRXJyb3IoKSB9XG4gICAgICAgICAgICBlbHNlIHsgcGFzc1Jlc2V0LnNob3dFcnJvcihcIlBhc3N3b3JkcyBkb24ndCBtYXRjaFwiKSB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICAvLyBmb3JtIHN1Ym1pdFxuICAgIHRoaXMuZm9ybVswXS5vbnN1Ym1pdCA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGlmIChwYXNzUmVzZXQuZm9ybVZhbGlkKCkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwYXNzUmVzZXQuc3VibWl0QnRuWzBdLnN0eWxlLCB7IGNvbG9yOiAndHJhbnNwYXJlbnQnLCBoZWlnaHQ6ICcxNHB4JywgJ2JvcmRlci1yYWRpdXMnOiAnNTBweCcgfSlcbiAgICAgICAgcGFzc1Jlc2V0LmZvcm0uYWRkQ2xhc3MocGFzc1Jlc2V0LklTX0RJU0FCTEVEKVxuICAgICAgICBwYXNzUmVzZXQuaGlkZUVycm9yKClcbiAgICAgICAgcGFzc1Jlc2V0LmxvYWRlclswXS5hbmltYXRlKHsgd2lkdGg6ICcxMDAlJyB9LCB7IGR1cmF0aW9uOiAzMDAwLCBmaWxsOiAnZm9yd2FyZHMnIH0pLm9uZmluaXNoID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGUudGFyZ2V0KSwgb2JqID0ge31cbiAgICAgICAgICBmb3JtRGF0YS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiAob2JqW2tleV0gPSB2YWx1ZSkpXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXNzUmVzZXQubWFpblswXS5zdHlsZSwgeyBvcGFjaXR5OiAwIH0pOyBPYmplY3QuYXNzaWduKHBhc3NSZXNldC5yZXN1bHRbMF0uc3R5bGUsIHsgb3BhY2l0eTogMCB9KVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcGFzc1Jlc2V0Lm1haW4uaGlkZSgpXG4gICAgICAgICAgICBwYXNzUmVzZXQucmVzdWx0LnNob3coKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFzc1Jlc2V0LnJlc3VsdFswXS5zdHlsZSwgeyBvcGFjaXR5OiAxIH0pXG4gICAgICAgICAgICB9LCA1KTtcbiAgICAgICAgICB9LCA0MDEpO1xuICAgICAgICAgIC8vIGFsZXJ0KEpTT04uc3RyaW5naWZ5KG9iaikpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGZvcm1WYWxpZDogZnVuY3Rpb24gKCkge1xuICAgIGxldCBhcnIgPSBwYXNzUmVzZXQuaW5wdXRBcnJcbiAgICBhcnIuZm9yRWFjaChlbCA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKHBhc3NSZXNldC5JU19FTVBUWSkpXG5cbiAgICBpZiAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbGV0IGVtcHR5SW5wdXQgPSBhcnIuZmlsdGVyKGVsID0+IGVsLnZhbHVlLmxlbmd0aCA9PSAwKVxuXG4gICAgICBpZiAoZW1wdHlJbnB1dC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgJC5lYWNoKGVtcHR5SW5wdXQsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgZW1wdHlJbnB1dFtpXS5jbGFzc0xpc3QuYWRkKHBhc3NSZXNldC5JU19FTVBUWSlcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGVtcHR5SW5wdXRbaV0uY2xhc3NMaXN0LnJlbW92ZShwYXNzUmVzZXQuSVNfRU1QVFkpXG4gICAgICAgICAgfSwgNDAwKTtcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwYXNzMSA9IGFyclswXS52YWx1ZSwgcGFzczIgPSBhcnJbMV0udmFsdWVcbiAgICAgICAgaWYgKHBhc3MxID09PSBwYXNzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cbiAgfSxcbiAgc2hvd0Vycm9yOiBmdW5jdGlvbiAodGV4dCA9ICdTb21ldGhpbmcgd2VudCB3cm9uZy4uLicpIHtcbiAgICB0aGlzLmVycm9yLmh0bWwodGV4dClcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuZXJyb3JbMF0uc3R5bGUsIHsgY29sb3I6ICcjYzAyOTQyJywgb3BhY2l0eTogMSwgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKDBweCknIH0pXG4gIH0sXG4gIGhpZGVFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5lcnJvclswXS5zdHlsZSwgeyBjb2xvcjogJyNjMDI5NDInLCBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoMTRweCknIH0pXG4gIH0sXG4gIHN1Y2Nlc3NFcnJvcjogZnVuY3Rpb24gKHRleHQgPSAnUGFzc3dvcmRzIG1hdGNoIScpIHtcbiAgICB0aGlzLmVycm9yLmh0bWwodGV4dClcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuZXJyb3JbMF0uc3R5bGUsIHsgY29sb3I6ICcjMDg4ZDdiJywgb3BhY2l0eTogMSwgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKDBweCknIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXNzUmVzZXQiLCJjb25zdCBab29tR2FsbGVyeSA9IHJlcXVpcmUoJy4uL2R5bmFtaWMvem9vbS1nYWxsZXJ5JylcblxuY2xhc3MgUHJvZHVjdFBhZ2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9wdGlvbnNBcnIgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnByb2R1Y3RfX2l0ZW0tb3B0aW9uOm5vdCguLS1zdGF0aWMpJyldXG4gICAgdGhpcy5vcHRpb25zUm93ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNpZGUtcm93X19vcHRpb25zJylcbiAgICB0aGlzLmNvbG9yUGlja0FyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY29sb3ItcGljaycpXVxuICAgIHRoaXMudG9nZ2xlUm93QXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50b2dnbGUtcm93JyldXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwcm9kdWN0X2Rlc2NyaXB0aW9uJylcbiAgICB0aGlzLmdhbGxlcnlEZXNrdG9wQXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNnYWxsZXJ5X2Rlc2t0b3AnKS5xdWVyeVNlbGVjdG9yQWxsKCcucHJvZHVjdF9fZ2FsbGVyeScpXVxuICAgIHRoaXMuZ2FsbGVyeU1vYmlsZUFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZ2FsbGVyeV9tb2JpbGUnKS5xdWVyeVNlbGVjdG9yQWxsKCcucHJvZHVjdF9fZ2FsbGVyeScpXVxuXG4gICAgdGhpcy5vcHRpb25Nb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vcHRpb24tbW9kYWwnKVxuICAgIHRoaXMub3B0aW9uTW9kYWxDb250ZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9wdGlvbi1tb2RhbF9fY29udGVudCcpXG4gICAgdGhpcy5vcHRpb25Nb2RhbE5leHRFbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtb3B0aW9uLW1vZGFsLW5leHRdJylcbiAgICB0aGlzLm9wdGlvbk1vZGFsTmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW9wdGlvbi1tb2RhbC1uYW1lXScpXG4gICAgdGhpcy5ldnROZXh0T3B0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtZXZ0PVwib3B0aW9uTW9kYWxOZXh0XCJdJylcbiAgICB0aGlzLmV2dENsb3NlT3B0aW9uTW9kYWxBcnIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1ldnQ9XCJvcHRpb25Nb2RhbENsb3NlXCJdJylcbiAgICB0aGlzLmZhdkJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0X19hZGQtZmF2JylcbiAgICB0aGlzLmFjdGl2ZU9wdGlvbkluZGV4ID0gdW5kZWZpbmVkXG5cbiAgICB0aGlzLmZpeGVkQmFyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZpeGVkLWJhcicpXG4gICAgdGhpcy5maXhlZEJhclRyaWdnZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2lkZS1yb3dfX3BheW1lbnRzJylcblxuICAgIHRoaXMuZ2FsbGVyeVpvb21JbnN0YW5jZSA9IG51bGxcblxuICAgIHRoaXMuaW5pdCgpXG4gIH1cblxuICBpbml0KCkge1xuICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDk5MSkge1xuICAgICAgdGhpcy5iaW5kT3B0aW9uVG9nZ2xlRGVza3RvcCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmluZE9wdGlvblRvZ2dsZU1vYmlsZSgpXG4gICAgICB0aGlzLmJpbmRPcHRpb25Nb2RhbEV2ZW50cygpXG4gICAgICB0aGlzLmJpbmRQdWxsRG93bigpXG4gICAgfVxuICAgIHRoaXMuc2V0QWN0aXZlT3B0aW9uc1RleHQoKVxuICAgIHRoaXMuYmluZE9wdGlvbkJ1dHRvbkNsaWNrKClcbiAgICB0aGlzLmJpbmRPcHRpb25CdXR0b25DbGlja0lucHV0VmFsdWUoKVxuICAgIC8vIHRoaXMuYmluZENvbG9yUGljaygpXG4gICAgdGhpcy5iaW5kVG9nZ2xlUm93KClcbiAgICB0aGlzLmJpbmRUb2dnbGVGYXYoKVxuICAgIHRoaXMuc2V0dXBEZXNjcmlwdGlvbigpXG4gICAgdGhpcy5zZXR1cFNwbGlkZSgpXG4gICAgdGhpcy5zZXR1cEdhbGxlcnkoKVxuICAgIHRoaXMub2JzZXJ2ZUZpeGVkQmFyKClcbiAgICB0aGlzLnBvc2l0aW9uRml4ZWRCYXIoKVxuICAgIHRoaXMuc2V0Rml4ZWRCYXJNZWRpYSgpXG4gICAgdGhpcy5mb3JtYXRQcmljZSgpXG4gICAgdGhpcy5iaW5kR2FsbGVyeVpvb20oKVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmZvcm1hdFByaWNlKClcbiAgICB9LCAyMDAwKTtcbiAgfVxuXG4gIC8vIEdhbGxlcnlcbiAgc2V0dXBEZXNrdG9wR2FsbGVyeSgpIHtcbiAgICBmb3IgKGNvbnN0IGdhbGxlcnkgb2YgdGhpcy5nYWxsZXJ5RGVza3RvcEFycikge1xuICAgICAgY29uc3QgdGh1bWJzID0gWy4uLmdhbGxlcnkucXVlcnlTZWxlY3RvcignLnByb2R1Y3RfX3RodW1iLWdhbGxlcnknKS5xdWVyeVNlbGVjdG9yQWxsKCcucHJvZHVjdC1tZWRpYScpXVxuICAgICAgY29uc3QgbWVkaWEgPSBbLi4uZ2FsbGVyeS5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdF9fbWFpbi1nYWxsZXJ5JykucXVlcnlTZWxlY3RvckFsbCgnLnByb2R1Y3QtbWVkaWEnKV1cblxuICAgICAgaWYgKHRodW1icy5sZW5ndGggJiYgbWVkaWEubGVuZ3RoKSB7XG4gICAgICAgIHRodW1icy5mb3JFYWNoKCh0aHVtYiwgaW5kZXgpID0+IHtcbiAgICAgICAgICB0aHVtYi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIG1lZGlhLmZvckVhY2goZWwgPT4gZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJylcbiAgICAgICAgICAgIG1lZGlhW2luZGV4XS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldHVwTW9iaWxlR2FsbGVyeSgpIHtcbiAgICBmb3IgKGNvbnN0IGdhbGxlcnkgb2YgdGhpcy5nYWxsZXJ5TW9iaWxlQXJyKSB7XG4gICAgICBjb25zdCBtYWluU3BsaWRlID0gZ2FsbGVyeS5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdF9fbWFpbi1nYWxsZXJ5LnNwbGlkZScpXG4gICAgICBjb25zdCB0aHVtYnNTcGxpZGUgPSBnYWxsZXJ5LnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0X190aHVtYi1nYWxsZXJ5LnNwbGlkZScpXG5cbiAgICAgIGlmIChtYWluU3BsaWRlICYmIHRodW1ic1NwbGlkZSkge1xuICAgICAgICBjb25zdCBtYWluID0gbmV3IFNwbGlkZShtYWluU3BsaWRlLCB7XG4gICAgICAgICAgdHlwZTogXCJsb29wXCIsXG4gICAgICAgICAgcGVyUGFnZTogMSxcbiAgICAgICAgICBwZXJNb3ZlOiAxLFxuICAgICAgICAgIGdhcDogOCxcbiAgICAgICAgICBhcnJvd3M6IGZhbHNlLFxuICAgICAgICAgIHBhZ2luYXRpb246IGZhbHNlLFxuICAgICAgICAgIHNwZWVkOiA3NTAsXG4gICAgICAgICAgYnJlYWtwb2ludHM6IHtcbiAgICAgICAgICAgIDk5MToge1xuICAgICAgICAgICAgICBwZXJQYWdlOiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNzY3OiB7XG4gICAgICAgICAgICAgIHBlclBhZ2U6IDEuNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDQ3OToge1xuICAgICAgICAgICAgICBwZXJQYWdlOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHRodW1icyA9IG5ldyBTcGxpZGUodGh1bWJzU3BsaWRlLCB7XG4gICAgICAgICAgcmV3aW5kOiB0cnVlLFxuICAgICAgICAgIHBhZ2luYXRpb246IGZhbHNlLFxuICAgICAgICAgIGFycm93czogZmFsc2UsXG4gICAgICAgICAgY292ZXI6IHRydWUsXG4gICAgICAgICAgaXNOYXZpZ2F0aW9uOiB0cnVlLFxuICAgICAgICAgIGZpeGVkV2lkdGg6IDM4LFxuICAgICAgICAgIGdhcDogNFxuICAgICAgICB9KVxuICAgICAgICBtYWluLnN5bmModGh1bWJzKVxuICAgICAgICBtYWluLm1vdW50KClcbiAgICAgICAgdGh1bWJzLm1vdW50KClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0dXBHYWxsZXJ5KCkge1xuICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDk5MSkge1xuICAgICAgdGhpcy5zZXR1cERlc2t0b3BHYWxsZXJ5KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXR1cE1vYmlsZUdhbGxlcnkoKVxuICAgIH1cbiAgfVxuXG4gIC8vIE1ldGhvZHNcbiAgc2V0QWN0aXZlT3B0aW9uc1RleHQoKSB7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5vcHRpb25zQXJyKSB7XG4gICAgICBjb25zdCBob2xkZXIgPSBvcHRpb24ucXVlcnlTZWxlY3RvcignLnByb2R1Y3Qtb3B0aW9uX19oZWFkLXJpZ2h0JylcbiAgICAgIGNvbnN0IGFjdGl2ZUJ0biA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCcub3B0aW9uLWJ0bi5pcy1hY3RpdmUnKSB8fCBvcHRpb24ucXVlcnlTZWxlY3RvcignLm9wdGlvbi1idG4uYWN0aXZlJylcblxuICAgICAgaWYgKGhvbGRlciAmJiBhY3RpdmVCdG4pIHtcblxuICAgICAgICBjb25zdCB0ZXh0Q29udGVudCA9IGFjdGl2ZUJ0bi50ZXh0Q29udGVudFxuXG4gICAgICAgIGlmICh0ZXh0Q29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW0gPSBjcmVhdGVFbGVtKCdkaXYnLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdwcm9kdWN0LW9wdGlvbi1jdXJyZW50JyxcbiAgICAgICAgICAgIGlubmVySFRNTDogdGV4dENvbnRlbnRcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgaG9sZGVyLnByZXBlbmQoc2VsZWN0ZWRFbGVtKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldEFjdGl2ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3QgY3VycmVudEVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jdXJyZW50LWNvbG9yXScpXG4gICAgaWYgKGN1cnJlbnRFbGVtKSB7XG4gICAgICBjdXJyZW50RWxlbS5pbm5lckhUTUwgPSBjb2xvclxuICAgIH1cbiAgfVxuICBzZXRBY3RpdmVDb2xvclBpY2tFbGVtKGVsZW0pIHtcbiAgICB0aGlzLmNvbG9yUGlja0Fyci5mb3JFYWNoKChwaWNrKSA9PiB7XG4gICAgICBpZiAocGljayA9PT0gZWxlbSkge1xuICAgICAgICBwaWNrLmNsYXNzTGlzdC5hZGQoJy0tYWN0aXZlJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpY2suY2xhc3NMaXN0LnJlbW92ZSgnLS1hY3RpdmUnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgc2V0dXBEZXNjcmlwdGlvbigpIHtcbiAgICBpZiAodGhpcy5kZXNjcmlwdGlvbikge1xuICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSB0aGlzLmRlc2NyaXB0aW9uLnRleHRDb250ZW50XG5cbiAgICAgIGNvbnN0IGV4dHJhY3RMYXN0UGFyYWdyYXBoID0gKCkgPT4ge1xuICAgICAgICBsZXQgZWxlbWVudHMgPSB0aGlzLmRlc2NyaXB0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ3AsIGRpdiwgbGknKVxuICAgICAgICBsZXQgaG9sZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2l0ZW1EZXRhaWxzJylcblxuICAgICAgICBpZiAoaG9sZGVyKSB7XG4gICAgICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlbGVtZW50LnRleHRDb250ZW50LnRyaW0oKS5zdGFydHNXaXRoKFwiVGhlc2UgcGllY2VzIGFyZSBoYW5kY3JhZnRlZCBhbmRcIilcbiAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudC50cmltKCkuc3RhcnRzV2l0aChcIlRoaXMgcGllY2UgaXMgaGFuZGNyYWZ0ZWQgYW5kXCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaG9sZGVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Byb2R1Y3RfX21vcmUtdHlwbycpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBleHRyYWN0TGFzdFBhcmFncmFwaCgpXG4gICAgfVxuICB9XG4gIHNldHVwU3BsaWRlKCkge1xuICAgIGNvbnN0IHNwbGlkZUFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubW9yZS1yb3dfX3NwbGlkZScpXVxuICAgIGZvciAoY29uc3QgZWwgb2Ygc3BsaWRlQXJyKSB7XG4gICAgICBsZXQgbWFpbiA9IG5ldyBTcGxpZGUoZWwsIHtcbiAgICAgICAgdHlwZTogXCJsb29wXCIsXG4gICAgICAgIHBlclBhZ2U6IDQsXG4gICAgICAgIHBlck1vdmU6IDEsXG4gICAgICAgIGF1dG9wbGF5OiAwLFxuICAgICAgICBnYXA6IFwiOHB4XCIsXG4gICAgICAgIGFycm93czogMSxcbiAgICAgICAgcGFnaW5hdGlvbjogMCxcbiAgICAgICAgc3BlZWQ6IDc1MCxcbiAgICAgICAgYnJlYWtwb2ludHM6IHtcbiAgICAgICAgICAxOTgwOiB7XG4gICAgICAgICAgICBwZXJQYWdlOiA1LFxuICAgICAgICAgICAgcGVyTW92ZTogMSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIDE2ODA6IHtcbiAgICAgICAgICAgIHBlclBhZ2U6IDQsXG4gICAgICAgICAgICBwZXJNb3ZlOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgMTEyMDoge1xuICAgICAgICAgICAgcGVyUGFnZTogNCxcbiAgICAgICAgICAgIHBlck1vdmU6IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICA5OTE6IHtcbiAgICAgICAgICAgIHBlclBhZ2U6IDQsXG4gICAgICAgICAgICBwZXJNb3ZlOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgNzY3OiB7XG4gICAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICAgIHJvd3M6IDIsXG4gICAgICAgICAgICAgIGNvbHM6IDMsXG4gICAgICAgICAgICAgIGdhcDogeyByb3c6IFwiMTBweFwiLCBjb2w6IFwiOHB4XCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICA0Nzg6IHtcbiAgICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgICAgcm93czogMixcbiAgICAgICAgICAgICAgY29sczogMixcbiAgICAgICAgICAgICAgZ2FwOiB7IHJvdzogXCIyNHB4XCIsIGNvbDogXCI4cHhcIiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSkubW91bnQod2luZG93LnNwbGlkZS5FeHRlbnNpb25zKVxuICAgIH1cbiAgfVxuXG4gIC8vIE9wdGlvbiBNb2RhbFxuICByZXZlcnRPcHRpb25zKCkge1xuICAgIGNvbnN0IGJvZHkgPSB0aGlzLm9wdGlvbk1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LW9wdGlvbl9fYm9keScpXG4gICAgY29uc3QgZ3VpZGVCdG4gPSB0aGlzLm9wdGlvbk1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5vcHRpb24tZ3VpZGUtYnRuJylcbiAgICBjb25zdCBlbXB0eU9wdGlvbiA9IHRoaXMub3B0aW9uc0Fyci5maW5kKG9wdGlvbiA9PiAhb3B0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LW9wdGlvbl9fYm9keScpKVxuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5vcHRpb25Nb2RhbC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwiaGlkZGVuXCJdJylcblxuXG4gICAgaWYgKGJvZHkgJiYgZW1wdHlPcHRpb24pIHtcbiAgICAgIGlmIChndWlkZUJ0bikge1xuICAgICAgICBib2R5LmFwcGVuZChndWlkZUJ0bilcbiAgICAgIH1cbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICBlbXB0eU9wdGlvbi5hcHBlbmQoaW5wdXQpXG4gICAgICB9XG4gICAgICBlbXB0eU9wdGlvbi5hcHBlbmQoYm9keSlcbiAgICB9XG4gIH1cbiAgYXBwZW5kT3B0aW9uKG9wdGlvbiA9IHRoaXMub3B0aW9uc0FyclswXSkge1xuICAgIHRoaXMucmV2ZXJ0T3B0aW9ucygpXG4gICAgaWYgKG9wdGlvbikge1xuICAgICAgY29uc3Qgb3B0aW9uTmFtZSA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1vcHRpb24tbmFtZScpXG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLm9wdGlvbnNBcnIuaW5kZXhPZihvcHRpb24pXG4gICAgICB0aGlzLmFjdGl2ZU9wdGlvbkluZGV4ID0gY3VycmVudEluZGV4XG4gICAgICBjb25zdCBuZXh0T3B0aW9uID0gdGhpcy5vcHRpb25zQXJyW2N1cnJlbnRJbmRleCArIDFdIHx8IHRoaXMub3B0aW9uc0FyclswXVxuICAgICAgY29uc3QgbmV4dE9wdGlvbk5hbWUgPSBuZXh0T3B0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LW9wdGlvbi1uYW1lJylcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb24ucXVlcnlTZWxlY3RvcignLnByb2R1Y3Qtb3B0aW9uX19ib2R5JylcbiAgICAgIGNvbnN0IGlucHV0ID0gb3B0aW9uLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJoaWRkZW5cIl0nKVxuXG4gICAgICBjb25zdCBndWlkZUJ0biA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCcub3B0aW9uLWd1aWRlLWJ0bicpXG4gICAgICBjb25zdCBtb2RhbFdyYXBwZXIgPSB0aGlzLm9wdGlvbk1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5vcHRpb24tbW9kYWxfX3dyYXBwZXInKVxuXG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICB0aGlzLm9wdGlvbk1vZGFsTmFtZS5pbm5lckhUTUwgPSBvcHRpb25OYW1lLnRleHRDb250ZW50XG4gICAgICAgIHRoaXMub3B0aW9uTW9kYWxOZXh0RWxlbS5pbm5lckhUTUwgPSBuZXh0T3B0aW9uTmFtZS50ZXh0Q29udGVudFxuICAgICAgICB0aGlzLm9wdGlvbk1vZGFsQ29udGVudC5hcHBlbmRDaGlsZChib2R5KVxuXG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgIHRoaXMub3B0aW9uTW9kYWxDb250ZW50LmFwcGVuZENoaWxkKGlucHV0KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGd1aWRlQnRuICYmIG1vZGFsV3JhcHBlcikge1xuICAgICAgICAgIG1vZGFsV3JhcHBlci5hcHBlbmQoZ3VpZGVCdG4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmluZE9wdGlvbk1vZGFsRXZlbnRzKCkge1xuICAgIHRoaXMuZXZ0TmV4dE9wdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMuYXBwZW5kT3B0aW9uKHRoaXMub3B0aW9uc0Fyclt0aGlzLmFjdGl2ZU9wdGlvbkluZGV4ICsgMV0gfHwgdGhpcy5vcHRpb25zQXJyWzBdKVxuICAgIH0pXG4gICAgdGhpcy5ldnRDbG9zZU9wdGlvbk1vZGFsQXJyLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2VPcHRpb25Nb2RhbCgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbiAgYmluZE9wdGlvblRvZ2dsZU1vYmlsZSgpIHtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLm9wdGlvbnNBcnIpIHtcbiAgICAgIGNvbnN0IGhlYWQgPSBvcHRpb24ucXVlcnlTZWxlY3RvcignLnByb2R1Y3Qtb3B0aW9uX19oZWFkJylcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb24ucXVlcnlTZWxlY3RvcignLnByb2R1Y3Qtb3B0aW9uX19ib2R5JylcblxuICAgICAgaWYgKGhlYWQgJiYgYm9keSkge1xuICAgICAgICBoZWFkLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYXBwZW5kT3B0aW9uKG9wdGlvbilcbiAgICAgICAgICB0aGlzLnNob3dPcHRpb25Nb2RhbCgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNob3dPcHRpb25Nb2RhbCgpIHtcbiAgICBsb2NrU2Nyb2xsKClcbiAgICB3aW5kb3cub3B0aW9uTW9kYWxCYWNrZHJvcCA9IG5ldyBCYWNrZHJvcCh7XG4gICAgICBoYWxmOiB0cnVlLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHsgdGhpcy5jbG9zZU9wdGlvbk1vZGFsKCkgfVxuICAgIH0pXG4gICAgdGhpcy5vcHRpb25Nb2RhbC5jbGFzc0xpc3QuYWRkKCctLXZpc2libGUnKVxuICB9XG4gIGNsb3NlT3B0aW9uTW9kYWwoKSB7XG4gICAgdW5sb2NrU2Nyb2xsKClcbiAgICB0aGlzLm9wdGlvbk1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoJy0tdmlzaWJsZScpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLm9wdGlvbk1vZGFsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKVxuICAgICAgdGhpcy5yZXZlcnRPcHRpb25zKClcbiAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLm9wdGlvbk1vZGFsKSk7XG4gICAgaWYgKHdpbmRvdy5vcHRpb25Nb2RhbEJhY2tkcm9wKSB7XG4gICAgICB3aW5kb3cub3B0aW9uTW9kYWxCYWNrZHJvcC5oaWRlKHRydWUpXG4gICAgfVxuICB9XG4gIGJpbmRQdWxsRG93bigpIHtcbiAgICBsZXQgc3RhcnRZID0gMDtcbiAgICBsZXQgY3VycmVudFkgPSAwO1xuICAgIGxldCBpc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgbGV0IGlzTW92aW5nUm9vdCA9IGZhbHNlO1xuICAgIGNvbnN0IHJvb3RFbCA9IHRoaXMub3B0aW9uTW9kYWw7XG4gICAgY29uc3Qgc2Nyb2xsZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcub3B0aW9uLW1vZGFsX19jb250ZW50JylcbiAgICBjb25zdCBoYW5kbGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9wdGlvbi1tb2RhbF9faGVhZGVyJylcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gJ2FsbCAwLjRzIGN1YmljLWJlemllcigwLjM5LCAwLjU3NSwgMC41NjUsIDEpJ1xuXG4gICAgcm9vdEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG5cbiAgICAgIGNvbnN0IGlzT25IYW5kbGVyID0gaGFuZGxlci5jb250YWlucyh0YXJnZXQpIHx8IHRhcmdldCA9PT0gaGFuZGxlcjtcblxuICAgICAgc3RhcnRZID0gZS50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICBpc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIGlzTW92aW5nUm9vdCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLmlzT25IYW5kbGVyID0gaXNPbkhhbmRsZXI7XG4gICAgfSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIHJvb3RFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAoZSkgPT4ge1xuICAgICAgaWYgKCFpc0RyYWdnaW5nKSByZXR1cm47XG5cbiAgICAgIGN1cnJlbnRZID0gZS50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICBsZXQgZGlmZlkgPSBjdXJyZW50WSAtIHN0YXJ0WTtcblxuICAgICAgcm9vdEVsLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG5cbiAgICAgIGlmIChkaWZmWSA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPbkhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIWlzTW92aW5nUm9vdCkge1xuICAgICAgICAgICAgaXNNb3ZpbmdSb290ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb290RWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoJHtkaWZmWX1weClgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzY3JvbGxlci5zY3JvbGxUb3AgPT09IDApIHtcbiAgICAgICAgICAgIGlmICghaXNNb3ZpbmdSb290KSB7XG4gICAgICAgICAgICAgIGlzTW92aW5nUm9vdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvb3RFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgke2RpZmZZfXB4KWA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIHJvb3RFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICgpID0+IHtcbiAgICAgIGlmICghaXNEcmFnZ2luZykgcmV0dXJuO1xuICAgICAgaXNEcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoaXNNb3ZpbmdSb290KSB7XG4gICAgICAgIGxldCBkaWZmWSA9IGN1cnJlbnRZIC0gc3RhcnRZO1xuICAgICAgICBsZXQgaGlkZU9mZnNldCA9IHJvb3RFbC5vZmZzZXRIZWlnaHQgKiAwLjM7XG4gICAgICAgIHJvb3RFbC5zdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblxuICAgICAgICBpZiAoZGlmZlkgPiBoaWRlT2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy5jbG9zZU9wdGlvbk1vZGFsKCk7XG4gICAgICAgICAgcm9vdEVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKDEwMCUpYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290RWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBNZXRob2RzIC0gT3B0aW9uc1xuICBoaWRlQWxsT3B0aW9ucyhleGNsdWRlID0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9uc0Fyci5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICBpZiAob3B0aW9uICE9PSBleGNsdWRlKSB7XG4gICAgICAgIHRoaXMuaGlkZU9wdGlvbihvcHRpb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dPcHRpb24ob3B0aW9uKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKGV4Y2x1ZGUgPT0gbnVsbCkge1xuICAgICAgdGhpcy5vcHRpb25zUm93LmNsYXNzTGlzdC5yZW1vdmUoJy0tYWN0aXZlJylcbiAgICB9XG4gIH1cbiAgc2hvd09wdGlvbihvcHRpb24pIHtcbiAgICBvcHRpb24uY2xhc3NMaXN0LmFkZCgnLS1hY3RpdmUnKVxuICB9XG4gIGhpZGVPcHRpb24ob3B0aW9uKSB7XG4gICAgb3B0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJy0tYWN0aXZlJylcbiAgfVxuXG4gIC8vIFByaWNlXG4gIGZvcm1hdFByaWNlKCkge1xuICAgIGNvbnN0IHByaWNlQXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcm9kdWN0X19pdGVtLXByaWNlJyldXG5cbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgcHJpY2VBcnIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBlbGVtLnRleHRDb250ZW50XG4gICAgICBjb25zdCBjb250YWluc0RvbGxhciA9IHRleHQuaW5jbHVkZXMoJyQnKVxuICAgICAgY29uc3QgcGFyZW50QmFyID0gZWxlbS5jbG9zZXN0KCcuZml4ZWQtYmFyJylcblxuICAgICAgaWYgKGNvbnRhaW5zRG9sbGFyICYmICFwYXJlbnRCYXIpIHtcbiAgICAgICAgY29uc3QgcHJpY2UgPSB0ZXh0LnJlcGxhY2UoJyQnLCAnJylcbiAgICAgICAgZWxlbS5pbm5lckhUTUwgPSBgPHNwYW4gY2xhc3M9XCJkb2xsYXItc3ltYm9sXCI+JDwvc3Bhbj4ke3ByaWNlLnJlcGxhY2UoL1xccy9nLCAnJyl9YFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJpbmQgRXZlbnRzXG4gIGJpbmRPcHRpb25Ub2dnbGVEZXNrdG9wKCkge1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHRoaXMub3B0aW9uc0Fycikge1xuICAgICAgY29uc3QgaGVhZCA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1vcHRpb25fX2hlYWQnKVxuICAgICAgY29uc3QgYnRuQXJyID0gWy4uLm9wdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCcub3B0aW9uLWJ0bicpXVxuICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgICBpZiAob3B0aW9uLmNsYXNzTGlzdC5jb250YWlucygnLS1hY3RpdmUnKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlT3B0aW9uKG9wdGlvbilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlQWxsT3B0aW9ucyhvcHRpb24pXG4gICAgICAgICAgICB0aGlzLnNob3dPcHRpb24ob3B0aW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5zaG93T3B0aW9uKG9wdGlvbilcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMuc2hvd09wdGlvbihvcHRpb24pXG4gICAgfVxuXG4gICAgLy8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgIC8vICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXRcbiAgICAvLyAgIGlmICghdGFyZ2V0LmNsb3Nlc3QoJy5wcm9kdWN0X19pdGVtLW9wdGlvbicpKSB7XG4gICAgLy8gICAgIHRoaXMuaGlkZUFsbE9wdGlvbnMoKVxuICAgIC8vICAgfVxuICAgIC8vIH0pXG4gIH1cbiAgYmluZE9wdGlvbkJ1dHRvbkNsaWNrKCkge1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHRoaXMub3B0aW9uc0Fycikge1xuICAgICAgY29uc3QgYnRuQXJyID0gWy4uLm9wdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCcub3B0aW9uLWJ0bicpXVxuICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtID0gb3B0aW9uLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LW9wdGlvbi1jdXJyZW50JylcblxuICAgICAgaWYgKGJ0bkFyci5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCBidG4gb2YgYnRuQXJyKSB7XG4gICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFidG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gYnRuLnRleHRDb250ZW50LnRyaW0oKVxuICAgICAgICAgICAgICBpZiAodGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkRWxlbSkge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFbGVtLmlubmVySFRNTCA9IHRleHRDb250ZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnRuQXJyLmZvckVhY2goZWwgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShJU19BQ1RJVkUpKVxuICAgICAgICAgICAgICBidG4uY2xhc3NMaXN0LmFkZChJU19BQ1RJVkUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBiaW5kT3B0aW9uQnV0dG9uQ2xpY2tJbnB1dFZhbHVlKCkge1xuICAgIGNvbnN0IGJ0bkFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcub3B0aW9uLWJ0bicpXVxuICAgIGZvciAoY29uc3QgYnRuIG9mIGJ0bkFycikge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGJ0bi5kYXRhc2V0LnZhbHVlXG4gICAgICAgIGlmICghdmFsdWUpIHRocm93IG5ldyBFcnJvcignZGF0YS12YWx1ZSBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQnKVxuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGJ0bi5jbG9zZXN0KCcucHJvZHVjdF9faXRlbS1vcHRpb24nKSB8fCBidG4uY2xvc2VzdCgnLm9wdGlvbi1tb2RhbF9fY29udGVudCcpXG4gICAgICAgIGlmICghcGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoJ3BhcmVudCBlbGVtZW50IGlzIHJlcXVpcmVkJylcblxuICAgICAgICBjb25zdCBpbnB1dCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcuY3VzdG9tLWZpZWxkcy1mZXRjaCcpXG4gICAgICAgIGlmICghaW5wdXQpIHRocm93IG5ldyBFcnJvcignY3VzdG9tLWZpZWxkcy1mZXRjaCBlbGVtZW50IGlzIHJlcXVpcmVkJylcblxuXG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWVcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2NoYW5nZScsIHsgYnViYmxlczogdHJ1ZSB9KVxuICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICAgICAgICB0aGlzLmNsb3NlT3B0aW9uTW9kYWwoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZENvbG9yUGljaygpIHtcbiAgICB0aGlzLmNvbG9yUGlja0Fyci5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgY29uc3QgYXR0ciA9IGJ0bi5kYXRhc2V0LmNvbG9yXG4gICAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgICAgdGhpcy5zZXRBY3RpdmVDb2xvcihhdHRyKVxuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlQ29sb3JQaWNrRWxlbShidG4pXG5cbiAgICAgICAgICBpZiAodGhpcy5maXhlZEJhcikge1xuICAgICAgICAgICAgdGhpcy5maXhlZEJhci5jbGFzc0xpc3QucmVtb3ZlKCctLWZpbGxlZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbiAgYmluZFRvZ2dsZVJvdygpIHtcbiAgICB0aGlzLnRvZ2dsZVJvd0Fyci5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgIGNvbnN0IGhlYWQgPSByb3cucXVlcnlTZWxlY3RvcignLnRvZ2dsZS1yb3dfX2hlYWQnKVxuICAgICAgY29uc3QgYm9keSA9IHJvdy5xdWVyeVNlbGVjdG9yKCcudG9nZ2xlLXJvd19fYm9keScpXG4gICAgICBjb25zdCB3cmFwcGVyID0gcm93LnF1ZXJ5U2VsZWN0b3IoJy50b2dnbGUtcm93X193cmFwcGVyJylcblxuICAgICAgaWYgKGhlYWQgJiYgYm9keSAmJiB3cmFwcGVyKSB7XG4gICAgICAgIGhlYWQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gd3JhcHBlci5zY3JvbGxIZWlnaHRcbiAgICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IGJvZHkub2Zmc2V0SGVpZ2h0ID4gMCAmJiByb3cuY2xhc3NMaXN0LmNvbnRhaW5zKCctLWFjdGl2ZScpXG5cbiAgICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIGJvZHkuc3R5bGUuaGVpZ2h0ID0gYDBweGBcbiAgICAgICAgICAgIHJvdy5jbGFzc0xpc3QucmVtb3ZlKCctLWFjdGl2ZScpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkuc3R5bGUuaGVpZ2h0ID0gYCR7c2Nyb2xsSGVpZ2h0fXB4YFxuICAgICAgICAgICAgcm93LmNsYXNzTGlzdC5hZGQoJy0tYWN0aXZlJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBiaW5kVG9nZ2xlRmF2KCkge1xuICAgIGlmICh0aGlzLmZhdkJ0bikge1xuICAgICAgdGhpcy5mYXZCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZmF2QnRuLmNsYXNzTGlzdC50b2dnbGUoJ2lzLWFjdGl2ZScpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBiaW5kR2FsbGVyeVpvb20oKSB7XG4gICAgY29uc3QgZ2FsbGVyeUFyciA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZ2FsbGVyeV9tb2JpbGUgLnByb2R1Y3RfX21haW4tZ2FsbGVyeScpXVxuICAgIGZvciAoY29uc3QgZ2FsbGVyeSBvZiBnYWxsZXJ5QXJyKSB7XG4gICAgICBnYWxsZXJ5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG1lZGlhQ2xpY2tlZCA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KCcucHJvZHVjdC1tZWRpYScpXG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8IDQ4MCAmJiBtZWRpYUNsaWNrZWQpIHtcblxuICAgICAgICAgIGlmICh0aGlzLmdhbGxlcnlab29tSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FsbGVyeVpvb21JbnN0YW5jZS5kZXN0cm95KClcbiAgICAgICAgICAgIHRoaXMuZ2FsbGVyeVpvb21JbnN0YW5jZSA9IG51bGxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBsaXN0ID0gZ2FsbGVyeS5xdWVyeVNlbGVjdG9yKCcuc3BsaWRlX19saXN0JylcbiAgICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgY29uc3QgbWVkaWFBcnIgPSBbLi4ubGlzdC5xdWVyeVNlbGVjdG9yQWxsKCcucHJvZHVjdC1tZWRpYTpub3QoLnNwbGlkZV9fc2xpZGUtLWNsb25lKScpXVxuICAgICAgICAgICAgdGhpcy5nYWxsZXJ5Wm9vbUluc3RhbmNlID0gbmV3IFpvb21HYWxsZXJ5KG1lZGlhQXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBGaXhlZCBCYXJcbiAgcG9zaXRpb25GaXhlZEJhcigpIHtcbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkZXInKVxuICAgIGlmIChoZWFkZXIgJiYgdGhpcy5maXhlZEJhciAmJiB0aGlzLmZpeGVkQmFyVHJpZ2dlcikge1xuICAgICAgdGhpcy5maXhlZEJhci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuXG4gICAgICBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDk5MSkge1xuICAgICAgICAgIHRoaXMuZml4ZWRCYXIuc3R5bGUuekluZGV4ID0gLTFcbiAgICAgICAgICB0aGlzLmZpeGVkQmFyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgICAgICAgIHRoaXMuZml4ZWRCYXIuc3R5bGUudG9wID0gJzEwMCUnXG4gICAgICAgICAgaWYgKCFoZWFkZXIuY29udGFpbnModGhpcy5maXhlZEJhcikpIHtcbiAgICAgICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZCh0aGlzLmZpeGVkQmFyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBoZWFkZXJaSW5kZXggPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShoZWFkZXIpLmdldFByb3BlcnR5VmFsdWUoJ3otaW5kZXgnKVxuICAgICAgICAgIHRoaXMuZml4ZWRCYXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQoaGVhZGVyWkluZGV4LCAxMCkgLSAxXG4gICAgICAgICAgdGhpcy5maXhlZEJhci5zdHlsZS50b3AgPSAnYXV0bydcbiAgICAgICAgICB0aGlzLmZpeGVkQmFyLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJ1xuICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLmZpeGVkQmFyKSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmZpeGVkQmFyKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKVxuICAgICAgdXBkYXRlKClcbiAgICB9XG4gIH1cbiAgb2JzZXJ2ZUZpeGVkQmFyKCkge1xuICAgIGNvbnN0IHRyaWdnZXJFbGVtID0gdGhpcy5maXhlZEJhclRyaWdnZXI7XG4gICAgY29uc3QgYmFyID0gdGhpcy5maXhlZEJhcjtcbiAgICBsZXQgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZGVyJyk7XG5cbiAgICBpZiAodHJpZ2dlckVsZW0gJiYgYmFyKSB7XG4gICAgICBsZXQgaGVhZGVyT2Zmc2V0ID0gaGVhZGVyID8gaGVhZGVyLm9mZnNldEhlaWdodCA6IDA7XG4gICAgICBsZXQgb2JzZXJ2ZXIgPSBudWxsO1xuXG4gICAgICBjb25zdCB1cGRhdGVPYnNlcnZlciA9ICgpID0+IHtcbiAgICAgICAgaGVhZGVyT2Zmc2V0ID0gaGVhZGVyID8gaGVhZGVyLm9mZnNldEhlaWdodCA6IDA7XG5cbiAgICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXJDYWxsYmFjayA9IChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgIGlmICghZW50cnkuaXNJbnRlcnNlY3RpbmcgJiYgZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LnRvcCA8IDApIHtcbiAgICAgICAgICAgICAgYmFyLmNsYXNzTGlzdC5hZGQoX19WSVNJQkxFKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRGaXhlZEJhck1lZGlhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiYXIuY2xhc3NMaXN0LnJlbW92ZShfX1ZJU0lCTEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKG9ic2VydmVyQ2FsbGJhY2ssIHtcbiAgICAgICAgICByb290OiBudWxsLFxuICAgICAgICAgIHJvb3RNYXJnaW46IGAtJHtoZWFkZXJPZmZzZXR9cHggMHB4IDBweCAwcHhgLFxuICAgICAgICAgIHRocmVzaG9sZDogMFxuICAgICAgICB9KTtcblxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRyaWdnZXJFbGVtKTtcbiAgICAgIH07XG5cbiAgICAgIHVwZGF0ZU9ic2VydmVyKCk7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVPYnNlcnZlcik7XG4gICAgfVxuICB9XG4gIHNldEZpeGVkQmFyTWVkaWEoKSB7XG4gICAgaWYgKHRoaXMuZml4ZWRCYXIpIHtcblxuICAgICAgaWYgKCF0aGlzLmZpeGVkQmFyLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpKSB7XG4gICAgICAgIHRoaXMuZml4ZWRCYXIuY2xhc3NMaXN0LnJlbW92ZSgnLS1maWxsZWQnKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB2aXNpYmxlR2FsbGVyeSA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucHJvZHVjdF9fZ2FsbGVyeScpXS5maW5kKChlbCkgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnXG4gICAgICB9KVxuXG4gICAgICBpZiAodmlzaWJsZUdhbGxlcnkpIHtcbiAgICAgICAgY29uc3QgbWFpbkdhbGxlcnkgPSB2aXNpYmxlR2FsbGVyeS5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdF9fbWFpbi1nYWxsZXJ5JylcbiAgICAgICAgY29uc3QgZml4ZWRCYXJNZWRpYSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5maXhlZC1iYXJfX21lZGlhJylcblxuICAgICAgICBpZiAobWFpbkdhbGxlcnkgJiYgZml4ZWRCYXJNZWRpYSkge1xuICAgICAgICAgIGNvbnN0IGltYWdlID0gbWFpbkdhbGxlcnkucXVlcnlTZWxlY3RvcignaW1nJylcbiAgICAgICAgICBjb25zdCBmaXhlZEJhckltYWdlID0gZml4ZWRCYXJNZWRpYS5xdWVyeVNlbGVjdG9yKCdpbWcnKVxuXG4gICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICBpZiAoIWZpeGVkQmFySW1hZ2UpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3SW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICAgICAgICAgICAgbmV3SW1nLnNyYyA9IGltYWdlLnNyY1xuICAgICAgICAgICAgICBmaXhlZEJhck1lZGlhLmFwcGVuZENoaWxkKG5ld0ltZylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpeGVkQmFySW1hZ2Uuc3JjID0gaW1hZ2Uuc3JjXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZml4ZWRCYXIuY2xhc3NMaXN0LmFkZCgnLS1maWxsZWQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2R1Y3RQYWdlIiwiY29uc3QgQ2FyZU1vZGFsID0gcmVxdWlyZSgnLi4vbW9kYWxzL2NhcmUtbW9kYWwnKVxuXG5jbGFzcyBSZXN1bHRzUGFnZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucm9vdEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW5fcmVzdWx0cycpO1xuICAgIHRoaXMuZmlsdGVyQm94QXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wYWdlLWZpbHRlci1ib3gnKV07XG4gICAgdGhpcy5maWx0ZXJNb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5maWx0ZXItbW9kYWwnKTtcbiAgICB0aGlzLmNhcmRzR3JpZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXJkcy1ncmlkJyk7XG4gICAgdGhpcy5maWx0ZXJNb2RhbEFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuZmlsdGVycyA9IHt9O1xuICAgIHRoaXMuY2FyZU1vZGFsSW5zdGFuY2UgPSBudWxsXG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvLyBNZXRob2RzXG4gIHNob3dGaWx0ZXJNb2RhbCgpIHtcbiAgICBsb2NrU2Nyb2xsKCk7XG4gICAgd2luZG93LmZpbHRlck1vZGFsQmFja2Ryb3AgPSBuZXcgQmFja2Ryb3Aoe1xuICAgICAgaGFsZjogdHJ1ZSxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7IHRoaXMuaGlkZUZpbHRlck1vZGFsKCk7IH1cbiAgICB9KTtcblxuICAgIHRoaXMuZmlsdGVyTW9kYWwuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5maWx0ZXJNb2RhbC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVkoMClcIjtcbiAgICB9LCAzKTtcbiAgfVxuXG4gIGhpZGVGaWx0ZXJNb2RhbCgpIHtcbiAgICB1bmxvY2tTY3JvbGwoKTtcbiAgICBpZiAod2luZG93LmZpbHRlck1vZGFsQmFja2Ryb3ApIHtcbiAgICAgIHdpbmRvdy5maWx0ZXJNb2RhbEJhY2tkcm9wLmhpZGUodHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuZmlsdGVyTW9kYWwuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKDEwMCUpXCI7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmZpbHRlck1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9LCBnZXRUcmFuc2l0aW9uVGltZSh0aGlzLmZpbHRlck1vZGFsKSk7XG4gIH1cblxuICBkZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGVkRnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgY29uc3QgbGF0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgICBmdW5jKC4uLmFyZ3MpXG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KVxuICAgIH07XG4gIH1cblxuXG4gIG9ic2VydmVGaWx0ZXJzKCkge1xuICAgIGZvciAoY29uc3QgZmlsdGVyIGluIHRoaXMuZmlsdGVycykge1xuICAgICAgaWYgKHRoaXMuZmlsdGVycy5oYXNPd25Qcm9wZXJ0eShmaWx0ZXIpKSB7XG4gICAgICAgIGNvbnN0IHsgYnRuQXJyLCBsaXN0IH0gPSB0aGlzLmZpbHRlcnNbZmlsdGVyXTtcblxuICAgICAgICBjb25zdCByYWRpb3MgPSBbLi4ubGlzdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKV07XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSBbLi4ubGlzdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKV07XG4gICAgICAgIGNvbnN0IGxpbmtzID0gWy4uLmxpc3QucXVlcnlTZWxlY3RvckFsbCgnYScpXTtcblxuICAgICAgICBjb25zdCBpc0ZpbGxlZCA9IHJhZGlvcy5zb21lKHJhZGlvID0+IHJhZGlvLmNoZWNrZWQpIHx8XG4gICAgICAgICAgY2hlY2tib3hlcy5zb21lKGNoZWNrYm94ID0+IGNoZWNrYm94LmNoZWNrZWQpIHx8XG4gICAgICAgICAgbGlua3Muc29tZShsaW5rID0+IGxpbmsuY2xhc3NMaXN0LmNvbnRhaW5zKCdpcy1hY3RpdmUnKSk7XG5cbiAgICAgICAgYnRuQXJyLmZvckVhY2goYnRuID0+IGJ0bi5jbGFzc0xpc3QudG9nZ2xlKCctLWZpbGxlZCcsIGlzRmlsbGVkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRGVza3RvcFxuICBzZXR1cERlc2t0b3BGaWx0ZXJzKCkge1xuICAgIHRoaXMuZmlsdGVyQm94QXJyLmZvckVhY2goKGJveCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGJ0biA9IGJveC5xdWVyeVNlbGVjdG9yKCcucGFnZS1maWx0ZXItYnRuJyk7XG4gICAgICBjb25zdCBkcm9wID0gYm94LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLWZpbHRlci1kcm9wJyk7XG4gICAgICBjb25zdCBvcHRpb25zQXJyID0gZHJvcC5xdWVyeVNlbGVjdG9yKCdhJykgPyBbLi4uZHJvcC5xdWVyeVNlbGVjdG9yQWxsKCdhJyldIDogWy4uLmRyb3AucXVlcnlTZWxlY3RvckFsbCgnbGFiZWwnKV07XG5cbiAgICAgIGlmIChvcHRpb25zQXJyLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmZpbHRlcnNbaW5kZXhdID0geyBidG5BcnI6IFtidG5dLCBsaXN0OiBkcm9wIH07XG5cbiAgICAgICAgb3B0aW9uc0Fyci5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICAgb3B0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUZpbHRlcnMoKVxuXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICAgICAgYm94LmNsYXNzTGlzdC5yZW1vdmUoJy0tZm9jdXNlZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRm9jdXNlZCA9IGJveC5jbGFzc0xpc3QuY29udGFpbnMoJy0tZm9jdXNlZCcpO1xuICAgICAgICB0aGlzLmZpbHRlckJveEFyci5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoJy0tZm9jdXNlZCcpKTtcbiAgICAgICAgaWYgKCFpc0ZvY3VzZWQpIGJveC5jbGFzc0xpc3QuYWRkKCctLWZvY3VzZWQnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgaWYgKCFlLnRhcmdldC5jbG9zZXN0KCcucGFnZS1maWx0ZXItYm94JykpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJCb3hBcnIuZm9yRWFjaChib3ggPT4gYm94LmNsYXNzTGlzdC5yZW1vdmUoJy0tZm9jdXNlZCcpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1vYmlsZVxuICBzZXR1cE1vYmlsZUZpbHRlcnMoKSB7XG4gICAgY29uc3QgZmlsdGVyTGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5maWx0ZXItbW9kYWxfX2ZpbHRlci1saXN0Jyk7XG4gICAgY29uc3Qgb3B0aW9uc0hvbGRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5maWx0ZXItbW9kYWxfX29wdGlvbnMnKTtcbiAgICBsZXQgZmlsdGVyQnRuQXJyID0gW107XG4gICAgbGV0IGxpc3RzQXJyID0gW107XG5cbiAgICB0aGlzLmZpbHRlckJveEFyci5mb3JFYWNoKChmaWx0ZXIsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBidG4gPSBmaWx0ZXIucXVlcnlTZWxlY3RvcignLnBhZ2UtZmlsdGVyLWJ0bicpO1xuICAgICAgY29uc3QgZHJvcCA9IGZpbHRlci5xdWVyeVNlbGVjdG9yKCcucGFnZS1maWx0ZXItZHJvcCcpO1xuICAgICAgY29uc3Qgb3B0aW9uc0FyciA9IGRyb3AucXVlcnlTZWxlY3RvcignYScpID8gWy4uLmRyb3AucXVlcnlTZWxlY3RvckFsbCgnYScpXSA6IFsuLi5kcm9wLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xhYmVsJyldO1xuXG4gICAgICBpZiAoIW9wdGlvbnNBcnIubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgIG9wdGlvbnNBcnIuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgICBvcHRpb24uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4gdGhpcy5vYnNlcnZlRmlsdGVycygpKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkaXNwbGF5TmFtZSA9IHRoaXMuZ2V0RmlsdGVyRGlzcGxheU5hbWUoYnRuLCBmaWx0ZXIpO1xuICAgICAgY29uc3QgZmlsdGVyTW9kYWxCdXR0b24gPSB0aGlzLmNyZWF0ZUZpbHRlckJ1dHRvbihkaXNwbGF5TmFtZSk7XG4gICAgICBjb25zdCBsaXN0ID0gdGhpcy5jcmVhdGVGaWx0ZXJMaXN0KG9wdGlvbnNBcnIpO1xuXG4gICAgICBmaWx0ZXJMaXN0LmFwcGVuZENoaWxkKGZpbHRlck1vZGFsQnV0dG9uKTtcbiAgICAgIG9wdGlvbnNIb2xkZXIuYXBwZW5kQ2hpbGQobGlzdCk7XG5cbiAgICAgIGZpbHRlckJ0bkFyci5wdXNoKGZpbHRlck1vZGFsQnV0dG9uKTtcbiAgICAgIGxpc3RzQXJyLnB1c2gobGlzdCk7XG5cbiAgICAgIHRoaXMuc2V0dXBGaWx0ZXJNb2RhbEJ1dHRvbkJlaGF2aW9yKGZpbHRlck1vZGFsQnV0dG9uLCBsaXN0LCBmaWx0ZXJCdG5BcnIsIGxpc3RzQXJyKTtcbiAgICAgIHRoaXMuc2V0dXBGaWx0ZXJPYmplY3QoaW5kZXgsIGJ0biwgZmlsdGVyTW9kYWxCdXR0b24sIGxpc3QpO1xuICAgICAgdGhpcy5iaW5kRmlsdGVyQnV0dG9uQ2xpY2soYnRuLCBmaWx0ZXJNb2RhbEJ1dHRvbiwgbGlzdCwgZmlsdGVyQnRuQXJyLCBsaXN0c0Fycik7XG4gICAgfSk7XG4gIH1cblxuICBnZXRGaWx0ZXJEaXNwbGF5TmFtZShidG4sIGZpbHRlcikge1xuICAgIGNvbnN0IGZpbHRlcklkID0gZmlsdGVyLmlkID8gZmlsdGVyLmlkIDogbnVsbDtcbiAgICBjb25zdCBidG5TcGFuID0gYnRuLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICBjb25zdCByYXdOYW1lID0gKGZpbHRlcklkICYmIGJ0blNwYW4pID8gYnRuU3Bhbi5pbm5lclRleHQudG9Mb3dlckNhc2UoKSA6ICdTb3J0IEJ5JztcbiAgICByZXR1cm4gKHJhd05hbWUuaW5jbHVkZXMoJ3N1YmNhdGVnb3JpZXMnKSB8fCByYXdOYW1lLmluY2x1ZGVzKCdzdWJjYXRlZ29yeScpKSA/ICdTdWJjYXRlZ29yaWVzJyA6XG4gICAgICAocmF3TmFtZS5pbmNsdWRlcygncHJpY2UnKSB8fCByYXdOYW1lLmluY2x1ZGVzKCdwcmljZSByYW5nZScpKSA/ICdQcmljZScgOiByYXdOYW1lO1xuICB9XG5cbiAgY3JlYXRlRmlsdGVyQnV0dG9uKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW0oJ2J1dHRvbicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2ZpbHRlci1tb2RhbF9fZmlsdGVyLWJ0bicsXG4gICAgICBpbm5lckhUTUw6IGA8c3Bhbj4ke2Rpc3BsYXlOYW1lfTwvc3Bhbj5gXG4gICAgfSk7XG4gIH1cblxuICBjcmVhdGVGaWx0ZXJMaXN0KG9wdGlvbnNBcnIpIHtcbiAgICBjb25zdCBsaXN0ID0gY3JlYXRlRWxlbSgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAnZmlsdGVyLW1vZGFsX19vcHRpb25zLWxpc3QnLFxuICAgICAgc3R5bGU6IHsgZGlzcGxheTogJ25vbmUnIH1cbiAgICB9KTtcbiAgICBvcHRpb25zQXJyLmZvckVhY2goZWwgPT4gbGlzdC5hcHBlbmRDaGlsZChlbCkpO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgc2V0dXBGaWx0ZXJNb2RhbEJ1dHRvbkJlaGF2aW9yKGZpbHRlck1vZGFsQnV0dG9uLCBsaXN0LCBmaWx0ZXJCdG5BcnIsIGxpc3RzQXJyKSB7XG4gICAgZmlsdGVyTW9kYWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBmaWx0ZXJCdG5BcnIuZm9yRWFjaChidG4gPT4gYnRuLmNsYXNzTGlzdC50b2dnbGUoJy0tYWN0aXZlJywgYnRuID09PSBmaWx0ZXJNb2RhbEJ1dHRvbikpO1xuICAgICAgbGlzdHNBcnIuZm9yRWFjaChsID0+IGwuc3R5bGUuZGlzcGxheSA9IChsID09PSBsaXN0KSA/ICdibG9jaycgOiAnbm9uZScpO1xuICAgIH0pO1xuICB9XG5cbiAgc2V0dXBGaWx0ZXJPYmplY3QoaW5kZXgsIGJ0biwgZmlsdGVyTW9kYWxCdXR0b24sIGxpc3QpIHtcbiAgICB0aGlzLmZpbHRlcnNbaW5kZXhdID0geyBidG5BcnI6IFtidG4sIGZpbHRlck1vZGFsQnV0dG9uXSwgbGlzdDogbGlzdCB9O1xuICB9XG5cbiAgYmluZEZpbHRlckJ1dHRvbkNsaWNrKGJ0biwgZmlsdGVyTW9kYWxCdXR0b24sIGxpc3QsIGZpbHRlckJ0bkFyciwgbGlzdHNBcnIpIHtcbiAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB0aGlzLnNob3dGaWx0ZXJNb2RhbCgpO1xuICAgICAgZmlsdGVyQnRuQXJyLmZvckVhY2goYnRuID0+IGJ0bi5jbGFzc0xpc3QucmVtb3ZlKCctLWFjdGl2ZScpKTtcbiAgICAgIGxpc3RzQXJyLmZvckVhY2gobCA9PiBsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZScpO1xuICAgICAgZmlsdGVyTW9kYWxCdXR0b24uY2xhc3NMaXN0LmFkZCgnLS1hY3RpdmUnKTtcbiAgICAgIGxpc3Quc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfSk7XG4gIH1cblxuICB1bndyYXBGaWx0ZXJzKCkge1xuICAgIGNvbnN0IGdyb3VwcyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucGFnZS1maWx0ZXJzX19ncm91cCcpXTtcbiAgICBncm91cHMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgICB3aGlsZSAoZ3JvdXAuZmlyc3RDaGlsZCkge1xuICAgICAgICBncm91cC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShncm91cC5maXJzdENoaWxkLCBncm91cCk7XG4gICAgICB9XG4gICAgICBncm91cC5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJpbmRUb3VjaEV2ZW50cygpIHtcbiAgICBsZXQgc3RhcnRZID0gMDtcbiAgICBsZXQgY3VycmVudFkgPSAwO1xuICAgIGxldCBpc0RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmZpbHRlck1vZGFsO1xuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmZpbHRlck1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5maWx0ZXItbW9kYWxfX2hlYWRlcicpO1xuXG4gICAgaGFuZGxlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKGUpID0+IHtcbiAgICAgIHN0YXJ0WSA9IGUudG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICBjb250YWluZXIuc3R5bGUudHJhbnNpdGlvbiA9ICdub25lJztcbiAgICB9KTtcblxuICAgIGhhbmRsZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgKGUpID0+IHtcbiAgICAgIGlmICghaXNEcmFnZ2luZykgcmV0dXJuO1xuICAgICAgY3VycmVudFkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgIGxldCBkaWZmWSA9IGN1cnJlbnRZIC0gc3RhcnRZO1xuXG4gICAgICBpZiAoZGlmZlkgPiAwKSB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgke2RpZmZZfXB4KWA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBoYW5kbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKCkgPT4ge1xuICAgICAgaWYgKCFpc0RyYWdnaW5nKSByZXR1cm47XG4gICAgICBpc0RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgIGxldCBkaWZmWSA9IGN1cnJlbnRZIC0gc3RhcnRZO1xuICAgICAgbGV0IGhpZGVPZmZzZXQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0ICogMC41O1xuICAgICAgY29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb24gPSAnYWxsIC4zNXMgZWFzZSc7XG5cbiAgICAgIGlmIChkaWZmWSA+IGhpZGVPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5oaWRlRmlsdGVyTW9kYWwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgwJSlgO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYmluZENsaWNrRXZlbnRzKCkge1xuICAgIGNvbnN0IGNsb3NlQXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWV2dD1cImNsb3NlRmlsdGVyTW9kYWxcIl0nKV07XG4gICAgY2xvc2VBcnIuZm9yRWFjaChjbG9zZSA9PiB7XG4gICAgICBjbG9zZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuaGlkZUZpbHRlck1vZGFsKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgZm9ybWF0R29sZENoYWluc1N1YmhlYWRpbmcoKSB7XG4gICAgY29uc3Qgc3ViaGVhZGluZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZXN1bHRzX19zdWJoZWFkaW5nJylcbiAgICBpZiAoc3ViaGVhZGluZykge1xuICAgICAgY29uc3QgdGV4dCA9ICdXZWxjb21lIHRvIG91ciBjb2xsZWN0aW9uIG9mIGZpbmUgMTRrIHNvbGlkIGdvbGQgY2hhaW5zLCB3aGVyZSBsdXh1cnkgbWVldHMgYWZmb3JkYWJpbGl0eSdcbiAgICAgIGlmIChzdWJoZWFkaW5nLmlubmVySFRNTC5pbmNsdWRlcyh0ZXh0KSkge1xuICAgICAgICBjb25zdCBzZW50ZW5jZXMgPSBzdWJoZWFkaW5nLmlubmVySFRNTC5zcGxpdCgnLicpLmZpbHRlcihzZW50ZW5jZSA9PiBzZW50ZW5jZS50cmltKCkgIT09ICcnKVxuICAgICAgICBpZiAoc2VudGVuY2VzWzBdID09PSB0ZXh0KSB7XG4gICAgICAgICAgc3ViaGVhZGluZy5pbm5lckhUTUwgPSBgXG4gICAgICAgICAgPHN0cm9uZz4ke3RleHR9Ljwvc3Ryb25nPlxuICAgICAgICAgICR7c2VudGVuY2VzLnNsaWNlKDEpLmpvaW4oJy4gJyl9XG4gICAgICAgICAgYFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0U3RpY2t5QmFyKCkge1xuICAgIGNvbnN0IGJhciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLWZpbHRlcnMnKTtcbiAgICBpZiAoIWJhcikgcmV0dXJuO1xuXG4gICAgbGV0IHRvcE9mZnNldCA9IDA7XG5cbiAgICBjb25zdCB0b3BCYW5uZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudG9wLWJhbm5lcicpO1xuICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5oZWFkZXInKTtcblxuICAgIGlmICh0b3BCYW5uZXIpIHtcbiAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0b3BCYW5uZXIpLnBvc2l0aW9uID09PSAnc3RpY2t5Jykge1xuICAgICAgICBjb25zdCBiYW5uZXJIZWlnaHQgPSB0b3BCYW5uZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBpZiAoYmFubmVySGVpZ2h0ID4gMCkge1xuICAgICAgICAgIHRvcE9mZnNldCArPSBiYW5uZXJIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICB0b3BPZmZzZXQgKz0gaGVhZGVyLm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAodG9wT2Zmc2V0ID4gMCkge1xuICAgICAgYmFyLnN0eWxlLnBvc2l0aW9uID0gJ3N0aWNreSc7XG4gICAgICBiYXIuc3R5bGUudG9wID0gYCR7dG9wT2Zmc2V0fXB4YDtcbiAgICB9XG4gIH1cblxuICBhZGp1c3RTdGlja3lCYXJPblJlc2l6ZSgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5kZWJvdW5jZSgoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0aWNreUJhcigpO1xuICAgIH0sIDEwMCkpXG4gIH1cblxuICBmb3JtYXRGaWx0ZXJUaXRsZXMoKSB7XG4gICAgY29uc3QgYXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wYWdlLWZpbHRlci1idG4nKV1cbiAgICBmb3IgKGNvbnN0IGJ0biBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHNwYW4gPSBidG4ucXVlcnlTZWxlY3Rvcignc3BhbjpmaXJzdC1jaGlsZCcpXG4gICAgICBpZiAoc3Bhbikge1xuICAgICAgICBjb25zdCByYXdOYW1lID0gc3Bhbi5pbm5lclRleHQudG9Mb3dlckNhc2UoKVxuICAgICAgICBjb25zdCBuYW1lID0gKHJhd05hbWUuaW5jbHVkZXMoJ3N1YmNhdGVnb3JpZXMnKSB8fCByYXdOYW1lLmluY2x1ZGVzKCdzdWJjYXRlZ29yeScpKSA/ICdTdWJjYXRlZ29yaWVzJyA6XG4gICAgICAgICAgKHJhd05hbWUuaW5jbHVkZXMoJ3ByaWNlJykgfHwgcmF3TmFtZS5pbmNsdWRlcygncHJpY2UgcmFuZ2UnKSkgPyAnUHJpY2UnIDogcmF3TmFtZTtcblxuICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpICE9PSByYXdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBzcGFuLmlubmVyVGV4dCA9IG5hbWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFZpZXdcbiAgc3dpdGNoVmlldyhtb2RlKSB7XG4gICAgaWYgKCF0aGlzLmNhcmRzR3JpZCkgcmV0dXJuXG5cbiAgICBjb25zdCBpc0xlc3MgPSBtb2RlID09PSAnbGVzcydcbiAgICB0aGlzLmNhcmRzR3JpZC5jbGFzc0xpc3QuYWRkKCctLWhpZGRlbicpXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY2FyZHNHcmlkLmNsYXNzTGlzdC50b2dnbGUoJy0tbGVzcycsIGlzTGVzcylcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmNhcmRzR3JpZC5jbGFzc0xpc3QucmVtb3ZlKCctLWhpZGRlbicpXG4gICAgICB9LCAxMDApXG4gICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUodGhpcy5jYXJkc0dyaWQpKVxuICB9XG5cbiAgYmluZFZpZXdTd2l0Y2goKSB7XG4gICAgY29uc3QgYnV0dG9ucyA9IHtcbiAgICAgIG1vcmU6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXJlc3VsdHMtZXZ0PVwidmlld01vcmVcIl0nKSxcbiAgICAgIGxlc3M6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXJlc3VsdHMtZXZ0PVwidmlld0xlc3NcIl0nKVxuICAgIH07XG5cbiAgICBjb25zdCB0b2dnbGVWaWV3ID0gKGFjdGl2ZUJ0biwgaW5hY3RpdmVCdG4sIG1vZGUpID0+IHtcbiAgICAgIGlmICghYWN0aXZlQnRuLmNsYXNzTGlzdC5jb250YWlucygnaXMtYWN0aXZlJykpIHtcbiAgICAgICAgYWN0aXZlQnRuLmNsYXNzTGlzdC5hZGQoJ2lzLWFjdGl2ZScpO1xuICAgICAgICBpbmFjdGl2ZUJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdpcy1hY3RpdmUnKTtcbiAgICAgICAgdGhpcy5zd2l0Y2hWaWV3KG1vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoYnV0dG9ucy5tb3JlICYmIGJ1dHRvbnMubGVzcykge1xuICAgICAgYnV0dG9ucy5tb3JlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdG9nZ2xlVmlldyhidXR0b25zLm1vcmUsIGJ1dHRvbnMubGVzcywgJ21vcmUnKSk7XG4gICAgICBidXR0b25zLmxlc3MuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0b2dnbGVWaWV3KGJ1dHRvbnMubGVzcywgYnV0dG9ucy5tb3JlLCAnbGVzcycpKTtcbiAgICB9XG4gIH1cblxuICAvLyBPdGhlclxuICBiaW5kQ2FyZU1vZGFsKCkge1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FyZS1tb2RhbCcpKSB7XG4gICAgICB0aGlzLmNhcmVNb2RhbEluc3RhbmNlID0gbmV3IENhcmVNb2RhbCgpXG4gICAgfVxuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBpZiAod2luZG93LmlubmVyV2lkdGggPiA5OTEpIHtcbiAgICAgIHRoaXMuc2V0dXBEZXNrdG9wRmlsdGVycygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldHVwTW9iaWxlRmlsdGVycygpO1xuICAgICAgdGhpcy51bndyYXBGaWx0ZXJzKCk7XG4gICAgICB0aGlzLmJpbmRUb3VjaEV2ZW50cygpO1xuICAgICAgdGhpcy5iaW5kQ2xpY2tFdmVudHMoKTtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlRmlsdGVycygpO1xuICAgIHRoaXMuZm9ybWF0R29sZENoYWluc1N1YmhlYWRpbmcoKVxuICAgIHRoaXMuc2V0U3RpY2t5QmFyKClcbiAgICB0aGlzLmFkanVzdFN0aWNreUJhck9uUmVzaXplKClcbiAgICB0aGlzLmZvcm1hdEZpbHRlclRpdGxlcygpXG4gICAgdGhpcy5iaW5kVmlld1N3aXRjaCgpXG4gICAgdGhpcy5iaW5kQ2FyZU1vZGFsKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3VsdHNQYWdlOyIsImNvbnN0IHNlbGxQYWdlID0ge1xuICBmYXFJdGVtczogWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zZWxsLWZhcS1pdGVtJyldLFxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmFxSXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmF0dGFjaEZhcSgpXG4gICAgICAkKCcuc2VsbC1mYXEtaXRlbV9fbWFpbicpLmVxKDApLnRyaWdnZXIoJ2NsaWNrJylcbiAgICB9XG4gIH0sXG4gIGF0dGFjaEZhcTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmFxSXRlbXMuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICAkKGVsKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBtYWluID0gJCh0aGlzKS5maW5kKCcuc2VsbC1mYXEtaXRlbV9fbWFpbicpLFxuICAgICAgICAgIHAgPSAkKHRoaXMpLmZpbmQoJ3AnKSwgc3ZnID0gJCh0aGlzKS5maW5kKCdzdmcnKVxuICAgICAgICBpZiAobWFpbi5oZWlnaHQoKSA9PSAwKSB7XG4gICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhJU19BQ1RJVkUpXG4gICAgICAgICAgbWFpbi5jc3MoeyBoZWlnaHQ6IGAke3BbMF0uc2Nyb2xsSGVpZ2h0fXB4YCB9KVxuICAgICAgICAgIHN2Zy5jc3MoeyB0cmFuc2Zvcm06ICdyb3RhdGUoMTgwZGVnKScgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKElTX0FDVElWRSlcbiAgICAgICAgICBtYWluLmNzcyh7IGhlaWdodDogYDBweGAgfSlcbiAgICAgICAgICBzdmcuY3NzKHsgdHJhbnNmb3JtOiAncm90YXRlKDBkZWcpJyB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZWxsUGFnZSIsImNsYXNzIFNlbGxXYXRjaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Zvcm0jc2VsbF9teV93YXRjaCcpXG4gICAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnNlY3Rpb25zQXJyID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWFzay1zZWN0aW9uXScpXVxuICAgIHRoaXMucHJvZ3Jlc3NCYXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXNrLXBhZ2VfX3Byb2dyZXNzLWJhcicpXG4gICAgdGhpcy5jdXJyZW50U3RlcEVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zdGVwLWN1cnJlbnRdJylcbiAgICB0aGlzLmNvdW50U3RlcEVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zdGVwLWNvdW50XScpXG4gICAgdGhpcy5jb250ZW50Q29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFzay1wYWdlX19xdWl6LWNvbnRlbnQnKVxuICAgIHRoaXMuYWRqdXN0Q29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFzay1wYWdlX19xdWl6LWFkanVzdCcpXG5cbiAgICB0aGlzLmZvY3VzZWRFbCA9IHVuZGVmaW5lZFxuICAgIHRoaXMud2F0Y2hCcmFuZCA9IHtcbiAgICAgIG5hbWU6IHVuZGVmaW5lZFxuICAgIH1cbiAgICB0aGlzLnVwbG9hZElucHV0ID0gdGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJylcbiAgICB0aGlzLnJlZ0V4cCA9IHtcbiAgICAgIHJvbGV4OiAvXFxicm9sZXhcXGIvaSxcbiAgICAgIGF1ZGVtYXJzOiAvXFxiYXVkZW1hcnNcXGIvaSxcbiAgICAgIHJpY2hhcmQ6IC9cXGJyaWNoYXJkXFxiL2ksXG4gICAgICBwYXRlazogL1xcYnBhdGVrXFxiL2ksXG4gICAgICBjYXJ0aWVyOiAvXFxiY2FydGllclxcYi9pLFxuICAgICAgYnJlaXRsaW5nOiAvXFxiYnJlaXRsaW5nXFxiL2lcbiAgICB9XG5cbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlXG4gICAgdGhpcy5zdGVwcyA9IHRoaXMuc2VjdGlvbnNBcnIubGVuZ3RoXG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IDFcbiAgICB0aGlzLmFjdGl2ZVNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zQXJyWzBdXG4gICAgdGhpcy5lbmRSZWFjaGVkID0gZmFsc2VcbiAgICB0aGlzLmF0VGhlU3RhcnQgPSB0cnVlXG4gICAgdGhpcy5pbml0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXR0ZXJzXG4gICAqL1xuICBnZXQgZ2V0QWN0aXZlU2VjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTZWN0aW9uXG4gIH1cbiAgZ2V0IGdldEN1cnJlbnRTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGVwXG4gIH1cbiAgZ2V0IGdldEZvY3VzZWRFbCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1c2VkRWxcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2RzXG4gICAqL1xuICB0b2dnbGVTZWN0aW9uU3RhdHVzKHNlY3Rpb24sIGNvbmRpdGlvbikge1xuICAgIGlmIChjb25kaXRpb24gPT09IGZhbHNlKSB7XG4gICAgICBzZWN0aW9uLmNsYXNzTGlzdC5yZW1vdmUoX19WQUxJRClcbiAgICB9IGVsc2Uge1xuICAgICAgc2VjdGlvbi5jbGFzc0xpc3QuYWRkKF9fVkFMSUQpXG4gICAgfVxuICAgIGNvbnN0IGJ0biA9IFsuLi5zZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNlbGwtZXZ0PVwibmV4dFwiXScpXVxuICAgIGJ0bi5mb3JFYWNoKGJ0biA9PiBidG4uZGlzYWJsZWQgPSAhY29uZGl0aW9uKVxuICB9XG4gIHZhbGlkYXRlU2VjdGlvbihzZWN0aW9uKSB7XG4gICAgc2VjdGlvbiA9IHRoaXMuZ2V0QWN0aXZlU2VjdGlvblxuXG4gICAgY29uc3RcbiAgICAgIHJlcXVpcmVkQXJyID0gWy4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnW3JlcXVpcmVkXTpub3QoW2Rpc2FibGVkXSknKV0sXG4gICAgICByYWRpb0FyciA9IFsuLi5zZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXTpub3QoW2Rpc2FibGVkXSknKV0sXG4gICAgICBjaGVja2JveEFyciA9IFsuLi5zZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXTpub3QoW2Rpc2FibGVkXSknKV0sXG4gICAgICBpbnB1dEFyciA9IFsuLi5zZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Om5vdChbdHlwZT1cImNoZWNrYm94XCJdKTpub3QoW3R5cGU9XCJyYWRpb1wiXSknKV0sXG4gICAgICBzZWxlY3RBcnIgPSBbLi4uc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3RbcmVxdWlyZWRdJyldLFxuICAgICAgcGhvbmVBcnIgPSBbLi4uc2VjdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS12YWxpZGF0ZT1cInBob25lXCJdJyldLFxuICAgICAgZmlsZUFyciA9IFsuLi5zZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJmaWxlXCJdJyldXG5cbiAgICBjb25zdCByYWRpb0FyckJ5TmFtZSA9IEFycmF5LmZyb20oXG4gICAgICBuZXcgU2V0KHJhZGlvQXJyLm1hcChyYWRpbyA9PiByYWRpby5uYW1lKSksXG4gICAgICBuYW1lID0+IHJhZGlvQXJyLmZpbHRlcihyYWRpbyA9PiByYWRpby5uYW1lID09PSBuYW1lKVxuICAgIClcblxuICAgIGlmIChyZXF1aXJlZEFyci5zb21lKGlucHV0ID0+ICFpbnB1dC52YWx1ZSkpIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VjdGlvblN0YXR1cyhzZWN0aW9uLCBmYWxzZSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgcmFkaW9Hcm91cCBvZiByYWRpb0FyckJ5TmFtZSkge1xuICAgICAgaWYgKHJhZGlvR3JvdXAuZXZlcnkocmFkaW8gPT4gIXJhZGlvLmNoZWNrZWQpKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlU2VjdGlvblN0YXR1cyhzZWN0aW9uLCBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrYm94QXJyLmxlbmd0aCAmJiBjaGVja2JveEFyci5ldmVyeShjaGVja2JveCA9PiAhY2hlY2tib3guY2hlY2tlZCkpIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VjdGlvblN0YXR1cyhzZWN0aW9uLCBmYWxzZSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChwaG9uZUFyci5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgcGhvbmVBcnIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZVxuICAgICAgICBjb25zdCB2YWx1ZURpZ2l0cyA9IHZhbHVlLnJlcGxhY2UoL1xcRC9nLCAnJykubGVuZ3RoXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gL15cXCtcXGR7MX1cXHNcXChcXGR7M31cXClcXHNcXGR7M31cXC1cXGR7NH0kL1xuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QodmFsdWUpICYmIHZhbHVlRGlnaXRzIDwgMTEpIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZVNlY3Rpb25TdGF0dXMoc2VjdGlvbiwgZmFsc2UpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGZpbGVJbnB1dCBvZiBmaWxlQXJyKSB7XG4gICAgICBjb25zdCBmaWxlcyA9IGZpbGVJbnB1dC5maWxlc1xuICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy50b2dnbGVTZWN0aW9uU3RhdHVzKHNlY3Rpb24sIGZhbHNlKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRvZ2dsZVNlY3Rpb25TdGF0dXMoc2VjdGlvbiwgdHJ1ZSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGFycmFuZ2VNb2RlbHMoc3RyaW5nKSB7XG4gICAgY29uc3RcbiAgICAgIGlucHV0QXJyID0gWy4uLnRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIm1vZGVsXCJdJyldLFxuICAgICAgZ3JvdXBJbnB1dEFyciA9IGlucHV0QXJyLmZpbHRlcihpbnB1dCA9PiBpbnB1dC5kYXRhc2V0Lmdyb3VwKSxcbiAgICAgIGZpbHRlcmVkQXJyID0gZ3JvdXBJbnB1dEFyci5maWx0ZXIoaW5wdXQgPT4geyByZXR1cm4gc3RyaW5nLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaW5wdXQuZGF0YXNldC5ncm91cCkgfSksXG4gICAgICBtb2RlbEdyaWQgPSB0aGlzLmZvcm0ucXVlcnlTZWxlY3RvcignW2RhdGEtc2VsbC1ncmlkPVwibW9kZWxcIl0nKSxcbiAgICAgIG1vZGVsSW5wdXQgPSB0aGlzLmZvcm0ucXVlcnlTZWxlY3RvcignaW5wdXQjd2F0Y2hfbW9kZWwnKSxcbiAgICAgIG1vZGVsSW5wdXRQYXJlbnQgPSBtb2RlbElucHV0LmNsb3Nlc3QoJy5zdXJ2ZXktYm94X19uYW1lZC1ncmlkJylcblxuICAgIGlucHV0QXJyLmZvckVhY2goaW5wdXQgPT4gaW5wdXQuY2hlY2tlZCA9IGZhbHNlKVxuICAgIC8vIGlucHV0QXJyLmZvckVhY2goaW5wdXQgPT4gaW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKSlcbiAgICBtb2RlbElucHV0LnZhbHVlID0gJydcbiAgICBtb2RlbElucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcpKVxuXG4gICAgaWYgKCFmaWx0ZXJlZEFyci5sZW5ndGgpIHtcbiAgICAgIG1vZGVsR3JpZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICBtb2RlbElucHV0UGFyZW50LnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbiAgICAgIG1vZGVsSW5wdXQuZGlzYWJsZWQgPSBmYWxzZVxuICAgICAgaW5wdXRBcnIuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIGlucHV0LmRpc2FibGVkID0gdHJ1ZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gZmFsc2VcbiAgICAgICAgLy8gaW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWxHcmlkLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbiAgICAgIG1vZGVsSW5wdXRQYXJlbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgbW9kZWxJbnB1dC5kaXNhYmxlZCA9IHRydWVcbiAgICAgIGlucHV0QXJyLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGlucHV0LmNsb3Nlc3QoJ2xhYmVsJylcbiAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSBmYWxzZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gZmFsc2VcbiAgICAgICAgaWYgKCFmaWx0ZXJlZEFyci5pbmNsdWRlcyhpbnB1dCkgJiYgaW5wdXQudmFsdWUgIT09ICdPdGhlcicpIHtcbiAgICAgICAgICBpZiAoaW5wdXQudmFsdWUpIHtcbiAgICAgICAgICAgIGxhYmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFiZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsc1xuICAgKi9cbiAgb2JzZXJ2ZVN0ZXBzRWxlbWVudHMoKSB7XG4gICAgdGhpcy5jdXJyZW50U3RlcEVsZW0uaW5uZXJIVE1MID0gdGhpcy5jdXJyZW50U3RlcFxuICB9XG4gIG9ic2VydmVCYXJFbGVtZW50cygpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMucHJvZ3Jlc3NCYXIucXVlcnlTZWxlY3RvckFsbCgnc3BhbicpXG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCA8IHRoaXMuY3VycmVudFN0ZXApIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKF9fQUNUSVZFKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKF9fQUNUSVZFKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgc2Nyb2xsVG9Gb3JtKCkge1xuICAgIGlmICh0aGlzLmZvcm0pIHtcbiAgICAgIGNvbnN0IGhlYWRlckhlaWdodCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWRlcicpKS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKSlcbiAgICAgIGNvbnN0IGJvdW5kVG9wID0gdGhpcy5mb3JtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICAgICAgaWYgKChib3VuZFRvcCAtIGhlYWRlckhlaWdodCkgPCAtMzApIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSAod2luZG93LnNjcm9sbFkgKyB0aGlzLmZvcm0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSAtIChoZWFkZXJIZWlnaHQgKyA3MClcbiAgICAgICAgemVuc2Nyb2xsLnRvWShkaXN0YW5jZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2hGb2N1c0V2ZW50KGVsZW0pIHtcbiAgICBpZiAoZWxlbSkge1xuICAgICAgY29uc3QgdGFnID0gZWxlbS50YWdOYW1lXG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlICdJTlBVVCcgfHwgJ1RFWFRBUkVBJzpcbiAgICAgICAgICBjb25zdCB0eXBlID0gZWxlbS50eXBlXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgICAgZWxlbS5jbGljaygpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgICAgZWxlbS5jbGljaygpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtLmZvY3VzKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NFTEVDVCc6XG4gICAgICAgICAgZWxlbS5mb2N1cygpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZWxlbS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZm9jdXMnKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZlbnRzXG4gICAqL1xuICBzbGlkZShzZWN0aW9uLCBhY3RpdmVTZWN0aW9uLCBudW1iZXIpIHtcbiAgICBjb25zdCBzZWN0aW9uSW5kZXggPSB0aGlzLnNlY3Rpb25zQXJyLmluZGV4T2Yoc2VjdGlvbilcbiAgICBjb25zdCBhY3RpdmVTZWN0aW9uSW5kZXggPSB0aGlzLnNlY3Rpb25zQXJyLmluZGV4T2YoYWN0aXZlU2VjdGlvbilcblxuICAgIGxldCBmcm9tVHJhbnNsYXRlID0gJ3RyYW5zbGF0ZVkoMjRweCknXG4gICAgbGV0IHRvVHJhbnNsYXRlID0gJ3RyYW5zbGF0ZVkoLTI0cHgpJ1xuXG4gICAgaWYgKGFjdGl2ZVNlY3Rpb25JbmRleCA+IHNlY3Rpb25JbmRleCkge1xuICAgICAgZnJvbVRyYW5zbGF0ZSA9ICd0cmFuc2xhdGVZKC0yNHB4KSdcbiAgICAgIHRvVHJhbnNsYXRlID0gJ3RyYW5zbGF0ZVkoMjRweCknXG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IFsuLi5hY3RpdmVTZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JyldXG4gICAgfVxuXG4gICAgdGhpcy5sb2NrZWQgPSB0cnVlXG4gICAgYWN0aXZlU2VjdGlvbi5zdHlsZS5vcGFjaXR5ID0gMFxuICAgIGFjdGl2ZVNlY3Rpb24uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJ1xuICAgIGFjdGl2ZVNlY3Rpb24uc3R5bGUudHJhbnNmb3JtID0gdG9UcmFuc2xhdGVcbiAgICBzZWN0aW9uLnN0eWxlLm9wYWNpdHkgPSAwXG4gICAgc2VjdGlvbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnXG4gICAgc2VjdGlvbi5zdHlsZS50cmFuc2Zvcm0gPSBmcm9tVHJhbnNsYXRlXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBhY3RpdmVTZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgIGFjdGl2ZVNlY3Rpb24uY2xhc3NMaXN0LnJlbW92ZShfX0FDVElWRSlcbiAgICAgIHNlY3Rpb24uc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xuICAgICAgc2VjdGlvbi5jbGFzc0xpc3QuYWRkKF9fQUNUSVZFKVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNlY3Rpb24uc3R5bGUub3BhY2l0eSA9IDFcbiAgICAgICAgc2VjdGlvbi5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgwcHgpJ1xuICAgICAgICBzZWN0aW9uLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0bydcblxuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlXG4gICAgICAgIHRoaXMuYWN0aXZlU2VjdGlvbiA9IHNlY3Rpb25cbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IG51bWJlclxuICAgICAgICB0aGlzLm9ic2VydmVTdGVwc0VsZW1lbnRzKClcbiAgICAgICAgdGhpcy5vYnNlcnZlQmFyRWxlbWVudHMoKVxuXG4gICAgICAgIGlmIChzZWN0aW9uID09PSB0aGlzLnNlY3Rpb25zQXJyW3RoaXMuc2VjdGlvbnNBcnIubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICB0aGlzLmZvcm0uc3VibWl0KClcbiAgICAgICAgfVxuICAgICAgfSwgMzApXG4gICAgfSwgZ2V0VHJhbnNpdGlvblRpbWUoYWN0aXZlU2VjdGlvbikpXG4gIH1cbiAgZmluaXNoKCkge1xuICAgIGNvbnN0IGNvbmZldHRpID0gbmV3IFBhZ2VDb25mZXR0aSgpXG4gICAgY29uZmV0dGkucHVzaCgpXG4gIH1cbiAgZ28obnVtYmVyKSB7XG4gICAgaWYgKCF0aGlzLmxvY2tlZCkge1xuICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuc2VjdGlvbnNBcnJbbnVtYmVyIC0gMV1cbiAgICAgIGNvbnN0IGFjdGl2ZVNlY3Rpb24gPSB0aGlzLmdldEFjdGl2ZVNlY3Rpb25cblxuICAgICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbnVtYmVyIDwgMSA/ICdTZWN0aW9uIG51bWJlciBjYW5ub3QgYmUgbGVzcyB0aGFuIDEnIDogJ1NlY3Rpb24gbnVtYmVyIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJyArIHRoaXMuc2VjdGlvbnNBcnIubGVuZ3RoXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcilcbiAgICAgIH1cbiAgICAgIGlmICghYWN0aXZlU2VjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBzZWN0aW9uJylcbiAgICAgIH1cblxuICAgICAgaWYgKHNlY3Rpb24gIT09IGFjdGl2ZVNlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zbGlkZShzZWN0aW9uLCBhY3RpdmVTZWN0aW9uLCBudW1iZXIpXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9Gb3JtKClcbiAgICAgICAgdGhpcy5mb2N1c2VkRWwgPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBCaW5kIEV2ZW50c1xuICAgKi9cbiAgYmluZFRvZ2dsZVN0ZXBzQ29udHJvbHMoKSB7XG4gICAgZm9yIChjb25zdCBzZWN0aW9uIG9mIHRoaXMuc2VjdGlvbnNBcnIpIHtcbiAgICAgIGNvbnN0IGlucHV0cyA9IFsuLi5zZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBzZWxlY3QnKV1cbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBjb25zdCBpc0NoZWNrYm94T3JSYWRpbyA9IGlucHV0LnR5cGUgPT09ICdjaGVja2JveCcgfHwgaW5wdXQudHlwZSA9PT0gJ3JhZGlvJyB8fCBpbnB1dC50eXBlID09PSAnZmlsZSdcbiAgICAgICAgaWYgKGlzQ2hlY2tib3hPclJhZGlvKSB7XG4gICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTZWN0aW9uKHNlY3Rpb24pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlU2VjdGlvbihzZWN0aW9uKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGJpbmREdWFsU2VsZWN0KCkge1xuICAgIGNvbnN0IGR1YWxBcnIgPSBbLi4udGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W2RhdGEtZHVhbF0nKV1cbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGR1YWxBcnIpIHtcbiAgICAgIGNvbnN0XG4gICAgICAgIG5hbWUgPSBpbnB1dC5uYW1lLFxuICAgICAgICBkdWFsTmFtZSA9IGlucHV0LmRhdGFzZXQuZHVhbCxcbiAgICAgICAgbmFtZUlucHV0QXJyID0gWy4uLnRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKGBpbnB1dFtuYW1lPVwiJHtuYW1lfVwiXWApXSxcbiAgICAgICAgaG9sZGVyID0gdGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3IoYGRpdltkYXRhLWR1YWw9XCIke2R1YWxOYW1lfVwiXWApXG5cbiAgICAgIGlmIChob2xkZXIpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ID0gaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdCwgaW5wdXQnKVxuICAgICAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAgICAgbmFtZUlucHV0QXJyLmZvckVhY2goKG5hbWVJbnB1dCkgPT4ge1xuICAgICAgICAgICAgbmFtZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3QuZGlzYWJsZWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0LmRpc2FibGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBiaW5kQnJhbmRTZWxlY3QoKSB7XG4gICAgY29uc3QgYnJhbmRTZWxlY3RBcnIgPSBbLi4udGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJypbbmFtZT1cImJyYW5kXCJdJyldXG4gICAgY29uc3QgZWxzVG9OYW1lID0gWy4uLnRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zZWxsLWJyYW5kXScpXVxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgYnJhbmRTZWxlY3RBcnIpIHtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICAgIGlmIChpbnB1dC5kaXNhYmxlZCkgcmV0dXJuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5wdXQudmFsdWVcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgIT09ICdvdGhlcicpIHtcbiAgICAgICAgICB0aGlzLndhdGNoQnJhbmQubmFtZSA9IHZhbHVlXG4gICAgICAgICAgZWxzVG9OYW1lLmZvckVhY2goZWwgPT4gZWwuaW5uZXJIVE1MID0gdGhpcy53YXRjaEJyYW5kLm5hbWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy53YXRjaEJyYW5kLm5hbWUgPSB1bmRlZmluZWRcbiAgICAgICAgICBlbHNUb05hbWUuZm9yRWFjaChlbCA9PiBlbC5pbm5lckhUTUwgPSAneW91ciBicmFuZCcpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR1cCBtb2RlbHNcbiAgICAgICAgdGhpcy5hcnJhbmdlTW9kZWxzKHZhbHVlKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZFBob25lSW5wdXQoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gWy4uLnRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtkYXRhLXZhbGlkYXRlPVwicGhvbmVcIl0nKV1cbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgbGV0IGtleUNvZGU7XG4gICAgICBmdW5jdGlvbiBtYXNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LmtleUNvZGUgJiYgKGtleUNvZGUgPSBldmVudC5rZXlDb2RlKTtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGlmIChwb3MgPCAzKSBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGxldCBtYXRyaXggPSBcIisxIChfX18pIF9fXy1fX19fXCIsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgZGVmID0gbWF0cml4LnJlcGxhY2UoL1xcRC9nLCBcIlwiKSxcbiAgICAgICAgICB2YWwgPSB0aGlzLnZhbHVlLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSxcbiAgICAgICAgICBuZXdWYWx1ZSA9IG1hdHJpeC5yZXBsYWNlKC9bX1xcZF0vZywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBpIDwgdmFsLmxlbmd0aCA/IHZhbC5jaGFyQXQoaSsrKSB8fCBkZWYuY2hhckF0KGkpIDogYTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgaSA9IG5ld1ZhbHVlLmluZGV4T2YoXCJfXCIpO1xuICAgICAgICBpZiAoaSAhPSAtMSkge1xuICAgICAgICAgIGkgPCA1ICYmIChpID0gMyk7XG4gICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVnID0gbWF0cml4LnN1YnN0cigwLCB0aGlzLnZhbHVlLmxlbmd0aCkucmVwbGFjZSgvXysvZyxcbiAgICAgICAgICBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXGR7MSxcIiArIGEubGVuZ3RoICsgXCJ9XCI7XG4gICAgICAgICAgfSkucmVwbGFjZSgvWysoKV0vZywgXCJcXFxcJCZcIik7XG4gICAgICAgIHJlZyA9IG5ldyBSZWdFeHAoXCJeXCIgKyByZWcgKyBcIiRcIik7XG4gICAgICAgIGlmICghcmVnLnRlc3QodGhpcy52YWx1ZSkgfHwgdGhpcy52YWx1ZS5sZW5ndGggPCA1IHx8IGtleUNvZGUgPiA0NyAmJiBrZXlDb2RlIDwgNTgpIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJibHVyXCIgJiYgdGhpcy52YWx1ZS5sZW5ndGggPCA1KSB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgIH1cblxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIG1hc2ssIGZhbHNlKTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBtYXNrLCBmYWxzZSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBtYXNrLCBmYWxzZSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBtYXNrLCBmYWxzZSk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGlmIChpbnB1dC52YWx1ZS5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoNCwgNClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShpbnB1dC52YWx1ZS5sZW5ndGgsIGlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZEN1cnJlbmN5SW5wdXQoKSB7XG4gICAgY29uc3QgaW5wdXRBcnIgPSBbLi4udGhpcy5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W2RhdGEtZm9ybWF0PVwiY3VycmVuY3lcIl0nKV1cbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0QXJyKSB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKCkgPT4ge1xuICAgICAgICBpZiAoaW5wdXQudmFsdWUpIHtcbiAgICAgICAgICBpbnB1dC52YWx1ZSA9IGZvcm1hdEFzQ3VycmVuY3koaW5wdXQudmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGJpbmRIYW5kbGVycygpIHtcbiAgICBjb25zdCBuZXh0QXJyID0gWy4uLnRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zZWxsLWV2dD1cIm5leHRcIl0nKV1cbiAgICBjb25zdCBiYWNrQXJyID0gWy4uLnRoaXMuZm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zZWxsLWV2dD1cImJhY2tcIl0nKV1cblxuICAgIGZvciAoY29uc3QgYnRuIG9mIG5leHRBcnIpIHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBpZiAoIWJ0bi5kaXNhYmxlZCkge1xuICAgICAgICAgIHRoaXMuZ28odGhpcy5nZXRDdXJyZW50U3RlcCArIDEpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBidG4gb2YgYmFja0Fycikge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGlmICghYnRuLmRpc2FibGVkKSB7XG4gICAgICAgICAgdGhpcy5nbyh0aGlzLmdldEN1cnJlbnRTdGVwIC0gMSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgYmluZFNldEZvY3VzZWRFbGVtZW50KCkge1xuICAgIGNvbnN0IGlucHV0cyA9IFsuLi50aGlzLmZvcm0ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKV1cbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4geyB0aGlzLmZvY3VzZWRFbCA9IGlucHV0IH0pXG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICgpID0+IHsgdGhpcy5mb2N1c2VkRWwgPSBpbnB1dCB9KVxuICAgIH1cbiAgfVxuICBiaW5kS2V5RXZlbnRzKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9ja2VkKSByZXR1cm5cbiAgICAgIGlmICghdGhpcy5nZXRBY3RpdmVTZWN0aW9uKSByZXR1cm5cblxuICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuZ2V0QWN0aXZlU2VjdGlvblxuICAgICAgY29uc3Qga2V5ID0gZS5rZXlcbiAgICAgIGNvbnN0IGtleUlzVGFiID0ga2V5ID09PSAnVGFiJ1xuICAgICAgY29uc3Qga2V5SXNFbnRlciA9IGtleSA9PT0gJ0VudGVyJ1xuICAgICAgY29uc3QgaXNCYWNrc3BhY2UgPSBrZXkgPT09ICdCYWNrc3BhY2UnXG5cbiAgICAgIGlmIChpc0JhY2tzcGFjZSkge1xuICAgICAgICBpZiAoIWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgIWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY29udGFpbnMoc2VjdGlvbikpIHJldHVyblxuICAgICAgICBjb25zdCBidG4gPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNlbGwtZXZ0PVwiYmFja1wiXScpXG4gICAgICAgIGlmIChidG4gJiYgIWJ0bi5kaXNhYmxlZCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgIGJ0bi5jbGljaygpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGtleUlzRW50ZXIpIHtcbiAgICAgICAgY29uc3QgYnRuID0gc2VjdGlvbi5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zZWxsLWV2dD1cIm5leHRcIl0nKVxuICAgICAgICBpZiAoYnRuKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgaWYgKCFidG4uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGJ0bi5jbGljaygpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlJc1RhYikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgY29uc3QgZm9jdXNlZEVsID0gdGhpcy5nZXRGb2N1c2VkRWxcbiAgICAgICAgY29uc3QgaW5wdXRzID0gWy4uLnNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKV0uZmlsdGVyKChpbnB1dCkgPT4ge1xuICAgICAgICAgIGlmICghaW5wdXQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdEJveCA9IGlucHV0LnBhcmVudE5vZGUuY2xvc2VzdCgnLnN1cnZleS1zZWxlY3QnKVxuICAgICAgICAgICAgaWYgKHNlbGVjdEJveCkge1xuICAgICAgICAgICAgICBpZiAoc2VsZWN0Qm94LnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaW5wdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLnNvcnQoKGEsIGIpID0+IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgLSAyKVxuICAgICAgICBsZXQgZWxlbVxuXG4gICAgICAgIGlmICghZm9jdXNlZEVsKSB7XG4gICAgICAgICAgZWxlbSA9IGlucHV0c1swXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGVsZW1XaXRoaW5TZWN0aW9uID0gaW5wdXRzLmluY2x1ZGVzKGZvY3VzZWRFbClcbiAgICAgICAgICBpZiAoZWxlbVdpdGhpblNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRFbGVtID0gaW5wdXRzW2lucHV0cy5pbmRleE9mKGZvY3VzZWRFbCkgKyAxXVxuICAgICAgICAgICAgaWYgKG5leHRFbGVtKSB7XG4gICAgICAgICAgICAgIGVsZW0gPSBuZXh0RWxlbVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbSA9IGlucHV0c1swXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtID0gaW5wdXRzWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEZvY3VzRXZlbnQoZWxlbSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGJpbmRTdWJtaXQoKSB7XG4gICAgJCh0aGlzLmZvcm0pLm9uKCdzdWJtaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGZvcm0gPSAkKHRoaXMpO1xuICAgICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRoaXMpO1xuICAgICAgdmFyIGFjdGlvblVybCA9IGZvcm0uYXR0cignYWN0aW9uJyk7XG4gICAgICAkLmFqYXgoe1xuICAgICAgICB1cmw6IGFjdGlvblVybCxcbiAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICBkYXRhOiBmb3JtRGF0YSxcbiAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICBjb250ZW50VHlwZTogZmFsc2UsXG4gICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICB2YXIgciA9ICQucGFyc2VKU09OKGRhdGEpO1xuICAgICAgICAgIGlmICghci5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3Nob3cgZXJyb3IgbWVzc2FnZSBcbiAgICAgICAgICAgIGFsZXJ0KHIubXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXBcbiAgICovXG4gIHNldHVwQmFyKCkge1xuICAgIGlmICh0aGlzLnByb2dyZXNzQmFyKSB7XG4gICAgICBsZXQgaHRtbCA9ICcnXG4gICAgICB0aGlzLnNlY3Rpb25zQXJyLmZvckVhY2goKHNlY3Rpb24sIGluZGV4KSA9PiB7XG4gICAgICAgIGh0bWwgKz0gYDxzcGFuIGRhdGEtYmFyLWlkPVwiJHtpbmRleH1cIj48L3NwYW4+YFxuICAgICAgfSlcbiAgICAgIHRoaXMucHJvZ3Jlc3NCYXIuaW5uZXJIVE1MID0gaHRtbFxuICAgIH1cbiAgICBpZiAodGhpcy5jdXJyZW50U3RlcEVsZW0gJiYgdGhpcy5jb3VudFN0ZXBFbGVtKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVwRWxlbS5pbm5lckhUTUwgPSAxXG4gICAgICB0aGlzLmNvdW50U3RlcEVsZW0uaW5uZXJIVE1MID0gdGhpcy5zZWN0aW9uc0Fyci5sZW5ndGhcbiAgICB9XG4gIH1cbiAgc2V0dXAoKSB7XG4gICAgdGhpcy5zZXR1cEJhcigpXG4gICAgdGhpcy5nbygxKVxuICAgIHRoaXMub2JzZXJ2ZVN0ZXBzRWxlbWVudHMoKVxuICAgIHRoaXMub2JzZXJ2ZUJhckVsZW1lbnRzKClcbiAgICB0aGlzLmJpbmRIYW5kbGVycygpXG4gIH1cblxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplXG4gICAqL1xuICBpbml0KCkge1xuICAgIGlmICh0aGlzLmZvcm0pIHtcbiAgICAgIHRoaXMuYmluZER1YWxTZWxlY3QoKVxuICAgICAgdGhpcy5iaW5kVG9nZ2xlU3RlcHNDb250cm9scygpXG4gICAgICB0aGlzLmJpbmRCcmFuZFNlbGVjdCgpXG4gICAgICB0aGlzLmJpbmRQaG9uZUlucHV0KClcbiAgICAgIHRoaXMuYmluZEN1cnJlbmN5SW5wdXQoKVxuICAgICAgdGhpcy5iaW5kU2V0Rm9jdXNlZEVsZW1lbnQoKVxuICAgICAgdGhpcy5iaW5kS2V5RXZlbnRzKClcbiAgICAgIHRoaXMuYmluZFN1Ym1pdCgpXG4gICAgICB0aGlzLnNldHVwKClcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZWxsV2F0Y2giLCJjb25zdCB0YWdQcmV2aWV3ID0ge1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbl9wcmludC10YWcnKSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlc2V0T3V0cHV0KClcbiAgICAgICAgdGhpcy5hdHRhY2hJbnB1dCgpXG4gICAgICAgIHRoaXMuYXR0YWNoSW1hZ2VVcGxvYWRlcigpXG4gICAgICAgIHRoaXMuYXR0YWNoUHJldmlld0NvbnRyb2xzKClcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIGNvbnNvbGUubG9nKCdUQUcgUFJFVklFVyBFUlInKVxuICAgIH1cbiAgfSxcbiAgcmVzZXRPdXRwdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBvdXRwdXRIb2xkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFnLXByZXZpZXdfX291dHB1dCcpLFxuICAgICAgb3V0cHV0SW1hZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFnLXByZXZpZXdfX3BpYycpXG4gICAgb3V0cHV0SG9sZGVyLmlubmVySFRNTCA9ICcnXG4gICAgb3V0cHV0SG9sZGVyLmNsYXNzTGlzdC5hZGQoSVNfRU1QVFkpXG4gICAgb3V0cHV0SW1hZ2UuY2xhc3NMaXN0LmFkZChJU19FTVBUWSlcbiAgfSxcbiAgYXR0YWNoSW5wdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBvdXRwdXRPYmogPSBuZXcgT2JqZWN0KCksXG4gICAgICBpbnB1dHMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInRleHRcIl0uZm9ybXBhZ2VfX2lucHV0JyldLFxuICAgICAgb3V0cHV0SG9sZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRhZy1wcmV2aWV3X19vdXRwdXQnKSxcbiAgICAgIHVwZGF0ZU91dHB1dCA9ICgpID0+IHtcbiAgICAgICAgbGV0IGZpbGxlZCA9IDAsIGh0bWwgPSBgYFxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvdXRwdXRPYmopIHtcbiAgICAgICAgICBpZiAob3V0cHV0T2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IG91dHB1dE9ialtrZXldXG4gICAgICAgICAgICBpZiAob2JqLnZhbHVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICArK2ZpbGxlZFxuICAgICAgICAgICAgICBodG1sICs9IGBcbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiJHtvYmouaWR9XCIgY2xhc3M9XCJ0YWctb3V0cHV0LXJvd1wiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4+JHtvYmoudGl0bGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPHNwYW4+JHtvYmoudmFsdWV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGxlZCAhPT0gMCkge1xuICAgICAgICAgIG91dHB1dEhvbGRlci5pbm5lckhUTUwgPSBodG1sXG4gICAgICAgICAgb3V0cHV0SG9sZGVyLmNsYXNzTGlzdC5yZW1vdmUoSVNfRU1QVFkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0SG9sZGVyLmlubmVySFRNTCA9ICcnXG4gICAgICAgICAgb3V0cHV0SG9sZGVyLmNsYXNzTGlzdC5hZGQoSVNfRU1QVFkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCwgaW5kZXgpID0+IHtcbiAgICAgIG91dHB1dE9ialtpbmRleF0gPSB7XG4gICAgICAgIGlkOiBpbnB1dC5pZCxcbiAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICB0aXRsZTogaW5wdXQuY2xvc2VzdCgnLmZvcm1wYWdlX19pbnB1dC1ib3gnKS5xdWVyeVNlbGVjdG9yKCdsYWJlbCcpLmlubmVySFRNTFxuICAgICAgfVxuXG4gICAgICBpbnB1dC5vbmlucHV0ID0gKCkgPT4ge1xuICAgICAgICBvdXRwdXRPYmpbaW5kZXhdLnZhbHVlID0gaW5wdXQudmFsdWUgfHwgJydcbiAgICAgICAgdXBkYXRlT3V0cHV0KClcbiAgICAgIH1cbiAgICAgIGlucHV0Lm9ua2V5ZG93biA9IChlKSA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgaXNFbnRlciA9IGUua2V5ID09PSAnRW50ZXInIHx8IGUua2V5Q29kZSA9PT0gMTMsXG4gICAgICAgICAgaXNCYWNrc2NhcGUgPSBlLmtleSA9PT0gJ0JhY2tzcGFjZScgfHwgZS5rZXkgPT09ICdEZWxldGUnLFxuICAgICAgICAgIGlzRXNjID0gZS5rZXkgPT09ICdFc2NhcGUnIHx8IGUua2V5ID09PSAnRXNjJyxcbiAgICAgICAgICBpc1VwID0gZS5rZXkgPT09ICdBcnJvd1VwJyxcbiAgICAgICAgICBpc0Rvd24gPSBlLmtleSA9PT0gJ0Fycm93RG93bicsXG4gICAgICAgICAgbmV4dCA9IGlucHV0c1tpbmRleCArIDFdLFxuICAgICAgICAgIHByZXYgPSBpbnB1dHNbaW5kZXggLSAxXVxuXG4gICAgICAgIGlmIChpc0VudGVyIHx8IGlzRG93bikge1xuICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHsgbmV4dC5mb2N1cygpIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCYWNrc2NhcGUpIHtcbiAgICAgICAgICBpZiAoaW5wdXQudmFsdWUubGVuZ3RoID09IDAgJiYgcHJldiAhPT0gdW5kZWZpbmVkKSB7IHByZXYuZm9jdXMoKSB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRXNjKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyBpbnB1dC5ibHVyKClcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVcCkge1xuICAgICAgICAgIGlmIChwcmV2ICE9PSB1bmRlZmluZWQpIHsgcHJldi5mb2N1cygpIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgWydmb2N1cycsICdibHVyJ10uZm9yRWFjaCgoZXYpID0+IHtcbiAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDw9IDQ3OSkge1xuICAgICAgICAgIGNvbnN0IGxhYmVsID0gaW5wdXQuY2xvc2VzdCgnLmZvcm1wYWdlX19pbnB1dC1ib3gnKS5xdWVyeVNlbGVjdG9yKCdsYWJlbCcpXG4gICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihldiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoIChldikge1xuICAgICAgICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgICAgICAgbGFiZWwuc3R5bGUub3BhY2l0eSA9IDBcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYmx1cic6XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnZhbHVlLmxlbmd0aCAhPT0gMCkgeyBsYWJlbC5zdHlsZS5vcGFjaXR5ID0gMCB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbGFiZWwuc3R5bGUub3BhY2l0eSA9IDAuNVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgfSlcbiAgfSxcbiAgYXR0YWNoSW1hZ2VVcGxvYWRlcjogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHVwbG9hZExhYmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3ByaW50VGFnX3VwbG9hZGVyJyksXG4gICAgICB1cGxvYWRJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbWFnZV91cGxvYWRfdGFnJyksXG4gICAgICBpbWdQcmV2aWV3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRhZy1wcmV2aWV3X19waWMnKVxuXG4gICAgLy8gRFJBRyAmIERST1BcbiAgICBpZiAodXBsb2FkTGFiZWwgIT09IG51bGwpIHtcbiAgICAgIHVwbG9hZExhYmVsLm9uZHJhZ292ZXIgPSAoZXZ0KSA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHVwbG9hZExhYmVsLmNsYXNzTGlzdC5hZGQoSVNfQUNUSVZFKVxuICAgICAgfVxuICAgICAgdXBsb2FkTGFiZWwub25kcmFnbGVhdmUgPSAoZXZ0KSA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHVwbG9hZExhYmVsLmNsYXNzTGlzdC5yZW1vdmUoSVNfQUNUSVZFKVxuICAgICAgfVxuICAgICAgdXBsb2FkTGFiZWwub25kcm9wID0gKGV2dCkgPT4ge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB1cGxvYWRMYWJlbC5jbGFzc0xpc3QucmVtb3ZlKElTX0FDVElWRSlcbiAgICAgICAgJCgnI2ltYWdlX3VwbG9hZF90YWcnKS5wcm9wKCdmaWxlcycsIGV2dC5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICBjb25zdCBmaWxlcyA9IFsuLi5ldnQuZGF0YVRyYW5zZmVyLml0ZW1zXSxcbiAgICAgICAgICBmaWxlID0gZmlsZXMuZmluZCgoaXRlbSkgPT4geyBpZiAoaXRlbS5raW5kID09PSAnZmlsZScpIHsgcmV0dXJuIGl0ZW0gfSB9KVxuICAgICAgICBwcm9jZXNzSW1hZ2UoZmlsZS5nZXRBc0ZpbGUoKSlcbiAgICAgIH1cblxuICAgICAgLy8gTUFOVUFMXG4gICAgICBpZiAodXBsb2FkSW5wdXQgIT09IG51bGwpIHtcbiAgICAgICAgdXBsb2FkSW5wdXQub25jaGFuZ2UgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IFsuLi5ldnQudGFyZ2V0LmZpbGVzXVswXVxuICAgICAgICAgIHByb2Nlc3NJbWFnZShmaWxlKVxuICAgICAgICAgIHVwbG9hZElucHV0LnZhbHVlID0gJydcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQUk9DRVNTIElNQUdFXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzSW1hZ2UoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICAgICAgICBpbWdQcmV2aWV3LmNsYXNzTGlzdC5yZW1vdmUoSVNfRU1QVFkpXG4gICAgICAgICAgICBpbWdQcmV2aWV3LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtlLnRhcmdldC5yZXN1bHR9KWBcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuICB9LFxuICBhdHRhY2hQcmV2aWV3Q29udHJvbHM6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YWctcHJldmlldy1tb2RhbCcpXG4gICAgaWYgKG1vZGFsICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBob2xkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFnLXByZXZpZXctbW9kYWxfX3dyYXBwZXInKVxuICAgICAgY29uc3QgdG9nZ2xlID0gKCkgPT4ge1xuICAgICAgICBsZXQgZGlzcGxheWVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobW9kYWwpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnXG4gICAgICAgIGlmIChkaXNwbGF5ZWQpIHtcbiAgICAgICAgICB1bmxvY2tTY3JvbGwoKVxuICAgICAgICAgIGNvbnN0IHByZXZpZXcgPSBob2xkZXIucXVlcnlTZWxlY3RvcignLmZvcm1wYWdlX190YWctcHJldmlldycpXG4gICAgICAgICAgaWYgKHByZXZpZXcgIT09IG51bGwpIHsgcHJldmlldy5yZW1vdmUoKSB9XG4gICAgICAgICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2tTY3JvbGwoKVxuICAgICAgICAgIGNvbnN0IHByZXZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9ybXBhZ2VfX3RhZy1wcmV2aWV3JylcbiAgICAgICAgICBob2xkZXIuYXBwZW5kQ2hpbGQocHJldmlldy5jbG9uZU5vZGUodHJ1ZSkpXG4gICAgICAgICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0XG4gICAgICAgIGlmICh0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWV2dCcpID09ICd0b2dnbGVQcmludFRhZ1ByZXZpZXcnKSB7XG4gICAgICAgICAgdG9nZ2xlKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0YWdQcmV2aWV3IiwiZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG5mdW5jdGlvbiBsb2NrU2Nyb2xsKCkge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKFwiaWItc2Nyb2xsLWxvY2tcIikpIHtcbiAgICAgIGxldCBvID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShcImliLXNjcm9sbC1sb2NrXCIsIG8pLFxuICAgICAgICAoZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIpLFxuICAgICAgICAoZG9jdW1lbnQuYm9keS5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIiksXG4gICAgICAgIChkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCA9IFwiLVwiICsgbyArIFwicHhcIiksXG4gICAgICAgIChkb2N1bWVudC5ib2R5LnN0eWxlLmxlZnQgPSBcIjBcIiksXG4gICAgICAgIChkb2N1bWVudC5ib2R5LnN0eWxlLndpZHRoID0gXCIxMDAlXCIpO1xuICAgIH1cbiAgfSwgMSk7XG59XG5mdW5jdGlvbiB1bmxvY2tTY3JvbGwoKSB7XG4gIGlmIChkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZShcImliLXNjcm9sbC1sb2NrXCIpKSB7XG4gICAgbGV0IG8gPSBkb2N1bWVudC5ib2R5LmdldEF0dHJpYnV0ZShcImliLXNjcm9sbC1sb2NrXCIpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKFwiaWItc2Nyb2xsLWxvY2tcIiksXG4gICAgICAoZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiXCIpLFxuICAgICAgKGRvY3VtZW50LmJvZHkuc3R5bGUucG9zaXRpb24gPSBcIlwiKSxcbiAgICAgIChkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCA9IFwiXCIpLFxuICAgICAgKGRvY3VtZW50LmJvZHkuc3R5bGUubGVmdCA9IFwiXCIpLFxuICAgICAgKGRvY3VtZW50LmJvZHkuc3R5bGUud2lkdGggPSBcIlwiKSxcbiAgICAgIHdpbmRvdy5zY3JvbGwoMCwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVsZW1EaXNwbGF5ZWQoZWxlbSkge1xuICBpZiAoIWVsZW0pIHJldHVybiBmYWxzZVxuICBsZXQgdGFyZ2V0ID0gZWxlbSBpbnN0YW5jZW9mIGpRdWVyeSA/IGVsZW0uZ2V0KDApIDogZWxlbVxuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5JykgIT09ICdub25lJ1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbSh0YWdOYW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgY2xhc3NOYW1lLCBpZCwgaW5uZXJIVE1MLCBzdHlsZSwgYXR0cmlidXRlcywgdG9BcHBlbmQgfSA9IG9wdGlvbnNcbiAgY29uc3QgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSlcbiAgaWYgKGNsYXNzTmFtZSkgZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gIGlmIChpZCkgZWxlbS5pZCA9IGlkO1xuICBpZiAoaW5uZXJIVE1MKSBlbGVtLmlubmVySFRNTCA9IGlubmVySFRNTDtcbiAgaWYgKHN0eWxlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5zdHlsZSkgeyBlbGVtLnN0eWxlW2tleV0gPSBvcHRpb25zLnN0eWxlW2tleV0gfVxuICB9XG4gIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5hdHRyaWJ1dGVzKSB7IGVsZW0uc2V0QXR0cmlidXRlKGtleSwgb3B0aW9ucy5hdHRyaWJ1dGVzW2tleV0pIH1cbiAgfVxuICBpZiAodG9BcHBlbmQpIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRvQXJyYXkodG9BcHBlbmQpKSB7IGVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQpIH1cbiAgfVxuICByZXR1cm4gZWxlbVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyhlbGVtLCAuLi5jbGFzc2VzKSB7XG4gIGZvciAoY29uc3QgY2xzIG9mIGNsYXNzZXMpIHtcbiAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xzKVxuICB9XG59XG5mdW5jdGlvbiBhZGRDbGFzc2VzKGVsZW0sIC4uLmNsYXNzZXMpIHtcbiAgZm9yIChjb25zdCBjbHMgb2YgY2xhc3Nlcykge1xuICAgIGVsZW0uY2xhc3NMaXN0LmFkZChjbHMpXG4gIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdEFzQ3VycmVuY3koc3RyaW5nKSB7XG4gIHN0cmluZyA9IHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnID8gc3RyaW5nIDogc3RyaW5nLnRvU3RyaW5nKClcbiAgY29uc3QgbnVtYmVyID0gcGFyc2VGbG9hdChzdHJpbmcucmVwbGFjZSgvLC9nLCAnJykpXG4gIGNvbnN0IHBhcnRzID0gbnVtYmVyLnRvRml4ZWQoMikuc3BsaXQoJy4nKVxuICBjb25zdCBkaWdpdHMgPSBwYXJ0c1swXVxuICBjb25zdCBkZWNpbWFsID0gcGFydHNbMV1cbiAgY29uc3QgaW50ZWdlciA9IGRpZ2l0cy5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCAnLCcpXG4gIHJldHVybiBgJHtpbnRlZ2VyfS4ke2RlY2ltYWx9YFxufVxuZnVuY3Rpb24gZ2V0RXZ0RE9NKGF0dHIpIHtcbiAgcmV0dXJuICQoYFtkYXRhLWV2dD1cIiR7YXR0cn1cIl1gKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25UaW1lKGVsZW0pIHtcbiAgbGV0IGVsID0gZWxlbSBpbnN0YW5jZW9mIGpRdWVyeSA/IGVsZW1bMF0gOiBlbGVtO1xuICByZXR1cm4gcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkudHJhbnNpdGlvbkR1cmF0aW9uKSAqIDEwMDA7XG59XG5mdW5jdGlvbiBnZXRPcmRpbmFsVHh0KG4pIHtcbiAgcmV0dXJuIG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEgPyAnc3QnIDogbiAlIDEwID09IDIgJiYgbiAlIDEwMCAhPSAxMiA/ICduZCcgOiBuICUgMTAgPT0gMyAmJiBuICUgMTAwICE9IDEzID8gJ3JkJyA6ICd0aCdcbn1cbmZ1bmN0aW9uIGdldFpJbmRleChlbGVtKSB7XG4gIHJldHVybiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKS5nZXRQcm9wZXJ0eVZhbHVlKCd6LWluZGV4JykpXG59XG5mdW5jdGlvbiB0b2dnbGVBZG1pbkJhcigpIHtcbiAgbGV0IGJhciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pYmEtdG9vbGJhcicpXG4gIGlmIChiYXIgJiYgYmFyICE9PSBudWxsKSB7XG4gICAgaWYgKGJhci5jbGFzc0xpc3QuY29udGFpbnMoSVNfTUlOSU1JWkVEKSkge1xuICAgICAgYmFyLmNsYXNzTGlzdC5yZW1vdmUoSVNfTUlOSU1JWkVEKVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXIuY2xhc3NMaXN0LmFkZChJU19NSU5JTUlaRUQpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0VtYWlsKGVtYWlsKSB7XG4gIHZhciByZWdleCA9IC9eKFthLXpBLVowLTlfListXSkrXFxAKChbYS16QS1aMC05LV0pK1xcLikrKFthLXpBLVowLTldezIsNH0pKyQvO1xuICByZXR1cm4gcmVnZXgudGVzdChlbWFpbCk7XG59XG5mdW5jdGlvbiBzYXZlQ2FydEVtYWlsKCkge1xuICB2YXIgZW1haWwgPSAkKCcjY2FydF9lbWFpbCcpLnZhbCgpO1xuICBpZiAoZW1haWwgIT0gJycgJiYgaXNFbWFpbChlbWFpbCkpIHtcbiAgICAkLmFqYXgoe1xuICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICB1cmw6ICcvanNvbi9jYXJ0LWVtYWlsJyxcbiAgICAgIGRhdGE6IHsgZW1haWxfYWRkcmVzczogZW1haWwgfSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGtsYXZpeW8uaWRlbnRpZnkoeyAnJGVtYWlsJzogZW1haWwgfSk7XG4gICAgICAgIG1haWxNb2RhbC5jbG9zZSgpO1xuICAgICAgICBzaG93TWVzc2FnZSgnc3VjY2VzcycsICdUaGFuayB5b3UnLCAnSXRlbSB3YXMgYWRkZWQgdG8geW91ciBjYXJ0LicpO1xuICAgICAgICAkKCcuY2FydF90cmlnZ2VyJykuY2xpY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzaG93TWVzc2FnZSgnZXJyb3InLCAnRXJyb3InLCAnUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzcyAhJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3dNZXNzYWdlKHR5cGUsIHRpdGxlLCBtc2cpIHtcbiAgdmFyIGFsZXJ0X3R5cGUgPSAodHlwZSA9PT0gJ3N1Y2Nlc3MnKSA/IHBhZ2VBbGVydHMuY2xhc3Nlcy5pbmZvIDogcGFnZUFsZXJ0cy5jbGFzc2VzLmVycm9yO1xuICBwYWdlQWxlcnRzLnNob3dBbGVydChhbGVydF90eXBlLCB0aXRsZSwgbXNnKTtcbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCkge1xuICBsZXQgdGltZW91dFxuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBsYXRlciA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgZnVuYyguLi5hcmdzKVxuICAgIH1cbiAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdClcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG93U2tlbGV0b24oKSB7XG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnLS1za2VsZXRvbicpXG59XG5cbmZ1bmN0aW9uIGhpZGVTa2VsZXRvbigpIHtcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCctLXNrZWxldG9uJylcbn1cblxuZnVuY3Rpb24gb3BlblByaWNlTW9kYWwodGFyZ2V0LCBpZCkge1xuICBjb25zdCBjYXJkID0gdGFyZ2V0LmNsb3Nlc3QoJy5wcm9kdWN0LWNhcmQnKVxuICBpZiAoIWNhcmQpIHJldHVyblxuXG4gIHdpbmRvdy5zaWduUHJpY2VNb2RhbCA9IG5ldyB3aW5kb3cucHJpY2VNb2RhbChjYXJkLCBpZClcbn1cblxuZnVuY3Rpb24gc2lnbnVwUHJpY2UoKSB7XG4gIGlmICghd2luZG93LnNpZ25QcmljZU1vZGFsKSB7XG4gICAgY29uc29sZS53YXJuKCdObyBwcmljZSBtb2RhbCBmb3VuZCcpXG4gICAgcmV0dXJuXG4gIH1cblxuICB3aW5kb3cuc2lnblByaWNlTW9kYWwuc2lnbnVwKClcbn1cblxuLyoqXG4gKiBDb3VudGRvd24gdGltZXJcbiAqIEV4YW1wbGUgb2YgdXNhZ2UgOiBcbiAqICAgIGNyZWF0ZVRpbWVyKHtcbiAgICAgIGRheVNlbGVjdG9yOiAnI3NhbGVfdGltZXJfZGF5cycsXG4gICAgICBob3VyU2VsZWN0b3I6ICcjc2FsZV90aW1lcl9ob3VycycsXG4gICAgICBtaW51dGVTZWxlY3RvcjogJyNzYWxlX3RpbWVyX21pbnV0ZXMnLFxuICAgICAgc2Vjb25kU2VsZWN0b3I6ICcjc2FsZV90aW1lcl9zZWNvbmRzJyxcbiAgICAgIGRhdGU6ICcyMDI0LTExLTMwIDEwOjAwOjAwJ1xuICAgIH0pXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlVGltZXIoc2V0dGluZ3MgPSB7fSkge1xuICBsZXQgeyBkYXlTZWxlY3RvciwgaG91clNlbGVjdG9yLCBtaW51dGVTZWxlY3Rvciwgc2Vjb25kU2VsZWN0b3IsIGRhdGUgfSA9IHNldHRpbmdzXG5cbiAgY29uc3QgZGF5RWxlbSA9IGRheVNlbGVjdG9yID8gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZGF5U2VsZWN0b3IpXSA6IG51bGxcbiAgY29uc3QgaG91ckVsZW0gPSBob3VyU2VsZWN0b3IgPyBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChob3VyU2VsZWN0b3IpXSA6IG51bGxcbiAgY29uc3QgbWludXRlRWxlbSA9IG1pbnV0ZVNlbGVjdG9yID8gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwobWludXRlU2VsZWN0b3IpXSA6IG51bGxcbiAgY29uc3Qgc2Vjb25kRWxlbSA9IHNlY29uZFNlbGVjdG9yID8gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2Vjb25kU2VsZWN0b3IpXSA6IG51bGxcbiAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKGRhdGUpXG4gIGxldCB0aW1lclxuXG4gIGlmICghZGF5RWxlbSAmJiAhaG91ckVsZW0gJiYgIW1pbnV0ZUVsZW0gJiYgIXNlY29uZEVsZW0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChpc05hTihlbmREYXRlKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0luY29ycmVjdCBkYXRlIGZvcm1hdCBwYXNzZWQgdG8gY3JlYXRlVGltZXIuJylcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHBhZCA9IChudW0pID0+IG51bS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJylcblxuICB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICB1cGRhdGVUaW1lcigpXG4gIH0sIDEwMDApXG5cbiAgZnVuY3Rpb24gdXBkYXRlVGltZXIoKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICBsZXQgZGlmZiA9IGVuZERhdGUgLSBub3dcblxuICAgIGlmIChkaWZmIDw9IDApIHtcbiAgICAgIGRpZmYgPSAwXG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKVxuICAgIH1cblxuICAgIGNvbnN0IGRheXMgPSBNYXRoLmZsb29yKGRpZmYgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpXG4gICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKChkaWZmICUgKDEwMDAgKiA2MCAqIDYwICogMjQpKSAvICgxMDAwICogNjAgKiA2MCkpXG4gICAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoKGRpZmYgJSAoMTAwMCAqIDYwICogNjApKSAvICgxMDAwICogNjApKVxuICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKChkaWZmICUgKDEwMDAgKiA2MCkpIC8gMTAwMClcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgZGF5RWxlbSkge1xuICAgICAgaWYgKGVsZW0gIT09IG51bGwpIHtcbiAgICAgICAgZWxlbS50ZXh0Q29udGVudCA9IHBhZChkYXlzKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgaG91ckVsZW0pIHtcbiAgICAgIGlmIChlbGVtICE9PSBudWxsKSB7XG4gICAgICAgIGVsZW0udGV4dENvbnRlbnQgPSBwYWQoaG91cnMpXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZvciAoY29uc3QgZWxlbSBvZiBtaW51dGVFbGVtKSB7XG4gICAgICBpZiAoZWxlbSAhPT0gbnVsbCkge1xuICAgICAgICBlbGVtLnRleHRDb250ZW50ID0gcGFkKG1pbnV0ZXMpXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZvciAoY29uc3QgZWxlbSBvZiBzZWNvbmRFbGVtKSB7XG4gICAgICBpZiAoZWxlbSAhPT0gbnVsbCkge1xuICAgICAgICBlbGVtLnRleHRDb250ZW50ID0gcGFkKHNlY29uZHMpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0b0FycmF5LFxuICBsb2NrU2Nyb2xsLFxuICB1bmxvY2tTY3JvbGwsXG4gIGVsZW1EaXNwbGF5ZWQsXG4gIGNyZWF0ZUVsZW0sXG4gIHJlbW92ZUNsYXNzZXMsXG4gIGFkZENsYXNzZXMsXG4gIGZvcm1hdEFzQ3VycmVuY3ksXG4gIGdldEV2dERPTSxcbiAgZ2V0VHJhbnNpdGlvblRpbWUsXG4gIGdldE9yZGluYWxUeHQsXG4gIGdldFpJbmRleCxcbiAgdG9nZ2xlQWRtaW5CYXIsXG4gIGlzRW1haWwsXG4gIHNhdmVDYXJ0RW1haWwsXG4gIHNob3dNZXNzYWdlLFxuICBkZWJvdW5jZSxcbiAgc2hvd1NrZWxldG9uLFxuICBoaWRlU2tlbGV0b24sXG4gIG9wZW5QcmljZU1vZGFsLFxuICBzaWdudXBQcmljZSxcbiAgY3JlYXRlVGltZXJcbn0iLCJsZXQgdmFyaWFibGVzID0ge1xuICBVUExPQURFRF9CTE9HX0lNRzogbnVsbCxcbiAgYWxlcnRUaW1lcjogbnVsbCxcbiAgc2lydlRpbWVyOiBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFyaWFibGVzOyIsIiFmdW5jdGlvbiAodCwgZSkgeyBcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIG1vZHVsZSA/IG1vZHVsZS5leHBvcnRzID0gZShyZXF1aXJlKFwianF1ZXJ5XCIpKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoW1wianF1ZXJ5XCJdLCBlKSA6ICh0ID0gdCB8fCBzZWxmKS5wYXJzbGV5ID0gZSh0LmpRdWVyeSkgfSh0aGlzLCBmdW5jdGlvbiAoaCkgeyBcInVzZSBzdHJpY3RcIjsgZnVuY3Rpb24gbih0KSB7IHJldHVybiAobiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0eXBlb2YgdCB9IDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgdC5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIHQgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIHQgfSkodCkgfSBmdW5jdGlvbiBsKCkgeyByZXR1cm4gKGwgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7IGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7IHZhciBpID0gYXJndW1lbnRzW2VdOyBmb3IgKHZhciByIGluIGkpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLCByKSAmJiAodFtyXSA9IGlbcl0pIH0gcmV0dXJuIHQgfSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9IGZ1bmN0aW9uIG8odCwgZSkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgaWYgKEFycmF5LmlzQXJyYXkodCkpIHJldHVybiB0IH0odCkgfHwgZnVuY3Rpb24gKHQsIGUpIHsgaWYgKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KSB8fCBcIltvYmplY3QgQXJndW1lbnRzXVwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpKSByZXR1cm47IHZhciBpID0gW10sIHIgPSAhMCwgbiA9ICExLCBzID0gdm9pZCAwOyB0cnkgeyBmb3IgKHZhciBhLCBvID0gdFtTeW1ib2wuaXRlcmF0b3JdKCk7ICEociA9IChhID0gby5uZXh0KCkpLmRvbmUpICYmIChpLnB1c2goYS52YWx1ZSksICFlIHx8IGkubGVuZ3RoICE9PSBlKTsgciA9ICEwKTsgfSBjYXRjaCAodCkgeyBuID0gITAsIHMgPSB0IH0gZmluYWxseSB7IHRyeSB7IHIgfHwgbnVsbCA9PSBvLnJldHVybiB8fCBvLnJldHVybigpIH0gZmluYWxseSB7IGlmIChuKSB0aHJvdyBzIH0gfSByZXR1cm4gaSB9KHQsIGUpIHx8IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIikgfSgpIH0gZnVuY3Rpb24gdSh0KSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyBpZiAoQXJyYXkuaXNBcnJheSh0KSkgeyBmb3IgKHZhciBlID0gMCwgaSA9IG5ldyBBcnJheSh0Lmxlbmd0aCk7IGUgPCB0Lmxlbmd0aDsgZSsrKWlbZV0gPSB0W2VdOyByZXR1cm4gaSB9IH0odCkgfHwgZnVuY3Rpb24gKHQpIHsgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCkgfHwgXCJbb2JqZWN0IEFyZ3VtZW50c11cIiA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKSByZXR1cm4gQXJyYXkuZnJvbSh0KSB9KHQpIHx8IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpIH0oKSB9IHZhciB0ID0gMSwgZSA9IHt9LCBkID0geyBhdHRyOiBmdW5jdGlvbiAodCwgZSwgaSkgeyB2YXIgciwgbiwgcywgYSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBlLCBcImlcIik7IGlmICh2b2lkIDAgPT09IGkpIGkgPSB7fTsgZWxzZSBmb3IgKHIgaW4gaSkgaS5oYXNPd25Qcm9wZXJ0eShyKSAmJiBkZWxldGUgaVtyXTsgaWYgKCF0KSByZXR1cm4gaTsgZm9yIChyID0gKHMgPSB0LmF0dHJpYnV0ZXMpLmxlbmd0aDsgci0tOykobiA9IHNbcl0pICYmIG4uc3BlY2lmaWVkICYmIGEudGVzdChuLm5hbWUpICYmIChpW3RoaXMuY2FtZWxpemUobi5uYW1lLnNsaWNlKGUubGVuZ3RoKSldID0gdGhpcy5kZXNlcmlhbGl6ZVZhbHVlKG4udmFsdWUpKTsgcmV0dXJuIGkgfSwgY2hlY2tBdHRyOiBmdW5jdGlvbiAodCwgZSwgaSkgeyByZXR1cm4gdC5oYXNBdHRyaWJ1dGUoZSArIGkpIH0sIHNldEF0dHI6IGZ1bmN0aW9uICh0LCBlLCBpLCByKSB7IHQuc2V0QXR0cmlidXRlKHRoaXMuZGFzaGVyaXplKGUgKyBpKSwgU3RyaW5nKHIpKSB9LCBnZXRUeXBlOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpIHx8IFwidGV4dFwiIH0sIGdlbmVyYXRlSUQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiXCIgKyB0KysgfSwgZGVzZXJpYWxpemVWYWx1ZTogZnVuY3Rpb24gKGUpIHsgdmFyIHQ7IHRyeSB7IHJldHVybiBlID8gXCJ0cnVlXCIgPT0gZSB8fCBcImZhbHNlXCIgIT0gZSAmJiAoXCJudWxsXCIgPT0gZSA/IG51bGwgOiBpc05hTih0ID0gTnVtYmVyKGUpKSA/IC9eW1xcW1xce10vLnRlc3QoZSkgPyBKU09OLnBhcnNlKGUpIDogZSA6IHQpIDogZSB9IGNhdGNoICh0KSB7IHJldHVybiBlIH0gfSwgY2FtZWxpemU6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnJlcGxhY2UoLy0rKC4pPy9nLCBmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gZSA/IGUudG9VcHBlckNhc2UoKSA6IFwiXCIgfSkgfSwgZGFzaGVyaXplOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5yZXBsYWNlKC86Oi9nLCBcIi9cIikucmVwbGFjZSgvKFtBLVpdKykoW0EtWl1bYS16XSkvZywgXCIkMV8kMlwiKS5yZXBsYWNlKC8oW2EtelxcZF0pKFtBLVpdKS9nLCBcIiQxXyQyXCIpLnJlcGxhY2UoL18vZywgXCItXCIpLnRvTG93ZXJDYXNlKCkgfSwgd2FybjogZnVuY3Rpb24gKCkgeyB2YXIgdDsgd2luZG93LmNvbnNvbGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW5kb3cuY29uc29sZS53YXJuICYmICh0ID0gd2luZG93LmNvbnNvbGUpLndhcm4uYXBwbHkodCwgYXJndW1lbnRzKSB9LCB3YXJuT25jZTogZnVuY3Rpb24gKHQpIHsgZVt0XSB8fCAoZVt0XSA9ICEwLCB0aGlzLndhcm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSkgfSwgX3Jlc2V0V2FybmluZ3M6IGZ1bmN0aW9uICgpIHsgZSA9IHt9IH0sIHRyaW1TdHJpbmc6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpIH0sIHBhcnNlOiB7IGRhdGU6IGZ1bmN0aW9uICh0KSB7IHZhciBlID0gdC5tYXRjaCgvXihcXGR7NCx9KS0oXFxkXFxkKS0oXFxkXFxkKSQvKTsgaWYgKCFlKSByZXR1cm4gbnVsbDsgdmFyIGkgPSBvKGUubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBwYXJzZUludCh0LCAxMCkgfSksIDQpLCByID0gKGlbMF0sIGlbMV0pLCBuID0gaVsyXSwgcyA9IGlbM10sIGEgPSBuZXcgRGF0ZShyLCBuIC0gMSwgcyk7IHJldHVybiBhLmdldEZ1bGxZZWFyKCkgIT09IHIgfHwgYS5nZXRNb250aCgpICsgMSAhPT0gbiB8fCBhLmdldERhdGUoKSAhPT0gcyA/IG51bGwgOiBhIH0sIHN0cmluZzogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgfSwgaW50ZWdlcjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGlzTmFOKHQpID8gbnVsbCA6IHBhcnNlSW50KHQsIDEwKSB9LCBudW1iZXI6IGZ1bmN0aW9uICh0KSB7IGlmIChpc05hTih0KSkgdGhyb3cgbnVsbDsgcmV0dXJuIHBhcnNlRmxvYXQodCkgfSwgYm9vbGVhbjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuICEvXlxccypmYWxzZVxccyokL2kudGVzdCh0KSB9LCBvYmplY3Q6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBkLmRlc2VyaWFsaXplVmFsdWUodCkgfSwgcmVnZXhwOiBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IFwiXCI7IHJldHVybiB0ID0gL15cXC8uKlxcLyg/OltnaW15XSopJC8udGVzdCh0KSA/IChlID0gdC5yZXBsYWNlKC8uKlxcLyhbZ2lteV0qKSQvLCBcIiQxXCIpLCB0LnJlcGxhY2UobmV3IFJlZ0V4cChcIl4vKC4qPykvXCIgKyBlICsgXCIkXCIpLCBcIiQxXCIpKSA6IFwiXlwiICsgdCArIFwiJFwiLCBuZXcgUmVnRXhwKHQsIGUpIH0gfSwgcGFyc2VSZXF1aXJlbWVudDogZnVuY3Rpb24gKHQsIGUpIHsgdmFyIGkgPSB0aGlzLnBhcnNlW3QgfHwgXCJzdHJpbmdcIl07IGlmICghaSkgdGhyb3cgJ1Vua25vd24gcmVxdWlyZW1lbnQgc3BlY2lmaWNhdGlvbjogXCInICsgdCArICdcIic7IHZhciByID0gaShlKTsgaWYgKG51bGwgPT09IHIpIHRocm93IFwiUmVxdWlyZW1lbnQgaXMgbm90IGEgXCIuY29uY2F0KHQsICc6IFwiJykuY29uY2F0KGUsICdcIicpOyByZXR1cm4gciB9LCBuYW1lc3BhY2VFdmVudHM6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiAodCA9IHRoaXMudHJpbVN0cmluZyh0IHx8IFwiXCIpLnNwbGl0KC9cXHMrLykpWzBdID8gaC5tYXAodCwgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIFwiXCIuY29uY2F0KHQsIFwiLlwiKS5jb25jYXQoZSkgfSkuam9pbihcIiBcIikgOiBcIlwiIH0sIGRpZmZlcmVuY2U6IGZ1bmN0aW9uICh0LCBpKSB7IHZhciByID0gW107IHJldHVybiBoLmVhY2godCwgZnVuY3Rpb24gKHQsIGUpIHsgLTEgPT0gaS5pbmRleE9mKGUpICYmIHIucHVzaChlKSB9KSwgciB9LCBhbGw6IGZ1bmN0aW9uICh0KSB7IHJldHVybiBoLndoZW4uYXBwbHkoaCwgdSh0KS5jb25jYXQoWzQyLCA0Ml0pKSB9LCBvYmplY3RDcmVhdGU6IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHQpIHsgaWYgKDEgPCBhcmd1bWVudHMubGVuZ3RoKSB0aHJvdyBFcnJvcihcIlNlY29uZCBhcmd1bWVudCBub3Qgc3VwcG9ydGVkXCIpOyBpZiAoXCJvYmplY3RcIiAhPSBuKHQpKSB0aHJvdyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdFwiKTsgaS5wcm90b3R5cGUgPSB0OyB2YXIgZSA9IG5ldyBpOyByZXR1cm4gaS5wcm90b3R5cGUgPSBudWxsLCBlIH0sIF9TdWJtaXRTZWxlY3RvcjogJ2lucHV0W3R5cGU9XCJzdWJtaXRcIl0sIGJ1dHRvbjpzdWJtaXQnIH07IGZ1bmN0aW9uIGkoKSB7IH0gZnVuY3Rpb24gcigpIHsgdGhpcy5fX2lkX18gPSBkLmdlbmVyYXRlSUQoKSB9IHZhciBzID0geyBuYW1lc3BhY2U6IFwiZGF0YS1wYXJzbGV5LVwiLCBpbnB1dHM6IFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3RcIiwgZXhjbHVkZWQ6IFwiaW5wdXRbdHlwZT1idXR0b25dLCBpbnB1dFt0eXBlPXN1Ym1pdF0sIGlucHV0W3R5cGU9cmVzZXRdLCBpbnB1dFt0eXBlPWhpZGRlbl1cIiwgcHJpb3JpdHlFbmFibGVkOiAhMCwgbXVsdGlwbGU6IG51bGwsIGdyb3VwOiBudWxsLCB1aUVuYWJsZWQ6ICEwLCB2YWxpZGF0aW9uVGhyZXNob2xkOiAzLCBmb2N1czogXCJmaXJzdFwiLCB0cmlnZ2VyOiAhMSwgdHJpZ2dlckFmdGVyRmFpbHVyZTogXCJpbnB1dFwiLCBlcnJvckNsYXNzOiBcInBhcnNsZXktZXJyb3JcIiwgc3VjY2Vzc0NsYXNzOiBcInBhcnNsZXktc3VjY2Vzc1wiLCBjbGFzc0hhbmRsZXI6IGZ1bmN0aW9uICgpIHsgfSwgZXJyb3JzQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7IH0sIGVycm9yc1dyYXBwZXI6ICc8dWwgY2xhc3M9XCJwYXJzbGV5LWVycm9ycy1saXN0XCI+PC91bD4nLCBlcnJvclRlbXBsYXRlOiBcIjxsaT48L2xpPlwiIH07IHIucHJvdG90eXBlID0geyBhc3luY1N1cHBvcnQ6ICEwLCBfcGlwZUFjY29yZGluZ1RvVmFsaWRhdGlvblJlc3VsdDogZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiB0KCkgeyB2YXIgdCA9IGguRGVmZXJyZWQoKTsgcmV0dXJuICEwICE9PSBlLnZhbGlkYXRpb25SZXN1bHQgJiYgdC5yZWplY3QoKSwgdC5yZXNvbHZlKCkucHJvbWlzZSgpIH0gdmFyIGUgPSB0aGlzOyByZXR1cm4gW3QsIHRdIH0sIGFjdHVhbGl6ZU9wdGlvbnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQuYXR0cih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5uYW1lc3BhY2UsIHRoaXMuZG9tT3B0aW9ucyksIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmFjdHVhbGl6ZU9wdGlvbnMgJiYgdGhpcy5wYXJlbnQuYWN0dWFsaXplT3B0aW9ucygpLCB0aGlzIH0sIF9yZXNldE9wdGlvbnM6IGZ1bmN0aW9uICh0KSB7IGZvciAodmFyIGUgaW4gdGhpcy5kb21PcHRpb25zID0gZC5vYmplY3RDcmVhdGUodGhpcy5wYXJlbnQub3B0aW9ucyksIHRoaXMub3B0aW9ucyA9IGQub2JqZWN0Q3JlYXRlKHRoaXMuZG9tT3B0aW9ucyksIHQpIHQuaGFzT3duUHJvcGVydHkoZSkgJiYgKHRoaXMub3B0aW9uc1tlXSA9IHRbZV0pOyB0aGlzLmFjdHVhbGl6ZU9wdGlvbnMoKSB9LCBfbGlzdGVuZXJzOiBudWxsLCBvbjogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyB8fCB7fSwgKHRoaXMuX2xpc3RlbmVyc1t0XSA9IHRoaXMuX2xpc3RlbmVyc1t0XSB8fCBbXSkucHVzaChlKSwgdGhpcyB9LCBzdWJzY3JpYmU6IGZ1bmN0aW9uICh0LCBlKSB7IGgubGlzdGVuVG8odGhpcywgdC50b0xvd2VyQ2FzZSgpLCBlKSB9LCBvZmY6IGZ1bmN0aW9uICh0LCBlKSB7IHZhciBpID0gdGhpcy5fbGlzdGVuZXJzICYmIHRoaXMuX2xpc3RlbmVyc1t0XTsgaWYgKGkpIGlmIChlKSBmb3IgKHZhciByID0gaS5sZW5ndGg7IHItLTspaVtyXSA9PT0gZSAmJiBpLnNwbGljZShyLCAxKTsgZWxzZSBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3RdOyByZXR1cm4gdGhpcyB9LCB1bnN1YnNjcmliZTogZnVuY3Rpb24gKHQpIHsgaC51bnN1YnNjcmliZVRvKHRoaXMsIHQudG9Mb3dlckNhc2UoKSkgfSwgdHJpZ2dlcjogZnVuY3Rpb24gKHQsIGUsIGkpIHsgZSA9IGUgfHwgdGhpczsgdmFyIHIsIG4gPSB0aGlzLl9saXN0ZW5lcnMgJiYgdGhpcy5fbGlzdGVuZXJzW3RdOyBpZiAobikgZm9yICh2YXIgcyA9IG4ubGVuZ3RoOyBzLS07KWlmICghMSA9PT0gKHIgPSBuW3NdLmNhbGwoZSwgZSwgaSkpKSByZXR1cm4gcjsgcmV0dXJuICF0aGlzLnBhcmVudCB8fCB0aGlzLnBhcmVudC50cmlnZ2VyKHQsIGUsIGkpIH0sIGFzeW5jSXNWYWxpZDogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuIGQud2Fybk9uY2UoXCJhc3luY0lzVmFsaWQgaXMgZGVwcmVjYXRlZDsgcGxlYXNlIHVzZSB3aGVuVmFsaWQgaW5zdGVhZFwiKSwgdGhpcy53aGVuVmFsaWQoeyBncm91cDogdCwgZm9yY2U6IGUgfSkgfSwgX2ZpbmRSZWxhdGVkOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm9wdGlvbnMubXVsdGlwbGUgPyBoKHRoaXMucGFyZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltcIi5jb25jYXQodGhpcy5vcHRpb25zLm5hbWVzcGFjZSwgJ211bHRpcGxlPVwiJykuY29uY2F0KHRoaXMub3B0aW9ucy5tdWx0aXBsZSwgJ1wiXScpKSkgOiB0aGlzLiRlbGVtZW50IH0gfTsgZnVuY3Rpb24gYyh0KSB7IGguZXh0ZW5kKCEwLCB0aGlzLCB0KSB9IGMucHJvdG90eXBlID0geyB2YWxpZGF0ZTogZnVuY3Rpb24gKHQsIGUpIHsgaWYgKHRoaXMuZm4pIHJldHVybiAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiAoZSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMSkpLCB0aGlzLmZuKHQsIGUpOyBpZiAoQXJyYXkuaXNBcnJheSh0KSkgeyBpZiAoIXRoaXMudmFsaWRhdGVNdWx0aXBsZSkgdGhyb3cgXCJWYWxpZGF0b3IgYFwiICsgdGhpcy5uYW1lICsgXCJgIGRvZXMgbm90IGhhbmRsZSBtdWx0aXBsZSB2YWx1ZXNcIjsgcmV0dXJuIHRoaXMudmFsaWRhdGVNdWx0aXBsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH0gdmFyIGkgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdOyBpZiAodGhpcy52YWxpZGF0ZURhdGUgJiYgaS5faXNEYXRlSW5wdXQoKSkgcmV0dXJuIGFyZ3VtZW50c1swXSA9IGQucGFyc2UuZGF0ZShhcmd1bWVudHNbMF0pLCBudWxsICE9PSBhcmd1bWVudHNbMF0gJiYgdGhpcy52YWxpZGF0ZURhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgaWYgKHRoaXMudmFsaWRhdGVOdW1iZXIpIHJldHVybiAhdCB8fCAhaXNOYU4odCkgJiYgKGFyZ3VtZW50c1swXSA9IHBhcnNlRmxvYXQoYXJndW1lbnRzWzBdKSwgdGhpcy52YWxpZGF0ZU51bWJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsgaWYgKHRoaXMudmFsaWRhdGVTdHJpbmcpIHJldHVybiB0aGlzLnZhbGlkYXRlU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHRocm93IFwiVmFsaWRhdG9yIGBcIiArIHRoaXMubmFtZSArIFwiYCBvbmx5IGhhbmRsZXMgbXVsdGlwbGUgdmFsdWVzXCIgfSwgcGFyc2VSZXF1aXJlbWVudHM6IGZ1bmN0aW9uICh0LCBlKSB7IGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiB0KSByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBbdF07IHZhciBpID0gdGhpcy5yZXF1aXJlbWVudFR5cGU7IGlmIChBcnJheS5pc0FycmF5KGkpKSB7IGZvciAodmFyIHIgPSBmdW5jdGlvbiAodCwgZSkgeyB2YXIgaSA9IHQubWF0Y2goL15cXHMqXFxbKC4qKVxcXVxccyokLyk7IGlmICghaSkgdGhyb3cgJ1JlcXVpcmVtZW50IGlzIG5vdCBhbiBhcnJheTogXCInICsgdCArICdcIic7IHZhciByID0gaVsxXS5zcGxpdChcIixcIikubWFwKGQudHJpbVN0cmluZyk7IGlmIChyLmxlbmd0aCAhPT0gZSkgdGhyb3cgXCJSZXF1aXJlbWVudCBoYXMgXCIgKyByLmxlbmd0aCArIFwiIHZhbHVlcyB3aGVuIFwiICsgZSArIFwiIGFyZSBuZWVkZWRcIjsgcmV0dXJuIHIgfSh0LCBpLmxlbmd0aCksIG4gPSAwOyBuIDwgci5sZW5ndGg7IG4rKylyW25dID0gZC5wYXJzZVJlcXVpcmVtZW50KGlbbl0sIHJbbl0pOyByZXR1cm4gciB9IHJldHVybiBoLmlzUGxhaW5PYmplY3QoaSkgPyBmdW5jdGlvbiAodCwgZSwgaSkgeyB2YXIgciA9IG51bGwsIG4gPSB7fTsgZm9yICh2YXIgcyBpbiB0KSBpZiAocykgeyB2YXIgYSA9IGkocyk7IFwic3RyaW5nXCIgPT0gdHlwZW9mIGEgJiYgKGEgPSBkLnBhcnNlUmVxdWlyZW1lbnQodFtzXSwgYSkpLCBuW3NdID0gYSB9IGVsc2UgciA9IGQucGFyc2VSZXF1aXJlbWVudCh0W3NdLCBlKTsgcmV0dXJuIFtyLCBuXSB9KGksIHQsIGUpIDogW2QucGFyc2VSZXF1aXJlbWVudChpLCB0KV0gfSwgcmVxdWlyZW1lbnRUeXBlOiBcInN0cmluZ1wiLCBwcmlvcml0eTogMiB9OyBmdW5jdGlvbiBhKHQsIGUpIHsgdGhpcy5fX2NsYXNzX18gPSBcIlZhbGlkYXRvclJlZ2lzdHJ5XCIsIHRoaXMubG9jYWxlID0gXCJlblwiLCB0aGlzLmluaXQodCB8fCB7fSwgZSB8fCB7fSkgfSB2YXIgcCA9IHsgZW1haWw6IC9eKCgoW2EtekEtWl18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2EtekEtWl18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpBLVpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16QS1aXXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpBLVpdfFxcZHwtfF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpBLVpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16QS1aXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2EtekEtWl18XFxkfC18X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2EtekEtWl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSQvLCBudW1iZXI6IC9eLT8oXFxkKlxcLik/XFxkKyhlWy0rXT9cXGQrKT8kL2ksIGludGVnZXI6IC9eLT9cXGQrJC8sIGRpZ2l0czogL15cXGQrJC8sIGFscGhhbnVtOiAvXlxcdyskL2ksIGRhdGU6IHsgdGVzdDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIG51bGwgIT09IGQucGFyc2UuZGF0ZSh0KSB9IH0sIHVybDogbmV3IFJlZ0V4cChcIl4oPzooPzpodHRwcz98ZnRwKTovLyk/KD86XFxcXFMrKD86OlxcXFxTKik/QCk/KD86KD86WzEtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswMV1cXFxcZHwyMlswLTNdKSg/OlxcXFwuKD86MT9cXFxcZHsxLDJ9fDJbMC00XVxcXFxkfDI1WzAtNV0pKXsyfSg/OlxcXFwuKD86WzEtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC00XSkpfCg/Oig/OlthLXpBLVpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XS0qKSpbYS16QS1aXFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0rKSg/OlxcXFwuKD86W2EtekEtWlxcXFx1MDBhMS1cXFxcdWZmZmYwLTldLSopKlthLXpBLVpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspKig/OlxcXFwuKD86W2EtekEtWlxcXFx1MDBhMS1cXFxcdWZmZmZdezIsfSkpKSg/OjpcXFxcZHsyLDV9KT8oPzovXFxcXFMqKT8kXCIpIH07IHAucmFuZ2UgPSBwLm51bWJlcjsgZnVuY3Rpb24gZih0KSB7IHZhciBlID0gKFwiXCIgKyB0KS5tYXRjaCgvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvKTsgcmV0dXJuIGUgPyBNYXRoLm1heCgwLCAoZVsxXSA/IGVbMV0ubGVuZ3RoIDogMCkgLSAoZVsyXSA/ICtlWzJdIDogMCkpIDogMCB9IGZ1bmN0aW9uIG0ocywgYSkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIGkgPSBuZXcgQXJyYXkoMSA8IGUgPyBlIC0gMSA6IDApLCByID0gMTsgciA8IGU7IHIrKylpW3IgLSAxXSA9IGFyZ3VtZW50c1tyXTsgcmV0dXJuIGkucG9wKCksIGEuYXBwbHkodm9pZCAwLCBbdF0uY29uY2F0KHUoKG4gPSBzLCBpLm1hcChkLnBhcnNlW25dKSkpKSk7IHZhciBuIH0gfSBmdW5jdGlvbiBnKHQpIHsgcmV0dXJuIHsgdmFsaWRhdGVEYXRlOiBtKFwiZGF0ZVwiLCB0KSwgdmFsaWRhdGVOdW1iZXI6IG0oXCJudW1iZXJcIiwgdCksIHJlcXVpcmVtZW50VHlwZTogdC5sZW5ndGggPD0gMiA/IFwic3RyaW5nXCIgOiBbXCJzdHJpbmdcIiwgXCJzdHJpbmdcIl0sIHByaW9yaXR5OiAzMCB9IH0gYS5wcm90b3R5cGUgPSB7IGluaXQ6IGZ1bmN0aW9uICh0LCBlKSB7IGZvciAodmFyIGkgaW4gdGhpcy5jYXRhbG9nID0gZSwgdGhpcy52YWxpZGF0b3JzID0gbCh7fSwgdGhpcy52YWxpZGF0b3JzKSwgdCkgdGhpcy5hZGRWYWxpZGF0b3IoaSwgdFtpXS5mbiwgdFtpXS5wcmlvcml0eSk7IHdpbmRvdy5QYXJzbGV5LnRyaWdnZXIoXCJwYXJzbGV5OnZhbGlkYXRvcjppbml0XCIpIH0sIHNldExvY2FsZTogZnVuY3Rpb24gKHQpIHsgaWYgKHZvaWQgMCA9PT0gdGhpcy5jYXRhbG9nW3RdKSB0aHJvdyBuZXcgRXJyb3IodCArIFwiIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGNhdGFsb2dcIik7IHJldHVybiB0aGlzLmxvY2FsZSA9IHQsIHRoaXMgfSwgYWRkQ2F0YWxvZzogZnVuY3Rpb24gKHQsIGUsIGkpIHsgcmV0dXJuIFwib2JqZWN0XCIgPT09IG4oZSkgJiYgKHRoaXMuY2F0YWxvZ1t0XSA9IGUpLCAhMCA9PT0gaSA/IHRoaXMuc2V0TG9jYWxlKHQpIDogdGhpcyB9LCBhZGRNZXNzYWdlOiBmdW5jdGlvbiAodCwgZSwgaSkgeyByZXR1cm4gdm9pZCAwID09PSB0aGlzLmNhdGFsb2dbdF0gJiYgKHRoaXMuY2F0YWxvZ1t0XSA9IHt9KSwgdGhpcy5jYXRhbG9nW3RdW2VdID0gaSwgdGhpcyB9LCBhZGRNZXNzYWdlczogZnVuY3Rpb24gKHQsIGUpIHsgZm9yICh2YXIgaSBpbiBlKSB0aGlzLmFkZE1lc3NhZ2UodCwgaSwgZVtpXSk7IHJldHVybiB0aGlzIH0sIGFkZFZhbGlkYXRvcjogZnVuY3Rpb24gKHQsIGUsIGkpIHsgaWYgKHRoaXMudmFsaWRhdG9yc1t0XSkgZC53YXJuKCdWYWxpZGF0b3IgXCInICsgdCArICdcIiBpcyBhbHJlYWR5IGRlZmluZWQuJyk7IGVsc2UgaWYgKHMuaGFzT3duUHJvcGVydHkodCkpIHJldHVybiB2b2lkIGQud2FybignXCInICsgdCArICdcIiBpcyBhIHJlc3RyaWN0ZWQga2V5d29yZCBhbmQgaXMgbm90IGEgdmFsaWQgdmFsaWRhdG9yIG5hbWUuJyk7IHJldHVybiB0aGlzLl9zZXRWYWxpZGF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9LCBoYXNWYWxpZGF0b3I6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAhIXRoaXMudmFsaWRhdG9yc1t0XSB9LCB1cGRhdGVWYWxpZGF0b3I6IGZ1bmN0aW9uICh0LCBlLCBpKSB7IHJldHVybiB0aGlzLnZhbGlkYXRvcnNbdF0gPyB0aGlzLl9zZXRWYWxpZGF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IChkLndhcm4oJ1ZhbGlkYXRvciBcIicgKyB0ICsgJ1wiIGlzIG5vdCBhbHJlYWR5IGRlZmluZWQuJyksIHRoaXMuYWRkVmFsaWRhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIH0sIHJlbW92ZVZhbGlkYXRvcjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHRoaXMudmFsaWRhdG9yc1t0XSB8fCBkLndhcm4oJ1ZhbGlkYXRvciBcIicgKyB0ICsgJ1wiIGlzIG5vdCBkZWZpbmVkLicpLCBkZWxldGUgdGhpcy52YWxpZGF0b3JzW3RdLCB0aGlzIH0sIF9zZXRWYWxpZGF0b3I6IGZ1bmN0aW9uICh0LCBlLCBpKSB7IGZvciAodmFyIHIgaW4gXCJvYmplY3RcIiAhPT0gbihlKSAmJiAoZSA9IHsgZm46IGUsIHByaW9yaXR5OiBpIH0pLCBlLnZhbGlkYXRlIHx8IChlID0gbmV3IGMoZSkpLCAodGhpcy52YWxpZGF0b3JzW3RdID0gZSkubWVzc2FnZXMgfHwge30pIHRoaXMuYWRkTWVzc2FnZShyLCB0LCBlLm1lc3NhZ2VzW3JdKTsgcmV0dXJuIHRoaXMgfSwgZ2V0RXJyb3JNZXNzYWdlOiBmdW5jdGlvbiAodCkgeyB2YXIgZTsgXCJ0eXBlXCIgPT09IHQubmFtZSA/IGUgPSAodGhpcy5jYXRhbG9nW3RoaXMubG9jYWxlXVt0Lm5hbWVdIHx8IHt9KVt0LnJlcXVpcmVtZW50c10gOiBlID0gdGhpcy5mb3JtYXRNZXNzYWdlKHRoaXMuY2F0YWxvZ1t0aGlzLmxvY2FsZV1bdC5uYW1lXSwgdC5yZXF1aXJlbWVudHMpOyByZXR1cm4gZSB8fCB0aGlzLmNhdGFsb2dbdGhpcy5sb2NhbGVdLmRlZmF1bHRNZXNzYWdlIHx8IHRoaXMuY2F0YWxvZy5lbi5kZWZhdWx0TWVzc2FnZSB9LCBmb3JtYXRNZXNzYWdlOiBmdW5jdGlvbiAodCwgZSkgeyBpZiAoXCJvYmplY3RcIiAhPT0gbihlKSkgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyB0LnJlcGxhY2UoLyVzL2ksIGUpIDogXCJcIjsgZm9yICh2YXIgaSBpbiBlKSB0ID0gdGhpcy5mb3JtYXRNZXNzYWdlKHQsIGVbaV0pOyByZXR1cm4gdCB9LCB2YWxpZGF0b3JzOiB7IG5vdGJsYW5rOiB7IHZhbGlkYXRlU3RyaW5nOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gL1xcUy8udGVzdCh0KSB9LCBwcmlvcml0eTogMiB9LCByZXF1aXJlZDogeyB2YWxpZGF0ZU11bHRpcGxlOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMCA8IHQubGVuZ3RoIH0sIHZhbGlkYXRlU3RyaW5nOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gL1xcUy8udGVzdCh0KSB9LCBwcmlvcml0eTogNTEyIH0sIHR5cGU6IHsgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uICh0LCBlLCBpKSB7IHZhciByID0gMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBpID8gaSA6IHt9LCBuID0gci5zdGVwLCBzID0gdm9pZCAwID09PSBuID8gXCJhbnlcIiA6IG4sIGEgPSByLmJhc2UsIG8gPSB2b2lkIDAgPT09IGEgPyAwIDogYSwgbCA9IHBbZV07IGlmICghbCkgdGhyb3cgbmV3IEVycm9yKFwidmFsaWRhdG9yIHR5cGUgYFwiICsgZSArIFwiYCBpcyBub3Qgc3VwcG9ydGVkXCIpOyBpZiAoIXQpIHJldHVybiAhMDsgaWYgKCFsLnRlc3QodCkpIHJldHVybiAhMTsgaWYgKFwibnVtYmVyXCIgPT09IGUgJiYgIS9eYW55JC9pLnRlc3QocyB8fCBcIlwiKSkgeyB2YXIgdSA9IE51bWJlcih0KSwgZCA9IE1hdGgubWF4KGYocyksIGYobykpOyBpZiAoZih1KSA+IGQpIHJldHVybiAhMTsgdmFyIGggPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gTWF0aC5yb3VuZCh0ICogTWF0aC5wb3coMTAsIGQpKSB9OyBpZiAoKGgodSkgLSBoKG8pKSAlIGgocykgIT0gMCkgcmV0dXJuICExIH0gcmV0dXJuICEwIH0sIHJlcXVpcmVtZW50VHlwZTogeyBcIlwiOiBcInN0cmluZ1wiLCBzdGVwOiBcInN0cmluZ1wiLCBiYXNlOiBcIm51bWJlclwiIH0sIHByaW9yaXR5OiAyNTYgfSwgcGF0dGVybjogeyB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gKHQsIGUpIHsgcmV0dXJuICF0IHx8IGUudGVzdCh0KSB9LCByZXF1aXJlbWVudFR5cGU6IFwicmVnZXhwXCIsIHByaW9yaXR5OiA2NCB9LCBtaW5sZW5ndGg6IHsgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiAhdCB8fCB0Lmxlbmd0aCA+PSBlIH0sIHJlcXVpcmVtZW50VHlwZTogXCJpbnRlZ2VyXCIsIHByaW9yaXR5OiAzMCB9LCBtYXhsZW5ndGg6IHsgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiB0Lmxlbmd0aCA8PSBlIH0sIHJlcXVpcmVtZW50VHlwZTogXCJpbnRlZ2VyXCIsIHByaW9yaXR5OiAzMCB9LCBsZW5ndGg6IHsgdmFsaWRhdGVTdHJpbmc6IGZ1bmN0aW9uICh0LCBlLCBpKSB7IHJldHVybiAhdCB8fCB0Lmxlbmd0aCA+PSBlICYmIHQubGVuZ3RoIDw9IGkgfSwgcmVxdWlyZW1lbnRUeXBlOiBbXCJpbnRlZ2VyXCIsIFwiaW50ZWdlclwiXSwgcHJpb3JpdHk6IDMwIH0sIG1pbmNoZWNrOiB7IHZhbGlkYXRlTXVsdGlwbGU6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiB0Lmxlbmd0aCA+PSBlIH0sIHJlcXVpcmVtZW50VHlwZTogXCJpbnRlZ2VyXCIsIHByaW9yaXR5OiAzMCB9LCBtYXhjaGVjazogeyB2YWxpZGF0ZU11bHRpcGxlOiBmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gdC5sZW5ndGggPD0gZSB9LCByZXF1aXJlbWVudFR5cGU6IFwiaW50ZWdlclwiLCBwcmlvcml0eTogMzAgfSwgY2hlY2s6IHsgdmFsaWRhdGVNdWx0aXBsZTogZnVuY3Rpb24gKHQsIGUsIGkpIHsgcmV0dXJuIHQubGVuZ3RoID49IGUgJiYgdC5sZW5ndGggPD0gaSB9LCByZXF1aXJlbWVudFR5cGU6IFtcImludGVnZXJcIiwgXCJpbnRlZ2VyXCJdLCBwcmlvcml0eTogMzAgfSwgbWluOiBnKGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiBlIDw9IHQgfSksIG1heDogZyhmdW5jdGlvbiAodCwgZSkgeyByZXR1cm4gdCA8PSBlIH0pLCByYW5nZTogZyhmdW5jdGlvbiAodCwgZSwgaSkgeyByZXR1cm4gZSA8PSB0ICYmIHQgPD0gaSB9KSwgZXF1YWx0bzogeyB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gKHQsIGUpIHsgaWYgKCF0KSByZXR1cm4gITA7IHZhciBpID0gaChlKTsgcmV0dXJuIGkubGVuZ3RoID8gdCA9PT0gaS52YWwoKSA6IHQgPT09IGUgfSwgcHJpb3JpdHk6IDI1NiB9LCBldXZhdGluOiB7IHZhbGlkYXRlU3RyaW5nOiBmdW5jdGlvbiAodCkgeyBpZiAoIXQpIHJldHVybiAhMDsgcmV0dXJuIC9eW0EtWl1bQS1aXVtBLVphLXowLTkgLV17Mix9JC8udGVzdCh0KSB9LCBwcmlvcml0eTogMzAgfSB9IH07IHZhciB2ID0ge307IHYuRm9ybSA9IHsgX2FjdHVhbGl6ZVRyaWdnZXJzOiBmdW5jdGlvbiAoKSB7IHZhciBlID0gdGhpczsgdGhpcy4kZWxlbWVudC5vbihcInN1Ym1pdC5QYXJzbGV5XCIsIGZ1bmN0aW9uICh0KSB7IGUub25TdWJtaXRWYWxpZGF0ZSh0KSB9KSwgdGhpcy4kZWxlbWVudC5vbihcImNsaWNrLlBhcnNsZXlcIiwgZC5fU3VibWl0U2VsZWN0b3IsIGZ1bmN0aW9uICh0KSB7IGUub25TdWJtaXRCdXR0b24odCkgfSksICExICE9PSB0aGlzLm9wdGlvbnMudWlFbmFibGVkICYmIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub3ZhbGlkYXRlXCIsIFwiXCIpIH0sIGZvY3VzOiBmdW5jdGlvbiAoKSB7IGlmICghKHRoaXMuX2ZvY3VzZWRGaWVsZCA9IG51bGwpID09PSB0aGlzLnZhbGlkYXRpb25SZXN1bHQgfHwgXCJub25lXCIgPT09IHRoaXMub3B0aW9ucy5mb2N1cykgcmV0dXJuIG51bGw7IGZvciAodmFyIHQgPSAwOyB0IDwgdGhpcy5maWVsZHMubGVuZ3RoOyB0KyspIHsgdmFyIGUgPSB0aGlzLmZpZWxkc1t0XTsgaWYgKCEwICE9PSBlLnZhbGlkYXRpb25SZXN1bHQgJiYgMCA8IGUudmFsaWRhdGlvblJlc3VsdC5sZW5ndGggJiYgdm9pZCAwID09PSBlLm9wdGlvbnMubm9Gb2N1cyAmJiAodGhpcy5fZm9jdXNlZEZpZWxkID0gZS4kZWxlbWVudCwgXCJmaXJzdFwiID09PSB0aGlzLm9wdGlvbnMuZm9jdXMpKSBicmVhayB9IHJldHVybiBudWxsID09PSB0aGlzLl9mb2N1c2VkRmllbGQgPyBudWxsIDogdGhpcy5fZm9jdXNlZEZpZWxkLmZvY3VzKCkgfSwgX2Rlc3Ryb3lVSTogZnVuY3Rpb24gKCkgeyB0aGlzLiRlbGVtZW50Lm9mZihcIi5QYXJzbGV5XCIpIH0gfSwgdi5GaWVsZCA9IHsgX3JlZmxvd1VJOiBmdW5jdGlvbiAoKSB7IGlmICh0aGlzLl9idWlsZFVJKCksIHRoaXMuX3VpKSB7IHZhciB0ID0gZnVuY3Rpb24gdChlLCBpLCByKSB7IGZvciAodmFyIG4gPSBbXSwgcyA9IFtdLCBhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspIHsgZm9yICh2YXIgbyA9ICExLCBsID0gMDsgbCA8IGkubGVuZ3RoOyBsKyspaWYgKGVbYV0uYXNzZXJ0Lm5hbWUgPT09IGlbbF0uYXNzZXJ0Lm5hbWUpIHsgbyA9ICEwOyBicmVhayB9IG8gPyBzLnB1c2goZVthXSkgOiBuLnB1c2goZVthXSkgfSByZXR1cm4geyBrZXB0OiBzLCBhZGRlZDogbiwgcmVtb3ZlZDogciA/IFtdIDogdChpLCBlLCAhMCkuYWRkZWQgfSB9KHRoaXMudmFsaWRhdGlvblJlc3VsdCwgdGhpcy5fdWkubGFzdFZhbGlkYXRpb25SZXN1bHQpOyB0aGlzLl91aS5sYXN0VmFsaWRhdGlvblJlc3VsdCA9IHRoaXMudmFsaWRhdGlvblJlc3VsdCwgdGhpcy5fbWFuYWdlU3RhdHVzQ2xhc3MoKSwgdGhpcy5fbWFuYWdlRXJyb3JzTWVzc2FnZXModCksIHRoaXMuX2FjdHVhbGl6ZVRyaWdnZXJzKCksICF0LmtlcHQubGVuZ3RoICYmICF0LmFkZGVkLmxlbmd0aCB8fCB0aGlzLl9mYWlsZWRPbmNlIHx8ICh0aGlzLl9mYWlsZWRPbmNlID0gITAsIHRoaXMuX2FjdHVhbGl6ZVRyaWdnZXJzKCkpIH0gfSwgZ2V0RXJyb3JzTWVzc2FnZXM6IGZ1bmN0aW9uICgpIHsgaWYgKCEwID09PSB0aGlzLnZhbGlkYXRpb25SZXN1bHQpIHJldHVybiBbXTsgZm9yICh2YXIgdCA9IFtdLCBlID0gMDsgZSA8IHRoaXMudmFsaWRhdGlvblJlc3VsdC5sZW5ndGg7IGUrKyl0LnB1c2godGhpcy52YWxpZGF0aW9uUmVzdWx0W2VdLmVycm9yTWVzc2FnZSB8fCB0aGlzLl9nZXRFcnJvck1lc3NhZ2UodGhpcy52YWxpZGF0aW9uUmVzdWx0W2VdLmFzc2VydCkpOyByZXR1cm4gdCB9LCBhZGRFcnJvcjogZnVuY3Rpb24gKHQsIGUpIHsgdmFyIGkgPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGUgPyBlIDoge30sIHIgPSBpLm1lc3NhZ2UsIG4gPSBpLmFzc2VydCwgcyA9IGkudXBkYXRlQ2xhc3MsIGEgPSB2b2lkIDAgPT09IHMgfHwgczsgdGhpcy5fYnVpbGRVSSgpLCB0aGlzLl9hZGRFcnJvcih0LCB7IG1lc3NhZ2U6IHIsIGFzc2VydDogbiB9KSwgYSAmJiB0aGlzLl9lcnJvckNsYXNzKCkgfSwgdXBkYXRlRXJyb3I6IGZ1bmN0aW9uICh0LCBlKSB7IHZhciBpID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBlID8gZSA6IHt9LCByID0gaS5tZXNzYWdlLCBuID0gaS5hc3NlcnQsIHMgPSBpLnVwZGF0ZUNsYXNzLCBhID0gdm9pZCAwID09PSBzIHx8IHM7IHRoaXMuX2J1aWxkVUkoKSwgdGhpcy5fdXBkYXRlRXJyb3IodCwgeyBtZXNzYWdlOiByLCBhc3NlcnQ6IG4gfSksIGEgJiYgdGhpcy5fZXJyb3JDbGFzcygpIH0sIHJlbW92ZUVycm9yOiBmdW5jdGlvbiAodCwgZSkgeyB2YXIgaSA9ICgxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGUgPyBlIDoge30pLnVwZGF0ZUNsYXNzLCByID0gdm9pZCAwID09PSBpIHx8IGk7IHRoaXMuX2J1aWxkVUkoKSwgdGhpcy5fcmVtb3ZlRXJyb3IodCksIHIgJiYgdGhpcy5fbWFuYWdlU3RhdHVzQ2xhc3MoKSB9LCBfbWFuYWdlU3RhdHVzQ2xhc3M6IGZ1bmN0aW9uICgpIHsgdGhpcy5oYXNDb25zdHJhaW50cygpICYmIHRoaXMubmVlZHNWYWxpZGF0aW9uKCkgJiYgITAgPT09IHRoaXMudmFsaWRhdGlvblJlc3VsdCA/IHRoaXMuX3N1Y2Nlc3NDbGFzcygpIDogMCA8IHRoaXMudmFsaWRhdGlvblJlc3VsdC5sZW5ndGggPyB0aGlzLl9lcnJvckNsYXNzKCkgOiB0aGlzLl9yZXNldENsYXNzKCkgfSwgX21hbmFnZUVycm9yc01lc3NhZ2VzOiBmdW5jdGlvbiAodCkgeyBpZiAodm9pZCAwID09PSB0aGlzLm9wdGlvbnMuZXJyb3JzTWVzc2FnZXNEaXNhYmxlZCkgeyBpZiAodm9pZCAwICE9PSB0aGlzLm9wdGlvbnMuZXJyb3JNZXNzYWdlKSByZXR1cm4gdC5hZGRlZC5sZW5ndGggfHwgdC5rZXB0Lmxlbmd0aCA/ICh0aGlzLl9pbnNlcnRFcnJvcldyYXBwZXIoKSwgMCA9PT0gdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIuZmluZChcIi5wYXJzbGV5LWN1c3RvbS1lcnJvci1tZXNzYWdlXCIpLmxlbmd0aCAmJiB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5hcHBlbmQoaCh0aGlzLm9wdGlvbnMuZXJyb3JUZW1wbGF0ZSkuYWRkQ2xhc3MoXCJwYXJzbGV5LWN1c3RvbS1lcnJvci1tZXNzYWdlXCIpKSwgdGhpcy5fdWkuJGVycm9yQ2xhc3NIYW5kbGVyLmF0dHIoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIHRoaXMuX3VpLmVycm9yc1dyYXBwZXJJZCksIHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLmFkZENsYXNzKFwiZmlsbGVkXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLCBcImZhbHNlXCIpLmZpbmQoXCIucGFyc2xleS1jdXN0b20tZXJyb3ItbWVzc2FnZVwiKS5odG1sKHRoaXMub3B0aW9ucy5lcnJvck1lc3NhZ2UpKSA6ICh0aGlzLl91aS4kZXJyb3JDbGFzc0hhbmRsZXIucmVtb3ZlQXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIiksIHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLnJlbW92ZUNsYXNzKFwiZmlsbGVkXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIikuZmluZChcIi5wYXJzbGV5LWN1c3RvbS1lcnJvci1tZXNzYWdlXCIpLnJlbW92ZSgpKTsgZm9yICh2YXIgZSA9IDA7IGUgPCB0LnJlbW92ZWQubGVuZ3RoOyBlKyspdGhpcy5fcmVtb3ZlRXJyb3IodC5yZW1vdmVkW2VdLmFzc2VydC5uYW1lKTsgZm9yIChlID0gMDsgZSA8IHQuYWRkZWQubGVuZ3RoOyBlKyspdGhpcy5fYWRkRXJyb3IodC5hZGRlZFtlXS5hc3NlcnQubmFtZSwgeyBtZXNzYWdlOiB0LmFkZGVkW2VdLmVycm9yTWVzc2FnZSwgYXNzZXJ0OiB0LmFkZGVkW2VdLmFzc2VydCB9KTsgZm9yIChlID0gMDsgZSA8IHQua2VwdC5sZW5ndGg7IGUrKyl0aGlzLl91cGRhdGVFcnJvcih0LmtlcHRbZV0uYXNzZXJ0Lm5hbWUsIHsgbWVzc2FnZTogdC5rZXB0W2VdLmVycm9yTWVzc2FnZSwgYXNzZXJ0OiB0LmtlcHRbZV0uYXNzZXJ0IH0pIH0gfSwgX2FkZEVycm9yOiBmdW5jdGlvbiAodCwgZSkgeyB2YXIgaSA9IGUubWVzc2FnZSwgciA9IGUuYXNzZXJ0OyB0aGlzLl9pbnNlcnRFcnJvcldyYXBwZXIoKSwgdGhpcy5fdWkuJGVycm9yQ2xhc3NIYW5kbGVyLmF0dHIoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIHRoaXMuX3VpLmVycm9yc1dyYXBwZXJJZCksIHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyLmFkZENsYXNzKFwiZmlsbGVkXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLCBcImZhbHNlXCIpLmFwcGVuZChoKHRoaXMub3B0aW9ucy5lcnJvclRlbXBsYXRlKS5hZGRDbGFzcyhcInBhcnNsZXktXCIgKyB0KS5odG1sKGkgfHwgdGhpcy5fZ2V0RXJyb3JNZXNzYWdlKHIpKSkgfSwgX3VwZGF0ZUVycm9yOiBmdW5jdGlvbiAodCwgZSkgeyB2YXIgaSA9IGUubWVzc2FnZSwgciA9IGUuYXNzZXJ0OyB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5hZGRDbGFzcyhcImZpbGxlZFwiKS5maW5kKFwiLnBhcnNsZXktXCIgKyB0KS5odG1sKGkgfHwgdGhpcy5fZ2V0RXJyb3JNZXNzYWdlKHIpKSB9LCBfcmVtb3ZlRXJyb3I6IGZ1bmN0aW9uICh0KSB7IHRoaXMuX3VpLiRlcnJvckNsYXNzSGFuZGxlci5yZW1vdmVBdHRyKFwiYXJpYS1kZXNjcmliZWRieVwiKSwgdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIucmVtb3ZlQ2xhc3MoXCJmaWxsZWRcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKS5maW5kKFwiLnBhcnNsZXktXCIgKyB0KS5yZW1vdmUoKSB9LCBfZ2V0RXJyb3JNZXNzYWdlOiBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IHQubmFtZSArIFwiTWVzc2FnZVwiOyByZXR1cm4gdm9pZCAwICE9PSB0aGlzLm9wdGlvbnNbZV0gPyB3aW5kb3cuUGFyc2xleS5mb3JtYXRNZXNzYWdlKHRoaXMub3B0aW9uc1tlXSwgdC5yZXF1aXJlbWVudHMpIDogd2luZG93LlBhcnNsZXkuZ2V0RXJyb3JNZXNzYWdlKHQpIH0sIF9idWlsZFVJOiBmdW5jdGlvbiAoKSB7IGlmICghdGhpcy5fdWkgJiYgITEgIT09IHRoaXMub3B0aW9ucy51aUVuYWJsZWQpIHsgdmFyIHQgPSB7fTsgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMubmFtZXNwYWNlICsgXCJpZFwiLCB0aGlzLl9faWRfXyksIHQuJGVycm9yQ2xhc3NIYW5kbGVyID0gdGhpcy5fbWFuYWdlQ2xhc3NIYW5kbGVyKCksIHQuZXJyb3JzV3JhcHBlcklkID0gXCJwYXJzbGV5LWlkLVwiICsgKHRoaXMub3B0aW9ucy5tdWx0aXBsZSA/IFwibXVsdGlwbGUtXCIgKyB0aGlzLm9wdGlvbnMubXVsdGlwbGUgOiB0aGlzLl9faWRfXyksIHQuJGVycm9yc1dyYXBwZXIgPSBoKHRoaXMub3B0aW9ucy5lcnJvcnNXcmFwcGVyKS5hdHRyKFwiaWRcIiwgdC5lcnJvcnNXcmFwcGVySWQpLCB0Lmxhc3RWYWxpZGF0aW9uUmVzdWx0ID0gW10sIHQudmFsaWRhdGlvbkluZm9ybWF0aW9uVmlzaWJsZSA9ICExLCB0aGlzLl91aSA9IHQgfSB9LCBfbWFuYWdlQ2xhc3NIYW5kbGVyOiBmdW5jdGlvbiAoKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0aGlzLm9wdGlvbnMuY2xhc3NIYW5kbGVyICYmIGgodGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlcikubGVuZ3RoKSByZXR1cm4gaCh0aGlzLm9wdGlvbnMuY2xhc3NIYW5kbGVyKTsgdmFyIHQgPSB0aGlzLm9wdGlvbnMuY2xhc3NIYW5kbGVyOyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGhpcy5vcHRpb25zLmNsYXNzSGFuZGxlciAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbmRvd1t0aGlzLm9wdGlvbnMuY2xhc3NIYW5kbGVyXSAmJiAodCA9IHdpbmRvd1t0aGlzLm9wdGlvbnMuY2xhc3NIYW5kbGVyXSksIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCkgeyB2YXIgZSA9IHQuY2FsbCh0aGlzLCB0aGlzKTsgaWYgKHZvaWQgMCAhPT0gZSAmJiBlLmxlbmd0aCkgcmV0dXJuIGUgfSBlbHNlIHsgaWYgKFwib2JqZWN0XCIgPT09IG4odCkgJiYgdCBpbnN0YW5jZW9mIGpRdWVyeSAmJiB0Lmxlbmd0aCkgcmV0dXJuIHQ7IHQgJiYgZC53YXJuKFwiVGhlIGNsYXNzIGhhbmRsZXIgYFwiICsgdCArIFwiYCBkb2VzIG5vdCBleGlzdCBpbiBET00gbm9yIGFzIGEgZ2xvYmFsIEpTIGZ1bmN0aW9uXCIpIH0gcmV0dXJuIHRoaXMuX2lucHV0SG9sZGVyKCkgfSwgX2lucHV0SG9sZGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm9wdGlvbnMubXVsdGlwbGUgJiYgXCJTRUxFQ1RcIiAhPT0gdGhpcy5lbGVtZW50Lm5vZGVOYW1lID8gdGhpcy4kZWxlbWVudC5wYXJlbnQoKSA6IHRoaXMuJGVsZW1lbnQgfSwgX2luc2VydEVycm9yV3JhcHBlcjogZnVuY3Rpb24gKCkgeyB2YXIgdCA9IHRoaXMub3B0aW9ucy5lcnJvcnNDb250YWluZXI7IGlmICgwICE9PSB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5wYXJlbnQoKS5sZW5ndGgpIHJldHVybiB0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5wYXJlbnQoKTsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHsgaWYgKGgodCkubGVuZ3RoKSByZXR1cm4gaCh0KS5hcHBlbmQodGhpcy5fdWkuJGVycm9yc1dyYXBwZXIpOyBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbmRvd1t0XSA/IHQgPSB3aW5kb3dbdF0gOiBkLndhcm4oXCJUaGUgZXJyb3JzIGNvbnRhaW5lciBgXCIgKyB0ICsgXCJgIGRvZXMgbm90IGV4aXN0IGluIERPTSBub3IgYXMgYSBnbG9iYWwgSlMgZnVuY3Rpb25cIikgfSByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ICYmICh0ID0gdC5jYWxsKHRoaXMsIHRoaXMpKSwgXCJvYmplY3RcIiA9PT0gbih0KSAmJiB0Lmxlbmd0aCA/IHQuYXBwZW5kKHRoaXMuX3VpLiRlcnJvcnNXcmFwcGVyKSA6IHRoaXMuX2lucHV0SG9sZGVyKCkuYWZ0ZXIodGhpcy5fdWkuJGVycm9yc1dyYXBwZXIpIH0sIF9hY3R1YWxpemVUcmlnZ2VyczogZnVuY3Rpb24gKCkgeyB2YXIgdCwgZSA9IHRoaXMsIGkgPSB0aGlzLl9maW5kUmVsYXRlZCgpOyBpLm9mZihcIi5QYXJzbGV5XCIpLCB0aGlzLl9mYWlsZWRPbmNlID8gaS5vbihkLm5hbWVzcGFjZUV2ZW50cyh0aGlzLm9wdGlvbnMudHJpZ2dlckFmdGVyRmFpbHVyZSwgXCJQYXJzbGV5XCIpLCBmdW5jdGlvbiAoKSB7IGUuX3ZhbGlkYXRlSWZOZWVkZWQoKSB9KSA6ICh0ID0gZC5uYW1lc3BhY2VFdmVudHModGhpcy5vcHRpb25zLnRyaWdnZXIsIFwiUGFyc2xleVwiKSkgJiYgaS5vbih0LCBmdW5jdGlvbiAodCkgeyBlLl92YWxpZGF0ZUlmTmVlZGVkKHQpIH0pIH0sIF92YWxpZGF0ZUlmTmVlZGVkOiBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IHRoaXM7IHQgJiYgL2tleXxpbnB1dC8udGVzdCh0LnR5cGUpICYmICghdGhpcy5fdWkgfHwgIXRoaXMuX3VpLnZhbGlkYXRpb25JbmZvcm1hdGlvblZpc2libGUpICYmIHRoaXMuZ2V0VmFsdWUoKS5sZW5ndGggPD0gdGhpcy5vcHRpb25zLnZhbGlkYXRpb25UaHJlc2hvbGQgfHwgKHRoaXMub3B0aW9ucy5kZWJvdW5jZSA/ICh3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2RlYm91bmNlZCksIHRoaXMuX2RlYm91bmNlZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGUudmFsaWRhdGUoKSB9LCB0aGlzLm9wdGlvbnMuZGVib3VuY2UpKSA6IHRoaXMudmFsaWRhdGUoKSkgfSwgX3Jlc2V0VUk6IGZ1bmN0aW9uICgpIHsgdGhpcy5fZmFpbGVkT25jZSA9ICExLCB0aGlzLl9hY3R1YWxpemVUcmlnZ2VycygpLCB2b2lkIDAgIT09IHRoaXMuX3VpICYmICh0aGlzLl91aS4kZXJyb3JzV3JhcHBlci5yZW1vdmVDbGFzcyhcImZpbGxlZFwiKS5jaGlsZHJlbigpLnJlbW92ZSgpLCB0aGlzLl9yZXNldENsYXNzKCksIHRoaXMuX3VpLmxhc3RWYWxpZGF0aW9uUmVzdWx0ID0gW10sIHRoaXMuX3VpLnZhbGlkYXRpb25JbmZvcm1hdGlvblZpc2libGUgPSAhMSkgfSwgX2Rlc3Ryb3lVSTogZnVuY3Rpb24gKCkgeyB0aGlzLl9yZXNldFVJKCksIHZvaWQgMCAhPT0gdGhpcy5fdWkgJiYgdGhpcy5fdWkuJGVycm9yc1dyYXBwZXIucmVtb3ZlKCksIGRlbGV0ZSB0aGlzLl91aSB9LCBfc3VjY2Vzc0NsYXNzOiBmdW5jdGlvbiAoKSB7IHRoaXMuX3VpLnZhbGlkYXRpb25JbmZvcm1hdGlvblZpc2libGUgPSAhMCwgdGhpcy5fdWkuJGVycm9yQ2xhc3NIYW5kbGVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5lcnJvckNsYXNzKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuc3VjY2Vzc0NsYXNzKSB9LCBfZXJyb3JDbGFzczogZnVuY3Rpb24gKCkgeyB0aGlzLl91aS52YWxpZGF0aW9uSW5mb3JtYXRpb25WaXNpYmxlID0gITAsIHRoaXMuX3VpLiRlcnJvckNsYXNzSGFuZGxlci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuc3VjY2Vzc0NsYXNzKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykgfSwgX3Jlc2V0Q2xhc3M6IGZ1bmN0aW9uICgpIHsgdGhpcy5fdWkuJGVycm9yQ2xhc3NIYW5kbGVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5zdWNjZXNzQ2xhc3MpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5lcnJvckNsYXNzKSB9IH07IGZ1bmN0aW9uIHkodCwgZSwgaSkgeyB0aGlzLl9fY2xhc3NfXyA9IFwiRm9ybVwiLCB0aGlzLmVsZW1lbnQgPSB0LCB0aGlzLiRlbGVtZW50ID0gaCh0KSwgdGhpcy5kb21PcHRpb25zID0gZSwgdGhpcy5vcHRpb25zID0gaSwgdGhpcy5wYXJlbnQgPSB3aW5kb3cuUGFyc2xleSwgdGhpcy5maWVsZHMgPSBbXSwgdGhpcy52YWxpZGF0aW9uUmVzdWx0ID0gbnVsbCB9IHZhciBfID0geyBwZW5kaW5nOiBudWxsLCByZXNvbHZlZDogITAsIHJlamVjdGVkOiAhMSB9OyB5LnByb3RvdHlwZSA9IHsgb25TdWJtaXRWYWxpZGF0ZTogZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSB0aGlzOyBpZiAoITAgIT09IHQucGFyc2xleSkgeyB2YXIgaSA9IHRoaXMuX3N1Ym1pdFNvdXJjZSB8fCB0aGlzLiRlbGVtZW50LmZpbmQoZC5fU3VibWl0U2VsZWN0b3IpWzBdOyBpZiAodGhpcy5fc3VibWl0U291cmNlID0gbnVsbCwgdGhpcy4kZWxlbWVudC5maW5kKFwiLnBhcnNsZXktc3ludGhldGljLXN1Ym1pdC1idXR0b25cIikucHJvcChcImRpc2FibGVkXCIsICEwKSwgIWkgfHwgbnVsbCA9PT0gaS5nZXRBdHRyaWJ1dGUoXCJmb3Jtbm92YWxpZGF0ZVwiKSkgeyB3aW5kb3cuUGFyc2xleS5fcmVtb3RlQ2FjaGUgPSB7fTsgdmFyIHIgPSB0aGlzLndoZW5WYWxpZGF0ZSh7IGV2ZW50OiB0IH0pOyBcInJlc29sdmVkXCIgPT09IHIuc3RhdGUoKSAmJiAhMSAhPT0gdGhpcy5fdHJpZ2dlcihcInN1Ym1pdFwiKSB8fCAodC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdC5wcmV2ZW50RGVmYXVsdCgpLCBcInBlbmRpbmdcIiA9PT0gci5zdGF0ZSgpICYmIHIuZG9uZShmdW5jdGlvbiAoKSB7IGUuX3N1Ym1pdChpKSB9KSkgfSB9IH0sIG9uU3VibWl0QnV0dG9uOiBmdW5jdGlvbiAodCkgeyB0aGlzLl9zdWJtaXRTb3VyY2UgPSB0LmN1cnJlbnRUYXJnZXQgfSwgX3N1Ym1pdDogZnVuY3Rpb24gKHQpIHsgaWYgKCExICE9PSB0aGlzLl90cmlnZ2VyKFwic3VibWl0XCIpKSB7IGlmICh0KSB7IHZhciBlID0gdGhpcy4kZWxlbWVudC5maW5kKFwiLnBhcnNsZXktc3ludGhldGljLXN1Ym1pdC1idXR0b25cIikucHJvcChcImRpc2FibGVkXCIsICExKTsgMCA9PT0gZS5sZW5ndGggJiYgKGUgPSBoKCc8aW5wdXQgY2xhc3M9XCJwYXJzbGV5LXN5bnRoZXRpYy1zdWJtaXQtYnV0dG9uXCIgdHlwZT1cImhpZGRlblwiPicpLmFwcGVuZFRvKHRoaXMuJGVsZW1lbnQpKSwgZS5hdHRyKHsgbmFtZTogdC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpLCB2YWx1ZTogdC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSB9KSB9IHRoaXMuJGVsZW1lbnQudHJpZ2dlcihsKGguRXZlbnQoXCJzdWJtaXRcIiksIHsgcGFyc2xleTogITAgfSkpIH0gfSwgdmFsaWRhdGU6IGZ1bmN0aW9uICh0KSB7IGlmICgxIDw9IGFyZ3VtZW50cy5sZW5ndGggJiYgIWguaXNQbGFpbk9iamVjdCh0KSkgeyBkLndhcm5PbmNlKFwiQ2FsbGluZyB2YWxpZGF0ZSBvbiBhIHBhcnNsZXkgZm9ybSB3aXRob3V0IHBhc3NpbmcgYXJndW1lbnRzIGFzIGFuIG9iamVjdCBpcyBkZXByZWNhdGVkLlwiKTsgdmFyIGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpOyB0ID0geyBncm91cDogZVswXSwgZm9yY2U6IGVbMV0sIGV2ZW50OiBlWzJdIH0gfSByZXR1cm4gX1t0aGlzLndoZW5WYWxpZGF0ZSh0KS5zdGF0ZSgpXSB9LCB3aGVuVmFsaWRhdGU6IGZ1bmN0aW9uICh0KSB7IHZhciBlLCBpID0gdGhpcywgciA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gdCA/IHQgOiB7fSwgbiA9IHIuZ3JvdXAsIHMgPSByLmZvcmNlLCBhID0gci5ldmVudDsgKHRoaXMuc3VibWl0RXZlbnQgPSBhKSAmJiAodGhpcy5zdWJtaXRFdmVudCA9IGwoe30sIGEsIHsgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHsgZC53YXJuT25jZShcIlVzaW5nIGB0aGlzLnN1Ym1pdEV2ZW50LnByZXZlbnREZWZhdWx0KClgIGlzIGRlcHJlY2F0ZWQ7IGluc3RlYWQsIGNhbGwgYHRoaXMudmFsaWRhdGlvblJlc3VsdCA9IGZhbHNlYFwiKSwgaS52YWxpZGF0aW9uUmVzdWx0ID0gITEgfSB9KSksIHRoaXMudmFsaWRhdGlvblJlc3VsdCA9ICEwLCB0aGlzLl90cmlnZ2VyKFwidmFsaWRhdGVcIiksIHRoaXMuX3JlZnJlc2hGaWVsZHMoKTsgdmFyIG8gPSB0aGlzLl93aXRob3V0UmVhY3R1YWxpemluZ0Zvcm1PcHRpb25zKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGgubWFwKGkuZmllbGRzLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC53aGVuVmFsaWRhdGUoeyBmb3JjZTogcywgZ3JvdXA6IG4gfSkgfSkgfSk7IHJldHVybiAoZSA9IGQuYWxsKG8pLmRvbmUoZnVuY3Rpb24gKCkgeyBpLl90cmlnZ2VyKFwic3VjY2Vzc1wiKSB9KS5mYWlsKGZ1bmN0aW9uICgpIHsgaS52YWxpZGF0aW9uUmVzdWx0ID0gITEsIGkuZm9jdXMoKSwgaS5fdHJpZ2dlcihcImVycm9yXCIpIH0pLmFsd2F5cyhmdW5jdGlvbiAoKSB7IGkuX3RyaWdnZXIoXCJ2YWxpZGF0ZWRcIikgfSkpLnBpcGUuYXBwbHkoZSwgdSh0aGlzLl9waXBlQWNjb3JkaW5nVG9WYWxpZGF0aW9uUmVzdWx0KCkpKSB9LCBpc1ZhbGlkOiBmdW5jdGlvbiAodCkgeyBpZiAoMSA8PSBhcmd1bWVudHMubGVuZ3RoICYmICFoLmlzUGxhaW5PYmplY3QodCkpIHsgZC53YXJuT25jZShcIkNhbGxpbmcgaXNWYWxpZCBvbiBhIHBhcnNsZXkgZm9ybSB3aXRob3V0IHBhc3NpbmcgYXJndW1lbnRzIGFzIGFuIG9iamVjdCBpcyBkZXByZWNhdGVkLlwiKTsgdmFyIGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpOyB0ID0geyBncm91cDogZVswXSwgZm9yY2U6IGVbMV0gfSB9IHJldHVybiBfW3RoaXMud2hlblZhbGlkKHQpLnN0YXRlKCldIH0sIHdoZW5WYWxpZDogZnVuY3Rpb24gKHQpIHsgdmFyIGUgPSB0aGlzLCBpID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSB0ID8gdCA6IHt9LCByID0gaS5ncm91cCwgbiA9IGkuZm9yY2U7IHRoaXMuX3JlZnJlc2hGaWVsZHMoKTsgdmFyIHMgPSB0aGlzLl93aXRob3V0UmVhY3R1YWxpemluZ0Zvcm1PcHRpb25zKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGgubWFwKGUuZmllbGRzLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC53aGVuVmFsaWQoeyBncm91cDogciwgZm9yY2U6IG4gfSkgfSkgfSk7IHJldHVybiBkLmFsbChzKSB9LCByZWZyZXNoOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZWZyZXNoRmllbGRzKCksIHRoaXMgfSwgcmVzZXQ6IGZ1bmN0aW9uICgpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLmZpZWxkcy5sZW5ndGg7IHQrKyl0aGlzLmZpZWxkc1t0XS5yZXNldCgpOyB0aGlzLl90cmlnZ2VyKFwicmVzZXRcIikgfSwgZGVzdHJveTogZnVuY3Rpb24gKCkgeyB0aGlzLl9kZXN0cm95VUkoKTsgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLmZpZWxkcy5sZW5ndGg7IHQrKyl0aGlzLmZpZWxkc1t0XS5kZXN0cm95KCk7IHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YShcIlBhcnNsZXlcIiksIHRoaXMuX3RyaWdnZXIoXCJkZXN0cm95XCIpIH0sIF9yZWZyZXNoRmllbGRzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmFjdHVhbGl6ZU9wdGlvbnMoKS5fYmluZEZpZWxkcygpIH0sIF9iaW5kRmllbGRzOiBmdW5jdGlvbiAoKSB7IHZhciBuID0gdGhpcywgdCA9IHRoaXMuZmllbGRzOyByZXR1cm4gdGhpcy5maWVsZHMgPSBbXSwgdGhpcy5maWVsZHNNYXBwZWRCeUlkID0ge30sIHRoaXMuX3dpdGhvdXRSZWFjdHVhbGl6aW5nRm9ybU9wdGlvbnMoZnVuY3Rpb24gKCkgeyBuLiRlbGVtZW50LmZpbmQobi5vcHRpb25zLmlucHV0cykubm90KG4ub3B0aW9ucy5leGNsdWRlZCkubm90KFwiW1wiLmNvbmNhdChuLm9wdGlvbnMubmFtZXNwYWNlLCBcImV4Y2x1ZGVkPXRydWVdXCIpKS5lYWNoKGZ1bmN0aW9uICh0LCBlKSB7IHZhciBpID0gbmV3IHdpbmRvdy5QYXJzbGV5LkZhY3RvcnkoZSwge30sIG4pOyBpZiAoXCJGaWVsZFwiID09PSBpLl9fY2xhc3NfXyB8fCBcIkZpZWxkTXVsdGlwbGVcIiA9PT0gaS5fX2NsYXNzX18pIHsgdmFyIHIgPSBpLl9fY2xhc3NfXyArIFwiLVwiICsgaS5fX2lkX187IHZvaWQgMCA9PT0gbi5maWVsZHNNYXBwZWRCeUlkW3JdICYmIChuLmZpZWxkc01hcHBlZEJ5SWRbcl0gPSBpLCBuLmZpZWxkcy5wdXNoKGkpKSB9IH0pLCBoLmVhY2goZC5kaWZmZXJlbmNlKHQsIG4uZmllbGRzKSwgZnVuY3Rpb24gKHQsIGUpIHsgZS5yZXNldCgpIH0pIH0pLCB0aGlzIH0sIF93aXRob3V0UmVhY3R1YWxpemluZ0Zvcm1PcHRpb25zOiBmdW5jdGlvbiAodCkgeyB2YXIgZSA9IHRoaXMuYWN0dWFsaXplT3B0aW9uczsgdGhpcy5hY3R1YWxpemVPcHRpb25zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyB9OyB2YXIgaSA9IHQoKTsgcmV0dXJuIHRoaXMuYWN0dWFsaXplT3B0aW9ucyA9IGUsIGkgfSwgX3RyaWdnZXI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0aGlzLnRyaWdnZXIoXCJmb3JtOlwiICsgdCkgfSB9OyBmdW5jdGlvbiBiKHQsIGUsIGksIHIsIG4pIHsgdmFyIHMgPSB3aW5kb3cuUGFyc2xleS5fdmFsaWRhdG9yUmVnaXN0cnkudmFsaWRhdG9yc1tlXSwgYSA9IG5ldyBjKHMpOyBsKHRoaXMsIHsgdmFsaWRhdG9yOiBhLCBuYW1lOiBlLCByZXF1aXJlbWVudHM6IGksIHByaW9yaXR5OiByID0gciB8fCB0Lm9wdGlvbnNbZSArIFwiUHJpb3JpdHlcIl0gfHwgYS5wcmlvcml0eSwgaXNEb21Db25zdHJhaW50OiBuID0gITAgPT09IG4gfSksIHRoaXMuX3BhcnNlUmVxdWlyZW1lbnRzKHQub3B0aW9ucykgfSBmdW5jdGlvbiB3KHQsIGUsIGksIHIpIHsgdGhpcy5fX2NsYXNzX18gPSBcIkZpZWxkXCIsIHRoaXMuZWxlbWVudCA9IHQsIHRoaXMuJGVsZW1lbnQgPSBoKHQpLCB2b2lkIDAgIT09IHIgJiYgKHRoaXMucGFyZW50ID0gciksIHRoaXMub3B0aW9ucyA9IGksIHRoaXMuZG9tT3B0aW9ucyA9IGUsIHRoaXMuY29uc3RyYWludHMgPSBbXSwgdGhpcy5jb25zdHJhaW50c0J5TmFtZSA9IHt9LCB0aGlzLnZhbGlkYXRpb25SZXN1bHQgPSAhMCwgdGhpcy5fYmluZENvbnN0cmFpbnRzKCkgfSB2YXIgRiA9IHsgcGVuZGluZzogbnVsbCwgcmVzb2x2ZWQ6ICEwLCByZWplY3RlZDogIShiLnByb3RvdHlwZSA9IHsgdmFsaWRhdGU6IGZ1bmN0aW9uICh0LCBlKSB7IHZhciBpOyByZXR1cm4gKGkgPSB0aGlzLnZhbGlkYXRvcikudmFsaWRhdGUuYXBwbHkoaSwgW3RdLmNvbmNhdCh1KHRoaXMucmVxdWlyZW1lbnRMaXN0KSwgW2VdKSkgfSwgX3BhcnNlUmVxdWlyZW1lbnRzOiBmdW5jdGlvbiAoaSkgeyB2YXIgciA9IHRoaXM7IHRoaXMucmVxdWlyZW1lbnRMaXN0ID0gdGhpcy52YWxpZGF0b3IucGFyc2VSZXF1aXJlbWVudHModGhpcy5yZXF1aXJlbWVudHMsIGZ1bmN0aW9uICh0KSB7IHJldHVybiBpW3IubmFtZSArICgoZSA9IHQpWzBdLnRvVXBwZXJDYXNlKCkgKyBlLnNsaWNlKDEpKV07IHZhciBlIH0pIH0gfSkgfTsgdy5wcm90b3R5cGUgPSB7IHZhbGlkYXRlOiBmdW5jdGlvbiAodCkgeyAxIDw9IGFyZ3VtZW50cy5sZW5ndGggJiYgIWguaXNQbGFpbk9iamVjdCh0KSAmJiAoZC53YXJuT25jZShcIkNhbGxpbmcgdmFsaWRhdGUgb24gYSBwYXJzbGV5IGZpZWxkIHdpdGhvdXQgcGFzc2luZyBhcmd1bWVudHMgYXMgYW4gb2JqZWN0IGlzIGRlcHJlY2F0ZWQuXCIpLCB0ID0geyBvcHRpb25zOiB0IH0pOyB2YXIgZSA9IHRoaXMud2hlblZhbGlkYXRlKHQpOyBpZiAoIWUpIHJldHVybiAhMDsgc3dpdGNoIChlLnN0YXRlKCkpIHsgY2FzZSBcInBlbmRpbmdcIjogcmV0dXJuIG51bGw7IGNhc2UgXCJyZXNvbHZlZFwiOiByZXR1cm4gITA7IGNhc2UgXCJyZWplY3RlZFwiOiByZXR1cm4gdGhpcy52YWxpZGF0aW9uUmVzdWx0IH0gfSwgd2hlblZhbGlkYXRlOiBmdW5jdGlvbiAodCkgeyB2YXIgZSwgaSA9IHRoaXMsIHIgPSAwIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IHQgPyB0IDoge30sIG4gPSByLmZvcmNlLCBzID0gci5ncm91cDsgaWYgKHRoaXMucmVmcmVzaCgpLCAhcyB8fCB0aGlzLl9pc0luR3JvdXAocykpIHJldHVybiB0aGlzLnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpLCB0aGlzLl90cmlnZ2VyKFwidmFsaWRhdGVcIiksIChlID0gdGhpcy53aGVuVmFsaWQoeyBmb3JjZTogbiwgdmFsdWU6IHRoaXMudmFsdWUsIF9yZWZyZXNoZWQ6ICEwIH0pLmFsd2F5cyhmdW5jdGlvbiAoKSB7IGkuX3JlZmxvd1VJKCkgfSkuZG9uZShmdW5jdGlvbiAoKSB7IGkuX3RyaWdnZXIoXCJzdWNjZXNzXCIpIH0pLmZhaWwoZnVuY3Rpb24gKCkgeyBpLl90cmlnZ2VyKFwiZXJyb3JcIikgfSkuYWx3YXlzKGZ1bmN0aW9uICgpIHsgaS5fdHJpZ2dlcihcInZhbGlkYXRlZFwiKSB9KSkucGlwZS5hcHBseShlLCB1KHRoaXMuX3BpcGVBY2NvcmRpbmdUb1ZhbGlkYXRpb25SZXN1bHQoKSkpIH0sIGhhc0NvbnN0cmFpbnRzOiBmdW5jdGlvbiAoKSB7IHJldHVybiAwICE9PSB0aGlzLmNvbnN0cmFpbnRzLmxlbmd0aCB9LCBuZWVkc1ZhbGlkYXRpb246IGZ1bmN0aW9uICh0KSB7IHJldHVybiB2b2lkIDAgPT09IHQgJiYgKHQgPSB0aGlzLmdldFZhbHVlKCkpLCAhKCF0Lmxlbmd0aCAmJiAhdGhpcy5faXNSZXF1aXJlZCgpICYmIHZvaWQgMCA9PT0gdGhpcy5vcHRpb25zLnZhbGlkYXRlSWZFbXB0eSkgfSwgX2lzSW5Hcm91cDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmdyb3VwKSA/IC0xICE9PSBoLmluQXJyYXkodCwgdGhpcy5vcHRpb25zLmdyb3VwKSA6IHRoaXMub3B0aW9ucy5ncm91cCA9PT0gdCB9LCBpc1ZhbGlkOiBmdW5jdGlvbiAodCkgeyBpZiAoMSA8PSBhcmd1bWVudHMubGVuZ3RoICYmICFoLmlzUGxhaW5PYmplY3QodCkpIHsgZC53YXJuT25jZShcIkNhbGxpbmcgaXNWYWxpZCBvbiBhIHBhcnNsZXkgZmllbGQgd2l0aG91dCBwYXNzaW5nIGFyZ3VtZW50cyBhcyBhbiBvYmplY3QgaXMgZGVwcmVjYXRlZC5cIik7IHZhciBlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgdCA9IHsgZm9yY2U6IGVbMF0sIHZhbHVlOiBlWzFdIH0gfSB2YXIgaSA9IHRoaXMud2hlblZhbGlkKHQpOyByZXR1cm4gIWkgfHwgRltpLnN0YXRlKCldIH0sIHdoZW5WYWxpZDogZnVuY3Rpb24gKHQpIHsgdmFyIHIgPSB0aGlzLCBlID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSB0ID8gdCA6IHt9LCBpID0gZS5mb3JjZSwgbiA9IHZvaWQgMCAhPT0gaSAmJiBpLCBzID0gZS52YWx1ZSwgYSA9IGUuZ3JvdXA7IGlmIChlLl9yZWZyZXNoZWQgfHwgdGhpcy5yZWZyZXNoKCksICFhIHx8IHRoaXMuX2lzSW5Hcm91cChhKSkgeyBpZiAodGhpcy52YWxpZGF0aW9uUmVzdWx0ID0gITAsICF0aGlzLmhhc0NvbnN0cmFpbnRzKCkpIHJldHVybiBoLndoZW4oKTsgaWYgKG51bGwgPT0gcyAmJiAocyA9IHRoaXMuZ2V0VmFsdWUoKSksICF0aGlzLm5lZWRzVmFsaWRhdGlvbihzKSAmJiAhMCAhPT0gbikgcmV0dXJuIGgud2hlbigpOyB2YXIgbyA9IHRoaXMuX2dldEdyb3VwZWRDb25zdHJhaW50cygpLCBsID0gW107IHJldHVybiBoLmVhY2gobywgZnVuY3Rpb24gKHQsIGUpIHsgdmFyIGkgPSBkLmFsbChoLm1hcChlLCBmdW5jdGlvbiAodCkgeyByZXR1cm4gci5fdmFsaWRhdGVDb25zdHJhaW50KHMsIHQpIH0pKTsgaWYgKGwucHVzaChpKSwgXCJyZWplY3RlZFwiID09PSBpLnN0YXRlKCkpIHJldHVybiAhMSB9KSwgZC5hbGwobCkgfSB9LCBfdmFsaWRhdGVDb25zdHJhaW50OiBmdW5jdGlvbiAodCwgZSkgeyB2YXIgaSA9IHRoaXMsIHIgPSBlLnZhbGlkYXRlKHQsIHRoaXMpOyByZXR1cm4gITEgPT09IHIgJiYgKHIgPSBoLkRlZmVycmVkKCkucmVqZWN0KCkpLCBkLmFsbChbcl0pLmZhaWwoZnVuY3Rpb24gKHQpIHsgaS52YWxpZGF0aW9uUmVzdWx0IGluc3RhbmNlb2YgQXJyYXkgfHwgKGkudmFsaWRhdGlvblJlc3VsdCA9IFtdKSwgaS52YWxpZGF0aW9uUmVzdWx0LnB1c2goeyBhc3NlcnQ6IGUsIGVycm9yTWVzc2FnZTogXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiB0IH0pIH0pIH0sIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7IHZhciB0OyByZXR1cm4gbnVsbCA9PSAodCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdGhpcy5vcHRpb25zLnZhbHVlID8gdGhpcy5vcHRpb25zLnZhbHVlKHRoaXMpIDogdm9pZCAwICE9PSB0aGlzLm9wdGlvbnMudmFsdWUgPyB0aGlzLm9wdGlvbnMudmFsdWUgOiB0aGlzLiRlbGVtZW50LnZhbCgpKSA/IFwiXCIgOiB0aGlzLl9oYW5kbGVXaGl0ZXNwYWNlKHQpIH0sIHJlc2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXNldFVJKCksIHRoaXMuX3RyaWdnZXIoXCJyZXNldFwiKSB9LCBkZXN0cm95OiBmdW5jdGlvbiAoKSB7IHRoaXMuX2Rlc3Ryb3lVSSgpLCB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoXCJQYXJzbGV5XCIpLCB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoXCJGaWVsZE11bHRpcGxlXCIpLCB0aGlzLl90cmlnZ2VyKFwiZGVzdHJveVwiKSB9LCByZWZyZXNoOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZWZyZXNoQ29uc3RyYWludHMoKSwgdGhpcyB9LCBfcmVmcmVzaENvbnN0cmFpbnRzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmFjdHVhbGl6ZU9wdGlvbnMoKS5fYmluZENvbnN0cmFpbnRzKCkgfSwgcmVmcmVzaENvbnN0cmFpbnRzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkLndhcm5PbmNlKFwiUGFyc2xleSdzIHJlZnJlc2hDb25zdHJhaW50cyBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHJlZnJlc2hcIiksIHRoaXMucmVmcmVzaCgpIH0sIGFkZENvbnN0cmFpbnQ6IGZ1bmN0aW9uICh0LCBlLCBpLCByKSB7IGlmICh3aW5kb3cuUGFyc2xleS5fdmFsaWRhdG9yUmVnaXN0cnkudmFsaWRhdG9yc1t0XSkgeyB2YXIgbiA9IG5ldyBiKHRoaXMsIHQsIGUsIGksIHIpOyBcInVuZGVmaW5lZFwiICE9PSB0aGlzLmNvbnN0cmFpbnRzQnlOYW1lW24ubmFtZV0gJiYgdGhpcy5yZW1vdmVDb25zdHJhaW50KG4ubmFtZSksIHRoaXMuY29uc3RyYWludHMucHVzaChuKSwgdGhpcy5jb25zdHJhaW50c0J5TmFtZVtuLm5hbWVdID0gbiB9IHJldHVybiB0aGlzIH0sIHJlbW92ZUNvbnN0cmFpbnQ6IGZ1bmN0aW9uICh0KSB7IGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGUrKylpZiAodCA9PT0gdGhpcy5jb25zdHJhaW50c1tlXS5uYW1lKSB7IHRoaXMuY29uc3RyYWludHMuc3BsaWNlKGUsIDEpOyBicmVhayB9IHJldHVybiBkZWxldGUgdGhpcy5jb25zdHJhaW50c0J5TmFtZVt0XSwgdGhpcyB9LCB1cGRhdGVDb25zdHJhaW50OiBmdW5jdGlvbiAodCwgZSwgaSkgeyByZXR1cm4gdGhpcy5yZW1vdmVDb25zdHJhaW50KHQpLmFkZENvbnN0cmFpbnQodCwgZSwgaSkgfSwgX2JpbmRDb25zdHJhaW50czogZnVuY3Rpb24gKCkgeyBmb3IgKHZhciB0ID0gW10sIGUgPSB7fSwgaSA9IDA7IGkgPCB0aGlzLmNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSExID09PSB0aGlzLmNvbnN0cmFpbnRzW2ldLmlzRG9tQ29uc3RyYWludCAmJiAodC5wdXNoKHRoaXMuY29uc3RyYWludHNbaV0pLCBlW3RoaXMuY29uc3RyYWludHNbaV0ubmFtZV0gPSB0aGlzLmNvbnN0cmFpbnRzW2ldKTsgZm9yICh2YXIgciBpbiB0aGlzLmNvbnN0cmFpbnRzID0gdCwgdGhpcy5jb25zdHJhaW50c0J5TmFtZSA9IGUsIHRoaXMub3B0aW9ucykgdGhpcy5hZGRDb25zdHJhaW50KHIsIHRoaXMub3B0aW9uc1tyXSwgdm9pZCAwLCAhMCk7IHJldHVybiB0aGlzLl9iaW5kSHRtbDVDb25zdHJhaW50cygpIH0sIF9iaW5kSHRtbDVDb25zdHJhaW50czogZnVuY3Rpb24gKCkgeyBudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIikgJiYgdGhpcy5hZGRDb25zdHJhaW50KFwicmVxdWlyZWRcIiwgITAsIHZvaWQgMCwgITApLCBudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGF0dGVyblwiKSAmJiB0aGlzLmFkZENvbnN0cmFpbnQoXCJwYXR0ZXJuXCIsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwYXR0ZXJuXCIpLCB2b2lkIDAsICEwKTsgdmFyIHQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibWluXCIpLCBlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm1heFwiKTsgbnVsbCAhPT0gdCAmJiBudWxsICE9PSBlID8gdGhpcy5hZGRDb25zdHJhaW50KFwicmFuZ2VcIiwgW3QsIGVdLCB2b2lkIDAsICEwKSA6IG51bGwgIT09IHQgPyB0aGlzLmFkZENvbnN0cmFpbnQoXCJtaW5cIiwgdCwgdm9pZCAwLCAhMCkgOiBudWxsICE9PSBlICYmIHRoaXMuYWRkQ29uc3RyYWludChcIm1heFwiLCBlLCB2b2lkIDAsICEwKSwgbnVsbCAhPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm1pbmxlbmd0aFwiKSAmJiBudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibWF4bGVuZ3RoXCIpID8gdGhpcy5hZGRDb25zdHJhaW50KFwibGVuZ3RoXCIsIFt0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibWlubGVuZ3RoXCIpLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibWF4bGVuZ3RoXCIpXSwgdm9pZCAwLCAhMCkgOiBudWxsICE9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibWlubGVuZ3RoXCIpID8gdGhpcy5hZGRDb25zdHJhaW50KFwibWlubGVuZ3RoXCIsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtaW5sZW5ndGhcIiksIHZvaWQgMCwgITApIDogbnVsbCAhPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm1heGxlbmd0aFwiKSAmJiB0aGlzLmFkZENvbnN0cmFpbnQoXCJtYXhsZW5ndGhcIiwgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm1heGxlbmd0aFwiKSwgdm9pZCAwLCAhMCk7IHZhciBpID0gZC5nZXRUeXBlKHRoaXMuZWxlbWVudCk7IHJldHVybiBcIm51bWJlclwiID09PSBpID8gdGhpcy5hZGRDb25zdHJhaW50KFwidHlwZVwiLCBbXCJudW1iZXJcIiwgeyBzdGVwOiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3RlcFwiKSB8fCBcIjFcIiwgYmFzZTogdCB8fCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfV0sIHZvaWQgMCwgITApIDogL14oZW1haWx8dXJsfHJhbmdlfGRhdGUpJC9pLnRlc3QoaSkgPyB0aGlzLmFkZENvbnN0cmFpbnQoXCJ0eXBlXCIsIGksIHZvaWQgMCwgITApIDogdGhpcyB9LCBfaXNSZXF1aXJlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdm9pZCAwICE9PSB0aGlzLmNvbnN0cmFpbnRzQnlOYW1lLnJlcXVpcmVkICYmICExICE9PSB0aGlzLmNvbnN0cmFpbnRzQnlOYW1lLnJlcXVpcmVkLnJlcXVpcmVtZW50cyB9LCBfdHJpZ2dlcjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHRoaXMudHJpZ2dlcihcImZpZWxkOlwiICsgdCkgfSwgX2hhbmRsZVdoaXRlc3BhY2U6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAhMCA9PT0gdGhpcy5vcHRpb25zLnRyaW1WYWx1ZSAmJiBkLndhcm5PbmNlKCdkYXRhLXBhcnNsZXktdHJpbS12YWx1ZT1cInRydWVcIiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGRhdGEtcGFyc2xleS13aGl0ZXNwYWNlPVwidHJpbVwiJyksIFwic3F1aXNoXCIgPT09IHRoaXMub3B0aW9ucy53aGl0ZXNwYWNlICYmICh0ID0gdC5yZXBsYWNlKC9cXHN7Mix9L2csIFwiIFwiKSksIFwidHJpbVwiICE9PSB0aGlzLm9wdGlvbnMud2hpdGVzcGFjZSAmJiBcInNxdWlzaFwiICE9PSB0aGlzLm9wdGlvbnMud2hpdGVzcGFjZSAmJiAhMCAhPT0gdGhpcy5vcHRpb25zLnRyaW1WYWx1ZSB8fCAodCA9IGQudHJpbVN0cmluZyh0KSksIHQgfSwgX2lzRGF0ZUlucHV0OiBmdW5jdGlvbiAoKSB7IHZhciB0ID0gdGhpcy5jb25zdHJhaW50c0J5TmFtZS50eXBlOyByZXR1cm4gdCAmJiBcImRhdGVcIiA9PT0gdC5yZXF1aXJlbWVudHMgfSwgX2dldEdyb3VwZWRDb25zdHJhaW50czogZnVuY3Rpb24gKCkgeyBpZiAoITEgPT09IHRoaXMub3B0aW9ucy5wcmlvcml0eUVuYWJsZWQpIHJldHVybiBbdGhpcy5jb25zdHJhaW50c107IGZvciAodmFyIHQgPSBbXSwgZSA9IHt9LCBpID0gMDsgaSA8IHRoaXMuY29uc3RyYWludHMubGVuZ3RoOyBpKyspIHsgdmFyIHIgPSB0aGlzLmNvbnN0cmFpbnRzW2ldLnByaW9yaXR5OyBlW3JdIHx8IHQucHVzaChlW3JdID0gW10pLCBlW3JdLnB1c2godGhpcy5jb25zdHJhaW50c1tpXSkgfSByZXR1cm4gdC5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiBlWzBdLnByaW9yaXR5IC0gdFswXS5wcmlvcml0eSB9KSwgdCB9IH07IGZ1bmN0aW9uIEMoKSB7IHRoaXMuX19jbGFzc19fID0gXCJGaWVsZE11bHRpcGxlXCIgfSBDLnByb3RvdHlwZSA9IHsgYWRkRWxlbWVudDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHRoaXMuJGVsZW1lbnRzLnB1c2godCksIHRoaXMgfSwgX3JlZnJlc2hDb25zdHJhaW50czogZnVuY3Rpb24gKCkgeyB2YXIgdDsgaWYgKHRoaXMuY29uc3RyYWludHMgPSBbXSwgXCJTRUxFQ1RcIiA9PT0gdGhpcy5lbGVtZW50Lm5vZGVOYW1lKSByZXR1cm4gdGhpcy5hY3R1YWxpemVPcHRpb25zKCkuX2JpbmRDb25zdHJhaW50cygpLCB0aGlzOyBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuJGVsZW1lbnRzLmxlbmd0aDsgZSsrKWlmIChoKFwiaHRtbFwiKS5oYXModGhpcy4kZWxlbWVudHNbZV0pLmxlbmd0aCkgeyB0ID0gdGhpcy4kZWxlbWVudHNbZV0uZGF0YShcIkZpZWxkTXVsdGlwbGVcIikuX3JlZnJlc2hDb25zdHJhaW50cygpLmNvbnN0cmFpbnRzOyBmb3IgKHZhciBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspdGhpcy5hZGRDb25zdHJhaW50KHRbaV0ubmFtZSwgdFtpXS5yZXF1aXJlbWVudHMsIHRbaV0ucHJpb3JpdHksIHRbaV0uaXNEb21Db25zdHJhaW50KSB9IGVsc2UgdGhpcy4kZWxlbWVudHMuc3BsaWNlKGUsIDEpOyByZXR1cm4gdGhpcyB9LCBnZXRWYWx1ZTogZnVuY3Rpb24gKCkgeyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB0aGlzLm9wdGlvbnMudmFsdWUpIHJldHVybiB0aGlzLm9wdGlvbnMudmFsdWUodGhpcyk7IGlmICh2b2lkIDAgIT09IHRoaXMub3B0aW9ucy52YWx1ZSkgcmV0dXJuIHRoaXMub3B0aW9ucy52YWx1ZTsgaWYgKFwiSU5QVVRcIiA9PT0gdGhpcy5lbGVtZW50Lm5vZGVOYW1lKSB7IHZhciB0ID0gZC5nZXRUeXBlKHRoaXMuZWxlbWVudCk7IGlmIChcInJhZGlvXCIgPT09IHQpIHJldHVybiB0aGlzLl9maW5kUmVsYXRlZCgpLmZpbHRlcihcIjpjaGVja2VkXCIpLnZhbCgpIHx8IFwiXCI7IGlmIChcImNoZWNrYm94XCIgPT09IHQpIHsgdmFyIGUgPSBbXTsgcmV0dXJuIHRoaXMuX2ZpbmRSZWxhdGVkKCkuZmlsdGVyKFwiOmNoZWNrZWRcIikuZWFjaChmdW5jdGlvbiAoKSB7IGUucHVzaChoKHRoaXMpLnZhbCgpKSB9KSwgZSB9IH0gcmV0dXJuIFwiU0VMRUNUXCIgPT09IHRoaXMuZWxlbWVudC5ub2RlTmFtZSAmJiBudWxsID09PSB0aGlzLiRlbGVtZW50LnZhbCgpID8gW10gOiB0aGlzLiRlbGVtZW50LnZhbCgpIH0sIF9pbml0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiRlbGVtZW50cyA9IFt0aGlzLiRlbGVtZW50XSwgdGhpcyB9IH07IGZ1bmN0aW9uIEEodCwgZSwgaSkgeyB0aGlzLmVsZW1lbnQgPSB0LCB0aGlzLiRlbGVtZW50ID0gaCh0KTsgdmFyIHIgPSB0aGlzLiRlbGVtZW50LmRhdGEoXCJQYXJzbGV5XCIpOyBpZiAocikgcmV0dXJuIHZvaWQgMCAhPT0gaSAmJiByLnBhcmVudCA9PT0gd2luZG93LlBhcnNsZXkgJiYgKHIucGFyZW50ID0gaSwgci5fcmVzZXRPcHRpb25zKHIub3B0aW9ucykpLCBcIm9iamVjdFwiID09PSBuKGUpICYmIGwoci5vcHRpb25zLCBlKSwgcjsgaWYgKCF0aGlzLiRlbGVtZW50Lmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgYmluZCBQYXJzbGV5IG9uIGFuIGV4aXN0aW5nIGVsZW1lbnQuXCIpOyBpZiAodm9pZCAwICE9PSBpICYmIFwiRm9ybVwiICE9PSBpLl9fY2xhc3NfXykgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGluc3RhbmNlIG11c3QgYmUgYSBGb3JtIGluc3RhbmNlXCIpOyByZXR1cm4gdGhpcy5wYXJlbnQgPSBpIHx8IHdpbmRvdy5QYXJzbGV5LCB0aGlzLmluaXQoZSkgfSBBLnByb3RvdHlwZSA9IHsgaW5pdDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHRoaXMuX19jbGFzc19fID0gXCJQYXJzbGV5XCIsIHRoaXMuX192ZXJzaW9uX18gPSBcIjIuOS4yXCIsIHRoaXMuX19pZF9fID0gZC5nZW5lcmF0ZUlEKCksIHRoaXMuX3Jlc2V0T3B0aW9ucyh0KSwgXCJGT1JNXCIgPT09IHRoaXMuZWxlbWVudC5ub2RlTmFtZSB8fCBkLmNoZWNrQXR0cih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5uYW1lc3BhY2UsIFwidmFsaWRhdGVcIikgJiYgIXRoaXMuJGVsZW1lbnQuaXModGhpcy5vcHRpb25zLmlucHV0cykgPyB0aGlzLmJpbmQoXCJwYXJzbGV5Rm9ybVwiKSA6IHRoaXMuaXNNdWx0aXBsZSgpID8gdGhpcy5oYW5kbGVNdWx0aXBsZSgpIDogdGhpcy5iaW5kKFwicGFyc2xleUZpZWxkXCIpIH0sIGlzTXVsdGlwbGU6IGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBkLmdldFR5cGUodGhpcy5lbGVtZW50KTsgcmV0dXJuIFwicmFkaW9cIiA9PT0gdCB8fCBcImNoZWNrYm94XCIgPT09IHQgfHwgXCJTRUxFQ1RcIiA9PT0gdGhpcy5lbGVtZW50Lm5vZGVOYW1lICYmIG51bGwgIT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSB9LCBoYW5kbGVNdWx0aXBsZTogZnVuY3Rpb24gKCkgeyB2YXIgdCwgZSwgciA9IHRoaXM7IGlmICh0aGlzLm9wdGlvbnMubXVsdGlwbGUgPSB0aGlzLm9wdGlvbnMubXVsdGlwbGUgfHwgKHQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSkgfHwgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpLCBcIlNFTEVDVFwiID09PSB0aGlzLmVsZW1lbnQubm9kZU5hbWUgJiYgbnVsbCAhPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpKSByZXR1cm4gdGhpcy5vcHRpb25zLm11bHRpcGxlID0gdGhpcy5vcHRpb25zLm11bHRpcGxlIHx8IHRoaXMuX19pZF9fLCB0aGlzLmJpbmQoXCJwYXJzbGV5RmllbGRNdWx0aXBsZVwiKTsgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlwbGUpIHJldHVybiBkLndhcm4oXCJUbyBiZSBib3VuZCBieSBQYXJzbGV5LCBhIHJhZGlvLCBhIGNoZWNrYm94IGFuZCBhIG11bHRpcGxlIHNlbGVjdCBpbnB1dCBtdXN0IGhhdmUgZWl0aGVyIGEgbmFtZSBvciBhIG11bHRpcGxlIG9wdGlvbi5cIiwgdGhpcy4kZWxlbWVudCksIHRoaXM7IHRoaXMub3B0aW9ucy5tdWx0aXBsZSA9IHRoaXMub3B0aW9ucy5tdWx0aXBsZS5yZXBsYWNlKC8oOnxcXC58XFxbfFxcXXxcXHt8XFx9fFxcJCkvZywgXCJcIiksIHQgJiYgaCgnaW5wdXRbbmFtZT1cIicgKyB0ICsgJ1wiXScpLmVhY2goZnVuY3Rpb24gKHQsIGUpIHsgdmFyIGkgPSBkLmdldFR5cGUoZSk7IFwicmFkaW9cIiAhPT0gaSAmJiBcImNoZWNrYm94XCIgIT09IGkgfHwgZS5zZXRBdHRyaWJ1dGUoci5vcHRpb25zLm5hbWVzcGFjZSArIFwibXVsdGlwbGVcIiwgci5vcHRpb25zLm11bHRpcGxlKSB9KTsgZm9yICh2YXIgaSA9IHRoaXMuX2ZpbmRSZWxhdGVkKCksIG4gPSAwOyBuIDwgaS5sZW5ndGg7IG4rKylpZiAodm9pZCAwICE9PSAoZSA9IGgoaS5nZXQobikpLmRhdGEoXCJQYXJzbGV5XCIpKSkgeyB0aGlzLiRlbGVtZW50LmRhdGEoXCJGaWVsZE11bHRpcGxlXCIpIHx8IGUuYWRkRWxlbWVudCh0aGlzLiRlbGVtZW50KTsgYnJlYWsgfSByZXR1cm4gdGhpcy5iaW5kKFwicGFyc2xleUZpZWxkXCIsICEwKSwgZSB8fCB0aGlzLmJpbmQoXCJwYXJzbGV5RmllbGRNdWx0aXBsZVwiKSB9LCBiaW5kOiBmdW5jdGlvbiAodCwgZSkgeyB2YXIgaTsgc3dpdGNoICh0KSB7IGNhc2UgXCJwYXJzbGV5Rm9ybVwiOiBpID0gaC5leHRlbmQobmV3IHkodGhpcy5lbGVtZW50LCB0aGlzLmRvbU9wdGlvbnMsIHRoaXMub3B0aW9ucyksIG5ldyByLCB3aW5kb3cuUGFyc2xleUV4dGVuZCkuX2JpbmRGaWVsZHMoKTsgYnJlYWs7IGNhc2UgXCJwYXJzbGV5RmllbGRcIjogaSA9IGguZXh0ZW5kKG5ldyB3KHRoaXMuZWxlbWVudCwgdGhpcy5kb21PcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMucGFyZW50KSwgbmV3IHIsIHdpbmRvdy5QYXJzbGV5RXh0ZW5kKTsgYnJlYWs7IGNhc2UgXCJwYXJzbGV5RmllbGRNdWx0aXBsZVwiOiBpID0gaC5leHRlbmQobmV3IHcodGhpcy5lbGVtZW50LCB0aGlzLmRvbU9wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5wYXJlbnQpLCBuZXcgQywgbmV3IHIsIHdpbmRvdy5QYXJzbGV5RXh0ZW5kKS5faW5pdCgpOyBicmVhazsgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKHQgKyBcImlzIG5vdCBhIHN1cHBvcnRlZCBQYXJzbGV5IHR5cGVcIikgfXJldHVybiB0aGlzLm9wdGlvbnMubXVsdGlwbGUgJiYgZC5zZXRBdHRyKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLm5hbWVzcGFjZSwgXCJtdWx0aXBsZVwiLCB0aGlzLm9wdGlvbnMubXVsdGlwbGUpLCB2b2lkIDAgIT09IGUgPyB0aGlzLiRlbGVtZW50LmRhdGEoXCJGaWVsZE11bHRpcGxlXCIsIGkpIDogKHRoaXMuJGVsZW1lbnQuZGF0YShcIlBhcnNsZXlcIiwgaSksIGkuX2FjdHVhbGl6ZVRyaWdnZXJzKCksIGkuX3RyaWdnZXIoXCJpbml0XCIpKSwgaSB9IH07IHZhciBFID0gaC5mbi5qcXVlcnkuc3BsaXQoXCIuXCIpOyBpZiAocGFyc2VJbnQoRVswXSkgPD0gMSAmJiBwYXJzZUludChFWzFdKSA8IDgpIHRocm93IFwiVGhlIGxvYWRlZCB2ZXJzaW9uIG9mIGpRdWVyeSBpcyB0b28gb2xkLiBQbGVhc2UgdXBncmFkZSB0byAxLjgueCBvciBiZXR0ZXIuXCI7IEUuZm9yRWFjaCB8fCBkLndhcm4oXCJQYXJzbGV5IHJlcXVpcmVzIEVTNSB0byBydW4gcHJvcGVybHkuIFBsZWFzZSBpbmNsdWRlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVwiKTsgdmFyIHggPSBsKG5ldyByLCB7IGVsZW1lbnQ6IGRvY3VtZW50LCAkZWxlbWVudDogaChkb2N1bWVudCksIGFjdHVhbGl6ZU9wdGlvbnM6IG51bGwsIF9yZXNldE9wdGlvbnM6IG51bGwsIEZhY3Rvcnk6IEEsIHZlcnNpb246IFwiMi45LjJcIiB9KTsgbCh3LnByb3RvdHlwZSwgdi5GaWVsZCwgci5wcm90b3R5cGUpLCBsKHkucHJvdG90eXBlLCB2LkZvcm0sIHIucHJvdG90eXBlKSwgbChBLnByb3RvdHlwZSwgci5wcm90b3R5cGUpLCBoLmZuLnBhcnNsZXkgPSBoLmZuLnBzbHkgPSBmdW5jdGlvbiAodCkgeyBpZiAoMSA8IHRoaXMubGVuZ3RoKSB7IHZhciBlID0gW107IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBlLnB1c2goaCh0aGlzKS5wYXJzbGV5KHQpKSB9KSwgZSB9IGlmICgwICE9IHRoaXMubGVuZ3RoKSByZXR1cm4gbmV3IEEodGhpc1swXSwgdCkgfSwgdm9pZCAwID09PSB3aW5kb3cuUGFyc2xleUV4dGVuZCAmJiAod2luZG93LlBhcnNsZXlFeHRlbmQgPSB7fSksIHgub3B0aW9ucyA9IGwoZC5vYmplY3RDcmVhdGUocyksIHdpbmRvdy5QYXJzbGV5Q29uZmlnKSwgd2luZG93LlBhcnNsZXlDb25maWcgPSB4Lm9wdGlvbnMsIHdpbmRvdy5QYXJzbGV5ID0gd2luZG93LnBzbHkgPSB4LCB4LlV0aWxzID0gZCwgd2luZG93LlBhcnNsZXlVdGlscyA9IHt9LCBoLmVhY2goZCwgZnVuY3Rpb24gKHQsIGUpIHsgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlICYmICh3aW5kb3cuUGFyc2xleVV0aWxzW3RdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZC53YXJuT25jZShcIkFjY2Vzc2luZyBgd2luZG93LlBhcnNsZXlVdGlsc2AgaXMgZGVwcmVjYXRlZC4gVXNlIGB3aW5kb3cuUGFyc2xleS5VdGlsc2AgaW5zdGVhZC5cIiksIGRbdF0uYXBwbHkoZCwgYXJndW1lbnRzKSB9KSB9KTsgdmFyICQgPSB3aW5kb3cuUGFyc2xleS5fdmFsaWRhdG9yUmVnaXN0cnkgPSBuZXcgYSh3aW5kb3cuUGFyc2xleUNvbmZpZy52YWxpZGF0b3JzLCB3aW5kb3cuUGFyc2xleUNvbmZpZy5pMThuKTsgd2luZG93LlBhcnNsZXlWYWxpZGF0b3IgPSB7fSwgaC5lYWNoKFwic2V0TG9jYWxlIGFkZENhdGFsb2cgYWRkTWVzc2FnZSBhZGRNZXNzYWdlcyBnZXRFcnJvck1lc3NhZ2UgZm9ybWF0TWVzc2FnZSBhZGRWYWxpZGF0b3IgdXBkYXRlVmFsaWRhdG9yIHJlbW92ZVZhbGlkYXRvciBoYXNWYWxpZGF0b3JcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uICh0LCBlKSB7IHdpbmRvdy5QYXJzbGV5W2VdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJFtlXS5hcHBseSgkLCBhcmd1bWVudHMpIH0sIHdpbmRvdy5QYXJzbGV5VmFsaWRhdG9yW2VdID0gZnVuY3Rpb24gKCkgeyB2YXIgdDsgcmV0dXJuIGQud2Fybk9uY2UoXCJBY2Nlc3NpbmcgdGhlIG1ldGhvZCAnXCIuY29uY2F0KGUsIFwiJyB0aHJvdWdoIFZhbGlkYXRvciBpcyBkZXByZWNhdGVkLiBTaW1wbHkgY2FsbCAnd2luZG93LlBhcnNsZXkuXCIpLmNvbmNhdChlLCBcIiguLi4pJ1wiKSksICh0ID0gd2luZG93LlBhcnNsZXkpW2VdLmFwcGx5KHQsIGFyZ3VtZW50cykgfSB9KSwgd2luZG93LlBhcnNsZXkuVUkgPSB2LCB3aW5kb3cuUGFyc2xleVVJID0geyByZW1vdmVFcnJvcjogZnVuY3Rpb24gKHQsIGUsIGkpIHsgdmFyIHIgPSAhMCAhPT0gaTsgcmV0dXJuIGQud2Fybk9uY2UoXCJBY2Nlc3NpbmcgVUkgaXMgZGVwcmVjYXRlZC4gQ2FsbCAncmVtb3ZlRXJyb3InIG9uIHRoZSBpbnN0YW5jZSBkaXJlY3RseS4gUGxlYXNlIGNvbW1lbnQgaW4gaXNzdWUgMTA3MyBhcyB0byB5b3VyIG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZC5cIiksIHQucmVtb3ZlRXJyb3IoZSwgeyB1cGRhdGVDbGFzczogciB9KSB9LCBnZXRFcnJvcnNNZXNzYWdlczogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGQud2Fybk9uY2UoXCJBY2Nlc3NpbmcgVUkgaXMgZGVwcmVjYXRlZC4gQ2FsbCAnZ2V0RXJyb3JzTWVzc2FnZXMnIG9uIHRoZSBpbnN0YW5jZSBkaXJlY3RseS5cIiksIHQuZ2V0RXJyb3JzTWVzc2FnZXMoKSB9IH0sIGguZWFjaChcImFkZEVycm9yIHVwZGF0ZUVycm9yXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiAodCwgYSkgeyB3aW5kb3cuUGFyc2xleVVJW2FdID0gZnVuY3Rpb24gKHQsIGUsIGksIHIsIG4pIHsgdmFyIHMgPSAhMCAhPT0gbjsgcmV0dXJuIGQud2Fybk9uY2UoXCJBY2Nlc3NpbmcgVUkgaXMgZGVwcmVjYXRlZC4gQ2FsbCAnXCIuY29uY2F0KGEsIFwiJyBvbiB0aGUgaW5zdGFuY2UgZGlyZWN0bHkuIFBsZWFzZSBjb21tZW50IGluIGlzc3VlIDEwNzMgYXMgdG8geW91ciBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QuXCIpKSwgdFthXShlLCB7IG1lc3NhZ2U6IGksIGFzc2VydDogciwgdXBkYXRlQ2xhc3M6IHMgfSkgfSB9KSwgITEgIT09IHdpbmRvdy5QYXJzbGV5Q29uZmlnLmF1dG9CaW5kICYmIGgoZnVuY3Rpb24gKCkgeyBoKFwiW2RhdGEtcGFyc2xleS12YWxpZGF0ZV1cIikubGVuZ3RoICYmIGgoXCJbZGF0YS1wYXJzbGV5LXZhbGlkYXRlXVwiKS5wYXJzbGV5KCkgfSk7IGZ1bmN0aW9uIFYoKSB7IGQud2Fybk9uY2UoXCJQYXJzbGV5J3MgcHVic3ViIG1vZHVsZSBpcyBkZXByZWNhdGVkOyB1c2UgdGhlICdvbicgYW5kICdvZmYnIG1ldGhvZHMgb24gcGFyc2xleSBpbnN0YW5jZXMgb3Igd2luZG93LlBhcnNsZXlcIikgfSB2YXIgUCA9IGgoe30pOyBmdW5jdGlvbiBPKGUsIGkpIHsgcmV0dXJuIGUucGFyc2xleUFkYXB0ZWRDYWxsYmFjayB8fCAoZS5wYXJzbGV5QWRhcHRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyB2YXIgdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7IHQudW5zaGlmdCh0aGlzKSwgZS5hcHBseShpIHx8IFAsIHQpIH0pLCBlLnBhcnNsZXlBZGFwdGVkQ2FsbGJhY2sgfSB2YXIgVCA9IFwicGFyc2xleTpcIjsgZnVuY3Rpb24gTSh0KSB7IHJldHVybiAwID09PSB0Lmxhc3RJbmRleE9mKFQsIDApID8gdC5zdWJzdHIoVC5sZW5ndGgpIDogdCB9IHJldHVybiBoLmxpc3RlbiA9IGZ1bmN0aW9uICh0LCBlKSB7IHZhciBpOyBpZiAoVigpLCBcIm9iamVjdFwiID09PSBuKGFyZ3VtZW50c1sxXSkgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBhcmd1bWVudHNbMl0gJiYgKGkgPSBhcmd1bWVudHNbMV0sIGUgPSBhcmd1bWVudHNbMl0pLCBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHRocm93IG5ldyBFcnJvcihcIldyb25nIHBhcmFtZXRlcnNcIik7IHdpbmRvdy5QYXJzbGV5Lm9uKE0odCksIE8oZSwgaSkpIH0sIGgubGlzdGVuVG8gPSBmdW5jdGlvbiAodCwgZSwgaSkgeyBpZiAoVigpLCAhKHQgaW5zdGFuY2VvZiB3IHx8IHQgaW5zdGFuY2VvZiB5KSkgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBnaXZlIFBhcnNsZXkgaW5zdGFuY2VcIik7IGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgaSkgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgcGFyYW1ldGVyc1wiKTsgdC5vbihNKGUpLCBPKGkpKSB9LCBoLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHQsIGUpIHsgaWYgKFYoKSwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgdCB8fCBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHRocm93IG5ldyBFcnJvcihcIldyb25nIGFyZ3VtZW50c1wiKTsgd2luZG93LlBhcnNsZXkub2ZmKE0odCksIGUucGFyc2xleUFkYXB0ZWRDYWxsYmFjaykgfSwgaC51bnN1YnNjcmliZVRvID0gZnVuY3Rpb24gKHQsIGUpIHsgaWYgKFYoKSwgISh0IGluc3RhbmNlb2YgdyB8fCB0IGluc3RhbmNlb2YgeSkpIHRocm93IG5ldyBFcnJvcihcIk11c3QgZ2l2ZSBQYXJzbGV5IGluc3RhbmNlXCIpOyB0Lm9mZihNKGUpKSB9LCBoLnVuc3Vic2NyaWJlQWxsID0gZnVuY3Rpb24gKGUpIHsgVigpLCB3aW5kb3cuUGFyc2xleS5vZmYoTShlKSksIGgoXCJmb3JtLGlucHV0LHRleHRhcmVhLHNlbGVjdFwiKS5lYWNoKGZ1bmN0aW9uICgpIHsgdmFyIHQgPSBoKHRoaXMpLmRhdGEoXCJQYXJzbGV5XCIpOyB0ICYmIHQub2ZmKE0oZSkpIH0pIH0sIGguZW1pdCA9IGZ1bmN0aW9uICh0LCBlKSB7IFYoKTsgdmFyIGkgPSBlIGluc3RhbmNlb2YgdyB8fCBlIGluc3RhbmNlb2YgeSwgciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgaSA/IDIgOiAxKTsgci51bnNoaWZ0KE0odCkpLCBpIHx8IChlID0gd2luZG93LlBhcnNsZXkpLCBlLnRyaWdnZXIuYXBwbHkoZSwgdShyKSkgfSwgaC5leHRlbmQoITAsIHgsIHsgYXN5bmNWYWxpZGF0b3JzOiB7IGRlZmF1bHQ6IHsgZm46IGZ1bmN0aW9uICh0KSB7IHJldHVybiAyMDAgPD0gdC5zdGF0dXMgJiYgdC5zdGF0dXMgPCAzMDAgfSwgdXJsOiAhMSB9LCByZXZlcnNlOiB7IGZuOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5zdGF0dXMgPCAyMDAgfHwgMzAwIDw9IHQuc3RhdHVzIH0sIHVybDogITEgfSB9LCBhZGRBc3luY1ZhbGlkYXRvcjogZnVuY3Rpb24gKHQsIGUsIGksIHIpIHsgcmV0dXJuIHguYXN5bmNWYWxpZGF0b3JzW3RdID0geyBmbjogZSwgdXJsOiBpIHx8ICExLCBvcHRpb25zOiByIHx8IHt9IH0sIHRoaXMgfSB9KSwgeC5hZGRWYWxpZGF0b3IoXCJyZW1vdGVcIiwgeyByZXF1aXJlbWVudFR5cGU6IHsgXCJcIjogXCJzdHJpbmdcIiwgdmFsaWRhdG9yOiBcInN0cmluZ1wiLCByZXZlcnNlOiBcImJvb2xlYW5cIiwgb3B0aW9uczogXCJvYmplY3RcIiB9LCB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gKHQsIGUsIGksIHIpIHsgdmFyIG4sIHMsIGEgPSB7fSwgbyA9IGkudmFsaWRhdG9yIHx8ICghMCA9PT0gaS5yZXZlcnNlID8gXCJyZXZlcnNlXCIgOiBcImRlZmF1bHRcIik7IGlmICh2b2lkIDAgPT09IHguYXN5bmNWYWxpZGF0b3JzW29dKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsaW5nIGFuIHVuZGVmaW5lZCBhc3luYyB2YWxpZGF0b3I6IGBcIiArIG8gKyBcImBcIik7IC0xIDwgKGUgPSB4LmFzeW5jVmFsaWRhdG9yc1tvXS51cmwgfHwgZSkuaW5kZXhPZihcInt2YWx1ZX1cIikgPyBlID0gZS5yZXBsYWNlKFwie3ZhbHVlfVwiLCBlbmNvZGVVUklDb21wb25lbnQodCkpIDogYVtyLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSB8fCByLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIildID0gdDsgdmFyIGwgPSBoLmV4dGVuZCghMCwgaS5vcHRpb25zIHx8IHt9LCB4LmFzeW5jVmFsaWRhdG9yc1tvXS5vcHRpb25zKTsgbiA9IGguZXh0ZW5kKCEwLCB7fSwgeyB1cmw6IGUsIGRhdGE6IGEsIHR5cGU6IFwiR0VUXCIgfSwgbCksIHIudHJpZ2dlcihcImZpZWxkOmFqYXhvcHRpb25zXCIsIHIsIG4pLCBzID0gaC5wYXJhbShuKSwgdm9pZCAwID09PSB4Ll9yZW1vdGVDYWNoZSAmJiAoeC5fcmVtb3RlQ2FjaGUgPSB7fSk7IGZ1bmN0aW9uIHUoKSB7IHZhciB0ID0geC5hc3luY1ZhbGlkYXRvcnNbb10uZm4uY2FsbChyLCBkLCBlLCBpKTsgcmV0dXJuIHQgPSB0IHx8IGguRGVmZXJyZWQoKS5yZWplY3QoKSwgaC53aGVuKHQpIH0gdmFyIGQgPSB4Ll9yZW1vdGVDYWNoZVtzXSA9IHguX3JlbW90ZUNhY2hlW3NdIHx8IGguYWpheChuKTsgcmV0dXJuIGQudGhlbih1LCB1KSB9LCBwcmlvcml0eTogLTEgfSksIHgub24oXCJmb3JtOnN1Ym1pdFwiLCBmdW5jdGlvbiAoKSB7IHguX3JlbW90ZUNhY2hlID0ge30gfSksIHIucHJvdG90eXBlLmFkZEFzeW5jVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZC53YXJuT25jZShcIkFjY2Vzc2luZyB0aGUgbWV0aG9kIGBhZGRBc3luY1ZhbGlkYXRvcmAgdGhyb3VnaCBhbiBpbnN0YW5jZSBpcyBkZXByZWNhdGVkLiBTaW1wbHkgY2FsbCBgUGFyc2xleS5hZGRBc3luY1ZhbGlkYXRvciguLi4pYFwiKSwgeC5hZGRBc3luY1ZhbGlkYXRvci5hcHBseSh4LCBhcmd1bWVudHMpIH0sIHguYWRkTWVzc2FnZXMoXCJlblwiLCB7IGRlZmF1bHRNZXNzYWdlOiBcIlRoaXMgdmFsdWUgc2VlbXMgdG8gYmUgaW52YWxpZC5cIiwgdHlwZTogeyBlbWFpbDogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSBhIHZhbGlkIGVtYWlsLlwiLCB1cmw6IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgYSB2YWxpZCB1cmwuXCIsIG51bWJlcjogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSBhIHZhbGlkIG51bWJlci5cIiwgaW50ZWdlcjogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSBhIHZhbGlkIGludGVnZXIuXCIsIGRpZ2l0czogXCJUaGlzIHZhbHVlIHNob3VsZCBiZSBkaWdpdHMuXCIsIGFscGhhbnVtOiBcIlRoaXMgdmFsdWUgc2hvdWxkIGJlIGFscGhhbnVtZXJpYy5cIiB9LCBub3RibGFuazogXCJUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgYmxhbmsuXCIsIHJlcXVpcmVkOiBcIlRoaXMgdmFsdWUgaXMgcmVxdWlyZWQuXCIsIHBhdHRlcm46IFwiVGhpcyB2YWx1ZSBzZWVtcyB0byBiZSBpbnZhbGlkLlwiLCBtaW46IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICVzLlwiLCBtYXg6IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgbG93ZXIgdGhhbiBvciBlcXVhbCB0byAlcy5cIiwgcmFuZ2U6IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgYmV0d2VlbiAlcyBhbmQgJXMuXCIsIG1pbmxlbmd0aDogXCJUaGlzIHZhbHVlIGlzIHRvbyBzaG9ydC4gSXQgc2hvdWxkIGhhdmUgJXMgY2hhcmFjdGVycyBvciBtb3JlLlwiLCBtYXhsZW5ndGg6IFwiVGhpcyB2YWx1ZSBpcyB0b28gbG9uZy4gSXQgc2hvdWxkIGhhdmUgJXMgY2hhcmFjdGVycyBvciBmZXdlci5cIiwgbGVuZ3RoOiBcIlRoaXMgdmFsdWUgbGVuZ3RoIGlzIGludmFsaWQuIEl0IHNob3VsZCBiZSBiZXR3ZWVuICVzIGFuZCAlcyBjaGFyYWN0ZXJzIGxvbmcuXCIsIG1pbmNoZWNrOiBcIllvdSBtdXN0IHNlbGVjdCBhdCBsZWFzdCAlcyBjaG9pY2VzLlwiLCBtYXhjaGVjazogXCJZb3UgbXVzdCBzZWxlY3QgJXMgY2hvaWNlcyBvciBmZXdlci5cIiwgY2hlY2s6IFwiWW91IG11c3Qgc2VsZWN0IGJldHdlZW4gJXMgYW5kICVzIGNob2ljZXMuXCIsIGVxdWFsdG86IFwiVGhpcyB2YWx1ZSBzaG91bGQgYmUgdGhlIHNhbWUuXCIsIGV1dmF0aW46IFwiSXQncyBub3QgYSB2YWxpZCBWQVQgSWRlbnRpZmljYXRpb24gTnVtYmVyLlwiIH0pLCB4LnNldExvY2FsZShcImVuXCIpLCAobmV3IGZ1bmN0aW9uICgpIHsgdmFyIHIgPSB0aGlzLCBuID0gd2luZG93IHx8IGdsb2JhbDsgbCh0aGlzLCB7IGlzTmF0aXZlRXZlbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0Lm9yaWdpbmFsRXZlbnQgJiYgITEgIT09IHQub3JpZ2luYWxFdmVudC5pc1RydXN0ZWQgfSwgZmFrZUlucHV0RXZlbnQ6IGZ1bmN0aW9uICh0KSB7IHIuaXNOYXRpdmVFdmVudCh0KSAmJiBoKHQudGFyZ2V0KS50cmlnZ2VyKFwiaW5wdXRcIikgfSwgbWlzYmVoYXZlczogZnVuY3Rpb24gKHQpIHsgci5pc05hdGl2ZUV2ZW50KHQpICYmIChyLmJlaGF2ZXNPayh0KSwgaChkb2N1bWVudCkub24oXCJjaGFuZ2UuaW5wdXRldmVudFwiLCB0LmRhdGEuc2VsZWN0b3IsIHIuZmFrZUlucHV0RXZlbnQpLCByLmZha2VJbnB1dEV2ZW50KHQpKSB9LCBiZWhhdmVzT2s6IGZ1bmN0aW9uICh0KSB7IHIuaXNOYXRpdmVFdmVudCh0KSAmJiBoKGRvY3VtZW50KS5vZmYoXCJpbnB1dC5pbnB1dGV2ZW50XCIsIHQuZGF0YS5zZWxlY3Rvciwgci5iZWhhdmVzT2spLm9mZihcImNoYW5nZS5pbnB1dGV2ZW50XCIsIHQuZGF0YS5zZWxlY3Rvciwgci5taXNiZWhhdmVzKSB9LCBpbnN0YWxsOiBmdW5jdGlvbiAoKSB7IGlmICghbi5pbnB1dEV2ZW50UGF0Y2hlZCkgeyBuLmlucHV0RXZlbnRQYXRjaGVkID0gXCIwLjAuM1wiOyBmb3IgKHZhciB0ID0gMCwgZSA9IFtcInNlbGVjdFwiLCAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJywgJ2lucHV0W3R5cGU9XCJyYWRpb1wiXScsICdpbnB1dFt0eXBlPVwiZmlsZVwiXSddOyB0IDwgZS5sZW5ndGg7IHQrKykgeyB2YXIgaSA9IGVbdF07IGgoZG9jdW1lbnQpLm9uKFwiaW5wdXQuaW5wdXRldmVudFwiLCBpLCB7IHNlbGVjdG9yOiBpIH0sIHIuYmVoYXZlc09rKS5vbihcImNoYW5nZS5pbnB1dGV2ZW50XCIsIGksIHsgc2VsZWN0b3I6IGkgfSwgci5taXNiZWhhdmVzKSB9IH0gfSwgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7IGRlbGV0ZSBuLmlucHV0RXZlbnRQYXRjaGVkLCBoKGRvY3VtZW50KS5vZmYoXCIuaW5wdXRldmVudFwiKSB9IH0pIH0pLmluc3RhbGwoKSwgeCB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNsZXkubWluLmpzLm1hcCIsIi8qKlxuICogQHBvcHBlcmpzL2NvcmUgdjIuMTEuOCAtIE1JVCBMaWNlbnNlXG4gKi9cblxuIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/dChleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sdCk6dCgoZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOmV8fHNlbGYpLlBvcHBlcj17fSl9KHRoaXMsKGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQoZSl7aWYobnVsbD09ZSlyZXR1cm4gd2luZG93O2lmKFwiW29iamVjdCBXaW5kb3ddXCIhPT1lLnRvU3RyaW5nKCkpe3ZhciB0PWUub3duZXJEb2N1bWVudDtyZXR1cm4gdCYmdC5kZWZhdWx0Vmlld3x8d2luZG93fXJldHVybiBlfWZ1bmN0aW9uIG4oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiB0KGUpLkVsZW1lbnR8fGUgaW5zdGFuY2VvZiBFbGVtZW50fWZ1bmN0aW9uIHIoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiB0KGUpLkhUTUxFbGVtZW50fHxlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnR9ZnVuY3Rpb24gbyhlKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgU2hhZG93Um9vdCYmKGUgaW5zdGFuY2VvZiB0KGUpLlNoYWRvd1Jvb3R8fGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KX12YXIgaT1NYXRoLm1heCxhPU1hdGgubWluLHM9TWF0aC5yb3VuZDtmdW5jdGlvbiBmKCl7dmFyIGU9bmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7cmV0dXJuIG51bGwhPWUmJmUuYnJhbmRzJiZBcnJheS5pc0FycmF5KGUuYnJhbmRzKT9lLmJyYW5kcy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmJyYW5kK1wiL1wiK2UudmVyc2lvbn0pKS5qb2luKFwiIFwiKTpuYXZpZ2F0b3IudXNlckFnZW50fWZ1bmN0aW9uIGMoKXtyZXR1cm4hL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChmKCkpfWZ1bmN0aW9uIHAoZSxvLGkpe3ZvaWQgMD09PW8mJihvPSExKSx2b2lkIDA9PT1pJiYoaT0hMSk7dmFyIGE9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxmPTEscD0xO28mJnIoZSkmJihmPWUub2Zmc2V0V2lkdGg+MCYmcyhhLndpZHRoKS9lLm9mZnNldFdpZHRofHwxLHA9ZS5vZmZzZXRIZWlnaHQ+MCYmcyhhLmhlaWdodCkvZS5vZmZzZXRIZWlnaHR8fDEpO3ZhciB1PShuKGUpP3QoZSk6d2luZG93KS52aXN1YWxWaWV3cG9ydCxsPSFjKCkmJmksZD0oYS5sZWZ0KyhsJiZ1P3Uub2Zmc2V0TGVmdDowKSkvZixoPShhLnRvcCsobCYmdT91Lm9mZnNldFRvcDowKSkvcCxtPWEud2lkdGgvZix2PWEuaGVpZ2h0L3A7cmV0dXJue3dpZHRoOm0saGVpZ2h0OnYsdG9wOmgscmlnaHQ6ZCttLGJvdHRvbTpoK3YsbGVmdDpkLHg6ZCx5Omh9fWZ1bmN0aW9uIHUoZSl7dmFyIG49dChlKTtyZXR1cm57c2Nyb2xsTGVmdDpuLnBhZ2VYT2Zmc2V0LHNjcm9sbFRvcDpuLnBhZ2VZT2Zmc2V0fX1mdW5jdGlvbiBsKGUpe3JldHVybiBlPyhlLm5vZGVOYW1lfHxcIlwiKS50b0xvd2VyQ2FzZSgpOm51bGx9ZnVuY3Rpb24gZChlKXtyZXR1cm4oKG4oZSk/ZS5vd25lckRvY3VtZW50OmUuZG9jdW1lbnQpfHx3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudH1mdW5jdGlvbiBoKGUpe3JldHVybiBwKGQoZSkpLmxlZnQrdShlKS5zY3JvbGxMZWZ0fWZ1bmN0aW9uIG0oZSl7cmV0dXJuIHQoZSkuZ2V0Q29tcHV0ZWRTdHlsZShlKX1mdW5jdGlvbiB2KGUpe3ZhciB0PW0oZSksbj10Lm92ZXJmbG93LHI9dC5vdmVyZmxvd1gsbz10Lm92ZXJmbG93WTtyZXR1cm4vYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3QobitvK3IpfWZ1bmN0aW9uIHkoZSxuLG8pe3ZvaWQgMD09PW8mJihvPSExKTt2YXIgaSxhLGY9cihuKSxjPXIobikmJmZ1bmN0aW9uKGUpe3ZhciB0PWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbj1zKHQud2lkdGgpL2Uub2Zmc2V0V2lkdGh8fDEscj1zKHQuaGVpZ2h0KS9lLm9mZnNldEhlaWdodHx8MTtyZXR1cm4gMSE9PW58fDEhPT1yfShuKSxtPWQobikseT1wKGUsYyxvKSxnPXtzY3JvbGxMZWZ0OjAsc2Nyb2xsVG9wOjB9LGI9e3g6MCx5OjB9O3JldHVybihmfHwhZiYmIW8pJiYoKFwiYm9keVwiIT09bChuKXx8dihtKSkmJihnPShpPW4pIT09dChpKSYmcihpKT97c2Nyb2xsTGVmdDooYT1pKS5zY3JvbGxMZWZ0LHNjcm9sbFRvcDphLnNjcm9sbFRvcH06dShpKSkscihuKT8oKGI9cChuLCEwKSkueCs9bi5jbGllbnRMZWZ0LGIueSs9bi5jbGllbnRUb3ApOm0mJihiLng9aChtKSkpLHt4OnkubGVmdCtnLnNjcm9sbExlZnQtYi54LHk6eS50b3ArZy5zY3JvbGxUb3AtYi55LHdpZHRoOnkud2lkdGgsaGVpZ2h0OnkuaGVpZ2h0fX1mdW5jdGlvbiBnKGUpe3ZhciB0PXAoZSksbj1lLm9mZnNldFdpZHRoLHI9ZS5vZmZzZXRIZWlnaHQ7cmV0dXJuIE1hdGguYWJzKHQud2lkdGgtbik8PTEmJihuPXQud2lkdGgpLE1hdGguYWJzKHQuaGVpZ2h0LXIpPD0xJiYocj10LmhlaWdodCkse3g6ZS5vZmZzZXRMZWZ0LHk6ZS5vZmZzZXRUb3Asd2lkdGg6bixoZWlnaHQ6cn19ZnVuY3Rpb24gYihlKXtyZXR1cm5cImh0bWxcIj09PWwoZSk/ZTplLmFzc2lnbmVkU2xvdHx8ZS5wYXJlbnROb2RlfHwobyhlKT9lLmhvc3Q6bnVsbCl8fGQoZSl9ZnVuY3Rpb24geChlKXtyZXR1cm5bXCJodG1sXCIsXCJib2R5XCIsXCIjZG9jdW1lbnRcIl0uaW5kZXhPZihsKGUpKT49MD9lLm93bmVyRG9jdW1lbnQuYm9keTpyKGUpJiZ2KGUpP2U6eChiKGUpKX1mdW5jdGlvbiB3KGUsbil7dmFyIHI7dm9pZCAwPT09biYmKG49W10pO3ZhciBvPXgoZSksaT1vPT09KG51bGw9PShyPWUub3duZXJEb2N1bWVudCk/dm9pZCAwOnIuYm9keSksYT10KG8pLHM9aT9bYV0uY29uY2F0KGEudmlzdWFsVmlld3BvcnR8fFtdLHYobyk/bzpbXSk6byxmPW4uY29uY2F0KHMpO3JldHVybiBpP2Y6Zi5jb25jYXQodyhiKHMpKSl9ZnVuY3Rpb24gTyhlKXtyZXR1cm5bXCJ0YWJsZVwiLFwidGRcIixcInRoXCJdLmluZGV4T2YobChlKSk+PTB9ZnVuY3Rpb24gaihlKXtyZXR1cm4gcihlKSYmXCJmaXhlZFwiIT09bShlKS5wb3NpdGlvbj9lLm9mZnNldFBhcmVudDpudWxsfWZ1bmN0aW9uIEUoZSl7Zm9yKHZhciBuPXQoZSksaT1qKGUpO2kmJk8oaSkmJlwic3RhdGljXCI9PT1tKGkpLnBvc2l0aW9uOylpPWooaSk7cmV0dXJuIGkmJihcImh0bWxcIj09PWwoaSl8fFwiYm9keVwiPT09bChpKSYmXCJzdGF0aWNcIj09PW0oaSkucG9zaXRpb24pP246aXx8ZnVuY3Rpb24oZSl7dmFyIHQ9L2ZpcmVmb3gvaS50ZXN0KGYoKSk7aWYoL1RyaWRlbnQvaS50ZXN0KGYoKSkmJnIoZSkmJlwiZml4ZWRcIj09PW0oZSkucG9zaXRpb24pcmV0dXJuIG51bGw7dmFyIG49YihlKTtmb3IobyhuKSYmKG49bi5ob3N0KTtyKG4pJiZbXCJodG1sXCIsXCJib2R5XCJdLmluZGV4T2YobChuKSk8MDspe3ZhciBpPW0obik7aWYoXCJub25lXCIhPT1pLnRyYW5zZm9ybXx8XCJub25lXCIhPT1pLnBlcnNwZWN0aXZlfHxcInBhaW50XCI9PT1pLmNvbnRhaW58fC0xIT09W1widHJhbnNmb3JtXCIsXCJwZXJzcGVjdGl2ZVwiXS5pbmRleE9mKGkud2lsbENoYW5nZSl8fHQmJlwiZmlsdGVyXCI9PT1pLndpbGxDaGFuZ2V8fHQmJmkuZmlsdGVyJiZcIm5vbmVcIiE9PWkuZmlsdGVyKXJldHVybiBuO249bi5wYXJlbnROb2RlfXJldHVybiBudWxsfShlKXx8bn12YXIgRD1cInRvcFwiLEE9XCJib3R0b21cIixMPVwicmlnaHRcIixQPVwibGVmdFwiLE09XCJhdXRvXCIsaz1bRCxBLEwsUF0sVz1cInN0YXJ0XCIsQj1cImVuZFwiLEg9XCJ2aWV3cG9ydFwiLFQ9XCJwb3BwZXJcIixSPWsucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBlLmNvbmNhdChbdCtcIi1cIitXLHQrXCItXCIrQl0pfSksW10pLFM9W10uY29uY2F0KGssW01dKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuY29uY2F0KFt0LHQrXCItXCIrVyx0K1wiLVwiK0JdKX0pLFtdKSxWPVtcImJlZm9yZVJlYWRcIixcInJlYWRcIixcImFmdGVyUmVhZFwiLFwiYmVmb3JlTWFpblwiLFwibWFpblwiLFwiYWZ0ZXJNYWluXCIsXCJiZWZvcmVXcml0ZVwiLFwid3JpdGVcIixcImFmdGVyV3JpdGVcIl07ZnVuY3Rpb24gcShlKXt2YXIgdD1uZXcgTWFwLG49bmV3IFNldCxyPVtdO2Z1bmN0aW9uIG8oZSl7bi5hZGQoZS5uYW1lKSxbXS5jb25jYXQoZS5yZXF1aXJlc3x8W10sZS5yZXF1aXJlc0lmRXhpc3RzfHxbXSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aWYoIW4uaGFzKGUpKXt2YXIgcj10LmdldChlKTtyJiZvKHIpfX0pKSxyLnB1c2goZSl9cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dC5zZXQoZS5uYW1lLGUpfSkpLGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bi5oYXMoZS5uYW1lKXx8byhlKX0pKSxyfWZ1bmN0aW9uIEMoZSx0KXt2YXIgbj10LmdldFJvb3ROb2RlJiZ0LmdldFJvb3ROb2RlKCk7aWYoZS5jb250YWlucyh0KSlyZXR1cm4hMDtpZihuJiZvKG4pKXt2YXIgcj10O2Rve2lmKHImJmUuaXNTYW1lTm9kZShyKSlyZXR1cm4hMDtyPXIucGFyZW50Tm9kZXx8ci5ob3N0fXdoaWxlKHIpfXJldHVybiExfWZ1bmN0aW9uIE4oZSl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sZSx7bGVmdDplLngsdG9wOmUueSxyaWdodDplLngrZS53aWR0aCxib3R0b206ZS55K2UuaGVpZ2h0fSl9ZnVuY3Rpb24gSShlLHIsbyl7cmV0dXJuIHI9PT1IP04oZnVuY3Rpb24oZSxuKXt2YXIgcj10KGUpLG89ZChlKSxpPXIudmlzdWFsVmlld3BvcnQsYT1vLmNsaWVudFdpZHRoLHM9by5jbGllbnRIZWlnaHQsZj0wLHA9MDtpZihpKXthPWkud2lkdGgscz1pLmhlaWdodDt2YXIgdT1jKCk7KHV8fCF1JiZcImZpeGVkXCI9PT1uKSYmKGY9aS5vZmZzZXRMZWZ0LHA9aS5vZmZzZXRUb3ApfXJldHVybnt3aWR0aDphLGhlaWdodDpzLHg6ZitoKGUpLHk6cH19KGUsbykpOm4ocik/ZnVuY3Rpb24oZSx0KXt2YXIgbj1wKGUsITEsXCJmaXhlZFwiPT09dCk7cmV0dXJuIG4udG9wPW4udG9wK2UuY2xpZW50VG9wLG4ubGVmdD1uLmxlZnQrZS5jbGllbnRMZWZ0LG4uYm90dG9tPW4udG9wK2UuY2xpZW50SGVpZ2h0LG4ucmlnaHQ9bi5sZWZ0K2UuY2xpZW50V2lkdGgsbi53aWR0aD1lLmNsaWVudFdpZHRoLG4uaGVpZ2h0PWUuY2xpZW50SGVpZ2h0LG4ueD1uLmxlZnQsbi55PW4udG9wLG59KHIsbyk6TihmdW5jdGlvbihlKXt2YXIgdCxuPWQoZSkscj11KGUpLG89bnVsbD09KHQ9ZS5vd25lckRvY3VtZW50KT92b2lkIDA6dC5ib2R5LGE9aShuLnNjcm9sbFdpZHRoLG4uY2xpZW50V2lkdGgsbz9vLnNjcm9sbFdpZHRoOjAsbz9vLmNsaWVudFdpZHRoOjApLHM9aShuLnNjcm9sbEhlaWdodCxuLmNsaWVudEhlaWdodCxvP28uc2Nyb2xsSGVpZ2h0OjAsbz9vLmNsaWVudEhlaWdodDowKSxmPS1yLnNjcm9sbExlZnQraChlKSxjPS1yLnNjcm9sbFRvcDtyZXR1cm5cInJ0bFwiPT09bShvfHxuKS5kaXJlY3Rpb24mJihmKz1pKG4uY2xpZW50V2lkdGgsbz9vLmNsaWVudFdpZHRoOjApLWEpLHt3aWR0aDphLGhlaWdodDpzLHg6Zix5OmN9fShkKGUpKSl9ZnVuY3Rpb24gXyhlLHQsbyxzKXt2YXIgZj1cImNsaXBwaW5nUGFyZW50c1wiPT09dD9mdW5jdGlvbihlKXt2YXIgdD13KGIoZSkpLG89W1wiYWJzb2x1dGVcIixcImZpeGVkXCJdLmluZGV4T2YobShlKS5wb3NpdGlvbik+PTAmJnIoZSk/RShlKTplO3JldHVybiBuKG8pP3QuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gbihlKSYmQyhlLG8pJiZcImJvZHlcIiE9PWwoZSl9KSk6W119KGUpOltdLmNvbmNhdCh0KSxjPVtdLmNvbmNhdChmLFtvXSkscD1jWzBdLHU9Yy5yZWR1Y2UoKGZ1bmN0aW9uKHQsbil7dmFyIHI9SShlLG4scyk7cmV0dXJuIHQudG9wPWkoci50b3AsdC50b3ApLHQucmlnaHQ9YShyLnJpZ2h0LHQucmlnaHQpLHQuYm90dG9tPWEoci5ib3R0b20sdC5ib3R0b20pLHQubGVmdD1pKHIubGVmdCx0LmxlZnQpLHR9KSxJKGUscCxzKSk7cmV0dXJuIHUud2lkdGg9dS5yaWdodC11LmxlZnQsdS5oZWlnaHQ9dS5ib3R0b20tdS50b3AsdS54PXUubGVmdCx1Lnk9dS50b3AsdX1mdW5jdGlvbiBGKGUpe3JldHVybiBlLnNwbGl0KFwiLVwiKVswXX1mdW5jdGlvbiBVKGUpe3JldHVybiBlLnNwbGl0KFwiLVwiKVsxXX1mdW5jdGlvbiB6KGUpe3JldHVybltcInRvcFwiLFwiYm90dG9tXCJdLmluZGV4T2YoZSk+PTA/XCJ4XCI6XCJ5XCJ9ZnVuY3Rpb24gWChlKXt2YXIgdCxuPWUucmVmZXJlbmNlLHI9ZS5lbGVtZW50LG89ZS5wbGFjZW1lbnQsaT1vP0Yobyk6bnVsbCxhPW8/VShvKTpudWxsLHM9bi54K24ud2lkdGgvMi1yLndpZHRoLzIsZj1uLnkrbi5oZWlnaHQvMi1yLmhlaWdodC8yO3N3aXRjaChpKXtjYXNlIEQ6dD17eDpzLHk6bi55LXIuaGVpZ2h0fTticmVhaztjYXNlIEE6dD17eDpzLHk6bi55K24uaGVpZ2h0fTticmVhaztjYXNlIEw6dD17eDpuLngrbi53aWR0aCx5OmZ9O2JyZWFrO2Nhc2UgUDp0PXt4Om4ueC1yLndpZHRoLHk6Zn07YnJlYWs7ZGVmYXVsdDp0PXt4Om4ueCx5Om4ueX19dmFyIGM9aT96KGkpOm51bGw7aWYobnVsbCE9Yyl7dmFyIHA9XCJ5XCI9PT1jP1wiaGVpZ2h0XCI6XCJ3aWR0aFwiO3N3aXRjaChhKXtjYXNlIFc6dFtjXT10W2NdLShuW3BdLzItcltwXS8yKTticmVhaztjYXNlIEI6dFtjXT10W2NdKyhuW3BdLzItcltwXS8yKX19cmV0dXJuIHR9ZnVuY3Rpb24gWShlKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSx7dG9wOjAscmlnaHQ6MCxib3R0b206MCxsZWZ0OjB9LGUpfWZ1bmN0aW9uIEcoZSx0KXtyZXR1cm4gdC5yZWR1Y2UoKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbbl09ZSx0fSkse30pfWZ1bmN0aW9uIEooZSx0KXt2b2lkIDA9PT10JiYodD17fSk7dmFyIHI9dCxvPXIucGxhY2VtZW50LGk9dm9pZCAwPT09bz9lLnBsYWNlbWVudDpvLGE9ci5zdHJhdGVneSxzPXZvaWQgMD09PWE/ZS5zdHJhdGVneTphLGY9ci5ib3VuZGFyeSxjPXZvaWQgMD09PWY/XCJjbGlwcGluZ1BhcmVudHNcIjpmLHU9ci5yb290Qm91bmRhcnksbD12b2lkIDA9PT11P0g6dSxoPXIuZWxlbWVudENvbnRleHQsbT12b2lkIDA9PT1oP1Q6aCx2PXIuYWx0Qm91bmRhcnkseT12b2lkIDAhPT12JiZ2LGc9ci5wYWRkaW5nLGI9dm9pZCAwPT09Zz8wOmcseD1ZKFwibnVtYmVyXCIhPXR5cGVvZiBiP2I6RyhiLGspKSx3PW09PT1UP1wicmVmZXJlbmNlXCI6VCxPPWUucmVjdHMucG9wcGVyLGo9ZS5lbGVtZW50c1t5P3c6bV0sRT1fKG4oaik/ajpqLmNvbnRleHRFbGVtZW50fHxkKGUuZWxlbWVudHMucG9wcGVyKSxjLGwscyksUD1wKGUuZWxlbWVudHMucmVmZXJlbmNlKSxNPVgoe3JlZmVyZW5jZTpQLGVsZW1lbnQ6TyxzdHJhdGVneTpcImFic29sdXRlXCIscGxhY2VtZW50Oml9KSxXPU4oT2JqZWN0LmFzc2lnbih7fSxPLE0pKSxCPW09PT1UP1c6UCxSPXt0b3A6RS50b3AtQi50b3AreC50b3AsYm90dG9tOkIuYm90dG9tLUUuYm90dG9tK3guYm90dG9tLGxlZnQ6RS5sZWZ0LUIubGVmdCt4LmxlZnQscmlnaHQ6Qi5yaWdodC1FLnJpZ2h0K3gucmlnaHR9LFM9ZS5tb2RpZmllcnNEYXRhLm9mZnNldDtpZihtPT09VCYmUyl7dmFyIFY9U1tpXTtPYmplY3Qua2V5cyhSKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdD1bTCxBXS5pbmRleE9mKGUpPj0wPzE6LTEsbj1bRCxBXS5pbmRleE9mKGUpPj0wP1wieVwiOlwieFwiO1JbZV0rPVZbbl0qdH0pKX1yZXR1cm4gUn12YXIgSz17cGxhY2VtZW50OlwiYm90dG9tXCIsbW9kaWZpZXJzOltdLHN0cmF0ZWd5OlwiYWJzb2x1dGVcIn07ZnVuY3Rpb24gUSgpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLG49MDtuPGU7bisrKXRbbl09YXJndW1lbnRzW25dO3JldHVybiF0LnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiEoZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpfSkpfWZ1bmN0aW9uIFooZSl7dm9pZCAwPT09ZSYmKGU9e30pO3ZhciB0PWUscj10LmRlZmF1bHRNb2RpZmllcnMsbz12b2lkIDA9PT1yP1tdOnIsaT10LmRlZmF1bHRPcHRpb25zLGE9dm9pZCAwPT09aT9LOmk7cmV0dXJuIGZ1bmN0aW9uKGUsdCxyKXt2b2lkIDA9PT1yJiYocj1hKTt2YXIgaSxzLGY9e3BsYWNlbWVudDpcImJvdHRvbVwiLG9yZGVyZWRNb2RpZmllcnM6W10sb3B0aW9uczpPYmplY3QuYXNzaWduKHt9LEssYSksbW9kaWZpZXJzRGF0YTp7fSxlbGVtZW50czp7cmVmZXJlbmNlOmUscG9wcGVyOnR9LGF0dHJpYnV0ZXM6e30sc3R5bGVzOnt9fSxjPVtdLHA9ITEsdT17c3RhdGU6ZixzZXRPcHRpb25zOmZ1bmN0aW9uKHIpe3ZhciBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIHI/cihmLm9wdGlvbnMpOnI7bCgpLGYub3B0aW9ucz1PYmplY3QuYXNzaWduKHt9LGEsZi5vcHRpb25zLGkpLGYuc2Nyb2xsUGFyZW50cz17cmVmZXJlbmNlOm4oZSk/dyhlKTplLmNvbnRleHRFbGVtZW50P3coZS5jb250ZXh0RWxlbWVudCk6W10scG9wcGVyOncodCl9O3ZhciBzLHAsZD1mdW5jdGlvbihlKXt2YXIgdD1xKGUpO3JldHVybiBWLnJlZHVjZSgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZS5jb25jYXQodC5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnBoYXNlPT09bn0pKSl9KSxbXSl9KChzPVtdLmNvbmNhdChvLGYub3B0aW9ucy5tb2RpZmllcnMpLHA9cy5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7dmFyIG49ZVt0Lm5hbWVdO3JldHVybiBlW3QubmFtZV09bj9PYmplY3QuYXNzaWduKHt9LG4sdCx7b3B0aW9uczpPYmplY3QuYXNzaWduKHt9LG4ub3B0aW9ucyx0Lm9wdGlvbnMpLGRhdGE6T2JqZWN0LmFzc2lnbih7fSxuLmRhdGEsdC5kYXRhKX0pOnQsZX0pLHt9KSxPYmplY3Qua2V5cyhwKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBwW2VdfSkpKSk7cmV0dXJuIGYub3JkZXJlZE1vZGlmaWVycz1kLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZW5hYmxlZH0pKSxmLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5uYW1lLG49ZS5vcHRpb25zLHI9dm9pZCAwPT09bj97fTpuLG89ZS5lZmZlY3Q7aWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygbyl7dmFyIGk9byh7c3RhdGU6ZixuYW1lOnQsaW5zdGFuY2U6dSxvcHRpb25zOnJ9KSxhPWZ1bmN0aW9uKCl7fTtjLnB1c2goaXx8YSl9fSkpLHUudXBkYXRlKCl9LGZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7aWYoIXApe3ZhciBlPWYuZWxlbWVudHMsdD1lLnJlZmVyZW5jZSxuPWUucG9wcGVyO2lmKFEodCxuKSl7Zi5yZWN0cz17cmVmZXJlbmNlOnkodCxFKG4pLFwiZml4ZWRcIj09PWYub3B0aW9ucy5zdHJhdGVneSkscG9wcGVyOmcobil9LGYucmVzZXQ9ITEsZi5wbGFjZW1lbnQ9Zi5vcHRpb25zLnBsYWNlbWVudCxmLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGYubW9kaWZpZXJzRGF0YVtlLm5hbWVdPU9iamVjdC5hc3NpZ24oe30sZS5kYXRhKX0pKTtmb3IodmFyIHI9MDtyPGYub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7cisrKWlmKCEwIT09Zi5yZXNldCl7dmFyIG89Zi5vcmRlcmVkTW9kaWZpZXJzW3JdLGk9by5mbixhPW8ub3B0aW9ucyxzPXZvaWQgMD09PWE/e306YSxjPW8ubmFtZTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBpJiYoZj1pKHtzdGF0ZTpmLG9wdGlvbnM6cyxuYW1lOmMsaW5zdGFuY2U6dX0pfHxmKX1lbHNlIGYucmVzZXQ9ITEscj0tMX19fSx1cGRhdGU6KGk9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe3UuZm9yY2VVcGRhdGUoKSxlKGYpfSkpfSxmdW5jdGlvbigpe3JldHVybiBzfHwocz1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtzPXZvaWQgMCxlKGkoKSl9KSl9KSkpLHN9KSxkZXN0cm95OmZ1bmN0aW9uKCl7bCgpLHA9ITB9fTtpZighUShlLHQpKXJldHVybiB1O2Z1bmN0aW9uIGwoKXtjLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KSksYz1bXX1yZXR1cm4gdS5zZXRPcHRpb25zKHIpLnRoZW4oKGZ1bmN0aW9uKGUpeyFwJiZyLm9uRmlyc3RVcGRhdGUmJnIub25GaXJzdFVwZGF0ZShlKX0pKSx1fX12YXIgJD17cGFzc2l2ZTohMH07dmFyIGVlPXtuYW1lOlwiZXZlbnRMaXN0ZW5lcnNcIixlbmFibGVkOiEwLHBoYXNlOlwid3JpdGVcIixmbjpmdW5jdGlvbigpe30sZWZmZWN0OmZ1bmN0aW9uKGUpe3ZhciBuPWUuc3RhdGUscj1lLmluc3RhbmNlLG89ZS5vcHRpb25zLGk9by5zY3JvbGwsYT12b2lkIDA9PT1pfHxpLHM9by5yZXNpemUsZj12b2lkIDA9PT1zfHxzLGM9dChuLmVsZW1lbnRzLnBvcHBlcikscD1bXS5jb25jYXQobi5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSxuLnNjcm9sbFBhcmVudHMucG9wcGVyKTtyZXR1cm4gYSYmcC5mb3JFYWNoKChmdW5jdGlvbihlKXtlLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixyLnVwZGF0ZSwkKX0pKSxmJiZjLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixyLnVwZGF0ZSwkKSxmdW5jdGlvbigpe2EmJnAuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsci51cGRhdGUsJCl9KSksZiYmYy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsci51cGRhdGUsJCl9fSxkYXRhOnt9fTt2YXIgdGU9e25hbWU6XCJwb3BwZXJPZmZzZXRzXCIsZW5hYmxlZDohMCxwaGFzZTpcInJlYWRcIixmbjpmdW5jdGlvbihlKXt2YXIgdD1lLnN0YXRlLG49ZS5uYW1lO3QubW9kaWZpZXJzRGF0YVtuXT1YKHtyZWZlcmVuY2U6dC5yZWN0cy5yZWZlcmVuY2UsZWxlbWVudDp0LnJlY3RzLnBvcHBlcixzdHJhdGVneTpcImFic29sdXRlXCIscGxhY2VtZW50OnQucGxhY2VtZW50fSl9LGRhdGE6e319LG5lPXt0b3A6XCJhdXRvXCIscmlnaHQ6XCJhdXRvXCIsYm90dG9tOlwiYXV0b1wiLGxlZnQ6XCJhdXRvXCJ9O2Z1bmN0aW9uIHJlKGUpe3ZhciBuLHI9ZS5wb3BwZXIsbz1lLnBvcHBlclJlY3QsaT1lLnBsYWNlbWVudCxhPWUudmFyaWF0aW9uLGY9ZS5vZmZzZXRzLGM9ZS5wb3NpdGlvbixwPWUuZ3B1QWNjZWxlcmF0aW9uLHU9ZS5hZGFwdGl2ZSxsPWUucm91bmRPZmZzZXRzLGg9ZS5pc0ZpeGVkLHY9Zi54LHk9dm9pZCAwPT09dj8wOnYsZz1mLnksYj12b2lkIDA9PT1nPzA6Zyx4PVwiZnVuY3Rpb25cIj09dHlwZW9mIGw/bCh7eDp5LHk6Yn0pOnt4OnkseTpifTt5PXgueCxiPXgueTt2YXIgdz1mLmhhc093blByb3BlcnR5KFwieFwiKSxPPWYuaGFzT3duUHJvcGVydHkoXCJ5XCIpLGo9UCxNPUQsaz13aW5kb3c7aWYodSl7dmFyIFc9RShyKSxIPVwiY2xpZW50SGVpZ2h0XCIsVD1cImNsaWVudFdpZHRoXCI7aWYoVz09PXQocikmJlwic3RhdGljXCIhPT1tKFc9ZChyKSkucG9zaXRpb24mJlwiYWJzb2x1dGVcIj09PWMmJihIPVwic2Nyb2xsSGVpZ2h0XCIsVD1cInNjcm9sbFdpZHRoXCIpLFc9VyxpPT09RHx8KGk9PT1QfHxpPT09TCkmJmE9PT1CKU09QSxiLT0oaCYmVz09PWsmJmsudmlzdWFsVmlld3BvcnQ/ay52aXN1YWxWaWV3cG9ydC5oZWlnaHQ6V1tIXSktby5oZWlnaHQsYio9cD8xOi0xO2lmKGk9PT1QfHwoaT09PUR8fGk9PT1BKSYmYT09PUIpaj1MLHktPShoJiZXPT09ayYmay52aXN1YWxWaWV3cG9ydD9rLnZpc3VhbFZpZXdwb3J0LndpZHRoOldbVF0pLW8ud2lkdGgseSo9cD8xOi0xfXZhciBSLFM9T2JqZWN0LmFzc2lnbih7cG9zaXRpb246Y30sdSYmbmUpLFY9ITA9PT1sP2Z1bmN0aW9uKGUsdCl7dmFyIG49ZS54LHI9ZS55LG89dC5kZXZpY2VQaXhlbFJhdGlvfHwxO3JldHVybnt4OnMobipvKS9vfHwwLHk6cyhyKm8pL298fDB9fSh7eDp5LHk6Yn0sdChyKSk6e3g6eSx5OmJ9O3JldHVybiB5PVYueCxiPVYueSxwP09iamVjdC5hc3NpZ24oe30sUywoKFI9e30pW01dPU8/XCIwXCI6XCJcIixSW2pdPXc/XCIwXCI6XCJcIixSLnRyYW5zZm9ybT0oay5kZXZpY2VQaXhlbFJhdGlvfHwxKTw9MT9cInRyYW5zbGF0ZShcIit5K1wicHgsIFwiK2IrXCJweClcIjpcInRyYW5zbGF0ZTNkKFwiK3krXCJweCwgXCIrYitcInB4LCAwKVwiLFIpKTpPYmplY3QuYXNzaWduKHt9LFMsKChuPXt9KVtNXT1PP2IrXCJweFwiOlwiXCIsbltqXT13P3krXCJweFwiOlwiXCIsbi50cmFuc2Zvcm09XCJcIixuKSl9dmFyIG9lPXtuYW1lOlwiY29tcHV0ZVN0eWxlc1wiLGVuYWJsZWQ6ITAscGhhc2U6XCJiZWZvcmVXcml0ZVwiLGZuOmZ1bmN0aW9uKGUpe3ZhciB0PWUuc3RhdGUsbj1lLm9wdGlvbnMscj1uLmdwdUFjY2VsZXJhdGlvbixvPXZvaWQgMD09PXJ8fHIsaT1uLmFkYXB0aXZlLGE9dm9pZCAwPT09aXx8aSxzPW4ucm91bmRPZmZzZXRzLGY9dm9pZCAwPT09c3x8cyxjPXtwbGFjZW1lbnQ6Rih0LnBsYWNlbWVudCksdmFyaWF0aW9uOlUodC5wbGFjZW1lbnQpLHBvcHBlcjp0LmVsZW1lbnRzLnBvcHBlcixwb3BwZXJSZWN0OnQucmVjdHMucG9wcGVyLGdwdUFjY2VsZXJhdGlvbjpvLGlzRml4ZWQ6XCJmaXhlZFwiPT09dC5vcHRpb25zLnN0cmF0ZWd5fTtudWxsIT10Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyYmKHQuc3R5bGVzLnBvcHBlcj1PYmplY3QuYXNzaWduKHt9LHQuc3R5bGVzLnBvcHBlcixyZShPYmplY3QuYXNzaWduKHt9LGMse29mZnNldHM6dC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMscG9zaXRpb246dC5vcHRpb25zLnN0cmF0ZWd5LGFkYXB0aXZlOmEscm91bmRPZmZzZXRzOmZ9KSkpKSxudWxsIT10Lm1vZGlmaWVyc0RhdGEuYXJyb3cmJih0LnN0eWxlcy5hcnJvdz1PYmplY3QuYXNzaWduKHt9LHQuc3R5bGVzLmFycm93LHJlKE9iamVjdC5hc3NpZ24oe30sYyx7b2Zmc2V0czp0Lm1vZGlmaWVyc0RhdGEuYXJyb3cscG9zaXRpb246XCJhYnNvbHV0ZVwiLGFkYXB0aXZlOiExLHJvdW5kT2Zmc2V0czpmfSkpKSksdC5hdHRyaWJ1dGVzLnBvcHBlcj1PYmplY3QuYXNzaWduKHt9LHQuYXR0cmlidXRlcy5wb3BwZXIse1wiZGF0YS1wb3BwZXItcGxhY2VtZW50XCI6dC5wbGFjZW1lbnR9KX0sZGF0YTp7fX07dmFyIGllPXtuYW1lOlwiYXBwbHlTdHlsZXNcIixlbmFibGVkOiEwLHBoYXNlOlwid3JpdGVcIixmbjpmdW5jdGlvbihlKXt2YXIgdD1lLnN0YXRlO09iamVjdC5rZXlzKHQuZWxlbWVudHMpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPXQuc3R5bGVzW2VdfHx7fSxvPXQuYXR0cmlidXRlc1tlXXx8e30saT10LmVsZW1lbnRzW2VdO3IoaSkmJmwoaSkmJihPYmplY3QuYXNzaWduKGkuc3R5bGUsbiksT2JqZWN0LmtleXMobykuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHQ9b1tlXTshMT09PXQ/aS5yZW1vdmVBdHRyaWJ1dGUoZSk6aS5zZXRBdHRyaWJ1dGUoZSwhMD09PXQ/XCJcIjp0KX0pKSl9KSl9LGVmZmVjdDpmdW5jdGlvbihlKXt2YXIgdD1lLnN0YXRlLG49e3BvcHBlcjp7cG9zaXRpb246dC5vcHRpb25zLnN0cmF0ZWd5LGxlZnQ6XCIwXCIsdG9wOlwiMFwiLG1hcmdpbjpcIjBcIn0sYXJyb3c6e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIn0scmVmZXJlbmNlOnt9fTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LmVsZW1lbnRzLnBvcHBlci5zdHlsZSxuLnBvcHBlciksdC5zdHlsZXM9bix0LmVsZW1lbnRzLmFycm93JiZPYmplY3QuYXNzaWduKHQuZWxlbWVudHMuYXJyb3cuc3R5bGUsbi5hcnJvdyksZnVuY3Rpb24oKXtPYmplY3Qua2V5cyh0LmVsZW1lbnRzKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbz10LmVsZW1lbnRzW2VdLGk9dC5hdHRyaWJ1dGVzW2VdfHx7fSxhPU9iamVjdC5rZXlzKHQuc3R5bGVzLmhhc093blByb3BlcnR5KGUpP3Quc3R5bGVzW2VdOm5bZV0pLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVt0XT1cIlwiLGV9KSx7fSk7cihvKSYmbChvKSYmKE9iamVjdC5hc3NpZ24oby5zdHlsZSxhKSxPYmplY3Qua2V5cyhpKS5mb3JFYWNoKChmdW5jdGlvbihlKXtvLnJlbW92ZUF0dHJpYnV0ZShlKX0pKSl9KSl9fSxyZXF1aXJlczpbXCJjb21wdXRlU3R5bGVzXCJdfTt2YXIgYWU9e25hbWU6XCJvZmZzZXRcIixlbmFibGVkOiEwLHBoYXNlOlwibWFpblwiLHJlcXVpcmVzOltcInBvcHBlck9mZnNldHNcIl0sZm46ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdGF0ZSxuPWUub3B0aW9ucyxyPWUubmFtZSxvPW4ub2Zmc2V0LGk9dm9pZCAwPT09bz9bMCwwXTpvLGE9Uy5yZWR1Y2UoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbbl09ZnVuY3Rpb24oZSx0LG4pe3ZhciByPUYoZSksbz1bUCxEXS5pbmRleE9mKHIpPj0wPy0xOjEsaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP24oT2JqZWN0LmFzc2lnbih7fSx0LHtwbGFjZW1lbnQ6ZX0pKTpuLGE9aVswXSxzPWlbMV07cmV0dXJuIGE9YXx8MCxzPShzfHwwKSpvLFtQLExdLmluZGV4T2Yocik+PTA/e3g6cyx5OmF9Ont4OmEseTpzfX0obix0LnJlY3RzLGkpLGV9KSx7fSkscz1hW3QucGxhY2VtZW50XSxmPXMueCxjPXMueTtudWxsIT10Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyYmKHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLngrPWYsdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSs9YyksdC5tb2RpZmllcnNEYXRhW3JdPWF9fSxzZT17bGVmdDpcInJpZ2h0XCIscmlnaHQ6XCJsZWZ0XCIsYm90dG9tOlwidG9wXCIsdG9wOlwiYm90dG9tXCJ9O2Z1bmN0aW9uIGZlKGUpe3JldHVybiBlLnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLChmdW5jdGlvbihlKXtyZXR1cm4gc2VbZV19KSl9dmFyIGNlPXtzdGFydDpcImVuZFwiLGVuZDpcInN0YXJ0XCJ9O2Z1bmN0aW9uIHBlKGUpe3JldHVybiBlLnJlcGxhY2UoL3N0YXJ0fGVuZC9nLChmdW5jdGlvbihlKXtyZXR1cm4gY2VbZV19KSl9ZnVuY3Rpb24gdWUoZSx0KXt2b2lkIDA9PT10JiYodD17fSk7dmFyIG49dCxyPW4ucGxhY2VtZW50LG89bi5ib3VuZGFyeSxpPW4ucm9vdEJvdW5kYXJ5LGE9bi5wYWRkaW5nLHM9bi5mbGlwVmFyaWF0aW9ucyxmPW4uYWxsb3dlZEF1dG9QbGFjZW1lbnRzLGM9dm9pZCAwPT09Zj9TOmYscD1VKHIpLHU9cD9zP1I6Ui5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBVKGUpPT09cH0pKTprLGw9dS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBjLmluZGV4T2YoZSk+PTB9KSk7MD09PWwubGVuZ3RoJiYobD11KTt2YXIgZD1sLnJlZHVjZSgoZnVuY3Rpb24odCxuKXtyZXR1cm4gdFtuXT1KKGUse3BsYWNlbWVudDpuLGJvdW5kYXJ5Om8scm9vdEJvdW5kYXJ5OmkscGFkZGluZzphfSlbRihuKV0sdH0pLHt9KTtyZXR1cm4gT2JqZWN0LmtleXMoZCkuc29ydCgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZFtlXS1kW3RdfSkpfXZhciBsZT17bmFtZTpcImZsaXBcIixlbmFibGVkOiEwLHBoYXNlOlwibWFpblwiLGZuOmZ1bmN0aW9uKGUpe3ZhciB0PWUuc3RhdGUsbj1lLm9wdGlvbnMscj1lLm5hbWU7aWYoIXQubW9kaWZpZXJzRGF0YVtyXS5fc2tpcCl7Zm9yKHZhciBvPW4ubWFpbkF4aXMsaT12b2lkIDA9PT1vfHxvLGE9bi5hbHRBeGlzLHM9dm9pZCAwPT09YXx8YSxmPW4uZmFsbGJhY2tQbGFjZW1lbnRzLGM9bi5wYWRkaW5nLHA9bi5ib3VuZGFyeSx1PW4ucm9vdEJvdW5kYXJ5LGw9bi5hbHRCb3VuZGFyeSxkPW4uZmxpcFZhcmlhdGlvbnMsaD12b2lkIDA9PT1kfHxkLG09bi5hbGxvd2VkQXV0b1BsYWNlbWVudHMsdj10Lm9wdGlvbnMucGxhY2VtZW50LHk9Rih2KSxnPWZ8fCh5PT09dnx8IWg/W2ZlKHYpXTpmdW5jdGlvbihlKXtpZihGKGUpPT09TSlyZXR1cm5bXTt2YXIgdD1mZShlKTtyZXR1cm5bcGUoZSksdCxwZSh0KV19KHYpKSxiPVt2XS5jb25jYXQoZykucmVkdWNlKChmdW5jdGlvbihlLG4pe3JldHVybiBlLmNvbmNhdChGKG4pPT09TT91ZSh0LHtwbGFjZW1lbnQ6bixib3VuZGFyeTpwLHJvb3RCb3VuZGFyeTp1LHBhZGRpbmc6YyxmbGlwVmFyaWF0aW9uczpoLGFsbG93ZWRBdXRvUGxhY2VtZW50czptfSk6bil9KSxbXSkseD10LnJlY3RzLnJlZmVyZW5jZSx3PXQucmVjdHMucG9wcGVyLE89bmV3IE1hcCxqPSEwLEU9YlswXSxrPTA7azxiLmxlbmd0aDtrKyspe3ZhciBCPWJba10sSD1GKEIpLFQ9VShCKT09PVcsUj1bRCxBXS5pbmRleE9mKEgpPj0wLFM9Uj9cIndpZHRoXCI6XCJoZWlnaHRcIixWPUoodCx7cGxhY2VtZW50OkIsYm91bmRhcnk6cCxyb290Qm91bmRhcnk6dSxhbHRCb3VuZGFyeTpsLHBhZGRpbmc6Y30pLHE9Uj9UP0w6UDpUP0E6RDt4W1NdPndbU10mJihxPWZlKHEpKTt2YXIgQz1mZShxKSxOPVtdO2lmKGkmJk4ucHVzaChWW0hdPD0wKSxzJiZOLnB1c2goVltxXTw9MCxWW0NdPD0wKSxOLmV2ZXJ5KChmdW5jdGlvbihlKXtyZXR1cm4gZX0pKSl7RT1CLGo9ITE7YnJlYWt9Ty5zZXQoQixOKX1pZihqKWZvcih2YXIgST1mdW5jdGlvbihlKXt2YXIgdD1iLmZpbmQoKGZ1bmN0aW9uKHQpe3ZhciBuPU8uZ2V0KHQpO2lmKG4pcmV0dXJuIG4uc2xpY2UoMCxlKS5ldmVyeSgoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KSl9KSk7aWYodClyZXR1cm4gRT10LFwiYnJlYWtcIn0sXz1oPzM6MTtfPjA7Xy0tKXtpZihcImJyZWFrXCI9PT1JKF8pKWJyZWFrfXQucGxhY2VtZW50IT09RSYmKHQubW9kaWZpZXJzRGF0YVtyXS5fc2tpcD0hMCx0LnBsYWNlbWVudD1FLHQucmVzZXQ9ITApfX0scmVxdWlyZXNJZkV4aXN0czpbXCJvZmZzZXRcIl0sZGF0YTp7X3NraXA6ITF9fTtmdW5jdGlvbiBkZShlLHQsbil7cmV0dXJuIGkoZSxhKHQsbikpfXZhciBoZT17bmFtZTpcInByZXZlbnRPdmVyZmxvd1wiLGVuYWJsZWQ6ITAscGhhc2U6XCJtYWluXCIsZm46ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdGF0ZSxuPWUub3B0aW9ucyxyPWUubmFtZSxvPW4ubWFpbkF4aXMscz12b2lkIDA9PT1vfHxvLGY9bi5hbHRBeGlzLGM9dm9pZCAwIT09ZiYmZixwPW4uYm91bmRhcnksdT1uLnJvb3RCb3VuZGFyeSxsPW4uYWx0Qm91bmRhcnksZD1uLnBhZGRpbmcsaD1uLnRldGhlcixtPXZvaWQgMD09PWh8fGgsdj1uLnRldGhlck9mZnNldCx5PXZvaWQgMD09PXY/MDp2LGI9Sih0LHtib3VuZGFyeTpwLHJvb3RCb3VuZGFyeTp1LHBhZGRpbmc6ZCxhbHRCb3VuZGFyeTpsfSkseD1GKHQucGxhY2VtZW50KSx3PVUodC5wbGFjZW1lbnQpLE89IXcsaj16KHgpLE09XCJ4XCI9PT1qP1wieVwiOlwieFwiLGs9dC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsQj10LnJlY3RzLnJlZmVyZW5jZSxIPXQucmVjdHMucG9wcGVyLFQ9XCJmdW5jdGlvblwiPT10eXBlb2YgeT95KE9iamVjdC5hc3NpZ24oe30sdC5yZWN0cyx7cGxhY2VtZW50OnQucGxhY2VtZW50fSkpOnksUj1cIm51bWJlclwiPT10eXBlb2YgVD97bWFpbkF4aXM6VCxhbHRBeGlzOlR9Ok9iamVjdC5hc3NpZ24oe21haW5BeGlzOjAsYWx0QXhpczowfSxUKSxTPXQubW9kaWZpZXJzRGF0YS5vZmZzZXQ/dC5tb2RpZmllcnNEYXRhLm9mZnNldFt0LnBsYWNlbWVudF06bnVsbCxWPXt4OjAseTowfTtpZihrKXtpZihzKXt2YXIgcSxDPVwieVwiPT09aj9EOlAsTj1cInlcIj09PWo/QTpMLEk9XCJ5XCI9PT1qP1wiaGVpZ2h0XCI6XCJ3aWR0aFwiLF89a1tqXSxYPV8rYltDXSxZPV8tYltOXSxHPW0/LUhbSV0vMjowLEs9dz09PVc/QltJXTpIW0ldLFE9dz09PVc/LUhbSV06LUJbSV0sWj10LmVsZW1lbnRzLmFycm93LCQ9bSYmWj9nKFopOnt3aWR0aDowLGhlaWdodDowfSxlZT10Lm1vZGlmaWVyc0RhdGFbXCJhcnJvdyNwZXJzaXN0ZW50XCJdP3QubW9kaWZpZXJzRGF0YVtcImFycm93I3BlcnNpc3RlbnRcIl0ucGFkZGluZzp7dG9wOjAscmlnaHQ6MCxib3R0b206MCxsZWZ0OjB9LHRlPWVlW0NdLG5lPWVlW05dLHJlPWRlKDAsQltJXSwkW0ldKSxvZT1PP0JbSV0vMi1HLXJlLXRlLVIubWFpbkF4aXM6Sy1yZS10ZS1SLm1haW5BeGlzLGllPU8/LUJbSV0vMitHK3JlK25lK1IubWFpbkF4aXM6UStyZStuZStSLm1haW5BeGlzLGFlPXQuZWxlbWVudHMuYXJyb3cmJkUodC5lbGVtZW50cy5hcnJvdyksc2U9YWU/XCJ5XCI9PT1qP2FlLmNsaWVudFRvcHx8MDphZS5jbGllbnRMZWZ0fHwwOjAsZmU9bnVsbCE9KHE9bnVsbD09Uz92b2lkIDA6U1tqXSk/cTowLGNlPV8raWUtZmUscGU9ZGUobT9hKFgsXytvZS1mZS1zZSk6WCxfLG0/aShZLGNlKTpZKTtrW2pdPXBlLFZbal09cGUtX31pZihjKXt2YXIgdWUsbGU9XCJ4XCI9PT1qP0Q6UCxoZT1cInhcIj09PWo/QTpMLG1lPWtbTV0sdmU9XCJ5XCI9PT1NP1wiaGVpZ2h0XCI6XCJ3aWR0aFwiLHllPW1lK2JbbGVdLGdlPW1lLWJbaGVdLGJlPS0xIT09W0QsUF0uaW5kZXhPZih4KSx4ZT1udWxsIT0odWU9bnVsbD09Uz92b2lkIDA6U1tNXSk/dWU6MCx3ZT1iZT95ZTptZS1CW3ZlXS1IW3ZlXS14ZStSLmFsdEF4aXMsT2U9YmU/bWUrQlt2ZV0rSFt2ZV0teGUtUi5hbHRBeGlzOmdlLGplPW0mJmJlP2Z1bmN0aW9uKGUsdCxuKXt2YXIgcj1kZShlLHQsbik7cmV0dXJuIHI+bj9uOnJ9KHdlLG1lLE9lKTpkZShtP3dlOnllLG1lLG0/T2U6Z2UpO2tbTV09amUsVltNXT1qZS1tZX10Lm1vZGlmaWVyc0RhdGFbcl09Vn19LHJlcXVpcmVzSWZFeGlzdHM6W1wib2Zmc2V0XCJdfTt2YXIgbWU9e25hbWU6XCJhcnJvd1wiLGVuYWJsZWQ6ITAscGhhc2U6XCJtYWluXCIsZm46ZnVuY3Rpb24oZSl7dmFyIHQsbj1lLnN0YXRlLHI9ZS5uYW1lLG89ZS5vcHRpb25zLGk9bi5lbGVtZW50cy5hcnJvdyxhPW4ubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLHM9RihuLnBsYWNlbWVudCksZj16KHMpLGM9W1AsTF0uaW5kZXhPZihzKT49MD9cImhlaWdodFwiOlwid2lkdGhcIjtpZihpJiZhKXt2YXIgcD1mdW5jdGlvbihlLHQpe3JldHVybiBZKFwibnVtYmVyXCIhPXR5cGVvZihlPVwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZShPYmplY3QuYXNzaWduKHt9LHQucmVjdHMse3BsYWNlbWVudDp0LnBsYWNlbWVudH0pKTplKT9lOkcoZSxrKSl9KG8ucGFkZGluZyxuKSx1PWcoaSksbD1cInlcIj09PWY/RDpQLGQ9XCJ5XCI9PT1mP0E6TCxoPW4ucmVjdHMucmVmZXJlbmNlW2NdK24ucmVjdHMucmVmZXJlbmNlW2ZdLWFbZl0tbi5yZWN0cy5wb3BwZXJbY10sbT1hW2ZdLW4ucmVjdHMucmVmZXJlbmNlW2ZdLHY9RShpKSx5PXY/XCJ5XCI9PT1mP3YuY2xpZW50SGVpZ2h0fHwwOnYuY2xpZW50V2lkdGh8fDA6MCxiPWgvMi1tLzIseD1wW2xdLHc9eS11W2NdLXBbZF0sTz15LzItdVtjXS8yK2Isaj1kZSh4LE8sdyksTT1mO24ubW9kaWZpZXJzRGF0YVtyXT0oKHQ9e30pW01dPWosdC5jZW50ZXJPZmZzZXQ9ai1PLHQpfX0sZWZmZWN0OmZ1bmN0aW9uKGUpe3ZhciB0PWUuc3RhdGUsbj1lLm9wdGlvbnMuZWxlbWVudCxyPXZvaWQgMD09PW4/XCJbZGF0YS1wb3BwZXItYXJyb3ddXCI6bjtudWxsIT1yJiYoXCJzdHJpbmdcIiE9dHlwZW9mIHJ8fChyPXQuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IocikpKSYmQyh0LmVsZW1lbnRzLnBvcHBlcixyKSYmKHQuZWxlbWVudHMuYXJyb3c9cil9LHJlcXVpcmVzOltcInBvcHBlck9mZnNldHNcIl0scmVxdWlyZXNJZkV4aXN0czpbXCJwcmV2ZW50T3ZlcmZsb3dcIl19O2Z1bmN0aW9uIHZlKGUsdCxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49e3g6MCx5OjB9KSx7dG9wOmUudG9wLXQuaGVpZ2h0LW4ueSxyaWdodDplLnJpZ2h0LXQud2lkdGgrbi54LGJvdHRvbTplLmJvdHRvbS10LmhlaWdodCtuLnksbGVmdDplLmxlZnQtdC53aWR0aC1uLnh9fWZ1bmN0aW9uIHllKGUpe3JldHVybltELEwsQSxQXS5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZVt0XT49MH0pKX12YXIgZ2U9e25hbWU6XCJoaWRlXCIsZW5hYmxlZDohMCxwaGFzZTpcIm1haW5cIixyZXF1aXJlc0lmRXhpc3RzOltcInByZXZlbnRPdmVyZmxvd1wiXSxmbjpmdW5jdGlvbihlKXt2YXIgdD1lLnN0YXRlLG49ZS5uYW1lLHI9dC5yZWN0cy5yZWZlcmVuY2Usbz10LnJlY3RzLnBvcHBlcixpPXQubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3csYT1KKHQse2VsZW1lbnRDb250ZXh0OlwicmVmZXJlbmNlXCJ9KSxzPUoodCx7YWx0Qm91bmRhcnk6ITB9KSxmPXZlKGEsciksYz12ZShzLG8saSkscD15ZShmKSx1PXllKGMpO3QubW9kaWZpZXJzRGF0YVtuXT17cmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOmYscG9wcGVyRXNjYXBlT2Zmc2V0czpjLGlzUmVmZXJlbmNlSGlkZGVuOnAsaGFzUG9wcGVyRXNjYXBlZDp1fSx0LmF0dHJpYnV0ZXMucG9wcGVyPU9iamVjdC5hc3NpZ24oe30sdC5hdHRyaWJ1dGVzLnBvcHBlcix7XCJkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuXCI6cCxcImRhdGEtcG9wcGVyLWVzY2FwZWRcIjp1fSl9fSxiZT1aKHtkZWZhdWx0TW9kaWZpZXJzOltlZSx0ZSxvZSxpZV19KSx4ZT1bZWUsdGUsb2UsaWUsYWUsbGUsaGUsbWUsZ2VdLHdlPVooe2RlZmF1bHRNb2RpZmllcnM6eGV9KTtlLmFwcGx5U3R5bGVzPWllLGUuYXJyb3c9bWUsZS5jb21wdXRlU3R5bGVzPW9lLGUuY3JlYXRlUG9wcGVyPXdlLGUuY3JlYXRlUG9wcGVyTGl0ZT1iZSxlLmRlZmF1bHRNb2RpZmllcnM9eGUsZS5kZXRlY3RPdmVyZmxvdz1KLGUuZXZlbnRMaXN0ZW5lcnM9ZWUsZS5mbGlwPWxlLGUuaGlkZT1nZSxlLm9mZnNldD1hZSxlLnBvcHBlckdlbmVyYXRvcj1aLGUucG9wcGVyT2Zmc2V0cz10ZSxlLnByZXZlbnRPdmVyZmxvdz1oZSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5taW4uanMubWFwIiwiLyohXG4gKiBAc3BsaWRlanMvc3BsaWRlLWV4dGVuc2lvbi1ncmlkXG4gKiBWZXJzaW9uICA6IDAuNC4xXG4gKiBMaWNlbnNlICA6IE1JVFxuICogQ29weXJpZ2h0OiAyMDIyIE5hb3Rvc2hpIEZ1aml0YVxuKi8oZnVuY3Rpb24oTyl7dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kP2RlZmluZShPKTpPKCl9KShmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIE8obil7bi5sZW5ndGg9MH1mdW5jdGlvbiBTKG4sdCxpKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobix0LGkpfWZ1bmN0aW9uIFQobil7cmV0dXJuIG4uYmluZC5hcHBseShuLFtudWxsXS5jb25jYXQoUyhhcmd1bWVudHMsMSkpKX1mdW5jdGlvbiBWKG4sdCl7cmV0dXJuIHR5cGVvZiB0PT09bn12YXIgUT1BcnJheS5pc0FycmF5O1QoVixcImZ1bmN0aW9uXCIpLFQoVixcInN0cmluZ1wiKSxUKFYsXCJ1bmRlZmluZWRcIik7ZnVuY3Rpb24gWChuKXtyZXR1cm4gUShuKT9uOltuXX1mdW5jdGlvbiBaKG4sdCl7WChuKS5mb3JFYWNoKHQpfXZhciBobj1PYmplY3Qua2V5cztmdW5jdGlvbiBFbihuLHQsaSl7aWYobil7dmFyIHI9aG4obik7cj1pP3IucmV2ZXJzZSgpOnI7Zm9yKHZhciBmPTA7ZjxyLmxlbmd0aDtmKyspe3ZhciBhPXJbZl07aWYoYSE9PVwiX19wcm90b19fXCImJnQoblthXSxhKT09PSExKWJyZWFrfX1yZXR1cm4gbn1mdW5jdGlvbiBnbihuKXtyZXR1cm4gUyhhcmd1bWVudHMsMSkuZm9yRWFjaChmdW5jdGlvbih0KXtFbih0LGZ1bmN0aW9uKGkscil7bltyXT10W3JdfSl9KSxufXZhciBqPVwic3BsaWRlXCI7ZnVuY3Rpb24gbW4oKXt2YXIgbj1bXTtmdW5jdGlvbiB0KHUsYyxsLHYpe2YodSxjLGZ1bmN0aW9uKGQsZyxtKXt2YXIgXz1cImFkZEV2ZW50TGlzdGVuZXJcImluIGQsQz1fP2QucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKGQsZyxsLHYpOmQucmVtb3ZlTGlzdGVuZXIuYmluZChkLGwpO18/ZC5hZGRFdmVudExpc3RlbmVyKGcsbCx2KTpkLmFkZExpc3RlbmVyKGwpLG4ucHVzaChbZCxnLG0sbCxDXSl9KX1mdW5jdGlvbiBpKHUsYyxsKXtmKHUsYyxmdW5jdGlvbih2LGQsZyl7bj1uLmZpbHRlcihmdW5jdGlvbihtKXtyZXR1cm4gbVswXT09PXYmJm1bMV09PT1kJiZtWzJdPT09ZyYmKCFsfHxtWzNdPT09bCk/KG1bNF0oKSwhMSk6ITB9KX0pfWZ1bmN0aW9uIHIodSxjLGwpe3ZhciB2LGQ9ITA7cmV0dXJuIHR5cGVvZiBDdXN0b21FdmVudD09XCJmdW5jdGlvblwiP3Y9bmV3IEN1c3RvbUV2ZW50KGMse2J1YmJsZXM6ZCxkZXRhaWw6bH0pOih2PWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIiksdi5pbml0Q3VzdG9tRXZlbnQoYyxkLCExLGwpKSx1LmRpc3BhdGNoRXZlbnQodiksdn1mdW5jdGlvbiBmKHUsYyxsKXtaKHUsZnVuY3Rpb24odil7diYmWihjLGZ1bmN0aW9uKGQpe2Quc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oZyl7dmFyIG09Zy5zcGxpdChcIi5cIik7bCh2LG1bMF0sbVsxXSl9KX0pfSl9ZnVuY3Rpb24gYSgpe24uZm9yRWFjaChmdW5jdGlvbih1KXt1WzRdKCl9KSxPKG4pfXJldHVybntiaW5kOnQsdW5iaW5kOmksZGlzcGF0Y2g6cixkZXN0cm95OmF9fXZhciBwbj1cInZpc2libGVcIix5bj1cImhpZGRlblwiLEg9XCJyZWZyZXNoXCIsd249XCJ1cGRhdGVkXCIsX249XCJkZXN0cm95XCI7ZnVuY3Rpb24gayhuKXt2YXIgdD1uP24uZXZlbnQuYnVzOmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxpPW1uKCk7ZnVuY3Rpb24gcihhLHUpe2kuYmluZCh0LFgoYSkuam9pbihcIiBcIiksZnVuY3Rpb24oYyl7dS5hcHBseSh1LFEoYy5kZXRhaWwpP2MuZGV0YWlsOltdKX0pfWZ1bmN0aW9uIGYoYSl7aS5kaXNwYXRjaCh0LGEsUyhhcmd1bWVudHMsMSkpfXJldHVybiBuJiZuLmV2ZW50Lm9uKF9uLGkuZGVzdHJveSksZ24oaSx7YnVzOnQsb246cixvZmY6VChpLnVuYmluZCx0KSxlbWl0OmZ9KX12YXIgQ249aiwkPWorXCJfX3NsaWRlXCIsQW49JCtcIl9fY29udGFpbmVyXCI7ZnVuY3Rpb24gbm4obil7bi5sZW5ndGg9MH1mdW5jdGlvbiBJKG4sdCxpKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobix0LGkpfWZ1bmN0aW9uIEIobil7cmV0dXJuIG4uYmluZC5hcHBseShuLFtudWxsXS5jb25jYXQoSShhcmd1bWVudHMsMSkpKX1mdW5jdGlvbiBOKG4sdCl7cmV0dXJuIHR5cGVvZiB0PT09bn1mdW5jdGlvbiBibihuKXtyZXR1cm4hUChuKSYmTihcIm9iamVjdFwiLG4pfXZhciBGPUFycmF5LmlzQXJyYXk7QihOLFwiZnVuY3Rpb25cIik7dmFyIEc9QihOLFwic3RyaW5nXCIpLExuPUIoTixcInVuZGVmaW5lZFwiKTtmdW5jdGlvbiBQKG4pe3JldHVybiBuPT09bnVsbH1mdW5jdGlvbiBEbihuKXtyZXR1cm4gbiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50fWZ1bmN0aW9uIFUobil7cmV0dXJuIEYobik/bjpbbl19ZnVuY3Rpb24gQShuLHQpe1UobikuZm9yRWFjaCh0KX1mdW5jdGlvbiB0bihuLHQpe3JldHVybiBuLnB1c2guYXBwbHkobixVKHQpKSxufWZ1bmN0aW9uIHJuKG4sdCxpKXtuJiZBKHQsZnVuY3Rpb24ocil7ciYmbi5jbGFzc0xpc3RbaT9cImFkZFwiOlwicmVtb3ZlXCJdKHIpfSl9ZnVuY3Rpb24gcShuLHQpe3JuKG4sRyh0KT90LnNwbGl0KFwiIFwiKTp0LCEwKX1mdW5jdGlvbiBSKG4sdCl7QSh0LG4uYXBwZW5kQ2hpbGQuYmluZChuKSl9ZnVuY3Rpb24gT24obix0KXtyZXR1cm4gRG4obikmJihuLm1zTWF0Y2hlc1NlbGVjdG9yfHxuLm1hdGNoZXMpLmNhbGwobix0KX1mdW5jdGlvbiBUbihuLHQpe3ZhciBpPW4/SShuLmNoaWxkcmVuKTpbXTtyZXR1cm4gdD9pLmZpbHRlcihmdW5jdGlvbihyKXtyZXR1cm4gT24ocix0KX0pOml9ZnVuY3Rpb24gb24obix0KXtyZXR1cm4gdD9UbihuLHQpWzBdOm4uZmlyc3RFbGVtZW50Q2hpbGR9dmFyIGVuPU9iamVjdC5rZXlzO2Z1bmN0aW9uIHVuKG4sdCxpKXtpZihuKXt2YXIgcj1lbihuKTtyPWk/ci5yZXZlcnNlKCk6cjtmb3IodmFyIGY9MDtmPHIubGVuZ3RoO2YrKyl7dmFyIGE9cltmXTtpZihhIT09XCJfX3Byb3RvX19cIiYmdChuW2FdLGEpPT09ITEpYnJlYWt9fXJldHVybiBufWZ1bmN0aW9uICRuKG4pe3JldHVybiBJKGFyZ3VtZW50cywxKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3VuKHQsZnVuY3Rpb24oaSxyKXtuW3JdPXRbcl19KX0pLG59ZnVuY3Rpb24gSW4obix0KXtVKHR8fGVuKG4pKS5mb3JFYWNoKGZ1bmN0aW9uKGkpe2RlbGV0ZSBuW2ldfSl9ZnVuY3Rpb24gSihuLHQpe0EobixmdW5jdGlvbihpKXtBKHQsZnVuY3Rpb24ocil7aSYmaS5yZW1vdmVBdHRyaWJ1dGUocil9KX0pfWZ1bmN0aW9uIEsobix0LGkpe2JuKHQpP3VuKHQsZnVuY3Rpb24ocixmKXtLKG4sZixyKX0pOkEobixmdW5jdGlvbihyKXtQKGkpfHxpPT09XCJcIj9KKHIsdCk6ci5zZXRBdHRyaWJ1dGUodCxTdHJpbmcoaSkpfSl9ZnVuY3Rpb24gZm4obix0LGkpe3ZhciByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobik7cmV0dXJuIHQmJihHKHQpP3Eocix0KTpLKHIsdCkpLGkmJlIoaSxyKSxyfWZ1bmN0aW9uIHAobix0LGkpe2lmKExuKGkpKXJldHVybiBnZXRDb21wdXRlZFN0eWxlKG4pW3RdO1AoaSl8fChuLnN0eWxlW3RdPVwiXCIraSl9ZnVuY3Rpb24gTm4obix0KXtyZXR1cm4gbiYmbi5jbGFzc0xpc3QuY29udGFpbnModCl9ZnVuY3Rpb24gUm4obil7QShuLGZ1bmN0aW9uKHQpe3QmJnQucGFyZW50Tm9kZSYmdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpfSl9ZnVuY3Rpb24gYW4obix0KXtyZXR1cm4gdD9JKG4ucXVlcnlTZWxlY3RvckFsbCh0KSk6W119ZnVuY3Rpb24gY24obix0KXtybihuLHQsITEpfWZ1bmN0aW9uIHgobil7cmV0dXJuIEcobik/bjpuP24rXCJweFwiOlwiXCJ9dmFyIHhuPVwic3BsaWRlXCI7ZnVuY3Rpb24gTW4obix0KXtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJbXCIreG4rXCJdIFwiKyh0fHxcIlwiKSl9dmFyIFNuPU1hdGgubWluLFVuPU1hdGgubWF4LHFuPU1hdGguZmxvb3IsSm49TWF0aC5jZWlsLEtuPU1hdGguYWJzO2Z1bmN0aW9uIFZuKG4pe3JldHVybiBuPDEwP1wiMFwiK246XCJcIitufXZhciBzbj0kK1wiX19yb3dcIix6PSQrXCItLWNvbFwiLEhuPXtyb3dzOjEsY29sczoxLGRpbWVuc2lvbnM6W10sZ2FwOnt9fTtmdW5jdGlvbiBCbihuKXtmdW5jdGlvbiB0KCl7dmFyIGY9bi5yb3dzLGE9bi5jb2xzLHU9bi5kaW1lbnNpb25zO3JldHVybiBGKHUpJiZ1Lmxlbmd0aD91OltbZixhXV19ZnVuY3Rpb24gaShmKXt2YXIgYT10KCk7cmV0dXJuIGFbU24oZixhLmxlbmd0aC0xKV19ZnVuY3Rpb24gcihmKXtmb3IodmFyIGE9dCgpLHUsYyxsPTAsdj0wO3Y8YS5sZW5ndGg7disrKXt2YXIgZD1hW3ZdO2lmKHU9ZFswXXx8MSxjPWRbMV18fDEsbCs9dSpjLGY8bClicmVha31yZXR1cm4gTW4odSYmYyxcIkludmFsaWQgZGltZW5zaW9uXCIpLFt1LGNdfXJldHVybntnZXQ6aSxnZXRBdDpyfX1mdW5jdGlvbiBGbihuLHQsaSl7dmFyIHI9ayhuKSxmPXIub24sYT1yLmRlc3Ryb3ksdT1uLkNvbXBvbmVudHMsYz1uLm9wdGlvbnMsbD11LkRpcmVjdGlvbi5yZXNvbHZlLHY9dS5TbGlkZXMuZm9yRWFjaDtmdW5jdGlvbiBkKCl7bSgpLGMuc2xpZGVGb2N1cyYmKGYocG4sVyksZih5bixZKSl9ZnVuY3Rpb24gZygpe3YoZnVuY3Rpb24oZSl7dmFyIHM9ZS5zbGlkZTtEKHMsITEpLE0ocykuZm9yRWFjaChmdW5jdGlvbihvKXtKKG8sXCJzdHlsZVwiKX0pLGIocykuZm9yRWFjaChmdW5jdGlvbihvKXtMKG8sITApLEoobyxcInN0eWxlXCIpfSl9KSxhKCl9ZnVuY3Rpb24gbSgpe3YoZnVuY3Rpb24oZSl7dmFyIHM9ZS5zbGlkZSxvPWkuZ2V0KGUuaXNDbG9uZT9lLnNsaWRlSW5kZXg6ZS5pbmRleCksaD1vWzBdLEU9b1sxXTtfKGgscyksQyhFLHMpLGIoZS5zbGlkZSkuZm9yRWFjaChmdW5jdGlvbih5LHcpe3kuaWQ9ZS5zbGlkZS5pZCtcIi1jb2xcIitWbih3KzEpLG4ub3B0aW9ucy5jb3ZlciYmTCh5KX0pfSl9ZnVuY3Rpb24gXyhlLHMpe3ZhciBvPXQuZ2FwLnJvdyxoPVwiY2FsYyhcIisxMDAvZStcIiVcIisobz9cIiAtIFwiK3gobykrXCIgKiBcIisoZS0xKS9lOlwiXCIpK1wiKVwiO00ocykuZm9yRWFjaChmdW5jdGlvbihFLHksdyl7cChFLFwiaGVpZ2h0XCIsaCkscChFLFwiZGlzcGxheVwiLFwiZmxleFwiKSxwKEUsXCJtYXJnaW5cIixcIjAgMCBcIit4KG8pK1wiIDBcIikscChFLFwicGFkZGluZ1wiLDApLHk9PT13Lmxlbmd0aC0xJiZwKEUsXCJtYXJnaW5Cb3R0b21cIiwwKX0pfWZ1bmN0aW9uIEMoZSxzKXt2YXIgbz10LmdhcC5jb2wsaD1cImNhbGMoXCIrMTAwL2UrXCIlXCIrKG8/XCIgLSBcIit4KG8pK1wiICogXCIrKGUtMSkvZTpcIlwiKStcIilcIjtiKHMpLmZvckVhY2goZnVuY3Rpb24oRSx5LHcpe3AoRSxcIndpZHRoXCIsaCkseSE9PXcubGVuZ3RoLTEmJnAoRSxsKFwibWFyZ2luUmlnaHRcIikseChvKSl9KX1mdW5jdGlvbiBMKGUscyl7dmFyIG89b24oZSxcIi5cIitBbiksaD1vbihvfHxlLFwiaW1nXCIpO2gmJmguc3JjJiYocChvfHxlLFwiYmFja2dyb3VuZFwiLHM/XCJcIjonY2VudGVyL2NvdmVyIG5vLXJlcGVhdCB1cmwoXCInK2guc3JjKydcIiknKSxwKGgsXCJkaXNwbGF5XCIscz9cIlwiOlwibm9uZVwiKSl9ZnVuY3Rpb24gTShlKXtyZXR1cm4gYW4oZSxcIi5cIitzbil9ZnVuY3Rpb24gYihlKXtyZXR1cm4gYW4oZSxcIi5cIit6KX1mdW5jdGlvbiBEKGUscyl7YihlKS5mb3JFYWNoKGZ1bmN0aW9uKG8pe0sobyxcInRhYmluZGV4XCIscz8wOm51bGwpfSl9ZnVuY3Rpb24gVyhlKXtEKGUuc2xpZGUsITApfWZ1bmN0aW9uIFkoZSl7RChlLnNsaWRlLCExKX1yZXR1cm57bW91bnQ6ZCxkZXN0cm95Omd9fWZ1bmN0aW9uIEduKG4sdCxpKXt2YXIgcj1rKG4pLGY9ci5vbixhPXIub2ZmLHU9dC5FbGVtZW50cyxjPXt9LGw9Qm4oYyksdj1GbihuLGMsbCksZD1DbitcIi0tZ3JpZFwiLGc9W107ZnVuY3Rpb24gbSgpe18oKSxmKHduLF8pfWZ1bmN0aW9uIF8oKXtJbihjKSwkbihjLEhuLGkuZ3JpZHx8e30pLFkoKT8oQygpLHRuKGcsdS5zbGlkZXMpLHEobi5yb290LGQpLFIodS5saXN0LGIoKSksYShIKSxmKEgsTSksTCgpKTplKCkmJihDKCksTCgpKX1mdW5jdGlvbiBDKCl7aWYoZSgpKXt2YXIgcz11LnNsaWRlczt2LmRlc3Ryb3koKSxnLmZvckVhY2goZnVuY3Rpb24obyl7Y24obyx6KSxSKHUubGlzdCxvKX0pLFJuKHMpLGNuKG4ucm9vdCxkKSxubihzKSx0bihzLGcpLG5uKGcpLGEoSCl9fWZ1bmN0aW9uIEwoKXtuLnJlZnJlc2goKX1mdW5jdGlvbiBNKCl7ZSgpJiZ2Lm1vdW50KCl9ZnVuY3Rpb24gYigpe3ZhciBzPVtdLG89MCxoPTAsRSx5O3JldHVybiBnLmZvckVhY2goZnVuY3Rpb24odyxQbil7dmFyIGRuPWwuZ2V0QXQoUG4pLHZuPWRuWzBdLGxuPWRuWzFdO2h8fChvfHwoRT1mbih3LnRhZ05hbWUsJCkscy5wdXNoKEUpKSx5PUQodm4sdyxFKSksVyhsbix3LHkpLCsraD49bG4mJihoPTAsbz0rK28+PXZuPzA6byl9KSxzfWZ1bmN0aW9uIEQocyxvLGgpe3ZhciBFPW8udGFnTmFtZS50b0xvd2VyQ2FzZSgpPT09XCJsaVwiP1widWxcIjpcImRpdlwiO3JldHVybiBmbihFLHNuLGgpfWZ1bmN0aW9uIFcocyxvLGgpe3JldHVybiBxKG8seiksUihoLG8pLG99ZnVuY3Rpb24gWSgpe2lmKGkuZ3JpZCl7dmFyIHM9Yy5yb3dzLG89Yy5jb2xzLGg9Yy5kaW1lbnNpb25zO3JldHVybiBzPjF8fG8+MXx8RihoKSYmaC5sZW5ndGg+MH1yZXR1cm4hMX1mdW5jdGlvbiBlKCl7cmV0dXJuIE5uKG4ucm9vdCxkKX1yZXR1cm57bW91bnQ6bSxkZXN0cm95OkN9fXR5cGVvZiB3aW5kb3c8XCJ1XCImJih3aW5kb3cuc3BsaWRlPXdpbmRvdy5zcGxpZGV8fHt9LHdpbmRvdy5zcGxpZGUuRXh0ZW5zaW9ucz13aW5kb3cuc3BsaWRlLkV4dGVuc2lvbnN8fHt9LHdpbmRvdy5zcGxpZGUuRXh0ZW5zaW9ucy5HcmlkPUduKX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BsaWRlLWV4dGVuc2lvbi1ncmlkLm1pbi5qcy5tYXAiLCJmdW5jdGlvbiByKG4sdCl7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspe3ZhciByPXRbaV07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLHIua2V5LHIpfX1mdW5jdGlvbiBKdChuLHQsaSl7dCYmcihuLnByb3RvdHlwZSx0KSxpJiZyKG4saSksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KX1cbi8qIVxuICogU3BsaWRlLmpzXG4gKiBWZXJzaW9uICA6IDQuMS40XG4gKiBMaWNlbnNlICA6IE1JVFxuICogQ29weXJpZ2h0OiAyMDIyIE5hb3Rvc2hpIEZ1aml0YVxuICovXG52YXIgbix0O249dGhpcyx0PWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHY9XCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiLEc9NCxybj01LHI9e0NSRUFURUQ6MSxNT1VOVEVEOjIsSURMRTozLE1PVklORzpHLFNDUk9MTElORzpybixEUkFHR0lORzo2LERFU1RST1lFRDo3fTtmdW5jdGlvbiBEKG4pe24ubGVuZ3RoPTB9ZnVuY3Rpb24gbyhuLHQsaSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4sdCxpKX1mdW5jdGlvbiBSKG4pe3JldHVybiBuLmJpbmQuYXBwbHkobixbbnVsbF0uY29uY2F0KG8oYXJndW1lbnRzLDEpKSl9ZnVuY3Rpb24gb24oKXt9dmFyIHA9c2V0VGltZW91dDtmdW5jdGlvbiBoKG4pe3JldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobil9ZnVuY3Rpb24gdShuLHQpe3JldHVybiB0eXBlb2YgdD09PW59ZnVuY3Rpb24gdW4obil7cmV0dXJuIWMobikmJnUoXCJvYmplY3RcIixuKX12YXIgZT1BcnJheS5pc0FycmF5LHg9Uih1LFwiZnVuY3Rpb25cIiksQz1SKHUsXCJzdHJpbmdcIiksZW49Uih1LFwidW5kZWZpbmVkXCIpO2Z1bmN0aW9uIGMobil7cmV0dXJuIG51bGw9PT1ufWZ1bmN0aW9uIG0obil7dHJ5e3JldHVybiBuIGluc3RhbmNlb2Yobi5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3fHx3aW5kb3cpLkhUTUxFbGVtZW50fWNhdGNoKG4pe3JldHVybiExfX1mdW5jdGlvbiB5KG4pe3JldHVybiBlKG4pP246W25dfWZ1bmN0aW9uIGcobix0KXt5KG4pLmZvckVhY2godCl9ZnVuY3Rpb24gYihuLHQpe3JldHVybi0xPG4uaW5kZXhPZih0KX1mdW5jdGlvbiBrKG4sdCl7cmV0dXJuIG4ucHVzaC5hcHBseShuLHkodCkpLG59ZnVuY3Rpb24gQSh0LG4saSl7dCYmZyhuLGZ1bmN0aW9uKG4pe24mJnQuY2xhc3NMaXN0W2k/XCJhZGRcIjpcInJlbW92ZVwiXShuKX0pfWZ1bmN0aW9uIE0obix0KXtBKG4sQyh0KT90LnNwbGl0KFwiIFwiKTp0LCEwKX1mdW5jdGlvbiBMKG4sdCl7Zyh0LG4uYXBwZW5kQ2hpbGQuYmluZChuKSl9ZnVuY3Rpb24gTyhuLGkpe2cobixmdW5jdGlvbihuKXt2YXIgdD0oaXx8bikucGFyZW50Tm9kZTt0JiZ0Lmluc2VydEJlZm9yZShuLGkpfSl9ZnVuY3Rpb24gY24obix0KXtyZXR1cm4gbShuKSYmKG4ubXNNYXRjaGVzU2VsZWN0b3J8fG4ubWF0Y2hlcykuY2FsbChuLHQpfWZ1bmN0aW9uIFMobix0KXtuPW4/byhuLmNoaWxkcmVuKTpbXTtyZXR1cm4gdD9uLmZpbHRlcihmdW5jdGlvbihuKXtyZXR1cm4gY24obix0KX0pOm59ZnVuY3Rpb24gZm4obix0KXtyZXR1cm4gdD9TKG4sdClbMF06bi5maXJzdEVsZW1lbnRDaGlsZH12YXIgRT1PYmplY3Qua2V5cztmdW5jdGlvbiB3KHQsaSxuKXt0JiYobj9FKHQpLnJldmVyc2UoKTpFKHQpKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe1wiX19wcm90b19fXCIhPT1uJiZpKHRbbl0sbil9KX1mdW5jdGlvbiBhbihyKXtyZXR1cm4gbyhhcmd1bWVudHMsMSkuZm9yRWFjaChmdW5jdGlvbihpKXt3KGksZnVuY3Rpb24obix0KXtyW3RdPWlbdF19KX0pLHJ9ZnVuY3Rpb24gZChpKXtyZXR1cm4gbyhhcmd1bWVudHMsMSkuZm9yRWFjaChmdW5jdGlvbihuKXt3KG4sZnVuY3Rpb24obix0KXtlKG4pP2lbdF09bi5zbGljZSgpOnVuKG4pP2lbdF09ZCh7fSx1bihpW3RdKT9pW3RdOnt9LG4pOmlbdF09bn0pfSksaX1mdW5jdGlvbiBzbih0LG4pe2cobnx8RSh0KSxmdW5jdGlvbihuKXtkZWxldGUgdFtuXX0pfWZ1bmN0aW9uIFAobixpKXtnKG4sZnVuY3Rpb24odCl7ZyhpLGZ1bmN0aW9uKG4pe3QmJnQucmVtb3ZlQXR0cmlidXRlKG4pfSl9KX1mdW5jdGlvbiBJKGksdCxyKXt1bih0KT93KHQsZnVuY3Rpb24obix0KXtJKGksdCxuKX0pOmcoaSxmdW5jdGlvbihuKXtjKHIpfHxcIlwiPT09cj9QKG4sdCk6bi5zZXRBdHRyaWJ1dGUodCxTdHJpbmcocikpfSl9ZnVuY3Rpb24gaihuLHQsaSl7bj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KG4pO3JldHVybiB0JiYoQyh0KT9NOkkpKG4sdCksaSYmTChpLG4pLG59ZnVuY3Rpb24gXyhuLHQsaSl7aWYoZW4oaSkpcmV0dXJuIGdldENvbXB1dGVkU3R5bGUobilbdF07YyhpKXx8KG4uc3R5bGVbdF09XCJcIitpKX1mdW5jdGlvbiBsbihuLHQpe18obixcImRpc3BsYXlcIix0KX1mdW5jdGlvbiBkbihuKXtuLnNldEFjdGl2ZSYmbi5zZXRBY3RpdmUoKXx8bi5mb2N1cyh7cHJldmVudFNjcm9sbDohMH0pfWZ1bmN0aW9uIHoobix0KXtyZXR1cm4gbi5nZXRBdHRyaWJ1dGUodCl9ZnVuY3Rpb24gdm4obix0KXtyZXR1cm4gbiYmbi5jbGFzc0xpc3QuY29udGFpbnModCl9ZnVuY3Rpb24gTihuKXtyZXR1cm4gbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKX1mdW5jdGlvbiBUKG4pe2cobixmdW5jdGlvbihuKXtuJiZuLnBhcmVudE5vZGUmJm4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKX0pfWZ1bmN0aW9uIGhuKG4pe3JldHVybiBmbigobmV3IERPTVBhcnNlcikucGFyc2VGcm9tU3RyaW5nKG4sXCJ0ZXh0L2h0bWxcIikuYm9keSl9ZnVuY3Rpb24gRihuLHQpe24ucHJldmVudERlZmF1bHQoKSx0JiYobi5zdG9wUHJvcGFnYXRpb24oKSxuLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpKX1mdW5jdGlvbiBwbihuLHQpe3JldHVybiBuJiZuLnF1ZXJ5U2VsZWN0b3IodCl9ZnVuY3Rpb24gZ24obix0KXtyZXR1cm4gdD9vKG4ucXVlcnlTZWxlY3RvckFsbCh0KSk6W119ZnVuY3Rpb24gWChuLHQpe0Eobix0LCExKX1mdW5jdGlvbiBtbihuKXtyZXR1cm4gbi50aW1lU3RhbXB9ZnVuY3Rpb24gVyhuKXtyZXR1cm4gQyhuKT9uOm4/bitcInB4XCI6XCJcIn12YXIgeW49XCJzcGxpZGVcIixmPVwiZGF0YS1cIit5bjtmdW5jdGlvbiBibihuLHQpe2lmKCFuKXRocm93IG5ldyBFcnJvcihcIltcIit5bitcIl0gXCIrKHR8fFwiXCIpKX12YXIgWT1NYXRoLm1pbix3bj1NYXRoLm1heCx4bj1NYXRoLmZsb29yLGtuPU1hdGguY2VpbCxVPU1hdGguYWJzO2Z1bmN0aW9uIFNuKG4sdCxpKXtyZXR1cm4gVShuLXQpPGl9ZnVuY3Rpb24gRW4obix0LGkscil7dmFyIG89WSh0LGkpLHQ9d24odCxpKTtyZXR1cm4gcj9vPG4mJm48dDpvPD1uJiZuPD10fWZ1bmN0aW9uIHEobix0LGkpe3ZhciByPVkodCxpKSx0PXduKHQsaSk7cmV0dXJuIFkod24ocixuKSx0KX1mdW5jdGlvbiBMbihuKXtyZXR1cm4oMDxuKS0objwwKX1mdW5jdGlvbiBPbih0LG4pe3JldHVybiBnKG4sZnVuY3Rpb24obil7dD10LnJlcGxhY2UoXCIlc1wiLFwiXCIrbil9KSx0fWZ1bmN0aW9uIEFuKG4pe3JldHVybiBuPDEwP1wiMFwiK246XCJcIitufXZhciBfbj17fTtmdW5jdGlvbiB6bigpe3ZhciBjPVtdO2Z1bmN0aW9uIGkobixpLHIpe2cobixmdW5jdGlvbih0KXt0JiZnKGksZnVuY3Rpb24obil7bi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihuKXtuPW4uc3BsaXQoXCIuXCIpO3IodCxuWzBdLG5bMV0pfSl9KX0pfXJldHVybntiaW5kOmZ1bmN0aW9uKG4sdCx1LGUpe2kobix0LGZ1bmN0aW9uKG4sdCxpKXt2YXIgcj1cImFkZEV2ZW50TGlzdGVuZXJcImluIG4sbz1yP24ucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKG4sdCx1LGUpOm4ucmVtb3ZlTGlzdGVuZXIuYmluZChuLHUpO3I/bi5hZGRFdmVudExpc3RlbmVyKHQsdSxlKTpuLmFkZExpc3RlbmVyKHUpLGMucHVzaChbbix0LGksdSxvXSl9KX0sdW5iaW5kOmZ1bmN0aW9uKG4sdCxvKXtpKG4sdCxmdW5jdGlvbih0LGkscil7Yz1jLmZpbHRlcihmdW5jdGlvbihuKXtyZXR1cm4hIShuWzBdIT09dHx8blsxXSE9PWl8fG5bMl0hPT1yfHxvJiZuWzNdIT09byl8fChuWzRdKCksITEpfSl9KX0sZGlzcGF0Y2g6ZnVuY3Rpb24obix0LGkpe3ZhciByO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIEN1c3RvbUV2ZW50P3I9bmV3IEN1c3RvbUV2ZW50KHQse2J1YmJsZXM6ITAsZGV0YWlsOml9KToocj1kb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpKS5pbml0Q3VzdG9tRXZlbnQodCwhMCwhMSxpKSxuLmRpc3BhdGNoRXZlbnQocikscn0sZGVzdHJveTpmdW5jdGlvbigpe2MuZm9yRWFjaChmdW5jdGlvbihuKXtuWzRdKCl9KSxEKGMpfX19dmFyIEI9XCJtb3VudGVkXCIsSD1cIm1vdmVcIixEbj1cIm1vdmVkXCIsTW49XCJjbGlja1wiLFBuPVwiYWN0aXZlXCIsSW49XCJpbmFjdGl2ZVwiLFJuPVwidmlzaWJsZVwiLENuPVwiaGlkZGVuXCIsSj1cInJlZnJlc2hcIixLPVwidXBkYXRlZFwiLGpuPVwicmVzaXplXCIsTm49XCJyZXNpemVkXCIsVG49XCJzY3JvbGxcIixWPVwic2Nyb2xsZWRcIixhPVwiZGVzdHJveVwiLEduPVwibmF2aWdhdGlvbjptb3VudGVkXCIsRm49XCJhdXRvcGxheTpwbGF5XCIsWG49XCJhdXRvcGxheTpwYXVzZVwiLFduPVwibGF6eWxvYWQ6bG9hZGVkXCIsWW49XCJza1wiLFVuPVwic2hcIjtmdW5jdGlvbiBRKG4pe3ZhciBpPW4/bi5ldmVudC5idXM6ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLHI9em4oKTtyZXR1cm4gbiYmbi5ldmVudC5vbihhLHIuZGVzdHJveSksYW4ocix7YnVzOmksb246ZnVuY3Rpb24obix0KXtyLmJpbmQoaSx5KG4pLmpvaW4oXCIgXCIpLGZ1bmN0aW9uKG4pe3QuYXBwbHkodCxlKG4uZGV0YWlsKT9uLmRldGFpbDpbXSl9KX0sb2ZmOlIoci51bmJpbmQsaSksZW1pdDpmdW5jdGlvbihuKXtyLmRpc3BhdGNoKGksbixvKGFyZ3VtZW50cywxKSl9fSl9ZnVuY3Rpb24gcW4odCxuLGkscil7dmFyIG8sdSxlPURhdGUubm93LGM9MCxmPSEwLGE9MDtmdW5jdGlvbiBzKCl7aWYoIWYpe2lmKGM9dD9ZKChlKCktbykvdCwxKToxLGkmJmkoYyksMTw9YyYmKG4oKSxvPWUoKSxyJiYrK2E+PXIpKXJldHVybiBsKCk7dT1oKHMpfX1mdW5jdGlvbiBsKCl7Zj0hMH1mdW5jdGlvbiBkKCl7dSYmY2FuY2VsQW5pbWF0aW9uRnJhbWUodSksZj0hKHU9Yz0wKX1yZXR1cm57c3RhcnQ6ZnVuY3Rpb24obil7bnx8ZCgpLG89ZSgpLShuP2MqdDowKSxmPSExLHU9aChzKX0scmV3aW5kOmZ1bmN0aW9uKCl7bz1lKCksYz0wLGkmJmkoYyl9LHBhdXNlOmwsY2FuY2VsOmQsc2V0OmZ1bmN0aW9uKG4pe3Q9bn0saXNQYXVzZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gZn19fWZ1bmN0aW9uIHMobil7dmFyIHQ9bjtyZXR1cm57c2V0OmZ1bmN0aW9uKG4pe3Q9bn0saXM6ZnVuY3Rpb24obil7cmV0dXJuIGIoeShuKSx0KX19fXZhciBuPVwiQXJyb3dcIixCbj1uK1wiTGVmdFwiLEhuPW4rXCJSaWdodFwiLHQ9bitcIlVwXCIsbj1uK1wiRG93blwiLEpuPVwidHRiXCIsbD17d2lkdGg6W1wiaGVpZ2h0XCJdLGxlZnQ6W1widG9wXCIsXCJyaWdodFwiXSxyaWdodDpbXCJib3R0b21cIixcImxlZnRcIl0seDpbXCJ5XCJdLFg6W1wiWVwiXSxZOltcIlhcIl0sQXJyb3dMZWZ0Olt0LEhuXSxBcnJvd1JpZ2h0OltuLEJuXX07dmFyIFo9XCJyb2xlXCIsJD1cInRhYmluZGV4XCIsaT1cImFyaWEtXCIsS249aStcImNvbnRyb2xzXCIsVm49aStcImN1cnJlbnRcIixRbj1pK1wic2VsZWN0ZWRcIixubj1pK1wibGFiZWxcIixabj1pK1wibGFiZWxsZWRieVwiLCRuPWkrXCJoaWRkZW5cIixudD1pK1wib3JpZW50YXRpb25cIix0dD1pK1wicm9sZWRlc2NyaXB0aW9uXCIsaXQ9aStcImxpdmVcIixydD1pK1wiYnVzeVwiLG90PWkrXCJhdG9taWNcIix1dD1bWiwkLFwiZGlzYWJsZWRcIixLbixWbixubixabiwkbixudCx0dF0saT15bitcIl9fXCIsZXQ9eW4sY3Q9aStcInRyYWNrXCIsZnQ9aStcImxpc3RcIixhdD1pK1wic2xpZGVcIixzdD1hdCtcIi0tY2xvbmVcIixsdD1hdCtcIl9fY29udGFpbmVyXCIsZHQ9aStcImFycm93c1wiLHZ0PWkrXCJhcnJvd1wiLGh0PXZ0K1wiLS1wcmV2XCIscHQ9dnQrXCItLW5leHRcIixndD1pK1wicGFnaW5hdGlvblwiLG10PWd0K1wiX19wYWdlXCIseXQ9aStcInByb2dyZXNzXCIrXCJfX2JhclwiLGJ0PWkrXCJ0b2dnbGVcIix3dD1pK1wic3JcIix0bj1cImlzLWFjdGl2ZVwiLHh0PVwiaXMtcHJldlwiLGt0PVwiaXMtbmV4dFwiLFN0PVwiaXMtdmlzaWJsZVwiLEV0PVwiaXMtbG9hZGluZ1wiLEx0PVwiaXMtZm9jdXMtaW5cIixPdD1cImlzLW92ZXJmbG93XCIsQXQ9W3RuLFN0LHh0LGt0LEV0LEx0LE90XTt2YXIgX3Q9XCJ0b3VjaHN0YXJ0IG1vdXNlZG93blwiLHp0PVwidG91Y2htb3ZlIG1vdXNlbW92ZVwiLER0PVwidG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2V1cCBjbGlja1wiO3ZhciBNdD1cInNsaWRlXCIsUHQ9XCJsb29wXCIsSXQ9XCJmYWRlXCI7ZnVuY3Rpb24gUnQobyxyLHQsdSl7dmFyIGUsbj1RKG8pLGk9bi5vbixjPW4uZW1pdCxmPW4uYmluZCxhPW8uQ29tcG9uZW50cyxzPW8ucm9vdCxsPW8ub3B0aW9ucyxkPWwuaXNOYXZpZ2F0aW9uLHY9bC51cGRhdGVPbk1vdmUsaD1sLmkxOG4scD1sLnBhZ2luYXRpb24sZz1sLnNsaWRlRm9jdXMsbT1hLkRpcmVjdGlvbi5yZXNvbHZlLHk9eih1LFwic3R5bGVcIiksYj16KHUsbm4pLHc9LTE8dCx4PWZuKHUsXCIuXCIrbHQpO2Z1bmN0aW9uIGsoKXt2YXIgbj1vLnNwbGlkZXMubWFwKGZ1bmN0aW9uKG4pe249bi5zcGxpZGUuQ29tcG9uZW50cy5TbGlkZXMuZ2V0QXQocik7cmV0dXJuIG4/bi5zbGlkZS5pZDpcIlwifSkuam9pbihcIiBcIik7SSh1LG5uLE9uKGguc2xpZGVYLCh3P3Q6cikrMSkpLEkodSxLbixuKSxJKHUsWixnP1wiYnV0dG9uXCI6XCJcIiksZyYmUCh1LHR0KX1mdW5jdGlvbiBTKCl7ZXx8RSgpfWZ1bmN0aW9uIEUoKXt2YXIgbix0LGk7ZXx8KG49by5pbmRleCwoaT1MKCkpIT09dm4odSx0bikmJihBKHUsdG4saSksSSh1LFZuLGQmJml8fFwiXCIpLGMoaT9QbjpJbixPKSksaT1mdW5jdGlvbigpe2lmKG8uaXMoSXQpKXJldHVybiBMKCk7dmFyIG49TihhLkVsZW1lbnRzLnRyYWNrKSx0PU4odSksaT1tKFwibGVmdFwiLCEwKSxyPW0oXCJyaWdodFwiLCEwKTtyZXR1cm4geG4obltpXSk8PWtuKHRbaV0pJiZ4bih0W3JdKTw9a24obltyXSl9KCksdD0haSYmKCFMKCl8fHcpLG8uc3RhdGUuaXMoW0cscm5dKXx8SSh1LCRuLHR8fFwiXCIpLEkoZ24odSxsLmZvY3VzYWJsZU5vZGVzfHxcIlwiKSwkLHQ/LTE6XCJcIiksZyYmSSh1LCQsdD8tMTowKSxpIT09dm4odSxTdCkmJihBKHUsU3QsaSksYyhpP1JuOkNuLE8pKSxpfHxkb2N1bWVudC5hY3RpdmVFbGVtZW50IT09dXx8KHQ9YS5TbGlkZXMuZ2V0QXQoby5pbmRleCkpJiZkbih0LnNsaWRlKSxBKHUseHQscj09PW4tMSksQSh1LGt0LHI9PT1uKzEpKX1mdW5jdGlvbiBMKCl7dmFyIG49by5pbmRleDtyZXR1cm4gbj09PXJ8fGwuY2xvbmVTdGF0dXMmJm49PT10fXZhciBPPXtpbmRleDpyLHNsaWRlSW5kZXg6dCxzbGlkZTp1LGNvbnRhaW5lcjp4LGlzQ2xvbmU6dyxtb3VudDpmdW5jdGlvbigpe3d8fCh1LmlkPXMuaWQrXCItc2xpZGVcIitBbihyKzEpLEkodSxaLHA/XCJ0YWJwYW5lbFwiOlwiZ3JvdXBcIiksSSh1LHR0LGguc2xpZGUpLEkodSxubixifHxPbihoLnNsaWRlTGFiZWwsW3IrMSxvLmxlbmd0aF0pKSksZih1LFwiY2xpY2tcIixSKGMsTW4sTykpLGYodSxcImtleWRvd25cIixSKGMsWW4sTykpLGkoW0RuLFVuLFZdLEUpLGkoR24sayksdiYmaShILFMpfSxkZXN0cm95OmZ1bmN0aW9uKCl7ZT0hMCxuLmRlc3Ryb3koKSxYKHUsQXQpLFAodSx1dCksSSh1LFwic3R5bGVcIix5KSxJKHUsbm4sYnx8XCJcIil9LHVwZGF0ZTpFLHN0eWxlOmZ1bmN0aW9uKG4sdCxpKXtfKGkmJnh8fHUsbix0KX0saXNXaXRoaW46ZnVuY3Rpb24obix0KXtyZXR1cm4gbj1VKG4tciksKG49d3x8IWwucmV3aW5kJiYhby5pcyhQdCk/bjpZKG4sby5sZW5ndGgtbikpPD10fX07cmV0dXJuIE99dmFyIEN0PWYrXCItaW50ZXJ2YWxcIjt2YXIganQ9e3Bhc3NpdmU6ITEsY2FwdHVyZTohMH07dmFyIE50PXtTcGFjZWJhcjpcIiBcIixSaWdodDpIbixMZWZ0OkJuLFVwOnQsRG93bjpufTtmdW5jdGlvbiBUdChuKXtyZXR1cm4gbj1DKG4pP246bi5rZXksTnRbbl18fG59dmFyIEd0PVwia2V5ZG93blwiO3ZhciBGdD1mK1wiLWxhenlcIixYdD1GdCtcIi1zcmNzZXRcIixXdD1cIltcIitGdCtcIl0sIFtcIitYdCtcIl1cIjt2YXIgWXQ9W1wiIFwiLFwiRW50ZXJcIl07dmFyIFV0PU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLE1lZGlhOmZ1bmN0aW9uKHIsbixvKXt2YXIgdT1yLnN0YXRlLHQ9by5icmVha3BvaW50c3x8e30sZT1vLnJlZHVjZWRNb3Rpb258fHt9LGk9em4oKSxjPVtdO2Z1bmN0aW9uIGYobil7biYmaS5kZXN0cm95KCl9ZnVuY3Rpb24gYShuLHQpe3Q9bWF0Y2hNZWRpYSh0KTtpLmJpbmQodCxcImNoYW5nZVwiLHMpLGMucHVzaChbbix0XSl9ZnVuY3Rpb24gcygpe3ZhciBuPXUuaXMoNyksdD1vLmRpcmVjdGlvbixpPWMucmVkdWNlKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGQobix0WzFdLm1hdGNoZXM/dFswXTp7fSl9LHt9KTtzbihvKSxsKGkpLG8uZGVzdHJveT9yLmRlc3Ryb3koXCJjb21wbGV0ZWx5XCI9PT1vLmRlc3Ryb3kpOm4/KGYoITApLHIubW91bnQoKSk6dCE9PW8uZGlyZWN0aW9uJiZyLnJlZnJlc2goKX1mdW5jdGlvbiBsKG4sdCxpKXtkKG8sbiksdCYmZChPYmplY3QuZ2V0UHJvdG90eXBlT2YobyksbiksIWkmJnUuaXMoMSl8fHIuZW1pdChLLG8pfXJldHVybntzZXR1cDpmdW5jdGlvbigpe3ZhciBpPVwibWluXCI9PT1vLm1lZGlhUXVlcnk7RSh0KS5zb3J0KGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGk/K24tK3Q6K3QtK259KS5mb3JFYWNoKGZ1bmN0aW9uKG4pe2EodFtuXSxcIihcIisoaT9cIm1pblwiOlwibWF4XCIpK1wiLXdpZHRoOlwiK24rXCJweClcIil9KSxhKGUsdikscygpfSxkZXN0cm95OmYscmVkdWNlOmZ1bmN0aW9uKG4pe21hdGNoTWVkaWEodikubWF0Y2hlcyYmKG4/ZChvLGUpOnNuKG8sRShlKSkpfSxzZXQ6bH19LERpcmVjdGlvbjpmdW5jdGlvbihuLHQsbyl7cmV0dXJue3Jlc29sdmU6ZnVuY3Rpb24obix0LGkpe3ZhciByPVwicnRsXCIhPT0oaT1pfHxvLmRpcmVjdGlvbil8fHQ/aT09PUpuPzA6LTE6MTtyZXR1cm4gbFtuXSYmbFtuXVtyXXx8bi5yZXBsYWNlKC93aWR0aHxsZWZ0fHJpZ2h0L2ksZnVuY3Rpb24obix0KXtuPWxbbi50b0xvd2VyQ2FzZSgpXVtyXXx8bjtyZXR1cm4gMDx0P24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKTpufSl9LG9yaWVudDpmdW5jdGlvbihuKXtyZXR1cm4gbiooXCJydGxcIj09PW8uZGlyZWN0aW9uPzE6LTEpfX19LEVsZW1lbnRzOmZ1bmN0aW9uKG4sdCxpKXt2YXIgcixvLHUsZT1RKG4pLGM9ZS5vbixmPWUuYmluZCxhPW4ucm9vdCxzPWkuaTE4bixsPXt9LGQ9W10sdj1bXSxoPVtdO2Z1bmN0aW9uIHAoKXtyPXkoXCIuXCIrY3QpLG89Zm4ocixcIi5cIitmdCksYm4ociYmbyxcIkEgdHJhY2svbGlzdCBlbGVtZW50IGlzIG1pc3NpbmcuXCIpLGsoZCxTKG8sXCIuXCIrYXQrXCI6bm90KC5cIitzdCtcIilcIikpLHcoe2Fycm93czpkdCxwYWdpbmF0aW9uOmd0LHByZXY6aHQsbmV4dDpwdCxiYXI6eXQsdG9nZ2xlOmJ0fSxmdW5jdGlvbihuLHQpe2xbdF09eShcIi5cIituKX0pLGFuKGwse3Jvb3Q6YSx0cmFjazpyLGxpc3Q6byxzbGlkZXM6ZH0pO3ZhciBuPWEuaWR8fGZ1bmN0aW9uKG4pe3JldHVyblwiXCIrbitBbihfbltuXT0oX25bbl18fDApKzEpfSh5biksdD1pLnJvbGU7YS5pZD1uLHIuaWQ9ci5pZHx8bitcIi10cmFja1wiLG8uaWQ9by5pZHx8bitcIi1saXN0XCIsIXooYSxaKSYmXCJTRUNUSU9OXCIhPT1hLnRhZ05hbWUmJnQmJkkoYSxaLHQpLEkoYSx0dCxzLmNhcm91c2VsKSxJKG8sWixcInByZXNlbnRhdGlvblwiKSxtKCl9ZnVuY3Rpb24gZyhuKXt2YXIgdD11dC5jb25jYXQoXCJzdHlsZVwiKTtEKGQpLFgoYSx2KSxYKHIsaCksUChbcixvXSx0KSxQKGEsbj90OltcInN0eWxlXCIsdHRdKX1mdW5jdGlvbiBtKCl7WChhLHYpLFgocixoKSx2PWIoZXQpLGg9YihjdCksTShhLHYpLE0ocixoKSxJKGEsbm4saS5sYWJlbCksSShhLFpuLGkubGFiZWxsZWRieSl9ZnVuY3Rpb24geShuKXtuPXBuKGEsbik7cmV0dXJuIG4mJmZ1bmN0aW9uKG4sdCl7aWYoeChuLmNsb3Nlc3QpKXJldHVybiBuLmNsb3Nlc3QodCk7Zm9yKHZhciBpPW47aSYmMT09PWkubm9kZVR5cGUmJiFjbihpLHQpOylpPWkucGFyZW50RWxlbWVudDtyZXR1cm4gaX0obixcIi5cIitldCk9PT1hP246dm9pZCAwfWZ1bmN0aW9uIGIobil7cmV0dXJuW24rXCItLVwiK2kudHlwZSxuK1wiLS1cIitpLmRpcmVjdGlvbixpLmRyYWcmJm4rXCItLWRyYWdnYWJsZVwiLGkuaXNOYXZpZ2F0aW9uJiZuK1wiLS1uYXZcIixuPT09ZXQmJnRuXX1yZXR1cm4gYW4obCx7c2V0dXA6cCxtb3VudDpmdW5jdGlvbigpe2MoSixnKSxjKEoscCksYyhLLG0pLGYoZG9jdW1lbnQsX3QrXCIga2V5ZG93blwiLGZ1bmN0aW9uKG4pe3U9XCJrZXlkb3duXCI9PT1uLnR5cGV9LHtjYXB0dXJlOiEwfSksZihhLFwiZm9jdXNpblwiLGZ1bmN0aW9uKCl7QShhLEx0LCEhdSl9KX0sZGVzdHJveTpnfSl9LFNsaWRlczpmdW5jdGlvbihyLG8sdSl7dmFyIG49UShyKSx0PW4ub24sZT1uLmVtaXQsYz1uLmJpbmQsZj0obj1vLkVsZW1lbnRzKS5zbGlkZXMsYT1uLmxpc3Qscz1bXTtmdW5jdGlvbiBpKCl7Zi5mb3JFYWNoKGZ1bmN0aW9uKG4sdCl7ZChuLHQsLTEpfSl9ZnVuY3Rpb24gbCgpe2goZnVuY3Rpb24obil7bi5kZXN0cm95KCl9KSxEKHMpfWZ1bmN0aW9uIGQobix0LGkpe3Q9UnQocix0LGksbik7dC5tb3VudCgpLHMucHVzaCh0KSxzLnNvcnQoZnVuY3Rpb24obix0KXtyZXR1cm4gbi5pbmRleC10LmluZGV4fSl9ZnVuY3Rpb24gdihuKXtyZXR1cm4gbj9wKGZ1bmN0aW9uKG4pe3JldHVybiFuLmlzQ2xvbmV9KTpzfWZ1bmN0aW9uIGgobix0KXt2KHQpLmZvckVhY2gobil9ZnVuY3Rpb24gcCh0KXtyZXR1cm4gcy5maWx0ZXIoeCh0KT90OmZ1bmN0aW9uKG4pe3JldHVybiBDKHQpP2NuKG4uc2xpZGUsdCk6Yih5KHQpLG4uaW5kZXgpfSl9cmV0dXJue21vdW50OmZ1bmN0aW9uKCl7aSgpLHQoSixsKSx0KEosaSl9LGRlc3Ryb3k6bCx1cGRhdGU6ZnVuY3Rpb24oKXtoKGZ1bmN0aW9uKG4pe24udXBkYXRlKCl9KX0scmVnaXN0ZXI6ZCxnZXQ6dixnZXRJbjpmdW5jdGlvbihuKXt2YXIgdD1vLkNvbnRyb2xsZXIsaT10LnRvSW5kZXgobikscj10Lmhhc0ZvY3VzKCk/MTp1LnBlclBhZ2U7cmV0dXJuIHAoZnVuY3Rpb24obil7cmV0dXJuIEVuKG4uaW5kZXgsaSxpK3ItMSl9KX0sZ2V0QXQ6ZnVuY3Rpb24obil7cmV0dXJuIHAobilbMF19LGFkZDpmdW5jdGlvbihuLG8pe2cobixmdW5jdGlvbihuKXt2YXIgdCxpLHI7bShuPUMobik/aG4obik6bikmJigodD1mW29dKT9PKG4sdCk6TChhLG4pLE0obix1LmNsYXNzZXMuc2xpZGUpLHQ9bixpPVIoZSxqbiksdD1nbih0LFwiaW1nXCIpLChyPXQubGVuZ3RoKT90LmZvckVhY2goZnVuY3Rpb24obil7YyhuLFwibG9hZCBlcnJvclwiLGZ1bmN0aW9uKCl7LS1yfHxpKCl9KX0pOmkoKSl9KSxlKEopfSxyZW1vdmU6ZnVuY3Rpb24obil7VChwKG4pLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gbi5zbGlkZX0pKSxlKEopfSxmb3JFYWNoOmgsZmlsdGVyOnAsc3R5bGU6ZnVuY3Rpb24odCxpLHIpe2goZnVuY3Rpb24obil7bi5zdHlsZSh0LGkscil9KX0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKG4pe3JldHVybihuP2Y6cykubGVuZ3RofSxpc0Vub3VnaDpmdW5jdGlvbigpe3JldHVybiBzLmxlbmd0aD51LnBlclBhZ2V9fX0sTGF5b3V0OmZ1bmN0aW9uKHQsbixpKXt2YXIgcixvLHUsZT0oYT1RKHQpKS5vbixjPWEuYmluZCxmPWEuZW1pdCxhPW4uU2xpZGVzLHM9bi5EaXJlY3Rpb24ucmVzb2x2ZSxsPShuPW4uRWxlbWVudHMpLnJvb3QsZD1uLnRyYWNrLHY9bi5saXN0LGg9YS5nZXRBdCxwPWEuc3R5bGU7ZnVuY3Rpb24gZygpe3I9aS5kaXJlY3Rpb249PT1KbixfKGwsXCJtYXhXaWR0aFwiLFcoaS53aWR0aCkpLF8oZCxzKFwicGFkZGluZ0xlZnRcIikseSghMSkpLF8oZCxzKFwicGFkZGluZ1JpZ2h0XCIpLHkoITApKSxtKCEwKX1mdW5jdGlvbiBtKG4pe3ZhciB0PU4obCk7IW4mJm8ud2lkdGg9PT10LndpZHRoJiZvLmhlaWdodD09PXQuaGVpZ2h0fHwoXyhkLFwiaGVpZ2h0XCIsZnVuY3Rpb24oKXt2YXIgbj1cIlwiO3ImJihibihuPWIoKSxcImhlaWdodCBvciBoZWlnaHRSYXRpbyBpcyBtaXNzaW5nLlwiKSxuPVwiY2FsYyhcIituK1wiIC0gXCIreSghMSkrXCIgLSBcIit5KCEwKStcIilcIik7cmV0dXJuIG59KCkpLHAocyhcIm1hcmdpblJpZ2h0XCIpLFcoaS5nYXApKSxwKFwid2lkdGhcIixpLmF1dG9XaWR0aD9udWxsOlcoaS5maXhlZFdpZHRoKXx8KHI/XCJcIjp3KCkpKSxwKFwiaGVpZ2h0XCIsVyhpLmZpeGVkSGVpZ2h0KXx8KHI/aS5hdXRvSGVpZ2h0P251bGw6dygpOmIoKSksITApLG89dCxmKE5uKSx1IT09KHU9TygpKSYmKEEobCxPdCx1KSxmKFwib3ZlcmZsb3dcIix1KSkpfWZ1bmN0aW9uIHkobil7dmFyIHQ9aS5wYWRkaW5nLG49cyhuP1wicmlnaHRcIjpcImxlZnRcIik7cmV0dXJuIHQmJlcodFtuXXx8KHVuKHQpPzA6dCkpfHxcIjBweFwifWZ1bmN0aW9uIGIoKXtyZXR1cm4gVyhpLmhlaWdodHx8Tih2KS53aWR0aCppLmhlaWdodFJhdGlvKX1mdW5jdGlvbiB3KCl7dmFyIG49VyhpLmdhcCk7cmV0dXJuXCJjYWxjKCgxMDAlXCIrKG4mJlwiICsgXCIrbikrXCIpL1wiKyhpLnBlclBhZ2V8fDEpKyhuJiZcIiAtIFwiK24pK1wiKVwifWZ1bmN0aW9uIHgoKXtyZXR1cm4gTih2KVtzKFwid2lkdGhcIildfWZ1bmN0aW9uIGsobix0KXtuPWgobnx8MCk7cmV0dXJuIG4/TihuLnNsaWRlKVtzKFwid2lkdGhcIildKyh0PzA6TCgpKTowfWZ1bmN0aW9uIFMobix0KXt2YXIgaSxuPWgobik7cmV0dXJuIG4/KG49TihuLnNsaWRlKVtzKFwicmlnaHRcIildLGk9Tih2KVtzKFwibGVmdFwiKV0sVShuLWkpKyh0PzA6TCgpKSk6MH1mdW5jdGlvbiBFKG4pe3JldHVybiBTKHQubGVuZ3RoLTEpLVMoMCkraygwLG4pfWZ1bmN0aW9uIEwoKXt2YXIgbj1oKDApO3JldHVybiBuJiZwYXJzZUZsb2F0KF8obi5zbGlkZSxzKFwibWFyZ2luUmlnaHRcIikpKXx8MH1mdW5jdGlvbiBPKCl7cmV0dXJuIHQuaXMoSXQpfHxFKCEwKT54KCl9cmV0dXJue21vdW50OmZ1bmN0aW9uKCl7dmFyIG4sdCxpO2coKSxjKHdpbmRvdyxcInJlc2l6ZSBsb2FkXCIsKG49UihmLGpuKSxpPXFuKHR8fDAsbixudWxsLDEpLGZ1bmN0aW9uKCl7aS5pc1BhdXNlZCgpJiZpLnN0YXJ0KCl9KSksZShbSyxKXSxnKSxlKGpuLG0pfSxyZXNpemU6bSxsaXN0U2l6ZTp4LHNsaWRlU2l6ZTprLHNsaWRlclNpemU6RSx0b3RhbFNpemU6UyxnZXRQYWRkaW5nOmZ1bmN0aW9uKG4pe3JldHVybiBwYXJzZUZsb2F0KF8oZCxzKFwicGFkZGluZ1wiKyhuP1wiUmlnaHRcIjpcIkxlZnRcIikpKSl8fDB9LGlzT3ZlcmZsb3c6T319LENsb25lczpmdW5jdGlvbihjLGksZil7dmFyIHQscj1RKGMpLG49ci5vbixhPWkuRWxlbWVudHMscz1pLlNsaWRlcyxvPWkuRGlyZWN0aW9uLnJlc29sdmUsbD1bXTtmdW5jdGlvbiB1KCl7aWYobihKLGQpLG4oW0ssam5dLHYpLHQ9aCgpKXt2YXIgbz10LHU9cy5nZXQoKS5zbGljZSgpLGU9dS5sZW5ndGg7aWYoZSl7Zm9yKDt1Lmxlbmd0aDxvOylrKHUsdSk7ayh1LnNsaWNlKC1vKSx1LnNsaWNlKDAsbykpLmZvckVhY2goZnVuY3Rpb24obix0KXt2YXIgaT10PG8scj1mdW5jdGlvbihuLHQpe249bi5jbG9uZU5vZGUoITApO3JldHVybiBNKG4sZi5jbGFzc2VzLmNsb25lKSxuLmlkPWMucm9vdC5pZCtcIi1jbG9uZVwiK0FuKHQrMSksbn0obi5zbGlkZSx0KTtpP08ocix1WzBdLnNsaWRlKTpMKGEubGlzdCxyKSxrKGwscikscy5yZWdpc3RlcihyLHQtbysoaT8wOmUpLG4uaW5kZXgpfSl9aS5MYXlvdXQucmVzaXplKCEwKX19ZnVuY3Rpb24gZCgpe2UoKSx1KCl9ZnVuY3Rpb24gZSgpe1QobCksRChsKSxyLmRlc3Ryb3koKX1mdW5jdGlvbiB2KCl7dmFyIG49aCgpO3QhPT1uJiYodDxufHwhbikmJnIuZW1pdChKKX1mdW5jdGlvbiBoKCl7dmFyIG4sdD1mLmNsb25lcztyZXR1cm4gYy5pcyhQdCk/ZW4odCkmJih0PShuPWZbbyhcImZpeGVkV2lkdGhcIildJiZpLkxheW91dC5zbGlkZVNpemUoMCkpJiZrbihOKGEudHJhY2spW28oXCJ3aWR0aFwiKV0vbil8fGZbbyhcImF1dG9XaWR0aFwiKV0mJmMubGVuZ3RofHwyKmYucGVyUGFnZSk6dD0wLHR9cmV0dXJue21vdW50OnUsZGVzdHJveTplfX0sTW92ZTpmdW5jdGlvbihyLGMsbyl7dmFyIGUsbj1RKHIpLHQ9bi5vbixmPW4uZW1pdCxhPXIuc3RhdGUuc2V0LHU9KG49Yy5MYXlvdXQpLnNsaWRlU2l6ZSxpPW4uZ2V0UGFkZGluZyxzPW4udG90YWxTaXplLGw9bi5saXN0U2l6ZSxkPW4uc2xpZGVyU2l6ZSx2PShuPWMuRGlyZWN0aW9uKS5yZXNvbHZlLGg9bi5vcmllbnQscD0obj1jLkVsZW1lbnRzKS5saXN0LGc9bi50cmFjaztmdW5jdGlvbiBtKCl7Yy5Db250cm9sbGVyLmlzQnVzeSgpfHwoYy5TY3JvbGwuY2FuY2VsKCkseShyLmluZGV4KSxjLlNsaWRlcy51cGRhdGUoKSl9ZnVuY3Rpb24geShuKXtiKFMobiwhMCkpfWZ1bmN0aW9uIGIobix0KXtyLmlzKEl0KXx8KHQ9dD9uOmZ1bmN0aW9uKG4pe3t2YXIgdCxpO3IuaXMoUHQpJiYodD1rKG4pLGk9dD5jLkNvbnRyb2xsZXIuZ2V0RW5kKCksKHQ8MHx8aSkmJihuPXcobixpKSkpfXJldHVybiBufShuKSxfKHAsXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVwiK3YoXCJYXCIpK1wiKFwiK3QrXCJweClcIiksbiE9PXQmJmYoVW4pKX1mdW5jdGlvbiB3KG4sdCl7dmFyIGk9bi1MKHQpLHI9ZCgpO3JldHVybiBuLT1oKHIqKGtuKFUoaSkvcil8fDEpKSoodD8xOi0xKX1mdW5jdGlvbiB4KCl7YihFKCksITApLGUuY2FuY2VsKCl9ZnVuY3Rpb24gayhuKXtmb3IodmFyIHQ9Yy5TbGlkZXMuZ2V0KCksaT0wLHI9MS8wLG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIHU9dFtvXS5pbmRleCxlPVUoUyh1LCEwKS1uKTtpZighKGU8PXIpKWJyZWFrO3I9ZSxpPXV9cmV0dXJuIGl9ZnVuY3Rpb24gUyhuLHQpe3ZhciBpPWgocyhuLTEpLShuPW4sXCJjZW50ZXJcIj09PShpPW8uZm9jdXMpPyhsKCktdShuLCEwKSkvMjoraSp1KG4pfHwwKSk7cmV0dXJuIHQ/KG49aSxuPW8udHJpbVNwYWNlJiZyLmlzKE10KT9xKG4sMCxoKGQoITApLWwoKSkpOm4pOml9ZnVuY3Rpb24gRSgpe3ZhciBuPXYoXCJsZWZ0XCIpO3JldHVybiBOKHApW25dLU4oZylbbl0raChpKCExKSl9ZnVuY3Rpb24gTChuKXtyZXR1cm4gUyhuP2MuQ29udHJvbGxlci5nZXRFbmQoKTowLCEhby50cmltU3BhY2UpfXJldHVybnttb3VudDpmdW5jdGlvbigpe2U9Yy5UcmFuc2l0aW9uLHQoW0IsTm4sSyxKXSxtKX0sbW92ZTpmdW5jdGlvbihuLHQsaSxyKXt2YXIgbyx1O24hPT10JiYobz1pPG4sdT1oKHcoRSgpLG8pKSxvPzA8PXU6dTw9cFt2KFwic2Nyb2xsV2lkdGhcIildLU4oZylbdihcIndpZHRoXCIpXSkmJih4KCksYih3KEUoKSxpPG4pLCEwKSksYShHKSxmKEgsdCxpLG4pLGUuc3RhcnQodCxmdW5jdGlvbigpe2EoMyksZihEbix0LGksbiksciYmcigpfSl9LGp1bXA6eSx0cmFuc2xhdGU6YixzaGlmdDp3LGNhbmNlbDp4LHRvSW5kZXg6ayx0b1Bvc2l0aW9uOlMsZ2V0UG9zaXRpb246RSxnZXRMaW1pdDpMLGV4Y2VlZGVkTGltaXQ6ZnVuY3Rpb24obix0KXt0PWVuKHQpP0UoKTp0O3ZhciBpPSEwIT09biYmaCh0KTxoKEwoITEpKSxuPSExIT09biYmaCh0KT5oKEwoITApKTtyZXR1cm4gaXx8bn0scmVwb3NpdGlvbjptfX0sQ29udHJvbGxlcjpmdW5jdGlvbihvLHUsZSl7dmFyIGMsZixhLHMsbj1RKG8pLHQ9bi5vbixpPW4uZW1pdCxsPXUuTW92ZSxkPWwuZ2V0UG9zaXRpb24scj1sLmdldExpbWl0LHY9bC50b1Bvc2l0aW9uLGg9KG49dS5TbGlkZXMpLmlzRW5vdWdoLHA9bi5nZXRMZW5ndGgsZz1lLm9taXRFbmQsbT1vLmlzKFB0KSx5PW8uaXMoTXQpLGI9UihMLCExKSx3PVIoTCwhMCkseD1lLnN0YXJ0fHwwLGs9eDtmdW5jdGlvbiBTKCl7Zj1wKCEwKSxhPWUucGVyTW92ZSxzPWUucGVyUGFnZSxjPV8oKTt2YXIgbj1xKHgsMCxnP2M6Zi0xKTtuIT09eCYmKHg9bixsLnJlcG9zaXRpb24oKSl9ZnVuY3Rpb24gRSgpe2MhPT1fKCkmJmkoXCJlaVwiKX1mdW5jdGlvbiBMKG4sdCl7dmFyIGk9YXx8KFAoKT8xOnMpLGk9Tyh4K2kqKG4/LTE6MSkseCwhKGF8fFAoKSkpO3JldHVybi0xPT09aSYmeSYmIVNuKGQoKSxyKCFuKSwxKT9uPzA6Yzp0P2k6QShpKX1mdW5jdGlvbiBPKG4sdCxpKXt2YXIgcjtyZXR1cm4gaCgpfHxQKCk/KChyPWZ1bmN0aW9uKG4pe2lmKHkmJlwibW92ZVwiPT09ZS50cmltU3BhY2UmJm4hPT14KWZvcih2YXIgdD1kKCk7dD09PXYobiwhMCkmJkVuKG4sMCxvLmxlbmd0aC0xLCFlLnJld2luZCk7KW48eD8tLW46KytuO3JldHVybiBufShuKSkhPT1uJiYodD1uLG49cixpPSExKSxuPDB8fGM8bj9uPWF8fCFFbigwLG4sdCwhMCkmJiFFbihjLHQsbiwhMCk/bT9pP248MD8tKGYlc3x8cyk6ZjpuOmUucmV3aW5kP248MD9jOjA6LTE6eihEKG4pKTppJiZuIT09dCYmKG49eihEKHQpKyhuPHQ/LTE6MSkpKSk6bj0tMSxufWZ1bmN0aW9uIEEobil7cmV0dXJuIG0/KG4rZiklZnx8MDpufWZ1bmN0aW9uIF8oKXtmb3IodmFyIG49Zi0oUCgpfHxtJiZhPzE6cyk7ZyYmMDxuLS07KWlmKHYoZi0xLCEwKSE9PXYobiwhMCkpe24rKzticmVha31yZXR1cm4gcShuLDAsZi0xKX1mdW5jdGlvbiB6KG4pe3JldHVybiBxKFAoKT9uOnMqbiwwLGMpfWZ1bmN0aW9uIEQobil7cmV0dXJuIFAoKT9ZKG4sYyk6eG4oKGM8PW4/Zi0xOm4pL3MpfWZ1bmN0aW9uIE0obil7biE9PXgmJihrPXgseD1uKX1mdW5jdGlvbiBQKCl7cmV0dXJuIWVuKGUuZm9jdXMpfHxlLmlzTmF2aWdhdGlvbn1mdW5jdGlvbiBJKCl7cmV0dXJuIG8uc3RhdGUuaXMoW0cscm5dKSYmISFlLndhaXRGb3JUcmFuc2l0aW9ufXJldHVybnttb3VudDpmdW5jdGlvbigpe1MoKSx0KFtLLEosXCJlaVwiXSxTKSx0KE5uLEUpfSxnbzpmdW5jdGlvbihuLHQsaSl7dmFyIHI7SSgpfHwtMTwocj1BKG49ZnVuY3Rpb24obil7dmFyIHQ9eDt7dmFyIGkscjtDKG4pPyhyPW4ubWF0Y2goLyhbK1xcLTw+XSkoXFxkKyk/Lyl8fFtdLGk9clsxXSxyPXJbMl0sXCIrXCI9PT1pfHxcIi1cIj09PWk/dD1PKHgrICsoXCJcIitpKygrcnx8MSkpLHgpOlwiPlwiPT09aT90PXI/eigrcik6YighMCk6XCI8XCI9PT1pJiYodD13KCEwKSkpOnQ9bT9uOnEobiwwLGMpfXJldHVybiB0fShuKSkpJiYodHx8ciE9PXgpJiYoTShyKSxsLm1vdmUobixyLGssaSkpfSxzY3JvbGw6ZnVuY3Rpb24obix0LGkscil7dS5TY3JvbGwuc2Nyb2xsKG4sdCxpLGZ1bmN0aW9uKCl7dmFyIG49QShsLnRvSW5kZXgoZCgpKSk7TShnP1kobixjKTpuKSxyJiZyKCl9KX0sZ2V0TmV4dDpiLGdldFByZXY6dyxnZXRBZGphY2VudDpMLGdldEVuZDpfLHNldEluZGV4Ok0sZ2V0SW5kZXg6ZnVuY3Rpb24obil7cmV0dXJuIG4/azp4fSx0b0luZGV4OnosdG9QYWdlOkQsdG9EZXN0OmZ1bmN0aW9uKG4pe3JldHVybiBuPWwudG9JbmRleChuKSx5P3EobiwwLGMpOm59LGhhc0ZvY3VzOlAsaXNCdXN5Okl9fSxBcnJvd3M6ZnVuY3Rpb24obyxuLHQpe3ZhciBpLHIsdT1RKG8pLGU9dS5vbixjPXUuYmluZCxmPXUuZW1pdCxhPXQuY2xhc3NlcyxzPXQuaTE4bixsPW4uRWxlbWVudHMsZD1uLkNvbnRyb2xsZXIsdj1sLmFycm93cyxoPWwudHJhY2sscD12LGc9bC5wcmV2LG09bC5uZXh0LHk9e307ZnVuY3Rpb24gYigpe3ZhciBuPXQuYXJyb3dzOyFufHxnJiZtfHwocD12fHxqKFwiZGl2XCIsYS5hcnJvd3MpLGc9UyghMCksbT1TKCExKSxpPSEwLEwocCxbZyxtXSksdnx8TyhwLGgpKSxnJiZtJiYoYW4oeSx7cHJldjpnLG5leHQ6bX0pLGxuKHAsbj9cIlwiOlwibm9uZVwiKSxNKHAscj1kdCtcIi0tXCIrdC5kaXJlY3Rpb24pLG4mJihlKFtCLERuLEosVixcImVpXCJdLEUpLGMobSxcImNsaWNrXCIsUihrLFwiPlwiKSksYyhnLFwiY2xpY2tcIixSKGssXCI8XCIpKSxFKCksSShbZyxtXSxLbixoLmlkKSxmKFwiYXJyb3dzOm1vdW50ZWRcIixnLG0pKSksZShLLHcpfWZ1bmN0aW9uIHcoKXt4KCksYigpfWZ1bmN0aW9uIHgoKXt1LmRlc3Ryb3koKSxYKHAsciksaT8oVCh2P1tnLG1dOnApLGc9bT1udWxsKTpQKFtnLG1dLHV0KX1mdW5jdGlvbiBrKG4pe2QuZ28obiwhMCl9ZnVuY3Rpb24gUyhuKXtyZXR1cm4gaG4oJzxidXR0b24gY2xhc3M9XCInK2EuYXJyb3crXCIgXCIrKG4/YS5wcmV2OmEubmV4dCkrJ1wiIHR5cGU9XCJidXR0b25cIj48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDQwIDQwXCIgd2lkdGg9XCI0MFwiIGhlaWdodD1cIjQwXCIgZm9jdXNhYmxlPVwiZmFsc2VcIj48cGF0aCBkPVwiJysodC5hcnJvd1BhdGh8fFwibTE1LjUgMC45MzItNC4zIDQuMzggMTQuNSAxNC42LTE0LjUgMTQuNSA0LjMgNC40IDE0LjYtMTQuNiA0LjQtNC4zLTQuNC00LjQtMTQuNi0xNC42elwiKSsnXCIgLz4nKX1mdW5jdGlvbiBFKCl7dmFyIG4sdCxpLHI7ZyYmbSYmKHI9by5pbmRleCxuPWQuZ2V0UHJldigpLHQ9ZC5nZXROZXh0KCksaT0tMTxuJiZyPG4/cy5sYXN0OnMucHJldixyPS0xPHQmJnQ8cj9zLmZpcnN0OnMubmV4dCxnLmRpc2FibGVkPW48MCxtLmRpc2FibGVkPXQ8MCxJKGcsbm4saSksSShtLG5uLHIpLGYoXCJhcnJvd3M6dXBkYXRlZFwiLGcsbSxuLHQpKX1yZXR1cm57YXJyb3dzOnksbW91bnQ6YixkZXN0cm95OngsdXBkYXRlOkV9fSxBdXRvcGxheTpmdW5jdGlvbihuLHQsaSl7dmFyIHIsbyx1PVEobiksZT11Lm9uLGM9dS5iaW5kLGY9dS5lbWl0LGE9cW4oaS5pbnRlcnZhbCxuLmdvLmJpbmQobixcIj5cIiksZnVuY3Rpb24obil7dmFyIHQ9bC5iYXI7dCYmXyh0LFwid2lkdGhcIiwxMDAqbitcIiVcIiksZihcImF1dG9wbGF5OnBsYXlpbmdcIixuKX0pLHM9YS5pc1BhdXNlZCxsPXQuRWxlbWVudHMsZD0odT10LkVsZW1lbnRzKS5yb290LHY9dS50b2dnbGUsaD1pLmF1dG9wbGF5LHA9XCJwYXVzZVwiPT09aDtmdW5jdGlvbiBnKCl7cygpJiZ0LlNsaWRlcy5pc0Vub3VnaCgpJiYoYS5zdGFydCghaS5yZXNldFByb2dyZXNzKSxvPXI9cD0hMSxiKCksZihGbikpfWZ1bmN0aW9uIG0obil7cD0hIShuPXZvaWQgMD09PW4/ITA6biksYigpLHMoKXx8KGEucGF1c2UoKSxmKFhuKSl9ZnVuY3Rpb24geSgpe3B8fChyfHxvP20oITEpOmcoKSl9ZnVuY3Rpb24gYigpe3YmJihBKHYsdG4sIXApLEkodixubixpLmkxOG5bcD9cInBsYXlcIjpcInBhdXNlXCJdKSl9ZnVuY3Rpb24gdyhuKXtuPXQuU2xpZGVzLmdldEF0KG4pO2Euc2V0KG4mJit6KG4uc2xpZGUsQ3QpfHxpLmludGVydmFsKX1yZXR1cm57bW91bnQ6ZnVuY3Rpb24oKXtoJiYoaS5wYXVzZU9uSG92ZXImJmMoZCxcIm1vdXNlZW50ZXIgbW91c2VsZWF2ZVwiLGZ1bmN0aW9uKG4pe3I9XCJtb3VzZWVudGVyXCI9PT1uLnR5cGUseSgpfSksaS5wYXVzZU9uRm9jdXMmJmMoZCxcImZvY3VzaW4gZm9jdXNvdXRcIixmdW5jdGlvbihuKXtvPVwiZm9jdXNpblwiPT09bi50eXBlLHkoKX0pLHYmJmModixcImNsaWNrXCIsZnVuY3Rpb24oKXtwP2coKTptKCEwKX0pLGUoW0gsVG4sSl0sYS5yZXdpbmQpLGUoSCx3KSx2JiZJKHYsS24sbC50cmFjay5pZCkscHx8ZygpLGIoKSl9LGRlc3Ryb3k6YS5jYW5jZWwscGxheTpnLHBhdXNlOm0saXNQYXVzZWQ6c319LENvdmVyOmZ1bmN0aW9uKG4sdCxpKXt2YXIgcj1RKG4pLm9uO2Z1bmN0aW9uIG8oaSl7dC5TbGlkZXMuZm9yRWFjaChmdW5jdGlvbihuKXt2YXIgdD1mbihuLmNvbnRhaW5lcnx8bi5zbGlkZSxcImltZ1wiKTt0JiZ0LnNyYyYmdShpLHQsbil9KX1mdW5jdGlvbiB1KG4sdCxpKXtpLnN0eWxlKFwiYmFja2dyb3VuZFwiLG4/J2NlbnRlci9jb3ZlciBuby1yZXBlYXQgdXJsKFwiJyt0LnNyYysnXCIpJzpcIlwiLCEwKSxsbih0LG4/XCJub25lXCI6XCJcIil9cmV0dXJue21vdW50OmZ1bmN0aW9uKCl7aS5jb3ZlciYmKHIoV24sUih1LCEwKSkscihbQixLLEpdLFIobywhMCkpKX0sZGVzdHJveTpSKG8sITEpfX0sU2Nyb2xsOmZ1bmN0aW9uKG4sYyx1KXt2YXIgZixhLHQ9UShuKSxpPXQub24scz10LmVtaXQsbD1uLnN0YXRlLnNldCxkPWMuTW92ZSx2PWQuZ2V0UG9zaXRpb24sZT1kLmdldExpbWl0LGg9ZC5leGNlZWRlZExpbWl0LHA9ZC50cmFuc2xhdGUsZz1uLmlzKE10KSxtPTE7ZnVuY3Rpb24geShuLHQsaSxyLG8pe3ZhciB1LGU9digpLGk9KHgoKSwhaXx8ZyYmaCgpfHwoaT1jLkxheW91dC5zbGlkZXJTaXplKCksdT1MbihuKSppKnhuKFUobikvaSl8fDAsbj1kLnRvUG9zaXRpb24oYy5Db250cm9sbGVyLnRvRGVzdChuJWkpKSt1KSxTbihlLG4sMSkpO209MSx0PWk/MDp0fHx3bihVKG4tZSkvMS41LDgwMCksYT1yLGY9cW4odCxiLFIodyxlLG4sbyksMSksbChybikscyhUbiksZi5zdGFydCgpfWZ1bmN0aW9uIGIoKXtsKDMpLGEmJmEoKSxzKFYpfWZ1bmN0aW9uIHcobix0LGkscil7dmFyIG89digpLHI9KG4rKHQtbikqKHQ9ciwobj11LmVhc2luZ0Z1bmMpP24odCk6MS1NYXRoLnBvdygxLXQsNCkpLW8pKm07cChvK3IpLGcmJiFpJiZoKCkmJihtKj0uNixVKHIpPDEwJiZ5KGUoaCghMCkpLDYwMCwhMSxhLCEwKSl9ZnVuY3Rpb24geCgpe2YmJmYuY2FuY2VsKCl9ZnVuY3Rpb24gcigpe2YmJiFmLmlzUGF1c2VkKCkmJih4KCksYigpKX1yZXR1cm57bW91bnQ6ZnVuY3Rpb24oKXtpKEgseCksaShbSyxKXSxyKX0sZGVzdHJveTp4LHNjcm9sbDp5LGNhbmNlbDpyfX0sRHJhZzpmdW5jdGlvbihlLG8sYyl7dmFyIGYsdCx1LGEscyxsLGQsdixuPVEoZSksaT1uLm9uLGg9bi5lbWl0LHA9bi5iaW5kLGc9bi51bmJpbmQsbT1lLnN0YXRlLHk9by5Nb3ZlLGI9by5TY3JvbGwsdz1vLkNvbnRyb2xsZXIseD1vLkVsZW1lbnRzLnRyYWNrLGs9by5NZWRpYS5yZWR1Y2Uscj0obj1vLkRpcmVjdGlvbikucmVzb2x2ZSxTPW4ub3JpZW50LEU9eS5nZXRQb3NpdGlvbixMPXkuZXhjZWVkZWRMaW1pdCxPPSExO2Z1bmN0aW9uIGooKXt2YXIgbj1jLmRyYWc7QyghbiksYT1cImZyZWVcIj09PW59ZnVuY3Rpb24gTihuKXt2YXIgdCxpLHI7bD0hMSxkfHwodD1SKG4pLGk9bi50YXJnZXQscj1jLm5vRHJhZyxjbihpLFwiLlwiK210K1wiLCAuXCIrdnQpfHxyJiZjbihpLHIpfHwhdCYmbi5idXR0b258fCh3LmlzQnVzeSgpP0YobiwhMCk6KHY9dD94OndpbmRvdyxzPW0uaXMoW0cscm5dKSx1PW51bGwscCh2LHp0LEEsanQpLHAodixEdCxfLGp0KSx5LmNhbmNlbCgpLGIuY2FuY2VsKCkseihuKSkpKX1mdW5jdGlvbiBBKG4pe3ZhciB0LGkscixvLHU7bS5pcyg2KXx8KG0uc2V0KDYpLGgoXCJkcmFnXCIpKSxuLmNhbmNlbGFibGUmJihzPyh5LnRyYW5zbGF0ZShmK0QobikvKE8mJmUuaXMoTXQpPzU6MSkpLHU9MjAwPE0obiksdD1PIT09KE89TCgpKSwodXx8dCkmJnoobiksbD0hMCxoKFwiZHJhZ2dpbmdcIiksRihuKSk6VShEKHU9bikpPlUoRCh1LCEwKSkmJih0PW4saT1jLmRyYWdNaW5UaHJlc2hvbGQscj11bihpKSxvPXImJmkubW91c2V8fDAscj0ocj9pLnRvdWNoOitpKXx8MTAscz1VKEQodCkpPihSKHQpP3I6byksRihuKSkpfWZ1bmN0aW9uIF8obil7dmFyIHQsaSxyO20uaXMoNikmJihtLnNldCgzKSxoKFwiZHJhZ2dlZFwiKSkscyYmKGk9ZnVuY3Rpb24obil7cmV0dXJuIEUoKStMbihuKSpZKFUobikqKGMuZmxpY2tQb3dlcnx8NjAwKSxhPzEvMDpvLkxheW91dC5saXN0U2l6ZSgpKihjLmZsaWNrTWF4UGFnZXN8fDEpKX0odD1mdW5jdGlvbihuKXtpZihlLmlzKFB0KXx8IU8pe3ZhciB0PU0obik7aWYodCYmdDwyMDApcmV0dXJuIEQobikvdH1yZXR1cm4gMH0odD1uKSkscj1jLnJld2luZCYmYy5yZXdpbmRCeURyYWcsayghMSksYT93LnNjcm9sbChpLDAsYy5zbmFwKTplLmlzKEl0KT93LmdvKFMoTG4odCkpPDA/cj9cIjxcIjpcIi1cIjpyP1wiPlwiOlwiK1wiKTplLmlzKE10KSYmTyYmcj93LmdvKEwoITApP1wiPlwiOlwiPFwiKTp3LmdvKHcudG9EZXN0KGkpLCEwKSxrKCEwKSxGKG4pKSxnKHYsenQsQSksZyh2LER0LF8pLHM9ITF9ZnVuY3Rpb24gVChuKXshZCYmbCYmRihuLCEwKX1mdW5jdGlvbiB6KG4pe3U9dCx0PW4sZj1FKCl9ZnVuY3Rpb24gRChuLHQpe3JldHVybiBJKG4sdCktSShQKG4pLHQpfWZ1bmN0aW9uIE0obil7cmV0dXJuIG1uKG4pLW1uKFAobikpfWZ1bmN0aW9uIFAobil7cmV0dXJuIHQ9PT1uJiZ1fHx0fWZ1bmN0aW9uIEkobix0KXtyZXR1cm4oUihuKT9uLmNoYW5nZWRUb3VjaGVzWzBdOm4pW1wicGFnZVwiK3IodD9cIllcIjpcIlhcIildfWZ1bmN0aW9uIFIobil7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRvdWNoRXZlbnQmJm4gaW5zdGFuY2VvZiBUb3VjaEV2ZW50fWZ1bmN0aW9uIEMobil7ZD1ufXJldHVybnttb3VudDpmdW5jdGlvbigpe3AoeCx6dCxvbixqdCkscCh4LER0LG9uLGp0KSxwKHgsX3QsTixqdCkscCh4LFwiY2xpY2tcIixULHtjYXB0dXJlOiEwfSkscCh4LFwiZHJhZ3N0YXJ0XCIsRiksaShbQixLXSxqKX0sZGlzYWJsZTpDLGlzRHJhZ2dpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc319fSxLZXlib2FyZDpmdW5jdGlvbih0LG4saSl7dmFyIHIsbyx1PVEodCksZT11Lm9uLGM9dS5iaW5kLGY9dS51bmJpbmQsYT10LnJvb3Qscz1uLkRpcmVjdGlvbi5yZXNvbHZlO2Z1bmN0aW9uIGwoKXt2YXIgbj1pLmtleWJvYXJkO24mJihyPVwiZ2xvYmFsXCI9PT1uP3dpbmRvdzphLGMocixHdCxoKSl9ZnVuY3Rpb24gZCgpe2YocixHdCl9ZnVuY3Rpb24gdigpe3ZhciBuPW87bz0hMCxwKGZ1bmN0aW9uKCl7bz1ufSl9ZnVuY3Rpb24gaChuKXtvfHwoKG49VHQobikpPT09cyhCbik/dC5nbyhcIjxcIik6bj09PXMoSG4pJiZ0LmdvKFwiPlwiKSl9cmV0dXJue21vdW50OmZ1bmN0aW9uKCl7bCgpLGUoSyxkKSxlKEssbCksZShILHYpfSxkZXN0cm95OmQsZGlzYWJsZTpmdW5jdGlvbihuKXtvPW59fX0sTGF6eUxvYWQ6ZnVuY3Rpb24oaSxuLG8pe3ZhciB0PVEoaSkscj10Lm9uLHU9dC5vZmYsZT10LmJpbmQsYz10LmVtaXQsZj1cInNlcXVlbnRpYWxcIj09PW8ubGF6eUxvYWQsYT1bRG4sVl0scz1bXTtmdW5jdGlvbiBsKCl7RChzKSxuLlNsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uKHIpe2duKHIuc2xpZGUsV3QpLmZvckVhY2goZnVuY3Rpb24obil7dmFyIHQ9eihuLEZ0KSxpPXoobixYdCk7dD09PW4uc3JjJiZpPT09bi5zcmNzZXR8fCh0PW8uY2xhc3Nlcy5zcGlubmVyLHQ9Zm4oaT1uLnBhcmVudEVsZW1lbnQsXCIuXCIrdCl8fGooXCJzcGFuXCIsdCxpKSxzLnB1c2goW24scix0XSksbi5zcmN8fGxuKG4sXCJub25lXCIpKX0pfSksKGY/cDoodShhKSxyKGEsZCksZCkpKCl9ZnVuY3Rpb24gZCgpeyhzPXMuZmlsdGVyKGZ1bmN0aW9uKG4pe3ZhciB0PW8ucGVyUGFnZSooKG8ucHJlbG9hZFBhZ2VzfHwxKSsxKS0xO3JldHVybiFuWzFdLmlzV2l0aGluKGkuaW5kZXgsdCl8fHYobil9KSkubGVuZ3RofHx1KGEpfWZ1bmN0aW9uIHYobil7dmFyIHQ9blswXTtNKG5bMV0uc2xpZGUsRXQpLGUodCxcImxvYWQgZXJyb3JcIixSKGgsbikpLEkodCxcInNyY1wiLHoodCxGdCkpLEkodCxcInNyY3NldFwiLHoodCxYdCkpLFAodCxGdCksUCh0LFh0KX1mdW5jdGlvbiBoKG4sdCl7dmFyIGk9blswXSxyPW5bMV07WChyLnNsaWRlLEV0KSxcImVycm9yXCIhPT10LnR5cGUmJihUKG5bMl0pLGxuKGksXCJcIiksYyhXbixpLHIpLGMoam4pKSxmJiZwKCl9ZnVuY3Rpb24gcCgpe3MubGVuZ3RoJiZ2KHMuc2hpZnQoKSl9cmV0dXJue21vdW50OmZ1bmN0aW9uKCl7by5sYXp5TG9hZCYmKGwoKSxyKEosbCkpfSxkZXN0cm95OlIoRCxzKSxjaGVjazpkfX0sUGFnaW5hdGlvbjpmdW5jdGlvbihsLG4sZCl7dmFyIHYsaCx0PVEobCkscD10Lm9uLGc9dC5lbWl0LG09dC5iaW5kLHk9bi5TbGlkZXMsYj1uLkVsZW1lbnRzLHc9bi5Db250cm9sbGVyLHg9dy5oYXNGb2N1cyxyPXcuZ2V0SW5kZXgsZT13LmdvLGM9bi5EaXJlY3Rpb24ucmVzb2x2ZSxrPWIucGFnaW5hdGlvbixTPVtdO2Z1bmN0aW9uIEUoKXt2JiYoVChrP28odi5jaGlsZHJlbik6diksWCh2LGgpLEQoUyksdj1udWxsKSx0LmRlc3Ryb3koKX1mdW5jdGlvbiBMKG4pe2UoXCI+XCIrbiwhMCl9ZnVuY3Rpb24gTyhuLHQpe3ZhciBpPVMubGVuZ3RoLHI9VHQodCksbz1BKCksdT0tMSxvPShyPT09YyhIbiwhMSxvKT91PSsrbiVpOnI9PT1jKEJuLCExLG8pP3U9KC0tbitpKSVpOlwiSG9tZVwiPT09cj91PTA6XCJFbmRcIj09PXImJih1PWktMSksU1t1XSk7byYmKGRuKG8uYnV0dG9uKSxlKFwiPlwiK3UpLEYodCwhMCkpfWZ1bmN0aW9uIEEoKXtyZXR1cm4gZC5wYWdpbmF0aW9uRGlyZWN0aW9ufHxkLmRpcmVjdGlvbn1mdW5jdGlvbiBfKG4pe3JldHVybiBTW3cudG9QYWdlKG4pXX1mdW5jdGlvbiB6KCl7dmFyIG4sdD1fKHIoITApKSxpPV8ocigpKTt0JiYoWChuPXQuYnV0dG9uLHRuKSxQKG4sUW4pLEkobiwkLC0xKSksaSYmKE0obj1pLmJ1dHRvbix0biksSShuLFFuLCEwKSxJKG4sJCxcIlwiKSksZyhcInBhZ2luYXRpb246dXBkYXRlZFwiLHtsaXN0OnYsaXRlbXM6U30sdCxpKX1yZXR1cm57aXRlbXM6Uyxtb3VudDpmdW5jdGlvbiBuKCl7RSgpLHAoW0ssSixcImVpXCJdLG4pO3ZhciB0PWQucGFnaW5hdGlvbjtpZihrJiZsbihrLHQ/XCJcIjpcIm5vbmVcIiksdCl7cChbSCxUbixWXSx6KTt2YXIgdD1sLmxlbmd0aCxpPWQuY2xhc3NlcyxyPWQuaTE4bixvPWQucGVyUGFnZSx1PXgoKT93LmdldEVuZCgpKzE6a24odC9vKTtNKHY9a3x8aihcInVsXCIsaS5wYWdpbmF0aW9uLGIudHJhY2sucGFyZW50RWxlbWVudCksaD1ndCtcIi0tXCIrQSgpKSxJKHYsWixcInRhYmxpc3RcIiksSSh2LG5uLHIuc2VsZWN0KSxJKHYsbnQsQSgpPT09Sm4/XCJ2ZXJ0aWNhbFwiOlwiXCIpO2Zvcih2YXIgZT0wO2U8dTtlKyspe3ZhciBjPWooXCJsaVwiLG51bGwsdiksZj1qKFwiYnV0dG9uXCIse2NsYXNzOmkucGFnZSx0eXBlOlwiYnV0dG9uXCJ9LGMpLGE9eS5nZXRJbihlKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4uc2xpZGUuaWR9KSxzPSF4KCkmJjE8bz9yLnBhZ2VYOnIuc2xpZGVYO20oZixcImNsaWNrXCIsUihMLGUpKSxkLnBhZ2luYXRpb25LZXlib2FyZCYmbShmLFwia2V5ZG93blwiLFIoTyxlKSksSShjLFosXCJwcmVzZW50YXRpb25cIiksSShmLFosXCJ0YWJcIiksSShmLEtuLGEuam9pbihcIiBcIikpLEkoZixubixPbihzLGUrMSkpLEkoZiwkLC0xKSxTLnB1c2goe2xpOmMsYnV0dG9uOmYscGFnZTplfSl9eigpLGcoXCJwYWdpbmF0aW9uOm1vdW50ZWRcIix7bGlzdDp2LGl0ZW1zOlN9LF8obC5pbmRleCkpfX0sZGVzdHJveTpFLGdldEF0Ol8sdXBkYXRlOnp9fSxTeW5jOmZ1bmN0aW9uKGksbix0KXt2YXIgcj10LmlzTmF2aWdhdGlvbixvPXQuc2xpZGVGb2N1cyx1PVtdO2Z1bmN0aW9uIGUoKXt2YXIgbix0O2kuc3BsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uKG4pe24uaXNQYXJlbnR8fChmKGksbi5zcGxpZGUpLGYobi5zcGxpZGUsaSkpfSksciYmKG49UShpKSwodD1uLm9uKShNbixzKSx0KFluLGwpLHQoW0IsS10sYSksdS5wdXNoKG4pLG4uZW1pdChHbixpLnNwbGlkZXMpKX1mdW5jdGlvbiBjKCl7dS5mb3JFYWNoKGZ1bmN0aW9uKG4pe24uZGVzdHJveSgpfSksRCh1KX1mdW5jdGlvbiBmKG4scil7bj1RKG4pO24ub24oSCxmdW5jdGlvbihuLHQsaSl7ci5nbyhyLmlzKFB0KT9pOm4pfSksdS5wdXNoKG4pfWZ1bmN0aW9uIGEoKXtJKG4uRWxlbWVudHMubGlzdCxudCx0LmRpcmVjdGlvbj09PUpuP1widmVydGljYWxcIjpcIlwiKX1mdW5jdGlvbiBzKG4pe2kuZ28obi5pbmRleCl9ZnVuY3Rpb24gbChuLHQpe2IoWXQsVHQodCkpJiYocyhuKSxGKHQpKX1yZXR1cm57c2V0dXA6UihuLk1lZGlhLnNldCx7c2xpZGVGb2N1czplbihvKT9yOm99LCEwKSxtb3VudDplLGRlc3Ryb3k6YyxyZW1vdW50OmZ1bmN0aW9uKCl7YygpLGUoKX19fSxXaGVlbDpmdW5jdGlvbihlLGMsZil7dmFyIG49UShlKS5iaW5kLGE9MDtmdW5jdGlvbiB0KG4pe3ZhciB0LGkscixvLHU7bi5jYW5jZWxhYmxlJiYodD0odT1uLmRlbHRhWSk8MCxpPW1uKG4pLHI9Zi53aGVlbE1pblRocmVzaG9sZHx8MCxvPWYud2hlZWxTbGVlcHx8MCxVKHUpPnImJm88aS1hJiYoZS5nbyh0P1wiPFwiOlwiPlwiKSxhPWkpLHU9dCxmLnJlbGVhc2VXaGVlbCYmIWUuc3RhdGUuaXMoRykmJi0xPT09Yy5Db250cm9sbGVyLmdldEFkamFjZW50KHUpfHxGKG4pKX1yZXR1cm57bW91bnQ6ZnVuY3Rpb24oKXtmLndoZWVsJiZuKGMuRWxlbWVudHMudHJhY2ssXCJ3aGVlbFwiLHQsanQpfX19LExpdmU6ZnVuY3Rpb24obix0LGkpe3ZhciByPVEobikub24sbz10LkVsZW1lbnRzLnRyYWNrLHU9aS5saXZlJiYhaS5pc05hdmlnYXRpb24sZT1qKFwic3BhblwiLHd0KSxjPXFuKDkwLFIoZiwhMSkpO2Z1bmN0aW9uIGYobil7SShvLHJ0LG4pLG4/KEwobyxlKSxjLnN0YXJ0KCkpOihUKGUpLGMuY2FuY2VsKCkpfWZ1bmN0aW9uIGEobil7dSYmSShvLGl0LG4/XCJvZmZcIjpcInBvbGl0ZVwiKX1yZXR1cm57bW91bnQ6ZnVuY3Rpb24oKXt1JiYoYSghdC5BdXRvcGxheS5pc1BhdXNlZCgpKSxJKG8sb3QsITApLGUudGV4dENvbnRlbnQ9XCLigKZcIixyKEZuLFIoYSwhMCkpLHIoWG4sUihhLCExKSkscihbRG4sVl0sUihmLCEwKSkpfSxkaXNhYmxlOmEsZGVzdHJveTpmdW5jdGlvbigpe1AobyxbaXQsb3QscnRdKSxUKGUpfX19fSkscXQ9e3R5cGU6XCJzbGlkZVwiLHJvbGU6XCJyZWdpb25cIixzcGVlZDo0MDAscGVyUGFnZToxLGNsb25lU3RhdHVzOiEwLGFycm93czohMCxwYWdpbmF0aW9uOiEwLHBhZ2luYXRpb25LZXlib2FyZDohMCxpbnRlcnZhbDo1ZTMscGF1c2VPbkhvdmVyOiEwLHBhdXNlT25Gb2N1czohMCxyZXNldFByb2dyZXNzOiEwLGVhc2luZzpcImN1YmljLWJlemllcigwLjI1LCAxLCAwLjUsIDEpXCIsZHJhZzohMCxkaXJlY3Rpb246XCJsdHJcIix0cmltU3BhY2U6ITAsZm9jdXNhYmxlTm9kZXM6XCJhLCBidXR0b24sIHRleHRhcmVhLCBpbnB1dCwgc2VsZWN0LCBpZnJhbWVcIixsaXZlOiEwLGNsYXNzZXM6e3NsaWRlOmF0LGNsb25lOnN0LGFycm93czpkdCxhcnJvdzp2dCxwcmV2Omh0LG5leHQ6cHQscGFnaW5hdGlvbjpndCxwYWdlOm10LHNwaW5uZXI6aStcInNwaW5uZXJcIn0saTE4bjp7cHJldjpcIlByZXZpb3VzIHNsaWRlXCIsbmV4dDpcIk5leHQgc2xpZGVcIixmaXJzdDpcIkdvIHRvIGZpcnN0IHNsaWRlXCIsbGFzdDpcIkdvIHRvIGxhc3Qgc2xpZGVcIixzbGlkZVg6XCJHbyB0byBzbGlkZSAlc1wiLHBhZ2VYOlwiR28gdG8gcGFnZSAlc1wiLHBsYXk6XCJTdGFydCBhdXRvcGxheVwiLHBhdXNlOlwiUGF1c2UgYXV0b3BsYXlcIixjYXJvdXNlbDpcImNhcm91c2VsXCIsc2xpZGU6XCJzbGlkZVwiLHNlbGVjdDpcIlNlbGVjdCBhIHNsaWRlIHRvIHNob3dcIixzbGlkZUxhYmVsOlwiJXMgb2YgJXNcIn0scmVkdWNlZE1vdGlvbjp7c3BlZWQ6MCxyZXdpbmRTcGVlZDowLGF1dG9wbGF5OlwicGF1c2VcIn19O2Z1bmN0aW9uIEJ0KG4sdCxpKXt2YXIgcj10LlNsaWRlcztmdW5jdGlvbiBvKCl7ci5mb3JFYWNoKGZ1bmN0aW9uKG4pe24uc3R5bGUoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoLVwiKzEwMCpuLmluZGV4K1wiJSlcIil9KX1yZXR1cm57bW91bnQ6ZnVuY3Rpb24oKXtRKG4pLm9uKFtCLEpdLG8pfSxzdGFydDpmdW5jdGlvbihuLHQpe3Iuc3R5bGUoXCJ0cmFuc2l0aW9uXCIsXCJvcGFjaXR5IFwiK2kuc3BlZWQrXCJtcyBcIitpLmVhc2luZykscCh0KX0sY2FuY2VsOm9ufX1mdW5jdGlvbiBIdCh1LG4sZSl7dmFyIGMsZj1uLk1vdmUsYT1uLkNvbnRyb2xsZXIscz1uLlNjcm9sbCx0PW4uRWxlbWVudHMubGlzdCxsPVIoXyx0LFwidHJhbnNpdGlvblwiKTtmdW5jdGlvbiBpKCl7bChcIlwiKSxzLmNhbmNlbCgpfXJldHVybnttb3VudDpmdW5jdGlvbigpe1EodSkuYmluZCh0LFwidHJhbnNpdGlvbmVuZFwiLGZ1bmN0aW9uKG4pe24udGFyZ2V0PT09dCYmYyYmKGkoKSxjKCkpfSl9LHN0YXJ0OmZ1bmN0aW9uKG4sdCl7dmFyIGk9Zi50b1Bvc2l0aW9uKG4sITApLHI9Zi5nZXRQb3NpdGlvbigpLG89ZnVuY3Rpb24obil7dmFyIHQ9ZS5yZXdpbmRTcGVlZDtpZih1LmlzKE10KSYmdCl7dmFyIGk9YS5nZXRJbmRleCghMCkscj1hLmdldEVuZCgpO2lmKDA9PT1pJiZyPD1ufHxyPD1pJiYwPT09bilyZXR1cm4gdH1yZXR1cm4gZS5zcGVlZH0obik7MTw9VShpLXIpJiYxPD1vP2UudXNlU2Nyb2xsP3Muc2Nyb2xsKGksbywhMSx0KToobChcInRyYW5zZm9ybSBcIitvK1wibXMgXCIrZS5lYXNpbmcpLGYudHJhbnNsYXRlKGksITApLGM9dCk6KGYuanVtcChuKSx0KCkpfSxjYW5jZWw6aX19dD1mdW5jdGlvbigpe2Z1bmN0aW9uIGkobix0KXt0aGlzLmV2ZW50PVEoKSx0aGlzLkNvbXBvbmVudHM9e30sdGhpcy5zdGF0ZT1zKDEpLHRoaXMuc3BsaWRlcz1bXSx0aGlzLm49e30sdGhpcy50PXt9O249QyhuKT9wbihkb2N1bWVudCxuKTpuO2JuKG4sbitcIiBpcyBpbnZhbGlkLlwiKSx0PWQoe2xhYmVsOnoodGhpcy5yb290PW4sbm4pfHxcIlwiLGxhYmVsbGVkYnk6eihuLFpuKXx8XCJcIn0scXQsaS5kZWZhdWx0cyx0fHx7fSk7dHJ5e2QodCxKU09OLnBhcnNlKHoobixmKSkpfWNhdGNoKG4pe2JuKCExLFwiSW52YWxpZCBKU09OXCIpfXRoaXMubj1PYmplY3QuY3JlYXRlKGQoe30sdCkpfXZhciBuPWkucHJvdG90eXBlO3JldHVybiBuLm1vdW50PWZ1bmN0aW9uKG4sdCl7dmFyIGk9dGhpcyxyPXRoaXMuc3RhdGUsbz10aGlzLkNvbXBvbmVudHM7cmV0dXJuIGJuKHIuaXMoWzEsN10pLFwiQWxyZWFkeSBtb3VudGVkIVwiKSxyLnNldCgxKSx0aGlzLmk9byx0aGlzLnI9dHx8dGhpcy5yfHwodGhpcy5pcyhJdCk/QnQ6SHQpLHRoaXMudD1ufHx0aGlzLnQsdyhhbih7fSxVdCx0aGlzLnQse1RyYW5zaXRpb246dGhpcy5yfSksZnVuY3Rpb24obix0KXtuPW4oaSxvLGkubik7KG9bdF09bikuc2V0dXAmJm4uc2V0dXAoKX0pLHcobyxmdW5jdGlvbihuKXtuLm1vdW50JiZuLm1vdW50KCl9KSx0aGlzLmVtaXQoQiksTSh0aGlzLnJvb3QsXCJpcy1pbml0aWFsaXplZFwiKSxyLnNldCgzKSx0aGlzLmVtaXQoXCJyZWFkeVwiKSx0aGlzfSxuLnN5bmM9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuc3BsaWRlcy5wdXNoKHtzcGxpZGU6bn0pLG4uc3BsaWRlcy5wdXNoKHtzcGxpZGU6dGhpcyxpc1BhcmVudDohMH0pLHRoaXMuc3RhdGUuaXMoMykmJih0aGlzLmkuU3luYy5yZW1vdW50KCksbi5Db21wb25lbnRzLlN5bmMucmVtb3VudCgpKSx0aGlzfSxuLmdvPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmkuQ29udHJvbGxlci5nbyhuKSx0aGlzfSxuLm9uPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIHRoaXMuZXZlbnQub24obix0KSx0aGlzfSxuLm9mZj1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5ldmVudC5vZmYobiksdGhpc30sbi5lbWl0PWZ1bmN0aW9uKG4pe3ZhciB0O3JldHVybih0PXRoaXMuZXZlbnQpLmVtaXQuYXBwbHkodCxbbl0uY29uY2F0KG8oYXJndW1lbnRzLDEpKSksdGhpc30sbi5hZGQ9ZnVuY3Rpb24obix0KXtyZXR1cm4gdGhpcy5pLlNsaWRlcy5hZGQobix0KSx0aGlzfSxuLnJlbW92ZT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5pLlNsaWRlcy5yZW1vdmUobiksdGhpc30sbi5pcz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5uLnR5cGU9PT1ufSxuLnJlZnJlc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbWl0KEopLHRoaXN9LG4uZGVzdHJveT1mdW5jdGlvbih0KXt2b2lkIDA9PT10JiYodD0hMCk7dmFyIG49dGhpcy5ldmVudCxpPXRoaXMuc3RhdGU7cmV0dXJuIGkuaXMoMSk/USh0aGlzKS5vbihcInJlYWR5XCIsdGhpcy5kZXN0cm95LmJpbmQodGhpcyx0KSk6KHcodGhpcy5pLGZ1bmN0aW9uKG4pe24uZGVzdHJveSYmbi5kZXN0cm95KHQpfSwhMCksbi5lbWl0KGEpLG4uZGVzdHJveSgpLHQmJkQodGhpcy5zcGxpZGVzKSxpLnNldCg3KSksdGhpc30sSnQoaSxbe2tleTpcIm9wdGlvbnNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ufSxzZXQ6ZnVuY3Rpb24obil7dGhpcy5pLk1lZGlhLnNldChuLCEwLCEwKX19LHtrZXk6XCJsZW5ndGhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pLlNsaWRlcy5nZXRMZW5ndGgoITApfX0se2tleTpcImluZGV4XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaS5Db250cm9sbGVyLmdldEluZGV4KCl9fV0pLGl9KCk7cmV0dXJuIHQuZGVmYXVsdHM9e30sdC5TVEFURVM9cix0fSxcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSh0KToobj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOm58fHNlbGYpLlNwbGlkZT10KCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGxpZGUubWluLmpzLm1hcCIsIiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUocmVxdWlyZShcIkBwb3BwZXJqcy9jb3JlXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIkBwb3BwZXJqcy9jb3JlXCJdLGUpOih0PXR8fHNlbGYpLnRpcHB5PWUodC5Qb3BwZXIpfSh0aGlzLChmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjt2YXIgZT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQsbj0hIWUmJiEhd2luZG93Lm1zQ3J5cHRvLHI9e3Bhc3NpdmU6ITAsY2FwdHVyZTohMH0sbz1mdW5jdGlvbigpe3JldHVybiBkb2N1bWVudC5ib2R5fTtmdW5jdGlvbiBpKHQsZSxuKXtpZihBcnJheS5pc0FycmF5KHQpKXt2YXIgcj10W2VdO3JldHVybiBudWxsPT1yP0FycmF5LmlzQXJyYXkobik/bltlXTpuOnJ9cmV0dXJuIHR9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPXt9LnRvU3RyaW5nLmNhbGwodCk7cmV0dXJuIDA9PT1uLmluZGV4T2YoXCJbb2JqZWN0XCIpJiZuLmluZGV4T2YoZStcIl1cIik+LTF9ZnVuY3Rpb24gcyh0LGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dC5hcHBseSh2b2lkIDAsZSk6dH1mdW5jdGlvbiB1KHQsZSl7cmV0dXJuIDA9PT1lP3Q6ZnVuY3Rpb24ocil7Y2xlYXJUaW1lb3V0KG4pLG49c2V0VGltZW91dCgoZnVuY3Rpb24oKXt0KHIpfSksZSl9O3ZhciBufWZ1bmN0aW9uIHAodCxlKXt2YXIgbj1PYmplY3QuYXNzaWduKHt9LHQpO3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKHQpe2RlbGV0ZSBuW3RdfSkpLG59ZnVuY3Rpb24gYyh0KXtyZXR1cm5bXS5jb25jYXQodCl9ZnVuY3Rpb24gZih0LGUpey0xPT09dC5pbmRleE9mKGUpJiZ0LnB1c2goZSl9ZnVuY3Rpb24gbCh0KXtyZXR1cm4gdC5zcGxpdChcIi1cIilbMF19ZnVuY3Rpb24gZCh0KXtyZXR1cm5bXS5zbGljZS5jYWxsKHQpfWZ1bmN0aW9uIHYodCl7cmV0dXJuIE9iamVjdC5rZXlzKHQpLnJlZHVjZSgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdm9pZCAwIT09dFtuXSYmKGVbbl09dFtuXSksZX0pLHt9KX1mdW5jdGlvbiBtKCl7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIil9ZnVuY3Rpb24gZyh0KXtyZXR1cm5bXCJFbGVtZW50XCIsXCJGcmFnbWVudFwiXS5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gYSh0LGUpfSkpfWZ1bmN0aW9uIGgodCl7cmV0dXJuIGEodCxcIk1vdXNlRXZlbnRcIil9ZnVuY3Rpb24gYih0KXtyZXR1cm4hKCF0fHwhdC5fdGlwcHl8fHQuX3RpcHB5LnJlZmVyZW5jZSE9PXQpfWZ1bmN0aW9uIHkodCl7cmV0dXJuIGcodCk/W3RdOmZ1bmN0aW9uKHQpe3JldHVybiBhKHQsXCJOb2RlTGlzdFwiKX0odCk/ZCh0KTpBcnJheS5pc0FycmF5KHQpP3Q6ZChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQpKX1mdW5jdGlvbiB3KHQsZSl7dC5mb3JFYWNoKChmdW5jdGlvbih0KXt0JiYodC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb249ZStcIm1zXCIpfSkpfWZ1bmN0aW9uIHgodCxlKXt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3QmJnQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdGF0ZVwiLGUpfSkpfWZ1bmN0aW9uIEUodCl7dmFyIGUsbj1jKHQpWzBdO3JldHVybiBudWxsIT1uJiZudWxsIT0oZT1uLm93bmVyRG9jdW1lbnQpJiZlLmJvZHk/bi5vd25lckRvY3VtZW50OmRvY3VtZW50fWZ1bmN0aW9uIE8odCxlLG4pe3ZhciByPWUrXCJFdmVudExpc3RlbmVyXCI7W1widHJhbnNpdGlvbmVuZFwiLFwid2Via2l0VHJhbnNpdGlvbkVuZFwiXS5mb3JFYWNoKChmdW5jdGlvbihlKXt0W3JdKGUsbil9KSl9ZnVuY3Rpb24gQyh0LGUpe2Zvcih2YXIgbj1lO247KXt2YXIgcjtpZih0LmNvbnRhaW5zKG4pKXJldHVybiEwO249bnVsbD09bi5nZXRSb290Tm9kZXx8bnVsbD09KHI9bi5nZXRSb290Tm9kZSgpKT92b2lkIDA6ci5ob3N0fXJldHVybiExfXZhciBUPXtpc1RvdWNoOiExfSxBPTA7ZnVuY3Rpb24gTCgpe1QuaXNUb3VjaHx8KFQuaXNUb3VjaD0hMCx3aW5kb3cucGVyZm9ybWFuY2UmJmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixEKSl9ZnVuY3Rpb24gRCgpe3ZhciB0PXBlcmZvcm1hbmNlLm5vdygpO3QtQTwyMCYmKFQuaXNUb3VjaD0hMSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsRCkpLEE9dH1mdW5jdGlvbiBrKCl7dmFyIHQ9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtpZihiKHQpKXt2YXIgZT10Ll90aXBweTt0LmJsdXImJiFlLnN0YXRlLmlzVmlzaWJsZSYmdC5ibHVyKCl9fXZhciBSPU9iamVjdC5hc3NpZ24oe2FwcGVuZFRvOm8sYXJpYTp7Y29udGVudDpcImF1dG9cIixleHBhbmRlZDpcImF1dG9cIn0sZGVsYXk6MCxkdXJhdGlvbjpbMzAwLDI1MF0sZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDpudWxsLGhpZGVPbkNsaWNrOiEwLGlnbm9yZUF0dHJpYnV0ZXM6ITEsaW50ZXJhY3RpdmU6ITEsaW50ZXJhY3RpdmVCb3JkZXI6MixpbnRlcmFjdGl2ZURlYm91bmNlOjAsbW92ZVRyYW5zaXRpb246XCJcIixvZmZzZXQ6WzAsMTBdLG9uQWZ0ZXJVcGRhdGU6ZnVuY3Rpb24oKXt9LG9uQmVmb3JlVXBkYXRlOmZ1bmN0aW9uKCl7fSxvbkNyZWF0ZTpmdW5jdGlvbigpe30sb25EZXN0cm95OmZ1bmN0aW9uKCl7fSxvbkhpZGRlbjpmdW5jdGlvbigpe30sb25IaWRlOmZ1bmN0aW9uKCl7fSxvbk1vdW50OmZ1bmN0aW9uKCl7fSxvblNob3c6ZnVuY3Rpb24oKXt9LG9uU2hvd246ZnVuY3Rpb24oKXt9LG9uVHJpZ2dlcjpmdW5jdGlvbigpe30sb25VbnRyaWdnZXI6ZnVuY3Rpb24oKXt9LG9uQ2xpY2tPdXRzaWRlOmZ1bmN0aW9uKCl7fSxwbGFjZW1lbnQ6XCJ0b3BcIixwbHVnaW5zOltdLHBvcHBlck9wdGlvbnM6e30scmVuZGVyOm51bGwsc2hvd09uQ3JlYXRlOiExLHRvdWNoOiEwLHRyaWdnZXI6XCJtb3VzZWVudGVyIGZvY3VzXCIsdHJpZ2dlclRhcmdldDpudWxsfSx7YW5pbWF0ZUZpbGw6ITEsZm9sbG93Q3Vyc29yOiExLGlubGluZVBvc2l0aW9uaW5nOiExLHN0aWNreTohMX0se2FsbG93SFRNTDohMSxhbmltYXRpb246XCJmYWRlXCIsYXJyb3c6ITAsY29udGVudDpcIlwiLGluZXJ0aWE6ITEsbWF4V2lkdGg6MzUwLHJvbGU6XCJ0b29sdGlwXCIsdGhlbWU6XCJcIix6SW5kZXg6OTk5OX0pLFA9T2JqZWN0LmtleXMoUik7ZnVuY3Rpb24gaih0KXt2YXIgZT0odC5wbHVnaW5zfHxbXSkucmVkdWNlKChmdW5jdGlvbihlLG4pe3ZhciByLG89bi5uYW1lLGk9bi5kZWZhdWx0VmFsdWU7byYmKGVbb109dm9pZCAwIT09dFtvXT90W29dOm51bGwhPShyPVJbb10pP3I6aSk7cmV0dXJuIGV9KSx7fSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sdCxlKX1mdW5jdGlvbiBNKHQsZSl7dmFyIG49T2JqZWN0LmFzc2lnbih7fSxlLHtjb250ZW50OnMoZS5jb250ZW50LFt0XSl9LGUuaWdub3JlQXR0cmlidXRlcz97fTpmdW5jdGlvbih0LGUpe3JldHVybihlP09iamVjdC5rZXlzKGooT2JqZWN0LmFzc2lnbih7fSxSLHtwbHVnaW5zOmV9KSkpOlApLnJlZHVjZSgoZnVuY3Rpb24oZSxuKXt2YXIgcj0odC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRpcHB5LVwiK24pfHxcIlwiKS50cmltKCk7aWYoIXIpcmV0dXJuIGU7aWYoXCJjb250ZW50XCI9PT1uKWVbbl09cjtlbHNlIHRyeXtlW25dPUpTT04ucGFyc2Uocil9Y2F0Y2godCl7ZVtuXT1yfXJldHVybiBlfSkse30pfSh0LGUucGx1Z2lucykpO3JldHVybiBuLmFyaWE9T2JqZWN0LmFzc2lnbih7fSxSLmFyaWEsbi5hcmlhKSxuLmFyaWE9e2V4cGFuZGVkOlwiYXV0b1wiPT09bi5hcmlhLmV4cGFuZGVkP2UuaW50ZXJhY3RpdmU6bi5hcmlhLmV4cGFuZGVkLGNvbnRlbnQ6XCJhdXRvXCI9PT1uLmFyaWEuY29udGVudD9lLmludGVyYWN0aXZlP251bGw6XCJkZXNjcmliZWRieVwiOm4uYXJpYS5jb250ZW50fSxufWZ1bmN0aW9uIFYodCxlKXt0LmlubmVySFRNTD1lfWZ1bmN0aW9uIEkodCl7dmFyIGU9bSgpO3JldHVybiEwPT09dD9lLmNsYXNzTmFtZT1cInRpcHB5LWFycm93XCI6KGUuY2xhc3NOYW1lPVwidGlwcHktc3ZnLWFycm93XCIsZyh0KT9lLmFwcGVuZENoaWxkKHQpOlYoZSx0KSksZX1mdW5jdGlvbiBTKHQsZSl7ZyhlLmNvbnRlbnQpPyhWKHQsXCJcIiksdC5hcHBlbmRDaGlsZChlLmNvbnRlbnQpKTpcImZ1bmN0aW9uXCIhPXR5cGVvZiBlLmNvbnRlbnQmJihlLmFsbG93SFRNTD9WKHQsZS5jb250ZW50KTp0LnRleHRDb250ZW50PWUuY29udGVudCl9ZnVuY3Rpb24gQih0KXt2YXIgZT10LmZpcnN0RWxlbWVudENoaWxkLG49ZChlLmNoaWxkcmVuKTtyZXR1cm57Ym94OmUsY29udGVudDpuLmZpbmQoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNsYXNzTGlzdC5jb250YWlucyhcInRpcHB5LWNvbnRlbnRcIil9KSksYXJyb3c6bi5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0aXBweS1hcnJvd1wiKXx8dC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0aXBweS1zdmctYXJyb3dcIil9KSksYmFja2Ryb3A6bi5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0aXBweS1iYWNrZHJvcFwiKX0pKX19ZnVuY3Rpb24gTih0KXt2YXIgZT1tKCksbj1tKCk7bi5jbGFzc05hbWU9XCJ0aXBweS1ib3hcIixuLnNldEF0dHJpYnV0ZShcImRhdGEtc3RhdGVcIixcImhpZGRlblwiKSxuLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsXCItMVwiKTt2YXIgcj1tKCk7ZnVuY3Rpb24gbyhuLHIpe3ZhciBvPUIoZSksaT1vLmJveCxhPW8uY29udGVudCxzPW8uYXJyb3c7ci50aGVtZT9pLnNldEF0dHJpYnV0ZShcImRhdGEtdGhlbWVcIixyLnRoZW1lKTppLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGhlbWVcIiksXCJzdHJpbmdcIj09dHlwZW9mIHIuYW5pbWF0aW9uP2kuc2V0QXR0cmlidXRlKFwiZGF0YS1hbmltYXRpb25cIixyLmFuaW1hdGlvbik6aS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWFuaW1hdGlvblwiKSxyLmluZXJ0aWE/aS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWluZXJ0aWFcIixcIlwiKTppLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtaW5lcnRpYVwiKSxpLnN0eWxlLm1heFdpZHRoPVwibnVtYmVyXCI9PXR5cGVvZiByLm1heFdpZHRoP3IubWF4V2lkdGgrXCJweFwiOnIubWF4V2lkdGgsci5yb2xlP2kuc2V0QXR0cmlidXRlKFwicm9sZVwiLHIucm9sZSk6aS5yZW1vdmVBdHRyaWJ1dGUoXCJyb2xlXCIpLG4uY29udGVudD09PXIuY29udGVudCYmbi5hbGxvd0hUTUw9PT1yLmFsbG93SFRNTHx8UyhhLHQucHJvcHMpLHIuYXJyb3c/cz9uLmFycm93IT09ci5hcnJvdyYmKGkucmVtb3ZlQ2hpbGQocyksaS5hcHBlbmRDaGlsZChJKHIuYXJyb3cpKSk6aS5hcHBlbmRDaGlsZChJKHIuYXJyb3cpKTpzJiZpLnJlbW92ZUNoaWxkKHMpfXJldHVybiByLmNsYXNzTmFtZT1cInRpcHB5LWNvbnRlbnRcIixyLnNldEF0dHJpYnV0ZShcImRhdGEtc3RhdGVcIixcImhpZGRlblwiKSxTKHIsdC5wcm9wcyksZS5hcHBlbmRDaGlsZChuKSxuLmFwcGVuZENoaWxkKHIpLG8odC5wcm9wcyx0LnByb3BzKSx7cG9wcGVyOmUsb25VcGRhdGU6b319Ti4kJHRpcHB5PSEwO3ZhciBIPTEsVT1bXSxfPVtdO2Z1bmN0aW9uIHooZSxhKXt2YXIgcCxnLGIseSxBLEwsRCxrLFA9TShlLE9iamVjdC5hc3NpZ24oe30sUixqKHYoYSkpKSksVj0hMSxJPSExLFM9ITEsTj0hMSx6PVtdLEY9dSh3dCxQLmludGVyYWN0aXZlRGVib3VuY2UpLFc9SCsrLFg9KGs9UC5wbHVnaW5zKS5maWx0ZXIoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGsuaW5kZXhPZih0KT09PWV9KSksWT17aWQ6VyxyZWZlcmVuY2U6ZSxwb3BwZXI6bSgpLHBvcHBlckluc3RhbmNlOm51bGwscHJvcHM6UCxzdGF0ZTp7aXNFbmFibGVkOiEwLGlzVmlzaWJsZTohMSxpc0Rlc3Ryb3llZDohMSxpc01vdW50ZWQ6ITEsaXNTaG93bjohMX0scGx1Z2luczpYLGNsZWFyRGVsYXlUaW1lb3V0czpmdW5jdGlvbigpe2NsZWFyVGltZW91dChwKSxjbGVhclRpbWVvdXQoZyksY2FuY2VsQW5pbWF0aW9uRnJhbWUoYil9LHNldFByb3BzOmZ1bmN0aW9uKHQpe2lmKFkuc3RhdGUuaXNEZXN0cm95ZWQpcmV0dXJuO2F0KFwib25CZWZvcmVVcGRhdGVcIixbWSx0XSksYnQoKTt2YXIgbj1ZLnByb3BzLHI9TShlLE9iamVjdC5hc3NpZ24oe30sbix2KHQpLHtpZ25vcmVBdHRyaWJ1dGVzOiEwfSkpO1kucHJvcHM9cixodCgpLG4uaW50ZXJhY3RpdmVEZWJvdW5jZSE9PXIuaW50ZXJhY3RpdmVEZWJvdW5jZSYmKHB0KCksRj11KHd0LHIuaW50ZXJhY3RpdmVEZWJvdW5jZSkpO24udHJpZ2dlclRhcmdldCYmIXIudHJpZ2dlclRhcmdldD9jKG4udHJpZ2dlclRhcmdldCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIpfSkpOnIudHJpZ2dlclRhcmdldCYmZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIpO3V0KCksaXQoKSxKJiZKKG4scik7WS5wb3BwZXJJbnN0YW5jZSYmKEN0KCksQXQoKS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUodC5fdGlwcHkucG9wcGVySW5zdGFuY2UuZm9yY2VVcGRhdGUpfSkpKTthdChcIm9uQWZ0ZXJVcGRhdGVcIixbWSx0XSl9LHNldENvbnRlbnQ6ZnVuY3Rpb24odCl7WS5zZXRQcm9wcyh7Y29udGVudDp0fSl9LHNob3c6ZnVuY3Rpb24oKXt2YXIgdD1ZLnN0YXRlLmlzVmlzaWJsZSxlPVkuc3RhdGUuaXNEZXN0cm95ZWQsbj0hWS5zdGF0ZS5pc0VuYWJsZWQscj1ULmlzVG91Y2gmJiFZLnByb3BzLnRvdWNoLGE9aShZLnByb3BzLmR1cmF0aW9uLDAsUi5kdXJhdGlvbik7aWYodHx8ZXx8bnx8cilyZXR1cm47aWYoZXQoKS5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSlyZXR1cm47aWYoYXQoXCJvblNob3dcIixbWV0sITEpLCExPT09WS5wcm9wcy5vblNob3coWSkpcmV0dXJuO1kuc3RhdGUuaXNWaXNpYmxlPSEwLHR0KCkmJigkLnN0eWxlLnZpc2liaWxpdHk9XCJ2aXNpYmxlXCIpO2l0KCksZHQoKSxZLnN0YXRlLmlzTW91bnRlZHx8KCQuc3R5bGUudHJhbnNpdGlvbj1cIm5vbmVcIik7aWYodHQoKSl7dmFyIHU9cnQoKSxwPXUuYm94LGM9dS5jb250ZW50O3coW3AsY10sMCl9TD1mdW5jdGlvbigpe3ZhciB0O2lmKFkuc3RhdGUuaXNWaXNpYmxlJiYhTil7aWYoTj0hMCwkLm9mZnNldEhlaWdodCwkLnN0eWxlLnRyYW5zaXRpb249WS5wcm9wcy5tb3ZlVHJhbnNpdGlvbix0dCgpJiZZLnByb3BzLmFuaW1hdGlvbil7dmFyIGU9cnQoKSxuPWUuYm94LHI9ZS5jb250ZW50O3coW24scl0sYSkseChbbixyXSxcInZpc2libGVcIil9c3QoKSx1dCgpLGYoXyxZKSxudWxsPT0odD1ZLnBvcHBlckluc3RhbmNlKXx8dC5mb3JjZVVwZGF0ZSgpLGF0KFwib25Nb3VudFwiLFtZXSksWS5wcm9wcy5hbmltYXRpb24mJnR0KCkmJmZ1bmN0aW9uKHQsZSl7bXQodCxlKX0oYSwoZnVuY3Rpb24oKXtZLnN0YXRlLmlzU2hvd249ITAsYXQoXCJvblNob3duXCIsW1ldKX0pKX19LGZ1bmN0aW9uKCl7dmFyIHQsZT1ZLnByb3BzLmFwcGVuZFRvLG49ZXQoKTt0PVkucHJvcHMuaW50ZXJhY3RpdmUmJmU9PT1vfHxcInBhcmVudFwiPT09ZT9uLnBhcmVudE5vZGU6cyhlLFtuXSk7dC5jb250YWlucygkKXx8dC5hcHBlbmRDaGlsZCgkKTtZLnN0YXRlLmlzTW91bnRlZD0hMCxDdCgpfSgpfSxoaWRlOmZ1bmN0aW9uKCl7dmFyIHQ9IVkuc3RhdGUuaXNWaXNpYmxlLGU9WS5zdGF0ZS5pc0Rlc3Ryb3llZCxuPSFZLnN0YXRlLmlzRW5hYmxlZCxyPWkoWS5wcm9wcy5kdXJhdGlvbiwxLFIuZHVyYXRpb24pO2lmKHR8fGV8fG4pcmV0dXJuO2lmKGF0KFwib25IaWRlXCIsW1ldLCExKSwhMT09PVkucHJvcHMub25IaWRlKFkpKXJldHVybjtZLnN0YXRlLmlzVmlzaWJsZT0hMSxZLnN0YXRlLmlzU2hvd249ITEsTj0hMSxWPSExLHR0KCkmJigkLnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIik7aWYocHQoKSx2dCgpLGl0KCEwKSx0dCgpKXt2YXIgbz1ydCgpLGE9by5ib3gscz1vLmNvbnRlbnQ7WS5wcm9wcy5hbmltYXRpb24mJih3KFthLHNdLHIpLHgoW2Esc10sXCJoaWRkZW5cIikpfXN0KCksdXQoKSxZLnByb3BzLmFuaW1hdGlvbj90dCgpJiZmdW5jdGlvbih0LGUpe210KHQsKGZ1bmN0aW9uKCl7IVkuc3RhdGUuaXNWaXNpYmxlJiYkLnBhcmVudE5vZGUmJiQucGFyZW50Tm9kZS5jb250YWlucygkKSYmZSgpfSkpfShyLFkudW5tb3VudCk6WS51bm1vdW50KCl9LGhpZGVXaXRoSW50ZXJhY3Rpdml0eTpmdW5jdGlvbih0KXtudCgpLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixGKSxmKFUsRiksRih0KX0sZW5hYmxlOmZ1bmN0aW9uKCl7WS5zdGF0ZS5pc0VuYWJsZWQ9ITB9LGRpc2FibGU6ZnVuY3Rpb24oKXtZLmhpZGUoKSxZLnN0YXRlLmlzRW5hYmxlZD0hMX0sdW5tb3VudDpmdW5jdGlvbigpe1kuc3RhdGUuaXNWaXNpYmxlJiZZLmhpZGUoKTtpZighWS5zdGF0ZS5pc01vdW50ZWQpcmV0dXJuO1R0KCksQXQoKS5mb3JFYWNoKChmdW5jdGlvbih0KXt0Ll90aXBweS51bm1vdW50KCl9KSksJC5wYXJlbnROb2RlJiYkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoJCk7Xz1fLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQhPT1ZfSkpLFkuc3RhdGUuaXNNb3VudGVkPSExLGF0KFwib25IaWRkZW5cIixbWV0pfSxkZXN0cm95OmZ1bmN0aW9uKCl7aWYoWS5zdGF0ZS5pc0Rlc3Ryb3llZClyZXR1cm47WS5jbGVhckRlbGF5VGltZW91dHMoKSxZLnVubW91bnQoKSxidCgpLGRlbGV0ZSBlLl90aXBweSxZLnN0YXRlLmlzRGVzdHJveWVkPSEwLGF0KFwib25EZXN0cm95XCIsW1ldKX19O2lmKCFQLnJlbmRlcilyZXR1cm4gWTt2YXIgcT1QLnJlbmRlcihZKSwkPXEucG9wcGVyLEo9cS5vblVwZGF0ZTskLnNldEF0dHJpYnV0ZShcImRhdGEtdGlwcHktcm9vdFwiLFwiXCIpLCQuaWQ9XCJ0aXBweS1cIitZLmlkLFkucG9wcGVyPSQsZS5fdGlwcHk9WSwkLl90aXBweT1ZO3ZhciBHPVgubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5mbihZKX0pKSxLPWUuaGFzQXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKTtyZXR1cm4gaHQoKSx1dCgpLGl0KCksYXQoXCJvbkNyZWF0ZVwiLFtZXSksUC5zaG93T25DcmVhdGUmJkx0KCksJC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLChmdW5jdGlvbigpe1kucHJvcHMuaW50ZXJhY3RpdmUmJlkuc3RhdGUuaXNWaXNpYmxlJiZZLmNsZWFyRGVsYXlUaW1lb3V0cygpfSkpLCQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwoZnVuY3Rpb24oKXtZLnByb3BzLmludGVyYWN0aXZlJiZZLnByb3BzLnRyaWdnZXIuaW5kZXhPZihcIm1vdXNlZW50ZXJcIik+PTAmJm50KCkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLEYpfSkpLFk7ZnVuY3Rpb24gUSgpe3ZhciB0PVkucHJvcHMudG91Y2g7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dDpbdCwwXX1mdW5jdGlvbiBaKCl7cmV0dXJuXCJob2xkXCI9PT1RKClbMF19ZnVuY3Rpb24gdHQoKXt2YXIgdDtyZXR1cm4hKG51bGw9PSh0PVkucHJvcHMucmVuZGVyKXx8IXQuJCR0aXBweSl9ZnVuY3Rpb24gZXQoKXtyZXR1cm4gRHx8ZX1mdW5jdGlvbiBudCgpe3ZhciB0PWV0KCkucGFyZW50Tm9kZTtyZXR1cm4gdD9FKHQpOmRvY3VtZW50fWZ1bmN0aW9uIHJ0KCl7cmV0dXJuIEIoJCl9ZnVuY3Rpb24gb3QodCl7cmV0dXJuIFkuc3RhdGUuaXNNb3VudGVkJiYhWS5zdGF0ZS5pc1Zpc2libGV8fFQuaXNUb3VjaHx8eSYmXCJmb2N1c1wiPT09eS50eXBlPzA6aShZLnByb3BzLmRlbGF5LHQ/MDoxLFIuZGVsYXkpfWZ1bmN0aW9uIGl0KHQpe3ZvaWQgMD09PXQmJih0PSExKSwkLnN0eWxlLnBvaW50ZXJFdmVudHM9WS5wcm9wcy5pbnRlcmFjdGl2ZSYmIXQ/XCJcIjpcIm5vbmVcIiwkLnN0eWxlLnpJbmRleD1cIlwiK1kucHJvcHMuekluZGV4fWZ1bmN0aW9uIGF0KHQsZSxuKXt2YXIgcjsodm9pZCAwPT09biYmKG49ITApLEcuZm9yRWFjaCgoZnVuY3Rpb24obil7blt0XSYmblt0XS5hcHBseShuLGUpfSkpLG4pJiYocj1ZLnByb3BzKVt0XS5hcHBseShyLGUpfWZ1bmN0aW9uIHN0KCl7dmFyIHQ9WS5wcm9wcy5hcmlhO2lmKHQuY29udGVudCl7dmFyIG49XCJhcmlhLVwiK3QuY29udGVudCxyPSQuaWQ7YyhZLnByb3BzLnRyaWdnZXJUYXJnZXR8fGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0QXR0cmlidXRlKG4pO2lmKFkuc3RhdGUuaXNWaXNpYmxlKXQuc2V0QXR0cmlidXRlKG4sZT9lK1wiIFwiK3I6cik7ZWxzZXt2YXIgbz1lJiZlLnJlcGxhY2UocixcIlwiKS50cmltKCk7bz90LnNldEF0dHJpYnV0ZShuLG8pOnQucmVtb3ZlQXR0cmlidXRlKG4pfX0pKX19ZnVuY3Rpb24gdXQoKXshSyYmWS5wcm9wcy5hcmlhLmV4cGFuZGVkJiZjKFkucHJvcHMudHJpZ2dlclRhcmdldHx8ZSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7WS5wcm9wcy5pbnRlcmFjdGl2ZT90LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIixZLnN0YXRlLmlzVmlzaWJsZSYmdD09PWV0KCk/XCJ0cnVlXCI6XCJmYWxzZVwiKTp0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIil9KSl9ZnVuY3Rpb24gcHQoKXtudCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixGKSxVPVUuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdCE9PUZ9KSl9ZnVuY3Rpb24gY3QodCl7aWYoIVQuaXNUb3VjaHx8IVMmJlwibW91c2Vkb3duXCIhPT10LnR5cGUpe3ZhciBuPXQuY29tcG9zZWRQYXRoJiZ0LmNvbXBvc2VkUGF0aCgpWzBdfHx0LnRhcmdldDtpZighWS5wcm9wcy5pbnRlcmFjdGl2ZXx8IUMoJCxuKSl7aWYoYyhZLnByb3BzLnRyaWdnZXJUYXJnZXR8fGUpLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBDKHQsbil9KSkpe2lmKFQuaXNUb3VjaClyZXR1cm47aWYoWS5zdGF0ZS5pc1Zpc2libGUmJlkucHJvcHMudHJpZ2dlci5pbmRleE9mKFwiY2xpY2tcIik+PTApcmV0dXJufWVsc2UgYXQoXCJvbkNsaWNrT3V0c2lkZVwiLFtZLHRdKTshMD09PVkucHJvcHMuaGlkZU9uQ2xpY2smJihZLmNsZWFyRGVsYXlUaW1lb3V0cygpLFkuaGlkZSgpLEk9ITAsc2V0VGltZW91dCgoZnVuY3Rpb24oKXtJPSExfSkpLFkuc3RhdGUuaXNNb3VudGVkfHx2dCgpKX19fWZ1bmN0aW9uIGZ0KCl7Uz0hMH1mdW5jdGlvbiBsdCgpe1M9ITF9ZnVuY3Rpb24gZHQoKXt2YXIgdD1udCgpO3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGN0LCEwKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLGN0LHIpLHQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIixsdCxyKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIixmdCxyKX1mdW5jdGlvbiB2dCgpe3ZhciB0PW50KCk7dC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsY3QsITApLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsY3QsciksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLGx0LHIpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLGZ0LHIpfWZ1bmN0aW9uIG10KHQsZSl7dmFyIG49cnQoKS5ib3g7ZnVuY3Rpb24gcih0KXt0LnRhcmdldD09PW4mJihPKG4sXCJyZW1vdmVcIixyKSxlKCkpfWlmKDA9PT10KXJldHVybiBlKCk7TyhuLFwicmVtb3ZlXCIsQSksTyhuLFwiYWRkXCIsciksQT1yfWZ1bmN0aW9uIGd0KHQsbixyKXt2b2lkIDA9PT1yJiYocj0hMSksYyhZLnByb3BzLnRyaWdnZXJUYXJnZXR8fGUpLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UuYWRkRXZlbnRMaXN0ZW5lcih0LG4sciksei5wdXNoKHtub2RlOmUsZXZlbnRUeXBlOnQsaGFuZGxlcjpuLG9wdGlvbnM6cn0pfSkpfWZ1bmN0aW9uIGh0KCl7dmFyIHQ7WigpJiYoZ3QoXCJ0b3VjaHN0YXJ0XCIseXQse3Bhc3NpdmU6ITB9KSxndChcInRvdWNoZW5kXCIseHQse3Bhc3NpdmU6ITB9KSksKHQ9WS5wcm9wcy50cmlnZ2VyLHQuc3BsaXQoL1xccysvKS5maWx0ZXIoQm9vbGVhbikpLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKFwibWFudWFsXCIhPT10KXN3aXRjaChndCh0LHl0KSx0KXtjYXNlXCJtb3VzZWVudGVyXCI6Z3QoXCJtb3VzZWxlYXZlXCIseHQpO2JyZWFrO2Nhc2VcImZvY3VzXCI6Z3Qobj9cImZvY3Vzb3V0XCI6XCJibHVyXCIsRXQpO2JyZWFrO2Nhc2VcImZvY3VzaW5cIjpndChcImZvY3Vzb3V0XCIsRXQpfX0pKX1mdW5jdGlvbiBidCgpe3ouZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9dC5ub2RlLG49dC5ldmVudFR5cGUscj10LmhhbmRsZXIsbz10Lm9wdGlvbnM7ZS5yZW1vdmVFdmVudExpc3RlbmVyKG4scixvKX0pKSx6PVtdfWZ1bmN0aW9uIHl0KHQpe3ZhciBlLG49ITE7aWYoWS5zdGF0ZS5pc0VuYWJsZWQmJiFPdCh0KSYmIUkpe3ZhciByPVwiZm9jdXNcIj09PShudWxsPT0oZT15KT92b2lkIDA6ZS50eXBlKTt5PXQsRD10LmN1cnJlbnRUYXJnZXQsdXQoKSwhWS5zdGF0ZS5pc1Zpc2libGUmJmgodCkmJlUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUodCl9KSksXCJjbGlja1wiPT09dC50eXBlJiYoWS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoXCJtb3VzZWVudGVyXCIpPDB8fFYpJiYhMSE9PVkucHJvcHMuaGlkZU9uQ2xpY2smJlkuc3RhdGUuaXNWaXNpYmxlP249ITA6THQodCksXCJjbGlja1wiPT09dC50eXBlJiYoVj0hbiksbiYmIXImJkR0KHQpfX1mdW5jdGlvbiB3dCh0KXt2YXIgZT10LnRhcmdldCxuPWV0KCkuY29udGFpbnMoZSl8fCQuY29udGFpbnMoZSk7XCJtb3VzZW1vdmVcIj09PXQudHlwZSYmbnx8ZnVuY3Rpb24odCxlKXt2YXIgbj1lLmNsaWVudFgscj1lLmNsaWVudFk7cmV0dXJuIHQuZXZlcnkoKGZ1bmN0aW9uKHQpe3ZhciBlPXQucG9wcGVyUmVjdCxvPXQucG9wcGVyU3RhdGUsaT10LnByb3BzLmludGVyYWN0aXZlQm9yZGVyLGE9bChvLnBsYWNlbWVudCkscz1vLm1vZGlmaWVyc0RhdGEub2Zmc2V0O2lmKCFzKXJldHVybiEwO3ZhciB1PVwiYm90dG9tXCI9PT1hP3MudG9wLnk6MCxwPVwidG9wXCI9PT1hP3MuYm90dG9tLnk6MCxjPVwicmlnaHRcIj09PWE/cy5sZWZ0Lng6MCxmPVwibGVmdFwiPT09YT9zLnJpZ2h0Lng6MCxkPWUudG9wLXIrdT5pLHY9ci1lLmJvdHRvbS1wPmksbT1lLmxlZnQtbitjPmksZz1uLWUucmlnaHQtZj5pO3JldHVybiBkfHx2fHxtfHxnfSkpfShBdCgpLmNvbmNhdCgkKS5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBlLG49bnVsbD09KGU9dC5fdGlwcHkucG9wcGVySW5zdGFuY2UpP3ZvaWQgMDplLnN0YXRlO3JldHVybiBuP3twb3BwZXJSZWN0OnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkscG9wcGVyU3RhdGU6bixwcm9wczpQfTpudWxsfSkpLmZpbHRlcihCb29sZWFuKSx0KSYmKHB0KCksRHQodCkpfWZ1bmN0aW9uIHh0KHQpe090KHQpfHxZLnByb3BzLnRyaWdnZXIuaW5kZXhPZihcImNsaWNrXCIpPj0wJiZWfHwoWS5wcm9wcy5pbnRlcmFjdGl2ZT9ZLmhpZGVXaXRoSW50ZXJhY3Rpdml0eSh0KTpEdCh0KSl9ZnVuY3Rpb24gRXQodCl7WS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoXCJmb2N1c2luXCIpPDAmJnQudGFyZ2V0IT09ZXQoKXx8WS5wcm9wcy5pbnRlcmFjdGl2ZSYmdC5yZWxhdGVkVGFyZ2V0JiYkLmNvbnRhaW5zKHQucmVsYXRlZFRhcmdldCl8fER0KHQpfWZ1bmN0aW9uIE90KHQpe3JldHVybiEhVC5pc1RvdWNoJiZaKCkhPT10LnR5cGUuaW5kZXhPZihcInRvdWNoXCIpPj0wfWZ1bmN0aW9uIEN0KCl7VHQoKTt2YXIgbj1ZLnByb3BzLHI9bi5wb3BwZXJPcHRpb25zLG89bi5wbGFjZW1lbnQsaT1uLm9mZnNldCxhPW4uZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCxzPW4ubW92ZVRyYW5zaXRpb24sdT10dCgpP0IoJCkuYXJyb3c6bnVsbCxwPWE/e2dldEJvdW5kaW5nQ2xpZW50UmVjdDphLGNvbnRleHRFbGVtZW50OmEuY29udGV4dEVsZW1lbnR8fGV0KCl9OmUsYz1be25hbWU6XCJvZmZzZXRcIixvcHRpb25zOntvZmZzZXQ6aX19LHtuYW1lOlwicHJldmVudE92ZXJmbG93XCIsb3B0aW9uczp7cGFkZGluZzp7dG9wOjIsYm90dG9tOjIsbGVmdDo1LHJpZ2h0OjV9fX0se25hbWU6XCJmbGlwXCIsb3B0aW9uczp7cGFkZGluZzo1fX0se25hbWU6XCJjb21wdXRlU3R5bGVzXCIsb3B0aW9uczp7YWRhcHRpdmU6IXN9fSx7bmFtZTpcIiQkdGlwcHlcIixlbmFibGVkOiEwLHBoYXNlOlwiYmVmb3JlV3JpdGVcIixyZXF1aXJlczpbXCJjb21wdXRlU3R5bGVzXCJdLGZuOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGU7aWYodHQoKSl7dmFyIG49cnQoKS5ib3g7W1wicGxhY2VtZW50XCIsXCJyZWZlcmVuY2UtaGlkZGVuXCIsXCJlc2NhcGVkXCJdLmZvckVhY2goKGZ1bmN0aW9uKHQpe1wicGxhY2VtZW50XCI9PT10P24uc2V0QXR0cmlidXRlKFwiZGF0YS1wbGFjZW1lbnRcIixlLnBsYWNlbWVudCk6ZS5hdHRyaWJ1dGVzLnBvcHBlcltcImRhdGEtcG9wcGVyLVwiK3RdP24uc2V0QXR0cmlidXRlKFwiZGF0YS1cIit0LFwiXCIpOm4ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1cIit0KX0pKSxlLmF0dHJpYnV0ZXMucG9wcGVyPXt9fX19XTt0dCgpJiZ1JiZjLnB1c2goe25hbWU6XCJhcnJvd1wiLG9wdGlvbnM6e2VsZW1lbnQ6dSxwYWRkaW5nOjN9fSksYy5wdXNoLmFwcGx5KGMsKG51bGw9PXI/dm9pZCAwOnIubW9kaWZpZXJzKXx8W10pLFkucG9wcGVySW5zdGFuY2U9dC5jcmVhdGVQb3BwZXIocCwkLE9iamVjdC5hc3NpZ24oe30scix7cGxhY2VtZW50Om8sb25GaXJzdFVwZGF0ZTpMLG1vZGlmaWVyczpjfSkpfWZ1bmN0aW9uIFR0KCl7WS5wb3BwZXJJbnN0YW5jZSYmKFkucG9wcGVySW5zdGFuY2UuZGVzdHJveSgpLFkucG9wcGVySW5zdGFuY2U9bnVsbCl9ZnVuY3Rpb24gQXQoKXtyZXR1cm4gZCgkLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS10aXBweS1yb290XVwiKSl9ZnVuY3Rpb24gTHQodCl7WS5jbGVhckRlbGF5VGltZW91dHMoKSx0JiZhdChcIm9uVHJpZ2dlclwiLFtZLHRdKSxkdCgpO3ZhciBlPW90KCEwKSxuPVEoKSxyPW5bMF0sbz1uWzFdO1QuaXNUb3VjaCYmXCJob2xkXCI9PT1yJiZvJiYoZT1vKSxlP3A9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtZLnNob3coKX0pLGUpOlkuc2hvdygpfWZ1bmN0aW9uIER0KHQpe2lmKFkuY2xlYXJEZWxheVRpbWVvdXRzKCksYXQoXCJvblVudHJpZ2dlclwiLFtZLHRdKSxZLnN0YXRlLmlzVmlzaWJsZSl7aWYoIShZLnByb3BzLnRyaWdnZXIuaW5kZXhPZihcIm1vdXNlZW50ZXJcIik+PTAmJlkucHJvcHMudHJpZ2dlci5pbmRleE9mKFwiY2xpY2tcIik+PTAmJltcIm1vdXNlbGVhdmVcIixcIm1vdXNlbW92ZVwiXS5pbmRleE9mKHQudHlwZSk+PTAmJlYpKXt2YXIgZT1vdCghMSk7ZT9nPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7WS5zdGF0ZS5pc1Zpc2libGUmJlkuaGlkZSgpfSksZSk6Yj1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKGZ1bmN0aW9uKCl7WS5oaWRlKCl9KSl9fWVsc2UgdnQoKX19ZnVuY3Rpb24gRih0LGUpe3ZvaWQgMD09PWUmJihlPXt9KTt2YXIgbj1SLnBsdWdpbnMuY29uY2F0KGUucGx1Z2luc3x8W10pO2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsTCxyKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIixrKTt2YXIgbz1PYmplY3QuYXNzaWduKHt9LGUse3BsdWdpbnM6bn0pLGk9eSh0KS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZSYmeihlLG8pO3JldHVybiBuJiZ0LnB1c2gobiksdH0pLFtdKTtyZXR1cm4gZyh0KT9pWzBdOml9Ri5kZWZhdWx0UHJvcHM9UixGLnNldERlZmF1bHRQcm9wcz1mdW5jdGlvbih0KXtPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChmdW5jdGlvbihlKXtSW2VdPXRbZV19KSl9LEYuY3VycmVudElucHV0PVQ7dmFyIFc9T2JqZWN0LmFzc2lnbih7fSx0LmFwcGx5U3R5bGVzLHtlZmZlY3Q6ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0ZSxuPXtwb3BwZXI6e3Bvc2l0aW9uOmUub3B0aW9ucy5zdHJhdGVneSxsZWZ0OlwiMFwiLHRvcDpcIjBcIixtYXJnaW46XCIwXCJ9LGFycm93Ontwb3NpdGlvbjpcImFic29sdXRlXCJ9LHJlZmVyZW5jZTp7fX07T2JqZWN0LmFzc2lnbihlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSxuLnBvcHBlciksZS5zdHlsZXM9bixlLmVsZW1lbnRzLmFycm93JiZPYmplY3QuYXNzaWduKGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsbi5hcnJvdyl9fSksWD17bW91c2VvdmVyOlwibW91c2VlbnRlclwiLGZvY3VzaW46XCJmb2N1c1wiLGNsaWNrOlwiY2xpY2tcIn07dmFyIFk9e25hbWU6XCJhbmltYXRlRmlsbFwiLGRlZmF1bHRWYWx1ZTohMSxmbjpmdW5jdGlvbih0KXt2YXIgZTtpZihudWxsPT0oZT10LnByb3BzLnJlbmRlcil8fCFlLiQkdGlwcHkpcmV0dXJue307dmFyIG49Qih0LnBvcHBlcikscj1uLmJveCxvPW4uY29udGVudCxpPXQucHJvcHMuYW5pbWF0ZUZpbGw/ZnVuY3Rpb24oKXt2YXIgdD1tKCk7cmV0dXJuIHQuY2xhc3NOYW1lPVwidGlwcHktYmFja2Ryb3BcIix4KFt0XSxcImhpZGRlblwiKSx0fSgpOm51bGw7cmV0dXJue29uQ3JlYXRlOmZ1bmN0aW9uKCl7aSYmKHIuaW5zZXJ0QmVmb3JlKGksci5maXJzdEVsZW1lbnRDaGlsZCksci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFuaW1hdGVmaWxsXCIsXCJcIiksci5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwiLHQuc2V0UHJvcHMoe2Fycm93OiExLGFuaW1hdGlvbjpcInNoaWZ0LWF3YXlcIn0pKX0sb25Nb3VudDpmdW5jdGlvbigpe2lmKGkpe3ZhciB0PXIuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uLGU9TnVtYmVyKHQucmVwbGFjZShcIm1zXCIsXCJcIikpO28uc3R5bGUudHJhbnNpdGlvbkRlbGF5PU1hdGgucm91bmQoZS8xMCkrXCJtc1wiLGkuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uPXQseChbaV0sXCJ2aXNpYmxlXCIpfX0sb25TaG93OmZ1bmN0aW9uKCl7aSYmKGkuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uPVwiMG1zXCIpfSxvbkhpZGU6ZnVuY3Rpb24oKXtpJiZ4KFtpXSxcImhpZGRlblwiKX19fX07dmFyIHE9e2NsaWVudFg6MCxjbGllbnRZOjB9LCQ9W107ZnVuY3Rpb24gSih0KXt2YXIgZT10LmNsaWVudFgsbj10LmNsaWVudFk7cT17Y2xpZW50WDplLGNsaWVudFk6bn19dmFyIEc9e25hbWU6XCJmb2xsb3dDdXJzb3JcIixkZWZhdWx0VmFsdWU6ITEsZm46ZnVuY3Rpb24odCl7dmFyIGU9dC5yZWZlcmVuY2Usbj1FKHQucHJvcHMudHJpZ2dlclRhcmdldHx8ZSkscj0hMSxvPSExLGk9ITAsYT10LnByb3BzO2Z1bmN0aW9uIHMoKXtyZXR1cm5cImluaXRpYWxcIj09PXQucHJvcHMuZm9sbG93Q3Vyc29yJiZ0LnN0YXRlLmlzVmlzaWJsZX1mdW5jdGlvbiB1KCl7bi5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsZil9ZnVuY3Rpb24gcCgpe24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLGYpfWZ1bmN0aW9uIGMoKXtyPSEwLHQuc2V0UHJvcHMoe2dldFJlZmVyZW5jZUNsaWVudFJlY3Q6bnVsbH0pLHI9ITF9ZnVuY3Rpb24gZihuKXt2YXIgcj0hbi50YXJnZXR8fGUuY29udGFpbnMobi50YXJnZXQpLG89dC5wcm9wcy5mb2xsb3dDdXJzb3IsaT1uLmNsaWVudFgsYT1uLmNsaWVudFkscz1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHU9aS1zLmxlZnQscD1hLXMudG9wOyFyJiZ0LnByb3BzLmludGVyYWN0aXZlfHx0LnNldFByb3BzKHtnZXRSZWZlcmVuY2VDbGllbnRSZWN0OmZ1bmN0aW9uKCl7dmFyIHQ9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxuPWkscj1hO1wiaW5pdGlhbFwiPT09byYmKG49dC5sZWZ0K3Uscj10LnRvcCtwKTt2YXIgcz1cImhvcml6b250YWxcIj09PW8/dC50b3A6cixjPVwidmVydGljYWxcIj09PW8/dC5yaWdodDpuLGY9XCJob3Jpem9udGFsXCI9PT1vP3QuYm90dG9tOnIsbD1cInZlcnRpY2FsXCI9PT1vP3QubGVmdDpuO3JldHVybnt3aWR0aDpjLWwsaGVpZ2h0OmYtcyx0b3A6cyxyaWdodDpjLGJvdHRvbTpmLGxlZnQ6bH19fSl9ZnVuY3Rpb24gbCgpe3QucHJvcHMuZm9sbG93Q3Vyc29yJiYoJC5wdXNoKHtpbnN0YW5jZTp0LGRvYzpufSksZnVuY3Rpb24odCl7dC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsSil9KG4pKX1mdW5jdGlvbiBkKCl7MD09PSgkPSQuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZS5pbnN0YW5jZSE9PXR9KSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQuZG9jPT09bn0pKS5sZW5ndGgmJmZ1bmN0aW9uKHQpe3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLEopfShuKX1yZXR1cm57b25DcmVhdGU6bCxvbkRlc3Ryb3k6ZCxvbkJlZm9yZVVwZGF0ZTpmdW5jdGlvbigpe2E9dC5wcm9wc30sb25BZnRlclVwZGF0ZTpmdW5jdGlvbihlLG4pe3ZhciBpPW4uZm9sbG93Q3Vyc29yO3J8fHZvaWQgMCE9PWkmJmEuZm9sbG93Q3Vyc29yIT09aSYmKGQoKSxpPyhsKCksIXQuc3RhdGUuaXNNb3VudGVkfHxvfHxzKCl8fHUoKSk6KHAoKSxjKCkpKX0sb25Nb3VudDpmdW5jdGlvbigpe3QucHJvcHMuZm9sbG93Q3Vyc29yJiYhbyYmKGkmJihmKHEpLGk9ITEpLHMoKXx8dSgpKX0sb25UcmlnZ2VyOmZ1bmN0aW9uKHQsZSl7aChlKSYmKHE9e2NsaWVudFg6ZS5jbGllbnRYLGNsaWVudFk6ZS5jbGllbnRZfSksbz1cImZvY3VzXCI9PT1lLnR5cGV9LG9uSGlkZGVuOmZ1bmN0aW9uKCl7dC5wcm9wcy5mb2xsb3dDdXJzb3ImJihjKCkscCgpLGk9ITApfX19fTt2YXIgSz17bmFtZTpcImlubGluZVBvc2l0aW9uaW5nXCIsZGVmYXVsdFZhbHVlOiExLGZuOmZ1bmN0aW9uKHQpe3ZhciBlLG49dC5yZWZlcmVuY2U7dmFyIHI9LTEsbz0hMSxpPVtdLGE9e25hbWU6XCJ0aXBweUlubGluZVBvc2l0aW9uaW5nXCIsZW5hYmxlZDohMCxwaGFzZTpcImFmdGVyV3JpdGVcIixmbjpmdW5jdGlvbihvKXt2YXIgYT1vLnN0YXRlO3QucHJvcHMuaW5saW5lUG9zaXRpb25pbmcmJigtMSE9PWkuaW5kZXhPZihhLnBsYWNlbWVudCkmJihpPVtdKSxlIT09YS5wbGFjZW1lbnQmJi0xPT09aS5pbmRleE9mKGEucGxhY2VtZW50KSYmKGkucHVzaChhLnBsYWNlbWVudCksdC5zZXRQcm9wcyh7Z2V0UmVmZXJlbmNlQ2xpZW50UmVjdDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7aWYobi5sZW5ndGg8Mnx8bnVsbD09PXQpcmV0dXJuIGU7aWYoMj09PW4ubGVuZ3RoJiZyPj0wJiZuWzBdLmxlZnQ+blsxXS5yaWdodClyZXR1cm4gbltyXXx8ZTtzd2l0Y2godCl7Y2FzZVwidG9wXCI6Y2FzZVwiYm90dG9tXCI6dmFyIG89blswXSxpPW5bbi5sZW5ndGgtMV0sYT1cInRvcFwiPT09dCxzPW8udG9wLHU9aS5ib3R0b20scD1hP28ubGVmdDppLmxlZnQsYz1hP28ucmlnaHQ6aS5yaWdodDtyZXR1cm57dG9wOnMsYm90dG9tOnUsbGVmdDpwLHJpZ2h0OmMsd2lkdGg6Yy1wLGhlaWdodDp1LXN9O2Nhc2VcImxlZnRcIjpjYXNlXCJyaWdodFwiOnZhciBmPU1hdGgubWluLmFwcGx5KE1hdGgsbi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmxlZnR9KSkpLGw9TWF0aC5tYXguYXBwbHkoTWF0aCxuLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQucmlnaHR9KSkpLGQ9bi5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVyblwibGVmdFwiPT09dD9lLmxlZnQ9PT1mOmUucmlnaHQ9PT1sfSkpLHY9ZFswXS50b3AsbT1kW2QubGVuZ3RoLTFdLmJvdHRvbTtyZXR1cm57dG9wOnYsYm90dG9tOm0sbGVmdDpmLHJpZ2h0Omwsd2lkdGg6bC1mLGhlaWdodDptLXZ9O2RlZmF1bHQ6cmV0dXJuIGV9fShsKHQpLG4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksZChuLmdldENsaWVudFJlY3RzKCkpLHIpfShhLnBsYWNlbWVudCl9fSkpLGU9YS5wbGFjZW1lbnQpfX07ZnVuY3Rpb24gcygpe3ZhciBlO298fChlPWZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJue3BvcHBlck9wdGlvbnM6T2JqZWN0LmFzc2lnbih7fSx0LnBvcHBlck9wdGlvbnMse21vZGlmaWVyczpbXS5jb25jYXQoKChudWxsPT0obj10LnBvcHBlck9wdGlvbnMpP3ZvaWQgMDpuLm1vZGlmaWVycyl8fFtdKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWUhPT1lLm5hbWV9KSksW2VdKX0pfX0odC5wcm9wcyxhKSxvPSEwLHQuc2V0UHJvcHMoZSksbz0hMSl9cmV0dXJue29uQ3JlYXRlOnMsb25BZnRlclVwZGF0ZTpzLG9uVHJpZ2dlcjpmdW5jdGlvbihlLG4pe2lmKGgobikpe3ZhciBvPWQodC5yZWZlcmVuY2UuZ2V0Q2xpZW50UmVjdHMoKSksaT1vLmZpbmQoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmxlZnQtMjw9bi5jbGllbnRYJiZ0LnJpZ2h0KzI+PW4uY2xpZW50WCYmdC50b3AtMjw9bi5jbGllbnRZJiZ0LmJvdHRvbSsyPj1uLmNsaWVudFl9KSksYT1vLmluZGV4T2YoaSk7cj1hPi0xP2E6cn19LG9uSGlkZGVuOmZ1bmN0aW9uKCl7cj0tMX19fX07dmFyIFE9e25hbWU6XCJzdGlja3lcIixkZWZhdWx0VmFsdWU6ITEsZm46ZnVuY3Rpb24odCl7dmFyIGU9dC5yZWZlcmVuY2Usbj10LnBvcHBlcjtmdW5jdGlvbiByKGUpe3JldHVybiEwPT09dC5wcm9wcy5zdGlja3l8fHQucHJvcHMuc3RpY2t5PT09ZX12YXIgbz1udWxsLGk9bnVsbDtmdW5jdGlvbiBhKCl7dmFyIHM9cihcInJlZmVyZW5jZVwiKT8odC5wb3BwZXJJbnN0YW5jZT90LnBvcHBlckluc3RhbmNlLnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZTplKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTpudWxsLHU9cihcInBvcHBlclwiKT9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOm51bGw7KHMmJloobyxzKXx8dSYmWihpLHUpKSYmdC5wb3BwZXJJbnN0YW5jZSYmdC5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKSxvPXMsaT11LHQuc3RhdGUuaXNNb3VudGVkJiZyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYSl9cmV0dXJue29uTW91bnQ6ZnVuY3Rpb24oKXt0LnByb3BzLnN0aWNreSYmYSgpfX19fTtmdW5jdGlvbiBaKHQsZSl7cmV0dXJuIXR8fCFlfHwodC50b3AhPT1lLnRvcHx8dC5yaWdodCE9PWUucmlnaHR8fHQuYm90dG9tIT09ZS5ib3R0b218fHQubGVmdCE9PWUubGVmdCl9cmV0dXJuIGUmJmZ1bmN0aW9uKHQpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtlLnRleHRDb250ZW50PXQsZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRpcHB5LXN0eWxlc2hlZXRcIixcIlwiKTt2YXIgbj1kb2N1bWVudC5oZWFkLHI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImhlYWQ+c3R5bGUsaGVhZD5saW5rXCIpO3I/bi5pbnNlcnRCZWZvcmUoZSxyKTpuLmFwcGVuZENoaWxkKGUpfSgnLnRpcHB5LWJveFtkYXRhLWFuaW1hdGlvbj1mYWRlXVtkYXRhLXN0YXRlPWhpZGRlbl17b3BhY2l0eTowfVtkYXRhLXRpcHB5LXJvb3Rde21heC13aWR0aDpjYWxjKDEwMHZ3IC0gMTBweCl9LnRpcHB5LWJveHtwb3NpdGlvbjpyZWxhdGl2ZTtiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7Y29sb3I6I2ZmZjtib3JkZXItcmFkaXVzOjRweDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoxLjQ7d2hpdGUtc3BhY2U6bm9ybWFsO291dGxpbmU6MDt0cmFuc2l0aW9uLXByb3BlcnR5OnRyYW5zZm9ybSx2aXNpYmlsaXR5LG9wYWNpdHl9LnRpcHB5LWJveFtkYXRhLXBsYWNlbWVudF49dG9wXT4udGlwcHktYXJyb3d7Ym90dG9tOjB9LnRpcHB5LWJveFtkYXRhLXBsYWNlbWVudF49dG9wXT4udGlwcHktYXJyb3c6YmVmb3Jle2JvdHRvbTotN3B4O2xlZnQ6MDtib3JkZXItd2lkdGg6OHB4IDhweCAwO2JvcmRlci10b3AtY29sb3I6aW5pdGlhbDt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciB0b3B9LnRpcHB5LWJveFtkYXRhLXBsYWNlbWVudF49Ym90dG9tXT4udGlwcHktYXJyb3d7dG9wOjB9LnRpcHB5LWJveFtkYXRhLXBsYWNlbWVudF49Ym90dG9tXT4udGlwcHktYXJyb3c6YmVmb3Jle3RvcDotN3B4O2xlZnQ6MDtib3JkZXItd2lkdGg6MCA4cHggOHB4O2JvcmRlci1ib3R0b20tY29sb3I6aW5pdGlhbDt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciBib3R0b219LnRpcHB5LWJveFtkYXRhLXBsYWNlbWVudF49bGVmdF0+LnRpcHB5LWFycm93e3JpZ2h0OjB9LnRpcHB5LWJveFtkYXRhLXBsYWNlbWVudF49bGVmdF0+LnRpcHB5LWFycm93OmJlZm9yZXtib3JkZXItd2lkdGg6OHB4IDAgOHB4IDhweDtib3JkZXItbGVmdC1jb2xvcjppbml0aWFsO3JpZ2h0Oi03cHg7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgbGVmdH0udGlwcHktYm94W2RhdGEtcGxhY2VtZW50Xj1yaWdodF0+LnRpcHB5LWFycm93e2xlZnQ6MH0udGlwcHktYm94W2RhdGEtcGxhY2VtZW50Xj1yaWdodF0+LnRpcHB5LWFycm93OmJlZm9yZXtsZWZ0Oi03cHg7Ym9yZGVyLXdpZHRoOjhweCA4cHggOHB4IDA7Ym9yZGVyLXJpZ2h0LWNvbG9yOmluaXRpYWw7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgcmlnaHR9LnRpcHB5LWJveFtkYXRhLWluZXJ0aWFdW2RhdGEtc3RhdGU9dmlzaWJsZV17dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC41NCwxLjUsLjM4LDEuMTEpfS50aXBweS1hcnJvd3t3aWR0aDoxNnB4O2hlaWdodDoxNnB4O2NvbG9yOiMzMzN9LnRpcHB5LWFycm93OmJlZm9yZXtjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1zdHlsZTpzb2xpZH0udGlwcHktY29udGVudHtwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjVweCA5cHg7ei1pbmRleDoxfScpLEYuc2V0RGVmYXVsdFByb3BzKHtwbHVnaW5zOltZLEcsSyxRXSxyZW5kZXI6Tn0pLEYuY3JlYXRlU2luZ2xldG9uPWZ1bmN0aW9uKHQsZSl7dmFyIG47dm9pZCAwPT09ZSYmKGU9e30pO3ZhciByLG89dCxpPVtdLGE9W10scz1lLm92ZXJyaWRlcyx1PVtdLGY9ITE7ZnVuY3Rpb24gbCgpe2E9by5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBjKHQucHJvcHMudHJpZ2dlclRhcmdldHx8dC5yZWZlcmVuY2UpfSkpLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jb25jYXQoZSl9KSxbXSl9ZnVuY3Rpb24gZCgpe2k9by5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlZmVyZW5jZX0pKX1mdW5jdGlvbiB2KHQpe28uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dD9lLmVuYWJsZSgpOmUuZGlzYWJsZSgpfSkpfWZ1bmN0aW9uIGcodCl7cmV0dXJuIG8ubWFwKChmdW5jdGlvbihlKXt2YXIgbj1lLnNldFByb3BzO3JldHVybiBlLnNldFByb3BzPWZ1bmN0aW9uKG8pe24obyksZS5yZWZlcmVuY2U9PT1yJiZ0LnNldFByb3BzKG8pfSxmdW5jdGlvbigpe2Uuc2V0UHJvcHM9bn19KSl9ZnVuY3Rpb24gaCh0LGUpe3ZhciBuPWEuaW5kZXhPZihlKTtpZihlIT09cil7cj1lO3ZhciB1PShzfHxbXSkuY29uY2F0KFwiY29udGVudFwiKS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbZV09b1tuXS5wcm9wc1tlXSx0fSkse30pO3Quc2V0UHJvcHMoT2JqZWN0LmFzc2lnbih7fSx1LHtnZXRSZWZlcmVuY2VDbGllbnRSZWN0OlwiZnVuY3Rpb25cIj09dHlwZW9mIHUuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdD91LmdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gbnVsbD09KHQ9aVtuXSk/dm9pZCAwOnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCl9fSkpfX12KCExKSxkKCksbCgpO3ZhciBiPXtmbjpmdW5jdGlvbigpe3JldHVybntvbkRlc3Ryb3k6ZnVuY3Rpb24oKXt2KCEwKX0sb25IaWRkZW46ZnVuY3Rpb24oKXtyPW51bGx9LG9uQ2xpY2tPdXRzaWRlOmZ1bmN0aW9uKHQpe3QucHJvcHMuc2hvd09uQ3JlYXRlJiYhZiYmKGY9ITAscj1udWxsKX0sb25TaG93OmZ1bmN0aW9uKHQpe3QucHJvcHMuc2hvd09uQ3JlYXRlJiYhZiYmKGY9ITAsaCh0LGlbMF0pKX0sb25UcmlnZ2VyOmZ1bmN0aW9uKHQsZSl7aCh0LGUuY3VycmVudFRhcmdldCl9fX19LHk9RihtKCksT2JqZWN0LmFzc2lnbih7fSxwKGUsW1wib3ZlcnJpZGVzXCJdKSx7cGx1Z2luczpbYl0uY29uY2F0KGUucGx1Z2luc3x8W10pLHRyaWdnZXJUYXJnZXQ6YSxwb3BwZXJPcHRpb25zOk9iamVjdC5hc3NpZ24oe30sZS5wb3BwZXJPcHRpb25zLHttb2RpZmllcnM6W10uY29uY2F0KChudWxsPT0obj1lLnBvcHBlck9wdGlvbnMpP3ZvaWQgMDpuLm1vZGlmaWVycyl8fFtdLFtXXSl9KX0pKSx3PXkuc2hvdzt5LnNob3c9ZnVuY3Rpb24odCl7aWYodygpLCFyJiZudWxsPT10KXJldHVybiBoKHksaVswXSk7aWYoIXJ8fG51bGwhPXQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXJldHVybiBpW3RdJiZoKHksaVt0XSk7aWYoby5pbmRleE9mKHQpPj0wKXt2YXIgZT10LnJlZmVyZW5jZTtyZXR1cm4gaCh5LGUpfXJldHVybiBpLmluZGV4T2YodCk+PTA/aCh5LHQpOnZvaWQgMH19LHkuc2hvd05leHQ9ZnVuY3Rpb24oKXt2YXIgdD1pWzBdO2lmKCFyKXJldHVybiB5LnNob3coMCk7dmFyIGU9aS5pbmRleE9mKHIpO3kuc2hvdyhpW2UrMV18fHQpfSx5LnNob3dQcmV2aW91cz1mdW5jdGlvbigpe3ZhciB0PWlbaS5sZW5ndGgtMV07aWYoIXIpcmV0dXJuIHkuc2hvdyh0KTt2YXIgZT1pLmluZGV4T2Yociksbj1pW2UtMV18fHQ7eS5zaG93KG4pfTt2YXIgeD15LnNldFByb3BzO3JldHVybiB5LnNldFByb3BzPWZ1bmN0aW9uKHQpe3M9dC5vdmVycmlkZXN8fHMseCh0KX0seS5zZXRJbnN0YW5jZXM9ZnVuY3Rpb24odCl7dighMCksdS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdCgpfSkpLG89dCx2KCExKSxkKCksbCgpLHU9Zyh5KSx5LnNldFByb3BzKHt0cmlnZ2VyVGFyZ2V0OmF9KX0sdT1nKHkpLHl9LEYuZGVsZWdhdGU9ZnVuY3Rpb24odCxlKXt2YXIgbj1bXSxvPVtdLGk9ITEsYT1lLnRhcmdldCxzPXAoZSxbXCJ0YXJnZXRcIl0pLHU9T2JqZWN0LmFzc2lnbih7fSxzLHt0cmlnZ2VyOlwibWFudWFsXCIsdG91Y2g6ITF9KSxmPU9iamVjdC5hc3NpZ24oe3RvdWNoOlIudG91Y2h9LHMse3Nob3dPbkNyZWF0ZTohMH0pLGw9Rih0LHUpO2Z1bmN0aW9uIGQodCl7aWYodC50YXJnZXQmJiFpKXt2YXIgbj10LnRhcmdldC5jbG9zZXN0KGEpO2lmKG4pe3ZhciByPW4uZ2V0QXR0cmlidXRlKFwiZGF0YS10aXBweS10cmlnZ2VyXCIpfHxlLnRyaWdnZXJ8fFIudHJpZ2dlcjtpZighbi5fdGlwcHkmJiEoXCJ0b3VjaHN0YXJ0XCI9PT10LnR5cGUmJlwiYm9vbGVhblwiPT10eXBlb2YgZi50b3VjaHx8XCJ0b3VjaHN0YXJ0XCIhPT10LnR5cGUmJnIuaW5kZXhPZihYW3QudHlwZV0pPDApKXt2YXIgcz1GKG4sZik7cyYmKG89by5jb25jYXQocykpfX19fWZ1bmN0aW9uIHYodCxlLHIsbyl7dm9pZCAwPT09byYmKG89ITEpLHQuYWRkRXZlbnRMaXN0ZW5lcihlLHIsbyksbi5wdXNoKHtub2RlOnQsZXZlbnRUeXBlOmUsaGFuZGxlcjpyLG9wdGlvbnM6b30pfXJldHVybiBjKGwpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPXQuZGVzdHJveSxhPXQuZW5hYmxlLHM9dC5kaXNhYmxlO3QuZGVzdHJveT1mdW5jdGlvbih0KXt2b2lkIDA9PT10JiYodD0hMCksdCYmby5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmRlc3Ryb3koKX0pKSxvPVtdLG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9dC5ub2RlLG49dC5ldmVudFR5cGUscj10LmhhbmRsZXIsbz10Lm9wdGlvbnM7ZS5yZW1vdmVFdmVudExpc3RlbmVyKG4scixvKX0pKSxuPVtdLGUoKX0sdC5lbmFibGU9ZnVuY3Rpb24oKXthKCksby5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdC5lbmFibGUoKX0pKSxpPSExfSx0LmRpc2FibGU9ZnVuY3Rpb24oKXtzKCksby5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kaXNhYmxlKCl9KSksaT0hMH0sZnVuY3Rpb24odCl7dmFyIGU9dC5yZWZlcmVuY2U7dihlLFwidG91Y2hzdGFydFwiLGQsciksdihlLFwibW91c2VvdmVyXCIsZCksdihlLFwiZm9jdXNpblwiLGQpLHYoZSxcImNsaWNrXCIsZCl9KHQpfSkpLGx9LEYuaGlkZUFsbD1mdW5jdGlvbih0KXt2YXIgZT12b2lkIDA9PT10P3t9OnQsbj1lLmV4Y2x1ZGUscj1lLmR1cmF0aW9uO18uZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9ITE7aWYobiYmKGU9YihuKT90LnJlZmVyZW5jZT09PW46dC5wb3BwZXI9PT1uLnBvcHBlciksIWUpe3ZhciBvPXQucHJvcHMuZHVyYXRpb247dC5zZXRQcm9wcyh7ZHVyYXRpb246cn0pLHQuaGlkZSgpLHQuc3RhdGUuaXNEZXN0cm95ZWR8fHQuc2V0UHJvcHMoe2R1cmF0aW9uOm99KX19KSl9LEYucm91bmRBcnJvdz0nPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTAgNnMxLjc5Ni0uMDEzIDQuNjctMy42MTVDNS44NTEuOSA2LjkzLjAwNiA4IDBjMS4wNy0uMDA2IDIuMTQ4Ljg4NyAzLjM0MyAyLjM4NUMxNC4yMzMgNi4wMDUgMTYgNiAxNiA2SDB6XCI+PC9zdmc+JyxGfSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlwcHktYnVuZGxlLnVtZC5taW4uanMubWFwIiwiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZmFjdG9yeSgpKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICB9IGVsc2Uge1xuICAgIChmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgLy8gVG8gbWFrZSBzdXJlIFplbnNjcm9sbCBjYW4gYmUgcmVmZXJlbmNlZCBmcm9tIHRoZSBoZWFkZXIsIGJlZm9yZSBgYm9keWAgaXMgYXZhaWxhYmxlXG4gICAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICByb290LnplbnNjcm9sbCA9IGZhY3RvcnkoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmV0cnkgOW1zIGxhdGVyXG4gICAgICAgIHNldFRpbWVvdXQoaW5zdGFsbCwgOSlcbiAgICAgIH1cbiAgICB9KSgpXG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICBcInVzZSBzdHJpY3RcIlxuXG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBicm93c2VyIGFscmVhZHkgc3VwcG9ydHMgbmF0aXZlIHNtb290aCBzY3JvbGxpbmcgKGUuZy4sIEZpcmVmb3ggMzYrIGFuZCBDaHJvbWUgNDkrKSBhbmQgaXQgaXMgZW5hYmxlZDpcbiAgdmFyIGlzTmF0aXZlU21vb3RoU2Nyb2xsRW5hYmxlZE9uID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbSAmJiBcImdldENvbXB1dGVkU3R5bGVcIiBpbiB3aW5kb3cgJiZcbiAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pW1wic2Nyb2xsLWJlaGF2aW9yXCJdID09PSBcInNtb290aFwiXG4gIH1cblxuXG4gIC8vIEV4aXQgaWYgaXTigJlzIG5vdCBhIGJyb3dzZXIgZW52aXJvbm1lbnQ6XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICEoXCJkb2N1bWVudFwiIGluIHdpbmRvdykpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuXG5cbiAgdmFyIG1ha2VTY3JvbGxlciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGRlZmF1bHREdXJhdGlvbiwgZWRnZU9mZnNldCkge1xuXG4gICAgLy8gVXNlIGRlZmF1bHRzIGlmIG5vdCBwcm92aWRlZFxuICAgIGRlZmF1bHREdXJhdGlvbiA9IGRlZmF1bHREdXJhdGlvbiB8fCA5OTkgLy9tc1xuICAgIGlmICghZWRnZU9mZnNldCAmJiBlZGdlT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAvLyBXaGVuIHNjcm9sbGluZywgdGhpcyBhbW91bnQgb2YgZGlzdGFuY2UgaXMga2VwdCBmcm9tIHRoZSBlZGdlcyBvZiB0aGUgY29udGFpbmVyOlxuICAgICAgZWRnZU9mZnNldCA9IDkgLy9weFxuICAgIH1cblxuICAgIC8vIEhhbmRsaW5nIHRoZSBsaWZlLWN5Y2xlIG9mIHRoZSBzY3JvbGxlclxuICAgIHZhciBzY3JvbGxUaW1lb3V0SWRcbiAgICB2YXIgc2V0U2Nyb2xsVGltZW91dElkID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICBzY3JvbGxUaW1lb3V0SWQgPSBuZXdWYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGN1cnJlbnQgc21vb3RoIHNjcm9sbCBvcGVyYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgKi9cbiAgICB2YXIgc3RvcFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFyVGltZW91dChzY3JvbGxUaW1lb3V0SWQpXG4gICAgICBzZXRTY3JvbGxUaW1lb3V0SWQoMClcbiAgICB9XG5cbiAgICB2YXIgZ2V0VG9wV2l0aEVkZ2VPZmZzZXQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGNvbnRhaW5lci5nZXRUb3BPZihlbGVtKSAtIGVkZ2VPZmZzZXQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyB0byBhIHNwZWNpZmljIHZlcnRpY2FsIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dGFyZ2V0WX0gVGhlIHZlcnRpY2FsIHBvc2l0aW9uIHdpdGhpbiB0aGUgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIHtkdXJhdGlvbn0gT3B0aW9uYWxseSB0aGUgZHVyYXRpb24gb2YgdGhlIHNjcm9sbCBvcGVyYXRpb24uXG4gICAgICogICAgICAgIElmIG5vdCBwcm92aWRlZCB0aGUgZGVmYXVsdCBkdXJhdGlvbiBpcyB1c2VkLlxuICAgICAqIEBwYXJhbSB7b25Eb25lfSBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIG9uY2UgdGhlIHNjcm9sbCBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICB2YXIgc2Nyb2xsVG9ZID0gZnVuY3Rpb24gKHRhcmdldFksIGR1cmF0aW9uLCBvbkRvbmUpIHtcbiAgICAgIHN0b3BTY3JvbGwoKVxuICAgICAgaWYgKGR1cmF0aW9uID09PSAwIHx8IChkdXJhdGlvbiAmJiBkdXJhdGlvbiA8IDApIHx8IGlzTmF0aXZlU21vb3RoU2Nyb2xsRW5hYmxlZE9uKGNvbnRhaW5lci5ib2R5KSkge1xuICAgICAgICBjb250YWluZXIudG9ZKHRhcmdldFkpXG4gICAgICAgIGlmIChvbkRvbmUpIHtcbiAgICAgICAgICBvbkRvbmUoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RhcnRZID0gY29udGFpbmVyLmdldFkoKVxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1heCgwLCB0YXJnZXRZKSAtIHN0YXJ0WVxuICAgICAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCBNYXRoLm1pbihNYXRoLmFicyhkaXN0YW5jZSksIGRlZmF1bHREdXJhdGlvbik7XG4gICAgICAgIChmdW5jdGlvbiBsb29wU2Nyb2xsKCkge1xuICAgICAgICAgIHNldFNjcm9sbFRpbWVvdXRJZChzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlOlxuICAgICAgICAgICAgdmFyIHAgPSBNYXRoLm1pbigxLCAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUpIC8gZHVyYXRpb24pXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGFic29sdXRlIHZlcnRpY2FsIHBvc2l0aW9uOlxuICAgICAgICAgICAgdmFyIHkgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHN0YXJ0WSArIGRpc3RhbmNlICogKHAgPCAwLjUgPyAyICogcCAqIHAgOiBwICogKDQgLSBwICogMikgLSAxKSkpXG4gICAgICAgICAgICBjb250YWluZXIudG9ZKHkpXG4gICAgICAgICAgICBpZiAocCA8IDEgJiYgKGNvbnRhaW5lci5nZXRIZWlnaHQoKSArIHkpIDwgY29udGFpbmVyLmJvZHkuc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGxvb3BTY3JvbGwoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChzdG9wU2Nyb2xsLCA5OSkgLy8gd2l0aCBjb29sZG93biB0aW1lXG4gICAgICAgICAgICAgIGlmIChvbkRvbmUpIHtcbiAgICAgICAgICAgICAgICBvbkRvbmUoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgOSkpXG4gICAgICAgIH0pKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIHRvIHRoZSB0b3Agb2YgYSBzcGVjaWZpYyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtlbGVtfSBUaGUgZWxlbWVudCB0byBzY3JvbGwgdG8uXG4gICAgICogQHBhcmFtIHtkdXJhdGlvbn0gT3B0aW9uYWxseSB0aGUgZHVyYXRpb24gb2YgdGhlIHNjcm9sbCBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtvbkRvbmV9IEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb25jZSB0aGUgc2Nyb2xsIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIHZhciBzY3JvbGxUb0VsZW0gPSBmdW5jdGlvbiAoZWxlbSwgZHVyYXRpb24sIG9uRG9uZSkge1xuICAgICAgc2Nyb2xsVG9ZKGdldFRvcFdpdGhFZGdlT2Zmc2V0KGVsZW0pLCBkdXJhdGlvbiwgb25Eb25lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgYW4gZWxlbWVudCBpbnRvIHZpZXcgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtlbGVtfSBUaGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge2R1cmF0aW9ufSBPcHRpb25hbGx5IHRoZSBkdXJhdGlvbiBvZiB0aGUgc2Nyb2xsIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge29uRG9uZX0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBvbmNlIHRoZSBzY3JvbGwgZmluaXNoZWQuXG4gICAgICovXG4gICAgdmFyIHNjcm9sbEludG9WaWV3ID0gZnVuY3Rpb24gKGVsZW0sIGR1cmF0aW9uLCBvbkRvbmUpIHtcbiAgICAgIHZhciBlbGVtSGVpZ2h0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgIHZhciBlbGVtQm90dG9tID0gY29udGFpbmVyLmdldFRvcE9mKGVsZW0pICsgZWxlbUhlaWdodFxuICAgICAgdmFyIGNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lci5nZXRIZWlnaHQoKVxuICAgICAgdmFyIHkgPSBjb250YWluZXIuZ2V0WSgpXG4gICAgICB2YXIgY29udGFpbmVyQm90dG9tID0geSArIGNvbnRhaW5lckhlaWdodFxuICAgICAgaWYgKGdldFRvcFdpdGhFZGdlT2Zmc2V0KGVsZW0pIDwgeSB8fCAoZWxlbUhlaWdodCArIGVkZ2VPZmZzZXQpID4gY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgIC8vIEVsZW1lbnQgaXMgY2xpcHBlZCBhdCB0b3Agb3IgaXMgaGlnaGVyIHRoYW4gc2NyZWVuLlxuICAgICAgICBzY3JvbGxUb0VsZW0oZWxlbSwgZHVyYXRpb24sIG9uRG9uZSlcbiAgICAgIH0gZWxzZSBpZiAoKGVsZW1Cb3R0b20gKyBlZGdlT2Zmc2V0KSA+IGNvbnRhaW5lckJvdHRvbSkge1xuICAgICAgICAvLyBFbGVtZW50IGlzIGNsaXBwZWQgYXQgdGhlIGJvdHRvbS5cbiAgICAgICAgc2Nyb2xsVG9ZKGVsZW1Cb3R0b20gLSBjb250YWluZXJIZWlnaHQgKyBlZGdlT2Zmc2V0LCBkdXJhdGlvbiwgb25Eb25lKVxuICAgICAgfSBlbHNlIGlmIChvbkRvbmUpIHtcbiAgICAgICAgb25Eb25lKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIHRvIHRoZSBjZW50ZXIgb2YgYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZWxlbX0gVGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtkdXJhdGlvbn0gT3B0aW9uYWxseSB0aGUgZHVyYXRpb24gb2YgdGhlIHNjcm9sbCBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtvZmZzZXR9IE9wdGlvbmFsbHkgdGhlIG9mZnNldCBvZiB0aGUgdG9wIG9mIHRoZSBlbGVtZW50IGZyb20gdGhlIGNlbnRlciBvZiB0aGUgc2NyZWVuLlxuICAgICAqICAgICAgICBBIHZhbHVlIG9mIDAgaXMgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0ge29uRG9uZX0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBvbmNlIHRoZSBzY3JvbGwgZmluaXNoZWQuXG4gICAgICovXG4gICAgdmFyIHNjcm9sbFRvQ2VudGVyT2YgPSBmdW5jdGlvbiAoZWxlbSwgZHVyYXRpb24sIG9mZnNldCwgb25Eb25lKSB7XG4gICAgICBzY3JvbGxUb1koTWF0aC5tYXgoMCwgY29udGFpbmVyLmdldFRvcE9mKGVsZW0pIC0gY29udGFpbmVyLmdldEhlaWdodCgpIC8gMiArIChvZmZzZXQgfHwgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgLyAyKSksIGR1cmF0aW9uLCBvbkRvbmUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBkZWZhdWx0IHNldHRpbmdzIGZvciB0aGlzIHNjcm9sbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtuZXdEZWZhdWx0RHVyYXRpb259IE9wdGlvbmFsbHkgYSBuZXcgdmFsdWUgZm9yIGRlZmF1bHQgZHVyYXRpb24sIHVzZWQgZm9yIGVhY2ggc2Nyb2xsIG1ldGhvZCBieSBkZWZhdWx0LlxuICAgICAqICAgICAgICBJZ25vcmVkIGlmIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgICAqIEBwYXJhbSB7bmV3RWRnZU9mZnNldH0gT3B0aW9uYWxseSBhIG5ldyB2YWx1ZSBmb3IgdGhlIGVkZ2Ugb2Zmc2V0LCB1c2VkIGJ5IGVhY2ggc2Nyb2xsIG1ldGhvZCBieSBkZWZhdWx0LiBJZ25vcmVkIGlmIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgc2V0dXAgPSBmdW5jdGlvbiAobmV3RGVmYXVsdER1cmF0aW9uLCBuZXdFZGdlT2Zmc2V0KSB7XG4gICAgICBpZiAobmV3RGVmYXVsdER1cmF0aW9uID09PSAwIHx8IG5ld0RlZmF1bHREdXJhdGlvbikge1xuICAgICAgICBkZWZhdWx0RHVyYXRpb24gPSBuZXdEZWZhdWx0RHVyYXRpb25cbiAgICAgIH1cbiAgICAgIGlmIChuZXdFZGdlT2Zmc2V0ID09PSAwIHx8IG5ld0VkZ2VPZmZzZXQpIHtcbiAgICAgICAgZWRnZU9mZnNldCA9IG5ld0VkZ2VPZmZzZXRcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZmF1bHREdXJhdGlvbjogZGVmYXVsdER1cmF0aW9uLFxuICAgICAgICBlZGdlT2Zmc2V0OiBlZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNldHVwOiBzZXR1cCxcbiAgICAgIHRvOiBzY3JvbGxUb0VsZW0sXG4gICAgICB0b1k6IHNjcm9sbFRvWSxcbiAgICAgIGludG9WaWV3OiBzY3JvbGxJbnRvVmlldyxcbiAgICAgIGNlbnRlcjogc2Nyb2xsVG9DZW50ZXJPZixcbiAgICAgIHN0b3A6IHN0b3BTY3JvbGwsXG4gICAgICBtb3Zpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhc2Nyb2xsVGltZW91dElkIH0sXG4gICAgICBnZXRZOiBjb250YWluZXIuZ2V0WSxcbiAgICAgIGdldFRvcE9mOiBjb250YWluZXIuZ2V0VG9wT2ZcbiAgICB9XG5cbiAgfVxuXG5cbiAgdmFyIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgdmFyIGdldERvY1kgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cuc2Nyb2xsWSB8fCBkb2NFbGVtLnNjcm9sbFRvcCB9XG5cbiAgLy8gQ3JlYXRlIGEgc2Nyb2xsZXIgZm9yIHRoZSBkb2N1bWVudDpcbiAgdmFyIHplbnNjcm9sbCA9IG1ha2VTY3JvbGxlcih7XG4gICAgYm9keTogZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LFxuICAgIHRvWTogZnVuY3Rpb24gKHkpIHsgd2luZG93LnNjcm9sbFRvKDAsIHkpIH0sXG4gICAgZ2V0WTogZ2V0RG9jWSxcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2NFbGVtLmNsaWVudEhlaWdodCB9LFxuICAgIGdldFRvcE9mOiBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBnZXREb2NZKCkgLSBkb2NFbGVtLm9mZnNldFRvcCB9XG4gIH0pXG5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNjcm9sbGVyIGZyb20gdGhlIHByb3ZpZGVkIGNvbnRhaW5lciBlbGVtZW50IChlLmcuLCBhIERJVilcbiAgICpcbiAgICogQHBhcmFtIHtzY3JvbGxDb250YWluZXJ9IFRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB3aXRoaW4gdGhlIGRvY3VtZW50LlxuICAgKiBAcGFyYW0ge2RlZmF1bHREdXJhdGlvbn0gT3B0aW9uYWxseSBhIHZhbHVlIGZvciBkZWZhdWx0IGR1cmF0aW9uLCB1c2VkIGZvciBlYWNoIHNjcm9sbCBtZXRob2QgYnkgZGVmYXVsdC5cbiAgICogICAgICAgIElnbm9yZWQgaWYgMCBvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHtlZGdlT2Zmc2V0fSBPcHRpb25hbGx5IGEgdmFsdWUgZm9yIHRoZSBlZGdlIG9mZnNldCwgdXNlZCBieSBlYWNoIHNjcm9sbCBtZXRob2QgYnkgZGVmYXVsdC4gXG4gICAqICAgICAgICBJZ25vcmVkIGlmIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgKiBAcmV0dXJucyBBIHNjcm9sbGVyIG9iamVjdCwgc2ltaWxhciB0byBgemVuc2Nyb2xsYCBidXQgY29udHJvbGxpbmcgdGhlIHByb3ZpZGVkIGVsZW1lbnQuXG4gICAqL1xuICB6ZW5zY3JvbGwuY3JlYXRlU2Nyb2xsZXIgPSBmdW5jdGlvbiAoc2Nyb2xsQ29udGFpbmVyLCBkZWZhdWx0RHVyYXRpb24sIGVkZ2VPZmZzZXQpIHtcbiAgICByZXR1cm4gbWFrZVNjcm9sbGVyKHtcbiAgICAgIGJvZHk6IHNjcm9sbENvbnRhaW5lcixcbiAgICAgIHRvWTogZnVuY3Rpb24gKHkpIHsgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCA9IHkgfSxcbiAgICAgIGdldFk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgfSxcbiAgICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0aC5taW4oc2Nyb2xsQ29udGFpbmVyLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY0VsZW0uY2xpZW50SGVpZ2h0KSB9LFxuICAgICAgZ2V0VG9wT2Y6IGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLm9mZnNldFRvcCB9XG4gICAgfSwgZGVmYXVsdER1cmF0aW9uLCBlZGdlT2Zmc2V0KVxuICB9XG5cblxuICAvLyBBdXRvbWF0aWMgbGluay1zbW9vdGhpbmcgb24gYWNob3JzXG4gIC8vIEV4Y2x1ZGUgSUU4LSBvciB3aGVuIG5hdGl2ZSBpcyBlbmFibGVkIG9yIFplbnNjcm9sbCBhdXRvLSBpcyBkaXNhYmxlZFxuICBpZiAoXCJhZGRFdmVudExpc3RlbmVyXCIgaW4gd2luZG93ICYmICF3aW5kb3cubm9aZW5zbW9vdGggJiYgIWlzTmF0aXZlU21vb3RoU2Nyb2xsRW5hYmxlZE9uKGRvY3VtZW50LmJvZHkpKSB7XG5cbiAgICB2YXIgaXNIaXN0b3J5U3VwcG9ydGVkID0gXCJoaXN0b3J5XCIgaW4gd2luZG93ICYmIFwicHVzaFN0YXRlXCIgaW4gaGlzdG9yeVxuICAgIHZhciBpc1Njcm9sbFJlc3RvcmF0aW9uU3VwcG9ydGVkID0gaXNIaXN0b3J5U3VwcG9ydGVkICYmIFwic2Nyb2xsUmVzdG9yYXRpb25cIiBpbiBoaXN0b3J5XG5cbiAgICAvLyBPbiBmaXJzdCBsb2FkICYgcmVmcmVzaCBtYWtlIHN1cmUgdGhlIGJyb3dzZXIgcmVzdG9yZXMgdGhlIHBvc2l0aW9uIGZpcnN0XG4gICAgaWYgKGlzU2Nyb2xsUmVzdG9yYXRpb25TdXBwb3J0ZWQpIHtcbiAgICAgIGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIlxuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIGlmIChpc1Njcm9sbFJlc3RvcmF0aW9uU3VwcG9ydGVkKSB7XG4gICAgICAgIC8vIFNldCBpdCB0byBtYW51YWxcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiIH0sIDkpXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LnN0YXRlICYmIFwiemVuc2Nyb2xsWVwiIGluIGV2ZW50LnN0YXRlKSB7XG4gICAgICAgICAgICB6ZW5zY3JvbGwudG9ZKGV2ZW50LnN0YXRlLnplbnNjcm9sbFkpXG4gICAgICAgICAgfVxuICAgICAgICB9LCBmYWxzZSlcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGVkZ2Ugb2Zmc2V0IG9uIGZpcnN0IGxvYWQgaWYgbmVjZXNzYXJ5XG4gICAgICAvLyBUaGlzIG1heSBub3Qgd29yayBvbiBJRSAob3Igb2xkZXIgY29tcHV0ZXI/KSBhcyBpdCByZXF1aXJlcyBtb3JlIHRpbWVvdXQsIGFyb3VuZCAxMDAgbXNcbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaGFzaCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBBZGp1c3RtZW50IGlzIG9ubHkgbmVlZGVkIGlmIHRoZXJlIGlzIGFuIGVkZ2Ugb2Zmc2V0OlxuICAgICAgICAgIHZhciBlZGdlT2Zmc2V0ID0gemVuc2Nyb2xsLnNldHVwKCkuZWRnZU9mZnNldFxuICAgICAgICAgIGlmIChlZGdlT2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KFwiI1wiKVsxXSlcbiAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtKSB7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXRZID0gTWF0aC5tYXgoMCwgemVuc2Nyb2xsLmdldFRvcE9mKHRhcmdldEVsZW0pIC0gZWRnZU9mZnNldClcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSB6ZW5zY3JvbGwuZ2V0WSgpIC0gdGFyZ2V0WVxuICAgICAgICAgICAgICAvLyBPbmx5IGRvIHRoZSBhZGp1c3RtZW50IGlmIHRoZSBicm93c2VyIGlzIHZlcnkgY2xvc2UgdG8gdGhlIGVsZW1lbnQ6XG4gICAgICAgICAgICAgIGlmICgwIDw9IGRpZmYgJiYgZGlmZiA8IDkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgdGFyZ2V0WSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgOSlcbiAgICAgIH1cblxuICAgIH0sIGZhbHNlKVxuXG4gICAgLy8gSGFuZGxpbmcgY2xpY2tzIG9uIGFuY2hvcnNcbiAgICB2YXIgUkVfbm9aZW5zbW9vdGggPSBuZXcgUmVnRXhwKFwiKF58XFxcXHMpbm9aZW5zbW9vdGgoXFxcXHN8JClcIilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGFuY2hvciA9IGV2ZW50LnRhcmdldFxuICAgICAgd2hpbGUgKGFuY2hvciAmJiBhbmNob3IudGFnTmFtZSAhPT0gXCJBXCIpIHtcbiAgICAgICAgYW5jaG9yID0gYW5jaG9yLnBhcmVudE5vZGVcbiAgICAgIH1cbiAgICAgIC8vIExldCB0aGUgYnJvd3NlciBoYW5kbGUgdGhlIGNsaWNrIGlmIGl0IHdhc24ndCB3aXRoIHRoZSBwcmltYXJ5IGJ1dHRvbiwgb3Igd2l0aCBzb21lIG1vZGlmaWVyIGtleXM6XG4gICAgICBpZiAoIWFuY2hvciB8fCBldmVudC53aGljaCAhPT0gMSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBzY3JvbGxpbmcgcG9zaXRpb24gc28gaXQgY2FuIGJlIHVzZWQgZm9yIHNjcm9sbCByZXN0b3JhdGlvbjpcbiAgICAgIGlmIChpc1Njcm9sbFJlc3RvcmF0aW9uU3VwcG9ydGVkKSB7XG4gICAgICAgIHZhciBoaXN0b3J5U3RhdGUgPSBoaXN0b3J5LnN0YXRlICYmIHR5cGVvZiBoaXN0b3J5LnN0YXRlID09PSBcIm9iamVjdFwiID8gaGlzdG9yeS5zdGF0ZSA6IHt9XG4gICAgICAgIGhpc3RvcnlTdGF0ZS56ZW5zY3JvbGxZID0gemVuc2Nyb2xsLmdldFkoKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIilcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIEF2b2lkIHRoZSBDaHJvbWUgU2VjdXJpdHkgZXhjZXB0aW9uIG9uIGZpbGUgcHJvdG9jb2wsIGUuZy4sIGZpbGU6Ly9pbmRleC5odG1sXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpbmQgdGhlIHJlZmVyZW5jZWQgSUQ6XG4gICAgICB2YXIgaHJlZiA9IGFuY2hvci5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpIHx8IFwiXCJcbiAgICAgIGlmIChocmVmLmluZGV4T2YoXCIjXCIpID09PSAwICYmICFSRV9ub1plbnNtb290aC50ZXN0KGFuY2hvci5jbGFzc05hbWUpKSB7XG4gICAgICAgIHZhciB0YXJnZXRZID0gMFxuICAgICAgICB2YXIgdGFyZ2V0RWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhyZWYuc3Vic3RyaW5nKDEpKVxuICAgICAgICBpZiAoaHJlZiAhPT0gXCIjXCIpIHtcbiAgICAgICAgICBpZiAoIXRhcmdldEVsZW0pIHtcbiAgICAgICAgICAgIC8vIExldCB0aGUgYnJvd3NlciBoYW5kbGUgdGhlIGNsaWNrIGlmIHRoZSB0YXJnZXQgSUQgaXMgbm90IGZvdW5kLlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldFkgPSB6ZW5zY3JvbGwuZ2V0VG9wT2YodGFyZ2V0RWxlbSlcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgdHJpZ2dlciB0aGUgYnJvd3NlcidzIGBoYXNoY2hhbmdlYCBldmVudC4uLlxuICAgICAgICB2YXIgb25Eb25lID0gZnVuY3Rpb24gKCkgeyB3aW5kb3cubG9jYXRpb24gPSBocmVmIH1cbiAgICAgICAgLy8gLi4udW5sZXNzIHRoZXJlIGlzIGFuIGVkZ2Ugb2Zmc2V0IHNwZWNpZmllZFxuICAgICAgICB2YXIgZWRnZU9mZnNldCA9IHplbnNjcm9sbC5zZXR1cCgpLmVkZ2VPZmZzZXRcbiAgICAgICAgaWYgKGVkZ2VPZmZzZXQpIHtcbiAgICAgICAgICB0YXJnZXRZID0gTWF0aC5tYXgoMCwgdGFyZ2V0WSAtIGVkZ2VPZmZzZXQpXG4gICAgICAgICAgaWYgKGlzSGlzdG9yeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgb25Eb25lID0gZnVuY3Rpb24gKCkgeyBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgXCJcIiwgaHJlZikgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB6ZW5zY3JvbGwudG9ZKHRhcmdldFksIG51bGwsIG9uRG9uZSlcbiAgICAgIH1cbiAgICB9LCBmYWxzZSlcblxuICB9XG5cblxuICByZXR1cm4gemVuc2Nyb2xsXG59KSk7Il19
